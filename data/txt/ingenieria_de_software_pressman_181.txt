150 PARTE DOS  MODELADO  1. La inteligencia del sistema debe estar distribuida entr e las clases para enfren- tar mejor las necesidades del problema.  Toda aplicación contiene cierto grado de  inteligencia, es decir, lo que el sistema sabe y lo que puede hacer. Esta inteligencia se  distribuye entre las clases de diferentes maneras. Las clases “tontas” (aquellas que tie-nen pocas responsabilidades) pueden modelarse para que actúen como subordinadas de ciertas clases “inteligentes” (las que tienen muchas responsabilidades). Aunque este enfoque hace directo el flujo del control en un sistema, tiene algunas desventajas: con- centra toda la inteligencia en pocas clases, lo que hace que sea más difícil hacer cam-bios, y tiende a que se requieran más clases y por ello más trabajo de desarrollo. Si la inteligencia del sistema tiene una distribución más pareja entre las clases de  una aplicación, cada objeto sabe algo, sólo hace unas cuantas cosas (que por lo general  están bien identificadas) y la cohesión del sistema mejora. 17 Esto facilita el manteni- miento del software y reduce el efecto de los resultados colaterales del cambio. Para determinar si la inteligencia del sistema está distribuida en forma apropiada,  deben evaluarse las responsabilidades anotadas en cada modelo de tarjeta CRC índice a fin de definir si alguna clase tiene una lista demasiado larga de responsabilidades. Esto indica una concentración de inteligencia. 18 Además, las responsabilidades de cada clase  deben tener el mismo nivel de abstracción. Por ejemplo, entre las operaciones enlista-das para una clase agregada llamada RevisarCuenta, un revisor anota dos responsabi-lidades: hacer el balance de la cuenta y eliminar comprobaciones concluidas. La primera  operación (responsabilidad) implica un procedimiento matemático complejo y lógico. La segunda es una simple actividad de oficina. Como estas dos operaciones no están en el mismo nivel de abstracción, eliminar comprobaciones concluidas debe colocarse den- tro de las responsabilidades de RevisarEntrada, clase que está incluida en la clase agregada RevisarCuenta.  2. Cada r esponsabilidad debe enunciarse del modo más general posible. Este li- neamiento implica que las responsabilidades generales (tanto atributos como operacio-nes) deben residir en un nivel elevado de la jerarquía de clases (porque son generales y se aplicarán a todas las subclases).  3. La inf ormación y el comportamiento relacionado con ella deben residir dentro  de la misma clase. Esto logra el principio orientado a objetos llamado encapsula- miento. Los datos y los procesos que los manipulan deben empacarse como una unidad cohesiva.  4. La inf ormación sobre una cosa debe localizarse con una sola clase, y no distri- buirse a través de muchas. Una sola clase debe tener la responsabilidad de almace-nar y manipular un tipo específico de información. En general, esta responsabilidad no debe ser compartida por varias clases. Si la información está distribuida, es más difícil dar mantenimiento al software y más complicado someterlo a prueba.  5. Cuando sea apr  opiado, las responsabilidades deben compartirse entre clases  relacionadas. Hay muchos casos en los que varios objetos relacionados deben tener el mismo comportamiento al mismo tiempo. Por ejemplo, considere un juego de video que deba tener en la pantalla las clases siguientes: Jugador, CuerpodelJugador, Brazos- delJugador, PiernasdelJugador y CabezadelJugador. Cada una de estas clases tiene sus propios atributos (como posición, orientación, color y velocidad) y todas deben actuali- zarse y desplegarse a medida que el usuario manipula una palanca de juego. Las res- 17 La cohesión es un concepto de diseño que se estudia en el capítulo 8. 18 En tales casos, puede ser necesario dividir la clase en una multiplicidad de ellas o completar subsistemas con el  objeto de distribuir la inteligencia de un modo más eficaz. 06Pressman(126-157).indd   15006Pressman(126-157).indd   150 14/1/10   14:29:2114/1/10   14:29:21