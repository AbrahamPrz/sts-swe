CommunicationsController  de la API del transmisor (que no controlábamos y estaba por definir). Al usar nuestra propia interfaz específica de la aplicación, el código de  CommunicationsController  era limpio y expresivo. Una vez definida la API del transmisor, creamos  TransmitterAdapter  para reducir las distancias. El adaptador [35]  encapsulaba la interacción con la API y ofrecía un único punto en el que evolucionaba. Figura 8.1. Predicción del transmisor Este diseño también nos ofrece un sello [36]  en el código para realizar pruebas. Con un elemento  FakeTransmitter , podemos probar las clases CommunicationsController . También podemos crear pruebas de límite una vez diseñada la API  Transmitter  para asegurarnos de que la utilizamos correctamente. Límites limpios En los límites suceden cosas interesantes. Los cambios es una de ellas. Los diseños de código correctos acomodan los cambios sin necesidad de grandes modificaciones. Cuando usamos código que no controlamos, hay que prestar especial atención a proteger nuestra inversión y asegurarnos de que los cambios futuros no son demasiado costosos. El código en los límites requiere una separación evidente y pruebas que definan expectativas. Debemos evitar que el código conozca los detalles de terceros. Es más aconsejable depender de algo que controlemos que de algo que no controlemos, y menos todavía si nos controla. Los límites de terceros se gestionan gracias a la presencia de 167