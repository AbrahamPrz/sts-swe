return plusDays(offsetToPreviousTarget); else return plusDays(offsetToFutureTarget); } El método  getEndOfCurrentMonth  (líneas  728-740)  es un tanto extraño ya que es un método de instancia que envidia [G14] a su propia clase aceptado un argumento  DayDate . Lo convierto en un verdadero método de instancia y clarifico algunos de los nombres. public DayDate getEndOfMonth() { Month month = getMonth(); int year = getYear(); int lastDay = lastDayOfMonth(month, year); return DayDateFactory.makeDate(lastDay, month, year); } La refactorización de  weekInMonthToString  (líneas  742-761)  resultó ser muy interesante. Mediante las herramientas de refactorización de mi IDE, primero cambié el método a la enumeración  WeekInMonth  creada antes y después cambié el nombre por  toString . Tras ello, lo convertí en método de instancia. Todas las pruebas fueron correctas (¿adivina hacia dónde nos dirigimos?). Seguidamente, eliminé el método. Fallaron cinco afirmaciones (líneas  411-415  del Listado  B-4).  Cambié estas líneas para usar los nombres de los enumeradores ( FIRST ,  SECOND , etc.). Las pruebas fueron correctas. ¿Ve por qué? ¿Puede ver también por qué son necesarios estos pasos? La herramienta de refactorización se encargó de que los invocadores anteriores de weekInMonthToString  invocaran ahora  toString  en el enumerador weekInMonth  ya que todos los enumeradores implementan  toString  para devolver sus nombres… Desafortunadamente, me pasé de listo. A pesar de la elegancia de la cadena de refactorización, comprobé que los únicos usuarios de esta función eran las pruebas que acababa de modificar, de modo que las eliminé. Así pues, tras determinar que sólo las pruebas invocaban  relativeToString (líneas  765-781),  eliminé directamente la función y sus pruebas. Hemos llegado a los métodos abstractos de esta clase abstracta. Y el primero es  toSerial  (líneas  838-844).  En un apartado anterior cambié el nombre por  toOrdinal . Al verlo en este contexto, decidí que el cambio de 354