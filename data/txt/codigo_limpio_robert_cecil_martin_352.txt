un lector de este código podría aceptar que adddays cambia el objeto date , de modo que necesitamos un nombre que acabe con la ambigüedad [n4]: plusdays y plusmonths . creo que la intención del método se captura correctamente por medio de daydate date = olddate.plusdays(5); mientras que el siguiente no transmite con fluidez al lector que el objeto date ha cambiado: date.plusdays(5); los algoritmos son cada vez más interesantes. getpreviousdayofweek (líneas 628-660) funciona pero es complicado. tras meditar en lo que sucedía [g21], pude simplificarlo y aplicar la explicación de variables temporales [g19] para aclarar su significado. también lo cambié de método estático a método de instancia [g18] y me deshice del método de instancia duplicado [g5] (líneas 997-1008). public daydate getpreviousdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index = getdayofweek().index; if (offsettotarget >= 0) offsettotarget - 7; return plusdays(offsettotarget); } sucede exactamente lo mismo con getfollowingdayofweek (líneas 662-693). public daydate getfollowingdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index - getdayofweek().index; if (offsettotarget <= 0) offsettotarget += 7; return plusdays(offsettotarget); } la siguiente función es getnearestdayofweek (líneas 695-726), que corregimos en un apartado anterior. pero esos cambios no son coherentes con el patrón actual de las dos últimas funciones [g11]. por ello, recurro a la explicación de variables temporales [g19] para aclarar el algoritmo. public daydate getnearestdayofweek(final day targetday) { int offsettothisweekstarget = targetday.index - getdayofweek().index; int offsettofuturetarget = (offsettothisweekstarget + 7) % 7; int offsettoprevioustarget = offsettofuturetarget - 7; if (offsettofuturetarget > 3) 353