Un lector de este código podría aceptar que  addDays  cambia el objeto date , de modo que necesitamos un nombre que acabe con la ambigüedad [N4]:  plusDays  y  plusMonths . Creo que la intención del método se captura correctamente por medio de DayDate date = oldDate.plusDays(5); mientras que el siguiente no transmite con fluidez al lector que el objeto date  ha cambiado: date.plusDays(5); Los algoritmos son cada vez más interesantes.  getPreviousDayOfWeek (líneas  628-660)  funciona pero es complicado. Tras meditar en lo que sucedía [G21], pude simplificarlo y aplicar la explicación de variables temporales [G19] para aclarar su significado. También lo cambié de método estático a método de instancia [G18] y me deshice del método de instancia duplicado [G5] (líneas  997-1008). public DayDate getPreviousDayOfWeek(Day targetDayOfWeek) { int offsetToTarget = targetDayOfWeek.index = getDayOfWeek().index; if (offsetToTarget >= 0) offsetToTarget - 7; return plusDays(offsetToTarget); } Sucede exactamente lo mismo con  getFollowingDayOfWeek  (líneas  662-693). public DayDate getFollowingDayOfWeek(Day targetDayOfWeek) { int offsetToTarget = targetDayOfWeek.index - getDayOfWeek().index; if (offsetToTarget <= 0) offsetToTarget += 7; return plusDays(offsetToTarget); } La siguiente función es  getNearestDayOfWeek  (líneas  695-726),  que corregimos en un apartado anterior. Pero esos cambios no son coherentes con el patrón actual de las dos últimas funciones [G11]. Por ello, recurro a la explicación de  variables temporales  [G19] para aclarar el algoritmo. public DayDate getNearestDayOfWeek(final Day targetDay) { int offsetToThisWeeksTarget = targetDay.index - getDayOfWeek().index; int offsetToFutureTarget = (offsetToThisWeeksTarget + 7) % 7; int offsetToPreviousTarget = offsetToFutureTarget - 7; if (offsetToFutureTarget > 3) 353