return stringValue == null ? “” : stringValue; } public void set Integer(int i) { integerValue = i; } public int getInteger() { return integerValue; } public abstract void set(String s); } Tras ello, implementé el método  set  en  BooleanArgumentMarshaller . private class BooleanArgumentMarshaler extends ArgumentMarshaler { public void set(String s) { booleanValue = true; } } Y por último cambié la invocación de  setBoolean  por la de  set . private void setBooleanArg(char argChar, boolean value) { booleanArgs.get(argChar). set(“true”) ; } Las pruebas seguían siendo satisfactorias. Como este cambio hacía que set  se implementara en  BooleanArgumentMarshaler , eliminé el método setBoolean  de la clase base  ArgumentMarshaler . La función abstracta  set  acepta un argumento  String  pero la implementación de  BooleanArgumentMarshaler  no lo usa. He incluido el argumento porque sabía que  StringArgumentMarshaler  e IntegerArgumentMarshaler  lo utilizarían. Tras ello, el objetivo era implementar el método  get  en BooleanArgumentMarshaler . La implementación de funciones get siempre es escabrosa ya que el tipo devuelto tiene que ser  Object  y en este caso debe convertirse a  Boolean . public boolean getBoolean(char arg) { Args.ArgumentMarshaler am = booleanArgs.get(arg); return am != null &&  (Boolean) am. get (); } Para compilarlo, añadí la función  get  a  ArgumentMarshaler . private abstract class ArgumentMarshaler { … 282