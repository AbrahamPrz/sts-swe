return stringvalue == null ? “” : stringvalue; } public void set integer(int i) { integervalue = i; } public int getinteger() { return integervalue; } public abstract void set(string s); } tras ello, implementé el método set en booleanargumentmarshaller . private class booleanargumentmarshaler extends argumentmarshaler { public void set(string s) { booleanvalue = true; } } y por último cambié la invocación de setboolean por la de set . private void setbooleanarg(char argchar, boolean value) { booleanargs.get(argchar). set(“true”) ; } las pruebas seguían siendo satisfactorias. como este cambio hacía que set se implementara en booleanargumentmarshaler , eliminé el método setboolean de la clase base argumentmarshaler . la función abstracta set acepta un argumento string pero la implementación de booleanargumentmarshaler no lo usa. he incluido el argumento porque sabía que stringargumentmarshaler e integerargumentmarshaler lo utilizarían. tras ello, el objetivo era implementar el método get en booleanargumentmarshaler . la implementación de funciones get siempre es escabrosa ya que el tipo devuelto tiene que ser object y en este caso debe convertirse a boolean . public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am != null && (boolean) am. get (); } para compilarlo, añadí la función get a argumentmarshaler . private abstract class argumentmarshaler { … 282