parameter = currentargument.next(); intvalue = integer.parseint (parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( numberformatexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } public object get() { return intvalue; } } también podemos convertir argumentmarshaler en una interfaz. private interface argumentmarshaler { void set (iterator<string> currentargument) throws argsexception; object get(); } veamos ahora lo sencillo que resulta añadir un nuevo tipo de argumento a la estructura. apenas necesitaremos cambios y los que apliquemos tendrán que ser aislados. en primer lugar, añadimos un nuevo caso de prueba para comprobar que el argumento double funciona correctamente: public void testsimpledoublepresent() throws exception { args args = new args(“x##”, new string[] {“-x”,“42.3”}); asserttrue(args.isvalid()); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42.3, args.getdouble(‘x’), .001); } limpiamos el código de análisis de esquemas y añadimos la detección ## para el tipo de argumento double . private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (elementtail. length() == 0 ) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail. equals(“*”) ) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail. equals(“#”) ) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); 304