parameter = currentArgument.next(); intValue = Integer.parseInt (parameter); } catch (NoSuchElementException e) { errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch ( NumberFormatException  e) { errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw new ArgsException(); } } public Object get() { return intValue; } } También podemos convertir  ArgumentMarshaler  en una interfaz. private  interface  ArgumentMarshaler { void set (Iterator<String> currentArgument) throws ArgsException; Object get(); } Veamos ahora lo sencillo que resulta añadir un nuevo tipo de argumento a la estructura. Apenas necesitaremos cambios y los que apliquemos tendrán que ser aislados. En primer lugar, añadimos un nuevo caso de prueba para comprobar que el argumento  double  funciona correctamente: public void testSimpleDoublePresent() throws Exception { Args args = new Args(“x##”, new String[] {“-x”,“42.3”}); assertTrue(args.isValid()); assertEquals(1, args.cardinality()); assertTrue(args.has(‘x’)); assertEquals(42.3, args.getDouble(‘x’), .001); } Limpiamos el código de análisis de esquemas y añadimos la detección  ## para el tipo de argumento  double . private void parseSchemaElement(String element) throws ParseException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (elementTail. length() == 0 ) marshalers.put(elementId, new BooleanArgumentMarshaler()); else if (elementTail. equals(“*”) ) marshalers.put(elementId, new StringArgumentMarshaler()); else if (elementTail. equals(“#”) ) marshalers.put(elementId, new IntegerArgumentMarshaler()); else if (elementTail.equals(“##”)) marshalers.put(elementId, new DoubleArgumentMarshaler()); 304