public Object get() { return null; } } Se compila y las pruebas fallan. Para que vuelvan a funcionar, basta con convertir  get  en abstracto e implementarlo en  BooleanArgumentMarshaler . private abstract class ArgumentMarshaler { protected boolean booleanValue = false; … public  abstract  Object get(); } private class BooleanArgumentMarshaler extends ArgumentMarshaler { public void set (String s) { booleanValue = true; } public Object get() { return booleanValue; } } De nuevo, las pruebas son satisfactorias. Ahora tanto  get  como  set  se implementan en  BooleanArgumentMarshaler . Esto me permite eliminar la antigua función  getBoolean  de  ArgumentMarshaler , cambiar la variable protegida  booleanValue  a  BooleanArgumentMarshaler  y convertirla en privada. Repetí el mismo patrón de cambios con las cadenas. Implementé  set  y get , eliminé las funciones sin usar y desplacé las variables. private void setStringArg(char argChar) throws ArgsException { currentArgument++; try { stringArgs.get(argChar). set (args[currentArgument]); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } … public String getString(char arg) { Args.ArgumentMarshaler am = stringArgs.get(arg); return am == null ? “” :  (String)  am. get (); } 283