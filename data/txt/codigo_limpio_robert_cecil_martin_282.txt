public object get() { return null; } } se compila y las pruebas fallan. para que vuelvan a funcionar, basta con convertir get en abstracto e implementarlo en booleanargumentmarshaler . private abstract class argumentmarshaler { protected boolean booleanvalue = false; … public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { public void set (string s) { booleanvalue = true; } public object get() { return booleanvalue; } } de nuevo, las pruebas son satisfactorias. ahora tanto get como set se implementan en booleanargumentmarshaler . esto me permite eliminar la antigua función getboolean de argumentmarshaler , cambiar la variable protegida booleanvalue a booleanargumentmarshaler y convertirla en privada. repetí el mismo patrón de cambios con las cadenas. implementé set y get , eliminé las funciones sin usar y desplacé las variables. private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.get(argchar). set (args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring(char arg) { args.argumentmarshaler am = stringargs.get(arg); return am == null ? “” : (string) am. get (); } 283