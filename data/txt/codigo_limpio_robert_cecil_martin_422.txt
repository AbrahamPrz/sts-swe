una agrupación de conexiones mq a un repositorio principal. imagine que hay dos operaciones en la aplicación: crear y actualizar: crear: adquirir una conexión al repositorio principal y la base de datos. comunicarse con el repositorio principal y después almacenar el trabajo local en la base de datos de procesos. actualizar: adquirir una conexión a la base de datos y después al repositorio principal. leer el trabajo de la base de datos y enviarlo al repositorio principal. ¿qué sucede con los usuarios que superan el tamaño de la agrupación? imagine que el tamaño de cada agrupación es 10 . 10 usuarios intentan usar crear, de modo que se adquieren diez conexiones de base de datos y cada subproceso se interrumpe después de esta adquisición pero antes de adquirir una conexión al repositorio principal. 10 usuarios intentan usar actualizar, de modo que se adquieren las diez conexiones al repositorio principal y cada subproceso se interrumpe después de adquirir el repositorio principal pero antes de adquirir una conexión a la base de datos. ahora los 10 subprocesos crear deben esperar a adquirir una conexión al repositorio principal pero los 10 subprocesos actualizar deben esperar a adquirir una conexión a la base de datos. bloqueo mutuo. el sistema no se recupera nunca. puede parecerle una situación improbable pero ¿quién desea un sistema que se colapsa cada semana? ¿quién quiere depurar un sistema con síntomas tan difíciles de reproducir? es el tipo de problema que tarda semanas en resolverse. una solución habitual consiste en añadir instrucciones de depuración para determinar qué sucede. evidentemente, estas instrucciones cambian tanto el código que el bloqueo mutuo se genera en otras situaciones y tarda meses en 423