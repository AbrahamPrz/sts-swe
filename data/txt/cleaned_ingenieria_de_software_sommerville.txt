ingeniería software, novena edición, dirige principalmente estudiantes universitarios que están inscritos cursos tanto introductorios como avanzados ingeniería software sistemas. asimismo, los ingenieros software que trabajan industria encon-trarán libro útil como lectura general para actualizar sus conocimientos acerca temas como reutilización software, diseño arquitectónico, confiabilidad, seguridad mejora procesos. presente obra actualizó incorporar los siguientes cambios: nuevos capítulos sobre software ágil sistemas embebidos. nuevo material sobre ingeniería dirigida por modelos, desarrollo fuente abierta desarrollo dirigido por pruebas, modelo queso suizo reason, arquitecturas sistemas confiables, análisis estático com - probación modelos, reutilización cots, software como servicio planeación ágil. nuevo estudio caso amplio alcance que detalla sistema registro pacientes. enfoque del presente texto centra temas fundamentales para todos los procesos desarrollo , particular, para desarrollo sistemas fiables. ingeniería software ingeniería software visítenos : una marca depara mayor información, consulte isbn ---- portada sommerville.indd // : pma-xvi .indd xvia-xvi .indd xvi // :: // :: pmingeniería software novena edición ian sommerville traducción: víctor campos olguíntraductor especialista sistemas computacionales revisión técnica: sergio fuenlabrada velázquezedna martha miranda chávezmiguel ángel torres duránmario alberto sesma martínezmario oviedo galdeanojosé luis lópez goytiaunidad profesional interdisciplinaria ingeniería ciencias sociales administrativas-instituto politécnico nacional, méxico darío guillermo cardacci universidad abierta interamericana, buenos aires, argentina marcelo martín marciszack universidad tecnológica nacional, córdoba, argentina addison-wesley -xvi .indd -xvi .indd // :: // :: pmauthorized translation from the english language edition, entitled software engineering, edition, ian sommerville published pearson education, inc., publishing addison-wesley, copyright © . all rights reserved. isbn traducción autorizada edición idioma inglés, titulada software engineering, edición por ian sommerville publicada por pearson education, inc., publicada como addison-wesley, copyright © . todos los derechos reservados. esta edición español única autorizada.edición español editor: luis . cruz castillo -mail: luis.cruz@pearson.com editor desarrollo: felipe hernández carrascosupervisor producción: juan josé garcía guzmán novena edición, .. © por pearson educación méxico, .. .. atlacomulco -. pisocol. industrial atoto, naucalpan juárez, estado méxico cámara nacional industria editorial mexicana. reg. núm. . addison-wesley una marca registrada pearson educación méxico, .. .. reservados todos los derechos. totalidad parte esta publicación pueden reproducirse, registrarse transmitirse, sistema recuperación información, ninguna forma por ningún medio, sea electrónico, mecánico, fotoquímico, magnético electroóptico, por fotocopia, grabación cualquier otro, sin permiso previo por escrito del editor. préstamo, alquiler cualquier otra forma cesión uso este ejemplar requerirá también autorización del editor sus representantes. isbn versión impresa: ---- isbn versión -book: ---- -chapter: ---- primera impresiónimpreso méxico. printed mexico. - datos catalogación bibliográfica sommerville, ian páginas: educación, méxico, isbn: ---- área: computación formato: . . cmingeniería software addison wesley una marca -xvi .indd iia-xvi .indd // :: // :: pmprefacio mientras escribía los capítulos finales este libro verano , cuenta que ingeniería software tenía años existencia. nombre “ingeniería software” propuso una conferencia organización del tratado del atlántico norte (otan) para analizar los problemas del desarrollo software; esa época había grandes sistemas software que estaban rezagados, que ofrecían fun-cionalidad que requerían los usuarios, que costaban más esperado que eran fiables. asistí dicha conferencia, pero año después escribí primer programa inicié vida profesional software. progreso ingeniería software sido notable durante vida profesional. actualidad, nuestras sociedades podrían funcionar sin grandes sistemas soft-ware profesionales. para construir sistemas empresariales existe una gran variedad tecnologías (, .net, saas, sap, bpel, soap, cbse, etcétera) que apoyan desarrollo implementación grandes aplicaciones empresariales. los servicios públicos infraestructura nacionales (energía, comunicaciones transporte) apoyan sistemas cómputo complejos fiables. software permitido exploración del espacio creación world wide web, sistema información más signi-ficativo historia humanidad. mundo ahora enfrenta nuevo conjunto desafíos: cambio climático temperaturas extremas, agotamiento los recursos natu-rales, una creciente población mundial que demanda alimentos vivienda, terrorismo internacional, necesidad ayudar los adultos mayores tener vidas satisfactorias plenas. necesitamos nuevas tecnologías para enfrentar todos esos problemas , desde luego, software desempeñará papel central dichas tecnologías. por tanto, ingeniería software una tecnología muy importante para futuro humanidad. debemos continuar educando los ingenieros software desarrollar disciplina manera que puedan crearse sistemas software más complejos. desde luego, aún existen problemas con los proyectos software. ocasiones, software todavía funciona con demoras más costoso esperado. sin embargo, debe permitirse que dichos problemas oculten los verdaderos éxitos ingeniería software, como tampoco los métodos tecnologías impresionantes que han desarrollado ese campo. ingeniería software ahora una especialidad tan vasta, que sería imposible cubrir toda materia libro. consecuencia, enfoque del presente texto centra los -xvi .indd iiia-xvi .indd iii // :: // :: pmiv prefacio temas clave para todos los procesos desarrollo , particular, para desarrollo sistemas fiables. hay creciente énfasis los métodos ágiles reutilización soft-ware. creo firmemente que los métodos ágiles tienen lugar, igual que ingeniería software dirigida por plan “tradicional”. necesario combinar mejor estos enfoques para construir mejores sistemas software. los libros inevitablemente reflejan las opiniones los prejuicios sus autores. probable que algunos lectores estén desacuerdo con mis opiniones con elección del material. tal desacuerdo sano reflejo diversidad disciplina esen-cial para evolución. obstante, espero que todos los ingenieros software los estudiantes esta materia puedan encontrar aquí material interés. integración con web existe una increíble cantidad información acerca ingeniería software disponi-ble web, tanta, que algunas personas han cuestionado los libros texto como éste todavía son necesarios. sin embargo, calidad información disponible web muy irregular; ocasiones presenta muy mal estructurada, por que resulta difícil encontrar información que necesita. consecuencia, creo que los libros texto todavía desempeñan una función importante aprendizaje. sirven como mapa del campo estudio; además, permiten organizar información acerca los métodos las técnicas, presentarla forma coherente legible. también ofrecen punto partida para efectuar una exploración más profunda literatura investigación del material disponible web. creo firmemente que los libros texto tienen futuro, pero sólo están integrados agregan valor material web. por ello, este libro fue diseñado como texto híbrido que combina material impreso con material publicado web, pues infor-mación central edición papel vincula con material complementario medios electrónicos. casi todos los capítulos incluyen “secciones web” especialmente diseña-das, que agregan información dicho capítulo. también existen cuatro “capítu-los web” acerca temas que cubrieron versión impresa del libro. sitio web que asocia con libro : http://softwareengineering-.com material sitio web del libro tiene cuatro componentes principales: . secciones web trata secciones adicionales que agregan información con- tenido presentado cada capítulo. dichas secciones web vinculan partir recuadros conexión separados cada capítulo. . capítulos web existen cuatro capítulos web que cubren métodos formales, diseño interacción, documentación arquitecturas aplicación. será posible agregar otros capítulos acerca nuevos temas durante vida del libro. . material para profesores material esta sección tiene intención apoyar los docentes que enseñan ingeniería software. véase sección “materiales apoyo” este prefacio. . estudios caso ofrecen información adicional acerca los estudios caso analizados libro (bomba insulina, sistema atención salud mental, -xvi .indd iva-xvi .indd // :: // :: pmprefacio sistema clima selvático), así como información acerca más estudios caso, como falla del cohete ariane . paralelamente estas secciones, también existen vínculos otros sitios con material útil acerca ingeniería software: lecturas complementarias, blogs, boletines, etcétera. doy bienvenida sus comentarios sugerencias acerca del libro sitio web, dirección electrónica ian@softwareengineering-.com. por favor, anote [] asunto mensaje. otro modo, mis filtros spam probablemente rechazarán mensaje usted recibirá una respuesta. cabe aclarar que éste espacio para resolver dudas los estudiantes relación con sus tareas escolares; sólo medio para comunicar comentarios sugerencias sobre texto. círculo lectores libro dirige principalmente estudiantes universitarios niveles superiores, que están inscritos cursos introductorios avanzados ingeniería software sistemas. los ingenieros software industria encontrarán libro útil como lectura general para actualizar sus conocimientos acerca temas como reutilización software, diseño arquitectónico, confiabilidad, seguridad, mejora procesos. parte suposición que los lectores completaron curso introducción programación están fami-liarizados con terminología del tema. cambios respecto ediciones anteriores esta edición conserva material fundamental acerca ingeniería software que cubrió ediciones anteriores, pero todos los capítulos fueron revisados actualizados, incluye nuevo material acerca muchos temas diferentes. los cambios más impor-tantes son: . dejó atrás enfoque centrado exclusivamente libro impreso, para dar paso enfoque híbrido que incluye texto impreso material web firmemente inte- grado con las secciones del libro. esto permitió reducir número capítulos versión impresa enfocarse material clave cada capítulo. . realizó una reestructuración para facilitar uso del libro enseñanza ingeniería software. libro consta ahora cuatro partes vez ocho, cada una puede usarse manera independiente combinación con otras como base curso ingeniería software. las cuatro partes son: introducción ingeniería software, confiabilidad seguridad, ingeniería software avanzada gestión ingeniería software. . muchos temas las ediciones anteriores presentan manera más concisa solo capítulo, con material adicional trasladado web. . algunos capítulos adicionales, basados capítulos ediciones anteriores que incluyen aquí, están disponibles web. -xvi .indd -xvi .indd // :: // :: pmvi prefacio . actualizó revisó contenido todos los capítulos. entre % del texto rescribió por completo. . agregaron nuevos capítulos acerca del desarrollo software ágil sistemas embebidos. . además esos nuevos capítulos, hay nuevo material acerca ingeniería dirigida por modelo, desarrollo fuente abierta, desarrollo dirigido por pruebas, modelo queso suizo reason, las arquitecturas sistemas confiables, análi-sis estático comprobación modelos, reutilización cots, software como servicio planeación ágil. . muchos capítulos incorporó nuevo estudio caso acerca sistema registro pacientes que someten tratamiento para problemas salud mental. uso del libro para enseñanza libro está diseñado forma que pueda utilizarse tres tipos diferentes cursos ingeniería software: . cursos introductorios generales acerca ingeniería software primera parte del libro diseñó explícitamente para apoyar curso semestre introducción ingeniería software. . cursos introductorios intermedios acerca temas específicos ingeniería software posible crear varios cursos más avanzados con los capítulos las partes . por ejemplo, impartí curso acerca ingeniería sistemas críti-cos usando los capítulos parte , junto con los capítulos acerca administra-ción calidad administración configuración. . cursos más avanzados acerca temas específicos ingeniería software este caso, los capítulos del libro constituyen fundamento para curso. luego, éste complementa con lecturas que exploran tema con mayor detalle. por ejemplo, curso acerca reutilización software podría basarse los capítulos , , . sitio web del libro está disponible más información acerca del uso del libro para enseñanza, incluida una comparación con ediciones anteriores. materiales apoyo una gran variedad materiales apoyo está disponible para ayudar los profesores que usen libro para impartir sus cursos ingeniería software. entre ellos incluyen:  presentaciones powerpoint para todos los capítulos del libro.  figuras powerpoint. -xvi .indd via-xvi .indd // :: // :: pmprefacio vii  una guía para profesor que consejos acerca cómo usar libro diferentes cursos, que explica relación entre los capítulos esta edición ediciones ante- riores.  más información acerca los estudios caso del libro.  estudios caso adicionales que pueden usarse cursos ingeniería software. presentaciones powerpoint adicionales acerca ingeniería sistemas. cuatro capítulos web que cubren métodos formales, diseño interacción, arquitec- turas aplicación documentación. todo ese material está disponible manera gratuita para los usuarios sitio web del libro sitio apoyo pearson que menciona más adelante. material adi-cional para los maestros está disponible manera restringida solamente para profesores acreditados:  respuestas modelo para ejercicios seleccionados fin capítulo.  preguntas respuestas exámenes para cada capítulo. todo material apoyo, incluido material protegido con contraseña, está dispo- nible : los profesores que usen libro para sus cursos pueden obtener una contraseña para ingresar material restringido registrarse sitio web pearson ponerse contacto con representante local pearson. autor proporciona las contraseñas. reconocimientos muchas personas contribuyeron través los años evolución este libro. quisiera agradecer todos los revisores, estudiantes usuarios del libro que comentaron edicio-nes anteriores, hicieron sugerencias constructivas para realizar cambios. particular, quiero agradecer familia (anne, ali jane) por ayuda apoyo mientras escribía libro. enorme agradecimiento especial para hija jane, quien dio muestra talento corregir las pruebas edición. participación fue muchísima ayuda, pues realizó excelente trabajo leer todo libro, marcar corre-gir una gran cantidad errores tipográficos gramaticales. ian sommerville octubre -xvi .indd viia-xvi .indd vii // :: // :: pmcontenido breve prefacio iii parte introducción ingeniería software capítulo introducción capítulo procesos software capítulo desarrollo ágil software capítulo ingeniería requerimientos capítulo modelado del sistema capítulo diseño arquitectónico capítulo diseño implementación capítulo pruebas software capítulo evolución del software parte confiabilidad seguridad capítulo sistemas sociotécnicos capítulo confiabilidad seguridad capítulo especificación confiabilidad seguridad capítulo ingeniería confiabilidad capítulo ingeniería seguridad capítulo garantía confiabilidad seguridad parte ingeniería software avanzada capítulo reutilización software capítulo ingeniería software basada componentes capítulo ingeniería software distribuido capítulo arquitectura orientada servicios capítulo software embebido capítulo ingeniería software orientada aspectos parte gestión software capítulo gestión proyectos capítulo planeación proyectos capítulo gestión calidad capítulo administración configuración capítulo mejora procesos glosario índice analítico índice autores -xvi .indd viiia-xvi .indd viii // :: // :: pmcontenido prefacio iii parte introducción ingeniería software capítulo introducción . desarrollo software profesional . ética ingeniería software . estudios caso capítulo procesos software . modelos proceso software . actividades del proceso . cómo enfrentar cambio . proceso unificado racional capítulo desarrollo ágil software . métodos ágiles . desarrollo dirigido por plan desarrollo ágil -xvi .indd ixa-xvi .indd // :: // :: pmx contenido . programación extrema . administración proyecto ágil . escalamiento métodos ágiles capítulo ingeniería requerimientos . requerimientos funcionales funcionales . documento requerimientos software . especificación requerimientos . procesos ingeniería requerimientos . adquisición análisis requerimientos . validación requerimientos . administración requerimientos capítulo modelado del sistema . modelos contexto . modelos interacción . modelos estructurales . modelos comportamiento . ingeniería dirigida por modelo capítulo diseño arquitectónico . decisiones diseño arquitectónico . vistas arquitectónicas . patrones arquitectónicos . arquitecturas aplicación capítulo diseño implementación . diseño orientado objetos con uso del uml . patrones diseño -xvi .indd -xvi .indd // :: // :: . conflictos implementación . desarrollo código abierto capítulo pruebas software . pruebas desarrollo . desarrollo dirigido por pruebas . pruebas versión . pruebas usuario capítulo evolución del software . procesos evolución . evolución dinámica del programa . mantenimiento del software . administración sistemas heredados parte confiabilidad seguridad capítulo sistemas sociotécnicos . sistemas complejos . ingeniería sistemas . procuración del sistema . desarrollo del sistema . operación del sistema capítulo confiabilidad seguridad . propiedades confiabilidad . disponibilidad fiabilidad . protección . seguridad -xvi .indd xia-xvi .indd // :: // :: pmxii contenido capítulo especificación confiabilidad seguridad . especificación requerimientos dirigida por riesgos . especificación protección . especificación fiabilidad . especificación seguridad . especificación formal capítulo ingeniería confiabilidad . redundancia diversidad . procesos confiables . arquitecturas sistemas confiables . programación confiable capítulo ingeniería seguridad . gestión del riesgo seguridad . diseño para seguridad . supervivencia del sistema capítulo garantía confiabilidad seguridad . análisis estático . pruebas fiabilidad . pruebas seguridad . aseguramiento del proceso . casos protección confiabilidad parte ingeniería software avanzada capítulo reutilización software . panorama reutilización . frameworks aplicación -xvi .indd xiia-xvi .indd xii // :: // :: . líneas productos software . reutilización productos cots capítulo ingeniería software basada componentes . componentes modelos componentes . procesos cbse . composición componentes capítulo ingeniería software distribuido . conflictos los sistemas distribuidos . computación cliente-servidor . patrones arquitectónicos para sistemas distribuidos . software como servicio capítulo arquitectura orientada servicios . servicios como componentes reutilización . ingeniería servicio . desarrollo software con servicios capítulo software embebido . diseño sistemas embebidos . patrones arquitectónicos . análisis temporización . sistemas operativos tiempo real capítulo ingeniería software orientada aspectos . separación intereses . aspectos, puntos enlaces puntos corte . ingeniería software con aspectos xiii -xvi .indd xiiia-xvi .indd xiii // :: // :: pmxiv contenido parte gestión software capítulo gestión proyectos . gestión del riesgo . gestión personal . trabajo equipo capítulo planeación proyectos . fijación precio software . desarrollo dirigido por plan . calendarización proyectos . planeación ágil . técnicas estimación capítulo gestión calidad . calidad del software . estándares software . revisiones inspecciones . medición métricas del software capítulo administración configuración . administración del cambio . gestión versiones . construcción del sistema . gestión entregas software (release) capítulo mejora procesos . proceso mejora procesos . medición del proceso -xvi .indd xiva-xvi .indd xiv // :: // :: . análisis del proceso . cambios los procesos . marco trabajo para mejora procesos cmmi glosario índice analítico índice autores -xvi .indd xva-xvi .indd // :: // :: pma-xvi .indd xvia-xvi .indd xvi // :: // :: pmla meta esta parte del libro ofrecer una introducción general ingeniería software. incluyen conceptos importantes como procesos software métodos ágiles; además, describen actividades esencia-les del desarrollo software, desde especificación inicial del software hasta evolución del sistema. los capítulos esta parte diseñaron para apoyar curso semestre ingeniería software. capítulo introduce lector manera general ingeniería software profesional define algunos conceptos respecto. también escribe breve análisis los conflictos éticos ingeniería soft-ware. importante que los ingenieros software consideren las nume-rosas implicaciones trabajo. este capítulo además presenta tres estudios caso que usan libro, saber: sistema para adminis-trar registros pacientes que someten tratamiento por problemas salud mental, sistema control para una bomba insulina portátil sistema meteorológico campo abierto. los capítulos tratan los procesos ingeniería software desarrollo ágil. capítulo presentan modelos proceso soft-ware genérico uso común, como waterfall (cascada), estudian las actividades básicas que son parte dichos procesos. capítulo complementa esto con estudio los métodos desarrollo ágil para ingeniería software. usa sobre todo programación extrema como parte ingeniería software -.indd -.indd // :: // :: pmejemplo método ágil, aunque también esta sección introduce brevemente scrum. los capítulos restantes son amplias descripciones las actividades del proceso software que introducirán capítulo . capítulo trata tema importante ingeniería requerimientos, donde definen las necesidades que debe hacer sistema. capítulo muestra modelado sistemas usando uml, donde enfoca uso los diagramas caso, diagramas clase, diagramas secuencia diagramas estado para modelar sistema software. capítulo introduce diseño arquitectónico estudia importancia arqui-tectura uso patrones arquitectónicos diseño software. capítulo trata sobre diseño orientado objetos uso patrones diseño. aquí también observan importantes problemas imple-mentación: reutilización, manejo configuración desarrollo host-target (anfitrión destino); también estudia desarrollo código abierto. capítulo enfoca las pruebas del software, desde prueba unidad durante desarrollo del sistema, hasta prueba puesta venta del software. también analiza uso del desarrollo impulsado por prueba, enfoque pionero los métodos ágiles, pero con gran aplicabilidad. finalmente, capítulo brinda panorama los temas sobre evolución del software. describen los procesos evo-lutivos, mantenimiento del software gestión sistemas legados. -.indd -.indd // :: // :: pmobjetivos los objetivos este capítulo consisten introducir lector ingeniería software ofrecer marco conceptual para entender resto del libro. estudiar este capítulo: ■ conocerá qué ingeniería software por qué importante; ■ comprenderá que desarrollo diferentes tipos sistemas software puede requerir distintas técnicas ingeniería software; ■ entenderá algunos conflictos éticos profesionales que son importantes para los ingenieros software; ■ conocerá tres sistemas diferentes tipos, que usarán como ejemplos largo del libro. contenido . desarrollo software profesional . ética ingeniería software. estudios caso introducción -.indd -.indd // :: // :: capítulo ■ introducción imposible operar mundo moderno sin software. las infraestructuras nacionales los servicios públicos controlan mediante sistemas basados computadoras, mayoría los productos eléctricos incluyen una computadora software control. fabricación distribución industrial están completamente computarizadas, como sistema financiero. entretenimiento, incluida industria musical, los juegos por computadora, cine televisión, usan software manera intensiva. por tanto, ingeniería software esencial para funcionamiento las sociedades, tanto nivel nacional como internacional. los sistemas software son abstractos intangibles. están restringidos por las propiedades los materiales, regidos por leyes físicas por procesos fabri-cación. esto simplifica ingeniería software, pues existen límites naturales potencial. sin embargo, debido falta restricciones físicas, los sistemas software pueden volverse rápidamente muy complejos, difíciles entender costosos cambiar. hay muchos tipos diferentes sistemas software, desde los simples sistemas embebidos, hasta los complejos sistemas información mundial. tiene sentido bus-car notaciones, métodos técnicas universales para ingeniería software, que diferentes tipos software requieren distintos enfoques. desarrollar sistema orga-nizacional información completamente diferente controlador para ins-trumento científico. ninguno estos sistemas tiene mucho común con juego por computadora gráficos intensivos. aunque todas estas aplicaciones necesitan ingenie-ría software, todas requieren las mismas técnicas ingeniería software. aún existen muchos reportes tanto proyectos software que salen mal como “fallas software”. por ello, ingeniería software considera inadecuada para desarrollo del software moderno. sin embargo, desde perspectiva del autor, muchas las llamadas fallas del software son consecuencia dos factores: . demandas crecientes conforme las nuevas técnicas ingeniería software ayudan construir sistemas más grandes complejos, las demandas cambian. los sistemas tienen que construirse distribuirse más rápidamente; requieren sistemas más grandes incluso más complejos; los sistemas deben tener nuevas capacidades que anteriormente consideraban imposibles. los métodos existentes ingeniería software pueden enfrentar situación, tienen que desarrollarse nuevas técni-cas ingeniería software para satisfacer nuevas demandas. . expectativas bajas relativamente sencillo escribir programas cómputo sin usar métodos técnicas ingeniería software. muchas compañías deslizan hacia ingeniería software conforme evolucionan sus productos servicios. usan métodos ingeniería software trabajo diario. por tanto, soft-ware con frecuencia más costoso menos confiable que debiera. nece-saria una mejor educación capacitación ingeniería software para solucionar este problema. los ingenieros software pueden estar orgullosos sus logros. desde luego, toda- vía presentan problemas desarrollar software complejo, pero, sin ingeniería soft-ware, habría explorado espacio tendría internet las telecomunicaciones modernas. todas las formas viaje serían más peligrosas caras. ingeniería software contribuido gran medida, sus aportaciones siglo xxi serán aún mayores. -.indd -.indd // :: // :: . ■ desarrollo software profesional . desarrollo software profesional muchos individuos escriben programas. las empresas los empleados hacen programas hoja cálculo para simplificar trabajo; científicos ingenieros elaboran progra-mas para procesar sus datos experimentales, los aficionados crean programas para propio interés satisfacción. sin embargo, gran mayoría del desarrollo software una actividad profesional, donde software realiza para propósitos negocios especí-ficos, para inclusión otros dispositivos como productos software, por ejemplo, sistemas información, sistemas cad, etcétera. software profesional, destinado usarse por alguien más aparte desarrollador, lleva cabo general por equipos, vez individualmente. mantiene cambia largo vida. ingeniería software busca apoyar desarrollo software profesional, lugar programación individual. incluye técnicas que apoyan especificación, diseño evolución del programa, ninguno los cuales son normalmente relevantes para desa-rrollo software personal. con objetivo ayudarlo obtener una amplia visión que trata ingeniería software, figura . resumen algunas preguntas planteadas con frecuencia. muchos suponen que software tan sólo otra palabra para los programas cómpu- . obstante, cuando habla ingeniería software, esto sólo refiere los programas , sino también toda documentación asociada los datos configu-ración requeridos para hacer que estos programas operen manera correcta. sistema software desarrollado profesionalmente usualmente más que solo programa. sistema por regular consta número programas separados archivos con-figuración que usan para instalar dichos programas. puede incluir documentación del sistema, que describe estructura del sistema; documentación del usuario, que explica cómo usar sistema, los sitios web para que los usuarios descarguen información reciente del producto. ésta una las principales diferencias entre desarrollo software profesional aficionado. usted diseña programa personal, nadie más usará tendrá que preocuparse por elaborar guías del programa, documentar diseño del programa, etcétera. por contrario, crea software que otros usarán otros ingenieros cambiarán, entonces, general debe ofrecer información adicional, así como código del programa.historia ingeniería software concepto “ingeniería software” propuso originalmente , una conferencia realizada para discutir que entonces llamaba “crisis del software” (naur randell, ). volvió claro que los enfoques individuales desarrollo programas escalaban hacia los grandes complejos sistemas software. éstos eran confiables, costaban más esperado distribuían con demora. largo las décadas desarrolló una variedad nuevas técnicas métodos ingeniería software, tales como programación estructurada, encubrimiento información desarrollo orientado objetos. perfeccionaron herramientas notaciones estándar ahora usan manera extensa. http:// -.indd -.indd // :: // :: capítulo ■ introducción los ingenieros software están interesados por desarrollo productos software ( decir, software que puede venderse cliente). existen dos tipos productos software: . productos genéricos consisten sistemas independientes que producen por una organización desarrollo venden mercado abierto cualquier cliente figura . preguntas planteadas con frecuencia sobre softwarepregunta respuesta ¿qué software? programas cómputo documentación asociada. los productos software desarrollan para cliente particular para mercado general. ¿cuáles son los atributos del buen software? buen software debe entregar usuario funcionalidad desempeño requeridos, debe ser sustentable, confiable utilizable. ¿qué ingeniería software? ingeniería software una disciplina ingeniería que interesa por todos los aspectos producción software. ¿cuáles son las actividades fundamentales ingeniería software?especificación, desarrollo, validación evolución del software. ¿cuál diferencia entre ingeniería software ciencias computación?las ciencias computación enfocan teoría fundamentos; mientras ingeniería software enfoca sentido práctico del desarrollo distribución software. ¿cuál diferencia entre ingeniería software ingeniería sistemas? ingeniería sistemas interesa por todos los aspectos del desarrollo sistemas basados computadoras, incluidos hardware, software ingeniería procesos. ingeniería software parte este proceso más general. ¿cuáles son los principales retos que enfrenta ingeniería software? enfrentan con una diversidad creciente, demandas por tiempos distribución limitados desarrollo software confiable. ¿cuáles son los costos ingeniería software?aproximadamente % los costos del software son desarrollo, % prueba. para software elaborado específicamente, los costos evolución superan con frecuencia los costos desarrollo. ¿cuáles son los mejores métodos técnicas ingeniería software?aun cuando todos los proyectos software deben gestionarse desarrollarse manera profesional, existen diferentes técnicas que son adecuadas para distintos tipos sistema. por ejemplo, los juegos siempre deben diseñarse usando una serie prototipos, mientras que los sistemas críticos control seguridad requieren una especificación completa analizable para desarrollo. por tanto, puede decirse que método sea mejor que otro. ¿qué diferencias marcado web ingeniería software? web llevado disponibilidad servicios software posibilidad desarrollar sistemas basados servicios distribuidos ampliamente. desarrollo sistemas basados web conducido importantes avances lenguajes programación reutilización software. -.indd -.indd // :: // :: . ■ desarrollo software profesional que desee comprarlos. ejemplos este tipo productos incluyen software para , como bases datos, procesadores texto, paquetes dibujo herramientas administración proyectos. también abarcan las llamadas aplicaciones verticales diseñadas para cierto propósito específico, tales como sistemas información librería, sistemas contabilidad sistemas para mantener registros dentales. . productos personalizados ( medida) son sistemas que están destinados para cliente particular. contratista software desarrolla programa especial-mente para dicho cliente. ejemplos este tipo software incluyen los sistemas control para dispositivos electrónicos, sistemas escritos para apoyar cierto proceso empresarial los sistemas control tráfico aéreo. una diferencia importante entre estos tipos software que, productos gené- ricos, organización que desarrolla software controla especificación del mismo. para los productos personalizados, organización que compra software generalmente desarrolla controla especificación, por que los desarrolladores software deben trabajar siguiendo dicha especificación. sin embargo, distinción entre estos tipos producto sistemas vuelve cada vez más difusa. ahora, cada vez más sistemas construyen con producto genérico como base, que luego adapta para ajustarse los requerimientos cliente. los sis-temas enterprise resource planning (erp, planeación recursos empresariales), como sistema sap, son los mejores ejemplos este enfoque. aquí, sistema grande complejo adapta una compañía incorporar información acerca las reglas los procesos empresariales, los reportes requeridos, etcétera. cuando habla calidad del software profesional, debe considerar que software usan cambian personas, además sus desarrolladores. consecuencia, calidad tiene que ver sólo con que hace software. cambio, debe incluir comportamiento del software mientras ejecuta, estructura organización los programas del sis-tema documentación asociada. esto refleja los llamados calidad atributos funcionales del software. ejemplos dichos atributos son tiempo respuesta del soft-ware ante duda usuario comprensibilidad del código del programa. conjunto específico atributos que espera sistema software depende evidentemente aplicación. así, sistema bancario debe ser seguro, juego inte-ractivo debe tener capacidad respuesta, sistema conmutación telefónica debe ser confiable, etcétera. esto puede generalizarse conjunto atributos que muestra figura ., los cuales consideran las características esenciales sistema software profesional. .. ingeniería software ingeniería software una disciplina ingeniería que interesa por todos los aspectos producción software, desde las primeras etapas especificación del sistema hasta mantenimiento del sistema después que pone operación. esta definición presentan dos frases clave: . disciplina ingeniería los ingenieros hacen que las cosas funcionen. aplican teorías, métodos herramientas donde adecuado. sin embargo, los usan manera -.indd -.indd // :: // :: capítulo ■ introducción selectiva siempre tratan encontrar soluciones problemas, incluso cuando hay teorías métodos aplicables. los ingenieros también reconocen que deben tra-bajar ante restricciones organizacionales financieras, modo que buscan solucio-nes dentro tales limitaciones. . todos los aspectos producción del software ingeniería software sólo interesa por los procesos técnicos del desarrollo software, sino también incluye actividades como administración del proyecto software desa-rrollo herramientas, así como métodos teorías para apoyar producción software. ingeniería busca obtener resultados calidad requerida dentro fecha del presupuesto. menudo esto requiere contraer compromisos: los ingenieros deben ser perfeccionistas. sin embargo, las personas que diseñan programas para mismas podrían pasar tanto tiempo como deseen desarrollo del programa. general, los ingenieros software adoptan trabajo enfoque sistemático organizado, pues usualmente ésta forma más efectiva producir software alta calidad. obstante, ingeniería busca seleccionar método más adecuado para conjunto circunstancias , esta manera, acercamiento desarrollo más creativo menos formal sería efectivo ciertas situaciones. desarrollo menos formal parti-cularmente adecuado para creación sistemas basados web, que requieren una mezcla habilidades software diseño gráfico. ingeniería software importante por dos razones: . cada vez con mayor frecuencia, los individuos sociedad apoyan los avan- zados sistemas software. por ende, requiere producir económica rápidamente sistemas confiables.figura . atributos esenciales del buen softwarecaracterísticas del producto descripción mantenimiento software debe escribirse tal forma que pueda evolucionar para satisfacer las necesidades cambiantes los clientes. éste atributo crítico porque cambio del software requerimiento inevitable entorno empresarial variable. confiabilidad seguridad confiabilidad del software incluye rango características que abarcan fiabilidad, seguridad protección. software confiable tiene que causar daño físico económico, caso falla del sistema. los usuarios malintencionados deben tener posibilidad acceder sistema dañarlo. eficiencia software tiene que desperdiciar los recursos del sistema, como memoria los ciclos del procesador. por tanto, eficiencia incluye capacidad respuesta, tiempo procesamiento, utilización memoria, etcétera. aceptabilidad software debe ser aceptable tipo usuarios para quienes diseña. esto significa que necesita ser comprensible, utilizable compatible con otros sistemas que ellos usan. -.indd -.indd // :: // :: . ■ desarrollo software profesional . menudo resulta más barato largo plazo usar métodos técnicas ingeniería software para los sistemas software, que sólo diseñar los programas como fuera proyecto programación personal. para muchos tipos sistemas, mayoría los costos consisten cambiar software después ponerlo operación. enfoque sistemático que usa ingeniería software conoce ocasiones como proceso software. proceso software una secuencia actividades que conducen elaboración producto software. existen cuatro actividades funda-mentales que son comunes todos los procesos software, éstas son: . especificación del software, donde clientes ingenieros definen software que producirá las restricciones operación. . desarrollo del software, donde diseña programa software. . validación del software, donde verifica software para asegurar que sea que cliente requiere. . evolución del software, donde modifica software para reflejar los requerimien- tos cambiantes del cliente del mercado. diferentes tipos sistemas necesitan distintos procesos desarrollo. por ejemplo, software tiempo real una aeronave debe especificarse por completo antes comenzar desarrollo. los sistemas comercio electrónico, especificación programa por general desarrollan conjunto. consecuencia, tales actividades genéricas pueden organizarse diferentes formas describirse distintos niveles detalle, dependiendo del tipo software que vaya desarrollar. capítulo des-criben con más puntualidad los procesos software. ingeniería software relaciona con las ciencias computación inge- niería sistemas: . las ciencias computación interesan por las teorías los métodos que sub- yacen las computadoras los sistemas software, tanto que ingeniería software preocupa por los asuntos prácticos producción del software. cierto conocimiento ciencias computación esencial para los ingenieros soft-ware, del mismo modo que cierto conocimiento física para los ingenieros electricistas. sin embargo, con frecuencia teoría las ciencias computación más aplicable programas relativamente pequeños. las teorías las ciencias computación siempre pueden aplicarse grandes problemas complejos que requieren una solución software. . ingeniería sistemas interesa por todos los aspectos del desarrollo evo- lución complejos sistemas, donde software tiene papel principal. por tanto, ingeniería sistemas preocupa por desarrollo hardware, dise- políticas procesos, implementación del sistema, así como por inge-niería software. los ingenieros sistemas intervienen especificación del sistema, definiendo arquitectura global , luego, integrando las diferentes partes para crear sistema terminado. están menos preocupados por ingeniería los componentes del sistema (hardware, software, etcétera). -.indd -.indd // :: // :: capítulo ■ introducción como expone siguiente sección, hay muchos tipos diferentes software. existe método una técnica universales ingeniería software que sea aplicable para todos éstos. obstante, tres problemas generales afectan muy diversos tipos software: . heterogeneidad cada vez con mayor frecuencia requieren sistemas que operen como distribuidos través redes que incluyan diferentes tipos computadoras dispositivos móviles. posible que software ejecute tanto computadoras propósito general como teléfonos móviles. tendrá que integrar con frecuencia nuevo software con sistemas legados más viejos, escritos diferentes lenguajes programación. reto aquí desarrollar técnicas para construir software confia-ble que sea suficientemente flexible para enfrentar esa heterogeneidad. . cambio empresarial social los negocios sociedad cambian manera increíblemente rápida, conforme desarrollan las economías emergentes nuevas tecnologías están disposición. ambos necesitan tener posibilidad cambiar software existente desarrollar rápidamente uno nuevo. muchas técnicas tradi-cionales ingeniería software consumen tiempo, generalmente entrega los nuevos sistemas tarda más planeado. requieren evolucionar modo que reduzca tiempo necesario para que software valor sus clientes. . seguridad confianza dado que software está vinculado con todos los aspectos vida, esencial confiar dicho software. esto especialmente cierto para los sistemas software remoto los que accede través una página web una interfaz servicio web. necesario asegurarse que usuarios malintencionados puedan atacar software que conserve seguridad información. desde luego, éstos son problemas independientes. por ejemplo, quizá sea nece- sario realizar cambios rápidos sistema legado con finalidad dotarlo con una interfaz servicio web. para enfrentar dichos retos necesitarán nuevas herramientas técnicas, así como formas innovadoras combinar usar los métodos existentes ingeniería software. .. diversidad ingeniería software ingeniería software enfoque sistemático para producción software que toma cuenta los temas prácticos costo, fecha confiabilidad, así como las nece-sidades clientes fabricantes software. como este enfoque sistemático realmente implementado varía manera drástica dependiendo organización que desarrolla software, tipo software los individuos que intervienen proceso desarrollo, existen métodos técnicas universales ingeniería software que sean adecuados para todos los sistemas las compañías. más bien, durante los últimos años evolu-cionó conjunto métodos herramientas ingeniería software. quizás factor más significativo determinación qué métodos técnicas ingeniería software son más importantes, tipo aplicación que está siendo desarrollada. existen muchos diferentes tipos aplicación, incluidos los siguientes: . aplicaciones independientes trata sistemas aplicación que corren una computadora local, como una , incluyen toda funcionalidad necesaria -.indd -.indd // :: // :: . ■ desarrollo software profesional requieren conectarse una red. ejemplos tales aplicaciones son las oficina una , programas cad, software manipulación fotografías, etcétera. . aplicaciones interactivas basadas transacción consisten aplicaciones que ejecutan una computadora remota las que los usuarios acceden desde sus propias terminales. evidentemente, ellas incluyen aplicaciones web como las comercio electrónico, donde posible interactuar con sistema remoto para comprar bienes servicios. esta clase aplicación también incluye sistemas empresariales, donde una organización brinda acceso sus sistemas tra-vés navegador web programa cliente propósito específico servi-cios basados nube, como correo electrónico compartición fotografías. las aplicaciones interactivas incorporan con frecuencia gran almacén datos que accede actualiza cada transacción. . sistemas control embebido trata sistemas control software que regulan gestionan dispositivos hardware. numéricamente, quizás existen más sistemas embebidos que cualquier otro tipo sistema. algunos ejemplos sis-temas embebidos incluyen software teléfono móvil (celular), software que controla los frenos antibloqueo automóvil software horno microondas para controlar proceso cocinado. . sistemas procesamiento lotes son sistemas empresariales que diseñan para procesar datos grandes lotes (batch). procesan gran cantidad entradas indivi-duales para crear salidas correspondientes. los ejemplos sistemas batch incluyen sistemas facturación periódica, como los sistemas facturación telefónica los sistemas pago salario. . sistemas entretenimiento son sistemas para uso sobre todo personal, que tienen intención entretener usuario. mayoría estos sistemas son juegos uno otro tipo. calidad interacción ofrecida usuario característica más importante los sistemas entretenimiento. . sistemas para modelado simulación éstos son sistemas que desarrollan científi-cos ingenieros para modelar procesos situaciones físicas, que incluyen muchos -jetos separados interactuantes. dichos sistemas menudo son computacionalmente intensivos para ejecución requieren sistemas paralelos alto desempeño. . sistemas adquisición datos son sistemas que desde entorno recopilan datos usando conjunto sensores, envían dichos datos para procesamiento otros sistemas. software tiene que interactuar con los sensores instala regularmente ambiente hostil, como interior motor una ubi-cación remota. . sistemas sistemas son sistemas compuestos cierto número sistemas software. algunos ellos son producto del software genérico, como programa hoja cálculo. otros sistemas ensamble pueden estar especialmente escri-tos para ese entorno. desde luego, los límites entre estos tipos sistemas son difusos. desarrolla juego para teléfono móvil (celular), debe tomar cuenta las mismas restriccio-nes (energía, interacción hardware) que las los desarrolladores del software del -.indd -.indd // :: // :: capítulo ■ introducción teléfono. los sistemas procesamiento por lotes usan con frecuencia conjunción con sistemas basados web. por ejemplo, una compañía, las solicitudes gastos viaje envían mediante una aplicación web, aunque procesa una aplicación batch para pago mensual. para cada tipo sistema usan distintas técnicas ingeniería software, por- que software tiene características muy diferentes. por ejemplo, sistema control embebido automóvil crítico para seguridad quema rom cuando instala vehículo; por consiguiente, muy costoso cambiarlo. tal sistema necesita verificación validación muy exhaustivas, tal modo que minimicen las probabili-dades volver llamar para revisión automóviles, después venta, para corregir los problemas del software. interacción del usuario mínima ( quizás inexistente), por que hay necesidad usar proceso desarrollo que apoye prototipo interfaz usuario. para sistema basado web sería adecuado enfoque basado desarrollo entrega iterativos, con sistema componentes reutilizables. sin embargo, tal enfoque podría ser práctico para sistema sistemas, donde tienen que definirse por adelantado las especificaciones detalladas las interacciones del sistema, modo que cada sistema desarrolle por separado. obstante, existen fundamentos ingeniería software que aplican todos los tipos sistema software: . deben llevarse cabo usando proceso desarrollo administrado comprendido. organización que diseña software necesita planear proceso desarrollo, así como tener ideas claras acerca que producirá tiempo que estará comple-tado. desde luego, usan diferentes procesos para distintos tipos software. . confiabilidad desempeño son importantes para todos los tipos sistemas. software tiene que comportarse como espera, sin fallas, cuando requiera estar disponible. debe ser seguro operación , tanto como sea posible, también contra ataques externos. sistema tiene que desempeñarse manera eficiente desperdiciar recursos. . importante comprender gestionar especificación los requerimientos del software ( que software debe hacer). debe conocerse qué esperan los dife-rentes clientes usuarios del sistema, gestionar sus expectativas, para entregar sistema útil dentro fecha presupuesto. . tiene que usar manera tan efectiva como sea posible los recursos existentes. esto significa que, donde sea adecuado, hay que reutilizar software que haya desa-rrollado, vez diseñar uno nuevo. estas nociones fundamentales sobre proceso, confiabilidad, requerimientos, gestión reutilización, son temas importantes este libro. diferentes métodos los reflejan formas diversas, pero subyacen todo desarrollo software profesional. hay que destacar que estos fundamentos cubren implementación progra- mación. este libro estudian técnicas específicas programación, que ellas varían drásticamente tipo sistema otro. por ejemplo, lenguaje guiones (scripts), como ruby, sirve para programación sistemas basados web, aunque sería totalmente inadecuado para ingeniería sistemas embebidos. -.indd -.indd // :: // :: . ■ desarrollo software profesional .. ingeniería software web desarrollo world wide web tuvo profundo efecto todas nuestras vidas. inicio, web fue básicamente almacén información universal accesible que tuvo escaso efecto sobre los sistemas software. dichos sistemas corrían computadoras locales eran sólo accesibles desde interior una organización. alrededor del año , web comenzó evolucionar, los navegadores les agregaron cada vez más funcionalidades. esto significó que los sistemas basados web podían desarrollarse donde tuviera acceso dichos sistemas usando navegador web, lugar una interfaz usuario propósito específico. esta situación condujo desarrollo una gran variedad nuevos productos sistemas que entregaban servicios innovadores, los cua-les ingresaba desde web. menudo los financiaban los anuncios publicitarios que desplegaban pantalla del usuario requerían del pago directo los usuarios. así como estos productos sistemas, desarrollo navegadores web que corrieran pequeños programas realizaran cierto procesamiento local condujo una evolución los negocios software organizacional. lugar elaborar software implementarlo las los usuarios, software implementaba servidor web. este avance hizo mucho más barato cambiar actualizar software, pues había necesidad instalar software cada . también redujo costos, que desarrollo interfaces usuario bastante caro. consecuencia, dondequiera que fuera posible hacerlo, muchos negocios mudaron interacción basada web con sistemas software compañía. siguiente etapa desarrollo los sistemas basados web fue noción los servicios web. estos últimos son componentes software que entregan funcionalidad específica útil, los que accede desde web. las aplicaciones construyen inte-grar dichos servicios web que ofrecen diferentes compañías. principio, esta vinculación suele ser dinámica, modo que utilice una aplicación cada vez que ejecutan diferen-tes servicios web. capítulo analiza este acercamiento desarrollo del software. los últimos años desarrolló noción “software como servicio”. pro- puso que software correría usualmente computadoras locales, sino “nubes cómputo” las que accede través internet. usted utiliza servicio como correo basado web, usa sistema basado nube. una nube computación enorme número sistemas cómputo vinculados que comparten muchos usuarios. éstos compran software, sino que pagan según tiempo software que utiliza, también les otorga acceso gratuito cambio ver anuncios publicitarios que despliegan sus pantallas. por consiguiente, llegada web condujo significativo cambio forma que organiza software empresarial. antes web, las aplicaciones empresa-riales eran básicamente monolíticas, los programas corrían computadoras individuales grupos computadoras. las comunicaciones eran locales dentro una organiza-ción. ahora software está ampliamente distribuido, ocasiones largo del mundo. las aplicaciones empresariales programan desde cero, sino que requieren reutili-zación extensiva componentes programas. efecto, este cambio radical organización del software tuvo que conducir modificaciones las formas que los sistemas basados web someten inge-niería. por ejemplo: . reutilización software convertido enfoque dominante para construir sistemas basados web. cuando construyen tales sistemas, uno piensa cómo ensamblarlos partir componentes sistemas software preexistentes. -.indd -.indd // :: // :: capítulo ■ introducción . ahora reconoce general que práctico especificar por adelantado todos los requerimientos para tales sistemas. los sistemas basados web deben desarro- llarse entregarse manera progresiva. . las interfaces usuario están restringidas por las capacidades los navegadores web. aunque tecnologías como ajax (holdener, ) significan que posible crear valiosas interfaces dentro navegador web, dichas tecnologías aún son difíciles emplear. usan más comúnmente los formatos web con escritura guiones local. las interfaces aplicación sistemas basados web con fre-cuencia son más deficientes que las interfaces usuario específicamente diseñadas productos sistema . las ideas fundamentales ingeniería software, discutidas sección ante- rior, aplican software basado web misma forma que otros tipos sistemas software. siglo , experiencia obtenida con desarrollo gran- des sistemas todavía relevante para software basado web. . ética ingeniería software como otras disciplinas ingeniería, ingeniería software realiza dentro marco social legal que limita libertad gente que trabaja dicha área. como ingeniero software, usted debe aceptar que labor implica responsabilidades mayores que simple aplicación habilidades técnicas. también debe comportarse forma ética moralmente responsable para ser respetado como ingeniero pro-fesional. sobra decir que debe mantener estándares normales honestidad integridad. debe usar sus habilidades experiencia para comportarse forma deshonesta modo que desacredite profesión ingeniería software. sin embargo, existen áreas donde los estándares comportamiento aceptable están acotados por legis-lación, sino por noción más difusa responsabilidad profesional. algunas ellas son: . confidencialidad por general, debe respetar confidencialidad sus emplea- dores clientes sin importar firmó acuerdo formal sobre misma. . competencia debe desvirtuar nivel competencia. decir, hay que aceptar manera intencional trabajo que esté fuera competencia. . derechos propiedad intelectual tiene que conocer las leyes locales que rigen uso propiedad intelectual, como las patentes copyright . debe ser cuidadoso para garantizar que protege propiedad intelectual empleadores clientes. . mal uso computadoras debe emplear sus habilidades técnicas para usar incorrectamente las computadoras otros individuos. mal uso compu-tadoras varía desde relativamente trivial (esto , distraerse con los juegos del compañero) hasta extremadamente serio (diseminación virus otro malware). -.indd -.indd // :: // :: . ■ ética ingeniería software las sociedades instituciones profesionales tienen importante papel que desempe- ñar establecimiento estándares éticos. organizaciones como acm, instituto ingenieros eléctricos electrónicos (ieee) british computer society publican código conducta profesional código ética. los integrantes tales organizaciones comprometen seguir dicho código cuando firman afiliarse. estos códigos con-ducta preocupan general por comportamiento ético fundamental. las asociaciones profesionales, sobre todo acm ieee, han cooperado para elaborar conjuntamente código ética práctica profesionales. este código existe tanto manera simplificada (figura .) como pormenorizada (gotterbarn ., ) que agrega detalle sustancia versión más corta. los fundamentos detrás este código resumen los primeros dos párrafos forma pormenorizada: las computadoras tienen una función central creciente comercio, indus-tria, gobierno, medicina, educación, entretenimiento sociedad general. los ingenieros software son quienes contribuyen, mediante partici-pación directa con enseñanza, análisis, especificación, diseño, desa-rrollo, certificación, mantenimiento prueba los sistemas software. figura . código ética acm/ieee (© ieee/acm, )código ética práctica profesional ingeniería software acm/ieee- fuerza trabajo conjunta acerca ética prácticas profesionales ingeniería softwarepreámbulo versión corta del código resume las aspiraciones alto nivel abstracción; las cláusulas que incluyen versión completa dan ejemplos detalles cómo dichas aspiraciones cambian forma que actuamos como profesionales ingeniería software. sin las aspiraciones, los detalles pueden volverse legalistas tediosos; mientras que sin los detalles, las aspiraciones suelen volverse muy resonantes pero vacías; conjunto, aspiraciones detalles forman código cohesivo. los ingenieros software deben comprometerse hacer del análisis, especificación, diseño, desarrollo, prueba mantenimiento del software, una profesión benéfica respetada. acuerdo con compromiso con salud, seguridad bienestar del público, los ingenieros software tienen que adherirse los ocho principios siguientes: . público: los ingenieros software deben actuar consecuentemente con interés del público. . cliente empleador: los ingenieros software tienen que comportarse tal forma que fomente mejor interés para cliente empleador, coherencia con interés público. . producto: los ingenieros software deben garantizar que sus productos modificaciones relacionadas satisfagan los estándares profesionales más altos posibles. . juicio: los ingenieros software tienen que mantener integridad independencia juicio profesional. . gestión: los administradores líderes ingeniería software deben suscribir promover enfoque ético gestión del desarrollo mantenimiento del software. . profesión: los ingenieros software tienen que fomentar integridad reputación profesión consecuente con interés público. . colegas: los ingenieros software deben ser justos con sus colegas apoyarlos.. uno mismo: los ingenieros software tienen que intervenir aprendizaje para toda vida, cuanto práctica profesión, promover enfoque ético. -.indd -.indd // :: // :: capítulo ■ introducción debido función desarrollo los sistemas software, los ingenieros software tienen oportunidades significativas para hacer correcto causar daño, para permitir que otros hagan correcto causen daño, para influir otros para hacer correcto causar daño. para garantizar, tanto como sea posible, que sus esfuerzos serán usados correctamente, los ingenieros software deben comprometerse hacer ingeniería software una profesión benéfica respetada. concordancia con dicho compromiso, los ingenieros software tienen que adherirse siguiente código ética práctica profesional. código contiene ocho principios relacionados con comportamiento las deci- siones tomadas por ingenieros software profesionales, incluidos practicantes, educadores, administradores, supervisores políticos, así como por aprendices estudiantes profesión. los principios identifican las relaciones éticamente responsables las que participan individuos, grupos organizaciones, así como las obligaciones principales dentro estas relaciones. las cláusulas cada principio son ilustraciones algunas las obligaciones incluidas dichas relaciones. tales obligaciones fundamentan sentido humano del ingeniero software, cuidado especial que debe las personas afectadas por trabajo los ingenieros software, los elementos únicos práctica ingeniería software. código las formula como obligaciones quienquiera que afirme aspire ser ingeniero software. cualquier situación donde distintos individuos tengan diferentes visiones obje- tivos, probable que usted enfrente dilemas éticos. por ejemplo, está desacuerdo, principio, con las políticas los ejecutivos más alto nivel compañía, ¿cómo reaccionaría? claramente, esto depende cada individuo naturaleza dis-crepancia. ¿ mejor argumentar caso para posición desde interior orga-nización renunciar principio? siente que existen problemas con proyecto software, ¿cuándo los reporta administración? los discute mientras apenas son indicio, puede estar exagerando reacción ante una situación; los deja para más tarde, quizá sea imposible resolver las dificultades. estos dilemas éticos los enfrentamos todos vida profesional , por fortuna, mayoría los casos son relativamente menores pueden resolverse sin demasiada dificultad. caso que puedan solucionarse, ingeniero afronta, tal vez, otro problema. acción basada los principios quizá sea renunciar empleo, aunque esta decisión bien podría afectar otros, como pareja sus hijos. una situación muy difícil para los ingenieros profesionales surge cuando emplea- dor actúa sin ética. decir, una compañía responsable del desarrollo sistema crítico seguridad , debido presión del tiempo, falsifica los registros validación seguridad. ¿ responsabilidad del ingeniero mantener confidencialidad alertar cliente manifestar, alguna forma, que sistema entregado quizá sea inseguro? problema aquí que hay absolutos cuando trata seguridad. aunque sis- tema pueda estar validado acuerdo con criterios predefinidos, dichos criterios quizá sean demasiado estrictos. realidad sistema operará con seguridad largo vida. también está caso que, aun cuando valide manera adecuada, sistema falle cause accidente. detección oportuna los problemas puede resultar lesiva para empleador otros trabajadores; fracaso por revelar los problemas podría ser dañino para otros. -.indd -.indd // :: // :: . ■ estudios caso lector debe formar propio criterio estos asuntos. aquí, posición ética ade- cuada depende por completo las percepciones los individuos que están implicados. este caso, potencial daño, alcance del mismo las personas afectadas deben influir decisión. escenario muy peligroso, estaría justificado anunciarlo través prensa nacional (por ejemplo). sin embargo, siempre hay que tratar resol-ver situación sin dejar respetar los derechos empleador. otro conflicto ético participación desarrollo sistemas militares nuclea- res. respecto, algunas personas sienten muy afectadas por estos temas evitan par-ticipar desarrollo algún sistema asociado con los sistemas militares. otras más trabajarán los sistemas militares, pero los armamento. incluso otras sentirán que seguridad nacional principio fundamental tienen objeciones éticas para trabajar sistemas armamento. tal situación importante que tanto empleadores como empleados dejen claro con antelación sus percepciones puntos vista. cuando una organización participa trabajo militar nuclear, debe contar con capacidad especificar que los emplea-dos tienen voluntad aceptar cualquier trabajo asignado. igual forma, empleado toma responsabilidad deja claro que quiere trabajar tales siste-mas, los empleadores tendrán que presionarlo para que éste haga más tarde. área general ética responsabilidad profesional vuelven más importan- tes conforme los sistemas intensivos software prevalecen cada vez más cuestiones del trabajo vida cotidiana. puede considerarse desde punto vista filosófico, donde tomen cuenta los principios básicos ética analice ética inge-niería software relación con dichos principios básicos. éste enfoque que toma laudon () , menor medida, huff martin (). texto johnson sobre ética computacional () también trata tema desde una perspectiva filosófica. sin embargo, este enfoque filosófico resulta muy abstracto difícil relacionar con experiencia cotidiana. preferible enfoque más concreto plasmado los códigos conducta práctica. considera que ética analiza mejor contexto ingeniería software como tema por derecho propio. por tanto, este libro presen-tan, donde adecuado, discusiones éticas abstractas, sino que incluyen ejemplos los ejercicios que son punto partida para una discusión grupal sobre conflictos éticos. . estudios caso para ilustrar los conceptos ingeniería software, largo del libro utilizan ejemplos tres tipos sistemas diferentes. razón usar solo estudio caso obedece que uno los mensajes clave este libro que práctica ingenie-ría software depende del tipo sistemas producir. por consiguiente, elegirá ejemplo adecuado cuando estudien conceptos como seguridad confiabilidad, mode-lado sistema, reutilización, etcétera. los tres tipos sistemas que usan como estudios caso son: . sistema embebido trata sistema donde software controla dis- positivo hardware está embebido dicho dispositivo. los conflictos los sistemas embebidos incluyen por general tamaño físico, capacidad reacción, -.indd -.indd // :: // :: capítulo ■ introducción administración energía, etcétera. ejemplo sistema embebido utilizado sistema software para controlar dispositivo médico. . sistema información sistema cuyo principal propósito gestionar dar acceso una base datos información. los conflictos los sistemas infor-mación incluyen seguridad, usabilidad, privacidad mantenimiento integridad los datos. sistema registros médicos utiliza como ejemplo sistema información. . sistema adquisición datos basado sensores trata sistema cuyo principal objetivo recolectar datos conjunto sensores procesar esos datos alguna forma. los requerimientos clave tales sistemas son fiabili-dad, incluso condiciones ambientes hostiles, capacidad mantenimiento. una estación meteorológica campo abierto ejemplo que usa como sistema adquisición datos. este capítulo introduce cada uno dichos sistemas, sobre todos ellos hay más información disponible web. .. sistema control para una bomba insulina una bomba insulina sistema médico que simula función del páncreas ( órgano interno). software que controla este sistema sistema embebido, que recopila informa-ción sensor controla una bomba que entrega usuario una dosis regulada insulina. las personas que sufren diabetes usan sistema. diabetes relativamente una condición común, donde páncreas humano incapaz producir suficientes cantida-des una hormona llamada insulina. insulina metaboliza glucosa (azúcar) sangre. tratamiento convencional diabetes incluye inyecciones regulares insu-lina genéticamente manipulada. los diabéticos calculan sus niveles azúcar sangre usando medidor externo , luego, ajustan dosis insulina que deben inyectarse. problema con este tratamiento que nivel insulina requerido depende sólo del nivel glucosa sangre, sino también del tiempo desde última inyec-ción insulina. esto podría conducir niveles muy bajos glucosa sanguínea ( hay mucha insulina) niveles muy altos azúcar sanguínea ( hay muy poca insulina). baja glucosa sanguínea , corto plazo, una condición más seria que puede resultar mal funcionamiento temporal del cerebro , finalmente, inconsciencia muerte. por otro lado, largo plazo los continuos niveles elevados glucosa sangre ocasio-nan daño ocular, renal problemas cardiacos. los avances recientes desarrollo sensores miniaturizados significan que ahora posible desarrollar sistemas automatizados suministro insulina. dichos sistemas monitorizan los niveles azúcar sangre , cuando requiere, administran una dosis adecuada insulina. los sistemas entrega insulina como éste existen para tratamiento pacientes hospitalarios. futuro, muchos diabéticos tendrán tales sistemas permanentemente unidos sus cuerpos. sistema suministro insulina controlado por software puede funcionar usar microsensor embebido paciente, con finalidad medir ciertos parámetros sanguíneos que sean proporcionales nivel azúcar. luego, esto envía controla-dor bomba, cual calcula nivel azúcar cantidad insulina que nece- -.indd -.indd // :: // :: pmsita. entonces envía señales una bomba miniaturizada para administrar insulina vía una aguja permanentemente unida. figura . muestra los componentes hardware organización bomba insulina. para entender los ejemplos, todo que necesita saber que sensor sangre mide conductividad eléctrica sangre bajo diferentes condiciones que dichos valo-res podrían relacionarse con nivel azúcar sangre. bomba insulina entrega una unidad insulina respuesta solo pulso controlador. por tanto, para entregar unidades insulina, controlador envía pulsos bomba. figura . modelo actividad uml que ilustra cómo software transforma una entrada nivel azúcar sangre, con una secuencia comandos que impulsan bomba insulina. claramente, éste sistema crítico seguridad. bomba opera hace manera correcta, entonces salud del usuario estaría grave riesgo éste caería estado coma debido que sus niveles azúcar sangre son muy altos muy bajos. con-secuencia, hay dos requerimientos esenciales alto nivel que debe satisfacer este sistema: . sistema tiene que estar disponible para entregar insulina cuando requiera. . sistema requiere funcionar manera confiable entregar cantidad correcta insulina, para contrarrestar nivel actual azúcar sangre.ensamble aguja sensor pantalla pantalla reloj controlador fuente poderdepósito insulina figura . hardware bomba insulina sensor sangre bomba insulinaazúcar sanguíneaanálisis lectura sensorcálculo insulina dosis insulinabitácora insulina bitácora dosiscálculo comandos bombadatos bombacontrol bomba insulina figura . modelo actividad bomba insulina. ■ estudios caso -.indd -.indd // :: // :: capítulo ■ introducción por consiguiente, sistema debe diseñarse implementarse para garantizar que siem- pre satisfaga dichos requerimientos. capítulos posteriores estudian requerimientos más detallados discute acerca cómo probar que sistema sea seguro. .. sistema información pacientes para atención salud mental sistema información pacientes para apoyar atención salud mental sistema información médica, que administra información pacientes que sufren problemas salud mental los tratamientos que reciben. mayoría los pacientes con problemas salud mental requieren tratamiento hospitalario dedicado, pero asistir regularmente clínicas especializadas donde reúnen con médico que tiene conocimiento detallado sus problemas. para facilitar asistencia los pacientes, dichas clínicas sólo funcionan los hospitales sino también consultorios médicos locales centros comunitarios. mhc-pms (sistema administración pacientes-atención salud mental) sistema información destinado para usarse clínicas. utiliza una base datos centralizada con información los pacientes, aunque también diseñó para operarse desde una , modo que puede acceder ella usarse desde sitios sin conectivi-dad red segura. cuando los sistemas locales tienen acceso seguro red, emplean información los pacientes base datos, pero además son capaces descargar usar copias locales registros pacientes cuando los sistemas están desconecta-dos. sistema sistema registros médicos completo, por que conserva información acerca otras condiciones médicas. sin embargo, interactúa intercambia datos con otros sistemas información clínica. figura . ilustra organización del mhc-pms. mhc-pms tiene dos metas globales: . generar información gestión que permita los administradores servicios salud valorar desempeño contra objetivos locales gobierno. . proporcionar personal médico información oportuna para apoyar tratamiento los pacientes. servidor mhc-pms base datos del pacientelocal mhc-pmslocal mhc-pmslocal mhc-pms figura . organización del mhc-pms -.indd -.indd // :: // :: pmla naturaleza los problemas salud mental tal que los pacientes hallan con frecuencia desorganizados suelen faltar sus citas, deliberada accidentalmente, perder recetas medicamentos, olvidar instrucciones realizar demandas irracionales personal médico. pueden llegar las clínicas manera inesperada. muy pocos casos, son riesgo para mismos para otros individuos. regularmente pueden cambiar dirección tener casa corto largo plazo. cuando los pacientes son peligrosos, quizá deban “internarse”: confinarse hospital seguro para tratamiento observación. los usuarios del sistema incluyen personal clínico como médicos, enfermeros visi- tadores salud (enfermeros que visitan las personas domicilio para verificar tratamiento). los usuarios médicos incluyen recepcionistas que hacen citas, personal archivo médico que organiza sistema registros, personal administrativo que redacta informes. sistema sirve para registrar información pacientes (nombre, dirección, edad, - riente más cercano, etcétera), consultas (fecha, médico, impresiones personales del pacien-, etcétera), condiciones tratamientos. los informes elaboran intervalos regulares para personal médico los administradores autoridad sanitaria. por general, los reportes para personal médico enfocan información individual pacien-tes, mientras que los reportes administración son anónimos interesan por las condiciones, costos tratamiento, etcétera. las características clave del sistema son: . administración atención individual los médicos atención primaria crean registros para pacientes, editan información sistema, ven historial del paciente, etcétera. sistema soporta resúmenes datos para que los médicos que reunieron con anterioridad con paciente enteren rápidamente los pro-blemas tratamientos clave que prescribieron. . monitorización del paciente sistema monitoriza regularmente los registros los pacientes que están involucrados tratamiento emite advertencias cuando detectan posibles dificultades. consecuencia, paciente visto médico durante cierto tiempo, puede emitirse una advertencia. uno los elementos más importantes del sistema monitorización seguir pista los pacientes que fueron internados garantizar que las verificaciones requeridas legalmente lleven cabo tiempo correcto. . informes administrativos sistema genera mensualmente informes administra- tivos que muestran número pacientes tratados cada clínica, cantidad pacientes que ingresaron salieron del sistema salud, total pacientes inter-nados, los medicamentos prescritos sus costos, etcétera. dos leyes diferentes afectan sistema. trata leyes protección datos que rigen confidencialidad información personal, las leyes salud mental, que esta-blecen detención obligatoria los pacientes considerados como peligro para mis-mos para otros. salud mental única este aspecto, pues única especialidad médica que puede recomendar detención pacientes contra voluntad éstos, cual está sujeto protecciones legislativas muy estrictas. una las metas del mhc-pms asegurar que personal siempre actúe concordancia con ley que sus decisiones, necesario, registren para revisión judicial. como todos los sistemas médicos, privacidad requerimiento sistema crí- tico. básico que información los pacientes sea confidencial nunca revele nadie . ■ estudios caso -.indd -.indd // :: // :: capítulo ■ introducción más, aparte del personal médico autorizado los mismos pacientes. mhc-pms también sistema crítico seguridad. algunas patologías mentales hacen que los pacientes vuelvan suicidas peligro para otros individuos. siempre que sea posible, sistema debe advertir personal médico acerca pacientes potencialmente suicidas peligrosos. diseño global del sistema debe considerar requerimientos privacidad seguridad. sistema tiene que estar disponible cuando necesite, otro modo seguridad estaría comprometida sería imposible prescribir los pacientes medicamento correcto. aquí existe conflicto potencial: privacidad más fácil mantener cuando existe sólo una copia los datos del sistema. sin embargo, para garantizar disponibilidad caso fallas del servidor desconexión una red, hay que conservar varias copias los datos. capítulos posteriores analizan las preferencias temporales entre tales requerimientos. .. estación meteorológica campo abierto para ayudar monitorizar cambio climático mejorar exactitud las predicciones meteorológicas áreas remotas, gobierno país con grandes áreas campo abierto decidió instalar varios cientos estaciones meteorológicas dichas áreas. las estaciones meteorológicas recopilan datos conjunto instrumentos que miden temperatura presión, luz solar, lluvia, rapidez dirección del viento. las estaciones meteorológicas campo abierto son parte sistema más grande (figura .), que sistema información meteorológica que recolecta datos esta-ciones meteorológicas los pone disposición otros sistemas para procesamiento. los sistemas figura . son: . sistema estación meteorológica responsable recolectar datos meteo- rológicos, realizar cierto procesamiento datos inicial transmitirlo sistema gestión datos. . sistema gestión archivado datos recolecta los datos todas las esta-ciones meteorológicas campo abierto, realiza procesamiento análisis datos, los archiva forma que los puedan recuperar otros sistemas, como los sistemas predicción meteorológica. . sistema mantenimiento estación comunica por satélite con todas las estaciones meteorológicas campo abierto, para monitorizar estado dichos sistemas dar reportes sobre problemas. puede actualizar software embebido dichos sistemas. caso problemas del sistema, también sirve para controlar manera remota sistema meteorológico campo abierto.«sistema» gestión archivado datos «sistema» mantenimiento estación«sistema» estación meteorológica figura . entorno estación meteorológica -.indd -.indd // :: // :: pmen figura . usó símbolo paquete uml para indicar que cada sistema una colección componentes, identificaron los sistemas separados usando este- reotipo uml «sistema». las asociaciones entre los paquetes indican que ahí existe intercambio información pero, esta etapa, hay necesidad definirlos con más detalle. cada estación meteorológica incluye algunos instrumentos que miden parámetros cli- matológicos como rapidez dirección del viento, temperaturas del terreno aire, presión barométrica lluvia durante periodo horas. cada uno dichos instrumentos está controlado por sistema software que toma periódicamente lecturas paráme-tros gestiona los datos recolectados desde los instrumentos. sistema estación meteorológica opera mediante recolección observacio- nes meteorológicas intervalos frecuentes; por ejemplo, las temperaturas miden cada minuto. sin embargo, puesto que ancho banda del satélite relativamente estrecho, estación meteorológica realiza cierto procesamiento local concentración los datos. luego, transmite los datos concentrados cuando los solicita sistema adquisición datos. pero , por cualquier razón, imposible realizar una conexión, entonces esta-ción meteorológica mantiene los datos localmente hasta que reanude comunicación. cada estación meteorológica alimentada por baterías debe estar completamente autocontenida: hay fuentes energía externas cables red disponibles. todas las comunicaciones son través vínculo satelital rapidez relativamente baja, estación meteorológica debe incluir algún mecanismo (solar eólico) para cargar sus baterías. puesto que despliegan áreas abiertas, están expuestas severas condicio-nes ambientales los animales llegan dañarlas. por tanto, software estación sólo encarga adquisición datos. también debe: . monitorizar los instrumentos, energía hardware comunicación, reportar los fallas sistema administración. . administrar energía del sistema, garantizar que las baterías estén cargadas siempre que las condiciones ambientales permitan; así como desconectar los generadores ante condiciones meteorológicas potencialmente adversas, como viento fuerte. . permitir reconfiguración dinámica donde partes del software sustituyan con nuevas versiones, los instrumentos respaldo enciendan sistema caso falla éste. puesto que las estaciones meteorológicas deben estar autocontenidas sin vigilancia, esto significa que software instalado complejo, aun cuando funcionalidad adquisición datos sea bastante simple.. ■ estudios caso -.indd -.indd // :: // :: capítulo ■ introducción puntos clave ■ ingeniería software una disciplina ingeniería que interesa por todos los aspectos producción software. ■ software sólo programa programas, sino que también incluye documentación. los atributos esenciales los productos software son mantenimiento, confiabilidad, seguridad, eficiencia aceptabilidad. ■ proceso software incluye todas las actividades que intervienen desarrollo software. las actividades alto nivel especificación, desarrollo, validación evolución son parte todos los procesos software. ■ las nociones fundamentales ingeniería software son universalmente aplicables todos los tipos desarrollo sistema. dichos fundamentos incluyen procesos, confiabilidad, seguridad, requerimientos reutilización software. ■ existen muchos tipos diferentes sistemas cada uno requiere para desarrollo herramientas técnicas adecuadas ingeniería software. existen pocas, que hay alguna, técnicas específicas diseño implementación que son aplicables todos los tipos sistemas. ■ las ideas fundamentales ingeniería software son aplicables todos los tipos sistemas software. dichos fundamentos incluyen procesos administración software, confiabilidad seguridad del software, ingeniería requerimientos reutilización software. ■ los ingenieros software tienen responsabilidades con profesión ingeniería sociedad. deben preocuparse únicamente por temas técnicos. ■ las sociedades profesionales publican códigos conducta que establecen los estándares comportamiento esperados sus miembros. lecturas sugeridas “ silver bullet: essence and accidents software engineering”. pesar fecha publicación, este artículo una buena introducción general los problemas ingeniería software. mensaje esencial del artículo cambiado. (. . brooks, ieee computer, (), abril .) http://doi.ieeecomputersociety.org/./... “software engineering code ethics approved”. artículo que analiza fondo los antecedentes para desarrollo del código ética acm/ieee que incluye las formas corta larga del código. (comm. acm, . gotterbarn, . miller, . rogerson, octubre .) http://portal.acm.org/citation.cfm?doid=.. professional issues software engineering. éste excelente libro que examina conflictos legales profesionales, así como éticos. autor prefiere enfoque práctico textos más teóricos acerca ética. (. bott, . coleman, . eaton . rowland, . edición, , taylor and francis.) capítulo ■ introducción -.indd -.indd // :: // :: pmcapítulo ■ ejercicios ieee software, march/april . éste número especial revista dedicado desarrollo software basado web. esta área cambiado muy rápidamente, modo que algunos artículos son poco arcaicos, pero mayoría todavía son relevantes. ( ieee software, (), .) http:/ /www. computer. org/ portal/ web/ software. “ view and century software engineering”. vistazo atrás adelante ingeniería software uno los primeros más distinguidos ingenieros software. barry boehm identifica principios atemporales ingeniería software, pero también sugiere que algunas prácticas uso común son obsoletas. (. boehm, proc. software engineering conf., shanghai. .) http://doi.ieeecomputersociety.org/./.. “software engineering ethics”. número especial ieee computer, con algunos artículos acerca del tema. (ieee computer, (), junio .) ejercicios .. explique por qué software profesional sólo son programas que desarrollan para cliente. .. ¿cuál principal diferencia entre desarrollo productos software genéricos desarrollo software personalizado? ¿qué significa esto práctica para los usuarios productos software genérico? .. ¿cuáles son los cuatro atributos importantes que debe tener todo software profesional? sugiera otros cuatro atributos que ocasiones sean significativos. .. además los retos heterogeneidad, cambio empresarial social, confianza seguridad, identifique otros problemas retos que sea probable que enfrente ingeniería software siglo xxi. (sugerencia: piense ambiente). .. con base conocimiento algunos tipos aplicación estudiados sección .., explique, con ejemplos, por qué diferentes tipos aplicación requieren técnicas especializadas ingeniería software, para apoyar diseño desarrollo. .. explique por qué existen ideas fundamentales ingeniería software que aplican todos los tipos sistemas software. .. explique cómo uso universal web cambió los sistemas software. .. analice hecho los ingenieros profesionales deben ser certificados misma forma que los médicos abogados. .. para cada una las cláusulas del código ética acm/ieee que muestra figura ., sugiera ejemplo adecuado que ilustre dicha cláusula. .. para ayudar contrarrestar terrorismo, muchos países planean desarrollaron sistemas cómputo que siguen pista gran cantidad sus ciudadanos sus acciones. claramente esto tiene implicaciones cuanto privacidad. discuta ética trabajar desarrollo este tipo sistema. -.indd -.indd // :: // :: capítulo ■ introducción referencias gotterbarn, ., miller, . rogerson, . (). software engineering code ethics approved. comm. acm, (), –. holdener, . . (). ajax: the definitive guide. sebastopol, .: ’reilly and associates.huff, . martin, . . (). computing consequences: framework for teaching ethical computing. comm. acm, (), –. johnson, . . (). computer ethics. englewood cliffs, : prentice hall.laudon, . (). ethical concepts and information technology. comm. acm, (), –. naur, . randell, . (). ingeniería software: reporte una conferencia patrocinada por comité científico otan, garmisch, alemania, octubre . -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo hacia idea proceso software: conjunto coherente actividades para producción software. estudiar este capítulo: ■ comprenderá los conceptos modelos sobre procesos software; ■ introducirá los tres modelos proceso software genérico sabrá cuándo usarlos; ■ entenderá las principales actividades del proceso ingeniería requerimientos software, así como del desarrollo, las pruebas evolución del software; ■ comprenderá por qué deben organizarse los procesos para enfrentar los cambios los requerimientos diseño software; ■ entenderá cómo proceso unificado racional (rational unified process, rup) integra buenas prácticas ingeniería software para crear procesos software adaptables. contenido . modelos proceso software . actividades del proceso. cómo enfrentar cambio. proceso unificado racional procesos software -.indd -.indd // :: // :: capítulo ■ procesos software proceso software una serie actividades relacionadas que conduce elabora- ción producto software. estas actividades pueden incluir desarrollo software desde cero lenguaje programación estándar como java . sin embargo, las aplicaciones negocios desarrollan precisamente esta forma. nuevo software empresarial con frecuencia ahora desarrolla extendiendo modificando los sistemas existentes, configurando integrando software comercial componentes del sistema. existen muchos diferentes procesos software, pero todos deben incluir cuatro acti-vidades que son fundamentales para ingeniería software: . especificación del software tienen que definirse tanto funcionalidad del soft- ware como las restricciones operación. . diseño implementación del software debe desarrollarse software para cumplir con las especificaciones. . validación del software hay que validar software para asegurarse que cumple que cliente quiere. . evolución del software software tiene que evolucionar para satisfacer las necesi-dades cambiantes del cliente. cierta forma, tales actividades forman parte todos los procesos software. por supuesto, práctica éstas son actividades complejas mismas incluyen subactividades tales como validación requerimientos, diseño arquitectónico, prueba unidad, etcétera. también existen actividades soporte proceso, como documentación manejo configuración del software. cuando los procesos discuten describen, por general habla actividades como especificar modelo datos, diseñar una interfaz usuario, etcétera, así como del orden dichas actividades. sin embargo, igual que las actividades, también las des-crip ciones los procesos deben incluir: . productos, que son los resultados una actividad del proceso. por ejemplo, resultado actividad del diseño arquitectónico modelo arquitectura software. . roles, que reflejan las responsabilidades gente que interviene proceso. ejemplos roles: gerente proyecto, gerente configuración, programador, etcétera. . precondiciones postcondiciones, que son declaraciones válidas antes después que realice una actividad del proceso cree producto. por ejemplo, antes comenzar diseño arquitectónico, una precondición que cliente haya apro-bado todos los requerimientos; después terminar esta actividad, una postcondición podría ser que revisen aquellos modelos uml que describen arquitectura. los procesos software son complejos , como todos los procesos intelectuales creativos, apoyan personas con capacidad juzgar tomar decisiones. hay proceso ideal; además, mayoría las organizaciones han diseñado sus propios procesos desarrollo software. los procesos han evolucionado para beneficiarse las capacidades gente una organización las características específicas los -.indd -.indd // :: // :: . ■ modelos proceso software sistemas que están desarrollando. para algunos sistemas, como los sistemas críticos, requiere proceso desarrollo muy estructurado. para los sistemas empresariales, con requerimientos rápidamente cambiantes, probable que sea más efectivo pro-ceso menos formal flexible. ocasiones, los procesos software clasifican como dirigidos por plan (plan-driven) como procesos ágiles. los procesos dirigidos por plan son aquellos donde todas las actividades del proceso planean por anticipado avance mide contra dicho plan. los procesos ágiles, que estudiarán capítulo , planeación incremental más fácil modificar proceso para reflejar los requerimientos cambian-tes del cliente. como plantean boehm turner (), cada enfoque adecuado para diferentes tipos software. por general, uno necesita encontrar equilibrio entre procesos dirigidos por plan procesos ágiles. aunque hay proceso software “ideal”, muchas organizaciones existe ámbito para mejorar proceso software. los procesos quizás incluyan técnicas obsoletas tal vez aprovechen las mejores prácticas industria ingeniería software. efecto, muchas organizaciones aún sacan ventaja los métodos ingeniería software desarrollo software. los procesos software pueden mejorarse con estandarización los procesos, donde reduce diversidad los procesos software una organización. esto con-duce mejorar comunicación, reducir tiempo capacitación, que soporte los procesos automatizados sea más económico. estandarización también representa primer paso importante tanto introducción nuevos métodos técnicas ingenie-ría software, como sus buenas prácticas. capítulo analiza con más detalle mejora proceso software. . modelos proceso software como explicó capítulo , modelo proceso software una representa-ción simplificada este proceso. cada modelo del proceso representa otro desde una particular perspectiva , por tanto, ofrece sólo información parcial acerca dicho proceso. por ejemplo, modelo actividad del proceso muestra las actividades secuencia, pero quizá sin presentar los roles las personas que intervienen esas actividades. esta sección introducen algunos modelos proceso muy generales ( ocasiones llamados “paradigmas proceso”) muestran desde una perspectiva arquitectónica. otras palabras, marco (framework) del proceso, pero los detalles las actividades específicas. tales modelos genéricos son descripciones definitivas los procesos software. más bien, son abstracciones del proceso que utilizan para explicar los diferentes enfo-ques del desarrollo software. pueden considerar marcos del proceso que extien-den adaptan para crear procesos más específicos ingeniería software. los modelos del proceso que examinan aquí son: . modelo cascada ( waterfall) éste toma las actividades fundamentales del proceso especificación, desarrollo, validación evolución , luego, los repre- senta como fases separadas del proceso, tal como especificación requerimientos, diseño software, implementación, pruebas, etcétera. -.indd -.indd // :: // :: capítulo ■ procesos software . desarrollo incremental este enfoque vincula las actividades especificación, desarrollo validación. sistema desarrolla como una serie versiones (incre- mentos), cada versión añade funcionalidad versión anterior. . ingeniería software orientada reutilización este enfoque basa existencia número significativo componentes reutilizables. proceso desarrollo del sistema enfoca integración estos componentes sis-tema, vez desarrollarlo desde cero. dichos modelos son mutuamente excluyentes con frecuencia usan con-junto, sobre todo para desarrollo grandes sistemas. para este tipo sistemas, tiene sentido combinar algunas las mejores características los modelos desarrollo cascada incremental. necesita contar con información sobre los requerimientos esenciales del sistema para diseñar arquitectura software que apoye dichos reque-rimientos. puede desarrollarse manera incremental. los subsistemas dentro sistema más grande desarrollan usando diferentes enfoques. partes del sistema que son bien comprendidas pueden especificarse desarrollarse utilizar proceso basado cascada. partes del sistema que por adelantado son difíciles especificar, como interfaz usuario, siempre deben desarrollarse con enfoque incremental. .. modelo cascada primer modelo publicado sobre proceso desarrollo software derivó partir procesos más generales ingeniería sistemas (royce, ). este modelo ilus-tra figura .. debido paso una fase cascada otra, este modelo conoce como “modelo cascada” ciclo vida del software. modelo cascada ejemplo proceso dirigido por plan; principio, usted debe planear programar todas las actividades del proceso, antes comenzar trabajar con ellas.definición requerimientos diseño del sistema del software implementación prueba unidad integración prueba del sistema operación mantenimiento figura . modelo cascada -.indd -.indd // :: // :: . ■ modelos proceso software las principales etapas del modelo cascada reflejan directamente las actividades fundamentales del desarrollo: . análisis definición requerimientos los servicios, las restricciones las metas del sistema establecen mediante consulta los usuarios del sistema. luego, definen con detalle sirven como una especificación del sistema. . diseño del sistema del software proceso diseño sistemas asigna los reque- rimientos, para sistemas hardware software, establecer una arquitectura sistema global. diseño del software implica identificar describir las abstraccio-nes fundamentales del sistema software sus relaciones. . implementación prueba unidad durante esta etapa, diseño software rea liza como conjunto programas unidades del programa. prueba uni-dad consiste verificar que cada unidad cumpla con especificación. . integración prueba sistema las unidades del programa los programas indivi- duales integran prueban como sistema completo para asegurarse que cumplan los requerimientos software. después probarlo, libera sistema software cliente. . operación mantenimiento por general (aunque necesariamente), ésta fase más larga del ciclo vida, donde sistema instala pone práctica. mantenimiento incluye corregir los errores que detectaron etapas anteriores del ciclo vida, mejorar implementación las unidades del sistema incremen-tar los servicios del sistema conforme descubren nuevos requerimientos. principio, resultado cada fase consiste uno más documentos que auto-rizaron (“firmaron”). siguiente fase debe comenzar sino hasta que termine fase previa. práctica, dichas etapas traslapan nutren mutuamente información. durante diseño identifican los problemas con los requerimientos. codificación descubren problemas diseño, así sucesivamente. proceso software simple modelo lineal, sino que implica retroalimentación una fase otra. entonces, posible que los documentos generados cada fase deban modificarse para reflejar los cambios que realizan. debido los costos producción aprobación documentos, las iteraciones suelen ser onerosas implicar rediseño significativo. por tanto, después pequeño número iteraciones, normal detener partes del desarrollo, como especificación, continuar con etapas desarrollo posteriores. los problemas dejan para una reso-lución posterior, ignoran programan. este freno prematuro los requerimientos quizá signifique que sistema hará que usuario desea. también podría conducir sistemas mal estructurados conforme los problemas diseño evadan con imple-mentación trucos. durante fase final del ciclo vida (operación mantenimiento), software pone servicio. descubren los errores las omisiones los requerimientos origi-nales del software. surgen los errores programa diseño, detecta necesidad nueva funcionalidad. por tanto, sistema debe evolucionar para mantenerse útil. hacer tales cambios (mantenimiento software) puede implicar repetición etapas anteriores del proceso. -.indd -.indd // :: // :: capítulo ■ procesos software ingeniería software cuarto limpio ejemplo del proceso desarrollo formal, diseñado originalmente por ibm, proceso cuarto limpio (cleanroom). proceso cuarto limpio, cada incremento software especifica formalmente tal especificación transforma una implementación. exactitud del software demuestra mediante enfoque formal. hay prueba unidad para defectos proceso prueba del sistema enfoca valoración fiabilidad del sistema. objetivo del proceso cuarto limpio obtener software con cero defectos, modo que los sistemas que entreguen cuenten con alto nivel fiabilidad. http:// modelo cascada consecuente con otros modelos del proceso ingeniería cada fase produce documentación. esto hace que proceso sea visible, modo que los administradores monitoricen progreso contra plan desarrollo. principal problema partición inflexible del proyecto distintas etapas. tienen que estable-cerse compromisos una etapa temprana del proceso, que dificulta responder los requerimientos cambiantes del cliente. principio, modelo cascada sólo debe usarse cuando los requerimientos entiendan bien sea improbable cambio radical durante desarrollo del sistema. sin embargo, modelo cascada refleja tipo proceso utilizado otros proyectos ingeniería. como más sencillo emplear modelo gestión común durante todo pro-yecto, aún son uso común los procesos software basados modelo cascada. una variación importante del modelo cascada desarrollo sistemas forma-les, donde crea modelo matemático para una especificación del sistema. después corrige este modelo, mediante transformaciones matemáticas que preservan consis-tencia código ejecutable. con base suposición que son correctas sus trans-formaciones matemáticas, puede aseverar, por tanto, que programa generado esta forma consecuente con especificación. los procesos formales desarrollo, como que basa método (schneider, ; wordsworth, ) son muy adecuados para desarrollo sistemas que cuenten con rigurosos requerimientos seguridad, fiabilidad protección. enfoque formal simplifica producción caso protección seguridad. esto demuestra los clientes reguladores que sistema realidad cumple sus requerimientos protec-ción seguridad. los procesos basados transformaciones formales usan por general sólo desarrollo sistemas críticos para protección seguridad. requieren experiencia espe-cializada. para mayoría los sistemas, este proceso ofrece costo/beneficio signifi-cativos sobre otros enfoques desarrollo sistemas. .. desarrollo incremental desarrollo incremental basa idea diseñar una implementación inicial, expo-ner ésta comentario del usuario, luego desarrollarla sus diversas versiones hasta producir sistema adecuado (figura .). las actividades especificación, desarrollo -.indd -.indd // :: // :: . ■ modelos proceso software validación están entrelazadas vez separadas, con rápida retroalimentación tra- vés las actividades. desarrollo software incremental, que una parte fundamental los enfoques ágiles, mejor que enfoque cascada para mayoría los sistemas empresaria-les, comercio electrónico personales. desarrollo incremental refleja forma que resuelven problemas. rara vez trabaja por adelantado una solución completa del problema, más bien avanza una serie pasos hacia una solución retro-cede cuando detecta que cometieron errores. desarrollar software manera incremental, resulta más barato fácil realizar cambios software conforme éste diseña. cada incremento versión del sistema incorpora algunas las funciones que nece-sita cliente. por general, los primeros incrementos del sistema incluyen función más importante más urgente. esto significa que cliente puede evaluar desarrollo del sistema una etapa relativamente temprana, para constatar entrega que requiere. caso contrario, sólo incremento actual debe cambiarse , posiblemente, definir una nueva función para incrementos posteriores. comparado con modelo cascada, desarrollo incremental tiene tres beneficios importantes: . reduce costo adaptar los requerimientos cambiantes del cliente. cantidad análisis documentación que tiene que reelaborarse son mucho menores requerido con modelo cascada. . más sencillo obtener retroalimentación del cliente sobre trabajo desarro- llo que realizó. los clientes pueden comentar las demostraciones del software darse cuenta cuánto implementado. los clientes encuentran difícil juzgar avance partir documentos diseño software. . posible que sea más rápida entrega implementación software útil cliente, aun incluido toda funcionalidad. los clientes tienen posibilidad usar ganar valor del software más temprano que sería posible con proceso cascada.actividades concurrentes validaciónversión finaldesarrolloversiones intermediasespecificaciónversión inicial bosquejo descripción figura . desarrollo incremental -.indd -.indd // :: // :: capítulo ■ procesos software problemas con desarrollo incremental aunque desarrollo incremental tiene muchas ventajas, está exento problemas. principal causa dificultad hecho que las grandes organizaciones tienen procedimientos burocráticos que han evolucionado con tiempo pueden suscitar falta coordinación entre dichos procedimientos proceso iterativo ágil más informal. ocasiones, tales procedimientos hallan ahí por buenas razones: por ejemplo, pueden existir procedimientos para garantizar que software implementa manera adecuada regulaciones externas ( estados unidos, por ejemplo, las regulaciones contabilidad sarbanes-oxley). cambio tales procedimientos podría resultar imposible, manera que los conflictos son inevitables. http:// desarrollo incremental ahora cierta forma enfoque más común para desa- rrollo sistemas aplicación. este enfoque puede estar basado plan, ser ágil , más usualmente, una mezcla dichos enfoques. enfoque basado plan identifi-can por adelantado los incrementos del sistema; adopta enfoque ágil, detectan los primeros incrementos, aunque desarrollo incrementos posteriores depende del avance las prioridades del cliente. desde una perspectiva administrativa, enfoque incremental tiene dos problemas: . proceso visible. los administradores necesitan entregas regulares para medir avance. los sistemas desarrollan rápidamente, resulta poco efectivo términos costos producir documentos que reflejen cada versión del sistema. . estructura del sistema tiende degradarse conforme tienen nuevos incremen- tos. menos que gaste tiempo dinero refactorización para mejorar soft-ware, cambio regular tiende corromper estructura. incorporación más cambios software vuelve cada vez más difícil costosa. los problemas del desarrollo incremental tornan particularmente agudos para sis-temas grandes, complejos larga duración, donde diversos equipos desarrollan dife-rentes partes del sistema. los grandes sistemas necesitan marco una arquitectura estable necesario definir con claridad, respecto dicha arquitectura, las responsabili-dades los distintos equipos que trabajan partes del sistema. esto debe planearse por adelantado vez desarrollarse manera incremental. puede desarrollar sistema incremental exponerlo los clientes para comen-tario, sin realmente entregarlo implementarlo entorno del cliente. entrega implementación incrementales significan que software usa procesos operaciona-les reales. esto siempre posible, que experimentación con nuevo software llega alterar los procesos empresariales normales. sección .. estudian las ventajas desventajas entrega incremental. -.indd -.indd // :: // :: . ■ modelos proceso software .. ingeniería software orientada reutilización mayoría los proyectos software hay cierta reutilización software. sucede con frecuencia manera informal, cuando las personas que trabajan proyecto cono-cen diseños códigos que son similares que requiere. los buscan, los modifican según necesite los incorporan sus sistemas. esta reutilización informal ocurre independientemente del proceso desarrollo que emplee. sin embargo, siglo xxi, los procesos desarrollo software que enfoca- ban reutilización software existente utilizan ampliamente. los enfoques orienta- dos reutilización apoyan una gran base componentes software reutilizable integración marcos para composición dichos componentes. ocasiones, tales componentes son sistemas por derecho propio (sistemas comerciales, off-the-shelf cots) que pueden mejorar funcionalidad específica, como procesador textos hoja cálculo. figura . muestra modelo del proceso general para desarrollo basado reutilización. aunque etapa inicial especificación requerimientos etapa validación comparan con otros procesos software proceso orientado reutilización, las etapas intermedias son diferentes. dichas etapas son: . análisis componentes dada especificación requerimientos, realiza una búsqueda componentes para implementar dicha especificación. por general, hay coincidencia exacta los componentes que usan proporcionan sólo parte funcionalidad requerida. . modificación requerimientos durante esta etapa analizan los requerimien- tos usando información los componentes descubiertos. luego modifican para reflejar los componentes disponibles. donde las modificaciones son imposibles, puede regresarse actividad análisis componentes para buscar soluciones alternativas. . diseño sistema con reutilización durante esta fase diseña marco concep- tual del sistema reutiliza marco conceptual existente. los creadores toman cuenta los componentes que reutilizan organizan marco referencia para atenderlo. posible que deba diseñarse algo software nuevo, están dispo-nibles los componentes reutilizables. . desarrollo integración diseña software que puede procurarse manera externa, integran los componentes los sistemas cots para crear nuevo sistema. integración del sistema, este modelo, puede ser parte del proceso desarrollo, vez una actividad independiente.especificación requerimientosanálisis componentes desarrollo integracióndiseño sistema con reutilizaciónmodificación requerimientos validación del sistemafigura . ingeniería software orientada reutilización -.indd -.indd // :: // :: capítulo ■ procesos software existen tres tipos componentes software que pueden usarse proceso orien- tado reutilización: . servicios web que desarrollan concordancia para atender servicios estándares que están disponibles para invocación remota. . colecciones objetos que desarrollan como paquete para integración con marco componentes como .net . . sistemas software independientes que configuran para usar entorno par- ticular. ingeniería software orientada reutilización tiene clara ventaja reducir cantidad software desarrollar , por tanto, disminuir costos riesgos; por general, también conduce entregas más rápidas del software. sin embargo, son inevitables los compromisos requerimientos esto conduciría hacia sistema que cubra las necesidades reales los usuarios. más aún, pierde algo control sobre evolución del sistema, conforme las nuevas versiones los componentes reutilizables estén bajo control organización que los usa. reutilización software muy importante tercera parte del libro dedican varios capítulos este tema. capítulo tratan los conflictos generales reutili-zación software reutilización cots, los capítulos estudia niería software basada componentes, capítulo explican los sistemas orientados servicio. . actividades del proceso los procesos software real son secuencias entrelazadas actividades técnicas, colabo-rativas administrativas con meta general especificar, diseñar, implementar pro-bar sistema software. los desarrolladores software usan trabajo diferentes herramientas software. las herramientas son útiles particularmente para dar apoyo edición distintos tipos documento para manejar inmenso volumen informa-ción detallada que reproduce gran proyecto software. las cuatro actividades básicas proceso especificación, desarrollo, validación evolución organizan diversa manera diferentes procesos desarrollo. modelo cascada organizan secuencia, mientras que entrelazan desarro-llo incremental. forma que llevan cabo estas actividades depende del tipo software, del personal inclusión estructuras organizativas. programación extrema, por ejemplo, las especificaciones escriben tarjetas. las pruebas son ejecu-tables desarrollan antes del programa . evolución incluye reestructuración refactorización sustancial del sistema. .. especificación del software especificación del software ingeniería requerimientos consisten proce- comprender definir qué servicios requieren del sistema, así como identifica-ción las restricciones sobre operación desarrollo del sistema. ingeniería requerimientos una etapa particularmente crítica del proceso software, que los -.indd -.indd // :: // :: . ■ actividades del proceso errores esta etapa conducen manera inevitable problemas posteriores tanto diseño como implementación del sistema. proceso ingeniería requerimientos (figura .) enfoca producir docu-mento requerimientos convenido que especifique los requerimientos los interesados que cumplirá sistema. por general, los requerimientos presentan dos niveles detalle. los usuarios finales clientes necesitan informe requerimientos alto nivel; los desarrolladores sistemas precisan una descripción más detallada del sistema. existen cuatro actividades principales proceso ingeniería requerimientos: . estudio factibilidad realiza una estimación sobre las necesidades identifi- cadas del usuario cubren con las actuales tecnologías software hardware. estudio considera sistema propuesto tendrá costo-beneficio desde punto vista empresarial, éste puede desarrollarse dentro las restricciones pre-supuestales existentes. estudio factibilidad debe ser rápido relativamente barato. resultado debe informar decisión respecto continúa continúa con análisis más detallado. . obtención análisis requerimientos éste proceso derivar los requeri-mientos del sistema mediante observación los sistemas existentes, discusiones con los usuarios proveedores potenciales, análisis tareas, etcétera. esto puede incluir desarrollo uno más modelos sistemas prototipos, que ayuda entender sistema que especificar.herramientas desarrollo software las herramientas desarrollo del software (llamadas ocasiones herramientas ingeniería software asistido por computadora case, por las siglas computer-aided software engineering) son programas usados para apoyar las actividades del proceso ingeniería software. consecuencia, estas herramientas incluyen editores diseño, diccionarios datos, compiladores, depuradores ( debuggers), herramientas construcción sistema, etcétera. las herramientas software ofrecen apoyo proceso automatizar algunas actividades del proceso brindar información sobre software que desarrolla. los ejemplos actividades susceptibles automatizarse son: ■ desarrollo modelos sistemas gráficos, como parte especificación requerimientos del diseño del software. ■ generación código partir dichos modelos sistemas gráficos. ■ producción interfaces usuario partir una descripción interfaz gráfica, creada por usuario manera interactiva. ■ depuración del programa mediante suministro información sobre programa que ejecuta. ■ traducción automatizada programas escritos, usando una versión anterior lenguaje programación para tener una versión más reciente. las herramientas pueden combinarse marco llamado ambiente desarrollo interactivo ide (por las siglas interactive development environment). esto ofrece conjunto común facilidades, que usan las herramientas para comunicarse operar con mayor destreza una forma integrada. eclipse ide usa ampliamente diseñó para incorporar muchos tipos diferentes herramientas software. http:// -.indd -.indd // :: // :: capítulo ■ procesos software . especificación requerimientos consiste actividad transcribir informa- ción recopilada durante actividad análisis, documento que define con-junto requerimientos. este documento incluyen dos clases requerimientos. los requerimientos del usuario son informes abstractos requerimientos del sistema para cliente usuario final del sistema; los requerimientos sistema son una descripción detallada funcionalidad ofrecer. . validación requerimientos esta actividad verifica que los requerimientos sean realistas, coherentes completos. durante este proceso inevitable descubrir errores documento requerimientos. consecuencia, deberían modificarse con finalidad corregir dichos problemas. desde luego, las actividades proceso requerimientos realizan simple-mente una secuencia estricta. análisis requerimientos continúa durante defini-ción especificación, largo del proceso salen luz nuevos requerimientos; por tanto, las actividades análisis, definición especificación están vinculadas. los métodos ágiles, como programación extrema, los requerimientos desarrollan manera incremental según las prioridades del usuario, tanto que obtención requerimientos proviene los usuarios que son parte del equipo desarrollo. .. diseño implementación del software etapa implementación desarrollo del software corresponde proceso con-vertir una especificación del sistema sistema ejecutable. siempre incluye procesos diseño programación software, aunque también puede involucrar corrección especificación del software, utiliza enfoque incremental desarrollo. diseño software entiende como una descripción estructura del software que implementar, los modelos las estructuras datos utilizados por sistema, las inter-faces entre componentes del sistema , ocasiones, los algoritmos usados. los diseñadores llegan inmediatamente una creación terminada, sino que desarrollan diseño manera iterativa. agregan formalidad detalle conforme realizan diseño con backtracking (vuelta atrás) constante para corregir diseños anteriores. figura . modelo abstracto este proceso, que ilustra las entradas proceso diseño, las actividades del proceso los documentos generados como salidas este proceso. estudio factibilidadobtención análisis requerimientos especificación requerimientos validación requerimientosinforme factibilidad modelos del sistema requerimientos del usuario del sistema documento requerimientosfigura . proceso ingeniería requerimientos -.indd -.indd // :: // :: . ■ actividades del proceso diagrama sugiere que las etapas del proceso diseño son secuenciales. hecho, las acti- vidades proceso diseño están vinculadas. todos los procesos diseño inevitable retroalimentación una etapa otra consecuente reelaboración del diseño. mayoría del software tiene interfaz junto con otros sistemas software. ellos incluyen sistema operativo, base datos, middleware otros sistemas aplicación. éstos constituyen “plataforma software”, decir, entorno donde ejecutará software. información sobre esta plataforma una entrada esencial proceso diseño, así que los diseñadores tienen que decidir mejor forma integrarla con entorno software. especificación requerimientos una descripción funcionalidad que debe brindar software, conjunción con sus requerimientos rendimiento confiabilidad. sistema debe procesar datos existentes, entonces especificación plataforma incluirá descripción tales datos; otro modo, descripción los datos será una entrada proceso diseño, manera que defina organización del sistema datos. las actividades proceso diseño varían dependiendo del tipo sistema desarrollar. por ejemplo, los sistemas tiempo real precisan del diseño temporiza-ción, pero sin incluir una base datos, por que hay que integrar diseño base datos. figura . muestra cuatro actividades que podrían formar parte del proceso diseño para sistemas información: . diseño arquitectónico, aquí identifica estructura global del sistema, los princi- pales componentes (llamados ocasiones subsistemas módulos), sus relaciones cómo distribuyen. . diseño interfaz, éste definen las interfaces entre los componentes siste-mas. esta especificación interfaz tiene que presentar ambigüedades. con una interfaz precisa, factible usar componente sin que otros tengan que saber cómo implementó. una vez que acuerdan las especificaciones interfaz, los compo-nentes diseñan desarrollan manera concurrente.arquitectura del sistemaespecificación base datosespecificación interfazespecificación componentesdiseño interfazdiseño componentesespecificación requerimientos diseño arquitectónicoplataforma informacióndescripción datosentradas diseño actividades diseño salidas diseñodiseño base datos figura . modelo general del proceso diseño -.indd -.indd // :: // :: capítulo ■ procesos software . diseño componentes , toma cada componente del sistema diseña cómo funcionará. esto puede ser simple dato funcionalidad que espera implementar, programador deja diseño específico. como alternativa, habría una lista cambios realizar sobre componente que reutiliza sobre modelo diseño detallado. modelo diseño sirve para generar automá-tico una implementación. . diseño base datos , donde diseñan las estructuras del sistema datos cómo representarán una base datos. nuevo, trabajo aquí depende una base datos reutilizará creará una nueva. tales actividades conducen conjunto salidas diseño, que también mues-tran figura .. detalle representación las mismas varían considerable-mente. para sistemas críticos, deben producirse documentos diseño detallados que establezcan descripciones exactas del sistema. usa enfoque dirigido por modelo, dichas salidas serían sobre todo diagramas. donde usen métodos ágiles desarrollo, las salidas del proceso diseño podrían ser documentos especificación separados, sino que tendrían que representarse código del programa. los métodos estructurados para diseño desarrollaron las décadas , fueron precursores del uml del diseño orientado objetos (budgen, ). apoyan producción modelos gráficos del sistema , muchos casos, generan instantá-neamente código partir dichos modelos. desarrollo dirigido por modelo (mdd) ingeniería dirigida por modelo (schmidt, ), donde crean modelos software diferentes niveles abstracción, una evolución los métodos estructurados. mdd hay mayor énfasis los modelos arquitectónicos con una separación entre modelos abstractos independientes implementación modelos específicos implementación. los modelos desarrollan con detalle suficiente, manera que sistema ejecutable puede generarse partir ellos. capítulo estudia este enfoque desarrollo. diseño programa para implementar sistema sigue naturalmente los pro-cesos elaboración del sistema. aunque algunas clases programa, como los sistemas críticos para seguridad, por general diseñan con detalle antes comenzar cualquier implementación, más común que entrelacen etapas posteriores del diseño desarrollo del programa. las herramientas desarrollo software usan para generar programa “esqueleto” partir diseño. esto incluye código para definir implementar interfaces , muchos casos, desarrollador sólo necesita agregar detalles operación cada componente del programa. programación una actividad personal hay proceso que siga manera general. algunos programadores comienzan con componentes que entienden, los desarrollan , luego, cambian hacia componentes que entienden menos. otros toman enfoque opuesto, métodos estructurados los métodos estructurados son enfoque diseño software donde definen los modelos gráficos que hay que desarrollar, como parte del proceso diseño. método también define proceso para diseñar los modelos las reglas que aplican cada tipo modelo. los métodos estructurados conducen documentación estandarizada para sistema son muy útiles ofrecer marco desarrollo para los creadores software con menor experiencia. http:// -.indd -.indd // :: // :: . ■ actividades del proceso dejan hasta último los componentes familiares, porque saben cómo diseñarlos. algunos desarrolladores les agrada definir con anticipación datos proceso, que luego usan para impulsar desarrollo del programa; otros dejan datos sin especificar tanto como sea posible. por general, los programadores realizan algunas pruebas del código que desarrolla-ron. esto revela con frecuencia defectos del programa que deben eliminarse del programa. esta actividad llama depuración ( debugging). prueba defectos depuración son procesos diferentes. primera establece existencia defectos, tanto que segunda dedica localizar corregir dichos defectos. cuando depura, uno debe elaborar una hipótesis sobre comportamiento observable del programa , luego, poner prueba dichas hipótesis con esperanza encontrar falla que causó salida anómala. poner prueba las hipótesis quizá requiera rastrear manual-mente código del programa; bien, tal vez necesiten nuevos casos prueba para localizar problema. con finalidad apoyar proceso depuración, deben utilizar herramientas interactivas que muestren valores intermedios las variables del programa, así como rastro las instrucciones ejecutadas. .. validación software validación software , más generalmente, verificación validación (&), crea para mostrar que sistema cumple tanto con sus especificaciones como con las expectativas del cliente. las pruebas del programa, donde sistema ejecuta través datos prueba simulados, son principal técnica validación. esta última también puede incluir procesos comprobación, como inspecciones revisiones cada etapa del proceso software, desde definición requerimientos del usuario hasta desa-rrollo del programa. dada predominancia las pruebas, incurre mayoría los costos validación durante implementación después ésta. con excepción los programas pequeños, los sistemas deben ponerse prueba como una unidad monolítica. figura . muestra proceso prueba tres etapas, donde los componentes del sistema ponen prueba; luego, hace mismo con sistema integrado , finalmente, sistema pone prueba con los datos del cliente. manera ideal, los defectos los componentes detectan oportunamente proceso, tanto que los problemas interfaz localizan cuando sistema integra. sin embargo, conforme descubran los defectos, programa deberá depurarse esto quizá requiera repetición otras etapas proceso pruebas. los errores los compo-nentes del programa pueden salir luz durante las pruebas del sistema. consecuen-cia, proceso iterativo, con información retroalimentada desde etapas posteriores hasta las partes iniciales del proceso. las etapas proceso pruebas son: . prueba desarrollo las personas que desarrollan sistema ponen prueba los componentes que constituyen sistema. cada componente prueba manera independiente, decir, sin otros componentes del sistema. éstos pueden ser simples prueba componentesprueba del sistemaprueba aceptación figura . etapas pruebas -.indd -.indd // :: // :: capítulo ■ procesos software des, como funciones clases objeto, agrupamientos coherentes dichas entidades. por general, usan herramientas automatización pruebas, como junit (massol husted, ), que pueden volver correr pruebas componentes cuando crean nuevas versiones del componente. . pruebas del sistema los componentes del sistema integran para crear sis-tema completo. este proceso tiene finalidad descubrir errores que resulten interac ciones anticipadas entre componentes problemas interfaz compo-nente, así como mostrar que sistema cubre sus requerimientos funcionales funcionales, poner prueba las propiedades emergentes del sistema. para sistemas grandes, esto puede ser proceso múltiples etapas, donde los componentes conjuntan para formar subsistemas que ponen prueba manera individual, antes que dichos subsistemas integren para establecer sistema final. . pruebas aceptación ésta etapa final proceso pruebas, antes que sistema acepte para uso operacional. sistema pone prueba con datos suministrados por cliente del sistema, vez datos prueba simulados. las pruebas aceptación revelan los errores las omisiones definición requeri-mientos del sistema, que los datos reales ejercitan sistema diferentes formas partir los datos prueba. asimismo, las pruebas aceptación revelan proble-mas requerimientos, donde las instalaciones del sistema realidad cumplan las necesidades del usuario cuando sea inaceptable rendimiento del sistema. por general, los procesos desarrollo pruebas componentes están entre-lazados. los programadores construyen sus propios datos prueba experimentan código manera incremental conforme desarrollan. éste enfoque económica-mente sensible, que programador conoce componente , por tanto, más indicado para generar casos prueba. usa enfoque incremental para desarrollo, cada incremento debe ponerse prueba conforme diseña, tales pruebas basan los requerimientos para dicho incremento. programación extrema, las pruebas desarrollan junto con los requerimientos antes comenzar desarrollo. esto ayuda los examinadores desarrolladores comprender los requerimientos, garantiza que haya demoras conforme creen casos prueba. cuando usa proceso software dirigido por plan (como desarrollo sis-temas críticos), las pruebas realizan mediante conjunto planes prueba. equipo independiente examinadores trabaja con base dichos planes prueba preformulados, que desarrollaron partir especificación diseño del sistema. figura . ilustra cómo vinculan los planes prueba entre las actividades pruebas desarrollo. esto conoce ocasiones como modelo desarrollo (colóquelo lado para distinguir ). ocasiones, las pruebas aceptación les identifica como “pruebas alfa”. los sistemas medida desarrollan sólo para cliente. proceso prueba alfa conti-núa hasta que desarrollador del sistema cliente estén acuerdo que sistema entregado una implementación aceptable los requerimientos. cuando sistema marca como producto software, utiliza con frecuencia proceso prueba llamado “prueba beta”. ésta incluye entregar sistema algunos clien-tes potenciales que están acuerdo con usar ese sistema. ellos reportan los problemas los desarrolladores del sistema. dicho informe expone producto uso real detecta errores que anticiparon los constructores del sistema. después esta retroalimentación, sistema modifica libera, sea para más pruebas beta para venta general. -.indd -.indd // :: // :: . ■ cómo enfrentar cambio .. evolución del software flexibilidad los sistemas software una las razones principales por las que cada vez más software incorpora los sistemas grandes complejos. una vez tomada decisión fabricar hardware, resulta muy costoso hacer cambios diseño. sin embargo, cualquier momento durante después del desarrollo del sistema, pueden hacerse cambios software. incluso los cambios mayores son todavía más baratos que los correspondientes cambios hardware del sistema. historia, siempre habido división entre proceso desarrollo del software proceso evolución del software (mantenimiento software). las personas conside-ran desarrollo software como una actividad creativa, cual diseña sistema software desde concepto inicial través sistema trabajo. obstante, consideran ocasiones mantenimiento del software como insulso poco interesante. aunque mayoría los casos los costos del mantenimiento son varias veces los costos iniciales desarrollo, los procesos mantenimiento consideran ocasiones como menos desafiantes que desarrollo software original. esta distinción entre desarrollo mantenimiento cada vez más irrelevante. muy difícil que cualquier sistema software sea sistema completamente nuevo, tiene mucho más sentido ver desarrollo mantenimiento como continuo. lugar dos procesos separados, más realista pensar ingeniería software como proceso evolutivo (figura .), donde software cambia continuamente largo vida, función los requerimientos las necesidades cambiantes del cliente. . cómo enfrentar cambio cambio inevitable todos los grandes proyectos software. los requerimientos del sistema varían conforme empresa procura que sistema responda presiones externas modifican las prioridades administrativas. medida que ponen dispo-sición nuevas tecnologías, surgen nuevas posibilidades diseño implementación. por ende, cualquiera que sea modelo del proceso software utilizado, esencial que ajuste los cambios software desarrollar.especificación requerimientosespecificación del sistema prueba aceptaciónprueba integración del sistemaprueba integración del subsistemadiseño del sistemadiseño detallado serviciomódulo código unidad pruebaplan prueba aceptaciónplan prueba integración del sistemaplan prueba integración subsistemas figura . probando fases proceso software dirigido por plan -.indd -.indd // :: // :: capítulo ■ procesos software cambio agrega los costos del desarrollo software debido que, por general, significa que trabajo terminado debe volver realizarse. esto llama reha-cer. por ejemplo, analizaron las relaciones entre los requerimientos sistema identifican nuevos requerimientos, parte todo análisis requerimientos tiene que repetirse. entonces, necesario rediseñar sistema para entregar los nuevos requerimien-tos, cambiar cualquier programa que haya desarrollado volver probar sistema. existen dos enfoques relacionados que usan para reducir los costos del rehacer: . evitar cambio, donde proceso software incluye actividades que anticipan cam- bios posibles antes requerirse labor significativa rehacer. por ejemplo, puede desarrollarse sistema prototipo para demostrar los clientes algunas características clave del sistema. ellos podrán experimentar con prototipo refinar sus requeri-mientos, antes comprometerse con mayores costos producción software. . tolerancia cambio, donde proceso diseña modo que los cambios ajusten con costo relativamente bajo. por general, esto comprende algunas formas desarrollo incremental. los cambios propuestos pueden implementarse incremen-tos que aún desarrollan. posible, entonces tal vez sólo incremento (una pequeña parte del sistema) tendría que alterarse para incorporar cambio. esta sección estudian dos formas enfrentar cambio los requerimientos cambiantes del sistema. trata siguiente: . prototipo sistema, donde rápidamente desarrolla una versión del sistema una parte del mismo, para comprobar los requerimientos del cliente factibilidad algunas decisiones diseño. esto apoya hecho evitar cambio, permitir que los usuarios experimenten con sistema antes entregarlo así refinar sus requerimientos. como resultado, probable que reduzca número propues-tas cambio requerimientos posterior entrega. . entrega incremental, donde los incrementos del sistema entregan cliente para comentario experimentación. esto apoya tanto hecho evitar cambio como tolerar cambio. por lado, evita compromiso prematuro con los reque-rimientos para todo sistema , por otro, permite incorporación cambios incrementos mayores costos relativamente bajos. noción refactorización, esto , mejoramiento estructura organización programa, también mecanismo importante que apoya tolerancia cambio. este tema explica capítulo , que ocupa los métodos ágiles.valoración sistemas existentesdefinición requerimientos del sistemapropuesta cambios sistemamodificación sistemas nuevo sistemasistemas existentesfigura . evolución del sistema -.indd -.indd // :: // :: . ■ cómo enfrentar cambio .. creación del prototipo prototipo una versión inicial sistema software que usa para demostrar conceptos, tratar opciones diseño encontrar más sobre problema sus posibles soluciones. rápido desarrollo iterativo del prototipo esencial, modo que con-trolen los costos, los interesados sistema experimenten por anticipado con pro-totipo durante proceso software. prototipo software usa proceso desarrollo software para contri-buir anticipar los cambios que requieran: . proceso ingeniería requerimientos, prototipo ayuda con selección validación requerimientos del sistema. . proceso diseño sistemas, prototipo sirve para buscar soluciones espe- cíficas software apoyar diseño interfaces del usuario. los prototipos del sistema permiten los usuarios ver qué tan bien sistema apoya trabajo. pueden obtener nuevas ideas para requerimientos descubrir áreas fortale-zas debilidades software. entonces, proponen nuevos requerimientos del sistema. más aún, conforme desarrolla prototipo, quizá revelen errores omisiones los requerimientos propuestos. una función descrita una especificación puede parecer útil bien definida. sin embargo, cuando dicha función combina con otras operacio-nes, los usuarios descubren frecuentemente que visión inicial era incorrecta estaba incompleta. entonces, modifica especificación del sistema con finalidad refle-jar nueva comprensión los requerimientos. mientras elabora sistema para realización experimentos diseño, pro-totipo del mismo sirve para comprobar factibilidad diseño propuesto. por ejem-plo, puede crearse prototipo del diseño una base datos ponerse prueba, con objetivo comprobar que soporta forma eficiente acceso datos para las consultas más comunes del usuario. asimismo, creación prototipos una parte esencial del proceso diseño interfaz del usuario. debido dinámica natural las interfaces usuario, las descripciones textuales los diagramas son suficientemente buenos para expresar los requerimientos interfaz del usuario. por tanto, crea-ción rápida prototipos con participación del usuario final única forma sensible para desarrollar interfaces usuario gráficas para sistemas software. figura . muestra modelo del proceso para desarrollo prototipos. los objetivos creación prototipos deben ser más explícitos desde inicio del pro-ceso. esto tendría finalidad desarrollar sistema para prototipo interfaz establecimiento objetivos del prototipodefinición funcionalidad del prototipodesarrollo del prototipoevaluación del prototipo plan creación del prototipobosquejo definiciónprototipo ejecutablereporte evaluaciónfigura . proceso desarrollo del prototipo -.indd -.indd // :: // :: capítulo ■ procesos software del usuario, diseñar sistema que valide los requerimientos funcionales del sistema desarrolle sistema que demuestre los administradores factibilidad aplicación. mismo prototipo puede cumplir con todos los objetivos, que éstos quedan sin especificar, los administradores usuarios finales quizá malinterpreten función del pro-totipo. consecuencia, posible que obtengan los beneficios esperados del desarrollo del prototipo. siguiente etapa del proceso consiste decidir qué poner , algo quizá más impor-tante, qué dejar fuera del sistema prototipo. para reducir los costos creación prototipos acelerar las fechas entrega, posible dejar cierta funcionalidad fuera del prototipo , también, decidir hacer más flexible los requerimientos funcionales, como tiempo respuesta utilización memoria. manejo gestión erro-res pueden ignorarse, menos que objetivo del prototipo sea establecer una interfaz usuario. además, posible reducir los estándares fiabilidad calidad del programa. etapa final del proceso evaluación del prototipo. hay que tomar provisiones durante esta etapa para capacitación del usuario usar los objetivos del prototipo para derivar plan evaluación. los usuarios requieren tiempo para sentirse cómodos con nuevo sistema integrarse patrón normal uso. una vez que utilizan sistema manera normal, descubren errores omisiones los requerimientos. problema general con creación prototipos que quizás prototipo utilice necesariamente misma forma que sistema final. revisor del prototipo tal vez sea usuario típico del sistema. también, podría resultar insuficiente tiempo capacitación durante evaluación del prototipo. prototipo lento, los evalua-dores podrían ajustar forma trabajar evitar aquellas características del sistema con tiempos respuesta lentos. cuando una mejor respuesta sistema final, puede usar forma diferente. ocasiones, los desarrolladores están presionados por los administradores para entregar prototipos desechables, sobre todo cuando existen demoras entrega versión final del software. sin embargo, por general esto aconsejable: . puede ser imposible corregir prototipo para cubrir requerimientos funcionales, como los requerimientos rendimiento, seguridad, robustez fiabilidad, ignorados durante desarrollo del prototipo. . cambio rápido durante desarrollo significa claramente que prototipo está documentado. única especificación diseño código del prototipo. esto muy bueno para mantenimiento largo plazo. . probablemente los cambios realizados durante desarrollo prototipos degrada- rán estructura del sistema, este último será difícil costoso mantener. . por general, durante desarrollo prototipos hacen más flexibles los están- dares calidad organización. los prototipos tienen que ser ejecutables para ser útiles. los modelos papel interfaz usuario del sistema (rettig, ) pueden ser efectivos para ayudar los usuarios refinar diseño interfaz trabajar través escenarios uso. desarrollo muy económico suelen construirse pocos días. una extensión esta técnica prototipo mago , donde sólo desarrolle interfaz del usuario. los usuarios interactúan con esta interfaz, pero sus solicitudes pasan una persona que los interpreta les devuelve respuesta adecuada. -.indd -.indd // :: // :: . ■ cómo enfrentar cambio .. entrega incremental entrega incremental (figura .) enfoque desarrollo software donde algu- nos los incrementos diseñados entregan cliente implementan para usarse entorno operacional. proceso entrega incremental, los clientes identifican, bosquejo, los servicios que proporciona sistema. identifican cuáles servicios son más importantes cuáles son menos significativos para ellos. entonces, define número incrementos entrega, cada incremento proporciona subconjunto funcionalidad del sistema. asignación servicios por incrementos depende prioridad del servi-cio, donde los servicios más alta prioridad implementan entregan primero. una vez identificados los incrementos del sistema, definen con detalle los reque-rimientos los servicios que van entregar primer incremento, desarrolla ese incremento. durante desarrollo, puede haber mayor análisis requerimientos para incrementos posteriores, aun cuando rechacen cambios requerimientos para incremento actual. una vez completado entregado incremento, los clientes ponen servicio. esto significa que toman entrega anticipada funcionalidad parcial del sistema. pueden experimentar con sistema que les ayuda clarificar sus requerimientos, para posterio-res incrementos del sistema. medida que completan nuevos incrementos, integran con los incrementos existentes, modo que con cada incremento entregado mejore funcionalidad del sistema. entrega incremental tiene algunas ventajas: . los clientes pueden usar los primeros incrementos como prototipos adquirir expe- riencia que informe sobre sus requerimientos, para posteriores incrementos del sis- tema. diferencia los prototipos, éstos son parte del sistema real, manera que hay reaprendizaje cuando está disponible sistema completo. . los clientes deben esperar hasta entrega completa del sistema, antes ganar valor del mismo. primer incremento cubre sus requerimientos más críticos, modo que posible usar inmediatamente software. . proceso mantiene los beneficios del desarrollo incremental cuanto que debe ser relativamente sencillo incorporar cambios sistema. . puesto que primero entregan los servicios mayor prioridad luego integran los incrementos, los servicios sistema más importantes reciben mayores pruebas. diseño arquitectura sistemadefinición los requerimientos del bosquejoasignación requerimientos incrementos ¿sistema incompleto? sistema finaldesarrollo incremento sistema validar incrementointegrar incrementovalidar sistemaimplementar incremento ¿sistemacompleto? figura . entrega incremental -.indd -.indd // :: // :: capítulo ■ procesos software esto significa que los clientes tienen menos probabilidad encontrar fallas soft- ware las partes más significativas del sistema. sin embargo, existen problemas con entrega incremental: . mayoría los sistemas requieren una serie recursos que utilizan para diferentes partes del sistema. dado que los requerimientos están definidos con detalle sino hasta que implementa incremento, resulta difícil identificar recur-sos comunes que necesiten todos los incrementos. . asimismo, desarrollo iterativo resulta complicado cuando diseña sistema reemplazo. los usuarios requieren toda funcionalidad del sistema antiguo, que común que deseen experimentar con nuevo sistema incompleto. por tanto, difícil conseguir retroalimentación útil del cliente. . esencia los procesos iterativos que especificación desarrolla con- junto con software. sin embargo, esto puede contradecir con modelo adquisiciones muchas organizaciones, donde especificación completa del sis-tema parte del contrato desarrollo del sistema. enfoque incremental, hay especificación completa del sistema, sino hasta que define incremento final. esto requiere una nueva forma contrato que los grandes clientes, como las agencias gubernamentales, encontrarían difícil adoptar. existen algunos tipos sistema donde desarrollo incremental entrega son mejor enfoque. hay sistemas muy grandes donde desarrollo incluye equipos que tra-bajan diferentes ubicaciones, algunos sistemas embebidos donde software depende del desarrollo hardware algunos sistemas críticos donde todos los requerimientos tienen que analizarse para comprobar las interacciones que comprometan seguridad protección del sistema. estos sistemas, desde luego, enfrentan los mismos problemas incertidumbre requerimientos cambiantes. consecuencia, para solucionar tales problemas obte-ner algunos los beneficios del desarrollo incremental, utiliza proceso donde prototipo del sistema elabore iterativamente utilice como plataforma, para expe-rimentar con los requerimientos diseño del sistema. con experiencia obtenida del prototipo, pueden concertarse los requerimientos definitivos. .. modelo espiral boehm boehm () propuso marco del proceso software dirigido por riesgo ( modelo espiral), que muestra figura .. aquí, proceso software representa como una espiral, como una secuencia actividades con cierto retroceso una actividad otra. cada ciclo espiral representa una fase del proceso software. por ende, ciclo más interno puede relacionarse con factibilidad del sistema, siguiente ciclo con definición requerimientos, ciclo que sigue con diseño del sistema, etcétera. modelo espiral combina evitar cambio con tolerancia cambio. anterior supone que los cambios son resultado riesgos del proyecto incluye activida-des gestión riesgos explícitas para reducir tales riesgos. -.indd -.indd // :: // :: . ■ cómo enfrentar cambio cada ciclo espiral divide cuatro sectores: . establecimiento objetivos definen objetivos específicos para dicha fase del proyecto. identifican restricciones proceso producto, traza plan gestión detallado. identifican los riesgos del proyecto. pueden planearse estra-tegias alternativas, según sean los riesgos. . valoración reducción del riesgo cada uno los riesgos identificados del proyecto, realiza análisis minucioso. dan acciones para reducir riesgo. por ejemplo, existe riesgo que los requerimientos sean inadecuados, puede desarrollarse sistema prototipo. . desarrollo validación después una evaluación del riesgo, elige modelo desarrollo para sistema. por ejemplo, creación prototipos desechables sería mejor enfoque desarrollo, predominan los riesgos interfaz del usuario. principal consideración son los riesgos seguridad, desarrollo con base transformaciones formales sería proceso más adecuado, entre otros. principal riesgo identificado integración subsistemas, modelo cascada sería mejor modelo desarrollo utilizar. . planeación proyecto revisa toma una decisión sobre hay que conti-nuar con otro ciclo espiral. opta por continuar, trazan los planes para siguiente fase del proyecto.figura . modelo espiral boehm del proceso software (© ieee, )análisis riesgos análisis riesgos análisis riesgos proto- tipo operacional concepto operación validación requerimientos diseño &vdiseño delproductodiseño detallado código prueba integraciónprueba aceptaciónservicio desarrollar, verificarproducto del siguiente nivelevaluar alternativas, identificar resolver riesgosdeterminar objetivos, alternativas restricciones plan siguiente faseintegración plan pruebaplan desarrolloplan requerimientos plan ciclo vidarevisión simulaciones, modelos, benchmarks requerimientos / prueba unidadanálisis riesgos -.indd -.indd // :: // :: capítulo ■ procesos software diferencia principal entre modelo espiral con otros modelos proceso soft- ware reconocimiento explícito del riesgo. ciclo espiral comienza por elabo-rar objetivos como rendimiento funcionalidad. luego, numeran formas alternativas alcanzar dichos objetivos lidiar con las restricciones cada uno ellos. cada alternativa valora contra cada objetivo identifican las fuentes riesgo del pro-yecto. siguiente paso resolver dichos riesgos, mediante actividades recopilación información, como análisis más detallado, creación prototipos simulación. una vez valorados los riesgos realiza cierto desarrollo, seguido por una actividad planeación para siguiente fase del proceso. manera informal, riesgo significa simplemente algo que podría salir mal. por ejemplo, intención usar nuevo lenguaje programación, riesgo sería que los compiladores disponibles sean con-fiables produzcan código-objeto suficientemente eficaz. los riesgos conducen propuestas cambios software problemas proyecto como exceso las fechas costo, manera que minimización del riesgo una actividad muy importante administración del proyecto. capítulo tratará gestión del riesgo, una parte esencial administración del proyecto. . proceso unificado racional proceso unificado racional (rup, por las siglas rational unified process ) (krutchen, ) ejemplo modelo proceso moderno que derivó del tra-bajo sobre uml proceso asociado desarrollo software unificado (rumbaugh ., ; arlow neustadt, ). aquí incluye una descripción, pues buen ejemplo modelo proceso híbrido. conjunta elementos todos los modelos proceso genéricos (sección .), ilustra buena práctica especificación diseño (sec-ción .), apoya creación prototipos entrega incremental (sección .). rup reconoce que los modelos proceso convencionales presentan una sola visión del proceso. contraste, rup por general describe desde tres perspectivas: . una perspectiva dinámica que muestra las fases del modelo través del tiempo. . una perspectiva estática que presenta las actividades del proceso que establecen.. una perspectiva práctica que sugiere buenas prácticas usar durante proceso. mayoría las descripciones del rup buscan combinar las perspectivas estática dinámica solo diagrama (krutchen, ). esto hace que proceso resulte más difícil entender, por que este texto usan descripciones separadas cada una estas perspectivas. rup modelo fases que identifica cuatro fases discretas proceso software. sin embargo, diferencia del modelo cascada, donde las fases igualan con actividades del proceso, las fases rup están más estrechamente vinculadas con empresa que con las preocupaciones técnicas. figura . muestra las fases del rup. éstas son: . concepción meta fase concepción establecer caso empresarial para sistema. deben identificarse todas las entidades externas (personas sistemas) -.indd -.indd // :: // :: . ■ proceso unificado racional que interactuarán con sistema definirán dichas interacciones. luego usa esta información para valorar aportación del sistema hacia empresa. esta aporta-ción menor, entonces proyecto puede cancelarse después esta fase. . elaboración las metas fase elaboración consisten desarrollar com-prensión del problema dominio, establecer marco conceptual arquitectónico para sistema, diseñar plan del proyecto identificar los riesgos clave del pro-yecto. completar esta fase, debe tenerse modelo requerimientos para sistema, que podría ser una serie casos uso del uml, una descripción arquitec-tónica plan desarrollo para software. . construcción fase construcción incluye diseño, programación pruebas del sistema. partes del sistema desarrollan paralelo integran durante esta fase. completar ésta, debe tenerse sistema software funcionando documen-tación relacionada lista para entregarse usuario. . transición fase final del rup interesa por cambio del sistema desde comunidad desarrollo hacia comunidad usuarios, por ponerlo funcionar ambiente real. esto algo ignorado mayoría los modelos proceso software aunque, efecto, una actividad costosa ocasiones problemática. complemento esta fase debe tener sistema software documentado que funcione correctamente entorno operacional. iteración con rup apoya dos formas. cada fase puede presentarse una forma iterativa, con los resultados desarrollados incrementalmente. además, todo con-junto fases puede expresarse manera incremental, como muestra flecha curva desde transición hasta concepción figura .. visión estática del rup enfoca las actividades que tienen lugar durante proceso desarrollo. les llama flujos trabajo descripción rup. proceso identifican seis flujos trabajo proceso centrales tres flujos trabajo apoyo centrales. rup diseñó conjunto con uml, manera que descripción del flujo trabajo orienta sobre modelos uml asociados, como modelos secuencia, modelos objeto, etcétera. figura . describen ingeniería central los flujos trabajo apoyo. ventaja presentación las visiones dinámica estática radica que las fases del proceso desarrollo están asociadas con flujos trabajo específicos. principio, menos, todos los flujos trabajo rup pueden estar activos totalidad las etapas del proceso. las fases iniciales del proceso, probable que use mayor esfuerzo los flujos trabajo como modelado del negocio requerimientos , fases posteriores, las pruebas despliegue.conce pción elaboración construcciónfase iteración transiciónfigura . fases proceso unificado racional -.indd -.indd // :: // :: capítulo ■ procesos software enfoque práctico del rup describe las buenas prácticas ingeniería software que recomiendan para uso desarrollo sistemas. las seis mejores prácticas fundamentales que recomiendan son: . desarrollo software manera iterativa incrementar plan del sistema con base las prioridades del cliente, desarrollar oportunamente las características del sistema mayor prioridad proceso desarrollo. . gestión requerimientos documentar manera explícita los requerimientos del cliente seguir huella los cambios dichos requerimientos. analizar efecto los cambios sobre sistema antes aceptarlos. . usar arquitecturas basadas componentes estructurar arquitectura del sis- tema componentes, como estudió anteriormente este capítulo. . software modelado visualmente usar modelos uml gráficos para elaborar repre-sentaciones software estáticas dinámicas. . verificar calidad del software garantizar que software cumpla con los están-dares calidad organización.figura . flujos trabajo estáticos proceso unificado racionalflujo trabajo descripción modelado del negocio modelan los procesos negocios utilizando casos uso empresa. requerimientos identifican los actores que interactúan con sistema desarrollan casos uso para modelar los requerimientos del sistema. análisis diseño crea documenta modelo diseño utilizando modelos arquitectónicos, componentes, objetos secuencias. implementación implementan estructuran los componentes del sistema subsistemas implementación. generación automática código partir modelos diseño ayuda acelerar este proceso. pruebas las pruebas son proceso iterativo que realiza conjunto con implementación. las pruebas del sistema siguen completar implementación. despliegue crea liberación producto, distribuye los usuarios instala lugar trabajo. administración configuración del cambioeste flujo trabajo apoyo gestiona los cambios sistema (véase capítulo ). administración del proyecto este flujo trabajo apoyo gestiona desarrollo del sistema (véase los capítulos ). entorno este flujo trabajo pone disposición del equipo desarrollo software, las herramientas adecuadas software. -.indd -.indd // :: // :: . controlar los cambios software gestionar los cambios software con sis- tema administración del cambio, así como con procedimientos herramientas administración configuración. rup proceso adecuado para todos los tipos desarrollo, por ejemplo, para desarrollo software embebido. sin embargo, representa enfoque que poten-cialmente combina los tres modelos proceso genéricos que estudiaron sección .. las innovaciones más importantes rup son separación fases flujos trabajo, reconocimiento que despliegue del software entorno del usuario forma parte del proceso. las fases son dinámicas tienen metas. los flujos trabajo son estáticos son actividades técnicas que asocian con una sola fase, sino que pueden usarse largo del desarrollo para lograr las metas cada fase. puntos clave ■ los procesos software son actividades implicadas producción sistema software. los modelos proceso software consisten representaciones abstractas dichos procesos. ■ los modelos proceso general describen organización los procesos software. los ejemplos estos modelos generales incluyen modelo cascada, desarrollo incremental desarrollo orientado reutilización. ■ ingeniería requerimientos proceso desarrollo una especificación software. las especificaciones tienen intención comunicar las necesidades sistema del cliente los desarrolladores del sistema. ■ los procesos diseño implementación tratan transformar una especificación requerimientos sistema software ejecutable. pueden usarse métodos diseño sistemáticos como parte esta transformación. ■ validación del software proceso comprobar que sistema conforma especificación que satisface las necesidades reales los usuarios del sistema. ■ evolución del software tiene lugar cuando cambian los sistemas software existentes para satisfacer nuevos requerimientos. los cambios son continuos software debe evolucionar para seguir siendo útil. ■ los procesos deben incluir actividades para lidiar con cambio. esto puede implicar una fase creación prototipos que ayude evitar malas decisiones sobre los requerimientos diseño. los procesos pueden estructurarse para desarrollo entrega iterativos, forma que los cambios realicen sin perturbar sistema como todo. ■ proceso unificado racional modelo proceso genérico moderno que está organizado fases (concepción, elaboración, construcción transición), pero separa las actividades (requerimientos, análisis diseño, etcétera) dichas fases.capítulo ■ puntos clave -.indd -.indd // :: // :: pmlecturas sugeridas managing software quality and business risk . aun cuando éste principalmente libro sobre administración software, incluye excelente capítulo (capítulo ) modelos proceso. (. ould, john wiley and sons ltd, .) process models software engineering. ofrece una excelente visión amplio rango modelos proceso ingeniería software que han propuesto. (. scacchi, encyclopaedia software engineering, . .. marciniak, john wiley and sons, .) http:/ /www. ics. uci. edu/ ~wscacchi/ papers/ -encyc/ process-models--encyc. pdf. the rational unified process— introduction ( edition) . éste libro más legible que hay disponible sobre rup hasta ahora. krutchen describe bien proceso, pero sería más deseable ver las dificultades prácticas usar proceso. (. krutchen, addison-wesley, .) ejercicios .. explicando las razones para respuesta, con base tipo sistema desarrollar, sugiera modelo proceso software genérico más adecuado que use como fundamento para administrar desarrollo los siguientes sistemas: sistema para controlar antibloqueo frenos automóvilun sistema realidad virtual para apoyar mantenimiento softwareun sistema contabilidad universitario que sustituya uno existenteun sistema interactivo programación viajes que ayude los usuarios planear viajes con menor impacto ambiental .. explique por qué desarrollo incremental enfoque más efectivo para diseñar sistemas software empresariales. ¿por qué este modelo menos adecuado para ingeniería sistemas tiempo real? .. considere modelo proceso basado reutilización que muestra figura .. explique por qué durante proceso esencial tener dos actividades separadas ingeniería requerimientos. .. sugiera por qué, proceso ingeniería requerimientos, importante hacer una distinción entre desarrollar los requerimientos del usuario desarrollar los requerimientos del sistema. .. describa las principales actividades proceso diseño software las salidas dichas actividades. con diagrama, muestre las posibles relaciones entre las salidas dichas actividades. .. explique por qué cambio inevitable los sistemas complejos, mencione ejemplos (además creación prototipos entrega incremental) las actividades proceso software que ayudan predecir los cambios lograr que software por desarrollar sea más resistente cambio. capítulo ■ procesos software -.indd -.indd // :: // :: .. explique por qué los sistemas desarrollados como prototipos por general deben usarse como sistemas producción. .. exponga por qué modelo espiral boehm modelo adaptable que puede apoyar las actividades tanto evitar cambio como tolerar cambio. práctica, este modelo usado ampliamente. sugiera por qué éste podría ser caso. .. ¿cuáles son las ventajas proporcionar visiones estática dinámica del proceso software como proceso unificado racional? .. históricamente, introducción tecnología causado profundos cambios mercado laboral , menos temporalmente, reemplazado personas los puestos trabajo. explique probable que introducción extensos procesos automatización tenga las mismas consecuencias para los ingenieros software. cree que haya consecuencias, explique por qué. cree que reducirá las oportunidades laborales, ¿ ético que los ingenieros afectados resistan pasiva activamente introducción esta tecnología? referencias arlow, . neustadt, . (). uml and the unified process: practical object-oriented analysis and design ( edition). boston: addison-wesley. boehm, . turner, . (). balancing agility and discipline: guide for the perplexed . boston: addison-wesley.boehm, . . (). “ spiral model software development and enhancement”. ieee computer, (), –.budgen, . (). software design ( edition). harlow, .: addison-wesley.krutchen, . (). the rational unified process— introduction ( edition) . reading, : addison-wesley.massol, . husted, . (). junit action. greenwich, conn.: manning publications .rettig, . (). “practical programmer: prototyping for tiny fingers”. comm. acm, (), –. royce, . . (). “managing the development large software systems: concepts and techniques”. ieee westcon, los angeles : –. rumbaugh, ., jacobson, . booch, . (). the unified software development process. reading, mass.: addison-wesley. schmidt, . . (). “model-driven engineering”. ieee computer, (), –.schneider, . (). the method. houndmills, : palgrave macmillan.wordsworth, . (). software engineering with . wokingham: addison-wesley.capítulo ■ referencias -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo los métodos desarrollo ágil software. estudiar este capítulo: ■ comprenderá las razones los métodos desarrollo ágil software, manifiesto ágil, así como las diferencias entre desarrollo ágil dirigido por plan; ■ conocerá las prácticas clave programación extrema cómo relacionan con los principios generales los métodos ágiles; ■ entenderá enfoque scrum para administración proyecto ágil; ■ reconocerá los conflictos problemas escalar los métodos desarrollo ágil para diseño sistemas software grandes. contenido . métodos ágiles . desarrollo dirigido por plan desarrollo ágil. programación extrema. administración proyecto ágil. escalamiento métodos ágiles desarrollo ágil software -.indd -.indd // :: // :: pmcapítulo ■ desarrollo ágil software las empresas operan ahora entorno global que cambia rápidamente. ese sen- tido, deben responder frente nuevas oportunidades mercados, cambio las con-diciones económicas, así como surgimiento productos servicios competitivos. software parte casi todas las operaciones industriales, modo que nuevo software desarrolla rápidamente para aprovechar las actuales oportunidades, con finalidad responder ante amenaza competitiva. consecuencia, actualidad entrega desarrollo rápidos son por general requerimiento fundamental los sistemas software. hecho, muchas empresas están dispuestas negociar calidad del software compromiso con los requerimientos, para lograr con mayor celeridad implementación que necesitan del software. debido que dichos negocios funcionan entorno cambiante, menudo prác-ticamente imposible derivar conjunto completo requerimientos software estable. los requerimientos iniciales cambian modo inevitable, porque los clientes encuentran imposible predecir cómo sistema afectará sus prácticas operacionales, cómo interac-tuará con otros sistemas cuáles operaciones usuarios automatizarán. posible que sea sólo hasta después entregar sistema, que los usuarios adquieran experien-cia con éste, cuando aclaren los requerimientos reales. incluso, probable que debido factores externos, los requerimientos cambien rápida impredeciblemente. tal caso, software podría ser obsoleto momento entregarse. los procesos desarrollo software que buscan especificar por completo los requerimientos , luego, diseñar, construir probar sistema, están orientados desarrollo rápido software. medida que los requerimientos cambian, descubren problemas los requerimientos, diseño implementación del sistema tienen que reelaborarse probarse nuevo. consecuencia, proceso convencional cascada uno basado especificación prolongan con frecuencia, tanto que software final entrega cliente mucho después que especificó originalmente. algunos tipos software, como los sistemas control críticos para seguridad, donde esencial análisis completo del sistema, resulta oportuno enfoque basado plan. sin embargo, ambiente empresarial rápido movimiento, esto llega causar verdaderos problemas. momento que software esté disponible para uso, razón original para adquisición quizás haya variado tan radicalmente que software sería inútil todas luces. por tanto, para sistemas empresariales, son esenciales particular los pro-cesos diseño que enfocan desarrollo entrega software rápidos. durante algún tiempo, reconoció necesidad desarrollo procesos sis-tema rápidos que administraran los requerimientos cambiantes. ibm introdujo desa-rrollo incremental década (mills ., ). entrada los llamados lenguajes cuarta generación, también misma década, apoyó idea del software desarrollo entrega rápidos (martin, ). sin embargo, noción prosperó real-mente finales década , con desarrollo noción enfoques ágiles como dsdm (stapleton, ), scrum (schwaber beedle, ) programación extrema (beck, ; beck, ). los procesos desarrollo del software rápido diseñan para producir rápidamente software útil. software desarrolla como una sola unidad, sino como una serie incrementos, cada uno ellos incluye una nueva funcionalidad del sistema. aun cuando existen muchos enfoques para desarrollo software rápido, comparten algu-nas características fundamentales: . los procesos especificación, diseño implementación están entrelazados. existe una especificación detallada del sistema, documentación del diseño -.indd -.indd // :: // :: capítulo ■ desarrollo ágil software minimiza generada automáticamente por entorno programación que usa para implementar sistema. documento requerimientos del usuario define sólo las características más importantes del sistema. . sistema desarrolla diferentes versiones. los usuarios finales otros colabo- radores del sistema intervienen especificación evaluación cada versión. ellos podrían proponer cambios software nuevos requerimientos que imple-menten una versión posterior del sistema. . las interfaces usuario del sistema desarrollan usando con frecuencia sis- tema elaboración interactivo, que permita que diseño interfaz cree rápidamente cuanto dibujan colocan iconos interfaz. tal situación, sistema puede generar una interfaz basada web para navegador una interfaz para una plataforma específica, como microsoft windows. los métodos ágiles son métodos desarrollo incremental donde los incrementos son mínimos , por general, crean las nuevas liberaciones del sistema, cada dos tres semanas ponen disposición los clientes. involucran los clientes proceso desarrollo para conseguir una rápida retroalimentación sobre los requerimientos cam-biantes. minimizan cantidad documentación con uso comunicaciones infor-males, vez reuniones formales con documentos escritos. . métodos ágiles década inicios siguiente, había una visión muy difundida que forma más adecuada para lograr mejor software era mediante una cuidadosa planea-ción del proyecto, aseguramiento calidad formalizada, uso métodos análisis diseño apoyado por herramientas case, así como procesos desarrollo soft-ware rigurosos controlados. esta percepción proviene comunidad ingeniería software, responsable del desarrollo grandes sistemas software larga duración, como los sistemas aeroespaciales gubernamentales. este software desarrollaron grandes equipos que trabajaban para diferentes com-pañías. menudo los equipos estaban geográficamente dispersos laboraban por largos periodos software. ejemplo este tipo software sistema control una aeronave moderna, que puede tardar hasta años desde especificación inicial hasta implementación. estos enfoques basados plan incluyen costos operativos significativos planeación, diseño documentación del sistema. dichos gas-tos justifican cuando debe coordinarse trabajo múltiples equipos desarrollo, cuando sistema sistema crítico cuando numerosas personas intervendrán mantenimiento del software largo vida. sin embargo, cuando este engorroso enfoque desarrollo basado planeación aplica sistemas negocios pequeños medianos, los costos que incluyen son tan grandes que dominan proceso desarrollo del software. invierte más tiempo diseñar sistema, que desarrollo prueba del programa. conforme cambian los requerimientos del sistema, resulta esencial reelaboración , principio menos, especificación diseño deben modificarse con programa. década descontento con estos enfoques engorrosos ingeniería software condujo algunos desarrolladores software proponer nuevos “métodos -.indd -.indd // :: // :: . ■ métodos ágiles ágiles”, los cuales permitieron que equipo desarrollo enfocara software lugar del diseño documentación. los métodos ágiles apoyan universalmente enfoque incremental para especificación, desarrollo entrega del software. son más adecuados para diseño aplicaciones que los requerimientos del sistema cam-bian, por general, rápidamente durante proceso desarrollo. tienen intención entregar con prontitud software operativo los clientes, quienes entonces propondrán requerimientos nuevos variados para incluir posteriores iteraciones del sistema. dirigen simplificar proceso burocrático evitar trabajo con valor dudoso largo plazo, eliminar documentación que quizá nunca emplee. filosofía detrás los métodos ágiles refleja manifiesto ágil, que acordaron muchos los desarrolladores líderes estos métodos. este manifiesto afirma: estamos descubriendo mejores formas para desarrollar software, hacerlo ayudar otros hacerlo. gracias este trabajo llegamos valorar: los individuos las interacciones sobre los procesos las herramientas software operativo sobre documentación exhaustivala colaboración con cliente sobre negociación del contratola respuesta cambio sobre seguimiento plan esto , aunque exista valor los objetos derecha, valoraremos más los izquierda. probablemente método ágil más conocido sea programación extrema (beck, ; beck, ), descrita más adelante este capítulo. otros enfoques ágiles inclu-yen los scrum (cohn, ; schwaber, ; schwaber beedle, ), crystal (cockburn, ; cockburn, ), desarrollo software adaptativo (highsmith, ), dsdm (stapleton, ; stapleton, ) desarrollo dirigido por caracte-rísticas (palmer felsing, ). éxito dichos métodos condujo cierta integración con métodos más tradicionales desarrollo, basados modelado sistemas, cual resulta noción modelado ágil (ambler jeffries, ) ejemplificaciones ágiles del proceso racional unificado (larman, ). aunque todos esos métodos ágiles basan noción del desarrollo entrega incrementales, proponen diferentes procesos para lograrlo. sin embargo, comparten una serie principios, según manifiesto ágil , por ende, tienen mucho común. dichos principios muestran figura .. diferentes métodos ágiles ejemplifican esos prin-cipios diversas formas; sin embargo, cuenta con espacio suficiente para discutir todos los métodos ágiles. cambio, este texto enfoca dos los métodos usados más ampliamente: programación extrema (sección .) scrum (sección .). los métodos ágiles han tenido mucho éxito para ciertos tipos desarrollo sistemas: . desarrollo del producto, donde una compañía software elabora producto pequeño mediano para venta. . diseño sistemas medida dentro una organización, donde hay claro compromiso del cliente por intervenir proceso desarrollo, donde exis- ten muchas reglas regulaciones externas que afecten software. -.indd -.indd // :: // :: capítulo ■ desarrollo ágil software como analiza sección final este capítulo, éxito los métodos ágiles debe interés considerable por usar dichos métodos para otros tipos desarrollo del software. obstante, dado enfoque equipos reducidos firmemente integrados, hay problemas escalarlos hacia grandes sistemas. también experimentado uso enfoques ágiles para ingeniería sistemas críticos (drobna ., ). sin embargo, causa las necesidades seguridad, protección análisis confiabilidad los sistemas críticos, los métodos ágiles requieren modificaciones significativas antes usarse cotidianamente con ingeniería sistemas críticos. práctica, los principios que subyacen los métodos ágiles son veces difíciles cumplir: . aunque atractiva idea del involucramiento del cliente proceso desarro- llo, éxito radica tener cliente que desee pueda pasar tiempo con equipo desarrollo, éste represente todos los participantes del sistema. los represen-tantes del cliente están comúnmente sujetos otras presiones, así que intervienen por completo desarrollo del software. . quizás algunos miembros del equipo cuenten con personalidad adecuada para participación intensa característica los métodos ágiles , consecuencia, podrán interactuar adecuadamente con los otros integrantes del equipo. . priorizar los cambios sería extremadamente difícil, sobre todo sistemas donde existen muchos participantes. cada uno por general ofrece diversas prioridades diferentes cambios. . mantener simplicidad requiere trabajo adicional. bajo presión fechas entrega, posible que los miembros del equipo carezcan tiempo para realizar las simplificaciones deseables sistema.figura . los principios los métodos ágilesprincipio descripción participación del cliente los clientes deben intervenir estrechamente durante proceso desarrollo. función consiste ofrecer priorizar nuevos requerimientos del sistema evaluar las iteraciones del mismo. entrega incremental software desarrolla incrementos cliente especifica los requerimientos que van incluir cada incremento. personas, procesos tienen que reconocerse aprovecharse las habilidades del equipo desarrollo. debe permitirse los miembros del equipo desarrollar sus propias formas trabajar sin procesos establecidos. adoptar cambio esperar que cambien los requerimientos del sistema , este modo, diseñar sistema para adaptar dichos cambios. mantener simplicidad enfocarse simplicidad tanto software desarrollar como proceso desarrollo. siempre que sea posible, trabajar manera activa para eliminar complejidad del sistema. -.indd -.indd // :: // :: . ■ métodos ágiles . muchas organizaciones, especialmente las grandes compañías, pasan años cambiando cultura, tal modo que los procesos definan continúen. para ellas, resulta difícil moverse hacia modelo trabajo donde los procesos sean informales estén definidos por equipos desarrollo. otro problema que técnico, decir, que consiste problema general con desarrollo entrega incremental, ocurre cuando cliente del sistema acude una organización externa para desarrollo del sistema. por general, documento requerimientos del software forma parte del contrato entre cliente proveedor. como especificación incremental inherente los métodos ágiles, quizá sea difícil elaborar contratos para este tipo desarrollo. como resultado, los métodos ágiles deben apoyarse contratos, los cuales cliente pague por tiempo requerido para desarrollo del sistema, vez hacerlo por desarrollo conjunto específico requerimientos. tanto todo marche bien, esto beneficia tanto cliente como desarrollador. obstante, cuando surgen proble-mas, sería difícil discutir acerca quién culpable quién debería pagar por tiempo los recursos adicionales requeridos para solucionar las dificultades. mayoría los libros ensayos que describen los métodos ágiles las experien-cias con éstos hablan del uso dichos métodos para desarrollo nuevos sistemas. sin embargo, como explica capítulo , una enorme cantidad esfuerzo ingeniería software usa mantenimiento evolución los sistemas software existentes. hay sólo pequeño número reportes experiencia sobre uso métodos ágiles para mantenimiento software (poole huisman, ). presentan entonces dos preguntas que deberían considerarse junto con los métodos mantenimiento ágiles: . ¿los sistemas que desarrollan usando enfoque ágil mantienen, pesar del énfasis proceso desarrollo minimizar documentación formal? . ¿los métodos ágiles pueden usarse con efectividad para evolucionar sistema como respuesta requerimientos cambio por parte del cliente? estima que documentación formal describe sistema , por tanto, facilita com- prensión quienes cambian sistema. sin embargo, práctica, con frecuencia - mentación formal conserva actualizada , por ende, refleja con precisión código del programa. por esta razón, los apasionados los métodos ágiles argumentan que escribir esta documentación una pérdida tiempo que clave para implemen-tar software mantenible producir código legible alta calidad. esta manera, las prácticas ágiles enfatizan importancia escribir código bien estructurado des-tinar esfuerzo mejorar código. consecuencia, falta documentación debe representar problema para mantener los sistemas desarrollados con uso enfoque ágil. obstante, según experiencia del autor con mantenimiento sistemas, éste sugiere que documento clave documento requerimientos del sistema, cual indica ingeniero software que supone que debe hacer sistema. sin tal conocimiento, difícil valorar efecto los cambios propuestos sistema. varios métodos ágiles recopilan los requerimientos manera informal incremental, aun-que sin crear documento coherente requerimientos. este respecto, probable -.indd -.indd // :: // :: capítulo ■ desarrollo ágil software que uso métodos ágiles haga más difícil costoso mantenimiento posterior del sistema. factible que las prácticas ágiles, usadas proceso mantenimiento , resulten efectivas, sea que utilice utilice enfoque ágil para desarrollo del sistema. entrega incremental, diseño para cambio mantenimiento simplicidad tienen sentido cuando modifica software. hecho, pensaría tanto proceso desarrollo ágil como proceso evolución del software. sin embargo, quizá principal dificultad luego entregar software sea mantener cliente interviniendo proceso. aunque cliente justifique participación tiempo completo representante durante desarrollo del sistema, esto menos probable mantenimiento, cuando los cambios son continuos. posible que los representantes del cliente pierdan interés sistema. consecuencia, previsible que requieran mecanismos alternativos, como las propuestas cambio, descritas capítulo , para establecer los nuevos requerimientos del sistema. otro problema potencial tiene que ver con mantener continuidad del equipo desa-rrollo. los métodos ágiles apoyan aquellos miembros del equipo que comprenden los aspectos del sistema sin que deban consultar documentación. separa equipo desarrollo ágil, entonces pierde este conocimiento implícito difícil que los nuevos miembros del equipo acumulen misma percepción del sistema sus componentes. quienes apoyan los métodos ágiles han creído fielmente promoción uso tienden pasar por alto sus limitaciones. esto alienta una respuesta igualmente extrema que, para autor, exagera los problemas con este enfoque (stephens rosenberg, ). críticos más razonables como demarco boehm (demarco boehm, ) des-tacan tanto las ventajas como las desventajas los métodos ágiles. proponen enfoque híbrido donde los métodos ágiles que incorporan algunas técnicas del desarrollo dirigido por plan son mejor forma avanzar. . desarrollo dirigido por plan desarrollo ágil los enfoques ágiles desarrollo software consideran diseño implementa-ción como las actividades centrales proceso del software. incorporan otras activida-des diseño implementación, como adquisición requerimientos pruebas. contraste, enfoque basado plan para ingeniería software identifica etapas separadas proceso software con salidas asociadas cada etapa. las sali-das una etapa usan como base para planear siguiente actividad del proceso. figura . muestra las distinciones entre los enfoques ágil basado plan para especificación sistemas. enfoque basado plan, iteración ocurre dentro las actividades con documentos formales usados para comunicarse entre etapas del proceso. por ejemplo, los requerimientos evolucionarán , final cuentas, producirá una especificación aquéllos. esto entonces una entrada proceso diseño implementación. enfoque ágil, iteración ocurre través las actividades. por tanto, los requerimien-tos diseño desarrollan conjunto, por separado. proceso software dirigido por plan soporta desarrollo entrega incre-mentales. perfectamente factible asignar requerimientos planear tanto fase diseño desarrollo como una serie incrementos. proceso ágil está inevitable- -.indd -.indd // :: // :: . ■ desarrollo dirigido por plan desarrollo ágil mente enfocado código puede producir cierta documentación diseño. como expone siguiente sección, equipo desarrollo ágil puede incluir “pico” documentación donde, vez producir una nueva versión sistema, equipo generará documentación del sistema. hecho, mayoría los proyectos software incluyen prácticas los enfoques ágil basado plan. para decidir sobre equilibrio entre enfoque basado plan uno ágil, deben responder algunas preguntas técnicas, humanas organizacionales: . ¿ importante tener una especificación diseño muy detallados antes diri- girse implementación? siendo así, probablemente usted tenga que usar enfo- que basado plan. . ¿ práctica una estrategia entrega incremental, donde software los clientes obtenga así una rápida retroalimentación ellos? ser caso, con-sidere uso métodos ágiles. . ¿qué tan grande sistema que desarrollará? los métodos ágiles son más efec- tivos cuando sistema logra diseñarse con pequeño equipo asignado que comunique manera informal. esto sería imposible para los grandes sistemas que precisan equipos desarrollo más amplios, manera que tal vez utilice enfoque basado plan. . ¿qué tipo sistema desarrollará? los sistemas que demandan mucho análisis antes implementación (por ejemplo, sistema tiempo real con requerimien-tos temporización compleja), por general, necesitan diseño bastante deta-llado para realizar este análisis. tales circunstancias, quizá sea mejor enfoque basado plan. . ¿cuál tiempo vida que espera del sistema? los sistemas con lapsos vida prolongados podrían requerir más documentación diseño, para comunicar equipo apoyo los propósitos originales los desarrolladores del sistema. sin embargo, especificación requerimientosingeniería requerimientosdiseño implementación petición cambio requerimientosdesarrollo basado plan desarrollo ágil ingeniería requerimientosdiseño implementación figura . especificación ágil dirigida por plan -.indd -.indd // :: // :: capítulo ■ desarrollo ágil software los defensores los métodos ágiles argumentan acertadamente que con frecuencia documentación conserva actualizada, usa mucho para mantenimiento del sistema largo plazo. . ¿qué tecnologías hallan disponibles para apoyar desarrollo del sistema? los métodos ágiles auxilian menudo buenas herramientas para seguir pista diseño evolución. desarrolla sistema con ide sin contar con bue-nas herramientas para visualización análisis programas, entonces posiblemente requiera más documentación diseño. . ¿cómo está organizado equipo desarrollo? equipo desarrollo está dis- tribuido, parte del desarrollo subcontrata, entonces tal vez requiera elabo-rar documentos diseño para comunicarse través los equipos desarrollo. quizá necesite planear por adelantado cuáles son. . ¿existen problemas culturales que afecten desarrollo del sistema? las organi- zaciones ingeniería tradicionales presentan una cultura desarrollo basada plan, pues una norma ingeniería. esto requiere comúnmente una amplia documentación diseño, vez del conocimiento informal que utiliza los procesos ágiles. . ¿qué tan buenos son los diseñadores programadores equipo desarrollo? argumenta ocasiones que los métodos ágiles requieren niveles habilidad superiores los enfoques basados plan, que los programadores simple-mente traducen diseño detallado código. usted tiene equipo con nive-les habilidad relativamente bajos, probable que necesite del mejor personal para desarrollar diseño, siendo otros los responsables programación. . ¿ sistema está sujeto regulación externa? regulador externo tiene que apro- bar sistema (por ejemplo, agencia aviación federal [faa] estadounidense aprueba software que crítico para operación una aeronave), entonces, tal vez requerirá documentación detallada como parte del sistema seguridad. realidad, irrelevante conflicto sobre proyecto puede considerarse diri-gido por plan ágil. final cuentas, principal inquietud los compradores sistema software cuentan con sistema software ejecutable, que cubra sus necesidades realice funciones útiles para usuario manera individual dentro una organización. práctica, muchas compañías que afirman haber usado métodos ágiles adoptaron algunas habilidades ágiles las integraron con sus procesos dirigidos por plan. . programación extrema programación extrema () quizás método ágil mejor conocido más amplia-mente usado. nombre acuñó beck () debido que enfoque desarrolló llevando niveles “extremos” las prácticas reconocidas, como desarrollo iterativo. por ejemplo, muchas versiones actuales sistema pueden desarrollarse mediante diferentes programadores, integrarse ponerse prueba solo día. -.indd -.indd // :: // :: . ■ programación extrema programación extrema, los requerimientos expresan como escenarios (llama- dos historias usuario), que implementan directamente como una serie tareas. los programadores trabajan pares antes escribir código desarrollan pruebas para cada tarea. todas las pruebas deben ejecutarse con éxito una vez que nuevo código integre sistema. entre las liberaciones del sistema existe breve lapso. figura . ilustra proceso para producir incremento del sistema por desarrollar. programación extrema incluye algunas prácticas, resumidas figura ., las cuales reflejan los principios los métodos ágiles: . desarrollo incremental apoya pequeñas frecuentes liberaciones del sis- tema. los requerimientos fundamentan simples historias del cliente, bien, escenarios usados como base para decidir qué funcionalidad debe incluirse incremento del sistema. . inclusión del cliente apoya través enlace continuo con cliente equipo desarrollo. representante del cliente participa desarrollo responsable definir las pruebas aceptación para sistema. . las personas, los procesos, basan programación pares, propiedad colectiva del código del sistema proceso desarrollo sustentable que incluya jornadas trabajo excesivamente largas. . cambio acepta mediante liberaciones regulares del sistema los clientes, desa- rrollo primera prueba, refactorización para evitar degeneración del código inte-gración continua nueva funcionalidad. . mantener simplicidad logra mediante refactorización constante, que mejora calidad del código, con uso diseños simples que anticipan innecesaria-mente futuros cambios sistema. proceso , los clientes intervienen estrechamente especificación prio-rización los requerimientos del sistema. estos últimos especifican como lis-tas actividades requeridas del sistema. cambio, cliente del sistema forma parte del equipo desarrollo discute los escenarios con otros miembros del equipo. conjunto, desarrollan una “tarjeta historia” que encapsula las necesidades del cliente. entonces, equipo desarrollo implementa dicho escenario una liberación futura del software. figura . muestra ejemplo una tarjeta historia para desglosar las historias tareasseleccionar historia usuario para esta liberaciónplanear liberación liberación del softwareevaluar sistemadesarrollar/ integrar/ poner prueba softwarefigura . ciclo liberación programación extrema -.indd -.indd // :: // :: capítulo ■ desarrollo ágil software sistema administración pacientes atención salud mental. ésta una breve descripción escenario para prescribir medicamentos paciente. las tarjetas historia son las entradas principales proceso planeación “juego planeación”. una vez diseñadas las tarjetas historia, equipo desarrollo las descompone tareas (figura .) estima esfuerzo los recursos requeridos para implementar cada tarea. esto involucra por general discusiones con cliente para refi-nar los requerimientos. entonces, para implementación, cliente prioriza las historias elige aquellas que pueden usarse inmediatamente para entregar apoyo empresarial útil. intención identificar funcionalidad útil que pueda implementarse aproximadamente dos semanas, cuando siguiente liberación del sistema esté disponible para cliente. desde luego, conforme cambian los requerimientos, las historias implementadas cambian desechan. demandan cambios para sistema que entregó, desarrollan nuevas tarjetas historia , otra vez, cliente decide dichos cambios tienen prioridad sobre nueva función.figura . prácticas programación extremaprincipio práctica descripción planeación incremental los requerimientos registran tarjetas historia (story cards) las historias que van incluir una liberación determinan por tiempo disponible prioridad relativa. los desarrolladores desglosan dichas historias “tareas” desarrollo. vea las figuras . .. liberaciones pequeñas principio desarrolla conjunto mínimo funcionalidad útil, que ofrece valor para negocio. las liberaciones del sistema son frecuentes agregan incrementalmente funcionalidad primera liberación. diseño simple realiza diseño suficiente para cubrir sólo aquellos requerimientos actuales. desarrollo primera pruebase usa marco referencia prueba unidad automatizada escribir las pruebas para una nueva pieza funcionalidad, antes que esta última implemente. refactorización espera que todos los desarrolladores refactoricen manera continua código , tan pronto como sea posible, encuentren mejoras éste. anterior conserva código simple mantenible. programación pares los desarrolladores trabajan pares, cada uno comprueba trabajo del otro; además, ofrecen apoyo para que realice siempre buen trabajo. propiedad colectiva los desarrolladores pares laboran todas las áreas del sistema, manera que desarrollan islas experiencia, que todos los desarrolladores responsabilizan por todo código. cualquiera puede cambiar cualquier función. integración continua tan pronto como esté completa una tarea, integra todo sistema. después tal integración, deben aprobarse todas las pruebas unidad sistema. ritmo sustentable grandes cantidades tiempo extra consideran aceptables, pues efecto neto este tiempo libre con frecuencia reducir calidad del código productividad término medio. cliente sitio representante del usuario final del sistema ( cliente) tiene que disponer tiempo completo para formar parte del equipo . proceso programación extrema, cliente miembro del equipo desarrollo responsable llevar los requerimientos del sistema grupo para implementación. -.indd -.indd // :: // :: . ■ programación extrema veces, durante planeación del juego, salen luz preguntas que pueden res- ponderse fácilmente requiere trabajo adicional para explorar posibles soluciones. equipo puede elaborar algún prototipo tratar desarrollarlo para entender problema solución. términos , éste “pico” (spike), decir, incremento donde realiza programación. también suele haber “picos” para diseñar arquitectura del sistema desarrollar documentación del sistema. programación extrema toma enfoque “extremo” para desarrollo incremental. nuevas versiones del software construyen varias veces día las versiones entre-gan los clientes aproximadamente cada dos semanas. nunca descuidan las fechas límite las liberaciones; hay problemas desarrollo, consulta cliente fun-cionalidad elimina liberación planeada. cuando programador diseña sistema para crear una nueva versión, debe correr todas las pruebas automatizadas existentes, así como las pruebas para nueva funcionali-dad. nueva construcción del software acepta siempre que todas las pruebas ejecu-ten con éxito. entonces esto convierte base para siguiente iteración del sistema. precepto fundamental ingeniería software tradicional que tiene que diseñar para cambiar. esto , deben anticiparse cambios futuros software diseñarlo manera que dichos cambios implementen con facilidad. sin embargo, programa-ción extrema descartó este principio basada hecho que diseñar para cambio con frecuencia desperdicia esfuerzo. vale pena gastar tiempo adicionar gene-ralidad programa para enfrentar cambio. los cambios anticipados casi nunca materializan realidad pueden hacerse peticiones cambio diametralmente opues-tas. por tanto, enfoque acepta que los cambios sucederán cuando éstos ocurran realmente reorganizará software.prescripción medicamentos kate una médica que quiere prescribir fármacos paciente que atiende una clínica. archivo del paciente desplegó computadora, manera que clic campo del medicamento luego puede seleccionar “medicamento actual”, “medicamento nuevo” “formulario”. selecciona “medicamento actual”, sistema pide comprobar dosis. quiere cambiar dosis, ingresa dosis luego confirma prescripción. elige “medicamento nuevo”, sistema supone que kate sabe cuál medicamento prescribir. ella teclea las primeras letras del nombre del medicamento. sistema muestra una lista medicamentos posibles cuyo nombre inicia con dichas letras. posteriormente elige fármaco requerido sistema responde solicitándole que verifique que medicamento seleccionado sea correcto. ella ingresa dosis luego confirma prescripción. kate elige “formulario”, sistema muestra recuadro búsqueda para formulario aprobado. entonces busca medicamento requerido. ella selecciona medicamento sistema pide comprobar que éste sea correcto. luego ingresa dosis confirma prescripción. sistema siempre verifica que dosis esté dentro del rango aprobado. así, pide kate que modifique. después que ella confirma prescripción, desplegará para verificación. kate hace clic “” “cambiar”. hace clic “”, prescripción registra base datos auditoría. hace clic “cambiar”, reingresa proceso “prescripción medicamento”. figura . una historia “prescripción medicamento” -.indd -.indd // :: // :: capítulo ■ desarrollo ágil software problema general con desarrollo incremental que tiende degradar estruc- tura del software, modo que los cambios software vuelven cada vez más difíciles implementar. esencia, desarrollo avanza encontrar soluciones alternativas los problemas, con resultado que código duplica con frecuencia, partes del software reutilizan forma inadecuada estructura global degrada conforme código agrega sistema. programación extrema aborda este problema sugerir que software debe refac-torizarse continuamente. esto significa que equipo programación busca posibles mejoras software las implementa inmediato. cuando miembro del equipo observa código que puede optimarse, realiza dichas mejoras, aun situaciones donde hay necesidad apremiante ellas. los ejemplos refactorización incluyen reor-ganización una jerarquía clases para remover código duplicado, ordenamiento cambio nombre atributos métodos, sustitución código con llamadas métodos definidos librería programa. los entornos desarrollo del pro-grama, como eclipse (carlson, ), incluyen herramientas para refactorizar, cual simplifica proceso encontrar dependencias entre secciones código realizar modificaciones globales código. entonces, principio, software siempre debe ser fácil comprensión cambiar medida que implementen nuevas historias. práctica, siempre caso. ocasiones presión del desarrollo significa que refactorización demora, porque dedica tiempo implementación una nueva funcionalidad. algunas característi-cas cambios nuevos pueden ajustarse con facilidad refactorizar nivel del código requerir modificar arquitectura del sistema. práctica, muchas compañías que adoptaron usan todas las prácticas programación extrema que mencionan figura .. seleccionan según sus formas específicas trabajar. por ejemplo, algunas compañías encuentran útil programación pares; otras prefieren usar programación las revisiones individuales. para acomo-dar diferentes niveles habilidad, algunos programadores hacen refactorización partes del sistema que ellos desarrollan, pueden usarse requerimientos convenciona-les vez historias usuario. sin embargo, mayoría las compañías que adoptan una variante usan liberaciones pequeñas, desarrollo primera prueba integración continua.figura . ejemplos tarjetas tarea para prescripción medicamentos. tarea : cambiar dosis del medicamento prescrito tarea : selección formulario tarea : verificación dosis verificación dosis una prevención seguridad para comprobar que médico prescribe una dosisriesgosamente pequeña grande. usar del formulario para nombre genérico del medicamento, busca formulario recupera las dosis, máxima mínima, recomendadas. verifica dosis prescrita contra mínimo máximo. está fuera rango, emite mensaje error señalando que dosis muy alta muy baja. está dentro del rango, habilita botón “confirmar”. -.indd -.indd // :: // :: . ■ programación extrema .. pruebas como indicó introducción este capítulo, una las diferencias importantes entre desarrollo incremental desarrollo dirigido por plan está forma que sistema pone prueba. con desarrollo incremental, hay especificación sis-tema que pueda usar equipo prueba externo para desarrollar pruebas del sistema. consecuencia, algunos enfoques del desarrollo incremental tienen proceso prue-bas muy informal, comparado con las pruebas dirigidas por plan. para evitar varios los problemas prueba validación del sistema, enfatiza importancia prueba programa. incluye enfoque para probar que reduce las posibilidades introducir errores detectados versión actual del sistema. las características clave poner prueba son: . desarrollo primera prueba, . desarrollo pruebas incrementales partir escenarios,. involucramiento del usuario desarrollo validación pruebas, . uso marcos pruebas automatizadas. desarrollo primera prueba una las innovaciones más importantes . lugar escribir algún código luego las pruebas para dicho código, las pruebas elaboran antes escribir código. esto significa que prueba puede correrse con-forme escribe código descubrir problemas durante desarrollo. escribir pruebas implícitamente define tanto una interfaz como una especificación del comportamiento para funcionalidad desarrollar. reducen los problemas mala interpretación los requerimientos interfaz. este enfoque puede adoptarse cualquier proceso donde haya una relación clara entre requerimiento sistema código que implementa dicho requerimiento. , siempre observa este vínculo porque las tarjetas historia que representan los requerimientos descomponen tareas, éstas son principal unidad implementación. adopción del desarrollo primera prueba condujo enfoques desarrollo basados pruebas más genera-les (astels, ). éstas estudian capítulo . desarrollo primera prueba, los implementadores tarea deben comprender ampliamente especificación, modo que sean capaces escribir pruebas para sistema. esto significa que las ambigüedades omisiones especificación deben clarificarse antes comenzar implementación. más aún, también evita problema del “retraso prueba”. esto puede ocurrir cuando desarrollador del sistema trabaja ritmo más rápido que examinador. implementación está cada vez más adelan- las pruebas hay una tendencia omitirlas, modo que mantenga fecha desarrollo. los requerimientos usuario expresan como escenarios historias, usua-rio los prioriza para desarrollo. equipo desarrollo valora cada escenario des-compone tareas. por ejemplo, figura . muestran algunas las tarjetas tarea desarrolladas partir tarjeta historia para prescripción medicamentos (figura .). cada tarea genera una más pruebas unidad, que verifican implementación descrita dicha tarea. figura . una descripción breve caso prueba que desarrolló para comprobar que dosis prescrita medicamento halle fuera los límites seguridad conocidos. -.indd -.indd // :: // :: capítulo ■ desarrollo ágil software papel del cliente proceso pruebas ayudar desarrollar pruebas aceptación para las historias, que deban implementarse siguiente liberación del sistema. como estudiará capítulo , las pruebas aceptación son proceso donde sistema pone prueba usando datos del cliente para verificar que cubren las necesidades reales éste. , prueba aceptación, como desarrollo, incremental. cliente que forma parte del equipo escribe pruebas conforme avanza desarrollo. por tanto, todo código nuevo valida para garantizar que eso sea que necesita cliente. para historia figura ., prueba aceptación implicaría escenarios donde ) cambió dosis medicamento, ) seleccionó nuevo medicamento ) usó formulario para encontrar medicamento. práctica, requiere por general una serie pruebas aceptación vez una sola prueba. contar con cliente para apoyar desarrollo pruebas aceptación ocasiones una gran dificultad proceso pruebas . quienes adoptan rol del cliente tienen disponibilidad muy limitada, por que probable que trabajen tiempo completo con equipo desarrollo. cliente podría creer que brindar los requerimientos fue suficiente contribución , por tanto, mostrarían renuentes intervenir proceso pruebas. automatización las pruebas esencial para desarrollo primera prueba. las pruebas escriben como componentes ejecutables antes implementar tarea. dichos componentes pruebas deben ser independientes, simular envío entrada probar verificar que resultado cumple con especificación salida. marco pruebas automatizadas sistema que facilita escritura pruebas realizables envía una serie pruebas para ejecución. junit (massol husted, ) ejemplo usado ampliamente marco pruebas automatizadas. conforme automatizan las pruebas, siempre hay una serie pruebas que ejecutan rápida fácilmente. cada vez que agregue cualquier funcionalidad sistema, pueden correrse las pruebas conocerse inmediato los problemas que introduce nuevo código. desarrollo primera prueba las pruebas automatizadas por general dan por resultado gran número pruebas que escriben ejecutan. sin embargo, este enfo-que conduce necesariamente pruebas minuciosas del programa. existen tres razones para ello: . los programadores prefieren programar que probar , ocasiones, toman atajos cuando escriben pruebas. por ejemplo, escriben pruebas incompletas que com- prueban todas las posibles excepciones que quizás ocurran.figura . descripción caso prueba para comprobar dosisentrada: . número que represente una sola dosis del medicamento.. número que signifique número dosis individuales por día. pruebas: . probar las entradas donde dosis individual sea correcta, pero frecuencia muy elevada.. probar las entradas donde dosis individual sea muy alta muy baja.. probar las entradas donde dosis individual × frecuencia sea muy alta muy baja.. probar las entradas donde dosis individual × frecuencia esté rango permitido. salida: mensaje error que indique que dosis está fuera del rango seguridad.prueba : comprobación dosis -.indd -.indd // :: // :: . ■ programación extrema . algunas pruebas llegan ser muy difíciles escribir manera incremental. por ejemplo, una interfaz usuario compleja, suele ser complicado escribir pruebas unidad para código que implementa “lógica despliegue” flujo tra-bajo entre pantallas. . difícil juzgar totalidad conjunto pruebas. aunque tenga muchas prue- bas sistema, conjunto pruebas ofrece cobertura completa. partes críticas del sistema pueden ejecutarse , por ende, permanecerían sin probarse. consecuencia, aunque gran conjunto pruebas ejecutadas regularmente impresión que sistema está completo correcto, esto tal vez sea caso. las pruebas revisan escriben más pruebas después del desarrollo, entonces pueden entregarse bugs (problemas, errores programa) liberación del sistema. .. programación pares otra práctica innovadora que introdujo que los programadores trabajan pares para desarrollar software. realidad, trabajan juntos misma estación trabajo para desarrollar software. sin embargo, los mismos pares siempre progra-man juntos. vez ello, los pares crean dinámicamente, manera que todos los miembros del equipo trabajen entre durante proceso desarrollo. uso programación pares tiene algunas ventajas: . apoya idea propiedad responsabilidad colectivas para sistema. esto refleja idea weinberg () sobre programación sin ego, donde software propiedad del equipo como todo los individuos son responsables por los problemas con código. cambio, equipo tiene responsabilidad colectiva para resolver dichos problemas. . actúa como proceso revisión informal, porque menos dos personas obser- van cada línea código. las inspecciones revisiones código (que explican capítulo ) son muy eficientes para detectar alto porcentaje errores software. sin embargo, consumen tiempo organización , usualmente, pre-sentan demoras proceso desarrollo. aunque programación pares proceso menos formal que quizá identifica tantos errores como las inspecciones código, proceso inspección mucho más económico que las inspeccio-nes formales del programa. . ayuda refactorización, que proceso mejoramiento del software. difi- cultad implementarlo entorno desarrollo normal que esfuerzo refactorización utiliza para beneficio largo plazo. individuo que practica fac-torización podría calificarse como menos eficiente que uno que simplemente realiza desarrollo del código. donde usan programación pares propiedad colectiva, otros benefician inmediatamente refactorización, modo que probable que apoyen proceso. respecto, tal vez pensaría que programación pares menos eficiente que programación individual. tiempo dado, par desarrolladores elaboraría -.indd -.indd // :: // :: capítulo ■ desarrollo ágil software mitad del código que dos individuos que trabajen solos. hay varios estudios productividad los programadores pares con resultados mixtos. usar estudiantes voluntarios, williams sus colaboradores (cockburn williams, ; williams ., ) descubrieron que productividad con programación pares comparable con dos individuos que trabajan manera independiente. las razones sugeridas son que los pares discuten software antes desarrollarlo, modo que probablemente tengan menos salidas falso menos rediseño. más aún, número errores que evitan por inspección informal tal que emplea menos tiempo reparar los bugs descubiertos durante proceso pruebas. sin embargo, los estudios con programadores más experimentados (arisholm ., ; parrish ., ) replican dichos resultados. hallaron que había una pérdida productividad significativa comparada con dos programadores que trabajan indivi-dualmente. hubo algunos beneficios calidad, pero compensaron por completo los costos programación pares. obstante, intercambio conocimiento que ocurre durante programación pares muy importante, pues reduce los riesgos glo-bales proyecto cuando salen miembros del equipo. mismo, esto hace que programación este tipo valga pena. . administración proyecto ágil responsabilidad principal los administradores del proyecto software dirigir proyecto, modo que software entregue tiempo con presupuesto planeado para ello. supervisan trabajo los ingenieros software monitorizan avance desarrollo del software. enfoque estándar administración proyectos basado plan. como estudia capítulo , los administradores apoyan plan para proyecto que muestra que debe entregar cuándo, así como quién trabajará desarrollo los entregables del proyecto. enfoque basado plan requiere realidad que admi-nistrador tenga una visión equilibrada todo que debe diseñarse los procesos desarrollo. sin embargo, funciona bien con los métodos ágiles, donde los requerimien-tos desarrollan incrementalmente, donde software entrega rápidos incrementos cortos, donde los cambios los requerimientos software son norma. como cualquier otro proceso diseño software profesional, desarrollo ágil tiene que administrarse tal modo que busque mejor uso del tiempo los recursos dis-ponibles para equipo. esto requiere enfoque diferente administración del proyecto, que adapte desarrollo incremental las fortalezas particulares los métodos ágiles. aunque enfoque scrum (schwaber, ; schwaber beedle, ) método ágil general, enfoque está administración iterativa del desarrollo, enfoques técnicos específicos para ingeniería software ágil. figura . representa diagrama del proceso administración scrum. este proceso prescribe uso prácticas programación, como programación pares desarrollo primera prueba. por tanto, puede usarse con enfoques ágiles más técnicos, como , para ofre-cer proyecto marco administrativo. existen tres fases con scrum. primera planeación del bosquejo, donde establecen los objetivos generales del proyecto diseño arquitectura software. -.indd -.indd // :: // :: . ■ administración proyecto ágil esto sigue una serie ciclos sprint, donde cada ciclo desarrolla incremento del sistema. finalmente, fase cierre del proyecto concluye proyecto, completa documentación requerida, como los marcos ayuda del sistema los manuales del usuario, valora las lecciones aprendidas proyecto. característica innovadora scrum fase central, saber, los ciclos sprint. sprint scrum una unidad planeación que valora trabajo que realizar, seleccionan las particularidades por desarrollar implementa software. final sprint, funcionalidad completa entrega los participantes. las carac-terísticas clave este proceso son las siguientes: . los sprints tienen longitud fija, por general dos cuatro semanas. corresponden desarrollo una liberación del sistema . . punto partida para planeación cartera del producto, que lista tra- bajo por realizar proyecto. durante fase valoración del sprint, esto revisa, asignan prioridades riesgos. cliente interviene estrechamente este proceso comienzo cada sprint puede introducir nuevos requerimientos tareas. . fase selección incluye todo equipo del proyecto que trabaja con cliente, con finalidad seleccionar las características funcionalidad desarrollar durante sprint. . una vez acordado, equipo organiza para desarrollar software. con obje- tivo revisar progreso , necesario, volver asignar prioridades trabajo, realizan reuniones diarias breves con todos los miembros del equipo. durante esta etapa, equipo aísla del cliente organización, todas las comunicaciones canalizan través del llamado “maestro scrum”. papel este último pro-teger equipo desarrollo distracciones externas. forma que trabajo realiza depende del problema del equipo. diferencia , scrum hace sugerencias específicas sobre cómo escribir requerimientos, desarrollar primera prueba, etcétera. sin embargo, dichas prácticas usan cuando equipo las considera adecuadas. . final del sprint, trabajo hecho revisa presenta los participantes. luego comienza siguiente ciclo sprint. idea detrás scrum que debe autorizarse todo equipo para tomar decisio-nes, modo que evita deliberadamente término “administrador del proyecto”. planeación del bosquejo diseño arquitectónicocierre del proyectovaloración selección revisión desarrollo ciclo sprintfigura . proceso scrum -.indd -.indd // :: // :: capítulo ■ desarrollo ágil software lugar ello, “maestro scrum” facilitador que ordena las reuniones diarias, rastrea atraso del trabajo realizar, registra las decisiones, mide progreso del atraso, comunica con los clientes administradores fuera del equipo. todo equipo asiste las reuniones diarias, que ocasiones son reuniones las que los participantes sientan, para hacerlas breves enfocadas. durante reunión, todos los miembros del equipo comparten información, describen sus avances desde última reunión, los problemas que han surgido los planes del día siguiente. ello signi-fica que todos equipo conocen que acontece , surgen problemas, replantean trabajo corto plazo para enfrentarlo. todos participan esta planeación; hay dirección descendente desde maestro scrum. web existen muchos reportes anecdóticos del uso exitoso del scrum. rising janoff () discuten uso exitoso entorno desarrollo software para tele-comunicaciones mencionan sus ventajas del modo siguiente: . producto desglosa conjunto piezas manejables comprensibles. . los requerimientos inestables retrasan progreso.. todo equipo tiene conocimiento todo , consecuencia, mejora comuni- cación entre equipo. . los clientes observan entrega tiempo los incrementos obtienen retroali- mentación sobre cómo funciona producto. . establece confianza entre clientes desarrolladores, vez que crea una cultura positiva donde todos esperan triunfo del proyecto. scrum, como originalmente designó, tenía intención usarse con equipos coasignados, donde todos los miembros del equipo pudieran congregarse diario reuniones breves. sin embargo, mucho del desarrollo del software implica ahora equi-pos distribuidos con miembros del equipo ubicados diferentes lugares alrededor del mundo. consecuencia, hay varios experimentos marcha con finalidad desarrollar scrum para entornos desarrollo distribuidos (smits pshigoda, ; sutherland ., ). . escalamiento métodos ágiles los métodos ágiles desarrollaron para usarse pequeños equipos programación, que podían trabajar juntos misma habitación comunicarse manera informal. por tanto, los métodos ágiles emplean principalmente para diseño sistemas pequeños medianos. desde luego, necesidad entrega más rápida del software, que más adecuada para las necesidades del cliente, aplica también sistemas más gran-des. por consiguiente, hay enorme interés escalar los métodos ágiles para enfrentar los sistemas mayor dimensión, desarrollados por grandes organizaciones. -.indd -.indd // :: // :: . ■ escalamiento métodos ágiles denning sus colaboradores () argumentan que única forma evitar los pro- blemas comunes ingeniería software, como los sistemas que cubren las necesi-dades del cliente exceden presupuesto, encontrar maneras hacer que los métodos ágiles funcionen para grandes sistemas. leffingwell () discute cuáles prácticas ágiles escalan desarrollo grandes sistemas. moore spens () reportan experien-cia usar enfoque ágil para desarrollar gran sistema médico, con desarrollado-res que trabajaban equipos distribuidos geográficamente. desarrollo grandes sistemas software difiere algunas formas del desarrollo sistemas pequeños: . los grandes sistemas son, por general, colecciones sistemas separados comunicación, donde equipos separados desarrollan cada sistema. dichos equipos trabajan con frecuencia diferentes lugares, ocasiones otras zonas horarias. prácticamente imposible que cada equipo tenga una visión todo sistema. consecuencia, sus prioridades son generalmente completar parte del sistema sin con- rar asuntos los sistemas más amplios. . los grandes sistemas son “sistemas abandonados” (hopkins jenkins, ); esto , incluyen interactúan con algunos sistemas existentes. muchos los requeri-mientos del sistema interesan por interacción , por tanto, realidad prestan flexibilidad desarrollo incremental. aquí también podrían ser relevantes los conflictos políticos menudo solución más sencilla pro-blema cambiar sistema existente. sin embargo, esto requiere negociar con los administradores dicho sistema para convencerlos que los cambios pueden implementarse sin riesgo para operación del sistema. . donde muchos sistemas integran para crear solo sistema, una fracción signifi- cativa del desarrollo ocupa configuración del sistema, desarrollo del código original. esto necesariamente compatible con desarrollo incre-mental integración frecuente del sistema. . los grandes sistemas sus procesos desarrollo por común están restringidos por reglas regulaciones externas, que limitan forma que pueden desarrollarse, cual requiere ciertos tipos documentación del sistema que producir, etcétera. . los grandes sistemas tienen tiempo prolongado adquisición desarrollo. difícil mantener equipos coherentes que conozcan sistema durante dicho periodo, pues resulta inevitable que algunas personas cambien otros empleos proyectos. . los grandes sistemas tienen por general conjunto variado participantes. por ejemplo, cuando enfermeras administradores son los usuarios finales sistema médico, personal médico ejecutivo, los administradores del hospital, etcé-tera, también son participantes sistema. realidad imposible involucrar todos estos participantes proceso desarrollo. existen dos perspectivas escalamiento los métodos ágiles: . una perspectiva “expansión” (scaling ), que interesa por uso dichos métodos para desarrollo grandes sistemas software que logran desarro- llarse con equipos pequeños. -.indd -.indd // :: // :: capítulo ■ desarrollo ágil software . una perspectiva “ampliación” (scaling out), que interesa por que los métodos ágiles introduzcan una organización grande con muchos años experiencia desarrollo software. los métodos ágiles tienen que adaptarse para enfrentar ingeniería los sistemas grandes. leffingwell () explica que esencial mantener los fundamentos los métodos ágiles: planeación flexible, liberación frecuente del sistema, integración conti-nua, desarrollo dirigido por pruebas buena comunicación del equipo. autor considera que las siguientes adaptaciones son críticas deben introducirse: . para desarrollo grandes sistemas posible enfocarse sólo código del sistema. necesario hacer más diseño frontal documentación del sistema. debe diseñarse arquitectura software producirse documentación para describir los aspectos críticos del sistema, como esquemas bases datos, división del trabajo entre los equipos, etcétera. . tienen que diseñarse usarse mecanismos comunicación entre equipos. esto debe incluir llamadas telefónicas regulares, videoconferencias entre los miembros del equipo frecuentes reuniones electrónicas breves, para que los equipos actuali-cen mutuamente del avance. hay que ofrecer varios canales comunicación (como correo electrónico, mensajería instantánea, wikis sistemas redes sociales) para facilitar las comunicaciones. . integración continua, donde todo sistema construya cada vez que desa- rrollador verifica cambio, prácticamente imposible cuando muchos progra-mas separados deben integrarse para crear sistema. sin embargo, resulta esencial mantener construcciones del sistema frecuentes liberaciones del sistema regulares. esto podría significar introducción nuevas herramientas gestión configu-ración que soporten desarrollo software por parte múltiples equipos. las compañías software pequeñas que desarrollan productos software están entre quienes adoptan con más entusiasmo los métodos ágiles. dichas compañías están restringidas por burocracias organizacionales estándares procesos, son capaces cambiar rápidamente para acoger nuevas ideas. desde luego, las compañías más grandes también experimentan proyectos específicos con los métodos ágiles; sin embargo, para ellas mucho más difícil “ampliar” dichos métodos toda organiza-ción. lindvall sus colaboradores () analizan algunos los problemas escalar los métodos ágiles cuatro grandes compañías tecnológicas. difícil introducir los métodos ágiles las grandes compañías por algunas razones: . los gerentes del proyecto carecen experiencia con los métodos ágiles; pueden ser reticentes para aceptar riesgo nuevo enfoque, pues saben cómo afectará sus proyectos particulares. . las grandes organizaciones tienen menudo procedimientos estándares calidad que espera sigan todos los proyectos , dada naturaleza burocrática, proba-ble que sean incompatibles con los métodos ágiles. ocasiones, reciben apoyo herramientas software (por ejemplo, herramientas gestión requerimientos), uso dichas herramientas obligatorio para todos los proyectos. -.indd -.indd // :: // :: . los métodos ágiles parecen funcionar mejor cuando los miembros del equipo tienen nivel habilidad relativamente elevado. sin embargo, dentro grandes orga- nizaciones, probablemente haya una amplia gama habilidades destrezas, los individuos con niveles habilidad inferiores quizá sean miembros equipos efectivos los procesos ágiles. . quizás haya resistencia cultural contra los métodos ágiles, especial aquellas organizaciones con una larga historia uso procesos convencionales ingenie-ría sistemas. los procedimientos gestión cambio pruebas son ejemplos procedimien-tos compañía que podrían ser compatibles con los métodos ágiles. adminis-tración del cambio proceso que controla los cambios sistema, modo que efecto los cambios sea predecible controlen los costos. antes realizarse, todos los cambios deben aprobarse esto entra conflicto con noción refactorización. , cualquier desarrollador puede mejorar cualquier código sin conseguir aprobación externa. para sistemas grandes, también existen estándares pruebas, donde una cons-trucción del sistema envía equipo pruebas externo. esto entraría conflicto con los enfoques primera prueba prueba frecuente utilizados . introducir sostener uso los métodos ágiles largo una organización grande proceso cambio cultural. cambio cultural tarda mucho tiempo implementarse menudo requiere cambio administración antes llevarse cabo. las compañías que deseen usar métodos ágiles necesitan promotores para alentar cambio. tienen que dedicar recursos significativos para proceso del cambio. momento escribir este texto, unas cuantas compañías clasificadas como grandes han realizado una transición exitosa desarrollo ágil largo organización. puntos clave ■ los métodos ágiles son métodos desarrollo incremental que enfocan diseño rápido, liberaciones frecuentes del software, reducción gastos proceso producción código alta calidad. hacen que cliente intervenga directamente proceso desarrollo. ■ decisión acerca usa enfoque desarrollo ágil uno basado plan depende del tipo software que elaborar, las capacidades del equipo desarrollo cultura compañía que diseña sistema. ■ programación extrema método ágil bien conocido que integra rango buenas prácticas programación, como las liberaciones frecuentes del software, mejoramiento continuo del software participación del cliente equipo desarrollo. ■ una fortaleza particular programación extrema, antes crear una característica del programa, desarrollo pruebas automatizadas. todas las pruebas deben ejecutarse con éxito cuando incremento integra sistema.capítulo ■ puntos clave -.indd -.indd // :: // :: ■ método scrum método ágil que ofrece marco referencia para administración del proyecto. centra alrededor conjunto sprints, que son periodos fijos cuando desarrolla incremento sistema. planeación basa priorizar atraso trabajo seleccionar las tareas importancia más alta para sprint. ■ resulta difícil escalamiento los métodos ágiles para sistemas grandes, que éstos necesitan diseño frontal cierta documentación. integración continua prácticamente imposible cuando existen muchos equipos desarrollo separados que trabajan proyecto. lecturas sugeridas extreme programming explained. éste fue primer libro sobre todavía , quizá, más legible. explica enfoque desde perspectiva uno sus inventores entusiasmo evidencia claramente libro. (kent beck, addison-wesley, .) “get ready for agile methods, with care”. una crítica detallada los métodos ágiles, que examina sus fortalezas debilidades; está escrito por ingeniero software con vasta experiencia. (. boehm, ieee computer, enero .) http:/ /doi. ieeecomputersociety. org/ . / . . scaling software agility: best practices for large enterprises . aunque enfoca los conflictos del escalamiento los métodos ágiles, este libro también incluye resumen los principales métodos ágiles, como , scrum crystal. (. leffingwell, addison-wesley, .) running agile software development project. mayoría los libros acerca los métodos ágiles enfocan método específico, pero este texto toma enfoque diferente analiza cómo poner práctica proyecto. buen consejo práctico. (. holcombe, john wiley and sons, .) ejercicios .. explique por qué entrega implementación rápidas nuevos sistemas con frecuencia más importante para las empresas que funcionalidad detallada dichos sistemas. .. señale cómo los principios subyacentes los métodos ágiles conducen acelerado desarrollo implementación del software. .. ¿cuándo desaconsejaría uso método ágil para desarrollar sistema software? .. programación extrema expresa los requerimientos del usuario como historias, cada historia escribe una tarjeta. analice las ventajas desventajas este enfoque para descripción requerimientos. capítulo ■ desarrollo ágil software -.indd -.indd // :: // :: .. explique por qué desarrollo primera prueba ayuda programador diseñar una mejor comprensión los requerimientos del sistema. ¿cuáles son las dificultades potenciales con desarrollo primera prueba? .. sugiera cuatro razones por las que tasa productividad los programadores que trabajan pares llega ser más mitad que dos programadores que trabajan individualmente. .. compare contraste enfoque scrum para administración proyectos con enfoques convencionales basados plan, estudiados capítulo . las comparaciones deben basarse efectividad cada enfoque para planear asignación personal los proyectos, estimar costo los mismos, mantener cohesión del equipo administrar los cambios conformación del equipo del proyecto. .. usted administrador software una compañía que desarrolla software control crítico para una aeronave. responsable elaboración sistema apoyo diseño software, que ayude traducción los requerimientos software una especificación formal del software (que estudia capítulo ). comente acerca las ventajas las desventajas las siguientes estrategias desarrollo: ) recopile los requerimientos para tal sistema con los ingenieros software los participantes externos (como autoridad certificación reguladora), desarrolle sistema usando enfoque basado plan. ) diseñe prototipo usando lenguaje script, como ruby python, evalúe este prototipo con los ingenieros software otros participantes; luego, revise los requerimientos del sistema. vuelva desarrollar sistema final con java. ) desarrolle sistema java usando enfoque ágil, con usuario involucrado equipo diseño. .. sugerido que uno los problemas tener usuario estrechamente involucrado con equipo desarrollo software que “ vuelve nativo”; esto , adopta punto vista del equipo desarrollo pierde visión las necesidades sus colegas usuarios. sugiera tres formas que podría evitar este problema discuta las ventajas desventajas cada enfoque. .. con finalidad reducir costos impacto ambiental del cambio, compañía decide cerrar algunas oficinas ofrecer apoyo personal para trabajar desde casa. sin embargo, gerente que introdujo política está consciente que software desarrolla usando métodos ágiles, que apoya trabajo cercano del equipo programación pares. analice las dificultades que causaría esta nueva política cómo podría solventar estos problemas.capítulo ■ ejercicios -.indd -.indd // :: // :: pmreferencias ambler, . . jeffries, . (). agile modeling: effective practices for extreme programming and the unified process. new york: john wiley & sons. arisholm, ., gallis, ., dyba, . sjoberg, . . . (). “evaluating pair programming with respect system complexity and programmer expertise”. ieee trans. software eng., (), –. astels, . (). test driven development: practical guide. upper saddle river, : prentice hall. beck, . (). “embracing change with extreme programming”. ieee computer, (), –. beck, . (). extreme programming explained. reading, mass.: addison-wesley.carlson, . (). eclipse distilled. boston: addison-wesley.cockburn, . (). agile software development. reading, mass.: addison-wesley.cockburn, . (). crystal clear: human-powered methodology for small teams . boston: addison-wesley.cockburn, . williams, . (). “the costs and benefits pair programming”. extreme programming examined. (.). boston: addison-wesley. cohn, . (). succeeding with agile: software development using scrum . boston: addison-wesley.demarco, . boehm, . (). “the agile methods fray”. ieee computer, (), –. denning, . ., gunderson, . hayes-roth, . (). “evolutionary system development”. comm. acm, (), –.drobna, ., noftz, . raghu, . (). “piloting four mission-critical projects”. ieee software, (), –.highsmith, . . (). adaptive software development: collaborative approach managing complex systems. new york: dorset house. hopkins, . jenkins, . (). eating the elephant: moving from greenfield development brownfield. boston, mass.: ibm press. larman, . (). applying uml and patterns: introduction object-oriented analysis and design and the unified process. englewood cliff, : prentice hall. leffingwell, . (). scaling software agility: best practices for large enterprises . boston: addison-wesley.lindvall, ., muthig, ., dagnino, ., wallin, ., stupperich, ., kiefer, ., may, . kahkonen, . (). “agile software development large organizations”. ieee computer, (), –. capítulo ■ desarrollo ágil software -.indd -.indd // :: // :: pmmartin, . (). application development without programmers. englewood cliffs, : prentice-hall. massol, . husted, . (). junit action. greenwich, conn.: manning publications .mills, . ., ’neill, ., linger, . ., dyer, . quinnan, . . (). “the management software engineering”. ibm systems. ., (), –. moore, . spens, . (). “scaling agile: finding your agile tribe”. proc. agile conference, toronto: ieee computer society. –.palmer, . . felsing, . . (). practical guide feature-driven development. englewood cliffs, : prentice hall. parrish, ., smith, ., hale, . hale, . (). “ field study developer pairs: productivity impacts and implications”. ieee software, (), –. poole, . huisman, . . (). “using extreme programming maintenance environment”. ieee software, (), –. rising, . janoff, . . (). “the scrum software development process for small teams”. ieee software, (), –. schwaber, . (). agile project management with scrum. seattle: microsoft press.schwaber, . beedle, . (). agile software development with scrum. englewood cliffs, : prentice hall. smits, . pshigoda, . (). “implementing scrum distributed software development organization”. agile , washington, : ieee computer society. stapleton, . (). dsdm dynamic systems development method. harlow, : addison-wesley.stapleton, . (). dsdm: business focused development, . harlow, : pearson education.stephens, . rosenberg, . (). extreme programming refactored. berkley, calif.: apress.sutherland, ., viktorov, ., blount, . puntikov, . (). “distributed scrum: agile project management with outsourced development teams”. hawaii int. conf. system sciences, hawaii: ieee computer society. weinberg, . (). the psychology computer programming. new york: van nostrand.williams, ., kessler, . ., cunningham, . jeffries, . (). “strengthening the case for pair programming”. ieee software, (), –.capítulo ■ referencias -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducir los requerimientos software discutir los procesos que hay descubrimiento documentación tales requerimientos. estudiar este capítulo: ■ entenderá los conceptos requerimientos del usuario del sistema, así como por qué tales requerimientos deben escribir diferentes formas; ■ comprenderá las diferencias entre requerimientos software funcionales funcionales; ■ reconocerá cómo organizan los requerimientos dentro documento requerimientos software; ■ conocerá las principales actividades ingeniería requerimientos: adquisición, análisis validación, así como las relaciones entre dichas actividades; ■ analizará por qué necesaria administración requerimientos cómo ésta apoya otras actividades ingeniería requerimientos. contenido . requerimientos funcionales funcionales . documento requerimientos software. especificación requerimientos. procesos ingeniería requerimientos. adquisición análisis requerimientos. validación requerimientos. administración requerimientos ingeniería requerimientos -.indd -.indd // :: // :: pmcapítulo ■ ingeniería requerimientos los requerimientos para sistema son descripciones que sistema debe hacer: servicio que ofrece las restricciones operación. tales requerimientos reflejan las necesidades los clientes por sistema que atienda cierto propósito, como sería con-trolar dispositivo, colocar pedido buscar información. proceso descubrir, analizar, documentar verificar estos servicios restricciones llama ingeniería requerimientos (). término “requerimiento” usa manera continua industria del software. algunos casos, requerimiento simplemente enunciado abstracto alto nivel servicio que debe proporcionar sistema, bien, una restricción sobre sis-tema. otro extremo, consiste una definición detallada formal una función del sistema. davis () explica por qué existen esas diferencias: una compañía desea otorgar contrato para gran proyecto desarro-llo software, tiene que definir sus necesidades una forma suficientemente abstracta para que una solución esté predefinida. los requerimientos deben redactarse tal forma que muchos proveedores liciten pos del contrato, ofre-ciendo, tal vez, diferentes maneras cubrir las necesidades organización del cliente. una vez otorgado contrato, proveedor tiene que escribir con más detalle una definición del sistema para cliente, modo que éste comprenda valide que hará software. estos documentos suelen nombrarse documentos requerimientos para sistema. algunos los problemas que surgen durante proceso ingeniería requerimien-tos son resultado del fracaso hacer una separación clara entre esos diferentes niveles descripción. este texto distinguen con uso del término “requerimientos del usuario” para representar los requerimientos abstractos alto nivel; “requerimientos del sistema” para caracterizar descripción detallada que sistema debe hacer. los requerimientos del usuario los requerimientos del sistema definen del siguiente modo: . los requerimientos del usuario son enunciados, lenguaje natural junto con diagramas, acerca qué servicios esperan los usuarios del sistema, las restric- ciones con las cuales éste debe operar. . los requerimientos del sistema son descripciones más detalladas las funciones, los servicios las restricciones operacionales del sistema software. documento requerimientos del sistema (llamado ocasiones especificación funcional) tiene que definir con exactitud que implementará. puede formar parte del contrato entre comprador del sistema los desarrolladores del software. los diferentes niveles requerimientos son útiles debido que informan sobre sis-tema distintos tipos lector. figura . ilustra diferencia entre los requerimientos del usuario del sistema. este ejemplo sistema administración pacientes para apoyar atención salud mental (mhc-pms) muestra cómo los requerimientos del usuario extienden hacia varios requerimientos del sistema. figura . observa que requerimiento del usuario muy general. los requerimientos del sistema ofrecen información más específica sobre los servicios las funciones del sistema que imple-mentará. -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos necesario escribir los requerimientos con diferentes niveles detalle, que varios lectores los usarán distintas formas. figura . muestra los posibles lectores los requerimientos del usuario los del sistema. éstos, los primeros por gene-ral están interesados manera que implementará sistema, quizá sean administradores quienes les atraigan las facilidades detalladas del sistema. mientras que los segundos necesitan conocer con más precisión qué hará sistema, que están preocupados sobre cómo apoyará los procesos negocios porque están inmersos implementación del sistema. este capítulo presenta panorama “tradicional” los requerimientos, más que los requerimientos los procesos ágiles. para mayoría los sistemas gran-des, todavía presenta una fase ingeniería requerimientos claramente identifi-cable, antes comenzar implementación del sistema. resultado documento requerimientos que puede formar parte del contrato desarrollo del sistema. desde luego, por común hay cambios posteriores los requerimientos, tanto que los reque-rimientos del usuario podrían extenderse como requerimientos sistema más detalla-dos. sin embargo, enfoque ágil para alcanzar, mismo tiempo, los requerimientos medida que sistema desarrolla rara vez utiliza diseño sistemas grandes. . requerimientos funcionales funcionales menudo, los requerimientos del sistema software clasifican como requerimientos funcionales requerimientos funcionales: . requerimientos funcionales son enunciados acerca servicios que sistema debe proveer, cómo debería reaccionar sistema entradas particulares cómo . mhc-pms elaborará mensualmente informes administrativos que revelen costo los medicamentos prescritos por cada clínica durante ese mes. . último día laboral cada mes redactará resumen los medicamentos prescritos, costo las clínicas que los prescriben. . sistema elaborará automáticamente informe que imprimirá después las : del último día laboral del mes.. realizará reporte para cada clínica junto con los nombres cada medicamento, número prescripciones, las dosis prescritas costo total los medicamentos prescritos. . los medicamentos están disponibles diferentes unidades dosis (por ejemplo, , ) harán informes por separado para cada unidad dosis. . acceso los informes costos restringirá usuarios autorizados lista control acceso administrativo.definición del requerimiento del usuario especificación los requerimientos del sistema figura . requerimientos del usuario requerimientos del sistema -.indd -.indd // :: // :: . ■ requerimientos funcionales funcionales debería comportarse sistema situaciones específicas. algunos casos, los reque- rimientos funcionales también explican que debe hacer sistema. . requerimientos funcionales son limitaciones sobre servicios funciones que ofrece sistema. incluyen restricciones tanto temporización del proceso desarrollo, como impuestas por los estándares. los requerimientos funcionales suelen aplicar sistema como todo, más que características servicios individuales del sistema. realidad, distinción entre los diferentes tipos requerimientos tan clara como sugieren estas definiciones sencillas. requerimiento usuario interesado por seguridad, como enunciado que limita acceso usuarios autorizados, parece-ría requerimiento funcional. sin embargo, cuando desarrolla con más detalle, este requerimiento puede generar otros requerimientos que son evidentemente funciona-les, como necesidad incluir facilidades autenticación sistema. esto muestra que los requerimientos son independientes que requerimiento genera restringe normalmente otros requerimientos. por tanto, los requerimientos del sistema sólo detallan los servicios las características que requieren del mismo, sino también especifican funcionalidad necesaria para asegurar que estos servicios características entreguen manera adecuada. .. requerimientos funcionales los requerimientos funcionales para sistema refieren que sistema debe hacer. tales requerimientos dependen del tipo software que esté desarrollando, los usuarios esperados del software del enfoque general que adopta organización cuando escriben los requerimientos. expresarse como requerimientos del usuario, los requerimientos funcionales describen por general forma abstracta que entien-dan los usuarios del sistema. sin embargo, requerimientos funcionales más específicos del sistema detallan las funciones del sistema, sus entradas salidas, sus excepciones, etcétera. los requerimientos funcionales del sistema varían desde requerimientos generales que cubren que tiene que hacer sistema, hasta requerimientos muy específicos que refle-jan maneras locales trabajar los sistemas existentes una organización. por ejem-plo, veamos algunos casos requerimientos funcionales para sistema mhc-pms, que gerentes del cliente usuarios finales del sistemaingenieros del clientegerentes los contratistasarquitectos del sistema usuarios finales del sistemaingenieros del clientearquitectos del sistemadesarrolladores softwarerequerimientos del usuario requerimientos del sistemafigura . lectores diferentes tipos especificación requerimientos -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos usan para mantener información pacientes que reciben tratamiento por problemas salud mental: . usuario podrá buscar todas las clínicas las listas citas. . sistema elaborará diariamente, para cada clínica, una lista pacientes que espera que asistan cita ese día. . cada miembro del personal que usa sistema debe identificarse manera indivi- dual con número ocho dígitos. estos requerimientos funcionales del usuario definen las actividades específicas que debe proporcionar sistema. tomaron del documento requerimientos del usuario muestran que los requerimientos funcionales pueden escribirse con diferentes niveles detalle (contraste los requerimientos ). inexactitud especificación requerimientos causa muchos problemas ingeniería software. natural que desarrollador sistemas interprete reque-rimiento ambiguo forma que simplifique implementación. sin embargo, con frecuencia, esto que desea cliente. tienen que establecerse nuevos requerimientos efectuar cambios sistema. desde luego, esto aplaza entrega del sistema aumenta los costos. caso del primer ejemplo requerimiento para mhc-pms que establece que usuario podrá buscar las listas citas todas las clínicas. motivo para este requerimiento que los pacientes con problemas salud mental ocasiones están confundidos. quizá tengan una cita una clínica realidad acudan una diferente. ahí que tienen una cita, registrará que asistieron, sin importar clínica. los miembros del personal médico que especifican esto quizás esperen que “buscar” significa que, dado nombre paciente, sistema busca dicho nombre las citas todas las clínicas. sin embargo, esto claro requerimiento. los desarrollado-res del sistema pueden interpretar requerimiento forma diferente implementar una búsqueda, tal modo que usuario deba elegir una clínica luego realizar búsqueda. evidentemente, esto implicará más entradas del usuario tomará más tiempo. principio, especificación los requerimientos funcionales sistema debe ser completa consistente. totalidad significa que deben definirse todos los servicios requeridos por usuario. consistencia quiere decir que los requerimientos tienen que evitar definiciones contradictorias. práctica, para sistemas complejos grandes, requerimientos dominio los requerimientos dominio derivan del dominio aplicación del sistema, más que partir las necesidades específicas los usuarios del sistema. pueden ser requerimientos funcionales nuevos por derecho propio, restricciones los requerimientos funcionales existentes formas que deben realizarse cálculos particulares. problema con los requerimientos dominio que los ingenieros software pueden entender las características del dominio que opera sistema. por común, pueden indicar requerimiento dominio perdió entró conflicto con otros requerimientos. http:// -.indd -.indd // :: // :: . ■ requerimientos funcionales funcionales casi imposible lograr consistencia totalidad los requerimientos. una causa para ello facilidad con que cometen errores omisiones escribir especificaciones para sistemas complejos. otra que hay muchos participantes sistema grande. participante individuo una función que afectado alguna forma por sis-tema. los participantes tienen diferentes necesidades, pero con frecuencia son inconsis-tentes. tales inconsistencias tal vez sean evidentes cuando especifican por primera vez los requerimientos, modo que especificación incluyen requerimientos inconsistentes. los problemas suelen surgir sólo después análisis profundidad después que entregó sistema cliente. .. requerimientos funcionales los requerimientos funcionales, como indica nombre, son requerimientos que relacionan directamente con los servicios específicos que sistema entrega sus usuarios. pueden relacionarse con propiedades emergentes del sistema, como fiabilidad, tiempo respuesta uso almacenamiento. forma alternativa, pueden definir res-tricciones sobre implementación del sistema, como las capacidades los dispositivos / las representaciones datos usados las interfaces con otros sistemas. los requerimientos funcionales, como rendimiento, seguridad disponi-bilidad, especifican restringen por general características del sistema como todo. los requerimientos funcionales menudo son más significativos que los requerimientos funcionales individuales. común que los usuarios del sistema encuentren formas para trabajar torno una función del sistema que realmente cubre sus necesidades. obstante, fracaso para cubrir los requerimientos funcionales haría que todo sis-tema fuera inútil. por ejemplo, sistema aeronave cubre sus requerimientos fiabilidad, será certificado para operación como dispositivo seguro; sistema control embebido fracasa para cubrir sus requerimientos rendimiento, operarán correctamente las funciones control. aunque posible identificar con regularidad cuáles componentes sistema imple-mentan requerimientos funcionales específicos (por ejemplo, hay componentes forma-teo que implementan requerimientos informe), por general más difícil relacionar componentes con requerimientos funcionales. implementación dichos requeri-mientos puede propagarse largo del sistema. para esto existen dos razones: . los requerimientos funcionales afectan más arquitectura global sistema que los componentes individuales. por ejemplo, para garantizar que cumplan los requerimientos rendimiento, quizá deba organizar sistema para minimizar las comunicaciones entre componentes. . requerimiento funcional individual, como requerimiento seguridad, podría generar algunos requerimientos funcionales relacionados que definan nuevos servicios del sistema que requieran. además, también podría generar requeri-mientos que restrinjan los requerimientos existentes. los requerimientos funcionales surgen través necesidades del usuario, debido restricciones presupuestales, políticas organización, necesidad interoperabilidad con otro software sistemas hardware, factores externos como regulaciones segu-ridad legislación sobre privacidad. figura . una clasificación requerimientos -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos funcionales. observe partir este diagrama que los requerimientos funciona- les provienen características requeridas del software (requerimientos del producto), organización que desarrolla software (requerimientos organización) fuentes externas: . requerimientos del producto estos requerimientos especifican restringen com- portamiento del software. los ejemplos incluyen requerimientos rendimiento sobre qué tan rápido debe ejecutar sistema cuánta memoria requiere, reque-rimientos fiabilidad que establecen tasa aceptable fallas, requerimientos seguridad requerimientos usabilidad. . requerimientos organización son requerimientos sistemas amplios, deri-vados políticas procedimientos organización del cliente del desarrollador. los ejemplos incluyen requerimientos del proceso operacional que definen cómo usará sistema, requerimientos del proceso desarrollo que especifican len-guaje programación, estándares del entorno proceso desarrollo utilizar, requerimientos ambientales que definen entorno operación del sistema. . requerimientos externos este término cubre todos los requerimientos derivados factores externos sistema proceso desarrollo. ellos incluyen requeri-mientos regulatorios que establecen que debe hacer sistema para ser aprobado uso por regulador, como sería banco central; requerimientos legislativos que tienen que seguirse para garantizar que sistema opere conforme ley, requerimientos éticos que garanticen que sistema será aceptable para sus usuarios público general. figura . muestra ejemplos requerimientos del producto, organización requerimientos externos tomados del mhc-pms, cuyos requerimientos usuario requerimientos rendimientorequerimientos espaciorequerimientos usabilidadrequerimientos eficienciarequerimientos confiabilidadrequerimientos seguridadrequerimientos regulatoriosrequerimientos éticos requerimientos legalesrequerimientos operacionalesrequerimientos desarrollorequerimientos ambientales requerimientos protección/seguridadrequerimientos contablesrequerimientos del productorequerimientos organizaciónrequerimientos externosrequerimientos funcionales figura . tipos requerimientos funcionales -.indd -.indd // :: // :: . ■ requerimientos funcionales funcionales introdujeron sección ... requerimiento del producto requerimiento disponibilidad que define cuándo estará disponible sistema tiempo muerto permi-tido cada día. dice algo sobre funcionalidad del mhc-pms identifica con clari-dad una restricción que deben considerar los diseñadores del sistema. requerimiento organización especifica cómo autentican los usuarios sistema. autoridad sanitaria que opera sistema mueve hacia procedimiento autenticación estándar para cualquier software donde, vez que los usuarios tengan nombre conexión (login), pasan tarjeta identidad por lector para identifi-carse mismos. requerimiento externo deriva necesidad que sistema esté conforme con legislación privacidad. evidentemente, privacidad asunto muy importante los sistemas atención salud, requerimiento especifica que sistema debe desarrollarse conforme estándar privacidad nacional. problema común con requerimientos funcionales que los usuarios clientes con frecuencia proponen estos requerimientos como metas generales, como facilidad uso, capacidad que sistema recupere fallas, rapidez respuesta usuario. las metas establecen buenas intenciones; obstante, ocasionan problemas los desa-rrolladores del sistema, pues dejan espacio para interpretación disputa posterior una vez que entregue sistema. por ejemplo, siguiente meta del sistema típica cómo administrador expresa los requerimientos usabilidad: para personal médico debe ser fácil usar sistema, este último debe organi-zarse tal forma que minimice los errores del usuario. anterior escribió para mostrar cómo podría expresarse meta como reque-rimiento funcional “comprobable”. aun cuando imposible comprobar manera objetiva meta del sistema, siguiente descripción puede incluir, menos, instrumentación software para contar los errores cometidos por los usuarios cuando prueban sistema. después cuatro horas capacitación, personal médico usará todas las fun-ciones del sistema. después esta capacitación, los usuarios experimentados deberán superar promedio dos errores cometidos por hora uso del sistema. siempre que sea posible, deberán escribir manera cuantitativa los requerimientos funcionales, manera que puedan ponerse objetivamente prueba. figura . mues-tra las métricas que utilizan para especificar propiedades funcionales del sistema. figura . ejemplos requerimientos funcionales mhc-pmsrequerimiento del productoel mhc-pms estará disponible todas las clínicas durante las horas trabajo normales (lunes viernes, : :). cualquier día, los tiempos muertos dentro las horas laborales normales rebasarán los cinco segundos. requerimientos organización los usuarios del sistema mhc-pms acreditarán mismos con uso tarjeta identidad autoridad sanitaria. requerimientos externos como establece hstan---priv, sistema implementará provisiones para privacidad del paciente. -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos usted puede medir dichas características cuando sistema pone prueba para compro- bar éste cumple cumple con sus requerimientos funcionales. práctica, los usuarios sistema suelen encontrar difícil traducir sus metas requerimientos mensurables. para algunas metas, como mantenibilidad, hay métricas para usarse. otros casos, incluso cuando sea posible especificación cuanti-tativa, los clientes logran relacionar sus necesidades con dichas especificaciones. comprenden qué significa algún número que define fiabilidad requerida (por así decirlo), términos experiencia cotidiana con los sistemas cómputo. más aún, costo por verificar objetivamente los requerimientos funcionales mensurables suele ser muy elevado, los clientes que pagan por sistema quizá piensen que dichos costos están justificados. los requerimientos funcionales entran menudo conflicto interactúan con otros requerimientos funcionales funcionales. por ejemplo, requerimiento autenticación figura . requiere, indiscutiblemente, instalación lector tarjetas cada computadora unida sistema. sin embargo, podría haber otro requeri-miento que solicite acceso móvil sistema desde las computadoras portátiles médicos enfermeras. por general, las computadoras portátiles están equipadas con lectores tarjeta, modo que, ante tales circunstancias, probablemente deba permitirse algún método autenticación alternativo. práctica, documento requerimientos, resulta difícil separar los requeri-mientos funcionales los funcionales. los requerimientos funcionales expre-san por separado los requerimientos funcionales, las relaciones entre ambos serían difíciles entender. obstante, deben destacar manera explícita los requeri-mientos que están claramente relacionados con las propiedades emergentes del sistema, como rendimiento fiabilidad. esto logra ponerlos una sección separada del documento requerimientos distinguirlos, alguna forma, otros requerimien-tos del sistema.figura . métricas para especificar requerimientos funcionalespropiedad medida rapidez transacciones/segundo procesadastiempo respuesta usuario/eventotiempo regeneración pantalla tamaño mbytesnúmero chips rom facilidad uso tiempo capacitaciónnúmero cuadros ayuda fiabilidad tiempo medio para fallaprobabilidad indisponibilidadtasa ocurrencia falladisponibilidad robustez tiempo reinicio después fallaporcentaje eventos que causan fallaprobabilidad corrupción datos falla portabilidad porcentaje enunciados dependientes objetivonúmero sistemas objetivo -.indd -.indd // :: // :: . ■ documento requerimientos software estándares del documento requerimientos algunas organizaciones grandes, como departamento defensa estadounidense institute electrical and electronic engineers (ieee), definieron estándares para los documentos requerimientos. comúnmente son muy genéricos, pero útiles como base para desarrollar estándares organizativos más detallados. ieee uno los proveedores estándares mejor conocidos desarrolló estándar para estructura documentos requerimientos. este estándar más adecuado para sistemas como comando militar sistemas control que tienen largo tiempo vida , por general, los diseña grupo organizaciones. http:// los requerimientos funcionales, como los requerimientos fiabilidad, protección confidencialidad, son particular importantes para los sistemas fundamentales. capítulo incluyen estos requerimientos, donde describen técnicas específicas para definir requerimientos confiabilidad seguridad. . documento requerimientos software documento requerimientos software (llamado algunas veces especificación requerimientos software srs) comunicado oficial que deben implementar los desarrolladores del sistema. incluye tanto los requerimientos del usuario para sis-tema, como una especificación detallada los requerimientos del sistema. ocasiones, los requerimientos del usuario del sistema integran una sola descripción. otros casos, los requerimientos del usuario definen una introducción especificación requerimientos del sistema. hay gran número requerimientos, los requerimientos del sistema detallados podrían presentarse documento aparte. son esenciales los documentos requerimientos cuando contratista externo diseña sistema software. sin embargo, los métodos desarrollo ágiles argumentan que los requerimientos cambian tan rápidamente que documento requerimientos vuelve obsoleto tan pronto como escribe, así que esfuerzo desperdicia gran medida. lugar documento formal, los enfoques como programación extrema (beck, ) recopilan manera incremental requerimientos del usuario los escriben tarjetas como historias usuario. esa manera, usuario prioridad los reque-rimientos para implementación siguiente incremento del sistema. este enfoque adecuado para sistemas empresariales donde los requerimientos son inestables. sin embargo, aún resulta útil escribir breve documento apoyo que defina los requerimientos empresa los requerimientos confiabilidad para sistema; fácil olvidar los requerimientos que aplican sistema como todo, cuando uno enfoca los requerimientos funcionales para siguiente liberación del sistema. documento requerimientos tiene conjunto variado usuarios, desde administrador ejecutivo organización que paga por sistema, hasta los ingenie-ros responsables del desarrollo del software. figura ., tomada del libro del autor con gerald kotonya sobre ingeniería requerimientos (kotonya sommerville, ), muestra los posibles usuarios del documento cómo ellos utilizan. -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos diversidad posibles usuarios significa que documento requerimientos debe ser compromiso entre comunicación los requerimientos los clientes, defini-ción los requerimientos con detalle preciso para desarrolladores examinadores, inclusión información sobre posible evolución del sistema. información cam-bios anticipados ayuda tanto los diseñadores del sistema evitar decisiones diseño restrictivas, como los ingenieros mantenimiento del sistema que deben adaptar sistema los nuevos requerimientos. nivel detalle que incluya documento requerimientos depende del tipo sistema diseñar proceso desarrollo utilizado. los sistemas críticos nece-sitan tener requerimientos detallados porque seguridad protección también deben analizarse forma pormenorizada. cuando sistema desarrolla una compañía inde-pendiente (por ejemplo, mediante subcontratación), deben detallarse precisarse las especificaciones del sistema. utiliza proceso desarrollo iterativo interno, entonces documento requerimientos suele ser mucho menos detallado cualquier ambigüedad puede resolverse durante desarrollo del sistema. figura . indica una posible organización para documento requerimientos basada estándar del ieee para documentos requerimientos (ieee, ). este estándar genérico adapta usos específicos. este caso, estándar extendió para incluir información evolución prevista del sistema. esta información ayuda los encargados del sistema permite los diseñadores incluir soporte para características futuras del sistema. naturalmente, información que incluya documento requerimientos depende del tipo software que desarrollar del enfoque para desarrollo que use. adopta enfoque evolutivo para producto software (por ejemplo), elusan los requerimientos para desarrollar pruebas validación para sistema.usan documento requerimientos para planear una cotización para sistema proceso desarrollo del sistema. usan los requerimientos para entender qué sistema debe desarrollarse. ingenieros prueba del sistemaadministradores ingenieros del sistemaespecifican los requerimientos los leen para comprobar que cubrensus necesidades. los clientesespecifican los cambios los requerimientos.clientes del sistema usan los requerimientos para comprender sistema las relaciones entre sus componentes.ingenieros mantenimiento del sistemafigura . usuarios documento requerimientos -.indd -.indd // :: // :: . ■ documento requerimientos software documento requerimientos dejará fuera muchos los capítulos detallados que sugirieron anteriormente. enfoque estará especificar los requerimientos del usuario los requerimientos funcionales alto nivel del sistema. este caso, diseñadores programadores usan criterio para decidir cómo cubrir los requerimientos establecidos del usuario para sistema. sin embargo, cuando software sea parte proyecto sistema grande que incluya interacción sistemas hardware software, será necesario por general figura . estructura documento requerimientoscapítulo descripción prefacio debe definir número esperado lectores del documento, así como describir historia versiones, incluidas las causas para creación una nueva versión resumen los cambios realizados cada versión. introducción describe necesidad para sistema. debe detallar brevemente las funciones del sistema explicar cómo funcionará con otros sistemas. también tiene que indicar cómo ajusta sistema los objetivos empresariales estratégicos globales organización que comisiona software. glosario define los términos técnicos usados documento. debe hacer conjeturas sobre experiencia habilidad del lector. definición requerimientos del usuarioaquí representan los servicios que ofrecen usuario. también, esta sección describen los requerimientos funcionales del sistema. esta descripción puede usar lenguaje natural, diagramas otras observaciones que sean comprensibles para los clientes. deben especificarse los estándares producto proceso que tienen que seguirse. arquitectura del sistemaeste capítulo presenta panorama alto nivel arquitectura anticipada del sistema, que muestra distribución funciones través los módulos del sistema. hay que destacar los componentes arquitectónicos que sean dereutilización. especificación requerimientos del sistemadebe representar los requerimientos funcionales funcionales con más detalle. preciso, también pueden detallarse más los requerimientos funcionales. pueden definirse las interfaces otros sistemas. modelos del sistema pueden incluir modelos gráficos del sistema que muestren las relaciones entre componentes del sistema, sistema entorno. ejemplos posibles modelos son los modelos objeto, modelos flujo datos modelos datos semánticos. evolución del sistema describe los supuestos fundamentales sobre los que basa sistema, cualquier cambio anticipado debido evolución hardware, cambio las necesidades del usuario, etc. esta sección útil para los diseñadores del sistema, pues los ayuda evitar decisiones diseño que restringirían probablemente futuros cambios sistema. apéndices brindan información específica detallada que relaciona con aplicación desarrollar; por ejemplo, descripciones hardware bases datos. los requerimientos hardware definen las configuraciones, mínima óptima, del sistema. los requerimientos base datos delimitan organización lógica los datos usados por sistema las relaciones entre datos. índice pueden incluirse documento varios índices. así como índice alfabético normal, uno diagramas, índice funciones, etcétera. -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos definir los requerimientos nivel detallado. esto significa que probable que los documentos requerimientos sean muy largos deban incluir mayoría, que todos, los capítulos que muestran figura .. para documentos extensos, muy importante incluir una tabla contenido global índice del documento, manera que los lectores encuentren con facilidad información que necesitan. . especificación requerimientos especificación requerimientos proceso escribir, documento reque-rimientos, los requerimientos del usuario del sistema. manera ideal, los requeri-mientos del usuario del sistema deben ser claros, sin ambigüedades, fáciles entender, completos consistentes. esto práctica difícil lograr, pues los participantes interpretan los requerimientos formas diferentes con frecuencia los requerimien-tos hay conflictos inconsistencias inherentes. los requerimientos del usuario para sistema deben describir los requerimientos funcionales funcionales, forma que sean comprensibles para los usuarios del sis-tema que cuentan con conocimiento técnico detallado. manera ideal, deberían especificar sólo comportamiento externo del sistema. documento requerimientos debe incluir detalles arquitectura diseño del sistema. consecuencia, usted escribe los requerimientos del usuario, tiene que usar jerga software, anota-ciones estructuradas formales. debe escribir los requerimientos del usuario lenguaje natural, con tablas formas sencillas, así como diagramas intuitivos. los requerimientos del sistema son versiones extendidas los requerimientos del usuario que los ingenieros software usan como punto partida para diseño del sistema. añaden detalles explican cómo sistema debe brindar los requerimientos del usua rio. pueden usar como parte del contrato para implementación del sistema , por tanto, deben ser una especificación completa detallada todo sistema. idealmente, los requerimientos del sistema deben describir manera simple comportamiento externo del sistema sus restricciones operacionales. tienen que ocuparse cómo diseña implementa sistema. sin embargo, nivel detalle requerido para especificar por completo sistema software complejo, práctica-mente imposible excluir toda información diseño. para ello existen varias razones: . tal vez tenga que diseñar una arquitectura inicial del sistema para ayudar estruc- turar especificación requerimientos. los requerimientos del sistema organizan problemas con uso lenguaje natural para especificación requerimientos flexibilidad del lenguaje natural, que tan útil para especificación, causa problemas frecuentemente. hay espacio para escribir requerimientos poco claros, los lectores (los diseñadores) pueden malinterpretar los requerimientos porque tienen antecedente diferente del usuario. fácil mezclar muchos requerimientos una sola oración quizá sea difícil estructurar los requerimientos lenguaje natural. http:// -.indd -.indd // :: // :: . ■ especificación requerimientos acuerdo con los diferentes subsistemas que constituyen sistema. como veremos los capítulos , esta definición arquitectónica esencial usted quiere reuti-lizar componentes software implementar sistema. . mayoría los casos, los sistemas deben interoperar con los sistemas existen- tes, cual restringe diseño impone requerimientos sobre nuevo sistema. . quizá sea necesario uso una arquitectura específica para cubrir los requeri- mientos funcionales (como programación -versión para lograr fiabilidad, que estudia capítulo ). regulador externo, que precise certificar que dicho sistema seguro, puede especificar que utilice diseño arquitectónico avalado. los requerimientos del usuario escriben casi siempre lenguaje natural, com-plementado con diagramas tablas adecuados documento requerimientos. los requerimientos del sistema escriben también lenguaje natural, pero igual modo utilizan otras notaciones basadas formas, modelos gráficos del sistema mode-los matemáticos del sistema. figura . resume las posibles anotaciones que podrían usarse para escribir requerimientos del sistema. los modelos gráficos son más útiles cuando necesario mostrar cómo cambia estado describir una secuencia acciones. los gráficos secuencia uml los gráficos estado, que explican capítulo , exponen secuencia acciones que ocurren respuesta cierto mensaje evento. ocasiones, usan especificaciones matemáticas formales con finalidad describir los requerimientos para sistemas protección seguridad críticos, aunque rara vez usan otras circunstancias. este enfoque para escribir especificaciones explica capítulo .figura . formas escribir una especificación requerimientos del sistemanotación descripción enunciados lenguaje natural los requerimientos escriben usar enunciados numerados lenguaje natural. cada enunciado debe expresar requerimiento. lenguaje natural estructurado los requerimientos escriben lenguaje natural una forma plantilla estándar. cada campo ofrece información aspecto del requerimiento. lenguajes descripción diseñoeste enfoque usa lenguaje como lenguaje programación, pero con características más abstractas para especificar los requerimientos definir modelo operacional del sistema. aunque actualidad este enfoque usa raras veces, aún tiene utilidad para especificaciones interfaz. anotaciones gráficas los modelos gráficos, complementados con anotaciones texto, sirven para definir los requerimientos funcionales del sistema; los casos uso del uml los diagramas secuencia emplean forma común. especificaciones matemáticas dichas anotaciones basan conceptos matemáticos como máquinas conjuntos estado finito. aunque tales especificaciones sin ambigüedades pueden reducir imprecisión documento requerimientos, mayoría los clientes comprenden una especificación formal. pueden comprobar que representa que quieren por ello tienen reticencia para aceptarlo como contrato sistema. -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos .. especificación lenguaje natural desde los albores ingeniería software, lenguaje natural usa para escribir los requerimientos software. expresivo, intuitivo universal. también potencial-mente vago, ambiguo significado depende los antecedentes del lector. como resul-tado, hay muchas propuestas para formas alternativas escribir los requerimientos. sin embargo, ninguna adoptado manera amplia, por que lenguaje natural seguirá siendo forma más usada para especificar los requerimientos del sistema del software. para minimizar interpretación errónea escribir los requerimientos lenguaje natural, recomienda seguir algunos lineamientos sencillos: . elabore formato estándar asegúrese que todas las definiciones requeri- mientos adhieran dicho formato. estandarizar formato menos probable cometer omisiones más sencillo comprobar los requerimientos. formato que usa autor expresa requerimiento una sola oración. cada requerimiento usuario asocia enunciado razones para explicar por qué propuso requerimiento. las razones también pueden incluir información sobre quién planteó requerimiento ( fuente del requerimiento), modo que usted conozca quién consultar caso que cambie requerimiento. . utilice lenguaje manera clara para distinguir entre requerimientos obligatorios deseables. los primeros son requerimientos que sistema debe soportar , por general, escriben futuro “debe ser”. tanto que los requerimientos deseables son necesarios escriben tiempo pospretérito como condicional “debería ser”. . use texto resaltado (negrilla, cursiva color) para seleccionar partes clave del requerimiento. . deduzca que los lectores entienden lenguaje técnico ingeniería soft- ware. fácil que malinterpreten palabras como “arquitectura” “módulo”. por tanto, debe evitar uso jerga, abreviaturas acrónimos. . siempre que sea posible, asocie una razón con cada requerimiento usuario. razón debe explicar por qué incluyó requerimiento. particularmente útil cuando los requerimientos cambian, pues ayuda decidir cuáles cambios serían indeseables. figura . ilustra cómo usan dichos lineamientos. incluye dos requerimientos para software embebido para bomba insulina automatizada, que introdujo capítulo . usted puede descargar especificación completa los requerimientos bomba insulina las páginas web del libro.. requiere, cada minutos sistema medirá azúcar sangre administrará insulina. ( los cambios azúcar sangre son relativamente lentos, manera que son necesarias mediciones más frecuentes; medición menos periódica podría conducir niveles azúcar innecesariamente elevados. ) . cada minuto, sistema debe correr una rutina autoevaluación, con las condiciones probar las acciones asociadas definidas tabla . (una rutina autoevaluación puede detectar problemas hardware software, prevenir usuario sobre hecho que operación normal puede ser imposible. ) figura . ejemplo requerimientos para sistema software bomba insulina -.indd -.indd // :: // :: . ■ especificación requerimientos .. especificaciones estructuradas lenguaje natural estructurado una manera escribir requerimientos del sistema, donde está limitada libertad del escritor requerimientos todos éstos anotan una forma estándar. aunque este enfoque conserva mayoría expresividad comprensibilidad del lenguaje natural, asegura que haya cierta uniformidad sobre especificación. las anotaciones lenguaje estructurado emplean plantillas para espe-cificar requerimientos del sistema. especificación utiliza constructos lenguaje programación para mostrar alternativas iteración, destaca elementos clave con uso sombreado fuentes distintas. los robertson (robertson robertson, ), libro del método ingeniería requerimientos volere, recomiendan que escriban los requerimientos del usuario inicialmente tarjetas, requerimiento por tarjeta. proponen algunos campos cada tarjeta, tales como razones los requerimientos, dependencias otros requerimien-tos, fuente los requerimientos, materiales apoyo, etcétera. anterior similar enfoque utilizado ejemplo especificación estructurada que muestra figura .. para usar enfoque estructurado que especifique los requerimientos sistema, hay que definir una más plantillas estándar para requerimientos, representar dichas plan-tillas como formas estructuradas. especificación puede estructurarse sobre los objetos manipulados por sistema, las funciones que sistema realiza los eventos procesa-dos por sistema. figura . muestra ejemplo una especificación basada forma, este caso, una que define cómo calcular dosis insulina administrar cuando azúcar sangre está dentro una banda segura.figura . especificación estructurada requerimiento para una bomba insulinabomba insulina/software control/srs/.. función descripción entradas fuentesalidasdestinoacción requerimientos precondiciónpostcondición efectos colateralescalcula dosis insulina: nivel seguro azúcar.calcula dosis insulina que suministrar cuando medición del nivel azúcar actual esté zona segura entre unidades. lectura del azúcar actual (), las dos lecturas previas ( ).lectura del azúcar actual del sensor. otras lecturas memoria.compdose: dosis insulina administrar.ciclo control principal.compdose cero estable nivel azúcar, cae aumenta nivel pero disminuye tasa aumento. nivel eleva tasa aumento crece, compdose calcula entonces dividir diferencia entre nivel azúcar actual nivel previo entre redondear resultado. suma redondea cero, tal caso compdose establece dosis mínima que puede entregarse. dos lecturas previas, modo que puede calcularse tasa cambio del nivel azúcar. depósito insulina contiene menos dosis individual insulina máxima permitida. sustituye con , luego sustituye con .ninguno. -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos cuando use una forma estándar para especificar requerimientos funcionales, debe incluir siguiente información: . una descripción función entidad especificar. . una descripción sus entradas sus procedencias.. una descripción sus salidas dónde dirigen.. información sobre los datos requeridos para cálculo otras entidades sis- tema que utilizan ( parte “requiere”). . una descripción acción que tomar.. usa enfoque funcional, una precondición establece que debe ser verda- dero antes llamar función, una postcondición especifica que verdadero después llamar función. . una descripción los efectos colaterales ( acaso hay alguno) operación. usar especificaciones estructuradas eliminan algunos los problemas especificación lenguaje natural. variabilidad especificación reduce los requerimientos organizan forma más efectiva. sin embargo, ocasiones todavía difícil escribir requerimientos sin ambigüedades, particular cuando deben especifi-carse cálculos complejos (por ejemplo, cómo calcular dosis insulina). para enfrentar este problema puede agregar información extra los requerimientos lenguaje natural, por ejemplo, con uso tablas modelos gráficos del sistema. éstos pueden mostrar cómo proceden los cálculos, cambia estado del sistema, interac-túan los usuarios con sistema realizan las secuencias acciones. las tablas son particularmente útiles cuando hay algunas posibles situaciones alternas necesita describir las acciones tomar cada una ellas. bomba insulina fundamenta sus cálculos del requerimiento insulina, tasa cambio los nive-les azúcar sangre. las tasas cambio calculan con las lecturas, actual anterior. figura . una descripción tabular cómo usa tasa cambio del azúcar sangre, para calcular cantidad insulina por suministrar.figura . especificación tabular del cálculo para una bomba insulinacondición acción nivel azúcar descenso ( , ) compdose nivel azúcar estable ( ) compdose nivel azúcar creciente tasa incremento decreciente (( ) , ( )) compdose nivel azúcar creciente tasa incremento estable creciente (( ) $ ( ))compdose round (( )/) resultado redondeado thencompdose minimumdose -.indd -.indd // :: // :: . ■ procesos ingeniería requerimientos . procesos ingeniería requerimientos como vimos capítulo , los procesos ingeniería requerimientos incluyen cuatro actividades alto nivel. éstas enfocan valorar sistema útil para empresa (estudio factibilidad), descubrir requerimientos (adquisición análisis), con-vertir dichos requerimientos alguna forma estándar (especificación) comprobar que los requerimientos definan realmente sistema que quiere cliente (validación). figura . mostró esto como proceso secuencial; sin embargo, práctica, ingenie-ría requerimientos proceso iterativo donde las actividades están entrelazadas. figura . presenta este entrelazamiento. las actividades están organizadas como proceso iterativo alrededor una espiral, salida documento requeri-mientos del sistema. cantidad tiempo esfuerzo dedicados cada actividad cada iteración depende etapa del proceso global tipo sistema que está siendo desa-rrollado. inicio del proceso, empleará más esfuerzo para comprender los requeri-mientos empresariales alto nivel los funcionales, así como los requerimientos del especificación requerimientos validación requerimientosadquisición requerimientosespecificación modelado requerimientos del sistema especificación requerimientos del usuario adquisición requerimientos del usuarioespecificación requerimientos empresa prototipos revisiones documento requerimientos del sistemainicio adquisición requerimientos del sistemaestudio factibilidad figura . vista espiral del proceso ingeniería requerimientos -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos usuario para sistema. más adelante proceso, los anillos exteriores espiral, dedicará más esfuerzo adquisición comprensión los requerimientos detallados del sistema. este modelo espiral acomoda enfoques desarrollo, donde los requerimientos elaboraron con diferentes niveles detalle. número iteraciones espiral tiende variar, modo que espiral terminará después adquirir algunos todos los requeri-mientos del usuario. puede usar desarrollo ágil vez creación prototipos, manera que diseñen conjunto los requerimientos implementación del sistema. algunas personas consideran ingeniería requerimientos como proceso apli-car método análisis estructurado, tal como análisis orientado objetos (larman, ). esto implica analizar sistema desarrollar conjunto modelos gráficos del sistema, como los modelos caso uso, que luego sirven como especificación del sistema. conjunto modelos describe comportamiento del sistema anota con información adicional que describe, por ejemplo, rendimiento fiabilidad requeri-dos del sistema. aunque los métodos estructurados desempeñan papel proceso ingeniería requerimientos, hay mucho más ingeniería requerimientos que cubre con dichos métodos. adquisición requerimientos, particular, una actividad centrada gente, las personas les gustan las restricciones impuestas por modelos sistema rígidos. prácticamente todos los sistemas cambian los requerimientos. las personas implica-das desarrollan una mejor comprensión qué quieren que haga software; organiza-ción que compra sistema cambia; hacen modificaciones hardware, software entorno organizacional del sistema. proceso administrar tales requerimientos cam-biantes llama administración requerimientos, tema que trata sección .. . adquisición análisis requerimientos después estudio factibilidad inicial, siguiente etapa del proceso ingeniería requerimientos adquisición análisis requerimientos. esta actividad, los ingenieros software trabajan con clientes usuarios finales del sistema para descu-brir dominio aplicación, qué servicios debe proporcionar sistema, desempeño requerido éste, las restricciones hardware, etcétera.estudios factibilidad estudio factibilidad breve estudio enfocado que debe realizarse con oportunidad proceso . debe responder tres preguntas clave: ) ¿ sistema contribuye con los objetivos globales organización? ) ¿ sistema puede implementarse dentro fecha presupuesto usando tecnología actual? ) ¿ sistema puede integrarse con otros sistemas que utilicen? respuesta cualquiera estas preguntas negativa, probablemente sea conveniente continuar con proyecto. http:// -.indd -.indd // :: // :: . ■ adquisición análisis requerimientos una organización, adquisición análisis requerimientos pueden involu- crar diversas clases personas. participante sistema quien debe tener alguna influencia directa indirecta sobre los requerimientos del mismo. los partici-pantes incluyen usuarios finales que interactuarán con sistema, cualquiera una organización que resultará afectada por . otros participantes del sistema pueden ser los ingenieros que desarrollan mantienen otros sistemas relacionados, administradores negocios, expertos dominio representantes asociaciones sindicales. figura . muestra modelo del proceso adquisición análisis. cada organización tendrá versión ejemplificación este modelo general, dependiendo factores locales, tales como experiencia del personal, tipo sistema desarrollar, estándares usados, etcétera. las actividades del proceso son: . descubrimiento requerimientos éste proceso interactuar con los parti- cipantes del sistema para descubrir sus requerimientos. también los requerimientos dominio los participantes documentación descubren durante esta activi-dad. existen numerosas técnicas complementarias que pueden usarse para descu-brimiento requerimientos, las cuales estudian más adelante esta sección. . clasificación organización requerimientos esta actividad toma compila- ción estructurada requerimientos, agrupa requerimientos relacionados los organiza grupos coherentes. forma más común agrupar requerimientos usar modelo arquitectura del sistema, para identificar subsistemas asociar los requerimientos con cada subsistema. práctica, ingeniería requeri-mientos diseño arquitectónico son actividades separadas completamente. . priorización negociación requerimientos inevitablemente, cuando intervie- nen diversos participantes, los requerimientos entrarán conflicto. esta actividad preocupa por priorizar los requerimientos, así como por encontrar resolver con-flictos requerimientos mediante negociación. por general, los participantes tienen que reunirse para resolver las diferencias estar acuerdo con compro-miso los requerimientos.. descubrimiento requerimientos . clasificación organización requerimientos . priorización negociación requerimientos. especificación requerimientos figura . proceso adquisición análisis requerimientos -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos . especificación requerimientos los requerimientos documentan ingresan siguiente ronda espiral. pueden producirse documentos requerimientos formales informales, como estudia sección .. figura . muestra que adquisición análisis requerimientos proceso iterativo con retroalimentación continua cada actividad otras actividades. ciclo del proceso comienza con descubrimiento requerimientos termina con documenta-ción los requerimientos. comprensión los requerimientos por parte del analista mejora con cada ronda del ciclo. ciclo concluye cuando está completo documento requerimientos. adquisición comprensión los requerimientos por parte los participantes del sistema proceso difícil por diferentes razones: . los participantes con frecuencia saben que quieren sistema cómputo, excepto términos muy generales; pueden encontrar difícil articular qué quieren que haga sistema; pueden hacer peticiones inalcanzables porque saben qué factible qué . . los participantes sistema expresan naturalmente los requerimientos con sus tér- minos conocimientos implícitos trabajo. los ingenieros requerimientos, sin experiencia dominio del cliente, podrían entender dichos requerimientos. . diferentes participantes tienen distintos requerimientos pueden expresarlos variadas formas. los ingenieros requerimientos deben descubrir todas las fuentes potenciales requerimientos identificar similitudes conflictos. . factores políticos llegan influir los requerimientos sistema. los adminis- tradores pueden solicitar requerimientos específicos del sistema, porque éstos les permitirán aumentar influencia organización. . ambiente económico empresarial donde ocurre análisis dinámico. inevitablemente cambia durante proceso análisis. puede cambiar importan-cia requerimientos particulares; bien, tal vez surjan nuevos requerimientos nuevos participantes quienes consultó originalmente. resulta ineludible que diferentes participantes tengan diversas visiones impor-tancia prioridad los requerimientos , algunas veces, dichas visiones están conflicto. durante proceso, usted deberá organizar negociaciones regulares con los participantes, forma que alcancen compromisos. imposible complacer por com-pleto cada participante, pero, algunos suponen que sus visiones consideraron forma adecuada, quizás intenten deliberadamente socavar proceso . etapa especificación requerimientos, los requerimientos adquiridos hasta momento documentan tal forma que puedan usarse para ayudar hallazgo -querimientos. esta etapa, podría generarse una primera versión del documento reque-rimientos del sistema, con secciones faltantes requerimientos incompletos. modo alternativo, los requerimientos pueden documentarse una forma completamente dife-rente (por ejemplo, una hoja cálculo tarjetas). escribir requerimientos tarjetas suele ser muy efectivo, que los participantes las administran, cambian organizan con facilidad. -.indd -.indd // :: // :: . ■ adquisición análisis requerimientos .. descubrimiento requerimientos descubrimiento requerimientos (llamado veces adquisición requerimientos) proceso recopilar información sobre sistema requerido los sistemas existentes, así como separar, partir esta información, los requerimientos del usuario del sistema. las fuentes información durante fase descubrimiento requerimientos incluyen documentación, participantes del sistema especificaciones sistemas similares. inte-racción con los participantes través entrevistas observaciones, pueden usarse escenarios prototipos para ayudar los participantes entender cómo será sistema. los participantes varían desde administradores usuarios finales sistema hasta participantes externos como los reguladores, quienes certifican aceptabilidad del sis-tema. por ejemplo, los participantes que incluyen para sistema información pacientes atención salud mental son: . pacientes cuya información registra sistema. . médicos que son responsables valorar tratar los pacientes.. enfermeros que coordinan, junto con los médicos, las consultas suministran algu- nos tratamientos. . recepcionistas que administran las citas médicas los pacientes.. personal que responsable instalar mantener sistema.. director ética médica que debe garantizar que sistema cumpla con los linea- mientos éticos actuales atención paciente. . encargados atención salud que obtienen información administrativa del sistema.. personal archivo médico que responsable garantizar que información del sistema conserve, implementen manera adecuada los procedimientos mantenimiento del archivo. además los participantes del sistema, observa que los requerimientos también pueden venir del dominio aplicación otros sistemas que interactúan con sis-tema especificar. todos ellos deben considerarse durante proceso adquisición requerimientos. todas estas diferentes fuentes requerimientos (participantes, dominio, sistemas) representan como puntos vista del sistema, cada visión muestra subconjunto los puntos vista punto vista una forma recopilar organizar conjunto requerimientos grupo participantes que cuentan con algo común. por tanto, cada punto vista incluye una serie requerimientos del sistema. los puntos vista pueden provenir usuarios finales, administradores, etcétera. ayudan identificar los individuos que brindan información sobre sus requerimientos estructurar los requerimientos para análisis. http:// -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos requerimientos para sistema. diferentes puntos vista problema enfocan pro- blema diferentes formas. sin embargo, sus perspectivas son totalmente independien-tes, sino que por general traslapan, manera que tienen requerimientos comunes. usted puede usar estos puntos vista para estructurar tanto descubrimiento como documentación los requerimientos del sistema. .. entrevistas las entrevistas formales informales con participantes del sistema son una parte mayoría los procesos ingeniería requerimientos. estas entrevistas, equipo ingeniería requerimientos formula preguntas los participantes sobre sistema que actualmente usan sistema que desarrollar. los requerimientos derivan las respuestas dichas preguntas. las entrevistas son dos tipos: . entrevistas cerradas, donde los participantes responden conjunto preguntas preestablecidas. . entrevistas abiertas, las cuales hay agenda predefinida. equipo inge- niería requerimientos explora rango conflictos con los participantes del sistema , como resultado, desarrolla una mejor comprensión sus necesidades. práctica, las entrevistas con los participantes son por general una combinación ambas. quizá deba obtener respuesta ciertas preguntas, pero eso menudo con-duce otros temas que discuten una forma menos estructurada. rara vez funcionan bien las discusiones completamente abiertas. con frecuencia debe plantear algunas pregun-tas para comenzar mantener entrevista enfocada sistema que desarrollar. las entrevistas son valiosas para lograr una comprensión global sobre qué hacen los participantes, cómo pueden interactuar con nuevo sistema las dificultades que enfren-tan con los sistemas actuales. las personas les gusta hablar acerca sus trabajos, así que por general están muy dispuestas participar entrevistas. sin embargo, las entrevistas son tan útiles para comprender los requerimientos desde dominio aplicación. por dos razones resulta difícil asimilar conocimiento dominio través entre-vistas: . todos los especialistas aplicación usan terminología jerga que son específi- cos dominio. imposible que ellos discutan los requerimientos dominio sin usar este tipo lenguaje. por general, usan terminología una forma precisa sutil, que para los ingenieros requerimientos fácil malinterpretar. . cierto conocimiento del dominio tan familiar los participantes que encuen- tran difícil explicarlo, bien, creen que tan fundamental que vale pena mencionarlo. por ejemplo, para bibliotecario necesario decir que todas las adquisiciones deben catalogarse antes agregarlas acervo. sin embargo, esto quizá sea obvio para entrevistador , por tanto, posible que tome cuenta los requerimientos. las entrevistas tampoco son una técnica efectiva para adquirir conocimiento sobre los requerimientos las restricciones organización, porque existen relaciones sutiles poder entre los diferentes miembros organización. las estructuras publicadas -.indd -.indd // :: // :: . ■ adquisición análisis requerimientos organización rara vez coinciden con realidad toma decisiones una orga- nización, pero los entrevistados quizá deseen revelar extraño estructura real, sino teórica. general, mayoría las personas muestran renuentes discutir los conflictos políticos organizacionales que afecten los requerimientos. los entrevistadores efectivos poseen dos características: . tienen mentalidad abierta, evitan ideas preconcebidas sobre los requerimientos escuchan los participantes. participante aparece con requerimientos sorpren- dentes, entonces tienen disposición para cambiar mentalidad acerca del sistema. . instan entrevistado con una pregunta trampolín para continuar plática, dar una propuesta requerimientos trabajar juntos sistema prototipo. cuando pregunta individuo “dime qué quieres” improbable que alguien consiga infor-mación útil. encuentran mucho más sencillo hablar contexto definido que términos generales. información las entrevistas complementa con otra información del sistema documentación que describe los procesos empresariales los sistemas existentes, las observaciones del usuario, etcétera. ocasiones, además los documentos del sistema, información entrevista puede ser única fuente datos sobre los requerimien-tos del sistema. sin embargo, entrevista por misma está expuesta perder informa-ción esencial , por consiguiente, debe usarse junto con otras técnicas adquisición requerimientos. .. escenarios por general, las personas encuentran más sencillo vincularse con ejemplos reales que con descripciones abstractas. pueden comprender criticar escenario sobre cómo inte-ractuar con sistema software. los ingenieros requerimientos usan información obtenida esta discusión para formular los verdaderos requerimientos del sistema. los escenarios son particularmente útiles para detallar bosquejo descripción requerimientos. trata ejemplos sobre descripciones sesiones interacción. cada escenario abarca comúnmente una interacción número pequeño interacciones posi-bles. desarrollan diferentes formas escenarios ofrecen varios tipos información con diversos niveles detalle acerca del sistema. las historias que usan programa-ción extrema, estudiadas capítulo , son tipo escenario requerimientos. escenario comienza con bosquejo interacción. durante proceso adquisición, suman detalles éste para crear una representación completa dicha interacción. forma más general, escenario puede incluir: . una descripción qué esperan sistema los usuarios cuando inicia escenario. . una descripción escenario del flujo normal los eventos.. una descripción qué puede salir mal cómo manejaría.. información otras actividades que estén marcha mismo tiempo.. una descripción del estado del sistema cuando termina escenario. -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos suposición inicial: paciente observa auxiliar médico que elabora registro sistema recaba información personal aquél (nombre, dirección, edad, etcétera). una enfermera ingresa sistema obtiene historia médica. normal: enfermera busca paciente por nombre completo. hay más paciente con mismo apellido, para identificarlo usa nombre fecha nacimiento. enfermera elige opción menú añade historia médica.inmediatamente enfermera sigue una serie indicadores (prompt) del sistema para ingresar información consultas otras instituciones, sobre problemas salud mental (entrada libre texto), condiciones médicas existentes ( enfermera selecciona las condiciones del menú), medicamentos administrados actualmente (seleccionados del menú), alergias (texto libre) vida familiar (formato). qué puede salir mal: existe registro del paciente puede encontrarse, enfermera debe crear nuevo registro ingresar información personal. las condiciones los medicamentos del paciente ingresan menú. enfermera debe elegir opción “otro” ingresar texto libre que describa condición/medicamento. paciente puede/ proporciona información acerca historia médica. enfermera tiene que ingresar texto libre que registre incapacidad/renuencia brindar información. sistema debe imprimir formato exclusión estándar que menciona que falta información podría significar que tratamiento esté limitado demorado. esto tiene que firmarlo paciente. otras actividades: mientras ingresa información, otros miembros del personal pueden consultar los registros, pero editarlos. estado del sistema completar: ingreso del usuario. registro del paciente, incluida historia médica, integra base datos, agrega registro bitácora (log) del sistema que indica tiempo inicio terminación sesión enfermera cargo. adquisición basada escenario implica trabajar con los participantes para iden- tificar escenarios captar detalles incluir dichos escenarios. estos últimos pueden escribirse como texto, complementarse con diagramas, tomas pantallas, etcétera. forma alternativa, posible usar enfoque más estructurado, como los escenarios evento casos uso. como ejemplo simple escenario texto, considere cómo usaría mhc-pms para ingresar datos nuevo paciente (figura .). cuando nuevo paciente asiste una clínica, auxiliar médico crea nuevo registro agrega información personal (nombre, edad, etcétera). después, una enfermera entrevista paciente recaba his-toria médica. luego, paciente tiene una consulta inicial con médico que diag-nostica , adecuado, recomienda tratamiento. escenario muestra que sucede cuando recaba historia médica. .. casos uso los casos uso son una técnica descubrimiento requerimientos que introdujo por primera vez método objectory (jacobson ., ). ahora convertido figura . escenario para recabar historia médica mhc-pms -.indd -.indd // :: // :: . ■ adquisición análisis requerimientos una característica fundamental del modelado lenguaje unificado. forma más sencilla, caso uso identifica los actores implicados una interacción, nombra tipo interacción. entonces, esto complementa con información adicional que des-cribe interacción con sistema. información adicional puede ser una descripción textual, bien, uno más modelos gráficos como una secuencia uml gráfico estado. los casos uso documentan con empleo diagrama caso uso alto nivel. conjunto casos uso representa todas las interacciones posibles que describirán los requerimientos del sistema. los actores proceso, que pueden ser individuos otros sistemas, representan como figuras sencillas. cada clase interac-ción constituye como una elipse con etiqueta. líneas vinculan los actores con inte-racción. manera opcional, agregan puntas flecha las líneas para mostrar cómo inicia interacción. esto ilustra figura ., que presenta algunos los casos uso para sistema información del paciente. hay distinción tajante rápida entre escenarios casos uso. algunas personas consideran que cada caso uso solo escenario; otras, como sugieren stevens pooley (), encapsulan conjunto escenarios solo caso uso. cada escenario solo hilo través del caso uso. por tanto, habría escenario para interacción normal, más escenarios para cada posible excepción. práctica, posible usarlos cualquier forma. los casos uso identifican las interacciones individuales entre sistema sus usua-rios otros sistemas. cada caso uso debe documentarse con una descripción textual. entonces pueden vincularse con otros modelos uml que desarrollará escenario con más detalle. por ejemplo, una breve descripción del caso uso establece con- sulta figura . sería: establecimiento consulta permite que dos más médicos, que trabajan diferentes consultorios, vean mismo registro simultáneamente. médico inicia consulta elegir individuo involucrado menú desplegable médicos que estén línea. entonces registro del paciente despliega sus pantallas, auxiliar médicoadministradorregistro paciente inf. personalgenera reporteexporta estadísticas enfermeramédicove registro edita registro establece consulta figura . casos uso para mhc-pms -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos pero sólo médico que inicia puede editar registro. además, crea una ven- tana chat texto para ayudar coordinar las acciones. supone que, manera separada, establecerá una conferencia telefónica para comunicación por voz. los escenarios los casos uso son técnicas efectivas para adquirir requerimientos los participantes que interactúan directamente con sistema. cada tipo interac-ción puede representarse como caso uso. sin embargo, debido que enfocan interacciones con sistema, son tan efectivas para adquirir restricciones requeri-mientos empresariales funcionales alto nivel, para descubrir requerimientos dominio. uml estándar facto para modelado orientado objetos, así que los casos uso adquisición basada casos ahora utilizan ampliamente para adquisición requerimientos. los casos uso estudian capítulo , muestra cómo emplean junto con otros modelos del sistema para documentar diseño sistema. .. etnografía los sistemas software existen aislados. usan contexto social organiza-cional, dicho escenario podría derivar restringir los requerimientos del sistema software. menudo satisfacer dichos requerimientos sociales organizacionales crí-tico para éxito del sistema. una razón por que muchos sistemas software entre-gan, nunca utilizan, que sus requerimientos consideran manera adecuada cómo afectaría contexto social organizacional operación práctica del sistema. etnografía una técnica observación que usa para entender los procesos operacionales ayudar derivar requerimientos apoyo para dichos procesos. ana-lista adentra ambiente laboral donde usará sistema. observa trabajo diario toma notas acerca las tareas existentes que intervienen los participantes. valor etnografía que ayuda descubrir requerimientos implícitos del sistema que refle-jan las formas actuales que trabaja gente, vez los procesos formales definidos por organización. las personas con frecuencia encuentran muy difícil articular los detalles trabajo, porque una segunda forma vida para ellas. entienden trabajo, pero tal vez relación con otras funciones organización. los factores sociales organizacionales que afectan trabajo, que son evidentes para los individuos, sólo vuelven claros cuando los percibe observador sin prejuicios. por ejemplo, grupo trabajo puede organizarse modo que sus miembros conozcan trabajo los demás suplan entre cuando alguien ausenta. probable que esto mencione durante una entrevista, pues grupo podría verlo como una parte integral función. suchman () fue una las primeras usar etnografía para estudiar trabajo oficina. ella descubrió que las prácticas reales del trabajo son más ricas, más complejas más dinámicas que los modelos simples supuestos por los sistemas automatización administrativa. diferencia entre trabajo supuesto real fue razón más importante por que dichos sistemas oficina tenían efecto significativo sobre productivi-dad. crabtree () analiza desde entonces una amplia gama estudios, describe, -.indd -.indd // :: // :: . ■ adquisición análisis requerimientos general, uso etnografía diseño sistemas. autor investigado métodos para integrar etnografía proceso ingeniería software, mediante vinculación con los métodos ingeniería requerimientos (viller sommerville, ; viller sommerville, ) patrones para documentar interacción sistemas cooperativos (martin ., ; martin ., ; martin sommerville, ). etnografía muy efectiva para descubrir dos tipos requerimientos: . requerimientos que derivan forma que realmente trabaja gente, vez forma cual las definiciones del proceso indican que debería trabajar. por ejemplo, los controladores tráfico aéreo pueden desactivar sistema alerta conflicto que detecte una aeronave con trayectoria vuelo que cruza, aun cuando los procedimientos control normales especifiquen que obligatorio usar tal sistema. ellos deliberadamente dejan aeronave sobre ruta conflic- durante breves momentos, para ayudarse dirigir espacio aéreo. estrategia control está diseñada para garantizar que dichas aeronaves desvíen antes que haya problemas, consideran que alarma alerta conflicto los distrae trabajo. . requerimientos que derivan cooperación conocimiento las activida- des otras personas. por ejemplo, los controladores tráfico aéreo pueden usar conocimiento del trabajo otros controladores para predecir número aero-naves que entrarán sector control. entonces, modifican sus estrategias control dependiendo dicha carga trabajo prevista. por tanto, sistema atc automatizado debería permitir los controladores sector tener cierta visibilidad del trabajo sectores adyacentes. etnografía puede combinarse con creación prototipos (figura .). etno-grafía informa del desarrollo del prototipo, modo que requieren menos ciclos refinamiento del prototipo. más aún, creación prototipos enfoca etnografía identificar problemas preguntas que entonces pueden discutirse con etnógrafo. siendo así, éste debe buscar las respuestas dichas preguntas durante siguiente fase estudio del sistema (sommerville ., ). los estudios etnográficos pueden revelar detalles críticos procesos, que con fre-cuencia pierden con otras técnicas adquisición requerimientos. sin embargo, debido enfoque usuario final, siempre adecuado para descubrir reque-rimientos organización dominio. todos los casos identifican nuevas características que deben agregarse sistema. consecuencia, etnografía enfoque completo para adquisición por misma, debe usarse para complementar otros enfoques, como análisis casos uso.análisis etnográficoreuniones interrogatorioetnografía enfocada evaluación prototipos desarrollo del sistema genéricoprototipo del sistemafigura . etnografía creación prototipos para análisis requerimientos -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos . validación requerimientos validación requerimientos proceso verificar que los requerimientos definan realmente sistema que verdad quiere cliente. traslapa con análisis, que interesa por encontrar problemas con los requerimientos. validación requerimien-tos importante porque los errores documento requerimientos pueden conducir grandes costos por tener que rehacer, cuando dichos problemas descubren durante desarrollo del sistema después que éste halla servicio. general, costo por corregir problema requerimientos hacer cambio sistema mucho mayor que reparar los errores diseño codificación. razón que cambio los requerimientos significa generalmente que también deben cambiar diseño implementación del sistema. más aún, sistema debe entonces ponerse prueba nuevo. durante proceso validación requerimientos, tienen que realizarse diferentes tipos comprobaciones sobre los requerimientos contenidos documento reque-rimientos. dichas comprobaciones incluyen: . comprobaciones validez usuario quizá crea que necesita sistema para realizar ciertas funciones. sin embargo, con mayor consideración análisis logra identificar las funciones adicionales diferentes que requieran. los sistemas tie-nen diversos participantes con diferentes necesidades, cualquier conjunto requeri-mientos inevitablemente compromiso través comunidad participantes. . comprobaciones consistencia los requerimientos documento deben estar conflicto. esto , debe haber restricciones contradictorias descripcio-nes diferentes misma función del sistema. . comprobaciones totalidad documento requerimientos debe incluir reque- rimientos que definan todas las funciones las restricciones pretendidas por usuario del sistema. . comprobaciones realismo usar conocimiento tecnología existente, los requerimientos deben comprobarse para garantizar que realidad pueden imple-mentarse. dichas comprobaciones también tienen que considerar presupuesto fecha para desarrollo del sistema. . verificabilidad para reducir potencial disputas entre cliente contratista, los requerimientos del sistema deben escribirse siempre manera que sean verifica-bles. esto significa que usted debe ser capaz escribir conjunto pruebas que demuestren que sistema entregado cumpla cada requerimiento especificado.revisiones requerimientos una revisión requerimientos proceso donde grupo personas del cliente del sistema desarrollador del sistema leen con detalle documento requerimientos buscan errores, anomalías inconsistencias. una vez detectados registrados, recae cliente desarrollador labor negociar cómo resolver los problemas identificados. http:// -.indd -.indd // :: // :: . ■ administración requerimientos hay algunas técnicas validación requerimientos que usan individualmente conjunto con otras: . revisiones requerimientos los requerimientos analizan sistemáticamente usando equipo revisores que verifican errores inconsistencias. . creación prototipos esta aproximación validación, muestra modelo ejecutable del sistema cuestión los usuarios finales clientes. así, ellos podrán experimentar con este modelo para constatar cubre sus necesidades reales. . generación casos prueba los requerimientos deben ser comprobables. las pruebas para los requerimientos diseñan como parte del proceso validación, esto revela con frecuencia problemas los requerimientos. una prueba difícil imposible diseñar, esto generalmente significa que los requerimientos serán difíciles implementar, por que deberían reconsiderarse. desarrollo prue-bas partir los requerimientos del usuario antes escribir cualquier código una pieza integral programación extrema. hay que subestimar los problemas incluidos validación requerimientos. final cuentas, difícil demostrar que conjunto requerimientos, hecho, cubre las necesidades los usuarios. estos últimos necesitan una imagen del sistema operación, así como comprender forma que dicho sistema ajustará trabajo. difícil, incluso para profesionales computación experimentados, realizar este tipo análisis abstracto, más aún para los usuarios del sistema. como resultado, rara vez usted encontrará todos los problemas requerimientos durante proceso validación requerimientos. inevitable que haya más cambios los requerimientos para corregir omisiones malas interpretaciones, después acordar documento requerimientos. . administración requerimientos los requerimientos para los grandes sistemas software siempre cambian. una razón que dichos sistemas desarrollaron por general para resolver problemas “horrorosos”: aquellos problemas que pueden definir por completo. como problema logra definir por completo, los requerimientos del software están condenados también estar incompletos. durante proceso software, comprensión que los participantes tienen los problemas cambia constantemente (figura .). entonces, los requerimientos del sistema también deben evolucionar para reflejar esa visión cambiante del problema.tiempocambio comprensión del problemacomprensión inicial del problema cambio los requerimientosrequerimientos inicialesfigura . evolución los requerimientos -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos una vez que instala sistema, utiliza con regularidad, surgirán inevitablemente nuevos requerimientos. difícil que los usuarios clientes del sistema anticipen qué efec-tos tendrá nuevo sistema sobre sus procesos negocios forma que hace trabajo. una vez que los usuarios finales experimentan sistema, descubrirán nuevas necesidades prioridades. existen muchas razones por las que inevitable cambio: . los ambientes empresarial técnico del sistema siempre cambian después ins- talación. puede introducirse nuevo hardware, quizá sea necesario poner interfaz sistema con otros sistemas, cambiar las prioridades empresa (con los con-secuentes cambios sistema apoyo requerido) introducir nuevas leyes regulaciones que sistema deba cumplir cabalmente. . los individuos que pagan por sistema los usuarios dicho sistema, por general, son los mismos. los clientes del sistema imponen requerimientos debido restric-ciones organizativas presupuestales. esto podría estar conflicto con los reque-rimientos del usuario final , después entrega, probablemente deban agregarse nuevas características para apoyar usuario, sistema debe cubrir sus metas. . los sistemas grandes tienen regularmente una comunidad usuarios diversa, cual muchos individuos tienen diferentes requerimientos prioridades que quizás estén conflicto sean contradictorios. los requerimientos finales del sistema ine-vitablemente tienen compromiso entre , con experiencia, menudo des-cubre que equilibrio apoyo brindado diferentes usuarios tiene que cambiar. administración requerimientos proceso comprender controlar los cam-bios los requerimientos del sistema. necesario seguir pista requerimientos indi-viduales mantener los vínculos entre los requerimientos dependientes, manera que pueda valorarse efecto del cambio los requerimientos. también preciso establecer proceso formal para hacer cambios las propuestas vincular éstos con los reque-rimientos del sistema. proceso formal administración requerimientos debe comenzar tan pronto como esté disponible borrador del documento requerimientos. sin embargo, hay que empezar planear cómo administrar cambio los requerimien-tos durante proceso adquisición los mismos. .. planeación administración requerimientos planeación una primera etapa esencial proceso administración requeri-mientos. esta etapa establece nivel detalle que requiere administración requerimientos. durante etapa administración requerimientos, usted tiene que decidir sobre:requerimientos duraderos volátiles algunos requerimientos son más susceptibles cambiar que otros. los requerimientos duraderos son los requerimientos que asocian con las actividades centrales, lento cambio, una organización. también estos requerimientos relacionan con actividades laborales fundamentales. por contrario, los requerimientos volátiles tienen más probabilidad cambio. asocian por general con actividades apoyo que reflejan cómo organización hace trabajo más que trabajo . http:// -.indd -.indd // :: // :: . ■ administración requerimientos . identificación requerimientos cada requerimiento debe identificarse manera exclusiva, forma que pueda tener referencia cruzada con otros requerimientos usarse las evaluaciones seguimiento. . proceso administración del cambio éste conjunto actividades que valoran efecto costo los cambios. siguiente sección estudia con más detalle este proceso. . políticas seguimiento dichas políticas definen las relaciones entre cada requeri-miento, así como entre los requerimientos diseño del sistema que debe registrarse. política seguimiento también tiene que definir cómo mantener dichos registros. . herramientas apoyo administración requerimientos incluye proce-samiento grandes cantidades información acerca los requerimientos. las herramientas disponibles varían desde sistemas especializados administración requerimientos, hasta hojas cálculo sistemas bases datos simples. administración requerimientos necesita apoyo automatizado herramientas software, para cual deben seleccionarse durante fase planeación. necesitan herramientas apoyo para: . almacenamiento requerimientos los requerimientos tienen que mantenerse almacén datos administrado seguro, que sea accesible para todos quienes intervienen proceso ingeniería requerimientos. . administración del cambio proceso administración del cambio (figura .) simplifica está disponible herramienta apoyo activa. . administración del seguimiento como estudió anteriormente, herramienta apoyo para seguimiento permite identificación requerimientos relacionados. algunas herramientas que están disponibles usan técnicas procesamiento len-guaje natural, para ayudar descubrir posibles relaciones entre los requerimientos. para sistemas pequeños, quizá sea necesario usar herramientas especializadas administración requerimientos. proceso administración requerimientos puede apoyarse con uso funciones disponibles procesadores texto, hojas cálculo bases datos . sin embargo, para sistemas más grandes requieren herra-mientas apoyo más especializadas. las páginas web del libro incluyen vínculos información acerca herramientas administración requerimientos. .. administración del cambio los requerimientos administración del cambio los requerimientos (figura .) debe aplicarse todos los cambios propuestos los requerimientos sistema, después aprobarse docu-mento requerimientos. administración del cambio esencial porque necesario determinar los beneficios implementar nuevos requerimientos están justificados por implementación del cambioanálisis del cambio estimación del costoanálisis del problema cambio especificaciónidentificación del problemarevisión requerimientos figura . administración del cambio requerimientos -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos los costos implementación. ventaja usar proceso formal para administra- ción del cambio que todas las propuestas cambio tratan manera consistente los cambios documento requerimientos realizan una forma controlada. existen tres etapas principales proceso administración del cambio: . análisis del problema especificación del cambio proceso comienza con identificación problema los requerimientos , ocasiones, con una pro-puesta cambio específica. durante esta etapa, problema propuesta cambio analizan para comprobar que válida. este análisis retroalimenta soli-citante del cambio, quien responderá con una propuesta cambio requerimien-tos más específica, decidirá retirar petición. . análisis del cambio estimación del costo efecto del cambio propuesto valora usando información seguimiento conocimiento general los requerimientos del sistema. costo por realizar cambio estima términos modificaciones documento requerimientos , adecuado, diseño implementación del sistema. una vez completado este análisis, toma una decisión acerca procede con cambio requerimientos. . implementación del cambio modifican documento requerimientos , donde sea necesario, diseño implementación del sistema. hay que organizar docu-mento requerimientos forma que sea posible realizar cambios sin reescritura reorganización extensos. conforme los programas, variabilidad los docu-mentos logra minimizar las referencias externas hacer las secciones del documento tan modulares como sea posible. esta manera, secciones individuales pueden modificarse sustituirse sin afectar otras partes del documento. nuevo requerimiento tiene que implementarse urgentemente, siempre existe tentación para cambiar sistema luego modificar manera retrospectiva docu-mento requerimientos. hay que tratar evitar esto, pues casi siempre conducirá que especificación requerimientos implementación del sistema salgan ritmo. una vez realizados los cambios sistema, fácil olvidar inclusión dichos cambios documento requerimientos, bien, agregar información documento reque-rimientos que sea inconsistente con implementación. los procesos desarrollo ágil, como programación extrema, diseñaron para enfrentar los requerimientos que cambian durante proceso desarrollo. dichos procesos, cuando usuario propone cambio requerimientos, éste pasa por proceso administración del cambio formal. vez ello, usuario tiene que priorizar dicho cambio , alta prioridad, decidir qué características del sistema planeadas para siguiente iteración pueden eliminarse.seguimiento requerimientos necesario seguir huella las relaciones entre requerimientos, sus fuentes diseño del sistema, modo que usted pueda analizar las razones para los cambios propuestos, así como efecto que dichos cambios tengan probablemente sobre otras partes del sistema. necesario poder seguir pista cómo cambio propaga hacia sistema. ¿por qué? http:// -.indd -.indd // :: // :: pmcapítulo ■ lecturas sugeridas puntos clave ■ los requerimientos para sistema software establecen que debe hacer sistema definen las restricciones sobre operación implementación. ■ los requerimientos funcionales son enunciados los servicios que debe proporcionar sistema, descripciones cómo deben realizarse algunos cálculos. ■ los requerimientos funcionales restringen con frecuencia sistema que desarrollar proceso desarrollo usar. éstos pueden ser requerimientos del producto, requerimientos organizacionales requerimientos externos. menudo relacionan con las propiedades emergentes del sistema , por tanto, aplican sistema conjunto. ■ documento requerimientos software enunciado acordado sobre los requerimientos del sistema. debe organizarse forma que puedan usarlo tanto los clientes del sistema como los desarrolladores del software. ■ proceso ingeniería requerimientos incluye estudio factibilidad, adquisición análisis requerimientos, especificación requerimientos, validación requerimientos administración requerimientos. ■ adquisición análisis requerimientos proceso iterativo que representa como una espiral actividades: descubrimiento requerimientos, clasificación organización requerimientos, negociación requerimientos documentación requerimientos. ■ validación requerimientos proceso comprobar validez, consistencia, totalidad, realismo verificabilidad los requerimientos. ■ los cambios empresariales, organizacionales técnicos conducen inevitablemente cambios los requerimientos para sistema software. administración requerimientos proceso gestionar controlar dichos cambios. lecturas sugeridas software requirements, edition. este libro, diseñado para escritores usuarios requerimientos, analiza las buenas prácticas ingeniería requerimientos. (. . weigers, , microsoft press.) “integrated requirements engineering: tutorial”. trata ensayo tutoría que analizan las actividades ingeniería requerimientos cómo pueden adaptarse para ajustarse las prácticas modernas ingeniería software. (. sommerville, ieee software, (), jan–feb .) http://.doi.org/./... mastering the requirements process, edition. libro bien escrito, fácil leer, que basa método particular (volere), pero que también incluye múltiples buenos consejos generales acerca ingeniería requerimientos. (. robertson . robertson, , addison-wesley.) “research directions requirements engineering”. buen estudio investigación ingeniería requerimientos que destaca los futuros retos investigación área, con finalidad enfrentar conflictos como escala agilidad. (. . . cheng . . atlee, proc. conf future software engineering, ieee computer society, .) http:/ /. doi. org/ . / fose. . . -.indd -.indd // :: // :: capítulo ■ ingeniería requerimientos ejercicios .. identifique describa brevemente cuatro tipos requerimientos que puedan definirse para sistema basado computadora. .. descubra las ambigüedades omisiones siguiente enunciado requerimientos sistema emisión boletos: sistema automatizado emisión boletos vende boletos ferrocarril. los usuarios seleccionan destino ingresan número tarjeta crédito uno identificación personal. boleto ferrocarril emite carga cuenta tarjeta crédito. cuando usuario oprime botón start, activa una pantalla menú con los posibles destinos, junto con mensaje que pide usuario seleccionar destino. una vez seleccionado destino, solicita los usuarios ingresar tarjeta crédito. comprueba validez luego pide usuario ingresar identificador personal. cuando valida transacción crediticia, emite boleto. .. vuelva escribir descripción anterior usando enfoque estructurado referido este capítulo. resuelva las ambigüedades identificadas forma adecuada. .. escriba conjunto requerimientos funcionales para sistema emisión boletos, establezca fiabilidad tiempo respuesta esperados. .. con técnica aquí sugerida, que las descripciones lenguaje natural presentan formato estándar, escriba requerimientos usuario plausibles para las siguientes funciones: ■ sistema bombeo petróleo (gasolina) asistido que incluya lector tarjeta crédito. cliente pasa tarjeta lector, luego especifica cantidad combustible requerido. suministra combustible deduce cuenta del cliente. ■ función dispensar efectivo cajero automático. ■ función revisión corrección ortográfica procesador textos. .. sugiera cómo ingeniero responsable redactar una especificación requerimientos sistema puede seguir huella las relaciones entre requerimientos funcionales funcionales. .. con conocimiento cómo usa cajero automático, desarrolle conjunto casos uso que pudieran servir como base para comprender los requerimientos para sistema cajero automático. .. ¿quién debería involucrarse una revisión requerimientos? dibuje modelo del proceso que muestre cómo podría organizarse una revisión requerimientos. .. cuando tienen que hacerse cambios emergencia los sistemas, posible que deba modificarse software del sistema antes aprobar los cambios los requerimientos. sugiera modelo proceso para realizar dichas modificaciones, que garantice que documento requerimientos implementación del sistema serán inconsistentes. .. usted acepta empleo con usuario software, quien contrató empleador anterior con finalidad desarrollar sistema para ellos. usted descubre que interpretación los requerimientos compañía diferente interpretación tomada por antiguo empleador. discuta qué haría tal situación. usted sabe que los costos para actual empleador aumentarán resuelven las ambigüedades. sin embargo, también tiene una responsabilidad confidencialidad con empleador anterior. -.indd -.indd // :: // :: pmcapítulo ■ referencias referencias beck, . (). “embracing change with extreme programming”. ieee computer, (), –. crabtree, . (). designing collaborative systems: practical guide ethnography. london: springer-verlag. davis, . . (). software requirements: objects, functions and states. englewood cliffs, : prentice hall. ieee. (). “ieee recommended practice for software requirements specifications”. ieee software engineering standards collection. los alamitos, .: ieee computer society press. jacobson, ., christerson, ., jonsson, . overgaard, . (). object-oriented software engineering. wokingham: addison-wesley.kotonya, . sommerville, . (). requirements engineering: processes and techniques. chichester, : john wiley and sons.larman, . (). applying uml and patterns: introduction object-oriented analysis and design and the unified process. englewood cliff, : prentice hall. martin, ., rodden, ., rouncefield, ., sommerville, . viller, . (). “finding patterns the fieldwork”. proc. ecscw’. bonn: kluwer. –. martin, ., rouncefield, . sommerville, . (). “applying patterns interaction work () design: -government and planning”. proc. acm chi’, acm press. –. martin, . sommerville, . (). “patterns interaction: linking ethnomethodology and design”. acm trans. computer-human interaction, (), –. robertson, . robertson, . (). mastering the requirements process. harlow, : addison- wesley. sommerville, ., rodden, ., sawyer, ., bentley, . twidale, . (). “integrating ethnography into the requirements engineering process”. proc. ’, san diego .: ieee computer society press. –. stevens, . pooley, . (). using uml: software engineering with objects and components, . harlow, : addison wesley. suchman, . (). plans and situated actions. cambridge: cambridge university press.viller, . sommerville, . (). “coherence: approach representing ethnographic analyses systems design”. human-computer interaction, ( & ), –. viller, . sommerville, . (). “ethnographically informed analysis for software engineers”. int. . human-computer studies, (), –. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducir algunos tipos modelo sistema que pueden desarrollarse, como parte ingeniería requerimientos los procesos diseño del sistema. estudiar este capítulo: ■ comprenderá cómo usar los modelos gráficos para representar los sistemas software; ■ entenderá por qué requieren diferentes tipos modelo, así como las perspectivas fundamentales contexto, interacción, estructura comportamiento del modelado sistemas; ■ accederá algunos los tipos diagrama lenguaje modelado unificado (uml) conocerá cómo utilizan dichos diagramas modelado del sistema; ■ estará tanto las ideas que subyacen ingeniería dirigida por modelo, donde sistema genera automáticamente partir modelos estructurales comportamiento. contenido . modelos contexto . modelos interacción. modelos estructurales. modelos comportamiento. ingeniería dirigida por modelo modelado del sistema -.indd -.indd // :: // :: pmcapítulo ■ modelado del sistema modelado sistemas proceso para desarrollar modelos abstractos sistema, donde cada modelo presenta una visión perspectiva diferente dicho sistema. general, modelado sistemas convertido medio para representar sis-tema usando algún tipo notación gráfica, que ahora casi siempre basa notaciones lenguaje modelado unificado (uml). sin embargo, también posible desa-rrollar modelos formales (matemáticos) sistema, generalmente como una especifi-cación detallada del sistema. este capítulo estudia modelado gráfico utilizando uml, capítulo , modelado formal. los modelos usan durante proceso ingeniería requerimientos para ayudar derivar los requerimientos sistema, durante proceso diseño para describir sistema los ingenieros que implementan sistema, después implementación para documentar estructura operación del sistema. posible desarrollar modelos tanto del sistema existente como del sistema diseñar: . los modelos del sistema existente usan durante ingeniería requerimientos. ayudan aclarar que hace sistema existente pueden utilizarse como base para discutir sus fortalezas debilidades. posteriormente, conducen los requerimientos para nuevo sistema. . los modelos del sistema nuevo emplean durante ingeniería requerimien- tos para ayudar explicar los requerimientos propuestos otros participantes del sistema. los ingenieros usan tales modelos para discutir las propuestas diseño documentar sistema para implementación. proceso ingeniería dirigido por modelo, posible generar una implementación sistema completa parcial partir del modelo del sistema. aspecto más importante modelo del sistema que deja fuera los detalles. modelo una abstracción del sistema estudiar, una representación alterna-tiva dicho sistema. manera ideal, una representación sistema debe mantener toda información sobre entidad representar. una abstracción simplifica recoge deliberadamente las características más destacadas. por ejemplo, muy improbable caso que este libro entregue por capítulos periódico, presentación sería una abstracción los puntos clave del libro. tradujera del inglés italiano, sería una repre-sentación alternativa. intención del traductor sería mantener toda información como presenta inglés. desde diferentes perspectivas, usted puede desarrollar diferentes modelos para repre-sentar sistema. por ejemplo: . una perspectiva externa, donde modelen contexto entorno del sistema. . una perspectiva interacción, donde modele interacción entre sistema entorno, entre los componentes sistema. . una perspectiva estructural, donde modelen organización sistema estructura datos que procese sistema. . una perspectiva comportamiento, donde modele comportamiento dinámico del sistema cómo responde ante ciertos eventos. -.indd -.indd // :: // :: capítulo ■ modelado del sistema estas perspectivas tienen mucho común con visión + arquitectura del sistema kruchten (kruchten, ), cual sugiere que arquitectura organiza-ción sistema deben documentarse desde diferentes perspectivas. capítulo estudia este enfoque + . este capítulo usan diagramas definidos uml (booch ., ; rumbaugh ., ), que han convertido lenguaje modelado estándar para modelado orientado objetos. uml tiene numerosos tipos diagramas , por tanto, soporta creación muchos diferentes tipos modelo sistema. sin embargo, estudio (erickson siau, ) mostró que mayoría los usuarios del uml considera-ban que cinco tipos diagrama podrían representar esencial sistema. . diagramas actividad, que muestran las actividades incluidas proceso procesamiento datos. . diagramas caso uso, que exponen las interacciones entre sistema entorno. . diagramas secuencias, que muestran las interacciones entre los actores sis- tema, entre los componentes del sistema. . diagramas clase, que revelan las clases objeto sistema las asociaciones entre estas clases. . diagramas estado, que explican cómo reacciona sistema frente eventos inter- nos externos. como aquí hay espacio para discutir todos los tipos diagramas uml, enfoque centrará cómo estos cinco tipos clave diagramas usan modelado del sistema. cuando desarrolle modelos sistema, sea flexible forma que use notación gráfica. siempre necesitará apegarse rigurosamente los detalles una notación. detalle rigor modelo dependen cómo use. hay tres formas que los modelos gráficos emplean con frecuencia: . como medio para facilitar discusión sobre sistema existente propuesto. . como una forma documentar sistema existente.. como una descripción detallada del sistema que sirve para generar una implementa- ción sistema. primer caso, propósito del modelo estimular discusión entre los inge- nieros software que intervienen desarrollo del sistema. los modelos pueden ser incompletos (siempre que cubran los puntos clave discusión) utilizar manera informal notación modelado. así como utilizan general los modelos llamado “modelado ágil” (ambler jeffries, ). cuando los modelos usan como documentación, tienen que estar completos, pues quizás usted sólo desee desarro-llar modelos para algunas partes sistema. sin embargo, estos modelos deben ser correctos: tienen que usar adecuadamente notación ser una descripción precisa del sistema. -.indd -.indd // :: // :: . ■ modelos contexto tercer caso, que los modelos usan como parte proceso desarrollo basado modelo, los modelos sistema deben ser completos correctos. razón para esto que usan como base para generar código fuente del sistema. por tanto, debe ser muy cuidadoso confundir símbolos equivalentes, como las flechas palo las bloque, que tienen significados diferentes. . modelos contexto una primera etapa especificación sistema, debe decidir sobre las fronte-ras del sistema. esto implica trabajar con los participantes del sistema para determinar cuál funcionalidad incluirá sistema cuál ofrece entorno del sistema. tal vez decida que apoyo automatizado para algunos procesos empresariales deba imple-mentarse, pero otros deben ser procesos manuales soportados por sistemas diferentes. debe buscar posibles traslapes funcionalidad con los sistemas existentes determi-nar dónde tiene que implementarse nueva funcionalidad. estas decisiones deben hacerse oportunamente durante proceso, para limitar los costos del sistema, así como tiempo necesario para comprender los requerimientos diseño del sistema. algunos casos, frontera entre sistema entorno relativamente clara. por ejemplo, donde sistema automático sustituye sistema manual computarizado, entorno del nuevo sistema, por general, mismo que entorno del sistema exis-tente. otros casos, existe más flexibilidad usted quien decide qué constituye frontera entre sistema entorno, durante proceso ingeniería requerimientos. por ejemplo, imagine que desarrolla especificación para sistema información pacientes para atención salud mental. este sistema intenta manejar informa-ción sobre los pacientes que asisten clínicas salud mental los tratamientos que les prescriben. desarrollar especificación para este sistema, debe decidir sis-tema tiene que enfocarse exclusivamente reunir información las consultas (junto con otros sistemas para recopilar información personal acerca los pacientes), también necesario que recopile datos personales acerca del paciente. ventaja apoyarse otros sistemas para información del paciente que evita duplicar datos. sin embargo, principal desventaja que usar otros sistemas haría más lento acceso información. estos sistemas están disponibles, entonces pueden usarse mhc-pms. lenguaje modelado unificado lenguaje modelado unificado conjunto compuesto por diferentes tipos diagrama para modelar sistemas software. surgió del trabajo década sobre modelado orientado objetos, cuando anotaciones similares, orientadas objetos, integraron para crear uml. una amplia revisión (uml ) finalizó . uml aceptado universalmente como enfoque estándar desarrollo modelos sistemas software. han propuesto variantes más generales para modelado sistemas. http:// -.indd -.indd // :: // :: capítulo ■ modelado del sistema definición frontera sistema juicio libre valor. las preocupa- ciones sociales organizacionales pueden significar que posición frontera sistema determine considerando factores técnicos. por ejemplo, una frontera sistema puede colocarse deliberadamente, modo que todo proceso análisis realice sitio; puede elegirse forma que sea innecesario consultar adminis-trador particularmente difícil; puede situarse manera que costo del sistema aumente división desarrollo del sistema deba, por tanto, expandirse diseño imple-mentación del sistema. una vez tomadas algunas decisiones sobre las fronteras del sistema, parte activi-dad análisis definición dicho contexto las dependencias que sistema tiene con entorno. normalmente, producir modelo arquitectónico simple primer paso esta actividad. figura . modelo contexto simple que muestra sistema información del paciente otros sistemas entorno. partir figura ., observa que mhc-pms está conectado con sistema citas sistema más general registro pacientes, con cual comparte datos. sistema también está conectado sistemas para manejo reportes asignación camas hospital, sistema estadísticas que recopila información para investigación. finalmente, utiliza sistema pres-cripción que elabora recetas para medicación los pacientes. los modelos contexto, por general, muestran que entorno incluye varios sistemas automatizados. sin embargo, presentan los tipos relaciones entre los sis-temas entorno sistema que especifica. los sistemas externos generan datos para sistema consumen datos del sistema. pueden compartir datos con sistema, conectarse directamente, través una red, conectarse absoluto. pueden estar físicamente juntos ubicados edificios separados. todas estas relaciones llegan afectar los requerimientos diseño del sistema definir, por que deben tomarse cuenta. por consiguiente, los modelos contexto simples usan junto con otros modelos, como los modelos proceso empresarial. éstos describen procesos humanos automa-tizados que usan sistemas particulares software.“sistema” mhc-pms“sistema” sistema registro del paciente “sistema” sistema citas“sistema” sistema admisiones“sistema” sistema reporte administrativo “sistema” sistema prescripción“sistema” sistema estadísticas figura . contexto del mhc-pms -.indd -.indd // :: // :: . ■ modelos contexto figura . modelo importante proceso sistema que muestra los procesos que utiliza mhc-pms. ocasiones, los pacientes que sufren pro-blemas salud mental son riesgo para otros para mismos. por ello, posible que hospital deban mantenerse contra voluntad para que les suministre trata-miento. tal detención está sujeta estrictas protecciones legales, por ejemplo, decisión detener paciente tiene que revisarse con regularidad, para que detenga persona indefinidamente sin una buena razón. una las funciones del mhc-pms garantizar que implementen dichas protecciones. figura . diagrama actividad uml. los diagramas actividad inten-tan mostrar las actividades que incluyen proceso sistema, así como flujo control una actividad otra. inicio proceso indica con círculo lleno; fin, mediante círculo lleno dentro otro círculo. los rectángulos con esquinas redondeadas representan actividades, esto , los subprocesos específicos que hay que realizar. puede incluir objetos los gráficos actividad. figura . muestran los sistemas que sirven para apoyar diferentes procesos. indicó que éstos son sistemas separados usar característica estereotipo uml. diagrama actividad uml, las flechas representan flujo trabajo una acti-vidad otra. una barra sólida emplea para indicar coordinación actividades. cuando flujo más una actividad dirige una barra sólida, entonces todas esas actividades deben completarse antes del posible avance. cuando flujo una barra sólida conduzca algunas actividades, éstas pueden ejecutarse forma paralela. por consiguiente, figura ., las actividades para informar trabajo social familiar cercano del paciente, así como para actualizar registro detención, pueden ser concurrentes. las flechas pueden anotarse con guardas que indiquen condición tomar dicho flujo. figura . observan guardas que muestran los flujos para pacientes que son confirmar decisión detención encontrar lugar seguro admitir hospitaltransferir estación policía traslado seguro hospital “sistema” sistema admisionesinformar pariente próximoinformar trabajo social actualizar registro “sistema” mhc-pms“sistema” mhc-pmsinformar paciente sus derechos registrar decisión detención[peligroso][ disponible] [ peligroso][disponible] figura . modelo del proceso detención involuntaria -.indd -.indd // :: // :: capítulo ■ modelado del sistema riesgo para sociedad quienes son. los pacientes peligrosos deben mantenerse una instalación segura. obstante, los pacientes suicidas que, por tanto, represen-tan riesgo para mismos, detendrían pabellón hospitalario adecuado. . modelos interacción todos los sistemas incluyen interacciones algún tipo. éstas son interacciones del usuario, que implican entradas salidas del usuario; interacciones entre sistema desarrollar otros sistemas; interacciones entre los componentes del sistema. mode-lado interacción del usuario importante, pues ayuda identificar los requerimientos del usuario. modelado interacción sistema sistema destaca los problemas comunicación que lleguen presentar. modelado interacción componentes ayuda entender probable que una estructura sistema propuesto obtenga rendimiento confiabilidad requeridos por sistema. esta sección cubren dos enfoques relacionados con modelado interacción: . modelado caso uso, que utiliza principalmente para modelar interacciones entre sistema actores externos (usuarios otros sistemas). . diagramas secuencia, que emplean para modelar interacciones entre compo- nentes del sistema, aunque también pueden incluirse agentes externos. los modelos caso uso los diagramas secuencia presentan interacción diferentes niveles detalle , por tanto, posible utilizarlos juntos. los detalles las interacciones que hay caso uso alto nivel documentan diagrama secuencia. uml también incluye diagramas comunicación usados para modelar interacciones. aquí analiza esto, que trata representaciones alternativas gráficos secuencia. hecho, algunas herramientas pueden generar diagrama comunicación partir diagrama secuencia. .. modelado casos uso modelado casos uso fue desarrollado originalmente por jacobson sus colabo-radores () década , incorporó primer lanzamiento del uml (rumbaugh ., ). como estudió capítulo , modelado casos uso utiliza ampliamente para apoyar adquisición requerimientos. caso uso puede tomarse como simple escenario que describa que espera usuario sistema. cada caso uso representa una tarea discreta que implica interacción externa con sistema. forma más simple, caso uso muestra como una elipse, con los actores que intervienen caso uso representados como figuras humanas. figura . presenta caso uso del mhc-pms que implica tarea subir datos desde mhc-pms hasta sistema más general registro pacientes. este sistema más general mantiene resumen datos sobre paciente, vez los datos sobre cada consulta, que registran mhc-pms. -.indd -.indd // :: // :: . ■ modelos interacción observe que este caso uso hay dos actores: operador que transfiere los datos sistema registro pacientes. notación con figura humana desarrolló original-mente para cubrir interacción entre individuos, pero también usa ahora para repre-sentar otros sistemas externos hardware. manera formal, los diagramas caso uso deben emplear líneas sin flechas; las flechas uml indican dirección del flujo mensajes. evidentemente, caso uso los mensajes pasan ambas direcciones. sin embargo, las flechas figura . usan manera informal para indicar que recepcionista médica inicia transacción los datos transfieren sistema registro pacientes. los diagramas caso uso brindan panorama bastante sencillo una interac-ción, modo que usted tiene que ofrecer más detalle para entender que está implicado. este detalle puede ser una simple descripción textual, una descripción estructurada una tabla diagrama secuencia, como discute continuación. posible elegir formato más adecuado, dependiendo del caso uso del nivel detalle que usted considere requiera modelo. para autor, formato más útil formato tabu-lar estándar. figura . ilustra una descripción tabular del caso uso “transferencia datos”. como vimos capítulo , los diagramas caso uso compuestos indican número casos uso diferentes. ocasiones, incluyen todas las interacciones posibles con sistema solo diagrama caso uso compuesto. sin embargo, esto quizá sea imposible debido cantidad casos uso. tales situaciones, puede desarrollar varios diagramas, cada uno los cuales exponga casos uso relacionados. por ejemplo, figura . presenta todos los casos uso mhc-pms, los cuales interviene actor “recepcionista médico”.recepcionista médico sistema gistro pacientetransferencia datos figura . caso uso transferencia datos figura . descripción tabular del caso uso “transferencia datos” mhc-pms: transferencia datos actores recepcionista médico, sistema registros paciente (prs). descripción recepcionista puede transferir datos del mhc-pms una base datos general registro pacientes, mantenida por una autoridad sanitaria. información transferida puede ser información personal actualizada (dirección, número telefónico, etc.) resumen del diagnóstico tratamiento del paciente. datos información personal del paciente, resumen tratamiento. estímulo comando usuario emitido por recepcionista médico.respuesta confirmación que prs actualizó.comentarios recepcionista debe tener permisos seguridad adecuados para acceder información del paciente prs. -.indd -.indd // :: // :: capítulo ■ modelado del sistema .. diagramas secuencia los diagramas secuencia uml usan principalmente para modelar las interaccio- nes entre los actores los objetos sistema, así como las interacciones entre los obje-tos . uml tiene una amplia sintaxis para diagramas secuencia, cual permite muchos tipos diferentes interacción modelar. como aquí hay espacio para cubrir todas las posibilidades, sólo nos enfocaremos básico este tipo diagrama. como sugiere nombre, diagrama secuencia muestra sucesión interaccio-nes que ocurre durante caso uso particular una instancia caso uso. figura . ejemplo diagrama secuencia que ilustra los fundamentos notación. estos modelos diagrama incluyen las interacciones caso uso “ver información paciente”, donde recepcionista médico puede conocer información algún paciente. los objetos actores que intervienen mencionan largo parte superior del diagrama, con una línea punteada que dibuja verticalmente partir éstos. las inte-racciones entre los objetos indican con flechas dirigidas. rectángulo sobre las líneas punteadas indica línea vida del objeto tratado ( decir, tiempo que instancia del objeto está involucrada computación). secuencia interacciones lee arriba abajo. las anotaciones sobre las flechas señalan las llamadas los objetos, sus parámetros los valores que regresan. este ejemplo, también muestra notación empleada para exponer alternativas. recuadro marcado con “alt” usa con las condi-ciones indicadas entre corchetes. figura . lee del siguiente modo: . recepcionista médico activa método viewinfo (ver información) una ins- tancia clase objeto patientinfo, suministra identificador del paciente, pid. objeto interfaz usuario, que despliega como formato que muestra información del paciente. . instancia llama base datos para regresar información requerida, suministra identificador del recepcionista para permitir verificación seguri-dad ( esta etapa preocupe dónde proviene este uid).recepcionista médicoregistro paciente transferir datos contacto pacientever info. pacientebaja paciente figura . casos uso que involucran papel “recepcionista médico” -.indd -.indd // :: // :: . ■ modelos interacción . base datos comprueba, mediante sistema autorización, que usuario esté autorizado para tal acción. . está autorizado, regresa información del paciente llena formato pantalla del usuario. autorización falla, entonces regresa mensaje error. figura . segundo ejemplo diagrama secuencia del mismo sistema que ilustra dos características adicionales. trata comunicación directa entre los actores sistema creación objetos como parte una secuencia operacio-nes. este ejemplo, objeto del tipo summary (resumen) crea para contener los datos del resumen que deben subirse prs (patient record system, decir, sistema registro paciente). este diagrama lee siguiente manera: . recepcionista inicia sesión (log) prs. . hay dos opciones disponibles. las opciones permiten transferencia directa información actualizada del paciente prs, transferencia datos del resumen salud del mhc-pms prs. . cada caso, verifican los permisos del recepcionista usando sistema auto- rización. . información personal transfiere directamente del objeto interfaz del usuario prs. manera alternativa, posible crear registro del resumen base datos , luego, transferir dicho registro. . completar transferencia, prs emite mensaje estatus usuario ter- mina sesión (log off).: patientinfo viewinfo (pid)reportes (info, pid, uid) autorizar (info.,uid) paciente infod: mhcpms- : autorización autorización error ( hay acceso)[autorización ] [autorización falla]recepcionista médico alt figura . diagrama secuencia para “ver información del paciente” -.indd -.indd // :: // :: capítulo ■ modelado del sistema menos que use diagramas secuencia para generación código documen- tación detallada, dichos diagramas tiene que incluir todas las interacciones. desarrolla modelos iniciales sistema proceso desarrollo para apoyar ingenie-ría requerimientos diseño alto nivel, habrá muchas interacciones que dependan decisiones implementación. por ejemplo, figura ., decisión sobre cómo conseguir identificador del usuario para comprobar autorización podría demorarse. una implementación, esto implicaría interacción con objeto user (usuario), pero esto importante esta etapa , por tanto, necesita incluirse diagrama secuencia.autorizaciónautorizar (, uid): patientinfo login ( ): mhcpms- : autorización [sendinfo] [sendsummary]recepcionista médicoprs updateinfo( ) actualizar prs (uid) actualizar (pid) actualizar mensaje ()resumen (uid) autorizaciónautorizar (, uid) :summary actualizar (pid)updatesummary( ) logout ( ) actualizar mensaje ()alt figura . diagrama secuencia para transferir datos -.indd -.indd // :: // :: . ■ modelos estructurales . modelos estructurales los modelos estructurales software muestran organización sistema, tér- minos los componentes que constituyen dicho sistema sus relaciones. los modelos estructurales son modelos estáticos, que muestran estructura del diseño del sistema, modelos dinámicos, que revelan organización del sistema cuando ejecuta. son mismo: organización dinámica sistema como conjunto hilos interacción tiende ser muy diferente modelo estático componentes del sistema. los modelos estructurales sistema crean cuando discute diseña arqui-tectura del sistema. diseño arquitectónico tema particularmente importante ingeniería software, los diagramas uml componente, paquete implemen-tación utilizan cuando presentan modelos arquitectónicos. los capítulos , cubren diferentes aspectos arquitectura software del modelado arquitec-tónico. esta sección enfoca uso diagramas clase para modelar estructura estática las clases objetos, sistema software. .. diagramas clase los diagramas clase pueden usarse cuando desarrolla modelo sistema orien-tado objetos para mostrar las clases sistema las asociaciones entre dichas clases. manera holgada, una clase objeto considera como una definición general tipo objeto del sistema. una asociación vínculo entre clases, que indica que hay una relación entre dicha clases. consecuencia, cada clase puede tener algún conoci-miento esta clase asociada. cuando desarrollan modelos durante las primeras etapas del proceso ingenie-ría software, los objetos representan algo mundo real, como paciente, una receta, médico, etcétera. conforme desarrolla una implementación, por general necesitan definir los objetos implementación adicionales que usan para dar funcionalidad requerida del sistema. aquí, enfoque está sobre modelado objetos del mundo real, como parte los requerimientos los primeros procesos diseño del software. los diagramas clase uml pueden expresarse con diferentes niveles deta-lle. cuando desarrolla modelo, primera etapa con frecuencia implica buscar mundo, identificar los objetos esenciales representarlos como clases. forma más sencilla hacer esto escribir nombre clase recuadro. también puede anotar existencia una asociación dibujando simplemente una línea entre las clases. análisis requerimientos orientado objetos análisis requerimientos orientado objetos, modelan entidades del mundo real usando clases objetos. usted puede crear diferentes tipos modelos objetos, que muestren cómo relacionan mutuamente las clases objetos, cómo agregan objetos para formar otros objetos, cómo interactúan los objetos entre , etcétera. cada uno éstos presenta información única acerca del sistema que especifica. http:// -.indd -.indd // :: // :: capítulo ■ modelado del sistema por ejemplo, figura . diagrama clase simple que muestra dos clases: patient (paciente) patient record (registro del paciente), con una asociación entre ellos. figura . ilustra una característica más los diagramas clase: habi-lidad para mostrar cuántos objetos intervienen asociación. este ejemplo, cada extremo asociación registra con , cual significa que hay una relación : entre objetos dichas clases. esto , cada paciente tiene exactamente registro, cada registro conserva información precisa del paciente. los últimos ejemplos observa que son posibles otras multiplicidades. define número exacto objetos que están implicados, bien, con uso asterisco (*), como muestra figu- ., que hay número indefinido objetos asociación. figura . desarrolla este tipo diagrama clase para mostrar que los objetos clase “paciente” también intervienen relaciones con varias otras clases. este ejemplo, observa que posible nombrar las asociaciones para dar lector indicio del tipo relación que existe. asimismo, uml permite especificar papel los objetos que participan asociación. este nivel detalle, los diagramas clase parecen modelos semánticos datos. los modelos semánticos datos usan diseño bases datos. muestran las entidades datos, sus atributos asociados las relaciones entre dichas entidades. este enfoque para modelar fue propuesto por primera vez por chen (), mediados década ; desde entonces, han desarrollado diversas variantes (codd, ; hammer mcleod, ; hull king, ), todas con misma forma básica. uml incluye una notación específica para este modelado bases datos, que supone proceso desarrollo orientado objetos, así como modelos datos que usan objetos sus relaciones. sin embargo, posible usar uml para representar modelo semántico datos. modelo semántico datos, piense entidades como pacienteregistro del paciente . clases asociación uml pacientemédico cabecera consultaconsultor medicamento tratamiento médico hospitalcondiciónremitido porremitido diagnosticado con asiste prescribe prescribe corre..* ..* ..* ..* ..*..* ....* ..* ..*..* figura . clases asociaciones mhc-pms -.indd -.indd // :: // :: . ■ modelos estructurales clases objeto simplificadas ( tienen operaciones), atributos como atributos clase objeto relaciones como nombres asociaciones entre clases objeto. cuando muestran las asociaciones entre clases, conveniente representar dichas clases forma más sencilla posible. para definirlas con más detalle, agregue infor-mación sobre sus atributos (las características objeto) operaciones (aquello que puede solicitar objeto). por ejemplo, objeto patient tendrá atributo address (dirección) puede incluir una operación llamada changeaddress (cambiar dirección), que llama cuando paciente manifiesta que mudó una dirección otra. uml, los atributos las operaciones muestran extender rectángulo simple que representa una clase. esto ilustra figura ., donde: . nombre clase objeto está sección superior. . los atributos clase están sección media. esto debe incluir los nombres del atributo , opcionalmente, sus tipos. . las operaciones (llamadas métodos java otros lenguajes programación ) asociadas con clase objeto están sección inferior del rectángulo. figura . expone posibles atributos operaciones sobre clase consulta (consultation). este ejemplo, supone que los médicos registran notas voz que transcriben más tarde para registrar detalles consulta. prescribir fármacos, médico debe usar método prescribir (prescribe) para generar una receta electrónica. .. generalización generalización una técnica cotidiana que usa para gestionar complejidad. vez aprender las características detalladas cada entidad que experimenta, dichas entidades colocan clases más generales (animales, automóviles, casas, consulta médicos fechahoraclínicarazónmedicamento prescritotratamiento prescritonotas voztranscripción... nuevo ( ) prescribir ( )registronotas ( )transcribir ( ) ... figura . clase consulta -.indd -.indd // :: // :: capítulo ■ modelado del sistema etcétera) aprenden las características dichas clases. esto permite deducir que diferentes miembros estas clases tienen algunas características comunes (por ejem-plo, las ardillas ratas son roedores). posible hacer enunciados generales que apliquen todos los miembros clase (por ejemplo, todos los roedores tienen dien-tes para roer). modelado sistemas, con frecuencia útil examinar las clases sistema, con finalidad ver hay ámbito para generalización. esto significa que infor-mación común mantendrá solamente lugar. ésta una buena práctica diseño, pues significa que, proponen cambios, entonces tiene que buscar todas las clases sistema, para observar ven afectadas por cambio. los lenguajes orientados objetos, como java, generalización implementa usando los mecanis-mos herencia clase construidos lenguaje. uml tiene tipo específico asociación para denotar generalización, como ilustra figura .. generalización muestra como una flecha que apunta hacia clase más general. esto indica que los médicos cabecera los médicos hospital pueden generalizarse como médicos, que hay tres tipos médicos hospital: quienes graduaron recientemente escuela medicina tienen que ser supervi-sados (médicos practicantes); quienes trabajan sin supervisión como parte equipo consultores (médicos registrados); los consultores, que son médicos experimentados con plenas responsabilidades toma decisiones. una generalización, los atributos las operaciones asociados con las clases nivel superior también asocian con las clases nivel inferior. esencia, las cla-ses nivel inferior son subclases que heredan los atributos las operaciones sus superclases. entonces dichas clases nivel inferior agregan atributos operaciones más específicos. por ejemplo, todos los médicos tienen nombre número telefónico; todos los médicos hospital tienen número personal departamento, pero los médicos cabecera tienen tales atributos, pues trabajan manera independiente. sin embargo, tienen nombre consultorio dirección. esto ilustra figura ., que muestra parte jerarquía generalización que extendió con atributos clase. las operaciones asociadas con clase “médico” buscan registrar dar baja médico con mhc-pms.médico médico cabeceramédico hospital consultor médico equipo médico practicantemédico calificadofigura . jerarquía generalización -.indd -.indd // :: // :: . ■ modelos comportamiento .. agregación los objetos mundo real con frecuencia están compuestos por diferentes partes. paquete estudio para curso, por ejemplo, estaría compuesto por libro, diapositivas powerpoint, exámenes recomendaciones para lecturas posteriores. ocasiones, modelo sistema, usted necesita ilustrar esto. uml proporciona tipo especial asociación entre clases llamado agregación, que significa que objeto ( todo) compone otros objetos (las partes). para mostrarlo, usa trazo forma dia-mante, junto con clase que representa todo. esto ilustra figura ., que indica que registro paciente una composición paciente (patient) número indefinido consulta (consultations). . modelos comportamiento los modelos comportamiento son modelos dinámicos del sistema conforme eje-cutan. ellos muestra que sucede que supone que pasa cuando sistema responde ante estímulo entorno. tales estímulos son dos tipos: . datos algunos datos que llegan procesan por sistema. . eventos algunos eventos activan procesamiento del sistema. los eventos pueden tener datos asociados, pero esto siempre caso.médico nombre # teléfonocorreo electrónico registro ( ) dar-baja ( ) médico hospital # personal# localizadormédico general especialidaddirecciónfigura . jerarquía generalización con detalles agregados paciente registrado paciente consulta ..* figura . asociación agregación -.indd -.indd // :: // :: capítulo ■ modelado del sistema muchos sistemas empresariales son sistemas procesamiento datos que activan principalmente por datos. son controlados por entrada datos sistema con relativa-mente poco procesamiento externo eventos. procesamiento incluye una secuencia acciones sobre dichos datos generación una salida. por ejemplo, sistema facturación telefónica aceptará información las llamadas hechas por cliente, calcu-lará los costos dichas llamadas generará una factura para enviarla dicho cliente. contraste, los sistemas tiempo real muchas veces están dirigidos por evento con pro-cesamiento datos mínimo. por ejemplo, sistema conmutación telefónico terrestre responde eventos como “receptor ocupado” generar tono dial, presionar las teclas teléfono para captura del número telefónico, etcétera. .. modelado dirigido por datos los modelos dirigidos por datos muestran secuencia acciones involucradas procesamiento datos entrada, así como generación una salida asociada. son particularmente útiles durante análisis requerimientos, pues sirven para mostrar procesamiento “extremo extremo” sistema. esto , exhiben toda secuencia acciones que ocurren desde una entrada procesar hasta salida correspondiente, que respuesta del sistema. los modelos dirigidos por datos están entre los primeros modelos gráficos soft-ware. década , los métodos estructurados como análisis estructurado demarco (demarco, ) introdujeron los diagramas flujo datos (dfd), como una forma ilustrar los pasos del procesamiento sistema. los modelos flujo datos son útiles porque hecho rastrear documentar cómo los datos asociados con proceso particular mueven través del sistema ayuda los analistas diseñadores entender que sucede. los diagramas flujo datos son simples intuitivos , por general, posible explicarlos los usuarios potenciales del sistema, quienes después pueden participar validación del modelo. uml soporta diagramas flujo datos, puesto que originalmente propusie-ron usaron para modelar procesamiento datos. razón para esto que los dfd enfocan funciones del sistema reconocen objetos del sistema. sin embargo, como los sistemas dirigidos por datos son tan comunes los negocios, uml . introdujo diagramas actividad, que son similares los diagramas flujo datos. por ejemplo, figura . indica cadena procesamiento involucrada software bomba insulina. este diagrama, observan los pasos procesamiento (representados como actividades) los datos que fluyen entre dichos pasos (representados como objetos).diagramas flujo datos los diagramas flujo datos (dfd) son modelos sistema que presentan una perspectiva funcional, donde cada transformación constituye una sola función solo proceso. los dfd usan para mostrar cómo fluyen los datos través una secuencia pasos del procesamiento. por ejemplo, paso del procesamiento sería filtrado registros duplicados una base datos clientes. los datos transforman cada paso antes moverse hacia siguiente etapa. dichos pasos transformaciones del procesamiento representan procesos funciones software, los cuales los diagramas flujo datos usan para documentar diseño software. http:// -.indd -.indd // :: // :: . ■ modelos comportamiento una forma alternativa mostrar secuencia procesamiento sistema usar diagramas secuencia uml. vio cómo utilizan para modelar interacción pero, los utiliza para que dichos mensajes sólo envíen izquierda derecha, luego muestran procesamiento secuencial datos sistema. figura . ilustra esto, con modelo secuencia del procesamiento pedido envío proveedor. los modelos secuencia destacan los objetos sistema, mientras que los diagramas flujo datos resaltan las funciones. diagrama flujo datos equivalente para orden procesamiento incluye las páginas web del libro. .. modelado dirigido por evento modelado dirigido por evento muestra cómo responde sistema eventos exter-nos internos. basa suposición que sistema tiene número finito estados que los eventos (estímulos) pueden causar una transición estado otro. por ejemplo, sistema que controla una válvula puede moverse estado “vál-vula abierta” estado “válvula cerrada”, cuando recibe comando operador ( estímulo). esta visión sistema adecuado particularmente para sistema tiempo real. modelado basado eventos introdujo los métodos diseño tiem- real, como los propuestos por ward mellor () harel (, ). uml soporta modelado basado eventos usando diagramas estado, que fun-damentaron gráficos estado (harel, , ). los diagramas estado muestran estados eventos del sistema que causan transiciones estado otro. exponen :pedido llenar ( ) agente compras validar ( ) [validación ]“almacén datos” pedidospresupuesto actualizar (importe) guardar ( ) proveedor enviar ( ) figura . modelo actividad operación bomba insulinasensor glucosa sangrenivel azúcar sangre requerimiento insulinacomandos control bombabomba insulinaobtener valor sensor calcular comandos bombadatos sensorcalcular nivel azúcar calcular liberación insulina control bomba figura . orden procesamiento -.indd -.indd // :: // :: capítulo ■ modelado del sistema flujo datos dentro del sistema, pero suelen incluir información adicional acerca los cálculos realizados cada estado. usa ejemplo software control para horno microondas muy sencillo, que ilustra modelado dirigido por evento. los hornos microondas reales son mucho más complejos que este sistema, pero sistema simplificado más fácil entender. este microondas sencillo tiene interruptor para seleccionar potencia com-pleta media, teclado numérico para ingresar tiempo cocción, botón ini-ciar/detener una pantalla alfanumérica. supone que secuencia acciones usar horno microondas : . seleccionar nivel potencia ( sea media completa) . ingresar tiempo cocción con teclado numérico.. presionar “iniciar”, comida cocina durante tiempo dado. por razones seguridad, horno opera cuando puerta esté abierta , com- pletar cocción, escuchará timbre. horno tiene una pantalla alfanumérica muy sencilla que usa para mostrar varios avisos alerta mensajes advertencia. los diagramas estado uml, los rectángulos redondeados representan estados del sistema. pueden incluir una breve descripción (después “”) las acciones que tomarán dicho estado. las flechas etiquetadas representan estímulos que fuerzan una transición estado otro. puede indicar los estados inicial final usando círcu-los rellenos, como los diagramas actividad. partir figura . observa que sistema empieza estado espera , inicialmente, responde botón potencia completa botón potencia media. los operaciónpotencia completa potencia mediapotencia mediapotencia completanúmero puerta abiertapuerta cerrada puerta cerradapuerta abiertainiciar potencia media : establecer potencia = tiempo : conseguir número exit: establecer tiempo deshabilitadocancelar espera : mostrar tiempoespera : desplegar tiempopotencia completa : establecer potencia = operación : operar horno : mostrar “listo” : mostrar “espere”temporizador temporizador figura . diagrama estado horno microondas -.indd -.indd // :: // :: . ■ modelos comportamiento usuarios pueden cambiar opinión después seleccionar uno ellos oprimir otro botón. establece tiempo , puerta está cerrada, habilita botón iniciar. pre-sionar este botón comienza operación del horno tiene lugar cocción durante tiempo especificado. éste final del ciclo cocción sistema regresa estado espera. notación uml permite indicar actividad que ocurre estado. una especifi-cación detallada del sistema, hay que proporcionar más detalle tanto los estímulos como los estados del sistema. esto ilustra figura ., cual señala una descripción tabular cada estado cómo generan los estímulos que fuerzan transiciones estado. problema con modelado basado estado que número posibles estados incrementa rápidamente. por tanto, para modelos sistemas grandes, necesita ocultar estado descripción esperar horno espera entrada. pantalla indica tiempo actual. potencia media potencia del horno establece watts. pantalla muestra “potencia media”. potencia completa potencia del horno establece watts. pantalla muestra “potencia completa”. establecer tiempo tiempo cocción establece valor entrada del usuario. pantalla indica tiempo cocción seleccionado actualiza conforme establece tiempo. deshabilitado operación del horno deshabilita por cuestiones seguridad. luz interior del horno está encendida. pantalla indica “ está listo”. habilitado habilita operación del horno. luz interior del horno está apagada. pantalla muestra “listo para cocinar”. operación horno operación. luz interior del horno está encendida. pantalla muestra cuenta descendente del temporizador. completar cocción, suena timbre durante cinco segundos. luz del horno está encendida. pantalla muestra “cocción completa” mientras suena timbre. estímulo descripción potencia media usuario oprime botón potencia media. potencia completa usuario oprime botón potencia completa.temporizador usuario oprime uno los botones del temporizador.número usuario oprime una tecla numérica. puerta abierta interruptor puerta del horno está cerrado.puerta cerrada interruptor puerta del horno está cerrado.iniciar usuario oprime botón iniciar. cancelar usuario oprime botón cancelar.figura . estados estímulos para horno microondas -.indd -.indd // :: // :: capítulo ■ modelado del sistema detalles los modelos. una forma hacer esto mediante noción superestado que encapsule algunos estados separados. este superestado parece solo estado modelo nivel superior, pero entonces expande para mostrar más detalles diagrama separado. para ilustrar este concepto, considere estado operación figura .. éste superestado que puede expandirse, como ilustra figura .. estado operación incluye algunos subestados. muestra que operación comienza con una comprobación estatus que, descubren problemas, indica una alarma operación deshabilita. cocción implica operar generador microondas durante tiempo especificado; terminar, suena timbre. puerta está abierta durante operación, sistema mueve hacia estado deshabilitado, como muestra figura .. . ingeniería dirigida por modelo ingeniería dirigida por modelo (mde, por las siglas model-driven engineering) enfoque desarrollo software donde los modelos, los programas, son las sali-das principales del proceso desarrollo (kent, ; schmidt, ). los programas que ejecutan una plataforma hardware/software generan tal caso automáti-camente partir los modelos. los partidarios mde argumentan que ésta eleva nivel abstracción ingeniería software, pues los ingenieros tienen que preocuparse por detalles del lenguaje programación las especificidades las plata-formas ejecución. ingeniería dirigida por modelo tiene sus raíces arquitectura dirigida por modelo (mda, por las siglas model-driven architecture), que fue propuesta por object management group (omg) como nuevo paradigma desarrollo software. ingeniería dirigida por modelo arquitectura dirigida por modelo falla tornamesafalla emisorpausacocinar : correr generador hecho : timbre seg esperaalarma : mostrar eventodo: comprobar estatuscomprobación deshabilitadooktiempo puerta abiertaoperación cancelar figura . operación del horno microondas -.indd -.indd // :: // :: . ■ ingeniería dirigida por modelo ven normalmente iguales. sin embargo, considera que mde tiene ámbito más amplio que mda. como estudia más adelante esta sección, mda enfoca las etapas diseño implementación del desarrollo software, mientras que mde interesa por todos los aspectos del proceso ingeniería software. por tanto, los temas como ingeniería requerimientos basada modelo, procesos software para desarrollo basado modelo, pruebas basadas modelo son parte mde, pero , este momento, mda. aunque mda usa desde , ingeniería basada modelo aún está una etapa temprana desarrollo, claro tendrá efecto significativo sobre práctica ingeniería software. los principales argumentos favor contra mde son: . favor mde ingeniería basada modelo permite los ingenieros pen- sar sobre sistemas nivel abstracción elevado, sin ocuparse por los deta-lles implementación. esto reduce probabilidad errores, acelera diseño proceso implementación, permite creación modelos aplicación reutilizables, independientes plataforma aplicación. usar herramientas poderosas, las implementaciones sistema pueden generarse para diferentes pla-taformas partir del mismo modelo. consecuencia, para adaptar sistema alguna nueva plataforma tecnológica, sólo necesario escribir traductor para dicha plataforma. cuando está disponible, todos los modelos independientes pla-taforma pueden reubicarse rápidamente nueva plataforma. . contra mde como analizó anteriormente este capítulo, los modelos son una buena forma facilitar las discusiones sobre diseño software. sin embargo, siempre sigue que las abstracciones que soporta modelo son las abstrac-ciones correctas para implementación. este modo, posible crear modelos diseño informal, pero siendo así, sistema implementa usando paquete configurable comercial (off-the-shelf). más aún, los argumentos para independen-cia plataforma sólo son válidos para sistemas grandes larga duración, donde las plataformas vuelven obsoletas durante tiempo vida sistema. sin embargo, para esta clase sistemas, sabe que implementación princi-pal problema: ingeniería requerimientos, seguridad confiabilidad, integración con sistemas heredados, las pruebas son más significativos. omg reporta sus páginas web ( his-torias éxito reveladoras mde enfoque utilizado dentro grandes compa-ñías como ibm siemens. las técnicas usaron con éxito desarrollo grandes sistemas software larga duración, como sistemas manejo tráfico aéreo. obstante, momento escribir este texto, los enfoques dirigidos por modelo son ampliamente usados por ingeniería software. como los métodos formales inge-niería software, que estudian capítulo , considera que mde impor-tante desarrollo. pero, como también caso con los métodos formales, claro los costos riesgos los enfoques dirigidos por modelo superan los posibles beneficios. .. arquitectura dirigida por modelo arquitectura dirigida por modelo (kleppe ., ; mellor ., ; stahl voelter, ) enfoque orientado modelos para diseño implementación software, que usa subconjunto modelos uml para describir sistema. aquí, -.indd -.indd // :: // :: capítulo ■ modelado del sistema crean modelos diferentes niveles abstracción. partir modelo independiente plataforma alto nivel, posible, principio, generar programa funcional sin intervención manual. método mda recomienda producción tres tipos modelo sistema abstracto: . modelo independiente computación (cim) que modela las importantes abs- tracciones dominio usadas sistema. ocasiones, los cim llaman mode- los dominio. posible desarrollar varios cim diferentes, que reflejen distintas percepciones del sistema. por ejemplo, puede haber cim seguridad, cual identifiquen abstracciones seguridad importantes, como cim activo, rol registro del paciente, que describan abstracciones como pacientes, consul-tas, etcétera. . modelo independiente plataforma (pim) que modele operación del sistema sin referencia implementación. pim describe usualmente mediante mode-los uml que muestran estructura estática del sistema cómo responde eventos externos internos. . modelos específicos plataforma (psm) que son transformaciones del modelo independiente plataforma con psm separado para cada plataforma apli-cación. principio, puede haber capas psm, cada una agrega cierto detalle específico plataforma. este modo, psm primer nivel podría ser específi- “middleware”, pero independiente base datos. cuando elige una base datos específica, podría generarse entonces psm específico base datos. como vimos, las transformaciones entre dichos modelos pueden definirse apli-carse automáticamente con herramientas software. esto ilustra figura ., que también muestra nivel final transformación automática. una transformación aplica psm para generar código ejecutable que opere plataforma soft-ware designada. momento escribir este texto, traducción automática cim pim todavía está etapa investigación prototipo. improbable que futuro cercano estén disponibles herramientas traducción completamente automatizadas. para futuro modelo específico plataformamodelo independiente plataformacódigo ejecutable traductor traductor traductor lineamientos específicos dominiopatrones reglas específicos plataformapatrones específicos lenguajemodelo independiente computación figura . trans- formaciones mda -.indd -.indd // :: // :: . ■ ingeniería dirigida por modelo previsible necesitará intervención humana, que indica mediante una figura ilustrativa figura .. los cim relacionan, parte del proceso traducción puede involucrar conceptos vinculación diferentes cim. por ejemplo, concepto papel cim seguridad que puede trazarse dentro del concepto miem-bro personal cim hospital. mellor balcer () dan nombre “puen-tes” información que soporta mapeo cim otro. traducción pim psm más madura dispone varias herramientas comerciales que proporcionan traductores pim plataformas comunes como java . éstas apoyan una extensa librería reglas patrones específicos pla-taforma para convertir pim psm. puede haber muchos psm para cada pim sistema. tiene intención que sistema software funcione diferentes plataformas (por ejemplo .net), entonces sólo necesario mantener pim. los psm para cada plataforma generan automáticamente. esto ilustra figura .. aunque las herramientas soporte mda incluyen traductores específicos pla-taforma, frecuente caso que sólo ofrezcan soporte parcial para traducción pim psm. gran mayoría los casos, entorno ejecución para sistema más que plataforma ejecución estándar (por ejemplo, , .net, etcétera). también incluye otros sistemas aplicación, librerías aplicación que son específicas una compañía librerías interfaz usuario. como éstas varían significativamente una compañía otra, está disponible soporte estándar para herramientas. por tanto, cuando introduce mda, quizá deban crearse traductores propósito especial que tomen cuenta las características del entorno local. algunos casos (por ejemplo, para generación interfaz usuario), traducción pim psm completamente automatizada imposible. existe una relación difícil entre métodos ágiles arquitectura dirigida por modelo. noción modelado frontal extenso contradice las ideas fundamentales del manifiesto ágil conjetura que pocos desarrolladores ágiles sienten cómodos con ingeniería dirigida por modelo. los desarrolladores mad afirman que tiene intención apoyar enfoque iterativo para desarrollo , por tanto, puede usarse dentro los métodos ágiles (mellor ., ). las transformaciones pueden automatizarse com-pletamente partir pim genera programa completo, entonces, principio, mda podría usarse proceso desarrollo ágil, que requeriría codificación separada. sin embargo, hasta donde sabe, hay herramientas mda que soporten prácticas como las pruebas regresión desarrollo dirigido por pruebas.modelo independiente plataformaprograma java generador código #generador código javatraductor traductor .net programa #modelo específico modelo específico .netfigura . múltiples modelos específicos plataforma -.indd -.indd // :: // :: capítulo ■ modelado del sistema .. uml ejecutable noción fundamental detrás ingeniería dirigida por modelo que debe ser posible transformación completamente automatizada modelos código. para lograr esto, usted tiene que ser capaz construir modelos gráficos, cuya semántica esté bien defi-nida. también necesita una forma agregar los modelos gráficos, información sobre forma que implementan las operaciones definidas modelo. esto posible usando subconjunto uml llamado uml ejecutable xuml (mellor balcer, ). aquí hay espacio para describir los detalles del xuml, así que simplemente presentará breve panorama sus principales características. uml desarrolló como lenguaje para soportar documentar diseño soft-ware, como lenguaje programación. los diseñadores del uml estaban pre-ocupados por los detalles semánticos del lenguaje, sino con expresividad. introdujeron nociones útiles como los diagramas caso uso, que ayudan con diseño, pero que son demasiado informales para soportar ejecución. por ende, para crear subcon-junto ejecutable uml, número tipos modelo redujo drásticamente tres tipos modelo clave: . modelos dominio que identifican las principales preocupaciones sistema. definen usando diagramas clase uml que incluyen objetos, atributos asocia- ciones. . modelos clase, los que definen clases, junto con sus atributos operaciones. . modelos estado, los que diagrama estado asocia con cada clase usa para describir ciclo vida clase. comportamiento dinámico del sistema puede especificarse manera declarativa usando lenguaje restricción objeto (ocl) puede expresarse mediante len-guaje acción uml. lenguaje acción como lenguaje programación muy alto nivel, donde posible referirse los objetos sus atributos, así como especifi-car acciones realizar. puntos clave ■ modelo una visión abstracta sistema que ignora algunos detalles del sistema. pueden desarrollarse modelos complementarios del sistema para mostrar contexto, las interacciones, estructura comportamiento del sistema. ■ los modelos contexto muestran cómo sistema modelar coloca entorno con otros sistemas procesos. ayudan definir las fronteras del sistema desarrollar. ■ los diagramas caso uso los diagramas secuencia emplean para describir las interacciones entre usuario/sistema diseñar usuarios/otros sistemas. los casos uso describen interacciones entre sistema actores externos; los diagramas secuencia agregan más información éstos mostrar las interacciones entre objetos del sistema. -.indd -.indd // :: // :: pmcapítulo ■ ejercicios ■ los modelos estructurales indican organización arquitectura sistema. los diagramas clase usan para definir estructura estática clases sistema sus asociaciones. ■ los modelos del comportamiento usan para describir conducta dinámica sistema ejecución. pueden modelarse desde perspectiva los datos procesados por sistema, mediante los eventos que estimulan respuestas sistema. ■ los diagramas actividad utilizan para modelar procesamiento datos, que cada actividad representa paso del proceso. ■ los diagramas estado utilizan para modelar comportamiento sistema respuesta eventos internos externos. ■ ingeniería dirigida por modelo enfoque desarrollo del software donde sistema representa como conjunto modelos que pueden transformarse automáticamente código ejecutable. lecturas sugeridas requirements analysis and system design. este libro enfoca análisis sistemas información examina cómo pueden usarse diferentes modelos uml proceso análisis. (. maciaszek, addison-wesley, .) mda distilled: principles model-driven architecture. trata una introducción concisa accesible método mda. está escrito por autores entusiastas, modo que con este enfoque libro dice muy poco acerca posibles problemas. (. . mellor, . scott . weise, addison-wesley, .) using uml: software engineering with objects and components, . una breve introducción legible uso del uml especificación diseño sistemas. éste excelente libro para comprender uml, aunque tiene una descripción completa notación. (. stevens con . pooley, addison-wesley, .) ejercicios .. explique por qué importante modelar contexto sistema que desarrollará. mencione dos ejemplos posibles errores que surgirían los ingenieros software entienden contexto del sistema. .. ¿cómo podría usar modelo sistema que existe? explique por qué siempre necesario que modelo sistema esté completo sea correcto. ¿ mismo sería cierto estuviera desarrollando modelo sistema nuevo? -.indd -.indd // :: // :: capítulo ■ modelado del sistema .. pide desarrollar sistema que ayudará con planeación eventos fiestas gran escala, como bodas, fiestas graduación, cumpleaños, etcétera. con diagrama actividad, modele contexto del proceso para tal sistema, que muestre las actividades que hay planeación una fiesta (reservación local, organización invitaciones, más) los elementos del sistema que tengan que usar cada etapa. .. para mhc-pms, proponga conjunto casos uso que ilustren las interacciones entre médico, que atiende pacientes prescribe medicamentos tratamientos, mhc-pms. .. desarrolle diagrama secuencia que muestre las interacciones que hay cuando estudiante registra para curso una universidad. los cursos pueden tener matrícula limitada, modo que proceso registro debe incluir comprobación qué lugares están disponibles. suponga que estudiante accede catálogo electrónico cursos para encontrar los cursos disponibles. .. busque cuidadosamente cómo representan los mensajes buzones sistema correo electrónico que utilice. modele las clases objetos que puedan usarse implementación del sistema para representar buzón mensaje correo electrónico. .. con base experiencia con cajero automático (atm), dibuje diagrama actividad que modele procesamiento datos cuando cliente retira dinero máquina. .. dibuje diagrama secuencia para mismo sistema. explique por qué debe desarrollar tanto diagramas actividad como secuencia, cuando modela comportamiento sistema. .. dibuje diagramas estado del software control para: ■ una lavadora automática con diferentes programas para distintos tipos ropa. ■ software para reproductor dvd. ■ una contestadora telefónica que registre los mensajes entrantes muestre número mensajes aceptados display leds. sistema debe permitir usuario del teléfono marcar desde cualquier ubicación, escribir una secuencia números (identificados como tonos) reproducir cualquier mensaje grabado. .. usted administrador ingeniería software equipo propone que debe usarse ingeniería dirigida por modelo para desarrollar sistema nuevo. ¿qué factores debe tomar cuenta cuando decide introducir este nuevo enfoque desarrollo software? -.indd -.indd // :: // :: pmcapítulo ■ referencias referencias ambler, . . jeffries, . (). agile modeling: effective practices for extreme programming and the unified process. new york: john wiley & sons. booch, ., rumbaugh, . jacobson, . (). the unified modeling language user guide, . boston: addison-wesley. chen, . (). “the entity relationship model—towards unified view data”. acm trans. database systems, (), –.codd, . . (). “extending the database relational model capture more meaning”. acm trans. database systems, (), –.demarco, . (). structured analysis and system specification. new york: yourdon press.erickson, . siau, . (). “theoretical and practical complexity modeling methods”. comm. acm, (), –.hammer, . mcleod, . (). “database descriptions with sdm: semantic database model”. acm trans. database sys., (), –. harel, . (). “statecharts: visual formalism for complex systems”. sci. comput. programming, (), –.harel, . (). “ visual formalisms”. comm. acm, (), –.hull, . king, . (). “semantic database modeling: survey, applications and research issues”. acm computing surveys, (), –. jacobson, ., christerson, ., jonsson, . overgaard, . (). object-oriented software engineering. wokingham.: addison-wesley.kent, . (). “model-driven engineering”. proc. int. conf. integrated formal methods, –. kleppe, ., warmer, . bast, . (). mda explained: the model driven architecture—practice and promise. boston: addison-wesley. kruchten, . (). “the + view model architecture”. ieee software, (), –. mellor, . . balcer, . . (). executable uml. boston: addison-wesley.mellor, . ., scott, . weise, . (). mda distilled: principles model-driven architecture. boston: addison-wesley.rumbaugh, ., jacobson, . booch, . (). the unified modeling language reference manual. reading, mass.: addison-wesley. -.indd -.indd // :: // :: capítulo ■ modelado del sistema rumbaugh, ., jacobson, . booch, . (). the unified modeling language reference manual, . boston: addison-wesley. schmidt, . . (). “model-driven engineering”. ieee computer, (), –.stahl, . voelter, . (). model-driven software development: technology, engineering, management. new york: john wiley & sons. ward, . mellor, . (). structured development for real-time systems. englewood cliffs, : prentice hall. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducir los conceptos arquitectura software diseño arquitectónico. estudiar este capítulo: ■ comprenderá por qué importante diseño arquitectónico del software; ■ conocerá las decisiones que deben tomarse sobre arquitectura software durante proceso diseño arquitectónico; ■ asimilará idea los patrones arquitectónicos, formas bien reconocidas organización las arquitecturas del sistema, que pueden reutilizarse los diseños del sistema; ■ identificará los patrones arquitectónicos usados frecuentemente diferentes tipos sistemas aplicación, incluidos los sistemas procesamiento transacción los sistemas procesamiento lenguaje. contenido . decisiones diseño arquitectónico . vistas arquitectónicas. patrones arquitectónicos. arquitecturas aplicación diseño arquitectónico -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico diseño arquitectónico interesa por entender cómo debe organizarse sistema cómo tiene que diseñarse estructura global ese sistema. modelo del proceso desarrollo software, como mostró capítulo , diseño arquitectónico primera etapa proceso diseño del software. enlace crucial entre diseño ingeniería requerimientos, que identifica los principales componentes estructura-les sistema relación entre ellos. salida del proceso diseño arquitectónico consiste modelo arquitectónico que describe forma que organiza sistema como conjunto componentes comunicación. los procesos ágiles, por general acepta que una las primeras etapas proceso desarrollo debe preocuparse por establecer una arquitectura global del sis-tema. usualmente resulta exitoso desarrollo incremental arquitecturas. mientras que refactorización componentes respuesta los cambios suele ser relativamente fácil, tal vez resulte costoso refactorizar una arquitectura sistema. para ayudar comprender que entiende por arquitectura del sistema, tome cuenta figura .. ella presenta modelo abstracto arquitectura para sistema robot empaquetado, que indica los componentes que tienen que desarro-llarse. este sistema robótico empaca diferentes clases objetos. usa componente visión para recoger los objetos una banda transportadora, identifica clase objeto selecciona tipo correcto empaque. luego, sistema mueve los objetos que empacar banda transportadora entrega coloca los objetos empacados otro transportador. modelo arquitectónico presenta dichos componentes los vínculos entre ellos. práctica, hay significativo traslape entre los procesos ingeniería reque-rimientos diseño arquitectónico. manera ideal, una especificación sistema debe incluir cierta información diseño. esto realista, excepto para sistemas muy pequeños. descomposición arquitectónica por general necesaria para estructurar organizar especificación. por tanto, como parte del proceso ingeniería reque-rimientos, usted podría proponer una arquitectura sistema abstracta donde asocien grupos funciones sistemas características con componentes subsistemas gran escala. luego, puede usar esta descomposición para discutir con los participantes sobre los requerimientos las características del sistema. las arquitecturas software diseñan dos niveles abstracción, que este texto llaman arquitectura pequeño arquitectura grande: . arquitectura pequeño interesa por arquitectura programas individua- les. este nivel, uno preocupa por forma que programa individual separa componentes. este capítulo centra principalmente arquitecturas programa. . arquitectura grande interesa por arquitectura sistemas empresaria- les complejos que incluyen otros sistemas, programas componentes programa. tales sistemas empresariales distribuyen través diferentes computadoras, que diferentes compañías administran poseen. los capítulos cubren las arquitecturas grandes; ellos estudiarán las arquitecturas los sistemas distribuidos. -.indd -.indd // :: // :: pmcapítulo ■ diseño arquitectónico arquitectura software importante porque afecta desempeño potencia, así como capacidad distribución mantenimiento sistema (bosch, ). como afirma bosch, los componentes individuales implementan los requerimientos funcionales del sistema. los requerimientos funcionales dependen arquitectura del sistema, decir, forma que dichos componentes organizan comunican. muchos sis-temas, los requerimientos funcionales están también influidos por componentes indivi-duales, pero hay duda que arquitectura del sistema influencia dominante. bass sus colaboradores () analizan tres ventajas diseñar documentar manera explícita arquitectura software: . comunicación con los participantes arquitectura una presentación alto nivel del sistema, que puede usarse como enfoque para discusión amplio número participantes. . análisis del sistema una etapa temprana desarrollo del sistema, aclarar arquitectura del sistema requiere cierto análisis. las decisiones diseño arquitectó-nico tienen efecto profundo sobre sistema puede cubrir requerimientos críticos como rendimiento, fiabilidad mantenibilidad. . reutilización gran escala modelo una arquitectura sistema una des-cripción corta manejable cómo organiza sistema cómo interoperan sus componentes. por general, arquitectura del sistema misma para sistemas con requerimientos similares , por tanto, puede soportar reutilización software gran escala. como explica capítulo , posible desarrollar arquitecturas línea productos donde misma arquitectura reutilice mediante una amplia gama sistemas relacionados.sistema visión sistema identificación objetoscontrolador brazocontrolador sujetador sistema selección empaque sistema empacadocontrolador transportadorafigura . arquitectura sistema control para robot empacador -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico hofmeister sus colaboradores () proponen que una arquitectura software sirve primer lugar como plan diseño para negociación requerimientos sistema , segundo lugar, como medio para establecer discusiones con clientes, desarrolladores administradores. también sugieren que una herramienta esencial para administración complejidad. oculta los detalles permite los diseñadores enfocarse las abstracciones clave del sistema. las arquitecturas sistemas modelan con frecuencia usando diagramas blo-ques simples, como figura .. cada recuadro diagrama representa com-ponente. los recuadros dentro recuadros indican que componente dividió subcomponentes. las flechas significan que los datos / señales control pasan componente otro dirección las flechas. hay varios ejemplos este tipo modelo arquitectónico catálogo arquitectura software booch (booch, ). los diagramas bloque presentan una imagen alto nivel estructura del sis-tema incluyen fácilmente individuos diferentes disciplinas que intervienen proceso desarrollo del sistema. obstante amplio uso, bass sus colaboradores () están acuerdo con los diagramas bloque informales para describir una arquitectura. afirman que tales diagramas informales son representaciones arquitectó-nicas deficientes, pues muestran tipo relaciones entre los componentes del sistema las propiedades externamente visibles los componentes. las aparentes contradicciones entre práctica teoría arquitectónica surgen porque hay dos formas que utiliza modelo arquitectónico programa: . como una forma facilitar discusión acerca del diseño del sistema una visión arquitectónica alto nivel sistema útil para comunicación con los parti-cipantes sistema planeación del proyecto, que satura con detalles. los participantes pueden relacionarse con entender una visión abstracta del sis-tema. tal caso, analizan sistema como todo sin confundirse por los detalles. modelo arquitectónico identifica los componentes clave que desarrollarán, modo que los administradores pueden asignar individuos para planear desarrollo dichos sistemas. . como una forma documentar una arquitectura que haya diseñado meta aquí producir modelo sistema completo que muestre los diferentes com-ponentes sistema, sus interfaces conexiones. argumento para esto que tal descripción arquitectónica detallada facilita comprensión evolución del sistema. los diagramas bloque son una forma adecuada para describir arquitectura del sistema durante proceso diseño, pues son una buena manera soportar las comu-nicaciones entre las personas involucradas proceso. muchos proyectos, suele ser única documentación arquitectónica que existe. sin embargo, arquitectura sistema debe documentarse ampliamente, entonces mejor usar una notación con semántica bien definida para descripción arquitectónica. obstante, tal como estu-dia sección ., algunas personas consideran que documentación detallada útil vale realmente pena costo desarrollo. -.indd -.indd // :: // :: . ■ decisiones diseño arquitectónico . decisiones diseño arquitectónico diseño arquitectónico proceso creativo cual diseña una organización del sistema que cubrirá los requerimientos funcionales funcionales éste. puesto que trata proceso creativo, las actividades dentro del proceso dependen del tipo sistema que desarrollar, los antecedentes experiencia del arquitecto del sistema, así como los requerimientos específicos del sistema. por tanto, útil pensar diseño arquitectónico como conjunto decisiones tomar vez una secuencia actividades. durante proceso diseño arquitectónico, los arquitectos del sistema deben tomar algunas decisiones estructurales que afectarán profundamente sistema proceso desarrollo. con base conocimiento experiencia, deben considerar las siguientes preguntas fundamentales sobre sistema: . ¿existe alguna arquitectura aplicación genérica que actúe como plantilla para sistema que está diseñando? . ¿cómo distribuirá sistema través algunos núcleos procesadores? . ¿qué patrones estilos arquitectónicos pueden usarse?. ¿cuál será enfoque fundamental usado para estructurar sistema?. ¿cómo los componentes estructurales sistema separarán subcomponentes?. ¿qué estrategia usará para controlar operación los componentes sistema? . ¿cuál organización arquitectónica mejor para entregar los requerimientos fun- cionales del sistema? . ¿cómo evaluará diseño arquitectónico?. ¿cómo documentará arquitectura del sistema? aunque cada sistema software único, los sistemas mismo dominio apli- cación tienen normalmente arquitecturas similares que reflejan los conceptos fundamen-tales del dominio. por ejemplo, las líneas producto aplicación son aplicaciones que construyen torno una arquitectura central con variantes que cubren requerimien-tos específicos del cliente. cuando diseña una arquitectura sistema, debe decidirse qué tienen común sistema las clases aplicación más amplias, con finalidad determinar cuánto conocimiento puede reutilizar dichas arquitecturas aplicación. sección . estudian las arquitecturas aplicación genéricas capítulo las líneas producto aplicación. para sistemas embebidos sistemas diseñados para computadoras personales, por general, hay solo procesador tendrá que diseñar una arquitectura distribuida para sistema. sin embargo, los sistemas más grandes ahora son sistemas distribuidos donde software sistema distribuye través muchas diferentes computadoras. elec-ción arquitectura distribución una decisión clave que afecta rendimiento -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico fiabilidad del sistema. éste tema importante por derecho propio trata por separado capítulo . arquitectura sistema software puede basarse patrón estilo arqui-tectónico particular. patrón arquitectónico una descripción una organización del sistema (garlan shaw, ), tal como una organización cliente-servidor una arquitec-tura por capas. los patrones arquitectónicos captan esencia una arquitectura que usó diferentes sistemas software. usted tiene que conocer tanto los patrones comunes, que éstos usen, como sus fortalezas debilidades cuando tomen decisiones sobre arquitectura sistema. sección . analizan algunos patrones uso frecuente. noción estilo arquitectónico garlan shaw (estilo patrón llegaron significar mismo) cubre las preguntas lista anterior. necesario elegir estructura más adecuada, como cliente-servidor estructura capas, que permita satisfacer los requerimientos del sistema. para descomponer las unidades del sistema estructural, usted opta por estrategia separar los componentes subcomponen-tes. los enfoques que pueden usarse permiten implementación diferentes tipos arquitectura. finalmente, proceso modelado control, toman decisiones sobre cómo controla ejecución componentes. desarrolla modelo general las relaciones control entre las diferentes partes del sistema. debido estrecha relación entre los requerimientos funcionales arquitectura software, estilo estructura arquitectónicos particulares que elijan para sistema dependerán los requerimientos sistema funcionales: . rendimiento rendimiento requerimiento crítico, arquitectura debe diseñarse para localizar operaciones críticas dentro pequeño número com-ponentes, con todos estos componentes desplegados misma computadora vez distribuirlos por red. esto significaría usar algunos componentes relativamente grandes, vez pequeños componentes grano fino, cual reduce número comunicaciones entre componentes. también puede considerar organizacio-nes del sistema tiempo operación que permitan éste ser replicable ejecutable diferentes procesadores. . seguridad seguridad requerimiento crítico, será necesario usar una estructura capas para arquitectura, con los activos más críticos protegidos las capas más internas, con alto nivel validación seguridad aplicado dichas capas. . protección protección requerimiento crítico, arquitectura debe dise-ñarse modo que las operaciones relacionadas con protección ubiquen algún componente individual pequeño número componentes. esto reduce los costos problemas validación protección, hace posible ofrecer sistemas protección relacionados que, caso falla, desactiven con seguridad sistema. . disponibilidad disponibilidad requerimiento crítico, arquitectura tiene que diseñarse para incluir componentes redundantes manera que sea posible sus-tituir actualizar componentes sin detener sistema. capítulo describen dos arquitecturas sistema tolerantes fallas sistemas alta disponibilidad. . mantenibilidad mantenibilidad requerimiento crítico, arquitectura del sistema debe diseñarse usando componentes autocontenidos grano fino que -.indd -.indd // :: // :: . ■ vistas arquitectónicas puedan cambiarse con facilidad. los productores datos tienen que separarse los consumidores hay que evitar compartir las estructuras datos. evidentemente, hay conflicto potencial entre algunas estas arquitecturas. por ejemplo, usar componentes grandes mejora rendimiento, utilizar componentes pequeños grano fino aumenta mantenibilidad. tanto rendimiento como man-tenibilidad son requerimientos importantes del sistema, entonces debe encontrarse algún compromiso. esto ocasiones logra usando diferentes patrones estilos arquitectó-nicos para distintas partes del sistema. evaluar diseño arquitectónico difícil porque verdadera prueba una arqui-tectura qué tan bien sistema cubre sus requerimientos funcionales funcionales cuando está uso. sin embargo, posible hacer cierta evaluación comparar diseño contra arquitecturas referencia patrones arquitectónicos genéricos. para ayudar con evaluación arquitectónica, también puede usarse descripción bosch () las características funcionales los patrones arquitectónicos. . vistas arquitectónicas introducción este capítulo explicó que los modelos arquitectónicos sistema software sirven para enfocar discusión sobre los requerimientos diseño del soft-ware. manera alternativa, pueden emplearse para documentar diseño, modo que usen como base diseño implementación más detallados, así como evo-lución futura del sistema. esta sección estudian dos temas que son relevantes para ambos: . ¿qué vistas perspectivas son útiles diseñar documentar una arquitectura del sistema? . ¿qué notaciones deben usarse para describir modelos arquitectónicos? imposible representar toda información relevante sobre arquitectura sistema solo modelo arquitectónico, que cada uno presenta únicamente una vista perspectiva del sistema. ésta puede mostrar cómo sistema descompone módulos, cómo interactúan los procesos tiempo operación las diferentes formas que los componentes del sistema distribuyen través una red. todo ello útil diferentes momentos manera que, para diseño documentación, por general necesita presentar múltiples vistas arquitectura software. existen diferentes opiniones relativas qué vistas requieren. krutchen (), bien conocido modelo vista + arquitectura software, sugiere que deben existir cuatro vistas arquitectónicas fundamentales, que relacionan usando casos uso escenarios. las vistas que sugiere son: . una vista lógica, que indique las abstracciones clave sistema como objetos clases objeto. este tipo vista tienen que relacionar los requerimientos del sistema con entidades. -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico . una vista proceso, que muestre cómo, tiempo operación, sistema está compuesto procesos interacción. esta vista útil para hacer juicios acerca las características funcionales del sistema, como rendimiento disponibilidad. . una vista desarrollo, que muestre cómo software está descompuesto para desarrollo, esto , indica descomposición del software elementos que implementen mediante solo desarrollador equipo desarrollo. esta vista útil para administradores programadores software. . una vista física, que exponga hardware del sistema cómo los componentes software distribuyen través los procesadores sistema. esta vista útil para los ingenieros sistemas que planean una implementación sistema. hofmeister sus colaboradores () sugieren uso vistas similares, pero éstas agregan noción vista conceptual. esta última una vista abstracta del sistema que puede ser base para descomponer los requerimientos alto nivel especificaciones más detalladas, ayudar los ingenieros tomar decisiones sobre componentes que pue-dan reutilizarse, representar una línea producto (que estudia capítulo ) vez solo sistema. figura ., que describe arquitectura robot empa-cado, ejemplo una vista conceptual del sistema. práctica, las vistas conceptuales casi siempre desarrollan durante proceso diseño usan para apoyar toma decisiones arquitectónicas. son una forma comunicar diferentes participantes esencia sistema. durante proceso diseño, también pueden desarrollarse algunas las otras vistas, tiempo que discuten dife-rentes aspectos del sistema, aunque haya necesidad una descripción completa desde todas las perspectivas. además podrían asociar patrones arquitectónicos, estudiados siguiente sección, con las diferentes vistas sistema. hay diferentes opiniones respecto los arquitectos software deben usar uml para una descripción arquitectónica (clements ., ). estudio (lange ., ) demostró que, cuando usa uml, aplica principalmente una forma holgada informal. los autores dicho ensayo argumentan que esto era incorrecto. autor está acuerdo con esta visión. uml diseñó para describir sistemas orientados objetos , etapa diseño arquitectónico, uno quiere describir con fre-cuencia sistemas nivel superior abstracción. las clases objetos están muy cerca implementación, como para ser útiles descripción arquitectónica. para autor, uml útil durante proceso diseño prefiere nota-ciones informales que sean más rápidas escribir puedan dibujarse fácilmente pizarrón. uml más valor cuando documenta una arquitectura detalle usa desarrollo dirigido por modelo, como estudió capítulo . algunos investigadores proponen uso lenguajes descripción arquitectónica (adl, por las siglas architectural description languages) más especializados (bass ., ) para describir arquitecturas del sistema. los elementos básicos los adl son componentes conectores, incluyen reglas lineamientos para arquitecturas bien formadas. sin embargo, debido naturaleza especializada, los expertos dominio aplicación tienen dificultad para entender usar los adl. esto dificulta valora-ción utilidad para ingeniería práctica del software. los adl diseñados para dominio particular (por ejemplo, sistemas automotores) pueden usarse como una base -.indd -.indd // :: // :: . ■ patrones arquitectónicos para desarrollo dirigido por modelo. sin embargo, considera que los modelos las notaciones informales, como uml, seguirán siendo las formas uso más común para documentar las arquitecturas del sistema. los usuarios métodos ágiles afirman que, por general, utiliza docu-mentación detallada del diseño. por tanto, desarrollarla desperdicio tiempo dinero. autor está gran medida acuerdo con esta visión considera que, para mayoría los sistemas, vale pena desarrollar una descripción arquitectónica detallada desde estas cuatro perspectivas. uno debe desarrollar las vistas que sean útiles para comunicación sin preocuparse documentación arquitectónica está completa . sin embargo, una excepción desarrollar sistemas críticos, cuando necesario realizar análisis confiabilidad detallado del sistema. tal vez deba convencer reguladores externos que sistema hizo conforme sus regulaciones , conse-cuencia, puede requerirse una documentación arquitectónica completa. . patrones arquitectónicos idea los patrones como una forma presentar, compartir reutilizar conoci-miento sobre los sistemas software usa ahora ampliamente. origen esto fue publicación libro acerca patrones diseño orientados objetos (gamma ., ), que incitó desarrollo otros tipos patrón, como los patrones para diseño organizacional (coplien harrison, ), patrones usabilidad (usability group, ), interacción (martin sommerville, ), administración configuración nombre mvc (modelo vista del controlador) descripción separa presentación interacción los datos del sistema. sistema estructura tres componentes lógicos que interactúan entre . componente modelo maneja los datos del sistema las operaciones asociadas esos datos. componente vista define gestiona cómo presentan los datos usuario. componente controlador dirige interacción del usuario (por ejemplo, teclas oprimidas, clics del mouse, etcétera) pasa estas interacciones vista modelo. véase figura .. ejemplo figura . muestra arquitectura sistema aplicación basado web, que organiza con uso del patrón mvc. cuándo usa usa cuando existen múltiples formas ver interactuar con los datos. también utiliza desconocerse los requerimientos futuros para interacción presentación. ventajas permite que los datos cambien manera independiente representación viceversa. soporta diferentes formas presentación los mismos datos, los cambios una representación muestran todos ellos. desventajas puede implicar código adicional complejidad código cuando modelo datos las interacciones son simples. figura . patrón modelo vista del controlador (mvc) -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico (berczuk appleton, ), etcétera. los patrones arquitectónicos propusieron década , con nombre “estilos arquitectónicos” (shaw garlan, ), una serie cinco volúmenes manuales sobre arquitectura software orientada patrones, publicados entre (buschmann ., ; buschmann ., ; buschmann ., ; kircher jain, ; schmidt ., ). esta sección introducen los patrones arquitectónicos describe brevemente una selección patrones arquitectónicos uso común diferentes tipos sistemas. para más información patrones uso, debe remitirse los manuales patrones publicados. patrón arquitectónico puede considerar como una descripción abstracta estili-zada buena práctica, que ensayó puso prueba diferentes sistemas entornos. este modo, patrón arquitectónico debe describir una organización sistema que tenido éxito sistemas previos. debe incluir información sobre cuándo cuándo adecuado usar dicho patrón, así como sobre las fortalezas debilidades del patrón. por ejemplo, figura . describe muy conocido patrón modelo-vista-controlador. este patrón soporte del manejo interacción muchos sistemas basados web. descripción del patrón estilizado incluye nombre del patrón, una breve des-cripción (con modelo gráfico asociado) ejemplo del tipo sistema donde usa patrón ( nuevo, quizá con modelo gráfico). también debe incluir información sobre cuándo hay que usar patrón, así como sobre sus ventajas desventajas. las figuras . . presentan los modelos gráficos arquitectura asociada con patrón mvc. ellas muestra arquitectura desde diferentes vistas: figura . una vista conceptual; tanto que figura . ilustra una posible arquitectura tiempo operación, cuando este patrón usa para manejo interacción sistema basado web. una breve sección capítulo general imposible describir todos los patro-nes genéricos que usan desarrollo software. cambio, presentan algunos ejemplos seleccionados patrones que utilizan ampliamente captan buenos prin-cipios diseño arquitectónico. las páginas web del libro incluyen más ejemplos acerca patrones arquitectónicos genéricos.controlador vista modeloselección vista cambio estadonotificación cambio consulta estadoeventos usuariomapear accionesde usuario para modelaractualizaciónselecciona vistainterpreta modelosolicita actualizacionesde modeloenvía eventos usuarioa controlador encapsula estadode aplicaciónnotifica los cambiosde vista estado figura . organización del mvc -.indd -.indd // :: // :: . ■ patrones arquitectónicos .. arquitectura capas las nociones separación independencia son fundamentales para diseño arquitec- tónico porque permiten localizar cambios. patrón mvc, que muestra figura ., separa elementos sistema, permitiéndoles cambiar forma independiente. por ejemplo, agregar una nueva vista cambiar una vista existente puede hacerse sin modificación alguna los datos subyacentes modelo. patrón arquitectura capas otra forma lograr separación independencia. este patrón ilustra figura .. aquí, funcionalidad del sistema está organizada capas separadas, cada una apoya sólo las facilidades los servicios ofrecidos por capa inmediatamente debajo ella. este enfoque capas soporta desarrollo incremental sistemas. conforme desarrolla una capa, algunos los servicios proporcionados por esta capa deben quedar disposición los usuarios. arquitectura también cambiable portátil. tanto interfaz varíe, una capa puede sustituirse por otra equivalente. más aún, cuando las interfaces capa cambian agregan nuevas facilidades una capa, sólo resulta afectada capa adyacente. medida que los sistemas capas localizan dependencias máquina capas más internas, facilita ofrecimiento implementaciones mul-tiplataforma sistema aplicación. sólo las capas más internas dependientes máquina deben reimplantarse para considerar las facilidades sistema operativo base datos diferentes. figura . ejemplo una arquitectura capas con cuatro capas. capa inferior incluye software soporte sistema, por general soporte base datos sistema operativo. siguiente capa aplicación, que comprende los componentes relacionados con funcionalidad aplicación, así como los componentes utilidad que usan otros componentes aplicación. tercera capa relaciona con gestión interfaz del usuario con brindar autenticación autorización usuario, mientras que navegador controlador formato desplegar solicita actualizaciónnotificación cambiosolicita regeneracióneventos usuariohttp solicita procesamientológica aplicaciónespecíficavalidación datospágina dinámicageneracióngestión formatos lógica empresarialbase datosvista modelo figura . arquitectura aplicación web con patrón mvc -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico capa superior proporciona facilidades interfaz usuario. desde luego, arbitrario número capas. cualquiera las capas figura . podría dividirse dos más capas. figura . ejemplo cómo puede aplicarse este patrón arquitectura capas sistema biblioteca llamado libsys, que permite acceso electrónico controlado material con derechos autor conjunto bibliotecas universitarias. tiene una arquitectura cinco capas , capa inferior, están las bases datos indi-viduales cada biblioteca. figura . (que encuentra sección .) observa otro ejemplo patrón arquitectura capas. muestra organización del sistema para atención salud mental (mhc-pms) que estudió capítulos anteriores. interfaz usuario lógica empresarial núcleo/funcionalidad aplicación utilidades del sistema soporte del sistema (, base datos, etc.)gestión interfaz usuario autenticación autorización figura . arquitectura genérica capas nombre arquitectura capas descripción organiza sistema capas con funcionalidad relacionada con cada capa. una capa servicios capa encima, modo que las capas nivel inferior representan servicios núcleo que probable utilicen largo todo sistema. véase figura .. ejemplo modelo capas sistema para compartir documentos con derechos autor tiene diferentes bibliotecas, como ilustra figura .. cuándo usa usa construirse nuevas facilidades encima los sistemas existentes; cuando desarrollo dispersa través varios equipos trabajo, cada uno responsable una capa funcionalidad; cuando exista requerimiento para seguridad multinivel. ventajas permite sustitución capas completas tanto conserve interfaz. para aumentar confiabilidad del sistema, cada capa pueden incluirse facilidades redundantes (por ejemplo, autenticación). desventajas práctica, suele ser difícil ofrecer una separación limpia entre capas, posible que una capa nivel superior deba interactuar directamente con capas nivel inferior, vez que sea través capa inmediatamente abajo ella. rendimiento suele ser problema, debido múltiples niveles interpretación una solicitud servicio mientras procesa cada capa. figura . patrón arquitectura capas -.indd -.indd // :: // :: . ■ patrones arquitectónicos .. arquitectura repositorio los patrones arquitectura capas mvc son ejemplos patrones que vista presentada organización conceptual sistema. siguiente ejemplo, patrón repositorio (figura .), describe cómo comparte datos conjunto componentes interacción. mayoría los sistemas que usan grandes cantidades datos organizan sobre una base datos repositorio compartido. por tanto, este modelo adecuado interfaz navegador web índice bibliotecabúsqueda distribuidarecuperación documentosgestor derechoscontabilidad dbnconexión libsysgestor formatos consultagestor impresión figura . arquitectura del sistema libsys nombre repositorio descripción todos los datos sistema gestionan repositorio central, accesible todos los componentes del sistema. los componentes interactúan directamente, sino tan sólo través del repositorio. ejemplo figura . ejemplo ide donde los componentes usan repositorio información diseño sistema. cada herramienta software genera información que, ese momento, está disponible para uso otras herramientas. cuándo usa este patrón usa cuando tiene sistema donde los grandes volúmenes información generados deban almacenarse durante mucho tiempo. también puede usarse sistemas dirigidos por datos, los que inclusión datos repositorio active una acción herramienta. ventajas los componentes pueden ser independientes, necesitan conocer existencia otros componentes. los cambios hechos por componente pueden propagar hacia todos los componentes. totalidad datos puede gestionar manera consistente (por ejemplo, respaldos realizados mismo tiempo), pues todos están lugar. desventajas repositorio punto falla único, modo que los problemas repositorio afectan todo sistema. posible que haya ineficiencias organizar toda comunicación través del repositorio. quizá sea difícil distribuir repositorio por medio varias computadoras.figura . patrón repositorio -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico para aplicaciones las que componente genere datos otro los use. los ejemplos este tipo sistema incluyen sistemas comando control, sistemas información administrativa, sistemas cad entornos desarrollo interactivo para software. figura . ilustra una situación que puede usarse repositorio. este diagrama muestra ide que incluye diferentes herramientas para soportar desarrollo dirigido por modelo. este caso, repositorio puede ser entorno controlado por versión (como estudia capítulo ) que hace seguimiento los cambios software per-mite regresar (rollback) versiones anteriores. organizar herramientas alrededor repositorio una forma eficiente compar-tir grandes cantidades datos. hay necesidad transmitir explícitamente datos componente otro. sin embargo, los componentes deben operar torno modelo repositorio datos acordado. inevitablemente, éste compromiso entre las nece-sidades específicas cada herramienta sería difícil imposible integrar nuevos com-ponentes, sus modelos datos ajustan esquema acordado. práctica, llega ser complicado distribuir repositorio sobre número máquinas. aunque posible distribuir repositorio lógicamente centralizado, puede haber problemas con redundancia inconsistencia los datos. ejemplo que muestra figura ., repositorio pasivo, control responsabilidad los componentes que usan repositorio. enfoque alternativo, que derivó para sistemas , utiliza modelo “blackboard” (pizarrón) que activa com-ponentes cuando los datos particulares tornan disponibles. esto adecuado cuando forma los datos del repositorio está menos estructurada. las decisiones sobre cuál herramienta activar puede hacerse sólo cuando hayan analizado los datos. este modelo introdujo nii (). bosch () incluye buen análisis cómo este estilo relaciona con los atributos calidad del sistema. .. arquitectura cliente-servidor patrón repositorio interesa por estructura estática sistema sin mostrar organización tiempo operación. siguiente ejemplo ilustra una organización tiempo operación, uso muy común para sistemas distribuidos. figura . describe patrón cliente-servidor.repositorio del proyectotraductor diseñoeditores umlgeneradores código analizador diseñogenerador reporteeditor java editor python figura . arquitectura repositorio para ide -.indd -.indd // :: // :: . ■ patrones arquitectónicos sistema que sigue patrón cliente-servidor organiza como conjunto ser- vicios servidores asociados, clientes que acceden usan los servicios. los princi-pales componentes este modelo son: . conjunto servidores que ofrecen servicios otros componentes. ejemplos éstos incluyen servidores impresión; servidores archivo que brindan servicios administración archivos, servidor compilador, que proporciona servicios compilación lenguaje programación. . conjunto clientes que solicitan los servicios que ofrecen los servidores. habrá usualmente varias instancias programa cliente que ejecuten manera con-currente diferentes computadoras. . una red que permite los clientes acceder dichos servicios. mayoría los sistemas cliente-servidor implementan como sistemas distribuidos, conectados mediante protocolos internet. las arquitecturas cliente-servidor consideran menudo como arquitecturas sis-temas distribuidos; sin embargo, modelo lógico servicios independientes que opera servidores separados puede implementarse una sola computadora. nuevo, beneficio importante separación independencia. los servicios servidores pueden cambiar sin afectar otras partes del sistema. posible que los clientes deban conocer los nombres los servidores disponibles, así como los servicios que proporcionan. sin embargo, los servidores necesitan cono-cer identidad los clientes cuántos clientes acceden sus servicios. los clientes acceden los servicios que proporciona servidor, través llamadas procedi-miento remoto usando protocolo solicitud-respuesta, como protocolo http utilizado nombre cliente-servidor descripción una arquitectura cliente-servidor, funcionalidad del sistema organiza servicios, cada servicio entrega servidor independiente. los clientes son usuarios dichos servicios para utilizarlos ingresan los servidores. ejemplo figura . ejemplo una filmoteca videoteca (videos/dvd) organizada como sistema cliente-servidor. cuándo usa usa cuando, desde varias ubicaciones, tiene que ingresar los datos una base datos compartida. como los servidores pueden replicar, también usan cuando carga sistema variable. ventajas principal ventaja este modelo que los servidores pueden distribuir través una red. funcionalidad general (por ejemplo, servicio impresión) estaría disponible todos los clientes, así que necesita implementarse todos los servicios. desventajas cada servicio solo punto falla, modo que susceptible ataques rechazo deservicio fallas del servidor. rendimiento resultará impredecible porque depende red, así como del sistema. quizás haya problemas administrativos cuando los servidores sean propiedad diferentes organizaciones. figura . patrón cliente-servidor -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico www. esencia, cliente realiza una petición servidor espera hasta que recibe una respuesta. figura . ejemplo sistema que basa modelo cliente-servidor. trata sistema multiusuario basado web, para ofrecer repertorio pelícu-las fotografías. este sistema, varios servidores manejan despliegan los diferentes tipos medios. los cuadros video necesitan transmitirse rápidamente sincronía, aunque una resolución relativamente baja. tal vez estén comprimidos almacén, manera que servidor video puede manipular diferentes formatos compre-sión descompresión del video. sin embargo, las imágenes fijas deben conservarse una resolución alta, por que adecuado mantenerlas servidor independiente. catálogo debe manejar una variedad consultas ofrecer vínculos hacia sis-tema información web, que incluye datos acerca las películas los videos, así servidor catálogo catálogo bibliotecaservidor video almacén películasservidor imagen almacén fotosservidor web inf. películas fotoscliente cliente cliente cliente internet figura . arquitectura cliente-servidor para una filmoteca nombre tubería filtro ( pipe and filter) descripción procesamiento datos sistema organiza forma que cada componente procesamiento (filtro) sea discreto realice tipo transformación datos. los datos fluyen (como una tubería) componente otro para procesamiento. ejemplo figura . ejemplo sistema tubería filtro usado para procesamiento facturas. cuándo usa suele utilizar aplicaciones procesamiento datos (tanto basadas lotes [ batch] como transacciones), donde las entradas procesan etapas separadas para generar salidas relacionadas. ventajas fácil entender soporta reutilización transformación. estilo del flujo trabajo coincide con estructura muchos procesos empresariales. evolución agregar transformaciones directa. puede implementarse como sistema secuencial como uno concurrente. desventajas formato para transferencia datos debe acordarse entre las transformaciones que comunican. cada transformación debe analizar sus entradas sintetizar sus salidas formato acordado. esto aumenta carga del sistema, puede significar que sea imposible reutilizar transformaciones funcionales que usen estructuras datos incompatibles.figura . patrón tubería filtro ( pipe and filter) -.indd -.indd // :: // :: . ■ patrones arquitectónicos como sistema comercio electrónico que soporte venta fotografías, películas videos. programa cliente simplemente una interfaz integrada usuario, construida mediante navegador web, para acceder dichos servicios. ventaja más importante del modelo cliente-servidor consiste que una arqui-tectura distribuida. éste puede usarse manera efectiva sistemas red con distintos procesadores distribuidos. fácil agregar nuevo servidor integrarlo resto del sistema, bien, actualizar manera clara servidores sin afectar otras partes del sistema. capítulo estudian las arquitecturas distribuidas, incluidas las arquitecturas cliente-servidor las arquitecturas objeto distribuidas. .. arquitectura tubería filtro ejemplo final patrón arquitectónico patrón tubería filtro ( pipe and filter). éste modelo organización tiempo operación sistema, donde las transformaciones funcionales procesan sus entradas producen salidas. los datos fluyen uno otro transforman conforme desplazan través secuencia. cada paso procesamiento implementa como transformador. los datos entrada fluyen por medio dichos transformadores hasta que convierten salida. las transformaciones pueden ejecutarse secuencialmente forma paralela. posible que los datos pro-cesen por cada transformador ítem por ítem solo lote. nombre “tubería filtro” proviene del sistema unix original, donde era posible vincular procesos empleando “tuberías”. por ellas pasaba una secuencia texto proceso otro. los sistemas conformados con este modelo pueden implementarse combinar comandos unix, usando las tuberías las instalaciones control del intérprete comandos unix. usa término “filtro” porque una transformación “filtra” los datos que puede procesar secuencia datos entrada. han utilizado variantes este patrón desde que usaron por primera vez compu-tadoras para procesamiento automático datos. cuando las transformaciones son secuenciales, con datos procesados lotes, este modelo arquitectónico tubería fil-tro convierte modelo secuencial lote, una arquitectura común para sistemas procesamiento datos (por ejemplo, sistema facturación). arquitectura sistema embebido puede organizarse también como proceso por entubamiento, donde cada proceso ejecuta manera concurrente. capítulo estudia uso este patrón sistemas embebidos. figura . muestra ejemplo este tipo arquitectura sistema, que usa una aplicación procesamiento lote. una organización emite facturas los clientes. una vez semana, los pagos efectuados incorporan las facturas. para leer facturas emitidasidentificar pagosemitir recibos encontrar pagos vencidosrecibos emitir recordatorio pagorecordatorios facturas pagos figura . ejemplo arquitectura tubería filtro -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico las facturas pagadas emite recibo. para las facturas saldadas dentro del plazo pago emite recordatorio. los sistemas interactivos son difíciles escribir con modelo tubería filtro, debido necesidad procesar una secuencia datos. aunque las entradas salidas textua-les simples pueden modelarse esta forma, las interfaces gráficas usuario tienen formatos / más complejos, así como una estrategia control que basa eventos como clics del mouse selecciones del menú. difícil traducir esto una forma com-patible con modelo pipelining (entubamiento). . arquitecturas aplicación los sistemas aplicación tienen intención cubrir las necesidades una empresa organización. todas las empresas tienen mucho común: necesitan contratar personal, emitir facturas, llevar contabilidad, etcétera. las empresas que operan mismo sector usan aplicaciones comunes específicas para sector. esta forma, además las funciones empresariales generales, todas las compañías telefónicas necesitan sistemas para conectar llamadas, administrar sus redes emitir facturas los clientes, entre otros. consecuencia, también los sistemas aplicación que utilizan dichas empresas tienen mucho común. estos factores común condujeron desarrollo arquitecturas software que describen estructura organización tipos particulares sistemas software. las arquitecturas aplicación encapsulan las principales características una clase sistemas. por ejemplo, los sistemas tiempo real puede haber modelos arquitectónicos genéricos diferentes tipos sistema, tales como sistemas recolección datos sistemas monitorización. aunque las instancias dichos sistemas difieren detalle, estructura arquitectónica común puede reutilizarse cuando desarrollen nuevos siste-mas del mismo tipo. arquitectura aplicación puede reimplantarse cuando desarrollen nuevos sis-temas, pero, para diversos sistemas empresariales, reutilización aplicaciones posible sin reimplementación. esto observa crecimiento los sistemas pla-neación recursos empresariales (erp, por las siglas enterprise resource planning) compañías como sap oracle, paquetes software vertical (cots) para aplica-ciones especializadas diferentes áreas negocios. dichos sistemas, sistema genérico configura adapta para crear una aplicación empresarial específica.patrones arquitectónicos para control existen patrones arquitectónicos específicos que reflejan formas usadas comúnmente para organizar control sistema. ellos incluyen control centralizado, basado componente que llama otros componentes, control con base evento, donde sistema reacciona eventos externos. http:// -.indd -.indd // :: // :: . ■ arquitecturas aplicación por ejemplo, sistema para suministrar administración cadena adapta diferen- tes tipos proveedores, bienes arreglos contractuales. como diseñador software, usted puede usar modelos arquitecturas aplicación varias formas: . como punto partida para proceso diseño arquitectónico está fami- liarizado con tipo aplicación que desarrolla, podría basar diseño inicial una arquitectura aplicación genérica. desde luego, ésta tendrá que ser especializada para sistema específico que desarrollar, pero buen comienzo para diseño. . como lista verificación del diseño usted desarrolló diseño arquitectónico para sistema aplicación, puede comparar éste con arquitectura aplicación genérica luego, verificar que diseño sea consistente con arquitectura genérica. . como una forma organizar trabajo del equipo desarrollo las arquitectu-ras aplicación identifican características estructurales estables las arquitecturas del sistema , muchos casos, posible desarrollar éstas paralelo. puede asig-nar trabajo los miembros del grupo para implementar diferentes componentes den-tro arquitectura. . como medio para valorar los componentes reutilizar tiene componen- tes por reutilizar, compare éstos con las estructuras genéricas para saber existen componentes similares arquitectura aplicación. . como vocabulario para hablar acerca los tipos aplicaciones discute acerca una aplicación específica trata comparar aplicaciones del mismo tipo, entonces puede usar los conceptos identificados arquitectura genérica para hablar sobre las aplicaciones. hay muchos tipos sistema aplicación , algunos casos, parecerían muy dife-rentes. sin embargo, muchas estas aplicaciones distintas superficialmente realidad tienen mucho común , por ende, suelen representarse mediante una sola arquitectura aplicación abstracta. esto ilustra aquí describir las siguientes arquitecturas dos tipos aplicación: . aplicaciones procesamiento transacción este tipo aplicaciones son aplicacio- nes centradas bases datos, que procesan los requerimientos del usuario mediante información actualizan ésta una base datos. trata del tipo más común sistemas empresariales interactivos. organizan tal forma que las acciones del usuario pueden interferir unas con otras mantiene integridad base arquitecturas aplicación sitio web del libro existen muchos ejemplos arquitecturas aplicación. incluyen descripciones sistemas procesamiento datos lote, sistemas asignación recursos sistemas edición basados eventos. http:// -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico datos. esta clase sistema incluye los sistemas bancarios interactivos, sistemas comercio electrónico, sistemas información sistemas reservaciones. . sistemas procesamiento lenguaje son sistemas los que las intenciones del usuario expresan lenguaje formal (como java). sistema procesamiento lenguaje elabora este lenguaje formato interno después interpreta dicha representación interna. los sistemas procesamiento lenguaje mejor conocidos son los compiladores, que traducen los programas lenguaje alto nivel dentro código máquina. sin embargo, los sistemas procesamiento lenguaje usan también interpretación lenguajes comandos para bases datos sistemas información, así como lenguajes marcado como xml (harold means, ; hunter ., ). eligieron estos tipos particulares sistemas porque una gran cantidad sistemas empresariales basados web son sistemas procesamiento transacciones, todo desarrollo del software apoya los sistemas procesamiento lenguaje. .. sistemas procesamiento transacciones los sistemas procesamiento transacciones (, por las siglas transaction pro-cessing) están diseñados para procesar peticiones del usuario mediante información una base datos, los requerimientos para actualizar una base datos (lewis ., ). técnicamente, una transacción base datos una secuencia operaciones que trata como una sola unidad (una unidad atómica). todas las operaciones una transacción tienen que completarse antes que sean permanentes los cambios base datos. esto garantiza que falla las operaciones dentro transacción con-duzca inconsistencias base datos. desde una perspectiva usuario, una transacción cualquier secuencia coherente operaciones que satisfacen objetivo, como “encontrar los horarios vuelos londres parís”. transacción del usuario requiere cambio base datos, entonces sería innecesario empaquetar esto como una transacción técnica base datos. ejemplo una transacción una petición cliente para retirar dinero una cuenta bancaria mediante cajero automático. esto incluye obtener detalles cuenta del cliente, verificar modificar saldo por cantidad retirada enviar comandos cajero automático para entregar dinero. hasta que todos estos pasos completan, transacción permanece inconclusa cambia base datos cuenta del cliente. por general, los sistemas procesamiento transacción son sistemas interactivos donde los usuarios hacen peticiones asíncronas servicios. figura . ilustra estruc-tura arquitectónica conceptual las aplicaciones . primero, usuario hace una petición sistema través componente procesamiento /. petición procesa mediante alguna lógica específica aplicación. crea una transacción pasa hacia gestor transacciones que, por general, está embebido sistema manejo procesamiento /ológica aplicacióngestor transacciónbase datosfigura . estructura las aplicaciones procesamiento transacción -.indd -.indd // :: // :: . ■ arquitecturas aplicación base datos. después que gestor transacciones asegura que transacción completado adecuadamente, señala aplicación que terminó procesamiento. los sistemas procesamiento transacción pueden organizarse como una arqui-tectura “tubería filtro” con componentes sistema responsables entradas, proce-samiento salida. por ejemplo, considere sistema bancario que permite los clientes consultar sus cuentas retirar dinero cajero automático. sistema está constituido por dos componentes software cooperadores: software del cajero automático software procesamiento cuentas servidor base datos del banco. los componentes entrada salida implementan como software cajero automático componente procesamiento parte del servidor base datos del banco. figura . muestra arquitectura este sistema ilustra las funciones los compo-nentes entrada, proceso salida. .. sistemas información todos los sistemas que incluyen interacción con una base datos compartida con-sideran sistemas información basados transacciones. sistema información permite acceso controlado una gran base información, tales como catálogo biblioteca, horario vuelos los registros pacientes hospital. cada vez más, los sistemas información son sistemas basados web, cuyo acceso mediante navegador web. figura . presenta modelo muy general sistema información. sistema modela con enfoque por capas (estudiado sección .), donde capa superior soporta interfaz usuario, capa inferior base datos del sistema. capa comunicaciones con usuario maneja todas las entradas salidas inter-faz usuario, capa recuperación información incluye lógica específica aplicación para acceder actualizar base datos. como verá más adelante, las capas este modelo pueden trazarse directamente hacia servidores dentro sistema basado internet. como ejemplo una instancia este modelo capas, figura . muestra arquitectura del mhc-pms. recuerde que este sistema mantiene administra detalles los pacientes que consultan médicos especialistas problemas salud mental. entrada proceso salida atm base datos atmimprimir detalles regresar tarjeta entregar dineroconsultar cuenta actualizar cuentaconseguir cuenta cliente validar tarjeta seleccionar serviciofigura . arquitectura software sistema atm -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico modelo agregaron detalles cada capa identificar los componentes que soportan las comunicaciones del usuario, así como recuperación acceso información: . capa superior responsable implementar interfaz usuario. este caso, implementó con uso navegador web. . segunda capa proporciona funcionalidad interfaz usuario que entrega través del navegador web. incluye componentes que permiten los usuarios ingre- sar sistema, componentes verificación para garantizar que las operaciones utilizadas estén permitidas acuerdo con rol. esta capa incluye componentes gestión formato menú que presentan información los usuarios, así como com-ponentes validación datos que comprueban consistencia información. . tercera capa implementa funcionalidad del sistema ofrece componentes que ponen operación seguridad del sistema, creación actualización infor-mación del paciente, importación exportación datos del paciente desde otras bases datos, los generadores reporte que elaboran informes administrativos.interfaz usuario recuperación modificación información gestión transacciones base datoscomunicaciones del usuarioautenticación autorización figura . arquitectura sistema información capas navegador web generación reportes gestión transacción base datos pacientesconexión (login)gestor formato menúvalidación datosverificación rol gestión seguridadgestor inf. pacientesimportación exportación datos figura . arquitectura del mhc-pms -.indd -.indd // :: // :: . ■ arquitecturas aplicación . finalmente, capa más baja, que construye usar sistema comercial ges- tión base datos, ofrece administración transacciones almacenamiento constante datos. los sistemas gestión información recursos, por general, son ahora sistemas basados web donde las interfaces usuario implementan con uso nave-gador web. por ejemplo, los sistemas comercio electrónico son sistemas gestión recursos basados internet, que aceptan pedidos electrónicos por bienes servicios , luego, ordenan entrega dichos bienes servicios cliente. sistema comercio electrónico, capa específica aplicación incluye funcionalidad adicional que soporta “carrito compras”, donde los usuarios pueden colocar algunos objetos transacciones separadas , luego, pagarlos una sola transacción. organización servidores dichos sistemas refleja usualmente modelo gené-rico cuatro capas presentadas figura .. dichos sistemas suelen implementar como arquitecturas cliente-servidor multinivel, como estudia capítulo : . servidor web responsable todas las comunicaciones del usuario, inter- faz usuario pone función mediante navegador web; . servidor aplicación responsable implementar lógica específica aplicación, así como del almacenamiento información las peticiones recu- peración; . servidor base datos mueve información hacia desde base datos , además, manipula gestión transacciones. uso múltiples servidores permite rendimiento elevado, igual que posibilita manipulación cientos transacciones por minuto. conforme aumenta demanda, pueden agregarse servidores cada nivel, para lidiar con procesamiento adicional implicado. .. sistemas procesamiento lenguaje los sistemas procesamiento lenguaje convierten lenguaje natural artificial otra representación del lenguaje , para lenguajes programación, también pueden ejecutar código resultante. ingeniería software, los compiladores traducen lenguaje pro- gramación artificial código máquina. otros sistemas procesamiento lenguaje traducen una descripción datos xml comandos para consultar una base datos una representación xml alternativa. los sistemas procesamiento lenguaje natural pueden transformar lenguaje natural otro, por ejemplo, francés noruego. figura . ilustra una posible arquitectura para sistema procesamiento lenguaje hacia lenguaje programación. las instrucciones lenguaje fuente definen programa ejecutar, tanto que traductor las convierte instrucciones para una máquina abstracta. luego, dichas instrucciones interpretan mediante otro componente que lee ( fetch) las instrucciones para ejecución las ejecuta usar ( necesario) datos del entorno. salida del proceso resultado interpretación instrucciones los datos entrada. -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico desde luego, para muchos compiladores, intérprete una unidad hardware que procesa instrucciones máquina, tanto que máquina abstracta procesador real. sin embargo, para lenguajes escritos manera dinámica, como python, intér-prete puede ser componente software. los compiladores lenguaje programación que forman parte entorno programación más general tienen una arquitectura genérica (figura .) que incluye los siguientes componentes: . analizador léxico, que toma valores simbólicos (tokens) los convierte una forma interna. . una tabla símbolos, que contiene información los nombres las entidades (variables, clase, objeto, etcétera) usados texto que traduce. . analizador sintaxis, cual verifica sintaxis del lenguaje que tradu- cir. emplea una gramática definida del lenguaje construye árbol sintaxis. . árbol sintaxis una estructura interna que representa programa compilar.instrucciones lenguaje fuente datos resultadostraductor intérpreteinstrucciones abstractas /mverificación sintaxis verificación semánticagenera lee (fetch) ejecutafigura . arquitectura sistema procesamiento lenguaje análisis léxicoanálisis sintácticoanálisis semánticogeneración códigotabla símbolos árbol sintaxis figura . una arquitectura compilador tubería filtro -.indd -.indd // :: // :: . ■ arquitecturas aplicación . analizador semántico que usa información del árbol sintaxis tabla sím- bolos, para verificar exactitud semántica del texto lenguaje entrada. . generador código que “recorre” árbol sintaxis genera código máquina abstracto. también pueden incluirse otros componentes que analizan transforman árbol sintaxis para mejorar eficiencia remover redundancia del código máquina gene-rado. otros tipos sistema procesamiento lenguaje, como traductor len-guaje natural, habrá componentes adicionales, por ejemplo, diccionario, código generado realidad texto entrada traducido otro lenguaje. existen patrones arquitectónicos alternativos que pueden usarse sistema pro-cesamiento lenguaje (garlan shaw, ). pueden implementarse compiladores con una composición repositorio modelo tubería filtro. una arquitectura compilador, tabla símbolos repositorio para datos compartidos. las fases análisis léxico, sintáctico semántico organizan manera secuencial, como mues-tra figura ., comunican través tabla símbolos compartida. este modelo tubería filtro compilación lenguaje efectivo entornos batch, donde los programas compilan ejecutan sin interacción del usuario; por ejem-plo, traducción documento xml otro. menos efectivo cuando com-pilador integra con otras herramientas procesamiento lenguaje, como sistema edición estructurado, depurador interactivo programa impresión estética (prettyprinter). esta situación, los cambios componente deben reflejarse inmediato otros componentes. por tanto, mejor organizar sistema torno repositorio, como muestra figura .. esta figura ilustra cómo sistema procesamiento lenguaje puede formar parte conjunto integrado herramientas soporte programación. este ejemplo, tabla símbolos árbol sintaxis actúan como almacén información cen-tral. las herramientas los fragmentos herramienta comunican través . otra información que ocasiones incrusta las herramientas, como definición gramá-tica definición del formato salida para programa, toma las herramientas coloca repositorio. consecuencia, editor enfocado sintaxis podría verificar que ésta sea correcta mientras escribe programa, prettyprinter puede crear listados del programa formato que sea fácil leer.arquitecturas referencia las arquitecturas referencia captan dominio características importantes las arquitecturas del sistema. esencia, incluyen todo que pueda estar una arquitectura aplicación aunque, realidad, muy improbable que alguna aplicación individual contenga todas las características mostradas una arquitectura referencia. objetivo principal las arquitecturas referencia consiste evaluar comparar las propuestas diseño , dicho dominio, educar las personas sobre las características arquitectónicas. http:// -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico puntos clave ■ una arquitectura software una descripción cómo organiza sistema software. las propiedades sistema, como rendimiento, seguridad disponibilidad, están influidas por arquitectura utilizada. ■ las decisiones diseño arquitectónico incluyen decisiones sobre tipo aplicación, distribución del sistema, los estilos arquitectónicos usar las formas que arquitectura debe documentarse evaluarse. ■ las arquitecturas pueden documentarse desde varias perspectivas diferentes vistas. las posibles vistas incluyen conceptual, lógica, proceso, desarrollo física. ■ los patrones arquitectónicos son medios para reutilizar conocimiento sobre las arquitecturas sistemas genéricos. describen arquitectura, explican cuándo debe usarse, exponen sus ventajas desventajas. ■ los patrones arquitectónicos usados comúnmente incluyen modelo vista del controlador, arquitectura capas, repositorio, cliente-servidor, tubería filtro. ■ los modelos genéricos las arquitecturas sistemas aplicación ayudan entender operación las aplicaciones, comparar aplicaciones del mismo tipo, validar diseños del sistema aplicación valorar componentes para reutilización gran escala. ■ los sistemas procesamiento transacción son sistemas interactivos que permiten acceso modificación remota información, una base datos por parte varios usuarios. los sistemas información los sistemas gestión recursos son ejemplos sistemas procesamiento transacciones. ■ los sistemas procesamiento lenguaje usan para traducir textos lenguaje otro para realizar las instrucciones especificadas lenguaje entrada. incluyen traductor una máquina abstracta que ejecuta lenguaje generado.analizador sintaxisanalizador léxicoanalizador semántico árbol sintaxis abstractodefinición gramatical tabla símbolosdefinición salidaimpresión estética editoroptimizador generador código repositoriofigura . arquitectura repositorio para sistema procesamiento lenguaje -.indd -.indd // :: // :: pmcapítulo ■ ejercicios lecturas sugeridas software architecture: perspectives emerging discipline. éste fue primer libro sobre arquitectura software incluye una amplia discusión acerca los diferentes estilos arquitectónicos. (. shaw . garlan, prentice-hall, .) software architecture practice, . trata una cuestión práctica arquitecturas software que exagera los beneficios del diseño arquitectónico. ofrece una clara razón empresarial sobre por qué son importantes las arquitecturas. (. bass, . clements . kazman, addison-wesley, .) “the golden age software architecture”. este ensayo estudia desarrollo arquitectura software, desde sus inicios década hasta uso actual. aun cuando tiene poco contenido técnico, presenta panorama histórico amplio interesante. (. shaw . clements, ieee software, (), marzo-abril .) http:/ /. doi. org/ . / . . . handbook software architecture. éste trabajo progreso grady booch, uno los primeros difusores arquitectura software. documentado las arquitecturas varios sistemas software, manera que lector puede ver realidad vez abstracción académica. disponible web con intención aparecer como libro. http:/ /www. handbookofsoftwarearchitecture. com/. ejercicios .. cuando describe sistema, explique por qué posible que deba diseñar arquitectura del sistema antes completar especificación requerimientos. .. pide preparar entregar una presentación administrador técnico para justificar contratación arquitecto sistemas para nuevo proyecto. escriba una lista que establezca los puntos clave presentación. por supuesto, debe explicar qué entiende por arquitecto sistemas. .. exponga por qué pueden surgir conflictos diseño cuando desarrolla una arquitectura para que tanto los requerimientos disponibilidad como los seguridad son los requerimientos funcionales más importantes. .. dibuje diagramas que muestren una vista conceptual una vista proceso las arquitecturas los siguientes sistemas: sistema automatizado emisión boletos que utilizan los pasajeros una estación ferrocarril. sistema videoconferencia controlado por computadora, que permita que los datos video, audio computadora sean mismo tiempo visibles muchos participantes. robot limpiador pisos cuya función sea asear espacios relativamente despejados, como corredores. limpiador debe detectar las paredes otros obstáculos. -.indd -.indd // :: // :: capítulo ■ diseño arquitectónico .. explique por qué usted usa normalmente muchos patrones arquitectónicos cuando diseña arquitectura sistema grande. además información sobre los patrones estudiados este capítulo, ¿qué información adicional puede serle útil diseñar sistemas grandes? .. sugiera una arquitectura para sistema (como itunes) que use para vender distribuir música por internet. ¿qué patrones arquitectónicos son base para esta arquitectura? .. especifique cómo usaría modelo referencia entornos case (disponibles las páginas web del libro), para comparar los ide ofrecidos por diferentes proveedores lenguaje programación como java. .. con modelo genérico sistema procesamiento lenguaje presentado aquí, diseñe arquitectura sistema que acepte comandos lenguaje natural los traduzca consultas base datos lenguaje como sql. .. con modelo básico sistema información, como presentó figura ., sugiera los componentes que puedan ser parte sistema información que permita los usuarios consultar información los vuelos que llegan salen aeropuerto específico. .. ¿debe existir una profesión separada “arquitecto software”, cuyo papel sea trabajar manera independiente con cliente para diseñar arquitectura sistema software? entonces, una compañía software aparte implementaría sistema. ¿cuáles serían las dificultades establecer tal profesión? referencias bass, ., clements, . kazman, . (). software architecture practice, . boston: addison-wesley. berczuk, . . appleton, . (). software configuration management patterns: effective teamwork, practical integration. boston: addison-wesley. booch, . (). “handbook software architecture”. publicación web. http:/ / bosch, . (). design and use software architectures. harlow, : addison-wesley.buschmann, ., henney, . schmidt, . . (). pattern-oriented software architecture volume : pattern language for distributed computing. new york: john wiley & sons. buschmann, ., henney, . schmidt, . . (). pattern-oriented software architecture volume : patterns and pattern languages. new york: john wiley & sons. buschmann, ., meunier, ., rohnert, . sommerlad, . (). pattern-oriented software architecture volume : system patterns. new york: john wiley & sons. -.indd -.indd // :: // :: pmcapítulo ■ referencias clements, ., bachmann, ., bass, ., garlan, ., ivers, ., little, ., nord, . stafford, . (). documenting software architectures: views and beyond. boston: addison-wesley. coplien, . . harrison, . . (). organizational patterns agile software development. englewood cliffs, : prentice hall. gamma, ., helm, ., johnson, . vlissides, . (). design patterns: elements reusable object-oriented software. reading, mass.: addison-wesley. garlan, . shaw, . (). “ introduction software architecture”. advances software engineering and knowledge engineering, –. harold, . . means, . . (). xml nutshell. sebastopol. calif.: ‘reilly.hofmeister, ., nord, . soni, . (). applied software architecture. boston: addison-wesley.hunter, ., rafter, ., fawcett, . van der vlist, . (). beginning xml, . indianapolis, ind.: wrox press. kircher, . jain, . (). pattern-oriented software architecture volume : patterns for resource management. new york: john wiley & sons. krutchen, . (). “the + view model software architecture”. ieee software, (), –. lange, . . ., chaudron, . . . muskens, . (). “uml software description and architecture description”. ieee software, (), –. lewis, . ., bernstein, . . kifer, . (). databases and transaction processing: application-oriented approach. boston: addison-wesley. martin, . sommerville, . (). “patterns interaction: linking ethnomethodology and design”. acm trans. computer-human interaction, (), –. nii, . . (). “blackboard systems, parts and ”. magazine, ( ), – –. schmidt, ., stal, ., rohnert, . buschmann, . (). pattern-oriented software architecture volume : patterns for concurrent and networked objects. new york: john wiley & sons. shaw, . garlan, . (). software architecture: perspectives emerging discipline. englewood cliffs, : prentice hall. usability group. (). “usability patterns”. publicación web. http:/ / -.indd -.indd // :: // :: pmobjetivos los objetivos este capítulo son introducirlo diseño software orientado objetos con uso del uml, así como resaltar las preocupaciones relevantes implementación. estudiar este capítulo: ■ comprenderá las actividades más importantes dentro proceso diseño general orientado objetos; ■ identificará algunos los diferentes modelos que pueden usarse para documentar diseño orientado objetos; ■ conocerá idea patrones diseño cómo éstos son una forma reutilizar conocimiento experiencia diseño; ■ introducirá los conflictos clave que debe considerar implementar software, incluida reutilización software desarrollo código abierto. contenido . diseño orientado objetos con uso del uml . patrones diseño. conflictos implementación. desarrollo código abierto diseño implementación -.indd -.indd // :: // :: pmcapítulo ■ diseño implementación diseño implementación del software etapa del proceso ingeniería soft- ware que desarrolla sistema software ejecutable. para algunos sistemas simples, diseño implementación del software ingeniería software, todas las demás actividades fusionan con este proceso. sin embargo, para sistemas grandes, diseño implementación del software son sólo uno una serie procesos (ingeniería requeri-mientos, verificación validación, etcétera) implicados ingeniería software. las actividades diseño implementación software encuentran invariable-mente entrelazadas. diseño software una actividad creativa donde identifi-can los componentes del software sus relaciones, con base los requerimientos cliente. implementación proceso realizar diseño como programa. algunas veces, hay una etapa diseño separada este último modela documenta. otras ocasiones, diseño halla mente del programador bosqueja bur-damente pizarrón hojas papel. diseño trata sobre cómo resolver pro-blema, modo que siempre existe proceso diseño. sin embargo, ocasiones necesario adecuado describir con detalle diseño usando uml otro lenguaje descripción diseño. diseño implementación están estrechamente vinculados usted, por general, debe tomar cuenta los conflictos implementación cuando desarrolle diseño. por ejemplo, usar uml para documentar diseño puede ser correcto está progra-mando lenguaje orientado objetos, como java #. menos útil cuando desarrolla lenguaje escritura dinámica, como python, tiene sentido abso-luto implementa sistema configurar paquete comercial. como estudió capítulo , los métodos ágiles suelen funcionar partir bosquejos informales del diseño dejan los programadores muchas las decisiones diseño. una las decisiones implementación más importantes, que toman una etapa inicial proyecto software, consiste determinar debe comprar diseñar software aplicación. gran rango dominios, ahora posible comprar sistemas comerciales (cots) que adapten personalicen según los requerimientos los usua-rios. por ejemplo, desea implementar sistema registros médicos, puede comprar paquete que use hospitales. posible que sea más barato rápido aplicar este enfoque vez desarrollar sistema lenguaje programación convencional. desarrollarse esta forma una aplicación, proceso diseño preocupa sobre cómo usar las características configuración dicho sistema, para entregar los reque-rimientos del mismo. por general, desarrollan modelos diseño del sistema, como los modelos los objetos del sistema sus interacciones. capítulo estudia enfoque basado cots. supone que mayoría los lectores este libro cuentan con algo experiencia diseño implementación programas. esto adquiere conforme aprende pro-gramar dominan los elementos lenguaje programación como java python. probablemente usted instruyó las buenas prácticas programación cuando estu-dió lenguajes programación, así como depurar los programas que desarrolla. por tanto, aquí cubren temas programación. cambio, este capítulo tiene dos metas: . mostrar cómo modelado sistemas diseño arquitectónico (que estudian los capítulos ) ponen práctica desarrollo diseño software orientado objetos. -.indd -.indd // :: // :: capítulo ■ diseño implementación . introducir importantes temas implementación que tratan normalmente los libros programación. ellos incluyen reutilización software, administración configuración desarrollo código abierto. como hay gran variedad plataformas desarrollo, capítulo desvía hacia algún lenguaje programación tecnología implementación específicos. por tanto, todos los ejemplos presentan usando uml vez lenguaje progra-mación como java python. . diseño orientado objetos con uso del uml sistema orientado objetos constituye con objetos que interactúan mantienen propio estado local ofrecen operaciones sobre dicho estado. representación del estado privada puede acceder directamente desde afuera del objeto. los proce-sos diseño orientado objetos implican diseño clases objetos las relaciones entre dichas clases; tales clases definen tanto los objetos sistema como sus interac-ciones. cuando diseño realiza como programa ejecución, los objetos crean dinámicamente partir estas definiciones clase. los sistemas orientados objetos son más fáciles cambiar que aquellos sistemas desarrollados usando enfoques funcionales. los objetos incluyen datos operaciones para manipular dichos datos. consecuencia, pueden entenderse modificarse como entidades independientes. cambiar implementación objeto agregar servicios afectará otros objetos del sistema. puesto que los objetos asocian con cosas, con frecuencia hay mapeo claro entre entidades del mundo real (como componentes hardware) sus objetos controladores sistema. esto mejora comprensibilidad , por ende, mantenibilidad del diseño. para desarrollar diseño sistema desde concepto hasta diseño detallado orientado objetos, hay muchas cuestiones por hacer: . comprender definir contexto las interacciones externas con sistema. . diseñar arquitectura del sistema.métodos diseño estructurado los métodos diseño estructurado refieren que diseño del software debe realizarse una forma metódica. diseñar sistema incluye seguir los pasos del método, así como corregir diseño sistema niveles cada vez más detallados. década había algunos métodos competencia para diseño orientado objetos. sin embargo, los creadores los métodos uso más común reunieron inventaron uml, que unificó las anotaciones usadas con los diferentes métodos. lugar enfocarse los métodos, mayoría las discusiones son ahora sobre procesos donde diseño como parte del proceso global desarrollo del software. proceso racional unificado (rup, por las siglas rational unified process) una buena muestra proceso desarrollo genérico. http:// -.indd -.indd // :: // :: . ■ diseño orientado objetos con uso del uml . identificar los objetos principales sistema. . desarrollar modelos diseño.. especificar interfaces. como todas las actividades creativas, diseño proceso secuencial tajante. diseño desarrolla obtener ideas, proponer soluciones corregir dichas solucio-nes conforme información encuentra disponible. cuando surjan problemas, ten-drá inevitablemente que regresar volver intentar. ocasiones exploran opciones detalle para observar funcionan; otras, ignoran hasta los detalles finales del proceso. consecuencia, texto ilustra deliberadamente este proceso como diagrama simple, debido que ello implicaría que diseño pudiera considerar como una secuencia clara actividades. hecho, todas las actividades anteriores están entrelazadas , por consiguiente, influyen entre . estas actividades proceso explican diseñar parte del software para estación meteorológica campo abierto que presentó capítulo . las estaciones meteo-rológicas campo abierto despliegan áreas remotas. cada estación meteorológica registra información meteorológica local transmite periódicamente, través vínculo satelital, sistema información meteorológica. .. contexto interacciones del sistema primera etapa cualquier proceso diseño software desarrollar compren-sión las relaciones entre software que diseñará ambiente externo. esto esencial para decidir cómo proporcionar funcionalidad requerida del sistema cómo estructurar sistema para que comunique con entorno. comprensión del con-texto permite también determinar las fronteras del sistema. establecimiento las fronteras del sistema ayuda decidir sobre las características que implementarán sistema que diseñar, así como sobre las otros sis-temas asociados. este caso, necesario decidir cómo distribuirá funcionalidad entre sistema control para todas las estaciones meteorológicas software embe-bido estación meteorológica . los modelos contexto del sistema los modelos interacción presentan vistas complementarias las relaciones entre sistema entorno: . modelo contexto del sistema modelo estructural, que muestra los otros sistemas entorno del sistema desarrollar. . modelo interacción modelo dinámico que indica forma que sis- tema interactúa con entorno conforme utiliza. modelo del contexto sistema puede representarse mediante asociaciones, las cuales muestran simplemente que existen algunas relaciones entre las entidades que inter-vienen asociación. naturaleza relaciones ahora específica. por tanto, posible documentar entorno del sistema con simple diagrama bloques, que mani-fieste las entidades sistema sus asociaciones. esto expone figura ., cual indica que los sistemas entorno cada estación meteorológica son sistema -.indd -.indd // :: // :: capítulo ■ diseño implementación información meteorológica, sistema satélite bordo sistema control. información cardinal vínculo muestra que hay sistema control, pero existen muchas estaciones meteorológicas, satélite sistema información meteorológica general. modelar las interacciones sistema con entorno, debe usar enfoque abstracto que contenga muchos detalles. una forma hacerlo usar modelo caso uso. como estudió los capítulos , cada caso uso representa una inte-racción con sistema. cada posible interacción menciona una elipse, entidad externa involucrada interacción representa con una figurilla. figura . presenta modelo caso uso para estación meteorológica. ahí demuestra que estación meteorológica interactúa con sistema informa-ción meteorológica para reportar datos meteorológicos estatus del hardware estación meteorológica. otras interacciones son través sistema control que puede emitir comandos control específicos estación meteorológica. como explicó capítulo , uml usa una figura para representar otros sistemas, así como usuarios. cada uno estos casos uso tiene que describirse lenguaje natural estruc-turado. eso ayudaría los diseñadores identificar objetos sistema les daría claridad acerca que pretende que haga sistema. para esta descripción, usa formato estándar que identifica con sencillez qué información intercambia, cómo sistema información meteorológicaestación meteorológica satellitesistema control satélite .... .. figura . contexto sistema para estación meteorológicacasos uso estación meteorológica reporte del clima: envía datos meteorológicos sistema información meteorológica reporte estatus: manda información estatus sistema información meteorológica reinicio: estación meteorológica apaga, reinicia sistema apagar: desconecta estación meteorológica reconfigurar: vuelve configurar software estación meteorológica ahorro energía: pone estación meteorológica modo ahorro energía control remoto: envía comandos control cualquier subsistema estación meteorológica http:// -.indd -.indd // :: // :: . ■ diseño orientado objetos con uso del uml inicia interacción, etcétera. eso muestra figura ., que describe caso uso sobre reporte del clima figura .. web hay ejemplos algunos otros casos uso. .. diseño arquitectónico una vez definidas las interacciones entre sistema software entorno del sistema, aplica esta información como base para diseñar arquitectura del sistema. desde luego, preciso combinar esto con conocimiento general los principios del diseño sistema caso usoactoresdatos estímulos respuesta comentariosestación meteorológicareporte del climasistema información meteorológica, estación meteorológicala estación meteorológica envía resumen datos meteorológicos, recopilados los instrumentos periodo recolección, sistema información meteorológica. los datos enviados incluyen las temperaturas, máxima, mínima promedio tierra aire; asimismo, las presiones aire máxima, mínima promedio; rapidez del viento, máxima, mínima promedio; totalidad lluvia dirección del viento que muestrea intervalos cinco minutos. sistema información meteorológica establece vínculo comunicación satelital con estación meteorológica solicita transmisión los datos. los datos resumidos envían sistema información meteorológica.por general, pide las estaciones meteorológicas reportarse una vez cada hora, pero esta periodicidad puede diferir una estación otra modificarse futuro.figura . descripción caso uso: reporte del climaapagarreporte del clima reinicioreporte estatus reconfigurarsistema información meteorológica sistema control ahorro energía control remotofigura . casos uso para estación meteorológica -.indd -.indd // :: // :: capítulo ■ diseño implementación arquitectónico con comprensión más detallada del dominio. identifique los prin- cipales componentes que constituyen sistema sus interacciones, posteriormente organice los componentes utilizando patrón arquitectónico como modelo capas cliente-servidor, aunque esto sea esencial esta etapa. figura . muestra diseño arquitectónico alto nivel para software esta-ción meteorológica. esta última compone subsistemas independientes que comu-nican través mensajes radiodifusión una infraestructura común, que presenta como vínculo “comunicación” figura .. cada subsistema escucha los mensajes esa infraestructura capta los mensajes que dirigen . éste otro estilo arquitec-tónico uso común, además los descritos capítulo . por ejemplo, cuando subsistema comunicaciones recibe comando control, como desconectarse, comando recibido por cada uno los otros subsistemas, que entonces apagan forma correcta. beneficio clave esta arquitectura consiste que fácil soportar diferentes configuraciones subsistemas debido que emisor del mensaje necesita dirigir mensaje subsistema específico. figura . expone arquitectura del subsistema recolección datos, inclui- figura .. los objetos “transmisor” “receptor” ocupan administrar las comunicaciones, objeto weatherdata (datos meteorológicos) encapsula infor- mación que recolecta los instrumentos transmite sistema información meteorológica. este arreglo sigue patrón productor-consumidor, estudiado capí-tulo . .. identificación clase objeto esta etapa del proceso diseño, necesario tener algunas ideas sobre los objetos esenciales sistema que diseña. conforme aumente comprensión del diseño, corregirá estas ideas los objetos del sistema. descripción del caso uso ayuda identificar objetos operaciones del sistema. partir descripción del caso uso “reporte del clima”, evidente que necesitarán objetos que representen los instru-mentos que recopilan los datos meteorológicos, así como objeto que simbolice resumen los datos meteorológicos. también suele requerir (unos) objeto() sistema alto nivel que encapsule() las interacciones del sistema definidas los «subsistema» recopilación datos«subsistema» comunicaciones«subsistema» gestor configuración«subsistema» gestor fallas«subsistema» gestor energía «subsistema» instrumentosvínculo comunicación figura . arquitectura alto nivel estación meteorológica -.indd -.indd // :: // :: . ■ diseño orientado objetos con uso del uml casos uso. con dichos objetos mente, usted puede comenzar identificar las clases objetos sistema. hay varias propuestas sobre cómo identificar las clases objetos los sistemas orientados objetos: . use análisis gramatical una descripción lenguaje natural del sistema construir. objetos atributos son sustantivos; operaciones servicios son verbos (abbott, ). . utilice entidades tangibles (cosas) dominio aplicación (como aeronave), roles (como administrador médico), eventos (como peticiones), interacciones (como reuniones), ubicaciones (como oficinas), unidades organizacionales (como compañías), etcétera (coad yourdon, ; shlaer mellor, ; wirfs-brock ., ). . emplee análisis basado escenarios, donde vez identifiquen analicen varios escenarios uso sistema. medida que analiza cada escenario, equipo responsable del análisis debe identificar los objetos, los atributos las opera-ciones requeridos (beck cunningham, ). práctica, debe usar varias fuentes conocimiento para descubrir clases objetos. dichas clases, así como los atributos las operaciones que identificaron comienzo partir descripción informal del sistema, pueden ser punto inicio para diseño. entonces posible usar más información del conocimiento del dominio aplicación del análisis del escenario para corregir ampliar los objetos iniciales. esta información recopila los documentos requerimientos, discusiones con usuarios análisis los sistemas existentes. estación meteorológica campo abierto, identificación objetos basa hardware tangible del sistema. aun cuando tiene suficiente espacio para incluir todos los objetos sistema, figura . muestran cinco clases objetos. los objetos termómetro tierra, anemómetro barómetro pertenecen dominio aplica-ción; tanto que los objetos weatherstation (estación meteorológica) weatherdata (datos meteorológicos) identificaron partir descripción del sistema des-cripción del escenario (caso uso): . clase objeto weatherstation proporciona interfaz básica estación meteorológica con entorno. sus operaciones reflejan las interacciones que recopilación datos transmisor receptor weatherdata figura . arquitectura sistema recopilación datos -.indd -.indd // :: // :: capítulo ■ diseño implementación muestran figura .. este caso, aunque usa una sola clase objeto para encapsular todas las interacciones, otros diseños pueden elaborar varias clases diferentes interfaz del sistema. . clase objeto weatherdata responsable procesar comando del report- weather (reporte del clima). envía los datos resumidos desde los aparatos estación meteorológica hacia sistema información meteorológica. . las clases objetos “termómetro tierra”, “anemómetro” “barómetro” rela- cionan directamente con instrumentos sistema. reflejan las entidades hard-ware tangibles sistema, las operaciones relacionan con control dicho hardware. tales objetos operan manera autónoma para recopilar datos fre-cuencia especificada almacenar localmente los datos recopilados. estos datos entregan por encargo objeto weatherdata. conocimiento del dominio aplicación usa para identificar otros objetos, atri-butos servicios. sabe que las estaciones meteorológicas localizan generalmente lugares remotos incluyen varios instrumentos que algunas veces funcionan mal. las fallas los instrumentos deben reportarse automáticamente. esto implica que necesi-tan atributos operaciones para comprobar buen funcionamiento los instrumentos. existen muchas estaciones meteorológicas remotas, modo que cada estación meteoro-lógica debe tener propio identificador (identifier). esta etapa del proceso diseño hay que enfocarse los objetos , sin pen-sar cómo podrían implementarse. una vez identificados los objetos, corrija diseño del objeto. busque características comunes luego elabore jerarquía herencia para sistema. por ejemplo, puede identificar una superclase “instrumento” que defina las carac-terísticas comunes todos los instrumentos, como identificador las operaciones get (conseguir) test (probar). también posible agregar nuevos atributos operaciones superclase, como atributo que mantenga frecuencia recolección datos.figura . objetos estación meteorológicaidentifier reportweather ( ) reportstatus ( ) powersave (instrumentos) remotecontrol (comandos) reconfigure (comandos) restart (instrumentos) shutdown (instrumentos)weatherstation airtemperatures groundtemperatureswindspeedswinddirectionspressuresrainfall collect ( ) summarize ( ) weatherdata anemómetro get ( ) test ( ) an_ident windspeedwinddirectionbarómetro get ( ) test ( ) bar_identpressureheighttermómetro tierra get ( ) test ( ) gt_identtemperature -.indd -.indd // :: // :: . ■ diseño orientado objetos con uso del uml .. modelos diseño como estudió capítulo , los modelos diseño sistema muestran los objetos clases objetos sistema. también indican las asociaciones relaciones entre tales entidades. dichos modelos son puente entre los requerimientos implemen-tación sistema. deben ser abstractos, manera que detalle innecesario oculte las relaciones entre ellos los requerimientos del sistema. sin embargo, deben incluir suficiente detalle para que los programadores tomen decisiones implemen-tación. por general, este tipo conflicto supera cuando desarrollan modelos con diferentes niveles detalle. donde existan vínculos cercanos entre ingenieros requerimientos, diseñadores programadores, los modelos abstractos pueden ser enton-ces todo que requiera. posible tomar decisiones diseño específico medida que implementa sistema, los problemas resuelven mediante discusiones infor-males. cuando los vínculos entre especificadores, diseñadores programadores del sistema son indirectos (por ejemplo, donde sistema diseña una parte una organización, pero implementa otra), probable que necesiten modelos más detallados. por consiguiente, paso importante proceso diseño determinar los mode-los diseño que necesitarán nivel detalle requerido dichos modelos. anterior depende del tipo sistema desarrollar. usted diseña sistema procesa-miento secuencial datos forma diferente que sistema embebido tiempo real, así que necesitará distintos modelos diseño. uml soporta diversos tipos modelos, pero, como estudió capítulo , rara vez los usará todos. minimizar número producción modelos reduce los costos del diseño tiempo requerido para completar proceso diseño. usar uml para elaboración diseño, usted por regular desarrollará dos tipos modelo diseño: . modelos estructurales, que describen estructura estática del sistema usando las clases objetos sus relaciones. las relaciones importantes que pueden documen- tarse esta etapa son las relaciones generalización (herencia), las relaciones usa/usado por las relaciones composición. . modelos dinámicos, que explican estructura dinámica del sistema muestran las interacciones entre los objetos del sistema. las interacciones que pueden documen-tarse incluyen secuencia peticiones servicio realizadas por los objetos, así como los cambios estado que activan las interacciones dichos objetos. las primeras fases del proceso diseño, considera que existen tres modelos que son útiles particularmente para agregar detalle los modelos caso uso arquitectó-nico: . modelos subsistema, que exponen los agrupamientos lógicos objetos subsis- temas coherentes. representan mediante una forma diagrama clase que cada subsistema muestra como paquete con objetos encerrados. los modelos subsistema son modelos estáticos (estructurales). -.indd -.indd // :: // :: capítulo ■ diseño implementación . modelos secuencia, que ilustran secuencia interacciones objetos. representan mediante una secuencia uml diagrama colaboración. los modelos secuencia son modelos dinámicos. . modelos máquina estado, que muestran cómo los objetos individuales cam- bian estado respuesta eventos. representan uml través diagramas estado. los modelos máquina estado son modelos dinámicos. modelo subsistema modelo estático útil, pues señala cómo está orga-nizado diseño grupos objetos relacionados lógicamente. figura . expuso este tipo modelo, para mostrar los subsistemas sistema del mapeo meteorológico. igual que los modelos subsistemas, puede diseñar también modelos objeto detallados, que presenten todos los objetos los sistemas sus asociaciones (herencia, generalización, agregación, etcétera). sin embargo, hay peligro hacer demasiado modelado. debe tomar decisiones detalladas acerca implementación que realidad debería dejarse los programadores del sistema. los modelos secuencia son modelos dinámicos que describen, para cada modo interacción, secuencia interacciones objeto que tienen lugar. cuando docu-menta diseño, debe producirse modelo secuencia por cada interacción signifi-cativa. usted desarrolló modelo caso uso, entonces debe haber modelo secuencia para cada caso uso que identifique. figura . ejemplo modelo secuencia, que muestra como diagrama secuencia uml. este diagrama indica secuencia interacciones que tienen lugar cuando sistema externo solicita los datos resumidos estación meteorológica. los diagramas secuencia leen arriba abajo: . objeto satcomms (comunicaciones satélite) recibe una petición del sistema información meteorológica para recopilar reporte del clima una estación :satcomms request (report) reconocimiento reportweather ( ) get (summary) reply (report) reconocimiento:weatherstation :commslink summarize ( ):weatherdata reconocimiento send (report) reconocimientosistema información meteorológica figura . diagrama secuencia que describe recolección datos -.indd -.indd // :: // :: . ■ diseño orientado objetos con uso del uml meteorológica. reconoce recepción esta petición. flecha continua mensaje enviado señala que sistema externo espera una respuesta, sino que puede realizar otro procesamiento. . satcomms envía mensaje weatherstation, vía vínculo satelital, para crear resumen los datos meteorológicos recolectados. nuevo, flecha continua indica que satcomms suspende espera una respuesta. . weatherstation envía mensaje objeto commslink (vínculos comunicacio- nes) para resumir los datos meteorológicos. este caso, punta flecha discon-tinua revela que instancia del objeto weatherstation espera una respuesta. . commslink llama método summarize (resumir) objeto weatherdata espera una respuesta. . resumen datos meteorológicos calcula regresa weatherstation vía objeto commslink. . weatherstation entonces llama objeto satcomms para transmitir los datos resu- midos sistema información meteorológica, través del sistema comunica-ciones satélite. los objetos satcomms weatherstation implementan como procesos concurren-tes, cuya ejecución puede suspenderse resumirse. instancia del objeto satcomms escucha los mensajes del sistema externo, decodifica dichos mensajes inicia operacio-nes estación meteorológica. los diagramas secuencia usan para modelar comportamiento combinado grupo objetos, pero quizá también desee resumir comportamiento objeto subsistema, respuesta mensajes eventos. para hacerlo, usa modelo máquina estado que muestre cómo instancia objeto cambia estado dependiendo los mensajes que recibe. uml incluye diagramas estado, inventados inicial-mente por harel () para describir modelos máquina estado. figura . diagrama estado para sistema estación meteorológica que indica cómo responde las peticiones varios servicios. puede leer este diagrama del siguiente modo: . estado del sistema shutdown (apagado), entonces puede responder men- saje restart(), reconfigure() powersave() (reiniciar, reconfigurar ahorrar energía, respectivamente). flecha sin etiqueta con burbuja negra evidencia que estado shutdown estado inicial. mensaje restart() causa una transición operación normal. los mensajes powersave() reconfigure() producen una transición estado donde sistema reconfigura mismo. diagrama estado muestra que reconfiguración sólo permite cuando sistema estado apagado. . estado running (operación), sistema espera más mensajes. recibe mensaje shutdown(), objeto regresa estado apagado. . capta mensaje reportweather() (reporte del clima), sistema avanza estado summarizing (resumir). cuando resumen está completo, sistema avanza hacia estado transmitting (transmisión), donde información transfiere sistema remoto. luego regresa estado running. -.indd -.indd // :: // :: capítulo ■ diseño implementación . recibe mensaje reportstatus() (reportar estatus), sistema avanza hacia estado testing (probar), luego estado transmitting, antes regresar estado running. . recibe una señal del reloj, sistema mueve hacia estado collecting (recolec- ción), donde recaba los datos los instrumentos. cada instrumento instruye vez para recolectar sus datos los sensores asociados. . recibe mensaje remotecontrol(), sistema avanza hacia estado controlado donde responde diferentes conjuntos mensajes desde sala control remoto. éstos muestran diagrama. los diagramas estado son modelos útiles alto nivel sistema operación objeto. por general, requiere diagrama estado para todos los obje-tos sistema. muchos los objetos sistema son relativamente simples modelo estado añade detalle innecesario diseño. .. especificación interfaz una parte importante cualquier proceso diseño especificación las interfaces entre los componentes diseño. necesario especificar las interfaces modo que los objetos subsistemas puedan diseñarse paralelo. una vez especificada interfaz, los desarrolladores otros objetos pueden suponer que implementará interfaz. diseño interfaz preocupa por especificación del detalle interfaz hacia objeto grupo objetos. esto significa definir las firmas semántica los transmisión realizadaremotecontrol ( ) reportstatus ( ) restart ( )shutdown ( ) prueba completa resumen meteorológicocompletoreloj recopilaciónrealizadaoperación reportweather ( )reconfigure ( ) powersave ( )configuración realizadashutdown running testing transmitting collecting summarizingcontrolado configuring figura . diagrama estado para estación meteorológica -.indd -.indd // :: // :: . ■ patrones diseño servicios que ofrecerá objeto grupo objetos. las interfaces pueden especifi- carse uml con misma notación diagrama clase. sin embargo, hay sección atributos debe incluirse estereotipo uml «interface» parte del nom-bre. semántica interfaz define mediante lenguaje restricción objeto (ocl). esto explica capítulo , donde estudia ingeniería software basada componentes. también muestra una forma alternativa para representar inter-faces uml. diseño interfaz deben incluir detalles representación datos, pues los atributos definen una especificación interfaz. sin embargo, debe con-tener operaciones para acceder los datos actualizarlos. puesto que representación datos está oculta, puede cambiar fácilmente sin afectar los objetos que usan dichos datos. esto conduce diseño que inherentemente más mantenible. por ejemplo, una representación arreglo pila puede cambiarse una representación lista, sin afectar otros objetos que usen pila. contraste, con frecuencia tiene sentido exponer los atributos modelo diseño estático, pues forma más compacta ilustrar las características esenciales los objetos. hay una relación simple : entre objetos interfaces. mismo objeto puede tener muchas interfaces, cada una las cuales punto vista los métodos que ofrece. esto soporta directamente java, donde las interfaces declaran por separado los objetos, los objetos “implementan” interfaces. igual modo, puede accederse grupo objetos través una sola interfaz. figura . indica dos interfaces que pueden definirse para estación meteoroló-gica. interfaz izquierda una interfaz reporte que precisa los nombres operación que usan para generar reportes del clima estatus. éstos mapean direc-tamente operaciones objeto weatherstation. interfaz control remoto propor-ciona cuatro operaciones, que mapean solo método objeto weatherstation. este caso, las operaciones individuales codifican cadena ( string) comando asociada con método remotecontrol, que muestra figura .. . patrones diseño los patrones diseño derivaron ideas planteadas por christopher alexander (alexander ., ), quien sugirió que había ciertos patrones comunes diseño construcción que eran relativamente agradables efectivos. patrón una descripción del problema esencia solución, modo que solución puede reutilizarse diferentes configuraciones. patrón una especificación detallada. más bien, puede «interfaz» control remoto startinstrument (instrument): istatus stopinstrument (instrument): istatus collectdata (instrument): istatus providedata (instrument): string«interfaz» reporte weatherreport (-ident): wreport statusreport (-ident): sreport figura . interfaces estación meteorológica -.indd -.indd // :: // :: capítulo ■ diseño implementación considerarla como descripción sabiduría experiencia acumuladas, una solución bien probada problema común. una cita del sitio web hillside group (http://hillside.net), que dedica mante-ner información acerca patrones, resume papel reutilización: los patrones los lenguajes patrón son formas describir mejores prácticas, buenos diseños, captan experiencia tal manera que posible que otros reutilicen esta experiencia. los patrones causaron enorme impacto diseño software orientado obje-tos. como son soluciones probadas problemas comunes, convirtieron vocabula-rio para hablar sobre diseño. por tanto, usted puede explicar diseño describir los patrones que utilizó. esto particular verdadero para los patrones diseño más cono-cidos que originalmente describió “banda los cuatro” libro patrones (gamma ., ). otras descripciones patrón especial importantes son las publicadas una serie libros por autores siemens, una gran compañía tecnológica europea (buschmann ., ; buschmann ., ; buschmann ., ; kircher jain, ; schmidt ., ). los patrones diseño asocian usualmente con diseño orientado objetos. los patrones publicados suelen apoyar características objetos como herencia polimorfismo para dar generalidad. sin embargo, principio universal encapsular nombre del patrón: observer descripción: separa despliegue del estado objeto del objeto permite ofrecimiento despliegues alternativos. cuando cambia estado del objeto, todos los despliegues notifican automáticamente actualizan para reflejar cambio. descripción del problema: muchas situaciones hay que proporcionar múltiples despliegues información del estado, tales como despliegue gráfico despliegue tabular. tal vez conozcan todos éstos cuando especifica información. todas las presentaciones alternativas deben soportar interacción , cuando cambia estado, los despliegues totalidad deben actualizarse. este patrón puede usarse todas las situaciones que requiera más formato despliegue para información del estado donde necesario que objeto mantenga información del estado para conocer sobre los formatos específicos despliegue utilizados. descripción solución: esto implica dos objetos abstractos, subject observer, dos objetos concretos, concretesubject (sujeto concreto) concreteobject (objeto concreto), que heredan los atributos los objetos abstractos relacionados. los objetos abstractos contienen operaciones generales que son aplicables todas las situaciones. estado desplegar mantiene concretesubject, que hereda operaciones subject permite agregar remover observers (cada observador corresponde despliegue) emite una notificación cuando cambia estado. concreteobserver (observador concreto) mantiene una copia del estado concretesubject implementa interfaz update() observer que permite que dichas copias conserven paso. concreteobserver automáticamente despliega estado refleja los cambios siempre que actualice estado. modelo uml del patrón ilustra figura .. consecuencias: sujeto sólo conoce observer abstracto los detalles clase concreta. por tanto, existe acoplamiento mínimo entre dichos objetos. debido esta falta conocimiento, son imprácticas las optimizaciones que mejoran rendimiento del despliegue. los cambios sujeto podrían generar conjunto actualizaciones vinculadas observadores, las cuales algunas quizá sean necesarias. figura . patrón observer (observador) -.indd -.indd // :: // :: . ■ patrones diseño experiencia patrón igualmente aplicable cualquier tipo diseño soft- ware. este modo, usted podría tener patrones configuración para sistemas cots. los patrones son una forma reutilizar conocimiento experiencia otros diseñadores. los cuatro elementos esenciales los patrones diseño, definidos por “banda los cuatro” libro patrones, son: . nombre que sea una referencia significativa patrón. . una descripción del área problemática que enuncie cuándo puede aplicarse patrón. . una descripción solución las partes solución diseño, sus relaciones responsabilidades. una descripción concreta diseño; una plantilla para que una solución diseño instale diferentes formas. esto con frecuencia expresa gráficamente muestra las relaciones entre los objetos las clases obje-tos solución. . estado las consecuencias, los resultados las negociaciones, aplicar patrón. anterior ayuda los diseñadores entender factible usar patrón una situación particular. gamma sus coautores descomponen descripción del problema motivación (una descripción del porqué útil patrón) aplicabilidad (una descripción las situaciones que puede usarse patrón). con descripción solución, explican estructura del patrón, los participantes, las colaboraciones implementación. para ilustrar descripción del patrón, texto usa patrón observer, tomado del libro gamma . (). esto muestra figura .. descripción del texto, emplean los cuatro elementos esenciales descripción también incluye breve enunciado sobre qué puede hacer patrón. este patrón utiliza situaciones donde requieren diferentes presentaciones del estado objeto. separa objeto que debe desplegarse las diferentes formas presentación. vemos figura ., que muestra dos presentaciones gráficas del mismo conjunto datos. las representaciones gráficas usan por general para explicar las clases obje-tos patrones sus relaciones. ello complementa descripción del patrón agrega observer observer : : : : abcd bcd figura . despliegues múltiples -.indd -.indd // :: // :: capítulo ■ diseño implementación detalles descripción solución. figura . representación uml del patrón observer. para usar patrones diseño, debe reconocer que cualquier problema diseño que enfrente posible que tenga patrón asociado para aplicarse. los ejemplos tales problemas, documentados libro patrones original “banda los cua-tro”, incluyen: . señalar varios objetos que cambiaron estado algún otro objeto (patrón observer). . ordenar las interfaces número objetos relacionados que menudo hayan desarrollado incrementalmente (patrón façade, fachada). . proporcionar una forma estándar para ingresar los elementos una colección, sin importar cómo implementó dicha colección (patrón iterator, iterador). . permitir posibilidad extender funcionalidad una clase existente tiempo operación (patrón decorator, decorador). los patrones soportan reutilización concepto alto nivel. cuando intente reutili- zar componentes ejecutables, estará restringido inevitablemente por decisiones diseño detalladas que los implementadores tomaron dichos componentes. éstas varían desde los algoritmos particulares usados para implementar los componentes, hasta los objetos tipos las interfaces del componente. cuando dichas decisiones diseño entran conflicto con los requerimientos particulares, reutilización componentes resulta imposible introduce ineficiencias sistema. uso patrones significa que reutilizan las ideas, pero podría adaptar implementación para ajustarse sistema que desarrolla. cuando usted comienza diseño sistema, quizá sea difícil saber, por adelan-tado, necesitará patrón particular. por tanto, uso patrones proceso diseño con frecuencia implica desarrollo diseño, experimentar problema , luego, reconocer que puede usarse patrón. efecto, esto posible enfoca los patrones propósito general documentados libro patrones original. sin subject observer attach (observer) detach (observer) notify ( )update ( ) concretesubject getstate ( ) subjectstateconcreteobserver update ( ) observerstateobserverstate = subject - getstate ( ) return subjectstatefor all observers - update ( ) figura . modelo uml del patrón observer -.indd -.indd // :: // :: . ■ conflictos implementación embargo, problema diferente, quizá descubra que difícil encontrar patrón adecuado entre los cientos patrones propuestos. los patrones son una gran idea, pero para usarlos manera efectiva necesita expe-riencia diseño software. hay que reconocer las situaciones donde aplicaría patrón. los programadores inexpertos, incluso leyeron los libros acerca patrones, siempre descubrirán que difícil decidir deben reutilizar patrón necesitan desa-rrollar una solución propósito especial. . conflictos implementación ingeniería software incluye todas las actividades implicadas desarrollo software, desde los requerimientos iniciales del sistema hasta mantenimiento administración del sistema desplegado. una etapa crítica este proceso , desde luego, implementación del sistema, cual crea una versión ejecutable del software. implementación quizá requiera desarrollo programas lenguajes programación alto bajo niveles, bien, personalización adaptación sistemas comerciales genéricos para cubrir los requerimientos específicos una organización. supone que mayoría los lectores este libro comprenderán los principios programación tendrán alguna experiencia respecto. como este capítulo tiene intención ofrecer enfoque independiente lenguaje, centró conflictos buena práctica programación, pues para esto tendrían que usar ejemplos espe-cíficos lenguaje. lugar, introducen algunos aspectos implementación que son muy importantes para ingeniería software que, por general, tocan los textos programación. éstos son: . reutilización mayoría del software moderno construye por reutilización los componentes sistemas existentes. cuando desarrolla software, debe usarse código existente tanto como sea posible. . administración configuración durante proceso desarrollo crean muchas versiones diferentes cada componente software. usted sigue huella dichas versiones sistema gestión configuración, estará proclive incluir sistema las versiones equivocadas dichos componentes. . desarrollo huésped-objetivo producción software ejecuta por general misma computadora que entorno desarrollo software. vez ello, diseña una computadora ( sistema huésped) ejecuta una computadora separada ( sistema objetivo). los sistemas huésped objetivo son algunas veces del mismo tipo, aunque suelen ser completamente diferentes. .. reutilización década , gran parte del nuevo software desarrolló desde cero, escribir todo código lenguaje programación alto nivel. única reutilización software significativo era reutilización funciones objetos las -.indd -.indd // :: // :: capítulo ■ diseño implementación librerías lenguaje programación. sin embargo, los costos presión por fechas significaban que este enfoque volvería cada vez más inviable, sobre todo para siste-mas comerciales basados internet. consecuencia, surgió enfoque desarrollo basado reutilización del software existente ahora emplea generalmente para sistemas empresariales, software científico , cada vez más, ingeniería sistemas embebidos. reutilización software posible algunos niveles diferentes: . nivel abstracción este nivel reutiliza software directamente, sino más bien utiliza conocimiento abstracciones exitosas diseño software. los patrones diseño los arquitectónicos (tratados capítulo ) son vías representación del conocimiento abstracto para reutilización. . nivel objeto este nivel reutilizan directamente los objetos una librería vez escribir uno mismo código. para implementar este tipo reutilización, deben encontrar librerías adecuadas descubrir los objetos métodos ofrecen funcionalidad que necesita. por ejemplo, usted requiere procesar mensajes correo programa java, tiene que usar objetos métodos una librería javamail. . nivel componente los componentes son colecciones objetos clases objetos que operan conjunto para brindar funciones servicios relacionados. con frecuencia debe adaptar extender componente agregar por cuenta pro-pia cierto código. ejemplo reutilización nivel componente donde usted construye interfaz usuario mediante marco. éste conjunto clases objetos generales que aplica manipulación eventos, gestión despliegue, etcétera. agrega conexiones los datos desplegar escribe código para definir detalles despliegue específicos, como plantilla pantalla colores. . nivel sistema este nivel reutilizan sistemas aplicación completos. usualmente esto implica cierto tipo configuración dichos sistemas. puede hacerse agregar modificar código ( reutiliza una línea producto soft-ware) usar interfaz configuración característica del sistema. mayoría los sistemas comerciales diseñan ahora esta forma, donde adapta reutilizan sistemas cots (comerciales) genéricos. veces este enfoque puede incluir reuti-lización muchos sistemas diferentes integrarlos para crear nuevo sistema. reutilizar software existente, factible desarrollar nuevos sistemas más rápi-damente, con menos riesgos desarrollo también costos menores. puesto que soft-ware reutilizado probó otras aplicaciones, debe ser más confiable que software nuevo. sin embargo, existen costos asociados con reutilización: . los costos del tiempo empleado búsqueda del software para reutilizar valorar cubre sus necesidades . posible que deba poner prueba software para asegurarse que funcionará entorno, especialmente éste diferente entorno desarrollo. . donde sea aplicable, los costos por comprar software reutilizable. para sistemas comerciales grandes, dichos costos suelen ser muy elevados. -.indd -.indd // :: // :: . ■ conflictos implementación . los costos por adaptar configurar los componentes software sistemas reutili- zables, con finalidad reflejar los requerimientos del sistema que desarrolla. . los costos integrar elementos software reutilizable unos con otros ( usa soft- ware diferentes fuentes) con nuevo código que haya desarrollado. integrar software reutilizable diferentes proveedores suele ser difícil costoso, que los proveedores podrían hacer conjeturas conflictivas sobre cómo reutilizará software respectivo. cómo reutilizar conocimiento software existentes sería primer punto con-siderar cuando inicie proyecto desarrollo software. hay que contemplar las posibilidades reutilización antes diseñar software detalle, pues tal vez usted quiera adaptar diseño para reutilización los activos software existentes. como estudió capítulo , proceso desarrollo orientado reutilización uno busca elementos reutilizables , luego, modifica los requerimientos diseño para hacer mejor uso ellos. para gran número sistemas aplicación, ingeniería software significa realidad reutilización software. consecuencia, este libro dedican este tema varios capítulos sección tecnologías software (capítulos , ). .. administración configuración desarrollo software, los cambios ocurren todo tiempo, modo que adminis-tración del cambio absolutamente esencial. cuando equipo individuos desarrolla software, hay que cerciorarse que los miembros del equipo interfieran con trabajo los demás. esto , dos personas trabajan sobre componente, los cambios deben coordinarse. otro modo, programador podría realizar cambios sobrescribir trabajo otro. también debe garantizar que todos tengan acceso las versiones más actualizadas componentes software; contrario, los desarrolladores pueden rehacer hecho. cuando algo salga mal con una nueva versión sistema, debe poder retroceder una versión operativa del sistema componente. administración configuración nombre dado proceso general gestio-nar sistema software cambiante. meta administración configuración apoyar proceso integración del sistema, modo que todos los desarrolladores tengan acceso una forma controlada código del proyecto los documentos, des-cubrir qué cambios realizaron, así como compilar vincular componentes para crear sistema. por tanto, hay tres actividades fundamentales administración configuración: . gestión versiones, donde soporte para hacer seguimiento las diferen- tes versiones los componentes software. los sistemas gestión versiones incluyen facilidades para que desarrollo esté coordinado por varios programado-res. esto evita que desarrollador sobrescriba código que haya sido enviado sistema por alguien más. . integración sistema, donde soporte para ayudar los desarrolladores defi- nir qué versiones componentes usan para crear cada versión sistema. luego, esta descripción utiliza para elaborar automáticamente sistema com-pilar vincular los componentes requeridos. -.indd -.indd // :: // :: capítulo ■ diseño implementación . rastreo problemas, donde soporte para que los usuarios reporten bugs otros problemas, también para que todos los desarrolladores sepan quién trabaja dichos problemas cuándo corrigen. las herramientas administración configuración software soportan cada una las actividades anteriores. dichas herramientas pueden diseñarse para trabajar conjunto sistema gestión cambio global, como clearcase (bellagio milligan, ). los sistemas administración configuración integrada, dise-ñan conjunto las herramientas gestión versiones, integración sistema ras-treo del problema. comparten estilo interfaz usuario integran través repositorio código común. alternativamente, pueden usarse herramientas por separado, instaladas entorno desarrollo integrado. gestión versiones puede soportarse mediante sistema gestión versiones como subversion (pilato ., ), que puede soportar desarrollo multisitio multiequipo. soporte integración sistema podría construirse lenguaje apoyarse conjunto herramientas por separado, como sistema construcción gnu. esto incluye que quizá sea herramienta integración mejor conocida, hecha unix. rastreo bugs los sistemas rastreo conflictos, como bugzilla, usan para reportar bugs otros conflictos, así como para seguir pista sobre corrigieron . virtud importancia ingeniería software profesional, capítulo analizan con más detenimiento administración configuración del cambio. .. desarrollo huésped-objetivo mayoría del desarrollo software basa modelo huésped-objetivo. software desarrolla una computadora ( huésped), aunque opera una máquina separada ( objetivo). sentido más amplio, puede hablarse una plataforma desarrollo una plataforma ejecución. una plataforma más que sólo hardware. incluye sistema operativo instalado más otro software soporte como sistema gestión base datos , para plataformas desarrollo, entorno desarrollo interactivo. ocasiones, las plataformas desarrollo ejecución son iguales, que posibilita dise-ñar software ponerlo prueba misma máquina. sin embargo, más común que sean diferentes, modo que necesario mover software desarrollado plataforma ejecución para ponerlo prueba, operar simulador máquina desarrollo. los simuladores usan con frecuencia elaborar sistemas embebidos. simu-lan dispositivos hardware, tales como sensores, los eventos entorno donde sistema podrá funcionamiento. los simuladores aceleran proceso desarrollo para sistemas embebidos, pues cada desarrollador puede contar con propia plataforma ejecución, sin tener que descargar software hardware objetivo. obstante, los simuladores son costosos desarrollar , por tanto, menudo sólo encuentran disponibles para las arquitecturas hardware más conocidas. sistema objetivo tiene instalado middleware otro software que necesite usar, tal caso sistema debe poner prueba utilizando dicho software. tal vez resulte práctico instalar dicho software máquina desarrollo, incluso misma que plataforma objetivo, debido restricciones licencia. ante tales circunstancias, usted necesita transferir código desarrollado plataforma ejecución, con finalidad poner prueba sistema. -.indd -.indd // :: // :: . ■ conflictos implementación una plataforma desarrollo software debe ofrecer una variedad herramientas para soportar los procesos ingeniería software. éstas pueden incluir: . compilador integrado sistema edición dirigida por sintaxis que permi- tan crear, editar compilar código. . sistema depuración lenguaje. . herramientas edición gráfica, tales como las herramientas para editar modelos uml. . herramientas prueba, como junit (massol, ) que operen automáticamente conjunto pruebas sobre una nueva versión programa. . herramientas apoyo proyecto que ayuden organizar código para dife- rentes proyectos desarrollo. igual que dichas herramientas estándar, sistema desarrollo puede incluir herra- mientas más especializadas, como analizadores estáticos (que estudian capítulo ). normalmente, los entornos desarrollo para equipos también contemplan servi-dor compartido que opera sistema administración del cambio configuración , acaso, sistema para soportar gestión requerimientos. las herramientas desarrollo software agrupan con frecuencia para crear entorno desarrollo integrado (ide), que conjunto herramientas software que apoyan diferentes aspectos del desarrollo software, dentro cierto marco común interfaz usuario. por común, los ide crean para apoyar desarrollo lenguaje programación específico, como java. lenguaje ide puede elaborarse espe-cialmente, ser una ejemplificación ide propósito general, con herramientas apoyo lenguaje específico. ide propósito general marco para colocar herramientas software, que brinden facilidades gestión datos para software desarrollar, mecanismos integración, que permitan las herramientas trabajar conjunto. entorno eclipse (carlson, ) ide propósito general mejor conocido. este entorno basa una arquitectura conexión ( plug-), modo que pueda especializarse para diferentes lenguajes dominios aplicación (clayberg rubel, ). por consiguiente, posi-ble instalar eclipse personalizarlo según sus necesidades específicas agregar plug-ins (enchufables conectables), para soportar desarrollo sistemas red java ingeniería sistemas embebidos usando . como parte del proceso desarrollo, requiere tomar decisiones sobre cómo des-plegará software desarrollado plataforma objetivo. esto directo para sistemas diagramas despliegue uml los diagramas despliegue uml muestran cómo los componentes software despliegan físicamente los procesadores; decir, diagrama despliegue muestra hardware software sistema, así como middleware usado para conectar los diferentes componentes sistema. esencia, los diagramas despliegue pueden considerar como una forma definir documentar entorno objetivo. http:// -.indd -.indd // :: // :: capítulo ■ diseño implementación embebidos, donde objetivo usualmente una sola computadora. sin embargo, para sistemas distribuidos, necesario decidir sobre las plataformas específicas donde desplegarán los componentes. los conflictos que hay que considerar tomar esta deci-sión son: . los requerimientos hardware software componente componente diseña para una arquitectura hardware específica, apoya algún otro sis-tema software, tiene que desplegarse por supuesto una plataforma que brinde soporte requerido hardware software. . los requerimientos disponibilidad del sistema los sistemas alta disponibili-dad pueden necesitar que los componentes desplieguen más una plataforma. esto significa que, caso una falla plataforma, esté disponible una imple-mentación alternativa del componente. . comunicaciones componentes hay alto nivel tráfico comunicacio-nes entre componentes, por general tiene sentido desplegarlos misma pla-taforma plataformas que estén físicamente cercanas entre . esto reduce latencia comunicaciones, decir, demora entre tiempo que transcurre desde momento que componente envía mensaje hasta que otro recibe. puede documentar sus decisiones sobre despliegue hardware software usando diagramas despliegue uml, que muestran cómo los componentes software dis-tribuyen través plataformas hardware. desarrolla sistema embebido, quizá deba tomar cuenta las características del objetivo, como tamaño físico, capacidades poder, necesidad respuestas tiempo real para eventos sensor, características físicas los actuadores, sistema operativo tiempo real. capítulo estudia ingeniería los sistemas embebidos. . desarrollo código abierto desarrollo código abierto enfoque desarrollo software que publica código sistema software invita voluntarios participar proceso desarrollo (raymond, ). sus raíces están free software foundation (http:// que aboga porque código fuente debe ser propietario sino, más bien, tiene que estar siempre disponible para que los usuarios examinen modifiquen como deseen. existía idea que código estaría controlado sería desarrollado por pequeño grupo central, vez por usuarios del código. software código abierto extendió esta idea usar internet para reclutar una población mucho mayor desarrolladores voluntarios. mayoría ellos también son usuarios del código. principio menos, cualquier contribuyente proyecto código abierto puede reportar corregir bugs, así como proponer nuevas características funcionalidades. sin embargo, práctica, los sistemas exitosos código abierto aún apoyan grupo central desarrolladores que controlan los cambios software. desde luego, producto mejor conocido código abierto sistema operativo linux, utilizado ampliamente como sistema servidor , cada vez más, como entorno escritorio. otros productos código abierto importantes son java, servidor web -.indd -.indd // :: // :: . ■ desarrollo código abierto apache sistema gestión base datos mysql. los protagonistas principales industria cómputo, como ibm sun, soportan movimiento código abierto basan software productos código abierto. existen miles otros sistemas componentes código abierto menos conocidos que también podrían usarse. por general, muy barato incluso gratuito adquirir software código abierto. usualmente, software código abierto descarga sin costo. sin embargo, usted quiere documentación soporte, entonces tal vez deba pagar por ello; aún así, los costos son por común bastante bajos. otro beneficio clave para usar productos código abierto que los sistemas código abierto mayores son casi siempre muy confiables. razón esto una gran población usuarios que quiere corregir los problemas por misma, lugar reportarlos desarrollador esperar una nueva versión del sistema. los bugs descubren reparan con más rapidez que que normalmente sería posible con software propietario. para una compañía que desarrolla software, existen dos conflictos código abierto que debe considerar: . ¿ producto que desarrollará deberá usar componentes código abierto? . ¿deberá usarse enfoque código abierto para desarrollo del software? las respuestas dichas preguntas dependen del tipo software que desarrollará, así como los antecedentes experiencia del equipo desarrollo. usted diseña producto software para venta, entonces resultan críticos tanto tiempo que sale mercado como reducción costos. desarrolla dominio donde estén disponibles sistemas código abierto alta calidad, puede aho-rrar tiempo dinero usar dichos sistemas. sin embargo, usted desarrolla software para conjunto específico requerimientos organizativos, entonces quizás uso componentes código abierto sea una opción. tal vez tenga que integrar software con sistemas existentes que sean compatibles con los sistemas código abierto disponi-bles. obstante, incluso entonces podría ser más rápido barato modificar sistema código abierto, vez volver desarrollar funcionalidad que necesita. cada vez más compañías productos usan enfoque código abierto para desarrollo. sus modelos empresariales dependen venta producto soft-ware, sino comercialización del soporte para dicho producto. consideran que invo-lucrar comunidad código abierto permitirá que software desarrolle manera más económica, más rápida creará una comunidad usuarios para software. pesar ello, nuevo, esto sólo aplicable realmente para productos software general, para aplicaciones específicas organización. muchas compañías creen que adoptar enfoque código abierto revelará conoci-miento empresarial confidencial sus competidores , por consiguiente, son reticentes adoptar tal modelo desarrollo. obstante, usted trabaja una pequeña compañía abre fuente software, esto puede garantizar los clientes que podrán soportar software caso que compañía salga del mercado. publicar código sistema significa que comunidad general necesa-riamente ayudará con desarrollo. los productos más exitosos código abierto han sido productos plataforma, vez sistemas aplicación. hay número limi-tado desarrolladores que pueden interesarse sistemas aplicación especializa-dos. , elaborar sistema software código abierto garantiza inclusión comunidad. -.indd -.indd // :: // :: capítulo ■ diseño implementación .. licencia código abierto aunque principio fundamental del desarrollo código abierto que código fuente debe estar disponible por entero, esto significa que cualquiera puede hacer que desee con código. por ley, desarrollador del código (una compañía individuo) todavía propietario del código. puede colocar restricciones sobre cómo utiliza incluir condiciones legales una licencia software código abierto (. laurent, ). algunos desarrolladores código abierto creen que componente código abierto usa para desarrollar nuevo sistema, entonces dicho sistema también debe ser código abierto. otros están satisfechos que código use sin esta restricción. los sistemas desarrollados pueden ser propietarios venderse como sistemas código cerrado. mayoría las licencias código abierto derivan uno tres modelos gene-rales: . licencia pública general gnu conoce como licencia “recíproca”; manera simple, significa que usted usa software código abierto que esté permitido bajo licencia gpl, entonces debe hacer que dicho software sea código abierto. . licencia pública menos general gnu una variante licencia anterior, que usted puede escribir componentes que vinculen con código abierto, sin tener que publicar código dichos componentes. sin embargo, cambia com-ponente permitido, entonces debe publicar éste como código abierto. . licencia berkeley standard distribution una licencia recíproca, cual sig- nifica que usted está obligado volver publicar algún cambio modificación código abierto. puede incluir código sistemas propietarios que vendan. usa componentes código abierto, debe reconocer creador original del código. los temas sobre permisos son importantes porque usa software código abierto como parte producto software, entonces tal vez esté obligado por los términos licencia hacer que propio producto sea código abierto. trata vender software, quizá desee mantenerlo secreto. esto significa que tal vez quiera evitar uso software código abierto con licencia gpl desarrollo. construye software que opere una plataforma código abierto, como linux, tal caso las licencias son problema. sin embargo, tan pronto como comience incluir componentes código abierto software, necesita establecer procesos bases datos para seguir pista que usó sus condiciones licencia. bayersdorfer () sugiere que las compañías que administran proyectos que usan código abierto deben: . establecer sistema para mantener información sobre los componentes código abierto que descargan usan. tienen que conservar una copia licen- cia para cada componente que sea válida momento que usó componente. las licencias suelen cambiar, así que necesita conocer las condiciones acordadas. . estar tanto los diferentes tipos licencias entender cómo está autorizado componente antes usarlo. puede decidir uso componente sistema, pero otro, porque planea usar dichos sistemas diferentes formas. -.indd -.indd // :: // :: pmcapítulo ■ puntos clave . estar tanto las rutas evolución para los componentes. necesita conocer poco sobre proyecto código abierto donde desarrollaron los componentes, para entender cómo pueden cambiar futuro. . educar personal acerca del código abierto. suficiente tener procedimientos para asegurar cumplimiento las condiciones licencia. también preciso educar los desarrolladores sobre código abierto permiso éste. . tener sistemas auditoría. los desarrolladores, con plazos ajustados, pueden sen- tirse tentados quebrantar los términos una licencia. posible, debe tener software para detectar evitar esto último. . participar comunidad código abierto. apoya productos código abierto, debe participar comunidad ayudar apoyar desarrollo. modelo empresarial software está cambiando. vuelto cada vez más difícil edificar una empresa mediante venta sistemas software especializado. muchas compañías prefieren hacer software código abierto entonces vender soporte consultoría los usuarios del software. probable que esta tendencia incremente, con uso creciente software código abierto con cada vez más software disponible esta forma. puntos clave ■ diseño implementación del software son actividades entrelazadas. nivel detalle diseño depende del tipo sistema desarrollar usa enfoque dirigido por plan uno ágil. ■ los procesos del diseño orientado objetos incluyen actividades para diseñar arquitectura del sistema, identificar objetos sistema, describir diseño mediante diferentes modelos objeto documentar las interfaces componente. ■ durante proceso diseño orientado objetos, puede elaborarse una variedad modelos diferentes. ellos incluyen modelos estáticos (modelos clase, modelos generalización, modelos asociación) modelos dinámicos (modelos secuencia, modelos máquina estado). ■ las interfaces componente deben definirse con precisión, modo que otros objetos puedan usarlos. para definir interfaces posible usar estereotipo interfaz uml. ■ cuando desarrolla software, siempre debe considerarse posibilidad reutilizar software existente, sea como componentes, servicios sistemas completos. ■ administración configuración proceso gestionar los cambios sistema software evolución. esencial cuando equipo personas coopera para desarrollar software. -.indd -.indd // :: // :: capítulo ■ diseño implementación ■ mayoría del desarrollo software desarrollo huésped-objetivo. usa ide una máquina para desarrollar huésped, que transfiere una máquina objetivo para ejecución. ■ desarrollo código abierto requiere hacer públicamente disponible código fuente sistema. esto significa que muchos individuos tienen posibilidad proponer cambios mejoras software. lecturas sugeridas design patterns: elements reusable object-oriented software. éste manual original patrones hardware que introdujo los patrones software una amplia comunidad. (. gamma, . helm, . johnson . vlissides, addison-wesley, .) applying uml and patterns: introduction object-oriented analysis and design and iterative development, edition. larman escribe claramente sobre diseño orientado objetos también analiza uso del uml. ésta una buena introducción uso patrones proceso diseño. (. larman, prentice hall, .) producing open source software: how run successful free software project. este libro una guía completa los antecedentes del software código abierto, los conflictos permiso las prácticas operar proyecto desarrollo código abierto. (. fogel, ’reilly media inc., .) capítulo sugieren más lecturas acerca reutilización software, capítulo otras referentes administración configuración. ejercicios .. con notación estructurada que muestra figura ., especifique los casos uso estación meteorológica para report status (reporte estatus) reconfigure (reconfigurar). tiene que hacer conjeturas razonables acerca funcionalidad que requiere aquí. .. suponga que mhc-pms desarrollará usando enfoque orientado objetos. dibuje diagrama caso uso, que muestre menos seis posibles casos uso para este sistema. .. con notación gráfica uml para clases objetos, diseñe las siguientes clases objetos, identifique los atributos las operaciones. use experiencia para decidir sobre los atributos las operaciones que deban asociarse con estos objetos: ■ teléfono. ■ impresora para computadora personal. ■ sistema estéreo personal. ■ cuenta bancaria. ■ catálogo biblioteca. -.indd -.indd // :: // :: pmcapítulo ■ referencias .. con los objetos estación meteorológica, identificados figura . como punto partida, identifique más objetos que puedan usarse este sistema. diseñe una jerarquía herencia para los objetos que haya identificado. .. desarrolle diseño estación meteorológica para mostrar interacción entre subsistema recolección datos los instrumentos que recolectan datos meteorológicos. utilice diagramas secuencia para mostrar esta interacción. .. identifique posibles objetos los siguientes sistemas desarrolle para ellos diseño orientado objetos. puede hacer conjeturas razonables sobre los sistemas cuando derive diseño. ■ sistema diario grupal administración del tiempo tiene intención apoyar los horarios las reuniones citas grupo compañeros trabajo. cuando hace una cita para muchas personas, sistema encuentra espacio común cada uno sus diarios arregla cita para esa hora. hay espacios comunes disponibles, interactúa con usuario para reordenar diario personal, con finalidad hacer espacio para cita. ■ una estación llenado (estación gasolina) configurará para operación completamente automatizada. los conductores pasan tarjeta crédito través lector conectado bomba gasolina; tarjeta verifica mediante comunicación con una computadora compañía crédito, establece límite combustible. luego, conductor puede tomar combustible requerido. cuando completa entrega combustible manguera bomba regresa soporte, costo del combustible surtido carga cuenta tarjeta crédito del conductor. tarjeta crédito regresa después deducción. tarjeta inválida, bomba devuelve antes despachar combustible. .. dibuje diagrama secuencia que muestre las interacciones los objetos sistema diario grupal, cuando grupo individuos organizan una reunión. .. dibuje diagrama estado uml que señale los posibles cambios estado diario grupal sistema llenado estación. .. con ejemplos, explique por qué importante administración configuración, cuando equipo individuos desarrolla producto software. .. una pequeña compañía desarrolló producto especializado que configura manera especial para cada cliente. los clientes nuevos, por general, tienen requerimientos específicos para incorporar sistema, pagan para que esto desarrolle. compañía tiene oportunidad licitar para nuevo contrato, cual representaría más del doble base clientes. nuevo cliente también quiere tener cierta participación configuración del sistema. explique por qué, estas circunstancias, puede ser buena idea que compañía que posee software convierta código abierto. referencias abbott, . (). “program design informal english descriptions”. comm. acm, (), –. alexander, ., ishikawa, . silverstein, . (). pattern language: towns, building, construction. oxford: oxford university press. -.indd -.indd // :: // :: capítulo ■ diseño implementación bayersdorfer, . (). “managing project with open source components”. acm interactions, (), –. beck, . cunningham, . (). “ laboratory for teaching object-oriented thinking”. proc. oopsla’ (conference object-oriented programming, systems, languages and applications), acm press. –. bellagio, . . milligan, . . (). software configuration management strategies and ibm rational clearcase: practical introduction. boston: pearson education (ibm press). buschmann, ., henney, . schmidt, . . (). pattern-oriented software architecture volume : pattern language for distributed computing. new york: john wiley & sons. buschmann, ., henney, . schmidt, . . (). pattern-oriented software architecture volume : patterns and pattern languages. new york: john wiley & sons. buschmann, ., meunier, ., rohnert, . sommerlad, . (). pattern-oriented software architecture volume : system patterns. new york: john wiley & sons.carlson, . (). eclipse distilled. boston: addison-wesley.clayberg, . rubel, . (). eclipse: building commercial-quality plug-ins. boston: addison wesley.coad, . yourdon, . (). object-oriented analysis. englewood cliffs, : prentice hall.gamma, ., helm, ., johnson, . vlissides, . (). design patterns: elements reusable object-oriented software. reading, mass.: addison-wesley. harel, . (). “statecharts: visual formalism for complex systems”. sci. comput. programming, (), –.kircher, . jain, . (). pattern-oriented software architecture volume : patterns for resource management. new york: john wiley & sons. massol, . (). junit action. greenwich, : manning publications.pilato, ., collins-sussman, . fitzpatrick, . (). version control with subversion. sebastopol, calif.: ’reilly media inc. raymond, . . (). the cathedral and the bazaar: musings linux and open source accidental revolutionary. sebastopol. calif.: ’reilly media, inc. schmidt, ., stal, ., rohnert, . buschmann, . (). pattern-oriented software architecture volume : patterns for concurrent and networked objects. new york: john wiley & sons. shlaer, . mellor, . (). object-oriented systems analysis: modeling the world data. englewood cliffs, : yourdon press.. laurent, . (). understanding open source and free software licensing. sebastopol, calif.: ’reilly media inc.wirfs-brock, ., wilkerson, . weiner, . (). designing object-oriented software. englewood cliffs, : prentice hall. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo las pruebas del software los procesos necesarios para tales pruebas. estudiar este capítulo: ■ comprenderá las etapas las pruebas, desde las pruebas durante desarrollo hasta prueba aceptación por los clientes del sistema; ■ introducirá las técnicas que ayudan elegir casos prueba que ponen funcionamiento para descubrir los defectos del programa; ■ entenderá desarrollo primera prueba, donde diseñan pruebas antes escribir código, las cuales operan automáticamente; ■ conocerá las diferencias importantes entre pruebas componente, sistema liberación, estará tanto los procesos las técnicas prueba del usuario. contenido . pruebas desarrollo . desarrollo dirigido por pruebas . pruebas versión . pruebas usuario pruebas software -.indd -.indd // :: // :: capítulo ■ pruebas software las pruebas intentan demostrar que programa hace que intenta que haga, así como descubrir defectos programa antes usarlo. probar software, ejecuta programa con datos artificiales. hay que verificar los resultados prueba que opera para buscar errores, anomalías información atributos funcionales del programa. proceso prueba tiene dos metas distintas: . demostrar desarrollador cliente que software cumple con los requerimien- tos. para software personalizado, esto significa que documento reque- rimientos debe haber, por menos, una prueba por cada requerimiento. para los productos software genérico, esto quiere decir que tiene que haber pruebas para todas las características del sistema, junto con combinaciones dichas característi-cas que incorporarán liberación del producto. . encontrar situaciones donde comportamiento del software sea incorrecto, inde-seable esté acuerdo con especificación. tales situaciones son consecuen-cia defectos del software. prueba defectos tiene finalidad erradicar comportamiento indeseable del sistema, como caídas del sistema, interacciones indeseadas con otros sistemas, cálculos incorrectos corrupción datos. primera meta conduce prueba validación; ella, espera que sistema desempeñe manera correcta mediante conjunto dado casos prueba, que refleje uso previsto del sistema. segunda meta orienta pruebas defectos, donde los casos prueba diseñan para presentar los defectos. los casos prueba las pruebas defecto pueden ser deliberadamente confusos necesitan expresar cómo usa normalmente sistema. desde luego, hay frontera definida entre estos dos enfoques pruebas. durante las pruebas validación, usted descubrirá defectos sistema; tanto que durante las pruebas defecto algunas las pruebas demostra-rán que programa cumple con sus requerimientos. diagrama figura . ayuda explicar las diferencias entre las pruebas vali-dación defecto. piense sistema que probar como fuera una caja negra. sistema acepta entradas desde algún conjunto entradas genera salidas con-junto salidas . algunas las salidas serán erróneas. son las salidas conjunto que sistema genera respuesta las entradas conjunto . prioridad las pruebas defecto encontrar dichas entradas conjunto porque ellas revelan problemas con sistema. las pruebas validación involucran pruebas con entradas correctas que están fuera estimulan sistema para generar las salidas correc- tas previstas. las pruebas pueden demostrar que software esté exento defectos que comportará como especifica cualquier circunstancia. siempre posible que una prueba que usted pase por alto descubra más problemas con sistema. como afirma forma elocuente edsger dijkstra, uno los primeros contribuyentes desarrollo ingeniería software (dijkstra ., ): las pruebas pueden mostrar sólo presencia errores, mas ausencia. las pruebas consideran parte proceso más amplio verificación validación (&) del software. aunque ambas son mismo, confunden con frecuencia. barry -.indd -.indd // :: // :: pmboehm, pionero ingeniería software, expresó manera breve diferencia entre las dos (boehm, ): ■ “validación: ¿construimos producto correcto?”. ■ “verificación: ¿construimos bien producto?”. los procesos verificación validación buscan comprobar que software por desa-rrollar cumpla con sus especificaciones, brinde funcionalidad deseada por las perso-nas que pagan por software. dichos procesos comprobación comienzan tan pronto como están disponibles los requerimientos continúan través todas las etapas del proceso desarrollo. finalidad verificación comprobar que software cumpla con funciona-lidad con los requerimientos funcionales establecidos. sin embargo, validación proceso más general. meta validación garantizar que software cumpla con las expectativas del cliente. más allá del simple hecho comprobar confor-midad con especificación, para demostrar que software hace que cliente espera que haga. validación esencial pues, como estudió capítulo , las especifi-caciones requerimientos siempre reflejan los deseos las necesidades reales los clientes usuarios del sistema. objetivo final los procesos verificación validación establecer confianza que sistema software “adecuado”. esto significa que sistema tiene que ser bas-tante eficaz para uso esperado. nivel confianza adquirido depende tanto del pro - del sistema las expectativas los usuarios del sistema, como del entorno del rca actual para sistema: . propósito del software cuanto más crítico sea software, más importante debe ser confiabilidad. por ejemplo, nivel confianza requerido para que use software control sistema crítico seguridad mucho mayor que requerido para prototipo desarrollado para demostrar nuevas ideas del producto. . expectativas del usuario debido experiencia con software confiable pla-gado errores, muchos usuarios tienen pocas expectativas calidad del software, por que sorprenden cuando éste falla. instalar sistema, los usuarios salida resultados pruebasalidas que revelan presencia dedefectosoeentrada datos prueba sistemaentradas que provocancomportamientoanómalo figura . modelo entrada salida una prueba programacapítulo ■ pruebas software -.indd -.indd // :: // :: capítulo ■ pruebas software podrían soportar fallas, porque los beneficios del uso exceden los costos recu- peración fallas. ante tales situaciones, necesario dedicar mucho tiempo puesta prueba del software. sin embargo, conforme software completa, los usuarios esperan que torne más confiable, modo que pueden requerirse prue-bas exhaustivas versiones posteriores. . entorno mercado cuando sistema comercializa, los vendedores del sis-tema deben considerar los productos competitivos, precio que los clientes están dispuestos pagar por sistema fecha requerida para entregar dicho sistema. ambiente competitivo, una compañía software puede decidir lanzar mer-cado programa antes estar plenamente probado depurado, pues quiere que sus productos sean los primeros ubicarse. producto software muy económico, los usuarios tal vez toleren nivel menor fiabilidad. igual que las pruebas software, proceso verificación validación impli-caría inspecciones revisiones software. estas últimas analizan comprueban los requerimientos del sistema, los modelos diseño, código fuente del programa, incluso las pruebas propuestas para sistema. éstas son las llamadas técnicas & “estáticas” donde necesario ejecutar software para verificarlo. figura . indica que las inspecciones las pruebas del software soportan & diferentes eta-pas del proceso del software. las flechas señalan las etapas del proceso que pueden usarse las técnicas. las inspecciones enfocan principalmente código fuente sistema, aun cuando cualquier representación legible del software, como sus requerimientos modelo diseño, logre inspeccionarse. cuando sistema inspecciona, utiliza conoci-miento del sistema, dominio aplicación lenguaje programación modelado para descubrir errores. hay tres ventajas inspección del software sobre las pruebas: . durante las pruebas, los errores pueden enmascarar (ocultar) otras fallas. cuando error lleva salidas inesperadas, nunca podrá asegurar las anomalías salida posteriores deben nuevo error son efectos colaterales del error original. puesto que inspección proceso estático, hay que preocuparse por las inte-racciones entre errores. consecuencia, una sola sesión inspección descubriría muchos errores sistema.modelos diseño umlarquitectura softwareespecificacion requerimientosesquemas base datosprograma prototipo sistemapruebasinspecciones figura . inspecciones pruebas -.indd -.indd // :: // :: . las versiones incompletas sistema pueden inspeccionar sin costos adicio- nales. programa está incompleto, entonces necesario desarrollar equipos prueba especializados para poner prueba las partes disponibles. evidentemente, esto genera costos para desarrollo del sistema. . además buscar defectos programa, una inspección puede considerar también atributos más amplios calidad programa, como cumplimiento con están-dares, portabilidad mantenibilidad. pueden buscarse ineficiencias, algoritmos inadecuados estilos programación imitados que hagan sistema difícil man-tener actualizar. las inspecciones programa son una idea antigua mayoría estudios experi-mentos indican que las inspecciones son más efectivas para descubrimiento defec-tos, que para las pruebas del programa. fagan () reportó que más del % los errores programa detectan mediante inspecciones informales programa. proceso cleanroom (cuarto limpio) (prowell ., ) afirma que más del % los defectos pueden detectarse inspecciones del programa. sin embargo, las inspecciones sustituyen las pruebas del software, que son eficaces para descubrir defectos que surjan por interacciones inesperadas entre diferentes partes programa, problemas temporización dificultades con rendimiento del sistema. más aún, compañías grupos desarrollo pequeños, suele ser espe-cialmente difícil costoso reunir equipo inspección separado, que todos los miembros potenciales del equipo también podrían ser desarrolladores software. capítulo (“gestión calidad”) estudian las revisiones inspecciones con más detenimiento. capítulo explica análisis estático automatizado, cual texto fuente programa analiza automáticamente para descubrir anomalías. este capítulo enfoca las pruebas los procesos pruebas. figura . presenta modelo abstracto del proceso prueba “tradicional”, como utiliza desarrollo dirigido por plan. los casos prueba son especificaciones las entradas prueba salida esperada del sistema (los resultados prueba), además información sobre que pone prueba. los datos prueba son las entradas que diseñaron para probar sistema. ocasiones pueden generarse automáticamente datos prueba; obstante, imposible generación automática casos prueba, pues debe estar implicada gente que entienda que supone que tiene que hacer sis-tema para especificar los resultados prueba previstos. sin embargo, posible automa-tizar ejecución pruebas. los resultados previstos comparan automáticamente con los resultados establecidos, manera que haya necesidad que individuo busque errores anomalías correr las pruebas.planeación pruebas planeación pruebas interesa por fecha los recursos todas las actividades durante proceso pruebas. incluye definición del proceso pruebas, tomar cuenta tanto personal como tiempo disponible. por general, creará plan prueba que define que debe probarse, fecha establecida pruebas cómo registrarán éstas. para sistemas críticos, plan prueba también puede incluir detalles las pruebas que van correr software. http:// ■ pruebas software -.indd -.indd // :: // :: capítulo ■ pruebas software por general, sistema software comercial debe pasar por tres etapas pruebas: . pruebas desarrollo, donde sistema pone prueba durante proceso para descubrir errores (bugs) defectos. probable que desarrollo prueba inter- vengan diseñadores programadores del sistema. . versiones prueba, donde equipo prueba por separado experimenta una ver-sión completa del sistema, antes presentarlo los usuarios. meta prueba versión comprobar que sistema cumpla con los requerimientos los parti-cipantes del sistema. . pruebas usuario, donde los usuarios reales potenciales sistema prueban sistema propio entorno. para productos software, “usuario” puede ser grupo interno marketing, que decide software comercializa, lanza vende. las pruebas aceptación efectúan cuando cliente prueba manera formal sistema para decidir debe aceptarse del proveedor del sistema, requiere más desarrollo. práctica, proceso prueba por general requiere una combinación prue-bas manuales automatizadas. las primeras pruebas manuales, examinador opera programa con algunos datos prueba compara los resultados con sus expectativas. anota reporta las discrepancias con los desarrolladores del programa. las pruebas automatizadas, éstas codifican programa que opera cada vez que prueba sis-tema desarrollo. comúnmente esto más rápido que las pruebas manuales, sobre todo cuando incluye pruebas regresión, decir, aquellas que implican volver correr prue-bas anteriores para comprobar que los cambios programa introdujeron nuevos bugs. uso pruebas automatizadas aumentó manera considerable durante los últimos años. sin embargo, las pruebas nunca pueden ser automatizadas por completo, que esta clase pruebas sólo comprueban que programa haga que supone que tiene que hacer. prácticamente imposible usar pruebas automatizadas para probar sistemas que dependan cómo ven las cosas (por ejemplo, una interfaz gráfica usuario) probar que pro-grama presenta efectos colaterales indeseados. . pruebas desarrollo las pruebas desarrollo incluyen todas las actividades prueba que realiza equipo que elabora sistema. examinador del software suele ser programador que diseñó dicho software, aunque éste siempre caso. algunos procesos desarrollo usan parejas programador/examinador (cusamano selby, ) donde cada programador diseñar casos pruebapreparar datos pruebacorrer programa con datos pruebacomparar resultados casos pruebacasos pruebadatos pruebaresultados pruebareportes prueba figura . modelo del proceso pruebas software -.indd -.indd // :: // :: . ■ pruebas desarrollo tiene examinador asociado que desarrolla pruebas auxilia con proceso pruebas. para sistemas críticos, puede usarse proceso más formal, con grupo prueba inde-pendiente dentro del equipo desarrollo. son responsables del desarrollo pruebas del mantenimiento registros detallados los resultados las pruebas. durante desarrollo, las pruebas realizan tres niveles granulación: . pruebas unidad, donde ponen prueba unidades programa clases obje- tos individuales. las pruebas unidad deben enfocarse comprobar funciona-lidad objetos métodos. . pruebas del componente, donde muchas unidades individuales integran para crear componentes compuestos. prueba componentes debe enfocarse probar interfaces del componente. . pruebas del sistema, donde algunos todos los componentes sistema inte-gran sistema prueba como todo. las pruebas del sistema deben enfocarse poner prueba las interacciones los componentes. las pruebas desarrollo son, ante todo, proceso prueba defecto, las cua-les meta consiste descubrir bugs software. por tanto, menudo están entre-lazadas con depuración: proceso localizar problemas con código cambiar programa para corregirlos. .. pruebas unidad las pruebas unidad son proceso probar componentes del programa, como méto-dos clases objetos. las funciones los métodos individuales son tipo más simple componente. las pruebas deben llamarse para dichas rutinas con diferentes paráme-tros entrada. usted puede usar los enfoques para diseño casos prueba que estudian sección .., con finalidad elaborar las pruebas función método. cuando pone prueba las clases objetos, tiene que diseñar las pruebas para brindar cobertura todas las características del objeto. esto significa que debe:  probar todas las operaciones asociadas con objeto;  establecer verificar valor todos los atributos relacionados con objeto; poner objeto todos los estados posibles. esto quiere decir que tiene que simular todos los eventos que causen cambio estado.depuración depuración (debugging) proceso para corregir los errores problemas descubiertos por las pruebas. usar información las pruebas del programa, los depuradores, para localizar reparar error del programa, emplean tanto conocimiento del lenguaje programación como resultado que espera prueba. este proceso recibe con frecuencia apoyo herramientas depuración interactivas que brindan información adicional sobre ejecución del programa. http:// -.indd -.indd // :: // :: capítulo ■ pruebas software considere, por ejemplo, objeto estación meteorológica del modelo analizado capítulo . interfaz este objeto muestra figura .. tiene solo atributo, que identificador ( identifier ). ésta una constante que establece cuando instala estación meteorológica. por consiguiente, sólo necesita una prueba que demuestre configuró manera adecuada. usted necesita definir casos prueba para todos los méto-dos asociados con objeto, como reportweather, reportstatus, etcétera. aunque ideal poner prueba los métodos aislamiento, algunos casos son precisas ciertas secuencias prueba. por ejemplo, para someter prueba método que desactiva los instrumentos estación meteorológica (shutdown), necesita ejecutar método restart (reinicio). generalización herencia provoca que sea más complicada prueba las clases objetos. usted debe poner únicamente prueba una operación clase donde definió, suponer que funcionará como esperaba las subclases que heredan operación. operación que hereda puede hacer conjeturas sobre otras operaciones atributos. posible que sean válidas algunas subclases que hereden operación. por consiguiente, tiene que poner prueba operación heredada todos los contextos que utilice. para probar los estados estación meteorológica, usa modelo estado, tal como que muestra figura . del capítulo anterior. usar este modelo, iden-tificará secuencias transiciones estado que deban probarse definirá secuencias eventos para forzar dichas transiciones. principio, hay que probar cualquier secuencia posible transición estado, aunque práctica ello resulte muy costoso. los ejem-plos secuencias estado que deben probarse estación meteorológica incluyen: shutdown → running → shutdown configuring → running → testing → transmitting → running running → collecting → running → summarizing → transmitting → running siempre que sea posible, deben automatizar las pruebas unidad. estas pruebas unidad automatizadas, podría usarse marco automatización pruebas (como junit) para escribir correr sus pruebas programa. los marcos pruebas unidad ofrecen clases pruebas genéricas que extienden para crear casos prueba espe-cíficos. tal caso, usted podrá correr todas las pruebas que implementó reportar, con frecuencia mediante alguna gui, éxito fracaso las pruebas. común que toda una serie pruebas completa opere algunos segundos, modo que posible ejecutar todas las pruebas cada vez que efectúe cambio programa. conjunto automatizado pruebas tiene tres partes: . una parte configuración, cual inicializa sistema con caso prueba, esto , las entradas salidas esperadas.identificador reportweather ( ) reportstatus ( ) powersave (instruments) remotecontrol (commands) reconfigure (commands) restart (instruments) shutdown (instruments)estaciónmeteorológica figura . interfaz objeto estación meteorológica -.indd -.indd // :: // :: . ■ pruebas desarrollo . una parte llamada (call), cual llama objeto método que probar. . una parte declaración, cual compara resultado llamada con resultado esperado. información evalúa como verdadera, prueba tuvo éxito; pero resulta falsa, entonces fracasó. ocasiones, objeto que prueba tiene dependencias otros objetos que tal vez escribieron que, utilizan, frenan proceso pruebas. objeto llama una base datos, por ejemplo, esto requeriría proceso configuración lento antes usarse. tales casos, usted puede decidir usar objetos mock (simulados). éstos son objetos con misma interfaz como los usados por objetos externos que simulan funcionalidad. por ende, objeto mock que aparenta una base datos suele tener sólo algunos ítems datos que organizan arreglo. por tanto, puede entrar rápi-damente ellos, sin las sobrecargas llamar una base datos acceder discos. igual modo, los objetos mock pueden usarse para simular una operación anormal eventos extraños. por ejemplo, pretende que sistema tome acción ciertas horas del día, objeto mock simplemente regresará estas horas, independientemente hora real reloj. .. elección casos pruebas unidad las pruebas son costosas consumen tiempo, así que importante elegir casos efecti-vos pruebas unidad. efectividad significa, este caso, dos cuestiones: . los casos prueba tienen que mostrar que, cuando usan como esperaba, componente que somete prueba hace que supone que debe hacer. . hay defectos componente, éstos deberían revelarse mediante los casos prueba. consecuencia, hay que escribir dos tipos casos prueba. primero debe refle-jar una operación normal programa mostrar que componente funciona. por ejemplo, usted probar componente que crea inicia registro nuevo paciente, entonces, caso prueba debe mostrar que registro existe una base datos, que sus campos configuraron como especificó. otro tipo caso prueba tiene que basarse probar experiencia donde surgen problemas comunes. debe usar entradas anormales para comprobar que procesan manera adecuada sin colapsar componente. aquí discuten dos estrategias posibles que serían efectivas para ayudarle elegir casos prueba. trata : . prueba partición, donde identifican grupos entradas con características comunes procesan misma forma. debe elegir las pruebas dentro cada uno dichos grupos. . pruebas basadas lineamientos, donde usan lineamientos para elegir los casos prueba. dichos lineamientos reflejan experiencia previa los tipos erro-res que suelen cometer los programadores desarrollar componentes. -.indd -.indd // :: // :: capítulo ■ pruebas software los datos entrada los resultados salida programa regularmente caen número clases diferentes con características comunes. los ejemplos -tas clases son números positivos, números negativos selecciones menú. por gene-ral, los programas comportan una forma comparable todos los miembros una clase. esto , usted prueba programa que hace cálculo requiere dos números posi-tivos, entonces esperaría que programa comportara igual modo todos los números positivos. debido este comportamiento equivalente, dichas clases llaman ocasiones par-ticiones equivalencia dominios (bezier, ). para diseño casos prueba, enfoque sistemático basa identificar todas las particiones entrada salida para sistema unos componentes. los casos prueba elaboran forma que las entra-das salidas encuentren dentro dichas particiones. prueba partición sirve para diseñar casos prueba tanto para sistemas como para componentes. figura ., elipse sombreada más grande ubicada lado izquierdo repre-senta conjunto todas las entradas posibles programa que someterá prueba. las elipses más pequeñas sin sombrear constituyen particiones equivalencia. pro-grama que ponga prueba debe procesar misma forma todos los miembros las particiones equivalencia entrada. las particiones equivalencia salida son particiones dentro las cuales todas las salidas tienen algo común. ocasiones hay mapeo : entre particiones equivalencia entrada salida. sin embargo, éste siempre caso; quizás usted necesite definir una partición equivalencia entrada independiente, donde única característica común las entradas sea que generan sali-das dentro misma partición salida. área sombreada elipse izquierda representa excepciones que pueden ocurrir ( decir, respuestas entradas inválidas). una vez identificado conjunto particiones, los casos prueba eligen cada una dichas particiones. una buena regla empírica para selección casos prueba seleccionar casos prueba las fronteras las particiones, además casos cerca del punto medio partición. razón que diseñadores programadores tienden consi-derar valores típicos entradas cuando desarrolla sistema. éstos prueban elegir punto medio partición. los valores frontera son usualmente atípicos (por ejemplo, cero puede comportarse manera diferente otros números negativos), modo que veces los desarrolladores los pasan por alto. con frecuencia ocurren fallas del programa cuando procesan estos valores atípicos.sistema entradas posiblesparticiones equivalencia entrada salidas posiblessalidas correctasparticiones salida figura . partición equivalencia -.indd -.indd // :: // :: . ■ pruebas desarrollo las particiones identifican mediante especificación del programa documen- tación del usuario partir experiencia, donde predicen las clases valor entrada que probable que detecten errores. por ejemplo, digamos que especificación programa establece que programa acepta entradas que son cinco dígitos enteros mayores que . usted usa esta información para identificar las particiones entrada los posibles valores entrada prueba. esto muestra figura .. cuando usa especificación sistema para reconocer particiones equivalen-cia, llama “pruebas caja negra”. aquí necesario algún conocimiento cómo funciona sistema. sin embargo, puede ser útil complementar las pruebas caja negra con “pruebas caja blanca”, las cuales busca código del programa para encontrar otras posibles pruebas. por ejemplo, código puede incluir excepciones para manejar las entradas incorrectas. este conocimiento utiliza para identificar “particiones excep-ción”: diferentes rangos donde deba aplicarse mismo manejo excepción. partición equivalencia enfoque efectivo para las pruebas, porque ayuda explicar los errores que cometen con frecuencia los programadores procesar entradas los bordes las particiones. usted también puede usar lineamientos prueba para ayudarse elegir casos prueba. los lineamientos encapsulan conocimiento sobre qué tipos casos prueba son efectivos para detección errores. por ejemplo, cuando prueban programas con secuencias, arreglos listas, los lineamientos que pueden ayu-dar revelar defectos incluyen: . probar software con secuencias que tengan sólo valor único. los programadores naturalmente consideran las secuencias como compuestas por muchos valores , ocasiones, incrustan esta suposición sus programas. consecuencia, presenta una secuencia valor único, posible que programa funcione manera adecuada. . usar diferentes secuencias diversos tamaños distintas pruebas. esto dismi-nuye las oportunidades que programa con defectos genere accidentalmente una salida correcta, debido algunas características accidentales entrada. . derivar pruebas modo que acceda los elementos primero, medio último secuencia. este enfoque revela problemas las fronteras partición.entre menos más valores entradaentre menos más número valores entrada figura . particiones equivalencia -.indd -.indd // :: // :: capítulo ■ pruebas software libro whittaker () incluye muchos ejemplos lineamientos que pueden utilizar diseño casos prueba. algunos los lineamientos más generales que sugiere son: ■ elegir entradas que fuercen sistema generar todos los mensajes error; ■ diseñar entradas que produzcan que los buffers entrada desborden; ■ repetir varias veces misma entrada serie entradas; ■ forzar generación salidas inválidas; ■ forzar resultados cálculo demasiado largos demasiado pequeños. conforme adquiera experiencia con las pruebas, usted podrá desarrollar sus propios lineamientos sobre cómo elegir casos prueba efectivos. siguiente sección este capítulo incluyen más ejemplos lineamientos prueba. .. pruebas componentes general, los componentes software son componentes compuestos constituidos por varios objetos interacción. por ejemplo, sistema estación meteorológica, componente reconfiguración incluye objetos que tratan con cada aspecto recon-figuración. acceso funcionalidad dichos objetos través interfaz componente definida. por consiguiente, prueba componentes compuestos tiene que enfocarse mostrar que interfaz componente comporta según especificación. usted puede suponer que dentro del componente completaron las pruebas unidad sobre objeto individual. figura . ilustra idea prueba interfaz componente. suponga que los componentes , integraron para crear componente subsistema más grande. los casos prueba aplican los componentes individuales, sino más bien interfaz del componente compuesto, creado combinar tales componentes. los errores inter-faz componente compuesto quizá detecten poner prueba los objetos individua-les, porque dichos errores resultan interacciones entre los objetos componente. existen diferentes tipos interfaz entre componentes programa , consecuencia, distintos tipos error interfaz que llegan ocurrir: . interfaces parámetro son interfaces que los datos, ocasiones referen- cias función, pasan componente otro. los métodos objeto tienen una interfaz parámetro.pruebas trayectoria las pruebas trayectoria son una estrategia prueba que dirige principalmente ejercitar cada trayectoria ejecución independiente través componente programa. ejecuta cualquier trayectoria independiente, entonces deben ejecutarse todos los enunciados componente menos una vez. todos los enunciados condicionales prueban para los casos verdadero falso. proceso desarrollo orientado objetos, prueba trayectoria puede usarse cuando prueban los métodos asociados con los objetos. http:// -.indd -.indd // :: // :: . ■ pruebas desarrollo . interfaces memoria compartida son interfaces que bloque memoria reparte entre componentes. los datos colocan memoria subsistema otros subsistemas los recuperan ahí. este tipo interfaz usa con frecuencia sistemas embebidos, donde los sensores crean datos que recuperan son procesa-dos por otros componentes del sistema. . interfaces procedimiento son interfaces que componente encapsula conjunto procedimientos que pueden ser llamados por otros componentes. los objetos otros componentes reutilizables tienen esta forma interfaz. . interfaces que pasan mensajes trata interfaces donde, enviar men- saje, componente solicita servicio otro componente. mensaje retorno incluye los resultados para ejecutar servicio. algunos sistemas orientados obje-tos tienen esta forma interfaz, así como los sistemas cliente-servidor. los errores interfaz son una las formas más comunes falla los sistemas complejos (lutz, ). dichos errores caen tres clases: ■ uso incorrecto interfaz componente que llama otro componente comete algún error uso interfaz. este tipo error común con interfaces pará-metro, donde los parámetros pueden ser del tipo equivocado, bien, pasar orden número equivocados parámetros. ■ mala interpretación interfaz componente que malinterpreta especifica-ción interfaz del componente llamado hace suposiciones sobre comporta-miento. componente llamado comporta como esperaba, cual entonces genera comportamiento imprevisto componente que llama. por ejemplo, método búsqueda binaria puede llamarse con parámetro que arreglo desordenado. entonces fallaría búsqueda. ■ errores temporización ocurren sistemas tiempo real que usan una memoria compartida una interfaz que pasa mensajes. productor datos consumidor datos operan diferentes niveles rapidez. menos que tenga cuidado par-ticular diseño interfaz, consumidor puede acceder información obsoleta, casos prueba figura . prueba interfaz -.indd -.indd // :: // :: capítulo ■ pruebas software porque productor información actualizó información interfaz compartida. las pruebas por defectos interfaz son difíciles porque algunas fallas interfaz sólo pueden manifestarse ante condiciones inusuales. por ejemplo, dice que objeto implementa una cola como una estructura datos longitud fija. objeto que llama puede suponer que cola implementó como una estructura datos infinita verificaría desbordamiento cola, cuando ingresa ítem. esta condición sólo logra detectar durante las pruebas, diseñar casos prueba que fuercen desbor-damiento cola, causen que desbordamiento corrompa comportamiento del objeto cierta forma detectable. problema posterior podría surgir derivado interacciones entre fallas dife-rentes módulos objetos. las fallas objeto sólo detectan cuando algún otro objeto comporta una forma inesperada. por ejemplo, objeto llama otro objeto para recibir algún servicio supone que correcta respuesta; servicio lla-mada deficiente algún modo, valor devuelto puede ser válido pero equivocado. esto detecta inmediato, sino sólo vuelve evidente cuando algún cálculo posterior sale mal. algunos lineamientos generales para las pruebas interfaz son: . examinar código que probar listar explícitamente cada llamado componente externo. diseñe conjunto pruebas donde los valores los pará-metros hacia los componentes externos estén los extremos finales sus ran-gos. dichos valores extremos tienen más probabilidad revelar inconsistencias interfaz. . donde los punteros pasen través una interfaz, pruebe siempre interfaz con parámetros puntero nulo. . donde componente llame través una interfaz procedimiento, diseñe pruebas que deliberadamente hagan que falle componente. diferir las suposi-ciones falla una las interpretaciones especificación equivocadas más comunes. . use pruebas esfuerzo los sistemas que pasan mensajes. esto significa que debe diseñar pruebas que generen muchos más mensajes los que probablemente ocurran práctica. ésta una forma efectiva revelar problemas tempori-zación. . donde algunos componentes interactúen través memoria compartida, diseñe pruebas que varíen orden que activan estos componentes. tales pruebas pueden revelar suposiciones implícitas hechas por programador, sobre orden que producen consumen los datos compartidos. ocasiones, las inspecciones revisiones suelen ser más efectivas costo que las pruebas para descubrir errores interfaz. las inspecciones pueden concentrarse interfaces componente interrogantes sobre comportamiento supuesto inter-faz planteada durante proceso inspección. lenguaje robusto como java permite que muchos errores interfaz sean descubiertos por compilador. los analizadores estáticos (capítulo ) son capaces detectar amplio rango errores interfaz. -.indd -.indd // :: // :: . ■ pruebas desarrollo .. pruebas del sistema las pruebas del sistema durante desarrollo incluyen integración componentes para crear una versión del sistema , luego, poner prueba sistema integrado. las pruebas sistema demuestran que los componentes son compatibles, que interactúan correctamente que transfieren los datos correctos momento adecuado través sus interfaces. evidentemente, traslapan con las pruebas componentes, pero existen dos importantes diferencias: . durante las pruebas sistema, los componentes reutilizables desarrollados por separado los sistemas comerciales pueden integrarse con componentes desarrolla-dos recientemente. entonces prueba sistema completo. . los componentes desarrollados por diferentes miembros del equipo grupos pueden integrarse esta etapa. prueba sistema proceso colectivo más que individual. algunas compañías, las pruebas del sistema implican equipo prueba independiente, sin inclusión diseñadores programadores. cuando integran componentes para crear sistema, obtiene comportamiento emergente. esto significa que algunos elementos funcionalidad del sistema sólo hacen evidentes cuando reúnen los componentes. éste podría ser comportamiento emergente planeado que debe probarse. por ejemplo, usted puede integrar compo-nente autenticación con componente que actualice información. esta manera, tiene una característica sistema que restringe información actualizada usuarios autorizados. sin embargo, algunas veces, comportamiento emergente está planeado desea. hay que desarrollar pruebas que demuestren que sistema sólo hace que supone que debe hacer. por tanto, las pruebas del sistema deben enfocarse poner prueba las interaccio-nes entre los componentes los objetos que constituyen sistema. también prueban componentes sistemas reutilizables para acreditar que integrarse nuevos componen-tes funcionen como esperaba. esta prueba interacción debe descubrir aquellos bugs componente que sólo revelan cuando usan otros componentes sistema. las pruebas interacción también ayudan encontrar interpretaciones erróneas, cometidas por desarrolladores componentes, acerca otros componentes sistema. por enfoque las interacciones, las pruebas basadas casos son enfoque efec-tivo para prueba del sistema. normalmente, cada caso uso implementado por integración pruebas incrementales las pruebas sistema implican integrar diferentes componentes , después, probar sistema integrado que creó. siempre hay que usar enfoque incremental para integración las pruebas ( decir, debe incluir componente, probar sistema, integrar otro componente, probar nuevo así sucesivamente). esto significa que, ocurren problemas, quizá deban interacciones con componente que integró más recientemente. integración las pruebas incrementales son fundamentales para los métodos ágiles como , donde las pruebas regresión (véase sección .) efectúan cada vez que integra nuevo incremento. http:// -.indd -.indd // :: // :: capítulo ■ pruebas software varios componentes objetos sistema. probar los casos uso obliga que ocurran estas interacciones. usted desarrolló diagrama secuencia para modelar imple-mentación casos uso, verá los objetos componentes implicados interacción. para ilustrar anterior, usa ejemplo del sistema estación meteorológica campo abierto, donde pide estación meteorológica reportar resumen datos una computadora remota. caso uso para esto describe figura . (capítulo anterior). figura . (copia figura .) muestra secuencia operaciones estación meteorológica, responder una petición recolección datos para sistema mapeo. este diagrama sirve para identificar operaciones que probarán para ayudar diseñar los casos prueba para efectuar las pruebas. por consiguiente, emitir una peti-ción para reporte dará como resultado ejecución siguiente cadena métodos: satcomms:request → weatherstation:reportweather → commslink:get(summary) → weatherdata:summarize diagrama secuencia ayuda diseñar los casos prueba específicos necesarios, pues muestra cuáles entradas requieren cuáles salidas crean: . una entrada una petición para reporte tiene que contar con reconocimiento asociado. última instancia, partir petición debe regresarse reporte. durante las pruebas, debe crear resumen datos que sirva para comprobar que reporte organiza correctamente. . una petición entrada para reporte weatherstation como resultado generación reporte resumido. usted puede probar esto aislamiento, creando datos brutos correspondientes resumen que preparó para prueba satcomms, demostrar que objeto weatherstation produce este resumen. tales datos brutos usan también para probar objeto weatherdata.satcomms request (report) reconoce reportweather ( ) get (summary) reply (report) reconoceweatherstation commslink summarise ( )weatherdata reconoce send (report) reconocesistema información meteorológica figura . gráfico secuencia recolección datos meteorológicos -.indd -.indd // :: // :: . ■ desarrollo dirigido por pruebas desde luego, figura . simplificó diagrama secuencia para que muestre excepciones. asimismo, una prueba completa caso/escenario uso consi-dera esto garantiza que los objetos manejen adecuadamente las excepciones. para mayoría sistemas difícil saber cuántas pruebas sistemas son esencia-les cuándo hay que dejar hacer pruebas. las pruebas exhaustivas, donde pone prueba cada secuencia posible ejecución del programa, son imposibles. por tanto, las pruebas deben basarse subconjunto probables casos prueba. manera ideal, para elegir este subconjunto, las compañías software cuentan con políticas, las cuales pueden basarse políticas prueba generales, como una política que todos los enunciados del programa ejecuten menos una vez. como alternativa, pueden basarse experiencia uso sistema , vez, enfocarse probar las caracterís-ticas del sistema operativo. por ejemplo: . tienen que probarse todas las funciones del sistema que ingresen través menú. . debe experimentarse combinación funciones (por ejemplo, formateo texto) que ingrese por medio del mismo menú. . donde proporcione entrada del usuario, hay que probar todas las funciones, sea con entrada correcta incorrecta. por experiencia con los principales productos software, como procesadores texto hojas cálculo, claro que lineamientos similares usan por general durante prueba del producto. usualmente funcionan cuando las características del software usan aislamiento. los problemas presentan, dice whittaker (), cuando las com-binaciones características uso menos común prueban conjunto. ejemplo cómo, procesador texto uso común, uso notas pie página con una plantilla columnas múltiples causa distribución incorrecta del texto. las pruebas automatizadas del sistema suelen ser más difíciles que las pruebas auto-matizadas unidad componente. las pruebas automatizadas unidad apoyan predicción salidas , luego, codificación dichas predicciones pro-grama. tal caso, compara pronóstico con resultado. sin embargo, punto aplicar sistema puede ser generar salidas que sean grandes logren predecirse con facilidad. tiene que examinar una salida demostrar credibilidad sin crearla nece-sariamente por adelantado. . desarrollo dirigido por pruebas desarrollo dirigido por pruebas (tdd, por las siglas test-driven development) enfoque diseño programas donde entrelazan desarrollo pruebas código (beck, ; jeffries melnik, ). esencia, código desarrolla incre-mentalmente, junto con una prueba para ese incremento. avanza hacia siguiente incremento sino hasta que código diseñado pasa prueba. desarrollo dirigido por pruebas introdujo como parte los métodos ágiles como programación extrema. obstante, puede usar también los procesos desarrollo basados plan. -.indd -.indd // :: // :: capítulo ■ pruebas software figura . ilustra proceso tdd fundamental. los pasos proceso son los siguientes: . comienza por identificar incremento funcionalidad requerido. éste usual- mente debe ser pequeño aplicable pocas líneas del código. . escribe una prueba para esta funcionalidad implementa como una prueba automatizada. esto significa que prueba puede ejecutarse reportarse, sin impor-tar aprueba falla. . luego corre prueba, junto con todas las otras pruebas que implementaron. inicialmente, aplica funcionalidad, modo que nueva prueba fallará. esto deliberado, pues muestra que prueba añade algo conjunto pruebas. . luego implementa funcionalidad opera nuevamente prueba. esto puede incluir refactorización del código existente, para perfeccionarlo adicionar nuevo código existente. . una vez puestas funcionamiento con éxito todas las pruebas, avanza implementación siguiente funcionalidad. entorno automatizado pruebas, como entorno junit que soporta pruebas del programa java (massol husted, ), esencial para tdd. conforme código desarrolla incrementos muy pequeños, uno tiene posibilidad correr cada prueba, cada vez que adiciona funcionalidad refactoriza programa. por consiguiente, las pruebas incrustan programa independiente que corre las pruebas apela sis-tema que prueba. usar este enfoque, unos cuantos segundos efectúan cientos pruebas independientes. argumento consistente con desarrollo dirigido por pruebas que ayuda los programadores aclarar sus ideas acerca que realmente debe hacer segmento código. para escribir una prueba, preciso entender que quiere, pues esta com-prensión facilita escritura del código requerido. desde luego, conocimiento comprensión son incompletos, entonces ayudará desarrollo dirigido por pruebas. por ejemplo, cálculo implica división, debería comprobar que divide los núme-ros entre cero. caso que olvide escribir una prueba para esto, programa nunca incluirá código comprobar. además mejor comprensión del problema, otros beneficios del desarrollo diri-gido por pruebas son: . cobertura código principio, cualquier segmento código que escriba debe tener menos una prueba asociada. por tanto, puede estar seguro que cual-identificar nueva funcionalidad escribir prueba correr pruebaimplementar funcionalidad refactorizaciónfallapasa figura . desarrollo dirigido por pruebas -.indd -.indd // :: // :: . ■ desarrollo dirigido por pruebas quier código sistema ejecuta realmente. código prueba medida que escribe, modo que los defectos descubren con oportunidad proceso desarrollo. . pruebas regresión conjunto pruebas desarrolla incrementalmente conforme desarrolla programa. siempre posible correr pruebas regresión para demostrar que los cambios programa introdujeron nuevos bugs. . depuración simplificada cuando falla una prueba, debe ser evidente dónde yace problema. preciso comprobar modificar código recién escrito. requieren herramientas depuración para localizar problema. los reportes del uso del desa-rrollo dirigido por pruebas indican que difícilmente alguna vez necesitará usar depurador automatizado desarrollo dirigido por pruebas (martin, ). . documentación del sistema las pruebas actúan como una forma documen-tación que describen que debe hacer código. leer las pruebas suele facilitar comprensión del código. uno los beneficios más importantes del desarrollo dirigido por pruebas que reduce los costos las pruebas regresión. estas últimas implican correr los conjun-tos pruebas ejecutadas exitosamente después realizar cambios sistema. prueba regresión verifica que dichos cambios hayan introducido nuevos bugs sistema, que nuevo código interactúa como esperaba con código existente. las pruebas regresión son muy costosas , por general, poco prácticas cuando sistema prueba manualmente, pues son muy elevados los costos tiempo esfuerzo. ante tales situaciones, usted debe ensayar elegir las pruebas más relevantes para volver correrlas, fácil perder pruebas importantes. sin embargo, las pruebas automatizadas, que son fundamentales para desarrollo primera prueba, reducen drásticamente los costos las pruebas regresión. las prue-bas existentes pueden volverse correr manera más rápida menos costosa. después realizar cambios sistema desarrollo primera prueba, todas las prue-bas existentes deben correr con éxito antes añadir cualquier funcionalidad accesoria. como programador, usted podría estar seguro que nueva funcionalidad que agregue causará revelará problemas con código existente. desarrollo dirigido por pruebas usa más diseño software nuevo, donde funcionalidad implementa código nuevo usa librerías estándar perfectamente pro-badas. reutilizan grandes componentes código sistemas heredados, entonces necesita escribir pruebas para dichos sistemas como todo. desarrollo dirigido por pruebas también puede ser ineficaz con sistemas multihilo. los diferentes hilos pueden entrelazarse diferentes momentos diversas corridas pruebas , por tanto, producirán resultados variados. usa desarrollo dirigido por pruebas, necesitará proceso prueba del sistema para validar sistema; esto , comprobar que cumple con los requerimientos todos los participantes del sistema. las pruebas sistema también demuestran rendimiento, confiabilidad evidencian que sistema haga aquello que debe hacer, como producir salidas indeseadas, etcétera. andrea () sugiere cómo pueden extenderse las herramien-tas prueba para integrar algunos aspectos las pruebas sistema con tdd. desarrollo dirigido por pruebas resulta ser enfoque exitoso para proyectos dimensión pequeña mediana. por general, los programadores que adoptan dicho enfo-que están contentos con descubren que una forma más productiva desarrollar -.indd -.indd // :: // :: capítulo ■ pruebas software software (jeffries melnik, ). algunos ensayos, demostró que conduce mejo- rar calidad del código; otros, los resultados son concluyentes. sin embargo, hay evidencia que tdd conduzca código con menor calidad. . pruebas versión las pruebas versión son proceso poner prueba una versión particular sis-tema que pretende usar fuera del equipo desarrollo. por general, versión del sistema para clientes usuarios. obstante, proyecto complejo, versión podría ser para otros equipos que desarrollan sistemas relacionados. para productos software, versión sería para gerente producto, quien después prepara para venta. existen dos distinciones importantes entre las pruebas versión las pruebas del sistema durante proceso desarrollo: . equipo independiente que intervino desarrollo del sistema debe ser responsable las pruebas versión. . las pruebas del sistema por parte del equipo desarrollo deben enfocarse descubrimiento bugs sistema (pruebas defecto). objetivo las prue-bas versión comprobar que sistema cumpla con los requerimientos sea suficientemente bueno para uso externo (pruebas validación). principal meta del proceso pruebas versión convencer proveedor del sistema que éste suficientemente apto para uso. así, puede liberarse como producto entregarse cliente. por tanto, las pruebas versión deben mostrar que sistema entrega funcionalidad, rendimiento confiabilidad especificados, que falla durante uso normal. deben considerarse todos los requerimientos del sistema, sólo los los usuarios finales del sistema. las pruebas versión, por regular, son proceso prueba caja negra, donde las pruebas derivan partir especificación del sistema. sistema trata como una caja negra cuyo comportamiento sólo puede determinarse por estudio entradas salidas relacionadas. otro nombre para esto “prueba funcional”, llamada así porque examinador sólo preocupa funcionalidad aplicación del software. .. pruebas basadas requerimientos principio general buena práctica ingeniería requerimientos que éstos deben ser comprobables; esto , los requerimientos tienen que escribirse forma que pueda diseñarse una prueba para dicho requerimiento. luego, examinador comprueba que requerimiento cumpla. consecuencia, las pruebas basadas requerimientos son enfoque sistemático diseño casos prueba, donde considera cada reque-rimiento deriva conjunto pruebas para éste. las pruebas basadas requeri-mientos son pruebas validación más que defecto: intenta demostrar que sistema implementó adecuadamente sus requerimientos. -.indd -.indd // :: // :: . ■ pruebas versión por ejemplo, considere los requerimientos relacionados para mhc-pms (presen- tado capítulo ), que enfocan comprobación alergias medicamentos: sabe que paciente alérgico algún fármaco particular, entonces prescripción dicho medicamento dará como resultado mensaje adverten-cia que emitirá usuario del sistema. quien prescribe ignora una advertencia alergia, deberá proporcionar una razón para ello. para comprobar estos requerimientos cumplen, tal vez necesite elaborar muchas pruebas relacionadas: . configurar registro paciente sin alergias conocidas. prescribir medicamen- tos para alergias que sabe que existen. comprobar que sistema emite mensaje advertencia. . realizar registro paciente con una alergia conocida. prescribir medica-mento que alérgico comprobar que sistema emite advertencia. . elaborar registro paciente donde reporten alergias dos más medica-mentos. prescribir dichos medicamentos por separado comprobar que emite advertencia correcta para cada medicamento. . prescribir dos medicamentos los que sea alérgico paciente. comprobar que emiten correctamente dos advertencias. . prescribir medicamento que emite una advertencia pasar por alto dicha adver-tencia. comprobar que sistema solicita usuario proporcionar información que explique por qué pasó por alto advertencia. partir esto puede ver que probar requerimiento sólo significa escribir una prueba. por general, usted deberá escribir muchas pruebas para garantizar que cubrió los requerimientos. también hay que mantener rastreo los registros sus pruebas basadas requerimientos, que vinculan las pruebas con los requerimientos espe-cíficos que ponen prueba. .. pruebas escenario las pruebas escenario son enfoque las pruebas versión donde crean esce-narios típicos uso les utiliza desarrollo casos prueba para sistema. escenario una historia que describe una forma que puede usarse sistema. los escenarios deben ser realistas, los usuarios reales del sistema tienen que relacionarse con ellos. usted empleó escenarios como parte del proceso ingeniería requeri-mientos (descritos capítulo ), entonces podría reutilizarlos como escenarios prueba. breve ensayo sobre las pruebas escenario, kaner () sugiere que una prueba escenario debe ser una historia narrativa que sea creíble bastante compleja. tiene que motivar los participantes; esto , deben relacionarse con escenario creer que importante que sistema pase prueba. también sugiere que debe ser fácil -.indd -.indd // :: // :: capítulo ■ pruebas software evaluar. hay problemas con sistema, entonces equipo pruebas versión tiene que reconocerlos. como ejemplo posible escenario para mhc-pms, figura . describe una forma utilizar sistema una visita domiciliaria, que pone prueba algunas características del mhc-pms: . autenticación ingresar sistema. . descarga carga registros paciente específicos desde una laptop. . agenda visitas domicilio. . cifrado descifrado registros pacientes dispositivo móvil. . recuperación modificación registros. . vinculación con base datos medicamentos que mantenga información acerca efectos colaterales. . sistema para recordatorio llamadas. usted examinador versión, opere través este escenario, interprete papel kate observe cómo comporta sistema respuesta las diferentes entradas. como “kate”, usted puede cometer errores deliberados, como ingresar palabra clave equivocada para decodificar registros. esto comprueba respuesta del sistema ante los errores. tiene que anotar cuidadosamente cualquier problema que surja, incluidos pro-blemas rendimiento. sistema muy lento, esto cambiará forma que usa. por ejemplo, tarda mucho cifrar registro, entonces los usuarios que tengan poco tiempo pueden saltar esta etapa. pierden laptop, una persona autorizada podría ver entonces los registros los pacientes. cuando usa enfoque basado escenarios, ponen prueba por general varios requerimientos dentro del mismo escenario. por tanto, además comprobar figura . escenario uso para mhc-pmskate enfermera con especialidad atención salud mental. una sus responsabilidades visitar domicilio los pacientes, para comprobar efectividad tratamiento que sufran efectos colaterales del fármaco. día visitas domésticas, kate ingresa mhc-pms usa para imprimir agenda visitas domiciliarias para ese día, junto con información resumida sobre los pacientes por visitar. solicita que los registros para dichos pacientes descarguen laptop. pide palabra clave para cifrar los registros laptop. uno los pacientes quienes visita jim, quien tratado con medicamentos antidepresivos. jim siente que medicamento ayuda, pero considera que efecto colateral que mantiene despierto durante noche. kate observa registro jim pide palabra clave para descifrar registro. comprueba medicamento prescrito consulta sus efectos colaterales. insomnio efecto colateral conocido, así que anota problema registro jim sugiere que visite clínica para que cambien medicamento. está acuerdo, así que kate ingresa recordatorio para llamarlo cuanto ella regrese clínica, para concertarle una cita con médico. termina consulta sistema vuelve cifrar registro jim. más tarde, terminar sus consultas, kate regresa clínica sube los registros los pacientes visitados base datos. sistema genera para kate una lista aquellos pacientes con quienes debe comunicarse, para obtener información seguimiento concertar citas clínica. -.indd -.indd // :: // :: . ■ pruebas versión requerimientos individuales, también demuestra que las combinaciones requerimien- tos causan problemas. .. pruebas rendimiento una vez integrado completamente sistema, posible probar propiedades emergentes, como rendimiento confiabilidad. las pruebas rendimiento deben diseñarse para garantizar que sistema procese carga pretendida. generalmente, esto implica efec-tuar una serie pruebas donde aumenta carga, hasta que rendimiento del sistema vuelve inaceptable. como con otros tipos pruebas, las pruebas rendimiento preocupan tanto por demostrar que sistema cumple con sus requerimientos, como por descubrir problemas defectos sistema. para probar los requerimientos rendimiento logran, quizá deba construir perfil operativo. perfil operativo (capítulo ) conjunto prue-bas que reflejan mezcla real trabajo que manejará sistema. por consiguiente, % las transacciones sistema son del tipo , % del tipo , resto los tipos , , entonces habrá que diseñar perfil operativo modo que gran mayoría pruebas sean del tipo . otra manera, obtendrá una prueba precisa del rendi-miento operativo del sistema. desde luego, este enfoque necesariamente mejor para pruebas defecto. experiencia demuestra que una forma efectiva descubrir defectos diseñar pruebas sobre los límites del sistema. las pruebas rendimiento, significa estresar sistema hacer demandas que estén fuera los límites diseño del software. esto conoce como “prueba esfuerzo”. por ejemplo, digamos que usted prueba sistema pro-cesamiento transacciones que diseña para procesar hasta transacciones por segundo. comienza por probar sistema con menos transacciones por segundo. luego aumenta gradualmente carga del sistema más allá transacciones por segundo, hasta que está muy por arriba carga máxima diseño del sistema sistema falla. este tipo pruebas tiene dos funciones: . prueba comportamiento falla del sistema. pueden surgir circunstancias través una combinación inesperada eventos donde carga colocada sistema supere carga máxima anticipada. ante tales circunstancias, importante que falla del sistema cause corrupción datos pérdida inesperada servicios usuario. las pruebas esfuerzo demuestran que sobrecarga del sistema hace que “falle poco” vez colapsar bajo carga. . fuerza sistema puede hacer que salgan luz defectos que descubrirían normalmente. aunque puede argumentar que esos defectos probablemente causen fallas sistema uso normal, pudiera haber una serie combinaciones inusuales circunstancias normales que requieren pruebas esfuerzo. las pruebas esfuerzo son particularmente relevantes para los sistemas distribuidos basados redes procesadores. dichos sistemas muestran con frecuencia degradación severa cuando cargan exceso. red empantana con coordinación datos que deben intercambiar los diferentes procesos. éstos vuelven cada vez más lentos conforme esperan los datos requeridos otros procesos. las pruebas esfuerzo ayu-dan descubrir cuándo comienza degradación, manera que puedan adicionar comprobaciones sistema para rechazar transacciones más allá este punto. -.indd -.indd // :: // :: capítulo ■ pruebas software . pruebas usuario las pruebas usuario del cliente son una etapa proceso pruebas donde los usuarios clientes proporcionan entrada asesoría sobre las pruebas del sistema. esto puede implicar probar manera formal sistema que comisionó proveedor externo, podría ser proceso informal donde los usuarios experimentan con nuevo producto software, para ver les gusta hace que necesitan. las pruebas usuario son esenciales, aun cuando hayan realizado pruebas abarcadoras sistema versión. razón esto que influencia del entorno trabajo del usua-rio tiene gran efecto sobre fiabilidad, rendimiento, uso robustez sistema. casi imposible que desarrollador sistema replique entorno trabajo del sistema, pues las pruebas entorno del desarrollador forzosamente son artificiales. por ejemplo, sistema que pretenda usar hospital usa entorno clínico donde suceden otros hechos, como emergencias pacientes, conversaciones con fami-liares del paciente, etcétera. todo ello afecta uso sistema, pero los desarrollado-res pueden incluirlos entorno pruebas. práctica, hay tres diferentes tipos pruebas usuario: . pruebas alfa, donde los usuarios del software trabajan con equipo diseño para probar software sitio del desarrollador. . pruebas beta, donde una versión del software pone disposición los usuarios, para permitirles experimentar descubrir problemas que encuentran con los desa-rrolladores del sistema. . pruebas aceptación, donde los clientes prueban sistema para decidir está listo para ser aceptado por los desarrolladores del sistema desplegado entor- del cliente. las pruebas alfa, los usuarios desarrolladores trabajan conjunto para probar sistema medida que desarrolla. esto significa que los usuarios pueden identificar problemas conflictos que son fácilmente aparentes para equipo prueba desarrollo. los desarrolladores realidad sólo pueden trabajar partir los requeri-mientos, pero con frecuencia esto refleja otros factores que afectan uso práctico del software. por tanto, los usuarios brindan información sobre práctica que ayuda con diseño pruebas más realistas. las pruebas alfa usan menudo cuando desarrollan productos software que venden como sistemas empaquetados. los usuarios dichos productos quizás estén satisfechos intervenir proceso pruebas alfa porque esto les infor-mación oportuna acerca las características del nuevo sistema que pueden explo-tar. también reduce riesgo que cambios anticipados software tengan efectos perturbadores para negocio. sin embargo, las pruebas alfa también utilizan cuando desarrolla software personalizado. los métodos ágiles, como , abogan por inclu-sión del usuario proceso desarrollo que los usuarios tengan papel activo diseño pruebas para sistema. las pruebas beta tienen lugar cuando una versión temprana sistema software, ocasiones sin terminar, pone disposición clientes usuarios para evaluación. -.indd -.indd // :: // :: . ■ pruebas usuario los examinadores beta pueden ser grupo selecto clientes que sean adoptadores tempranos del sistema. manera alternativa, software pone disposición pública para uso quienquiera que esté interesado . las pruebas beta usan sobre todo para productos software que emplean entornos múltiples diferentes ( oposición los sistemas personalizados, que utilizan por general entorno definido). imposible que los desarrolladores producto conozcan repliquen todos los entornos donde usará software. consecuencia, las pruebas beta son esenciales para descubrir problemas interacción entre software las características del entorno donde emplea. las pruebas beta también son una forma comercialización: los clien-tes aprenden sobre sistema que puede hacer por ellos. las pruebas aceptación son una parte inherente del desarrollo sistemas persona-lizados. tienen lugar después las pruebas versión. implican cliente que prueba manera formal sistema, para decidir debe aceptarlo del desarrollador del sistema. aceptación implica que debe realizarse pago por sistema. existen seis etapas proceso pruebas aceptación, como muestra figura .. éstas son: . definir los criterios aceptación esta etapa debe, manera ideal, anticiparse proceso, antes firmar contrato por sistema. los criterios aceptación forman parte del contrato del sistema tienen que convenirse entre cliente desarrollador. sin embargo, práctica suele ser difícil definir los criterios manera tan anticipada proceso. posible que estén disponibles requeri-mientos detallados que haya cambios significativos los requerimientos durante proceso desarrollo. . plan pruebas aceptación esto incluye decidir sobre los recursos, tiempo presupuesto para las pruebas aceptación, así como establecer calendario pruebas. plan pruebas aceptación debe incluir también cobertura requerida los requerimientos orden que prueban las características del sistema. tiene que definir riesgos proceso prueba, como caídas del sistema rendi-miento inadecuado, resolver cómo mitigar dichos riesgos. . derivar pruebas aceptación una vez establecidos los criterios aceptación, tienen que diseñarse pruebas para comprobar sistema aceptable . las pruebas aceptación deben dirigirse probar tanto las características funcionales como las funcionales del sistema (por ejemplo, rendimiento). ideal sería que dieran cobertura completa los requerimientos del sistema. práctica, difícil establecer criterios aceptación completamente objetivos. con frecuencia hay espacio para argumentar sobre las pruebas deben mostrar que criterio cubre manera definitiva.definir criterios aceptacióncriterios prueba planear prueba aceptaciónderivar las pruebas aceptacióncorrer las pruebas aceptaciónnegociar los resultados pruebaaceptar rechazar sistemaplan pruebapruebasresultados pruebareporte prueba figura . proceso prueba aceptación -.indd -.indd // :: // :: capítulo ■ pruebas software . correr pruebas aceptación las pruebas aceptación acordadas ejecu- tan sobre sistema. manera ideal, esto debería ocurrir entorno real donde usará sistema, pero esto podría ser perturbador poco práctico. consecuencia, quizá deba establecerse entorno pruebas usuario para efectuar dichas prue-bas. difícil automatizar este proceso, que parte las pruebas aceptación podría necesitar poner prueba las interacciones entre usuarios finales sistema. posible que requiera cierta capacitación los usuarios finales. . negociar los resultados las pruebas poco probable que pasen todas las pruebas aceptación definidas que haya problemas con sistema. éste caso, entonces las pruebas aceptación están completas sistema está listo para entregarse. con mayor regularidad descubrirán algunos problemas. -les casos, desarrollador cliente tienen que negociar para decidir sistema suficientemente adecuado para ponerse uso. también deben acordar sobre respuesta del desarrollador para identificar problemas. . rechazo/aceptación del sistema esta etapa incluye una reunión entre los desarro-lladores cliente para decidir sistema debe aceptarse . sistema suficientemente bueno para usarse, entonces requiere mayor desarrollo para corregir los problemas identificados. una vez completo, repite fase pruebas aceptación. los métodos ágiles, como , las pruebas aceptación tienen significado tanto diferente. principio, comparten noción que son los usuarios quienes deciden sistema aceptable . sin embargo, , usuario forma parte del equipo desarrollo ( decir, examinador alfa) proporciona los requerimientos del sistema términos historias usuario. también responsable definir las pruebas, que permi-ten determinar software desarrollado soporta historia del usuario. las pruebas son automatizadas desarrollo avanza sino hasta que pasan las pruebas acepta-ción históricas. por consiguiente, hay una actividad separada pruebas aceptación. como estudió capítulo , problema con participación del usuario garantizar que quien inserte equipo desarrollo sea usuario “típico” con conocimiento general cómo usará sistema. quizá sea difícil encontrar tal usua-rio , por tanto, las pruebas aceptación realidad tal vez sean verdadero reflejo práctica. más aún, requerimiento pruebas automatizadas limita seve-ramente flexibilidad los sistemas interactivos pruebas. para tales sistemas, las pruebas aceptación podrían requerir que grupos usuarios finales usen sistema como fuera parte trabajo cotidiano. usted puede considerar que las pruebas aceptación son conflicto contractual tajante. sistema pasa sus pruebas aceptación, debe rechazarse pago realiza. sin embargo, realidad más compleja. los clientes quieren usar software tan pronto como puedan debido los beneficios despliegue inmediato. ellos quizá compraron nuevo hardware, capacitaron personal modificaron sus procesos. tal vez están deseosos aceptar software, sin importar los problemas, que los costos por usar software serían mayores que los trabajar torno los problemas. por consiguiente, resultado las negociaciones podría ser aceptación condicional del sistema. cliente acepta tal sistema para comenzar despliegue. proveedor del sis-tema acuerda reparar los problemas urgentes entregar una nueva versión cliente tan rápido como sea posible. -.indd -.indd // :: // :: pmcapítulo ■ lecturas sugeridas puntos clave ■ las pruebas sólo pueden mostrar presencia errores programa. embargo, pueden garantizar que surjan fallas posteriores. ■ las pruebas desarrollo son responsabilidad del equipo desarrollo del software. equipo independiente debe responsabilizarse probar sistema antes darlo conocer los clientes. proceso pruebas usuario, clientes usuarios del sistema brindan datos prueba verifican que las pruebas sean exitosas. ■ las pruebas desarrollo incluyen pruebas unidad, donde examinan objetos métodos individuales; pruebas componente, donde estudian grupos objetos relacionados; pruebas del sistema, donde analizan sistemas parciales completos. ■ cuando pruebe software, debe tratar “romperlo” mediante experiencia los lineamientos que elijan los tipos casos prueba que hayan sido efectivos para descubrir defectos otros sistemas. ■ siempre que sea posible, deben escribir pruebas automatizadas. las pruebas incrustan programa que puede correrse cada vez que hace cambio sistema. ■ desarrollo primera prueba enfoque desarrollo, donde las pruebas escriben antes que pruebe código. realizan pequeños cambios código, éste refactoriza hasta que todas las pruebas ejecuten exitosamente. ■ las pruebas escenario son útiles porque imitan uso práctico del sistema. implican trazar escenario uso típico utilizarlo para derivar casos prueba. ■ las pruebas aceptación son proceso prueba usuario, donde meta decidir software suficientemente adecuado para desplegarse utilizarse entorno operacional. lecturas sugeridas “how design practical test cases”. artículo práctico sobre diseño casos prueba elaborado por publicista una compañía japonesa, que tiene una muy buena reputación debido que entrega software con muy pocas fallas. (. yamaura, ieee software, (), noviembre .) http:/ /. doi. org/ . / . . how break software: practical guide testing. trata libro más práctico que teórico, sobre las pruebas software. autor presenta conjunto lineamientos basados experiencia relativa diseño pruebas, que probablemente sean efectivas detección fallas del sistema. (. . whittaker, addison-wesley, .) “software testing and verification”. este número especial del ibm systems journal comprende algunos ensayos pruebas, incluido buen panorama. además, incluye ensayos métricas prueba automatización pruebas. (ibm systems journal, (), enero .) “test-driven development”. este número especial acerca del desarrollo dirigido por pruebas, cual incluye buen panorama general del tdd, así como ensayos experiencia sobre cómo usó tdd para diferentes tipos software. (ieee software, () mayo/junio .) -.indd -.indd // :: // :: capítulo ■ pruebas software ejercicios .. explique por qué necesario que programa esté completamente libre defectos antes entregarse sus clientes. .. indique por qué las pruebas sólo pueden detectar presencia errores, pero ausencia. .. algunas personas argumentan que los desarrolladores deben intervenir las pruebas propio código, sino que todas las pruebas deben ser responsabilidad equipo independiente. exponga argumentos favor contra las pruebas efectuadas por parte los mismos desarrolladores. .. pide lector poner prueba método llamado “catwhitespace” objeto “paragraph” que, dentro del párrafo, sustituye secuencias caracteres blancos con solo carácter blanco. identifique las particiones prueba para este ejemplo derive conjunto pruebas para método “catwhitespace”. .. ¿qué prueba regresión? explique cómo uso pruebas automatizadas marco pruebas como junit simplifican las pruebas regresión. .. mhc-pms construyó adaptar sistema información comercial. ¿cuáles considera que son las diferencias entre probar tal sistema probar software que desarrolló usando lenguaje orientado objetos como java? .. diseñe escenario que pueda usar para ayudarse elaborar pruebas para sistema estación meteorológica campo abierto. .. ¿qué entiende por “pruebas esfuerzo”? sugiera cómo puede hacer una prueba esfuerzo del mhc-pms. .. ¿cuáles son los beneficios hacer participar usuarios las pruebas versión una etapa temprana del proceso pruebas? ¿hay desventajas implicación del usuario? .. enfoque común las pruebas del sistema probar sistema hasta que agote presupuesto pruebas , luego, entregar sistema los clientes. discuta ética este enfoque para sistemas que entregan clientes externos. referencias andrea, . (). “envisioning the next generation functional testing tools”. ieee software, (), –. beck, . (). test driven development: example. boston: addison-wesley.bezier, . (). software testing techniques, edition. new york: van nostrand rheinhold.boehm, . . (). “software engineering; & trends and defense needs.” research directions software technology. wegner, . (.). cambridge, mass.: mit press. –.cusamano, . selby, . . (). microsoft secrets. new york: simon and shuster. -.indd -.indd // :: // :: pmcapítulo ■ referencias dijkstra, . ., dahl, . . hoare, . . . (). structured programming. londres: academic press. fagan, . . (). “advances software inspections”. ieee trans. software eng., - (), –. jeffries, . melnik, . (). “tdd: the art fearless programming”. ieee software, , –. kaner, . (). “the power ‘what . . .’ and nine ways fuel your imagination: cem kaner scenario testing”. software testing and quality engineering, (), –. lutz, . . (). “analyzing software requirements errors safety-critical embedded systems”. ’, san diego, calif.: ieee. martin, . . (). “professionalism and test-driven development”. ieee software, (), –. massol, . husted, . (). junit action. greenwich, conn.: manning publications .prowell, . ., trammell, . ., linger, . . poore, . . (). cleanroom software engineering: technology and process. reading, mass.: addison-wesley.whittaker, . . (). how break software: practical guide testing . boston: addison- wesley. -.indd -.indd // :: // :: pmobjetivos los objetivos este capítulo son explicar por qué evolución del software forma parte importante ingeniería software, así como describir los procesos evolución del software. estudiar este capítulo: ■ comprenderá que cambio inevitable los sistemas software deben mantener utilidad, que desarrollo evolución del software pueden integrarse modelo espiral; ■ entenderá los procesos evolución del software las influencias sobre dichos procesos; ■ aprenderá sobre los diferentes tipos mantenimiento software los factores que afectan los costos mantenimiento; ■ conocerá cómo pueden valorarse los sistemas heredados para decidir deben descartar, mantener, someter reingeniería sustituir. contenido . procesos evolución . evolución dinámica del programa . mantenimiento del software . administración sistemas heredados evolución del software -.indd -.indd // :: // :: pmel desarrollo del software detiene cuando sistema entrega, sino que continúa largo vida éste. después distribuir sistema, inevitablemente debe modi-ficarse, con finalidad mantenerlo útil. tanto los cambios empresariales como los las expectativas del usuario generan nuevos requerimientos para software existente. posible que tengan que modificarse partes del software para corregir errores encontrados durante operación, para adaptarlo los cambios plataforma software hard-ware, para mejorar rendimiento otras características funcionales. evolución del software importante porque las organizaciones invierten grandes cantidades dinero actualidad son completamente dependientes dichos sistemas. sus sistemas consideran activos empresariales críticos, por que tienen que invertir cambio del sistema para mantener valor estos activos. consecuen-cia, las compañías más grandes gastan más conservar los sistemas existentes que desarrollo sistemas nuevos. con base una encuesta industrial informal, erlikh () sugiere que entre % los costos del software organizacional son costos evolución; mientras que otros estudios sugieren que éstos conforman alrededor dos tercios los costos del software. desde luego, los costos del cambio del software repre-sentan una gran parte del presupuesto todas las compañías. evolución del software puede potenciarse cambiar los requerimientos empre-sariales, con reportes defectos del software por cambios otros sistemas entorno del sistema software. hopkins jenkins () acuñaron término “desarrollo software abandonado” (subutilizado) para describir situaciones que los sistemas software tienen que desarrollarse gestionarse ambiente donde dependen muchos otros sistemas software. por consiguiente, evolución sistema rara vez puede considerarse aisla-miento. los cambios entorno conducen cambios sistema que, vez, pueden generar más cambios entorno. desde luego, hecho que los sistemas tengan que evolucionar ambiente “rico sistemas” con frecuencia aumenta las dificultades los costos evolución. además comprender analizar impacto cambio propuesto sobre sistema , también probable que deba valorar cómo esto afec-taría otros sistemas entorno operacional. por general, los sistemas software útiles tienen una vida muy larga. por ejemplo, los grandes sistemas militares infraestructura, como los control tráfico aéreo, llegan durar años más; tanto que los sistemas empresariales con frecuencia superan los años. puesto que costo del software elevado, una compañía debe usar sistema software durante muchos años para recuperar inversión. evidentemente, los requerimientos los sistemas instalados cambian conforme hacen negocio entorno. por consiguiente, crean intervalos regulares nuevas versiones los siste-mas, las cuales incorporan cambios actualizaciones. por ende, ingeniería software debe considerar como proceso espiral, con requerimientos, diseño, implementación pruebas continuas, largo vida del sistema (figura .). esto comienza por crear versión del sistema. una vez entregada, proponen cambios casi inmediato comienza desarrollo versión . hecho, necesidad evolución puede volverse evidente incluso antes que sistema distribuya, manera que las futuras versiones del software estarían desarrollo antes que libere versión actual. este modelo evolución software implica que una sola organización responsable tanto del desarrollo del software inicial como evolución del software. mayoría los productos software empacados desarrollan siguiendo este enfoque. para software personalizado, por general utiliza enfoque diferente. una compañía capítulo ■ evolución del software -.indd -.indd // :: // :: capítulo ■ evolución del software software desarrolla para cliente , luego, personal desarrollo del propio clien- hace cargo del sistema. ellos son los responsables evolución del software. forma alternativa, cliente del software puede otorgar por separado contrato una compañía diferente, con finalidad que soporte sistema continuar evolución. este caso, probable que existan discontinuidades proceso espiral. los docu-mentos requerimientos diseño quizá compartan entre una compañía otra. éstas podrían fusionarse reorganizarse heredar software otras compañías, para luego descubrir que este último tiene que cambiarse. cuando transición del desarrollo evolución uniforme, proceso cambiar software después entrega conoce como “mantenimiento software”. como analizará más adelante este capí-tulo, mantenimiento incluye actividades proceso adicionales, como comprensión del programa, además las actividades normales desarrollo del software. rajlich bennett () propusieron una visión alternativa del ciclo vida evo-lución del software, como indica figura .. ese modelo, distinguen entre evolu-ción servicio. evolución fase donde posible hacer cambios significativos arquitectura funcionalidad del software. durante servicio, los únicos cambios que realizan son relativamente pequeños. durante evolución, software usa con éxito hay flujo constante propues-tas cambios los requerimientos. sin embargo, conforme software modifica, estructura tiende degradarse los cambios vuelven más más costosos. esto sucede con frecuencia después algunos años uso, cuando también requieren otros cam-bios ambientales como hardware los sistemas operativos. alguna etapa ciclo vida, software alcanza punto transición donde los cambios significativos que implementan nuevos requerimientos vuelven cada vez menos rentables. desarrollo inicialevolución servicio retiro gradual figura . evolución servicioespecificación implementación validación operaciónversión versión versión etc.inicio figura . modelo espiral desarrollo evolución -.indd -.indd // :: // :: . ■ procesos evolución dicha fase, software avanza evolución servicio. durante fase ser- vicio, software todavía útil utiliza, pero sólo realizan pequeños cambios tácticos. durante esta fase, compañía normalmente considera cómo reemplazar soft-ware. fase final, retiro gradual ( phase-out), software todavía puede usarse, aunque implementan más cambios. los usuarios tienen que sobrellevar cualquier problema que descubran. . procesos evolución los procesos evolución del software varían dependiendo del tipo software que mantiene, los procesos desarrollo usados organización las habilidades las personas que intervienen. algunas organizaciones, evolución proceso informal, donde las solicitudes cambios provienen sobre todo conversaciones entre los usuarios del sistema los desarrolladores. otras compañías, trata proceso formalizado con documentación estructurada generada cada etapa del proceso. las propuestas cambio sistema son motor para evolución del sistema todas las organizaciones. estos cambios provienen requerimientos existentes que hayan implementado sistema liberado, peticiones nuevos requerimientos, reportes bugs los participantes del sistema, nuevas ideas para mejora del software por parte del equipo desarrollo del sistema. los procesos identificación cambios evolución del sistema son cíclicos continúan largo vida sistema (figura .). las propuestas cambio deben vincularse con los componentes del sistema que van modificar para implementar dichas propuestas. esto permite que costo impacto del cambio logren valorarse. anterior forma parte del proceso general administración del cambio, que también debe garantizar inclusión versiones correc-tas los componentes cada versión del sistema. capítulo estudiará administración del cambio configuración.proceso evolución del softwarepropuestas cambio nuevo sistemaproceso identificación del cambio figura . identificación del cambio procesos evolución -.indd -.indd // :: // :: capítulo ■ evolución del software figura ., adaptada arthur (), muestra panorama del proceso evolu- ción, cual incluye actividades fundamentales análisis del cambio, planeación versión, implementación del sistema liberación los clientes. costo impacto dichos cambios valoran para saber qué tanto resultará afectado sistema por cambio cuánto costaría implementarlo. los cambios propuestos aceptan, pla-nea una nueva versión del sistema. durante planeación versión consideran todos los cambios propuestos (reparación fallas, adaptación nueva funcionalidad). entonces toma una decisión acerca cuáles cambios implementar siguiente ver-sión del sistema. después implementarse, valida libera una nueva versión del sistema. luego, proceso repite con conjunto nuevo cambios propuestos para siguiente liberación. posible considerar implementación del cambio como una iteración del proceso desarrollo, donde las revisiones sistema diseñan, aplican ponen prueba. sin embargo, una diferencia crítica que primera etapa implementación del cam-bio puede involucrar comprensión del programa, sobre todo los desarrolladores del sistema original son los responsables implementar cambio. durante esta fase comprensión del programa, hay que entender cómo está estructurado, cómo entrega funcionalidad cómo afectaría cambio propuesto. necesita esta comprensión para asegurarse que cambio implementado cause nuevos problemas, cuando introduzca sistema existente. manera ideal, etapa implementación del cambio este proceso debe modifi-car especificación, diseño implementación del sistema para reflejar los cambios mismo (figura .). proponen, analizan validan los nuevos requerimientos que reflejan los cambios sistema. los componentes del sistema rediseñan implemen-tan, sistema vuelve probarse. adecuado, como parte del proceso análisis cambio, podrían elaborarse prototipos con los cambios propuestos. durante proceso evolución, analizan detalle los requerimientos surgen implicaciones los cambios que eran aparentes comienzo del proceso análisis cambio. esto significa que los cambios propuestos pueden modificarse quizá requieran más pláticas con cliente antes implementación. ocasiones, las peticiones cambio relacionan con problemas del sistema que tienen que enfrentarse manera urgente. estos cambios urgentes surgen básicamente por tres razones: . ocurre una falla seria del sistema que deba repararse para permitir que continúe operación normal.planeación versióncambio implementaciónliberación del sistemaanálisis del impactopeticiones cambio adaptación plataformamejora del sistemareparación fallas figura . proceso evolución del software -.indd -.indd // :: // :: . ■ procesos evolución . los cambios los sistemas que operan entorno tienen efectos inesperados que perturban operación normal. . hay cambios anticipados empresa que opera sistema, como surgi-miento competidores nuevos introducción una nueva legislación que afecte sistema. tales casos, necesidad realizar cambio rápidamente significa que quizá pueda seguir proceso formal análisis cambio. vez modificar los requerimien-tos diseño, puede hacer una reparación emergencia programa para resolver problema inmediato (figura .). sin embargo, riesgo que los requerimientos, diseño del software código vuelvan inconsistentes. aunque trate documentar cambio los requerimientos diseño, posible que software requiera reparacio-nes emergencia adicionales, las cuales tienen prioridad sobre documentación. con tiempo, cambio original olvida documentación código del sistema nunca realinean. por general, las reparaciones emergencia del sistema tienen que completarse tan rápido como sea posible. elige una solución rápida viable, lugar mejor solución cuanto estructura del sistema. esto acelera proceso degeneración del software, modo que los cambios futuros vuelven progresivamente más difíciles , con ello, aumenta costo mantenimiento. idealmente, cuando hacen reparaciones emergencia código, petición cambio debería quedar pendiente después reparar las fallas código. entonces, pueden volver implementar manera más cuidadosa después mayor análisis. desde luego, código reparación reutilizable. una mejor solución problema surgirá cuando haya más tiempo disponible para análisis. sin embargo, práctica casi inevitable que dichas mejoras tengan baja prioridad. con frecuencia olvidan , realizan más cambios sistema, entonces vuelve imposible reelaborar las repa-raciones emergencia. los métodos procesos ágiles, que estudiaron capítulo , utilizan tanto para evolución del programa como para desarrollo. hecho, puesto que dichos métodos basan desarrollo incremental, hacer transición del desarrollo ágil evolución posterior entrega debería tener complicaciones. las técnicas como las pruebas regresión automatizadas son útiles cuando realizan cambios sistema. los cambios pueden expresarse como historias usuario, involucramiento del cliente priorizará los cambios que requieran sistema operacional. resumen, evolu-ción simplemente implica continuación del proceso desarrollo ágil.actualización requerimientosdesarrollo del softwareanálisis requerimientoscambios propuestosfigura . implementación del cambio modificar código fuenteentregar sistema modificadoanalizar código fuentepeticiones cambiofigura . proceso reparación emergencia -.indd -.indd // :: // :: capítulo ■ evolución del software sin embargo, posible que surjan problemas situaciones donde haya transferencia equipo desarrollo equipo separado responsable evolución. existen dos situaciones potencialmente problemáticas: . donde equipo desarrollo haya usado enfoque ágil, pero equipo evolu- ción esté familiarizado con los métodos ágiles prefiera enfoque basado plan. quizás equipo evolución espere documentación detallada para apoyar evolución, esto rara vez sucede los procesos ágiles. podría haber enun-ciado definitivo los requerimientos del sistema que sea modificable conforme realizan cambios sistema. . donde haya usado enfoque basado plan para desarrollo, pero equipo evolución prefiera usar métodos ágiles. este caso, equipo evolución tal vez deba comenzar desde cero para desarrollar pruebas automatizadas , además, posible que código sistema haya refactorizado simplificado como espera desarrollo ágil. este caso, tal vez requiera algo reingeniería para mejorar código, antes usarlo proceso desarrollo ágil. poole huisman () reportan sus experiencias uso programación extrema, para mantener sistema grande que originalmente desarrolló usando enfoque basado plan. después someter sistema reingeniería para mejorar estruc-tura, usó con mucho éxito proceso mantenimiento. . evolución dinámica del programa dinámica evolución del programa estudio del cambio sistema. las décadas , lehman belady () realizaron varios estudios empíricos acerca del cambio sistema, con una visión para entender más sobre las características evolución del software. trabajo continuó década , conforme lehman sus colegas investigaron importancia retroalimentación los procesos evolución (lehman, ; lehman ., ; lehman ., ). partir estos estudios, propusieron las “leyes lehman” relacionadas cambio del sistema (figura .). lehman belady afirman que dichas leyes suelen ser verdaderas para todos los tipos sistemas software organizacional grandes (los llamados sistemas tipo ). trata sistemas los cuales los requerimientos modifican para reflejar las necesidades cam-biantes empresa. las nuevas versiones del sistema son esenciales para que éste proporcione valor negocio. primera ley afirma que mantenimiento del sistema proceso inevitable. medida que cambia entorno del sistema, surgen nuevos requerimientos sistema debe modificarse. cuando sistema modificado reintroduce entorno, promueve más cambios ambientales, manera que proceso evolución comienza nuevo. segunda ley afirma que, conforme cambia sistema, estructura degrada. única manera evitar que esto ocurra invertir mantenimiento preventivo. invierte tiempo mejorando estructura del software sin agregar nada funcionali-dad. evidentemente, esto significa costos adicionales, por encima los asignados para implementar los cambios requeridos sistema. -.indd -.indd // :: // :: . ■ evolución dinámica del programa tercera ley , quizá, más interesante polémica las leyes lehman. sugiere que los sistemas grandes tienen una dinámica propia que establece una etapa tem-prana del proceso desarrollo. esto determina las grandes tendencias del proceso mantenimiento del sistema limita número cambios posibles sistema. lehman belady sugieren que esta ley consecuencia factores estructurales que influyen cambio sistema restringen, así como factores organizacionales que afectan pro-ceso evolución. los factores estructurales que afectan tercera ley provienen complejidad los sistemas grandes. conforme cambia extiende programa, estructura tiende degradarse. esto verdadero para todos los tipos sistemas ( sólo para software) ocurre porque una estructura con propósito específico adapta para uno diferente. esta degradación, controla, hace cada vez más difícil realizar cambios ulteriores programa. hacer pequeños cambios reduce alcance degradación estructural , por consiguiente, aminora los riesgos causar serios problemas confiabilidad del sistema. realizan grandes cambios, hay una alta probabilidad que introduzcan nuevas fallas, los cuales impedirían más cambios programa. los factores organizacionales que afectan tercera ley reflejan hecho que, por general, los sistemas grandes producen organizaciones grandes. estas compañías tienen burocracias internas que establecen los presupuestos cambio para cada sistema controlan proceso toma decisiones. las empresas deben tomar decisiones sobre los riesgos valor los cambios, así como sobre los costos inherentes. tales deci-siones toman tiempo , ocasiones, tardan más para decidir acerca los cambios por ley descripción cambio continuo programa usado entorno real debe cambiar; otro modo, dicho entorno volvería progresivamente inútil. complejidad creciente medida que cambia programa evolución, estructura tiende volverse más compleja. deben dedicarse recursos adicionales para conservar simplificar estructura. evolución programa grandela evolución del programa proceso autorregulador. los atributos del sistema, como tamaño, tiempo entre versiones número errores reportados, son casi invariantes para cada versión del sistema. estabilidad organizacional durante vida programa, tasa desarrollo aproximadamente constante independiente los recursos dedicados desarrollo del sistema. conservación familiaridada largo existencia sistema, cambio incremental cada liberación casi constante. crecimiento continuo funcionalidad ofrecida por los sistemas tiene que aumentar continuamente para mantener satisfacción del usuario. declive calidad calidad los sistemas declinará, menos que modifiquen para reflejar los cambios entorno operacional. sistema retroalimentación los procesos evolución incorporan sistemas retroalimentación multiagente multiciclo. además, deben tratarse como sistemas retroalimentación para lograr una mejora significativa del producto. figura . leyes lehman -.indd -.indd // :: // :: capítulo ■ evolución del software realizar que para implementarlos. consecuencia, rapidez los procesos toma decisiones organización controla tasa cambio del sistema. cuarta ley lehman sugiere que mayoría los grandes proyectos pro-gramación funcionan estado “saturado”. decir, cambio los recursos personal tiene efectos imperceptibles evolución largo plazo del sistema. esto congruente con tercera ley, que sugiere que evolución del programa gran medida independiente las decisiones administrativas. esta ley confirma que los grandes equipos desarrollo software con frecuencia son improductivos, porque los gastos comunicación dominan trabajo del equipo. quinta ley lehman relaciona con los incrementos cambio cada versión del sistema. agregar nueva funcionalidad sistema introduce inevitablemente nuevas fallas mismo. cuanto más funcionalidad agregue cada versión, más fallas habrá. por consiguiente, gran incremento funcionalidad una versión del sistema sig-nifica que esto tendrá que seguir una versión ulterior, donde reparen las fallas del nuevo sistema. dicha versión debe agregarse relativamente poca funcionalidad. esta ley sugiere que deben presupuestar grandes incrementos funcionalidad cada versión, sin tomar cuenta necesidad reparación las fallas. las primeras cinco leyes fueron las propuestas iniciales lehman; las leyes restan-tes agregaron después trabajo posterior. las leyes sexta séptima son similares , esencia, indican que los usuarios software volverán cada vez más infortunados con sistema, menos que mantenga agregue nueva funcionalidad. ley final refleja trabajo más reciente sobre los procesos retroalimentación, aunque toda-vía está claro cómo aplica desarrollo software práctico. general, las observaciones lehman parecen sensatas. hay que tomarlas cuenta cuando planee proceso mantenimiento. podría suceder que las considera-ciones empresariales requieran ignorarlas algún momento. por ejemplo, por razones marketing, quizá sea necesario realizar muchos cambios significativos sistema una sola versión. consecuencia probable esto que tal vez requieran una más versiones dedicadas reparación del error. menudo esto observa software computadoras personales, cuando una nueva gran versión alguna aplicación con frecuencia viene seguida por una actualización para reparar bug. . mantenimiento del software mantenimiento del software proceso general cambiar sistema después que éste entregó. término usualmente aplica software personalizado, que gru-pos desarrollo separados intervienen antes después entrega. los cambios rea-lizados software van desde los simples para corregir errores codificación, los más extensos para corregir errores diseño, hasta mejorías significativas para corregir errores especificación incorporar nuevos requerimientos. los cambios implementan modi-ficando los componentes del sistema existentes agregándole nuevos componentes donde sea necesario. existen tres tipos mantenimiento software: . reparaciones fallas los errores codificación por general son relativa- mente baratos corregir; los errores diseño son más costosos, que quizás impliquen reescritura muchos componentes del programa. los errores -.indd -.indd // :: // :: . ■ mantenimiento del software requerimientos son los más costosos reparar debido que podría ser necesario extenso rediseño del sistema. . adaptación ambiental este tipo mantenimiento requiere cuando algún -pecto del entorno del sistema, como hardware, plataforma operativa del sistema otro soporte, cambia software. sistema aplicación tiene que modificarse para lidiar con dichos cambios ambientales. . adición funcionalidad este tipo mantenimiento necesario cuando varían los requerimientos del sistema, respuesta cambio organizacional empresa-rial. escala los cambios requeridos software suele ser mucho mayor que los otros tipos mantenimiento. práctica, hay una distinción clara entre estos tipos mantenimiento. cuando adapta sistema nuevo entorno, puede agregar funcionalidad para sacar ven-taja las nuevas características del entorno. las fallas desarrollo del software con frecuencia quedan expuestas debido que los usuarios usan sistema formas anticipadas. cambiar sistema para adaptar forma trabajar mejor forma corregir dichas fallas. estos tipos mantenimiento reconocen comúnmente, pero diferentes personas ocasiones les dan diferentes nombres. manera universal usa término “mante-nimiento correctivo” para referirse mantenimiento para reparación fallas desa-rrollo. por otro lado, “mantenimiento adaptativo” algunas veces quiere decir adaptarse nuevo entorno otras veces significa adaptar software nuevos requerimientos. “mantenimiento perfectivo” veces significa perfeccionar software implementar nuevos requerimientos; otros casos representa mantener funcionalidad del sistema, pero mejorando estructura rendimiento. debido incertidumbre torno nomenclatura, este capítulo evitó uso tales términos. han realizado varios estudios sobre mantenimiento del software que observan las relaciones entre mantenimiento desarrollo, así como entre las diferentes actividades mantenimiento (krogstie ., ; lientz swanson, ; nosek palvia, ; sousa, ). debido diferencias terminología, los detalles estos estudios pueden compararse. pesar los cambios tecnología los diferentes dominios aplicación, parece que, desde década , sido notable cambio moderado que habido distribución del esfuerzo evolución. los estudios concuerdan ampliamente que mantenimiento del software toma una proporción más alta presupuestos que nuevo desarrollo (casi dos tercios mantenimiento tercio desarrollo). también coinciden que una mayor parte del presupuesto mantenimiento destina implementación nuevos requerimientos, reparación bugs. figura . muestra una distribución aproximada los costos mantenimiento. evidentemente, los porcentajes específicos variarán una orga-nización otra pero, manera universal, reparar las fallas del desarrollo del sistema actividad mantenimiento más costosa. evolucionar sistema para enfrentar nuevos entornos requerimientos nuevos cambiantes consume más esfuerzo mantenimiento. los costos relativos mantenimiento del nuevo desarrollo varían dominio aplicación otro. guimaraes () descubrió que los costos mantenimiento para sistemas aplicación empresarial son ampliamente comparables con los costos desa-rrollo del sistema. para sistemas embebidos tiempo real, los costos mantenimiento fueron hasta cuatro veces mayores que los costos desarrollo. los requerimientos alta -.indd -.indd // :: // :: capítulo ■ evolución del software fiabilidad rendimiento dichos sistemas significan que los módulos deben estar estre- chamente ligados , por tanto, son difíciles cambiar. aunque estas estimaciones tienen más años antigüedad, improbable que las distribuciones costos para diferentes tipos sistema hayan cambiado significativamente. por general, resulta efectivo costo invertir esfuerzo diseño implemen-tación sistema, con finalidad reducir los costos cambios futuros. agregar nueva funcionalidad después entrega costoso porque toma tiempo aprender cómo funciona sistema analizar impacto los cambios propuestos. por tanto, posi-ble que trabajo realizado durante desarrollo para hacer que software sea más fácil entender, cambiar, reduzca los costos evolución. las buenas técnicas ingeniería software, como especificación precisa, uso desarrollo orientado objetos administración configuración, contribuyen reducir los costos mantenimiento. figura . muestra cómo disminuyen los costos totales vida del sistema con-forme emplea más esfuerzo durante desarrollo, para producir sistema manteni-ble. debido reducción potencial costos comprensión, análisis pruebas, hay significativo efecto multiplicador cuando sistema desarrolla para ser mantenible. para sistema , los $, por costos adicionales desarrollo invirtieron para hacer sistema más mantenible. esto como resultado ahorro $ costos mantenimiento durante vida del sistema. esto supone que aumento porcentual adición modificación funcionalidad (%)reparación fallas desarrollo (%) adaptación ambiental (%) figura . distribución del esfuerzo mantenimiento sistema costos desarrollo costos mantenimiento$ figura . costos desarrollo mantenimiento -.indd -.indd // :: // :: . ■ mantenimiento del software costos desarrollo como resultado una reducción porcentual comparable cos- tos totales del sistema. dichas estimaciones son hipotéticas; sin embargo, hay duda que desarrollar soft-ware para hacerlo más mantenible efectivo costo, toman cuenta todos los costos por vida. ésta razón para refactorizar desarrollo ágil. sin refactori-zación, código vuelve cada vez más difícil costoso cambiar. sin embargo, desarrollo basado plan, realidad que inversión adicional mejoramien- del código rara vez hace durante desarrollo. esto debe principalmente las formas que mayoría las organizaciones aplican sus presupuestos. invertir mantenibilidad conduce aumentos costo corto plazo, los cuales son mensurables. por desgracia, las ganancias largo plazo pueden medirse mismo tiempo, modo que las compañías son renuentes gastar dinero rendimiento futuro incierto. general, resulta más costoso agregar funcionalidad después que sistema está operación, que implementar misma funcionalidad durante desarrollo. las razones son: . estabilidad del equipo después que sistema entrega, normal que equipo desarrollo separe que los individuos trabajen nuevos proyectos. nuevo equipo los individuos responsables del mantenimiento del sistema entienden sistema los antecedentes las decisiones diseño del mismo. necesitan emplear tiempo para comprender sistema existente, antes implementar cambios . . práctica desarrollo deficiente contrato para mantener sistema por general está separado del contrato desarrollo del sistema. contrato manteni-miento puede otorgarse una compañía diferente, desarrollador original del sistema. este factor, junto con falta estabilidad del equipo, indica que hay incentivo para que equipo desarrollo escriba software mantenible. equipo desarrollo puede buscar atajos para ahorrar esfuerzo durante desarrollo, para ellos vale pena hacerlo, incluso esto significa que software sea más difícil cambiar futuro. . habilidades del personal personal mantenimiento con frecuencia relati-vamente inexperto está familiarizado con dominio aplicación. mante-nimiento tiene una mala imagen entre los ingenieros software. ven como proceso que requiere menos habilidades que desarrollo sistemas asigna menudo personal más novato. más aún, los sistemas antiguos pueden estar escri-tos lenguajes programación obsoletos. posible que personal man-tenimiento tenga mucha experiencia desarrollo estos lenguajes debe aprenderlos para mantener sistema.sistemas heredados los sistemas heredados son sistemas antiguos que todavía son útiles ocasiones críticos para operación empresa. pueden implementarse usando lenguajes tecnología obsoletos, utilizar otros sistemas que sean costosos mantener. normalmente estructura degradado por cambios documentación está extraviada desactualizada. obstante, quizá sea efectivo costo sustituir tales sistemas. quizá sólo usen algunas veces año sea demasiado riesgoso sustituirlos porque hayan perdido las especificaciones. http:// -.indd -.indd // :: // :: capítulo ■ evolución del software . antigüedad estructura del programa conforme realizan cambios programa, estructura tiende degradarse. consecuencia, medida que los programas envejecen, vuelven más difíciles entender cambiar. algunos sistemas desarrollaron sin técnicas modernas ingeniería software. posible que nunca hayan estado bien estructurados tal vez estuvieron optimizados para eficiencia para comprensibilidad. documentación del sistema puede estar perdida ser inconsistente. posible que los sistemas antiguos hayan sujetado una ges-tión rigurosa configuración, modo que desperdicia tiempo para encontrar las versiones correctas los componentes del sistema cambiar. los primeros tres estos problemas surgen del hecho que muchas organizacio-nes todavía consideran desarrollo mantenimiento como actividades separadas. mantenimiento como una actividad segunda clase, hay incentivo para gastar dinero durante desarrollo para reducir los costos del cambio sistema. única solu-ción largo plazo este problema aceptar que los sistemas rara vez tienen una vida definida pero continúan uso, cierta forma, durante periodo indefinido. como sugirió introducción, debe considerar que los sistemas evolucionan largo vida durante proceso desarrollo continuo. cuarto conflicto, problema estructura degradada del sistema más sencillo enfrentar. las técnicas reingeniería software (que describen más ade-lante este capítulo) son aplicables para mejorar estructura comprensibilidad del sistema. transformaciones arquitectónicas pueden adaptar sistema hardware nuevo. refactorización mejora calidad del código del sistema facilita cambio. .. predicción mantenimiento los gerentes aborrecen las sorpresas, sobre todo derivan costos inesperadamente elevados. por consiguiente, debe tratar predecir qué cambios deben proponerse sistema qué partes del sistema probable que sean las más difíciles mantener. también hay que tratar estimar los costos mantenimiento globales para sistema durante cierto lapso tiempo. figura . muestra dichas predicciones las pregun-tas asociadas. predecir número peticiones cambio para sistema requiere entendi-miento relación entre sistema ambiente externo. algunos sistemas tienen unadocumentación documentación del sistema ayuda proceso mantenimiento proporcionar quienes dan mantenimiento información acerca estructura organización del sistema, así como las características que ofrece los usuarios del sistema. aunque los defensores los enfoques ágiles, como , sugieren que código debe ser principal documentación, los modelos diseño alto nivel información acerca dependencias restricciones facilitarán comprensión realización cambios código. autor escribió capítulo aparte sobre documentación que lector puede descargar. http:// -.indd -.indd // :: // :: . ■ mantenimiento del software relación muy compleja con ambiente externo, los cambios dicho entorno inevita- blemente derivarán cambios sistema. para evaluar las relaciones entre sistema ambiente, debe valorar: . número complejidad las interfaces del sistema cuanto más grande sea número interfaces más complejas sean dichas interfaces, más probable será que requieran cambios interfaz conforme propongan nuevos requerimientos. . número requerimientos sistema inherentemente inestables como estu-dió capítulo , más probable que los requerimientos que reflejan políticas procedimientos organización sean más inestables que los requerimientos que basan características dominio estable. . los procesos empresariales donde usa sistema medida que evolucionan los procesos empresariales, generan peticiones cambio del sistema. cuantos más proce-sos use sistema, habrá más demandas cambio del mismo. durante muchos años, los investigadores han observado las relaciones entre complejidad del programa, medidas por métricas como complejidad ciclomática (mccabe, ) mantenibilidad (banker ., ; coleman ., ; kafura reddy, ; kozlov ., ). debería sorprender que dichos estudios descubrieran que, cuanto más complejo sea sistema componente, más costoso será darle mantenimiento. las mediciones complejidad son muy útiles para identificar componentes programa que suelen ser costosos mantener. kafura reddy () examinaron algunos componen-tes del sistema descubrieron que esfuerzo mantenimiento tendía enfocarse pequeño número componentes complejos. por ello, para reducir los costos manteni-miento, debe tratar sustituir los componentes complejos del sistema con alternativas más sencillas. después poner servicio sistema, deben usar datos proceso para auxi-liarse predecir mantenibilidad. los siguientes son ejemplos métricas proceso que sirven para valorar mantenibilidad:predicción mantenibilidad predicción cambios sistemapredicción costos mantenimiento¿cuáles serán los costos mantenimiento durante vida este sistema? ¿cuáles serán los costos mantener este sistema durante próximo año?¿qué partes del sistema serán las más costosas mantener? ¿cuántas peticiones cambio pueden esperarse?¿qué partes del sistema tienen más probabilidad resultar afectadas por peticiones cambio? figura . predicción mantenimiento -.indd -.indd // :: // :: capítulo ■ evolución del software . número peticiones para mantenimiento correctivo aumento número reportes bugs fallas indicaría que introdujeron más errores programa los que repararon durante proceso mantenimiento. esto podría revelar declive mantenibilidad. . tiempo promedio requerido para análisis del impacto refleja número com-ponentes programa que ven afectados por petición cambio. este tiempo aumenta, implica que más componentes resultaron afectados que mantenibili-dad decrece. . tiempo promedio tomado para implementar una petición cambio éste mismo que tiempo para análisis del impacto, aunque puede correlacionarse con , sino más bien cantidad tiempo que necesita para modificar sis-tema documentación, después valorar cuáles componentes serán afectados. aumento tiempo necesario para implementar cambio puede indicar declive mantenibilidad. . número peticiones cambio pendientes con tiempo, aumento este número implicaría declive mantenibilidad. información predicha sobre las peticiones cambio las predicciones acerca mantenibilidad del sistema usan para predecir los costos mantenimiento. mayoría los gerentes combinan esta información con intuición experiencia para estimar costos. modelo cocomo estimación costos (boehm ., ), que estudia capítulo , sugiere que una estimación del esfuerzo manteni-miento del software puede basarse esfuerzo por comprender código existente, así como esfuerzo para desarrollar nuevo código. .. reingeniería software como estudió sección anterior, proceso evolución del sistema incluye comprender programa que debe cambiarse , luego, implementar dichos cambios. sin embargo, muchos sistemas, especialmente los sistemas heredados más antiguos, son difí-ciles entender cambiar. posible que los programas hayan optimizado para rendimiento utilización espacio expensas claridad , con tiempo, estruc-tura inicial del programa quizá corrompió debido una serie cambios. para hacer que los sistemas software heredados sean más sencillos mantener, pueden someter reingeniería para mejorar estructura entendimiento. reingenie-ría puede implicar volver documentar sistema, refactorizar arquitectura, traducir los programas lenguaje programación moderno, modificar actualizar estructura los valores los datos del sistema. funcionalidad del software cambia , normal-mente, conviene tratar evitar grandes cambios arquitectura sistema. hay dos beneficios importantes reingeniería respecto sustitución: . reducción del riesgo hay alto riesgo desarrollo software empresarial crítico. pueden cometerse errores especificación del sistema tal vez haya problemas desarrollo. las demoras introducción del nuevo software podrían significar que empresa está perdida que incurrirá costos adicionales. -.indd -.indd // :: // :: . ■ mantenimiento del software . reducción costos costo reingeniería puede ser significativamente menor que costo desarrollar software nuevo. ulrich () cita ejemplo sistema comercial para cual los costos reimplementación estimaron $ millones. sistema tuvo reingeniería exitosa por $ millones. con tecnolo-gía software moderna, costo relativo reimplementación quizá sea menor que esto, pero todavía superará considerablemente los costos reingeniería. figura . modelo general del proceso reingeniería. entrada proceso sistema heredado, tanto que salida una versión mejorada reestructurada del mismo programa. las actividades este proceso reingeniería son las siguientes: . traducción del código fuente con una herramienta traducción, programa convierte lenguaje programación antiguo una versión más moderna del mismo lenguaje, lenguaje diferente. . ingeniería inversa programa analiza extrae información . esto ayuda documentar organización funcionalidad. nuevo, este proceso , por general, completamente automatizado. . mejoramiento estructura del programa estructura control del pro-grama analiza modifica para facilitar lectura comprensión, cual suele estar parcialmente automatizado, pero requiere regularmente alguna intervención manual. . modularización del programa las partes relacionadas del programa agrupan , donde adecuado, elimina redundancia. algunos casos, esta etapa impli-cará refactorización arquitectónica (por ejemplo, sistema que use muchos alma-cenes datos diferentes puede refactorizarse para usar solo depósito). éste proceso manual. . reingeniería datos los datos procesados por programa cambian para reflejar cambios programa. esto puede significar redefinición los esquemas bases datos convertir las bases datos existentes nueva estructura. por general,ingeniería inversadocumentación del programa mejora estructura del programamodularización del programa programa reestructuradoreingeniería datos datos con reingenieríadatos originalesprograma con reingenieríaprograma original traducción código fuente figura . proceso reingeniería -.indd -.indd // :: // :: capítulo ■ evolución del software hay que limpiar los datos. esto implica encontrar corregir errores, eliminar regis- tros duplicados, etcétera. hay herramientas disponibles para auxiliar reingenie- ría datos. reingeniería programas necesariamente requiere todos los pasos figura .. necesita traducción del código fuente, todavía usa lenguaje progra-mación aplicación. logra hacer automáticamente toda reingeniería, entonces quizá sea necesaria recuperación documentación mediante ingeniería inversa. reingeniería datos sólo requiere cuando las estructuras datos programa cambian durante reingeniería del sistema. para hacer que sistema con reingeniería interopere con nuevo software, tal vez tengan que desarrollar servicios adaptadores, como estudia capítulo . éstos ocultan las interfaces originales del sistema software presentan las nuevas inter-faces, mejor estructuradas, que pueden usarse con otros componentes. este proceso envolvimiento los sistemas heredados una importante técnica para desarrollar ser-vicios reutilizables gran escala. los costos reingeniería dependen evidentemente extensión del trabajo que realiza. existe espectro posibles enfoques reingeniería, como muestra figura .. los costos aumentan izquierda derecha, modo que traducción del código fuente opción más barata. reingeniería como parte migración arqui-tectónica más costosa. problema con reingeniería software que existen límites prácticos cuánto mejora sistema gracias reingeniería. posible, por ejemplo, convertir sistema escrito con enfoque funcional, sistema orientado objetos. los grandes cambios arquitectónicos reorganización radical gestión los datos del sistema pueden realizarse automáticamente, modo que son muy costosos. aunque rein-geniería podría mejorar mantenibilidad, sistema con reingeniería probablemente será tan mantenible como sistema nuevo desarrollado usando modernos métodos ingeniería software. .. mantenimiento preventivo mediante refactorización refactorización proceso hacer mejoras programa para frenar degrada-ción mediante cambio (opdyke johnson, ). ello significa modificar programa para mejorar estructura, reducir complejidad hacerlo más fácil entender. veces considera que refactorización está limitada desarrollo orientado objetos, pero los principios son aplicables cualquier enfoque desarrollo. mientras refacto-reestructuración automatizada con cambios manualesconversión automatizada del código fuentereestructuración más cambios arquitectónicosreestructuración automatizada del programareestructuración del programa datos aumento costo figura . enfoques reingeniería -.indd -.indd // :: // :: . ■ mantenimiento del software rice programa, debe agregar funcionalidad, sino que hay que concentrarse mejora del programa. por ende, puede considerar refactorización como “manteni-miento preventivo” que reduce los problemas cambios futuros. aunque reingeniería refactorización tienen intención hacer software más fácil entender cambiar, son mismo. reingeniería lleva cabo des-pués haber mantenido sistema durante cierto tiempo , por consiguiente, los costos mantenimiento aumentan. usan herramientas automatizadas para procesar some-ter reingeniería sistema heredado así crear nuevo sistema que sea más mante-nible. refactorización proceso continuo mejoramiento debido proceso desarrollo evolución. tiene intención evitar degradación estructura código que aumentan los costos las dificultades por mantener sistema. refactorización una parte inherente los métodos ágiles, como pro-gramación extrema, porque dichos métodos basan cambio. consecuencia, calidad del programa proclive degradarse rápidamente, modo que los desarrolla-dores ágiles con frecuencia refactorizan sus programas para evitar tal degradación. énfasis las pruebas regresión los métodos ágiles reduce riesgo introducir nuevos errores través refactorización. cualquier error que introduzca debe ser detectable, que las pruebas anteriormente exitosas podrían fracasar. sin embargo, refactorización depende otras “actividades ágiles” utiliza con cualquier enfo-que desarrollo. fowler sus colaboradores () sugieren que existen situaciones estereotípicas (que llaman “malos olores”), las cuales código programa susceptible mejorarse. los ejemplos malos olores que pueden mejorarse mediante refactorización incluyen: . código duplicado mismo código muy similar puede incluirse diferentes lugares programa. éste descarta implementa como solo método función que llame cuando requiera. . métodos largos método demasiado largo, debe rediseñarse varios métodos más cortos. . enunciados switch (case) con frecuencia éstos implican duplicación, donde cambio (switch) depende del tipo algún valor. los enunciados switch pueden dispersarse alrededor programa. los lenguajes orientados objetos, nor-malmente posible usar polimorfismo para lograr mismo. . aglomeración datos las aglomeraciones datos ocurren cuando mismo grupo objetos datos (campos clases, parámetros métodos) vuelven ocurrir muchos lugares programa. generalmente pueden sustituirse con objeto que encapsule todos los datos. . generalidad especulativa esto ocurre cuando los desarrolladores incluyen gene-ralidad programa, caso que requiera futuro. por general, esto simplemente puede eliminarse. fowler, libro sitio web, también sugiere algunas transformaciones primitivas refactorización que pueden usarse manera individual conjunto para lidiar con los malos olores. los ejemplos dichas transformaciones incluyen método extract (extraer), donde eliminan duplicados crea nuevo método; expresión condi-cional consolidate (consolidar), donde sustituye una secuencia pruebas con una sola prueba; método pull (subir), donde sustituyen métodos similares subclases con -.indd -.indd // :: // :: capítulo ■ evolución del software solo método una superclase. los entornos desarrollo interactivo, como eclipse, incluyen soporte para refactorización sus editores. esto facilita encontrar partes depen-dientes programa que deban cambiarse para implementar refactorización. refactorización, realizada durante desarrollo del programa, una forma efectiva reducir los costos largo plazo mantenimiento programa. sin embargo, toma responsabilidad del mantenimiento programa, cuya estructura esté significativamente degradada, entonces sería casi imposible refactorizar sólo código. tal vez tenga que considerar refactorización del diseño, que probablemente resulte ser problema más costoso difícil. refactorización del diseño implica identificar patrones diseño relevantes (que estudian capítulo ) sustituir código existente con código que implemente dichos patrones diseño (kerievsky, ). por cuestiones espacio analiza esto aquí. . administración sistemas heredados para los sistemas software nuevos desarrollados con modernos procesos ingeniería software, como desarrollo incremental cbse, posible planear cómo integrar desarrollo evolución del sistema. cada vez con mayor frecuencia, las compañías empiezan entender que proceso desarrollo del sistema proceso todo ciclo vida que útil una separación artificial entre desarrollo del software mantenimiento. sin embargo, todavía existen muchos sistemas heredados que son sistemas empresariales críticos. éstos tienen que extenderse adaptarse las cambiantes prácticas del comercio electrónico. mayoría las organizaciones, por general, tienen portafolio sistemas heredados, que usan con presupuesto limitado para mantenimiento actualización. deben decidir cómo obtener mejor retorno inversión. esto requiere hacer una valoración realista sus sistemas heredados , luego, decidir acerca estrategia más adecuada para hacer evolucionar dichos sistemas. existen cuatro opciones estratégicas: . desechar completamente sistema esta opción debe elegirse cuando sistema vaya realizar una aportación efectiva los procesos empresariales. por gene-ral, esto ocurre cuando los procesos empresariales cambiaron desde instalación del sistema apoyan más sistema heredado. . dejar sin cambios sistema continuar mantenimiento regular esta opción debe elegirse cuando sistema todavía requiera, pero sea bastante estable los usuarios del sistema hagan relativamente pocas peticiones cambio. . someter sistema reingeniería para mejorar mantenibilidad esta opción debe elegirse cuando calidad del sistema haya degradado por cambio toda-vía propone nuevo cambio sistema. este proceso podría incluir desarrollo nuevos componentes interfaz, modo que sistema original logre trabajar con otros sistemas más recientes. . sustituir todo parte del sistema con nuevo sistema esta opción tiene que elegirse cuando factores como hardware nuevo signifiquen que viejo sistema pueda continuar operación donde sistemas comerciales (off-the-shelf) permiti-rían nuevo sistema desarrollarse costo razonable. muchos casos adopta -.indd -.indd // :: // :: . ■ administración sistemas heredados una estrategia sustitución evolutiva, cual grandes componentes del sistema sustituyen con sistemas comerciales, otros componentes reutilizan siempre que sea posible. naturalmente, tales opciones son excluyentes. cuando sistema está compuesto por muchos programas, posible aplicar diferentes opciones cada programa. cuando valora sistema heredado, tiene que observarse desde las perspectivas empresarial técnica (warren, ). desde perspectiva empresarial, debe decidir compañía necesita realmente sistema. desde una perspectiva técnica, hay que valorar calidad del software aplicación, así como hardware software soporte del sistema. luego, usa una combinación del valor empresarial calidad del sistema, para informar decisión acerca qué hacer con sistema heredado. por ejemplo, suponga que una organización posee sistemas heredados. tiene que valorar calidad valor empresarial cada uno dichos sistemas. entonces crea una gráfica que muestre valor relativo empresarial calidad del sistema. esto ilustra figura .. figura . observa que existen cuatro grupos sistemas: . baja calidad, bajo valor empresarial mantener estos sistemas operación será costoso tasa retorno para empresa será bastante pequeña. estos sistemas deben descartarse. . baja calidad, alto valor empresarial estos sistemas realizan una importante aportación empresarial, modo que pueden desechar. sin embargo, baja calidad significa que mantenimiento resulta costoso. dichos sistemas tienen que someterse reingeniería para mejorar calidad. pueden sustituirse, está disponi-ble sistema comercial adecuado. . alta calidad, bajo valor empresarial estos sistemas aportan mucho empresa, pero mantenimiento quizá sea muy costoso. vale pena sustituir tales sistemas, así que puede continuarse mantenimiento normal del sistema, requieren cambios costosos hardware del sistema sigue uso. los cam-bios costosos son necesarios, entonces software puede desecharse. calidad del sistemavalor empresarialalto valor empresarial baja calidadalto valor empresarialalta calidad bajo valor empresarialbaja calidadbajo valor empresarialalta calidad figura . ejemplo valoración sistema heredado -.indd -.indd // :: // :: capítulo ■ evolución del software . alta calidad, alto valor empresarial estos sistemas deben mantenerse opera- ción. sin embargo, alta calidad significa que tiene que invertir transfor- mación sustitución del sistema. hay que continuar con mantenimiento normal del sistema. para calcular valor empresarial sistema, tiene que identificar los partici-pantes del sistema, como sus usuarios finales sus administradores, plantear una serie preguntas acerca del sistema. existen cuatro temas básicos que deben analizar: . uso del sistema los sistemas sólo usan ocasionalmente por número pequeño individuos, quizá tengan bajo valor empresarial. ocasiones sis-tema heredado desarrolló para satisfacer una necesidad empresarial que cambió que ahora, manera más efectiva, satisface otras formas. sin embargo, debe tener cuidado acerca del uso ocasional pero, vez, importante los siste-mas. por ejemplo, una universidad, sistema registro estudiantes quizá sólo utilice comienzo cada año escolar. sin embargo, sistema esencial con alto valor empresarial. . los procesos empresariales que mantienen cuando introduce sistema, los procesos empresariales diseñan para explotar las capacidades del sistema. sis-tema inflexible, sería casi imposible modificar dichos procesos empresariales. sin embargo, conforme cambia entorno, los procesos empresariales originales suelen volverse obsoletos. por tanto, sistema puede tener bajo valor empresarial porque fuerza uso procesos empresariales ineficientes. . confiabilidad del sistema confiabilidad del sistema sólo problema técnico, sino también problema empresarial. sistema confiable los problemas afectan directamente los clientes empresa hacen que los trabaja-dores empresa distraigan otras tareas para resolver dichos problemas, sistema tiene valor empresarial bajo. . las salidas del sistema aquí tema clave importancia las salidas del sistema, para funcionamiento exitoso empresa. empresa depende dichas salidas, entonces sistema tiene alto valor empresarial. por contrario, tales salidas pueden generarse fácilmente alguna otra forma, sistema produce salidas que rara vez utilizan, entonces valor empresarial suele ser bajo. por ejemplo, suponga que una compañía ofrece sistema pedidos viajes que usa personal responsable arreglar los viajes. ellos pueden colocar los pedidos con agente viajes aprobado. luego, los boletos entregan compañía recibe una factura por ellos. sin embargo, una evaluación del valor empresarial podría revelar que este sistema sólo usa para colocar porcentaje muy pequeño pedidos viaje. las personas que hacen los arreglos viaje descubren que más barato más conveniente tratar directamente con los proveedores viajes mediante sus sitios web. este sistema todavía puede usarse, pero hay razón real para conservarlo. misma funcionalidad está disponible por parte sistemas externos. por otro lado, suponga que una compañía desarrolló sistema que lleva segui-miento todos los pedidos previos del cliente , automáticamente, genera recorda-torio para que los clientes vuelvan solicitar bienes. esto como resultado gran número pedidos repetidos mantiene los clientes satisfechos porque sienten que -.indd -.indd // :: // :: . ■ administración sistemas heredados figura . factores usados valoración del entornoproveedor está tanto sus necesidades. las salidas tal sistema son muy importan- tes para empresa , consecuencia, este sistema tiene alto valor empresarial. para valorar sistema software desde una perspectiva técnica, necesita con-siderar tanto sistema aplicación como entorno donde opera sistema. entorno incluye hardware todo software soporte asociado (compiladores, entornos desarrollo, etcétera) que requieran para mantener sistema. entorno importante porque muchos cambios del sistema resultan cambios entorno, como actualizaciones hardware sistema operativo. posible, proceso valoración ambiental deben hacer mediciones del sistema sus procesos mantenimiento. los ejemplos datos que suelen ser útiles incluyen los costos mantenimiento del hardware del sistema del software soporte, número fallas hardware que ocurren durante algún periodo, frecuencia con que aplican “parches” correcciones software soporte del sistema. los factores que deben considerar durante valoración del entorno muestran figura .. observe que son todas las características técnicas del entorno. también debe considerar fiabilidad los proveedores del hardware del software soporte. dichos proveedores están negocio, tal vez haya soporte para sus sistemas. para valorar calidad técnica sistema aplicación, quizá deban valorar diversos factores (figura .) que relacionan principalmente con confiabilidad del sistema, las dificultades mantener sistema documentación. también puedenfactor preguntas estabilidad del proveedor ¿ proveedor todavía está operación? ¿ proveedor financieramente estable probable que continúe operación? proveedor está negocio, ¿alguien más mantiene los sistemas? tasa falla ¿ hardware tiene una alta tasa fallas reportadas? ¿ software soporte cae fuerza reinicio del sistema? edad ¿qué antigüedad tienen hardware software? cuanto más viejos sean hardware software soporte, más obsoletos serán. quizá todavía funcionen correctamente, pero podría haber beneficios económicos empresariales significativos moverse hacia sistema más moderno. rendimiento ¿ rendimiento del sistema adecuado? ¿los problemas rendimiento tienen efecto relevante sobre los usuarios del sistema? requerimientos soporte ¿qué apoyo local requieren hardware software? existen altos costos asociados con este apoyo, valdría pena considerar sustitución del sistema. costos mantenimiento ¿cuáles son los costos del mantenimiento hardware las licencias del software soporte? hardware más antiguo puede tener costos mantenimiento más altos que los sistemas modernos. software soporte quizá tenga costos altos por licencia anual. interoperabilidad ¿hay problemas interfaz entre sistema otros sistemas? ¿ pueden usar los compiladores, por ejemplo, con las versiones actuales del sistema operativo? ¿ requiere emulación hardware? -.indd -.indd // :: // :: capítulo ■ evolución del software recolectar datos que ayudarán juzgar calidad del sistema. los datos que podrían ser útiles valoración calidad son: . número peticiones cambio del sistema los cambios sistema, por general, corrompen estructura del sistema dificultan cambios futuros. cuanto más alto sea este valor acumulado, más baja será calidad del sistema. . número interfaces usuario éste factor importante los sistemas basados formas, donde cada forma puede considerarse como una interfaz usuario separada. cuanto más interfaces haya, más probabilidad habrá que exis-tan inconsistencias redundancias dichas interfaces. . volumen datos usados por sistema cuanto más alto sea volumen datos (número archivos, tamaño base datos, etcétera), más probable será que haya inconsistencias datos que reduzcan calidad del sistema. idealmente, debe usarse una valoración objetiva para informar las decisiones acerca qué hacer con sistema heredado. sin embargo, muchos casos, las decisiones realidad son objetivas, sino que basan consideraciones políticas organizacio-nales. por ejemplo, fusionan dos empresas, socio políticamente más poderoso por general conservará sus sistemas desechará los demás. gerente ejecutivo una factor preguntas entendimiento ¿cuán difícil entender código fuente del sistema actual? ¿cuán complejas son las estructuras control que utilizan? ¿las variables tienen nombres significativos que reflejan función? documentación ¿qué documentación del sistema está disponible? ¿ documentación está completa, consistente actualizada? datos ¿existe algún modelo datos explícito para sistema? ¿ qué medida los datos duplican través los archivos? ¿los datos usados por sistema están actualizados son consistentes? rendimiento ¿ rendimiento aplicación adecuado? ¿los problemas rendimiento tienen efecto significativo sobre los usuarios del sistema? lenguaje programación ¿hay compiladores modernos disponibles para lenguaje programación usado para desarrollar sistema? ¿ lenguaje programación todavía usa para desarrollo nuevos sistemas? administración configuración ¿todas las versiones totalidad las partes del sistema administran mediante sistema administración configuración? ¿existe una descripción explícita las versiones componentes que usan sistema actual? datos prueba ¿existen datos prueba para sistema? ¿hay registro pruebas regresión realizadas cuando agregaron nuevas características sistema? habilidades del personal ¿hay personal disponible que tenga las habilidades para mantener aplicación? ¿hay personal disponible que tenga experiencia con sistema? figura . factores usados valoración aplicación -.indd -.indd // :: // :: pmcapítulo ■ lecturas sugeridas organización decide moverse hacia una nueva plataforma hardware, entonces esto puede requerir sustitución aplicaciones. hay presupuesto disponible para transformación del sistema año particular, entonces puede continuar mante-nimiento del sistema, aunque esto dará como resultado costos más altos largo plazo. puntos clave ■ desarrollo evolución del software pueden considerarse como proceso integrado iterativo que representa usando modelo espiral. ■ para sistemas personalizados, por general, los costos del mantenimiento software superan los desarrollo. ■ proceso evolución del software conducido por peticiones cambios incluye análisis del impacto del cambio, planeación las versiones implementación del cambio. ■ las leyes lehman, como noción que cambio continuo, describen algunas percepciones derivadas estudios largo plazo evolución del sistema. ■ existen tres tipos mantenimiento software: reparación bugs, modificación del software para trabajar nuevo entorno implementación requerimientos nuevos diferentes. ■ reingeniería software trata reestructuración redocumentación software para hacerlo más fácil entender cambiar. ■ refactorización, que hace pequeños cambios programa sin alterar funcionalidad, podría considerarse como mantenimiento preventivo. ■ valor empresarial sistema heredado calidad del software aplicación entorno deben valorarse para determinar sistema tiene que sustituirse, transformarse mantenerse. lecturas sugeridas “software maintenance and evolution: roadmap”. además examinar los retos investigación, este ensayo adecuado breve panorama del mantenimiento evolución del software por parte investigadores líderes esta área. los problemas investigación que identificaron todavía resuelven. (. rajlich .. bennett, proc. int. conf. software engineering, ieee press, .) http:/ /doi. acm. org/ . / . . modernizing legacy systems: software technologies, engineering processes, and business practices. este excelente libro toca temas generales mantenimiento evolución del software, así como migración sistemas heredados. libro basa estudio caso amplio transformación sistema cobol sistema cliente-servidor basado java. (. . seacord, . plakosh . . lewis, addison-wesley, .) -.indd -.indd // :: // :: capítulo ■ evolución del software working effectively with legacy code. consejo prácticos sólidos acerca los problemas dificultades lidiar con sistemas heredados. (. feathers, john wiley & sons, .) ejercicios .. explique por qué sistema software que usa entorno real debe cambiar volverse progresivamente menos útil. .. exponga las razones subyacentes las leyes lehman. ¿ qué circunstancias pueden fallar estas leyes? .. partir figura ., observe que análisis impacto subproceso importante proceso evolución del software. con diagrama, sugiera qué actividades habría análisis impacto del cambio. .. como gerente proyecto software, una compañía que especializa desarrollo software para industria petrolera extranjero, asigna tarea descubrir los factores que afectan mantenibilidad los sistemas desarrollados por compañía. sugiera cómo configurar programa para analizar proceso mantenimiento descubrir métricas mantenibilidad adecuadas para compañía. .. describa brevemente los tres tipos principales mantenimiento del software. ¿por qué ocasiones difícil diferenciarlos? .. ¿cuáles son los principales factores que afectan los costos reingeniería sistemas? .. ¿ qué circunstancias una organización puede decidir desechar sistema, cuando valoración del sistema sugiere que alta calidad alto valor empresarial? .. ¿cuáles son las opciones estratégicas para evolución sistemas heredados? ¿ que situaciones sustituiría parte todo sistema vez continuar mantenimiento del software? .. explique por qué los problemas con software soporte significarían que una organización tiene que sustituir sus sistemas heredados. .. ¿los ingenieros software tienen responsabilidad profesional para producir código que pueda mantenerse cambiarse, incluso empleador solicita manera explícita? referencias arthur, . . (). software evolution. new york: john wiley & sons. banker, . ., datar, . ., kemerer, . . zweig, . (). “software complexity and maintenance costs”. comm. acm, (), –. boehm, . ., abts, ., brown, . ., chulani, ., clark, . ., horowitz, ., madachy, ., reifer, . steece, . (). software cost estimation with cocomo . upper saddle river, : prentice hall. -.indd -.indd // :: // :: pmcapítulo ■ referencias coleman, ., ash, ., lowther, . oman, . (). “using metrics evaluate software system maintainability”. ieee computer, (), –. erlikh, . (). “leveraging legacy system dollars for -business”. professional, (), mayo/ junio , –.fowler, ., beck, ., brant, ., opdyke, . roberts, . (). refactoring: improving the design existing code. boston: addison-wesley.guimaraes, . (). “managing application program maintenance expenditures”. comm. acm, (), –.hopkins, . jenkins, . (). eating the elephant: moving from greenfield development brownfield. boston: ibm press. kafura, . reddy, . . (). “the use software complexity metrics software maintenance”. ieee trans. software engineering, - (), –. kerievsky, . (). refactoring patterns. boston: addison wesley.kozlov, ., koskinen, ., sakkinen, . markkula, . (). “assessing maintainability change over multiple software releases”. . software maintenance and evolution, (), –. krogstie, ., jahr, . sjoberg, . . . (). “ longitudinal study development and maintenance norway: report from the investigation”. information and software technology, (), –. lehman, . . (). “laws software evolution revisited”. proc. european workshop software process technology (ewspt’), springer-verlag. –. lehman, . . belady, . (). program evolution: processes software change. london: academic press. lehman, . ., perry, . . ramil, . . (). “ evidence supporting the feast hypothesis and the laws software evolution”. proc. metrics ‘, bethesda. maryland: ieee computer society press. –. lehman, . ., ramil, . . sandler, . (). “ approach modelling long-term growth trends software systems”. proc. int. conf. software maintenance, florencia, italia: –. lientz, . . swanson, . . (). software maintenance management. reading, mass.: addison- wesley. mccabe, . . (). “ complexity measure”. ieee trans. software engineering., - (), –. nosek, . . palvia, . (). “software maintenance management: changes the last decade”. software maintenance: research and practice, (), –. opdyke, . . johnson, . . (). “refactoring: aid designing application frameworks and evolving object-oriented systems”. symposium object-oriented programming emphasizing practical applications (sooppa ‘), poughkeepsie, new york. poole, . huisman, . . (). “using extreme programming maintenance environment”. ieee software, (), –. -.indd -.indd // :: // :: capítulo ■ evolución del software rajlich, . . bennett, . . (). “ staged model for the software life cycle”. ieee computer, (), –. sousa, . . (). “ survey the software maintenance process”. ieee international conference software maintenance (icsm ’), washington, ..: –. ulrich, . . (). “the evolutionary growth software reengineering and the decade ahead”. american programmer, (), –. warren, . . (). the renaissance legacy systems. londres: springer. -.indd -.indd // :: // :: pma medida que los sistemas software crecen tamaño complejidad, cree firmemente que reto más significativo que enfrenta ingeniería software consiste garantizar seguridad dichos sistemas. para con-fiar sistema debe tener certeza que estará disponible cuando requiera que rendirá esperado. tiene que ser confiable para que las computadoras los datos estén amenazados por . ello significa que los temas confiabilidad seguridad del sistema con frecuencia son más importantes que los detalles funcionalidad del mismo. por con-siguiente, esta parte del libro diseñó para introducir los estudiantes profesionales ingeniería software los importantes temas confiabilidad seguridad. primer capítulo esta sección, capítulo , ocupa los sistemas sociotécnicos que, primera vista, parecerían tener mucho que ver con confiabilidad del software. sin embargo, muchas fallas seguri-dad confiabilidad surgen por causas humanas organización, que pueden ignorar considerar confiabilidad seguridad del sis-tema. los ingenieros software deben estar tanto esto rechazar idea que mejores técnicas tecnología pueden garantizar que los sistemas sean completamente confiables seguros. capítulo introduce los conceptos básicos confiabilidad segu- ridad, explica los principios fundamentales evasión, detección parte seguridad -.indd -.indd // :: // :: pmrecuperación usados para construir sistemas confiables. capítulo complementa capítulo , que cubre ingeniería requerimientos, con análisis los enfoques específicos que utilizan para derivar especificar requerimientos seguridad confiabilidad del sistema. capítulo accede brevemente uso especificación formal; asi-mismo, web está disponible capítulo adicional sobre este tema. los capítulos tratan las técnicas ingeniería software para desarrollo sistemas confiables seguros. aun cuando las ingenie-rías confiabilidad seguridad tratan por separado, ambas tienen mucho común. también estudia importancia las arqui-tecturas software, presentan lineamientos diseño técnicas programación que ayudan lograr confiabilidad seguridad. explica por qué importante usar redundancia diversidad, para ase-gurar que los sistemas sean capaces enfrentar fallas operacionales ataques externos. introduce cada vez más importante tema supervivencia resiliencia del software, que permite los sistemas continuar con entrega servicios esenciales, aunque seguridad vea amenazada. finalmente, esta sección, capítulo trata sobre garantía con- fiabilidad seguridad. explica uso del análisis estático com-probación del modelo para verificación del sistema detección fallas desarrollo. dichas técnicas han empleado con éxito ingeniería sistemas críticos. también analizan los enfoques especí-ficos para probar confiabilidad seguridad los sistemas, exponer por qué sería necesario caso confiabilidad para convencer supervisor externo que sistema seguro confiable. -.indd -.indd // :: // :: pmobjetivos los objetivos este capítulo son introducirlo concepto sistema sociotécnico ( sistema que incluye personal, software hardware), así como mostrarle necesidad tener una perspectiva los sistemas sobre seguridad confiabilidad. estudiar este capítulo: ■ conocerá qué entiende por sistema sociotécnico, entenderá diferencia entre sistema técnico basado computadora sistema sociotécnico; ■ introducirá concepto propiedades sistema emergente, como fiabilidad, rendimiento, seguridad protección; ■ identificará las actividades procuración, desarrollo operación que intervienen proceso ingeniería sistemas; ■ sabrá por qué confiabilidad seguridad del software deben considerarse por separado cómo éstas resultan afectadas por conflictos sistemas, como errores del operador. contenido . sistemas complejos . ingeniería sistemas . procuración del sistema . desarrollo del sistema . operación del sistema sistemas sociotécnicos -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos sistema cómputo, software hardware son interdependientes. sin hard- ware, sistema software sería una abstracción, decir, sería simplemente una representación idea cierto conocimiento humano. mientras que sin software, hardware sólo conjunto dispositivos electrónicos inertes. obstante, ambos juntan para formar sistema, entonces crea una máquina capaz realizar cálcu-los complejos transferir los resultados dichos cálculos entorno. esto ilustra una las características fundamentales sistema: más que suma sus partes. los sistemas tienen propiedades que sólo vuelven evidentes cuando sus componentes integran operan conjunto. por consiguiente, ingeniería soft-ware una actividad independiente, sino una parte intrínseca más general proce-sos ingeniería sistemas. los sistemas software son sistemas aislados, sino componentes esenciales sistemas más extensos que tienen cierto propósito humano, social organizacional. por ejemplo, software del sistema meteorológico campo abierto controla los ins-trumentos una estación meteorológica. comunica con otros sistemas software forma parte sistemas más amplios predicción del clima, nacionales internaciona-les. además del hardware software, estos sistemas incluyen procesos para predecir clima, personal que opera sistema analiza sus salidas. sistema también abarca las organizaciones que dependen para ayudarlas dar predicciones meteorológicas individuos, gobiernos, industrias, etcétera. estos sistemas más amplios ocasiones llaman sistemas sociotécnicos. incluyen elementos técnicos como individuos, procesos, regulaciones, etcétera, así como componentes técnicos, por ejemplo, computadoras, soft-ware otro equipo. los sistemas sociotécnicos son tan complejos que prácticamente imposible enten-derlos como todo. vez ello, deben verse como capas, como muestra figura .. tales capas constituyen columna los sistemas sociotécnicos: . capa equipo está compuesta dispositivos hardware, algunos los cuales pueden ser computadoras. . capa del sistema operativo ésta interactúa con hardware ofrece con- junto facilidades comunes para capas software superiores sistema. . capa comunicaciones gestión datos extiende las facilidades del sistema operativo ofrece una interfaz que permite interacción con funcionalidad más extensa, como acceso sistemas remotos, una base datos sistema, etcé-tera. ocasiones, esto llama middleware, pues halla entre aplicación sistema operativo. . capa aplicaciones entrega funcionalidad específica aplicación que requiere. esta capa puede haber varios programas aplicación diferentes. . capa proceso empresarial este nivel definen establecen los procesos empresariales organización que usan software del sistema. . capa organización incluye procesos estratégicos alto nivel, así como reglas, políticas normas empresa que deben seguirse usar sistema. . capa social ella definen las leyes regulaciones sociedad que rigen operación del sistema. -.indd -.indd // :: // :: pmcapítulo ■ sistemas sociotécnicos principio, mayoría las interacciones están entre capas contiguas, cada capa oculta detalle capa abajo capa superior. práctica, éste siem-pre caso. entre las capas quizás haya interacciones inesperadas, cual derivaría problemas para sistema como todo. por ejemplo, imagine que hay cambio ley que administra acceso información personal. esto proviene capa social. ello conduce nuevos procedimientos organizacionales cambios para los procesos empresariales. sin embargo, sistema aplicación quizá sea capaz brindar nivel privacidad requerido, modo que deben implementarse cambios capa comunicaciones gestión datos. deliberar manera holística sobre los sistemas, vez considerar simplemente software aislamiento, esencial cuando considera seguridad confiabilidad del software. las fallas operación del software, , rara vez tienen consecuencias serias, porque software intangible , aun cuando dañe, restauración fácil económica. obstante, cuando dichas fallas operación software caen cascada por otras partes del sistema, afectan entorno físico humano del software. aquí, las consecuencias falla operación son más significativas. posible que las perso-nas deban realizar trabajo extra para contener recuperarse falla operación; por ejemplo, pueden tener daños físicos equipo, pérdida corrupción datos, fallas confidencialidad con consecuencias desconocidas. por tanto, hay que tomar una perspectiva nivel del sistema cuando diseñe software que tenga que ser seguro confiable. usted necesita entender las consecuencias las fallas operación del software para otros elementos sistema. también debe entender cómo esos otros elementos del sistema causan las fallas operación del soft-ware, cómo ayudarían proteger software recuperar éste contra tales fallas. por consiguiente, problema existente una falla operación del sistema, más que del software. esto significa que preciso examinar cómo interactúa software con entorno inmediato para garantizar que: . las fallas operación del software estén, tanto como sea posible, contenidas den- tro las capas del sistema afecten seriamente operación capas adjuntas. particular, las fallas operación del software deben conducir fallas operación del sistema.equiposistema operativocomunicaciones gestión datossistema aplicaciónprocesos empresarialesorganizaciónsociedad ingeniería sistemasingeniería software figura . capas los sistemas sociotécnicos -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos . entiende cómo las fallas desarrollo operación las capas, que son del software, llegan afectar software. usted también puede considerar cómo elabo-rar pruebas software con finalidad ayudar detectar dichas fallas, cómo dar soporte para recuperarse las mismas. puesto que software inherentemente flexible, deja por general los ingenieros software solucionar los problemas imprevistos del sistema. suponga que una instalación deradar está ubicada tal modo que pasan espectros imagen del radar. práctico mover radar sitio con menos interferencia, así que los ingenieros sistemas deben encontrar otra forma eliminar tales espectros. solución puede ser mejorar las capacida-des procesamiento imágenes del software para eliminar los espectros las imágenes. esto quizás haga lento software, tal forma que rendimiento vuelve inadmisible. problema caracterizará entonces como una “falla operación del software”; mientras que, hecho, una falla proceso diseño para sistema como todo. muy común este tipo situación, donde los ingenieros software tienen pro-blema mejorar las capacidades del software, sin aumentar los costos del hardware. muchas las llamadas fallas operación del software son consecuencia proble-mas inherentes software, sino resultado buscar cambiar software para instalar requerimientos modificados ingeniería del sistema. buen ejemplo esto fue falla del sistema equipaje del aeropuerto denver (swartz, ), donde esperaba que software controlador lidiara con las limitaciones del equipo utilizado. ingeniería sistemas (stevens ., ; thayer, ; thomé, ; white ., ) proceso para diseñar sistemas completos, sólo software estos siste-mas. software elemento controlador integrador estos sistemas, los costos ingeniería software con frecuencia son principal componente costo los sis-temas globales costos. como ingeniero software, ayuda hecho tener amplio conocimiento cómo interactúa software con otros sistemas hardware software, cómo supone que usará. este conocimiento útil para comprender los límites del software, para diseñar mejor software participar grupo ingeniería sistemas. . sistemas complejos término “sistema” usa forma universal. habla sistemas cómputo, siste-mas operativos, sistemas pago, sistema educativo, sistema gobierno cosas por estilo. indiscutiblemente, trata usos muy diferentes palabra “sistema”, aunque algún modo comparten característica que sistema más que simplemente suma sus partes. los sistemas abstractos, como sistema gobierno, están fuera del ámbito este libro. cambio, enfoque está los sistemas que incluyen computadoras que tienen algún propósito específico, como habilitar comunicación, soportar navegación calcu-lar los salarios. siguiente una definición trabajo útil sobre estos tipos sistemas: sistema una colección intencionada componentes interrelacionados, diferentes tipos, que trabajan conjunto para lograr algún objetivo. esta definición general abarca una amplia gama sistemas; por ejemplo, sis-tema simple, como apuntador láser, que generalmente incluye algunos componentes hardware, además una pequeña cantidad software control. contraste, -.indd -.indd // :: // :: . ■ sistemas complejos sistema control tráfico incluye miles componentes hardware software, aparte usuarios que toman decisiones con base información dicho sistema cómputo. una característica todos los sistemas complejos que las propiedades com-portamiento los componentes del sistema están estrechamente vinculados. funcio-namiento exitoso cada componente del sistema depende del funcionamiento los otros componentes. por ende, software sólo opera procesador está funciona-miento. procesador sólo realiza cálculos sistema software —que define dichos cálculos— instaló manera exitosa. comúnmente, los sistemas complejos son jerárquicos , por ende, incluyen otros sis-temas. por ejemplo, sistema comando control policiaco incluye sistema información geográfica para proporcionar detalles ubicación los incidentes. tales sistemas incluidos les conoce como “subsistemas”, los cuales pueden operar por cuenta propia como sistemas independientes. muestra ello que mismo sistema información geográfica puede ser utilizado sistemas control orden emergen-cias logística transporte. los sistemas que incluyen software dividen dos categorías: . sistemas técnicos basados computadora trata sistemas que incluyen componentes hardware software, aunque incluyen procedimientos pro- cesos. los ejemplos sistemas técnicos abarcan televisores, teléfonos móviles otros equipos con software embebido. mayoría del software para , juegos computadora, etcétera, también ubica esta categoría. los individuos las orga-nizaciones usan los sistemas técnicos para una finalidad específica, aunque cono-cimiento este propósito forme parte del sistema. por ejemplo, procesador texto que usó para escribir este libro desconoce usó para escribir libro. . sistemas sociotécnicos éstos incluyen uno más sistemas técnicos, pero también incluyen individuos que entienden propósito del sistema dentro del sistema . los sistemas sociotécnicos tienen procesos operacionales definidos las personas (los operadores) son partes inherentes del sistema. están administrados por políticas reglas organizacionales, podrían verse afectados por restricciones externas como leyes nacionales políticas reguladoras. por ejemplo, este libro creó mediante sistema edición sociotécnico que incluye varios procesos sistemas técnicos. los sistemas sociotécnicos son sistemas empresariales que intentan auxiliar para alcanzar una meta negocio. ésta puede ser incrementar las ventas, reducir uso material fabricación, recolectar impuestos, mantener espacio aéreo seguro, etcé-tera. puesto que están incrustados entorno organizacional, procuración,* desa-rrollo uso dichos sistemas tienen influencia las políticas los procedimientos organización, así como cultura laboral. los usuarios del sistema son indivi-duos que están influidos por forma que administra organización, así como por sus interacciones con otras personas dentro fuera organización. cuando trata desarrollar sistemas sociotécnicos, necesario entender entorno organización donde utiliza. hace, los sistemas quizá cubran las necesidades empresariales , consecuencia, los usuarios sus administradores rechazarán sistema. *nota del revisor técnico: inglés, término procurement (procuración) abarca las actividades com- pra, elaboración del plan inicial desarrollo contratación para desarrollo. éste sentido del término procuración este texto. -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos los factores organizacionales del entorno del sistema que pueden afectar los requeri- mientos, diseño operación sistema sociotécnico incluyen: . cambios procesos sistema puede requerir cambios los procesos tra- bajo del entorno. así, ciertamente requerirá capacitación. los cambios son significativos, implican que gente pierda empleo, hay riesgo que los usuarios resistan introducción del sistema. . cambios laborales los nuevos sistemas pueden reemplazar las habilidades los usuarios entorno, bien, hacer que cambien forma como trabajan. así, los usuarios opondrían activamente introducción del sistema orga-nización. los diseños que requieran que los directivos deban cambiar forma trabajar, para acoplarse nuevo sistema cómputo, menudo son molestos. los directivos quizá crean que estatus organización decrece por sistema. . cambios organización sistema podría cambiar estructura política poder una organización. por ejemplo, una organización depende sistema complejo, quienes controlan acceso dicho sistema tienen, por tanto, mayor poder político. los sistemas sociotécnicos poseen tres características que son particularmente impor-tantes considerar seguridad confiabilidad: . tienen propiedades emergentes que son propiedades del sistema como todo, vez asociarse con partes individuales del sistema. las propiedades emergentes depen-den tanto los componentes del sistema como las relaciones entre ellos. debido esta complejidad, las propiedades emergentes sólo evalúan cuando sistema está ensamblado. seguridad confiabilidad son propiedades emergentes del sistema. . menudo suelen ser deterministas. ello quiere decir que, cuando les presenta una entrada específica, posible que produzcan siempre misma salida. comportamiento del sistema depende del personal que opera los individuos siempre reaccionan misma forma. más aún, uso del sistema puede crear nuevas relaciones entre los componentes del sistema , por consiguiente, cambiar comportamiento emergente. ahí que los fallas desarrollo operación del sistema puedan ser transitorias, las personas quizá estén acuerdo real-mente ocurrió una falla operación. . amplitud con que sistema apoya los objetivos organización sólo depende del sistema . también radica estabilidad dichos objetivos, las relaciones los conflictos entre los objetivos organización, cómo gente orga-nización interpreta dichos objetivos. una nueva administración podría reinterpretar los objetivos organización, los cuales debería apoyar sistema diseñado, modo que sistema “exitoso” vería entonces como una “falla operación”. las consideraciones sociotécnicas son críticas por general determinación sistema cumplió exitosamente con sus objetivos. por desgracia, tomar cuenta esto muy difícil para los ingenieros con poca experiencia estudios sociales cul-turales. para ayudar entender los efectos los sistemas sobre las organizaciones, -.indd -.indd // :: // :: . ■ sistemas complejos desarrollaron varias metodologías, como las sociotécnicas mumford () meto- dología sistemas blandos checkland (; checkland scholes, ). también hay estudios sociológicos acerca los efectos los sistemas basados computadoras sobre trabajo (ackroyd ., ; anderson ., ; suchman, ). .. propiedades emergentes del sistema las relaciones complejas entre los componentes sistema significan que sistema más que simplemente suma sus partes. tiene propiedades que son propieda-des del sistema como todo. tales “propiedades emergentes” (checkland, ) pueden atribuirse alguna parte específica del sistema. cambio, sólo surgen una vez que integran los componentes del sistema. algunas tales propiedades, como peso, suelen derivarse directamente propiedades comparables subsistemas. sin embargo, muy menudo son resultado interrelaciones complejas entre subsistemas. propiedad del sistema puede calcularse directamente partir las propiedades los componentes individuales del mismo. figura . muestran ejemplos algunas propiedades emergentes. hay dos tipos propiedades emergentes: . propiedades emergentes funcionales, cuando propósito sistema sólo surge después integrar sus componentes. por ejemplo, una bicicleta tiene propiedad funcional ser dispositivo transporte, una vez que ensamblan sus compo-nentes. . propiedades emergentes funcionales, que relacionan con comportamiento del sistema entorno operacional. fiabilidad, rendimiento, seguridad protección son ejemplos propiedades emergentes. éstas son críticas para los sistemas basados computadora, pues las fallas para lograr nivel mínimo definido dichas pro-piedades suelen hacer inútil sistema. algunos usuarios tal vez necesiten varias propiedad descripción volumen volumen sistema ( total espacio ocupado) varía función cómo ordenan conectan los componentes ensamblados. fiabilidad fiabilidad del sistema depende fiabilidad del componente, aun cuando interacciones inesperadas lleguen causar nuevos tipos fallas operación , por consiguiente, afecten fiabilidad del sistema. seguridad seguridad del sistema (capacidad para resistir ataques) una propiedad compleja que mide con facilidad. pueden concebirse ataques que anticiparon los diseñadores del sistema ello quizá logre vencer las protecciones internas. reparabilidad esta propiedad refleja qué tan fácilmente corrige problema con sistema una vez descubierto. depende diagnosticar problema, acceder los componentes que están fallando modificar sustituir dichos componentes. usabilidad esta propiedad refleja sencillez con que usa sistema. depende los componentes técnicos del sistema, sus operadores entorno operacional. figura . ejemplos propiedades emergentes -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos las funciones del sistema, modo que sin ellas sistema también sería aceptable. sin embargo, sistema que sea confiable sea demasiado lento tiene amplias probabilidades ser rechazado por todos los usuarios. las propiedades emergentes confiabilidad, como fiabilidad, dependen tanto las propiedades los componentes individuales como sus interacciones. los compo-nentes sistema son interdependientes. las fallas componente pueden propa-garse largo del sistema afectar operación otros componentes. pesar ello, con frecuencia difícil anticiparse cómo las fallas dichos componentes afectarán otros componentes. por ello, prácticamente imposible estimar fiabilidad global del sistema partir datos sobre fiabilidad los componentes del sistema. sistema sociotécnico necesita considerar fiabilidad desde tres perspectivas: . fiabilidad del hardware ¿cuál probabilidad que los componentes hardware fallen cuánto tiempo tardaría repararse componente averiado? . fiabilidad del software ¿cuál probabilidad que componente soft-ware produzca una salida incorrecta? falla del software distinta falla del hardware, pues software desgasta. con frecuencia, las fallas soft-ware son transitorias. sistema sigue trabajando después producir resultado incorrecto. . fiabilidad del operador ¿cuán probable que operador sistema cometa error proporcione una entrada incorrecta? ¿cuán probable que software falle para detectar este error propague? las fiabilidades del hardware, software operador son independientes. figura . muestra cómo las fallas nivel podrían propagarse otros niveles sis-tema. falla hardware quizá genere señales falsas que están fuera del rango las entradas esperadas por software. entonces, software puede comportarse manera impredecible producir salidas imprevistas. esto suele confundir , consecuencia, estresar operador del sistema. error del operador más probable cuando éste siente estresado. este modo, una falla hardware significaría tal caso que operador del sistema cometerá figura . propagación fallahardwaresoftwareoperación falla inicialpropagaciónde falla consecuenciade falla -.indd -.indd // :: // :: . ■ sistemas complejos errores que, vez, conducirían más problemas software procesamiento adi- cional. esto podría sobrecargar hardware causando más fallas. por tanto, falla inicial, que podría ser recuperable, convertiría rápidamente problema serio que como resultado una parálisis completa del sistema. fiabilidad sistema depende del contexto que use. sin embargo, entorno del sistema puede especificar por completo, los diseñadores del sis-tema pueden colocar restricciones dicho entorno para sistemas operacionales. los diferentes sistemas que operan dentro entorno tal vez reaccionen los problemas formas impredecibles, cual consecuencia afectaría fiabilidad todos esos sistemas. por ejemplo, imagine que sistema diseña para operar una temperatura ambiente normal. para permitir variaciones condiciones excepcionales, los componentes electró-nicos sistema diseñan para operar dentro cierto intervalo temperaturas, por ejemplo, grados. fuera este intervalo temperatura, los componentes comportarán forma impredecible. ahora suponga que este sistema instala cerca del aire acondicionado. éste falla arroja gas caliente sobre dispositivo electrónico, entonces sistema podría sobrecalentarse. siendo así, los componentes , consecuen-cia, todo sistema, fallarían. este sistema hubiera instalado alguna otra parte ese ambiente, tal problema ocurriría. cuando aire acondicionado funciona adecuadamente hay problemas. obstante, debido cercanía física dichas máquinas, existió entre ellas una rela-ción prevista que condujo falla del sistema. como fiabilidad, las propiedades emergentes como rendimiento usabilidad son difíciles valorar, aunque pueden medirse después poner funcionamiento sis-tema. sin embargo, propiedades como seguridad protección son mensurables. aquí, usted está interesado simplemente por los atributos que relacionan con comportamiento del sistema, sino también con comportamiento deseado inacep-table. sistema seguro aquel que impide acceso autorizado sus datos. pesar ello, resulta claramente imposible predecir todos los posibles modos acceso prohibirlos forma explícita. por consiguiente, sólo sería posible valorar dichas pro-piedades “ debe”. esto , sólo sabe que sistema seguro cuando alguien trata penetrarlo. .. determinismo sistema determinista uno completamente predecible. ignoran los problemas temporización, los sistemas software que ejecutan hardware confiable por completo los que presentan una secuencia entradas producirán siempre misma secuencia salidas. por supuesto, hay nada como hardware completamente fia-ble; sin embargo, hardware por general bastante fiable para considerar los siste-mas hardware como deterministas. por otro lado, los individuos son deterministas. cuando les presenta exac-tamente misma entrada ( decir, requerimiento para completar una tarea), sus respuestas dependerán sus estados emocional físico, persona que hace peti-ción, otros individuos entorno cualquier otra cuestión que estén haciendo. algunas ocasiones, sentirán satisfechos por hacer trabajo, aunque otras negarán realizarlo. -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos por lado, los sistemas sociotécnicos son deterministas, que incluyen personas , por otro, debido que los cambios hardware, software los datos dichos sis-temas son muy frecuentes. las interacciones entre tales cambios son complejas , por tanto, comportamiento del sistema vuelve impredecible. éste problema mismo, pero, desde una perspectiva confiabilidad, sería difícil decidir ocurrió una falla del sistema, así como estimar periodicidad las fallas del mismo. por ejemplo, suponga que sistema presenta conjunto entradas prueba. éste procesa dichas entradas registra los resultados. algún tiempo después, procesan las mismas entradas prueba comparan los efectos con los resultantes almacenados anteriormente. cinco ellos son diferentes. ¿esto significa que existen cinco fallas? ¿ las diferencias simplemente son variaciones razonables compor-tamiento del sistema? descubrirá esto sólo observar los resultados con más deteni-miento hacer juicios sobre forma que sistema manejó cada entrada. .. criterios éxito por general, los sistemas sociotécnicos complejos desarrollan para enfrentar que ocasiones conoce como “problemas malvados” (rittel webber, ). pro-blema malvado aquel que tan complejo que implica tantas entidades relacionadas que hay especificación definitiva del problema. diferentes participantes ven pro-blema diversas formas ninguna tiene una comprensión integral del problema como todo. verdadera naturaleza del problema sólo surge conforme desarrolla una solución. ejemplo extremo problema malvado planeación caso terre-motos. nadie capaz predecir con exactitud dónde estará epicentro sismo, qué hora ocurrirá qué efecto tendrá sobre ambiente local. imposible especificar con detalle cómo hacer frente gran terremoto. esto dificulta definición los criterios éxito para sistema. ¿cómo determinar nuevo sistema contribuye, con base forma que fue planteado, con las metas empresariales organización que pagó por sistema? juicio éxito hace por general con base las razones originales procurar desarrollar sistema. vez ello, basa sistema efectivo cuando implementa. puesto que ambiente empresarial suele variar muy rápidamente, las metas empresariales quizá cambien manera significativa durante desarrollo del sistema. situación incluso más compleja cuando existen múltiples metas conflicto, que interpretan modo diferente por diversos participantes. por ejemplo, sistema que basa mhc-pms (estudiado capítulo ) diseñó para brindar apoyo dos metas empresariales distintas: . mejorar calidad atención para quienes padecen enfermedades mentales. . aumentar ingreso ofrecer reportes detallados atención brindada los costos esa atención. por desgracia, demostró que éstas eran metas conflicto porque información requerida para satisfacer meta reportar significaba que los médicos las enferme-ras debían proporcionar información adicional, más allá los registros sanitarios que generalmente conservan. esto reducía calidad atención los pacientes, pues -.indd -.indd // :: // :: . ■ ingeniería sistemas significaba que personal clínico tenía menos tiempo para hablar con ellos. desde una perspectiva médica, este sistema era una mejora sobre sistema manual anterior, pero era desde una perspectiva administrativa. naturaleza los atributos seguridad confiabilidad incluso hace ocasiones más difícil decidir sistema exitoso. intención sistema nuevo será, diga-mos, mejorar seguridad sustituir sistema existente con entorno datos más seguro. suponga que, después instalación, sistema atacado, que sobreviene una brecha seguridad algunos datos corrompen. ¿esto significa que sistema resultó fracaso? imposible decirlo, porque conoce dimensión las pérdidas que ocurrirían con sistema antiguo, dados los mismos ataques. . ingeniería sistemas ingeniería sistemas abarca todas las actividades que hay procuración, especificación, diseño, implementación, validación, despliegue, operación mantenimiento los sistemas sociotécnicos. los ingenieros sistemas sólo preocupan por software, sino también por hardware las interacciones del siste- con los usuarios entorno. ellos deben pensar los servicios que ofrece sis-tema, las restricciones con las cuales deben construir operar mismo, así como las formas las cuales sistema usa para cumplir con () propósito(). existen tres etapas que traslapan (figura .) vida los sistemas sociotécni-cos grandes complejos: . procuración adquisición durante esta etapa decide propósito sis- tema; establecen los requerimientos alto nivel del sistema; toman decisiones sobre cómo distribuirá funcionalidad través del hardware, software personal; adquieren los componentes que constituirán sistema. . desarrollo durante esta etapa diseña sistema. los procesos desarrollo incluyen todas las actividades que intervienen desarrollo del sistema, como definición requerimientos, diseño del sistema, ingeniería del hardware soft-ware, integración pruebas del sistema. definen los procesos operacionales diseñan los cursos capacitación para los usuarios del sistema. . operación esta etapa implementa sistema, capacita los usuarios pone funcionamiento sistema. constantemente, tienen entonces que cambiar los procesos operacionales planeados para reflejar entorno trabajo real donde usa sistema. con tiempo, sistema evoluciona medida que identifican nuevos requerimientos. final cuentas, sistema declina valor retira del servicio activo para reemplazarse. estas etapas son independientes. una vez que sistema está operación, quizá sea posible que procure nuevo equipo software para sustituir los componentes obsoletos del sistema, ofrecer nueva funcionalidad, bien, hacer frente aumento demanda. igual modo, las peticiones cambios durante operación requieren más desarrollo del sistema. -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos seguridad confiabilidad global sistema tienen influencia las activida- des durante todas estas etapas. las opciones diseño pueden restringirse por decisiones procuración ámbito del sistema, así como hardware software. quizá sea imposible implementar ciertos tipos protecciones del sistema. ello introduciría vulnerabilidades que podrían conducir futuras fallas del sistema. los errores humanos cometidos durante las fases especificación, diseño desarrollo significarían que introducen fallas desarrollo sistema. las pruebas inadecuadas significarían que las fallas desarrollo descubren antes que implemente sistema. durante operación, los errores configuración del sistema para implementación podrían conducir más vulnerabilidades. los operadores del sistema también pueden cometer errores uso del sistema. quizá las suposiciones realizadas durante procuración original olviden cuando hacen cambios sistema , nueva cuenta, podrían introducir vulnerabilidades sistema. una diferencia importante entre ingeniería sistemas software inclusión una variedad disciplinas profesionales largo vida del sistema. por ejemplo, figura . muestran las disciplinas técnicas que intervienen procuración desarrollo nuevo sistema para manejo tráfico aéreo. están implicados arquitectos ingenieros civiles, porque los nuevos sistemas manejo del tráfico aéreo, por general, tienen que instalarse nuevo edificio. participan ingenieros eléctricos mecánicos para especificar mantener energía eléctrica aire acondicionado. los ingenieros electrónica ocupan las computadoras, los radares otros equipos. los ergonomistas diseñan las estaciones trabajo los controladores, tanto que los ingenieros software diseñadores interfaz usuario encargan del software del sistema. esencial inclusión varias disciplinas profesionales, que existen demasiados aspectos diferentes los sistemas sociotécnicos complejos. sin embargo, las variedades entre disciplinas pueden introducir vulnerabilidades los sistemas , por consiguiente, comprometer seguridad confiabilidad del sistema que desarrollar: . diferentes disciplinas usan las mismas palabras que significan distintas cuestiones. las interpretaciones equivocadas son comunes entre ingenieros con antecedentes diversos. descubren resuelven durante desarrollo del sistema, podrían conducir errores los sistemas entregados. por ejemplo, ingeniero electrónico que sepa poco acerca programación #, tal vez entienda que método java comparable una función .figura . etapas ingeniería sistemasprocuración desarrollo operaciónimplementaciónactualizaciones equipo software evolución del sistema -.indd -.indd // :: // :: . ■ procuración del sistema . cada disciplina hace suposiciones sobre que puede hacer otra disciplina. tales suposiciones basan con frecuencia una comprensión inadecuada que posible realmente. por ejemplo, diseñador interfaz usuario propondrá una (user interface ) gráfica para sistema embebido que requiera mayor cantidad procesamiento , consecuencia, sobrecargará procesador del sistema. . las disciplinas tratan proteger sus fronteras profesionales justifican ciertas decisiones diseño porque éstas requerirán experiencia profesional. con-secuencia, ingeniero software puede cuestionar favor sistema cierre puertas edificio basado software, aun cuando sería más fiable sistema mecánico basado llaves. . procuración del sistema fase inicial ingeniería sistemas procuración del sistema (llamada ocasiones adquisición del sistema). esta etapa toman decisiones sobre ámbito sistema que adquirirá, los presupuestos plazos del sistema, así como sobre los requerimientos alto nivel del sistema. usar esta información, toman más deci-siones sobre procura sistema, tipo sistema requerido (los) proveedor() del sistema. los controladores para tales decisiones son: . estado otros sistemas organización organización tiene una mezcla sistemas que logran comunicarse con facilidad que son costosos mante-ner, entonces procuración sistema reemplazo conduciría beneficios empresariales significativos. . necesidad cumplir con regulaciones externas cada vez más, las empresas están reguladas deben demostrar cumplimiento con regulaciones definidas manera externa (por ejemplo, las regulaciones contabilidad sarbanes-oxley estados unidos). esto podría requerir sustitución los sistemas que cumplen provisión nuevos sistemas específicamente para monitorizar cumplimiento. . competencia externa una empresa necesita competir forma más efectiva mantener una posición competitiva, sería conveniente realizar inversión nuevosfigura . disciplinas profesionales que intervienen ingeniería sistemasingeniería sistemasingeniería eléctricaingeniería mecánica ergonomíaingeniería softwareingeniería civilarquitectura diseño interfaz usuarioingeniería electrónica -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos sistemas que mejoren eficiencia los procesos empresariales. para sistemas militares, necesidad mejorar capacidad ante las nuevas amenazas una importante razón para procurar sistemas nuevos. . reorganización empresarial las empresas otras organizaciones reestructuran frecuentemente con intención mejorar eficiencia / servicio cliente. las reorganizaciones conducen cambios los procesos empresariales que requie-ren soporte nuevos sistemas. . presupuesto disponible presupuesto disponible factor innegable determinación del ámbito los nuevos sistemas que pueden procurarse. además, con frecuencia procuran nuevos sistemas gubernamentales que reflejan los cambios principios políticos. por ejemplo, ocasiones los políticos deciden com-prar sistemas vigilancia nuevos que, afirman, combatirán terrorismo. comprar tales sistemas muestran los electores que toman acciones. sin embargo, dichos sistemas gestionan menudo sin análisis costo/beneficio, donde comparen los beneficios que resultan las diferentes opciones gastos. los sistemas grandes complejos consisten por general una mezcla compo-nentes comerciales especialmente construidos. una razón por que incluye cada vez más software los sistemas que permite mayor uso los componentes hard-ware existentes, que software actúa como “pegamento” (glue) para hacer que dichos componentes hardware funcionen conjunto manera efectiva. necesidad por desarrollar este “glueware” una razón por cual ocasiones los ahorros para usar componentes comerciales (off-the-shelf ) son tan cuantiosos como anticipaba. figura . ilustra modelo simplificado del proceso procuración, tanto para componentes del sistema cots como para componentes del sistema que diseñaron desarrollaron medida. los puntos importantes sobre proceso que muestra este diagrama son: . los componentes comerciales regularmente cubren con exactitud los requeri- mientos, menos que éstos hayan escrito con tales componentes mente. por ello, elegir sistema significa que debe encontrarse coincidencia más cercana entre los requerimientos del sistema las funcionalidades ofrecidas por los siste-mas comerciales. entonces, quizá tengan que modificarse los requerimientos. esto podría tener efectos secundarios sobre otros subsistemas.figura . procesos procuración del sistemasistema comercial disponible personalización del sistema requeridoadaptación requerimientos definición requerimientosemisión solicitud licitaciónseleccionar licitadorvaloración sistemas existenteselección del proveedor del sistema negociación del contratodefinición requerimientos empresarialesestudio mercado para sistemas existentes -.indd -.indd // :: // :: . ■ procuración del sistema . cuando sistema construye medida, especificación requerimientos forma parte del contrato para sistema que adquirir. por consiguiente, trata documento tanto legal como técnico. . después seleccionar contratista para construir sistema, hay periodo negociación del contrato que quizá tengan que negociar más cambios los requerimientos, discutir temas como costo los cambios sistema. igual modo, una vez seleccionado sistema cots, posiblemente deba negociar con proveedor acerca costos, condiciones licencia, posibles cambios sistema, etcétera. software hardware los sistemas sociotécnicos los desarrolla por gene-ral una organización diferente ( proveedor) organización que procura sistema sociotécnico global. razón para esto que empresa del cliente rara vez desarrolla software, manera que sus empleados tienen las habilidades necesarias para diseñar los sistemas por mismos. hecho, muy pocas compañías tienen las capacidades para diseñar, fabricar poner prueba todos los componentes gran sistema sociotécnico complejo. consecuencia, proveedor del sistema, que comúnmente conoce como con-tratista principal, con frecuencia subcontrata desarrollo diferentes subsistemas algunos subcontratistas. para sistemas grandes, como los sistemas control del tráfico aéreo, grupo proveedores pueden formar consorcio para licitar por contrato. consorcio debe incluir todas las capacidades requeridas para este tipo sistema. esto incluye proveedores hardware computadora, desarrolladores software, provee-dores periféricos equipo especial, como sistemas radar. comprador trata con contratista con los subcontratistas, modo que hay una sola interfaz comprador/proveedor. los subcontratistas diseñan construyen partes del sistema bajo una especificación que produce contratista principal. una vez comple-tado, contratista principal integra los diferentes componentes los entrega cliente. dependiendo del contrato, comprador puede permitir que contratista principal selec-cione libremente los subcontratistas, bien, solicitar contratista principal que elija subcontratistas entre una lista autorizada. toma decisiones elecciones durante procuración del sistema tiene una gran influencia sobre seguridad confiabilidad sistema. por ejemplo, toma una decisión para procurar sistema comercial, entonces organización debería aceptar que tienen influencia muy limitada sobre los requerimientos seguridad confiabilidad este sistema. ello depende básicamente las decisiones tomadas por los proveedo-res del sistema. además, los sistemas comerciales pueden tener debilidades seguridad conocidas requerir configuración compleja. los errores configuración, donde los puntos entrada sistema aseguran manera adecuada, son una fuente principal problemas seguridad. por otro lado, una decisión para procurar sistema personalizado significa que debe dedicarse esfuerzo considerable para entender definir los requerimientos segu-ridad confiabilidad. una compañía tiene experiencia limitada área, ésta será una labor muy difícil realizar. debe lograrse nivel confiabilidad requerido, así como rendimiento aceptable del sistema, entonces tal vez sea necesario extender tiempo desarrollo aumentar presupuesto. -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos . desarrollo del sistema las metas del proceso desarrollo del sistema son diseñar adquirir todos los compo- nentes sistema , después, integrar dichos componentes para elaborar sistema final. los requerimientos son puente entre los procesos procuración desarrollo. durante procuración definen los requerimientos empresariales los requerimientos funcionales funcionales alto nivel del sistema. puede considerar esto como inicio del desarrollo, ahí traslape los procesos que muestran figura .. una vez acordados los contratos para los componentes del sistema, tiene lugar ingenie-ría más detallada los requerimientos. figura . modelo del proceso desarrollo sistemas. este proceso ingeniería sistemas fue una importante influencia modelo “ cascada” del pro-ceso software estudiado capítulo . aunque ahora acepta que modelo “ cascada” general adecuado para desarrollo del software, mayoría los procesos desarrollo sistemas son procesos derivados plan que todavía siguen dicho modelo. los procesos derivados plan utilizan ingeniería sistemas, que diferentes partes del sistema desarrollan mismo tiempo. para sistemas que incluyen hardware otro equipo, los cambios durante desarrollo suelen ser muy costosos , ocasiones, prácticamente imposibles. por consiguiente, esencial que los requeri-mientos del sistema estén completamente entendidos antes comenzar desarrollo trabajo construcción del hardware. rara vez posible reformar diseño del sistema para resolver problemas hardware. por tal razón, cada vez más funcionalidad del sistema asigna software del sistema. esto permite algunos cambios durante desarrollo del sistema, respuesta los nuevos requerimientos del sistema que surgen inevitablemente. uno los aspectos que más confunden ingeniería sistemas que las com-pañías usan una terminología diferente para cada etapa del proceso. también varía estructura del proceso. algunas ocasiones, ingeniería requerimientos parte del proceso desarrollo , otras, una actividad independiente. sin embargo, esencia hay seis actividades fundamentales cuanto desarrollo sistemas: . desarrollo requerimientos los requerimientos alto nivel empresariales identificados durante proceso procuración deben desarrollarse con más detalle. los requerimientos deben asignarse hardware, software los procesos, hay que priorizar implementación.ingeniería subsistemasdiseño del sistemadesarrollo requerimientosimplementación del sistema pruebas del sistema integración del sistema figura . desarrollo sistemas -.indd -.indd // :: // :: . ■ desarrollo del sistema . diseño del sistema este proceso superpone significativamente con proceso desarrollo requerimientos. implica establecimiento arquitectura global del sistema, identificar los diferentes componentes del sistema entender las rela-ciones entre ellos. . ingeniería subsistemas esta etapa implica desarrollo los componentes software del sistema; configuración del hardware software comerciales , necesario, diseño hardware para propósito especial; definición los procesos operacionales para sistema, rediseño los procesos empresariales esenciales. . integración del sistema durante esta etapa, los componentes reúnen para crear nuevo sistema. sólo entonces vuelven evidentes las propiedades emergentes del sistema. . pruebas del sistema por general, ésta una actividad extensa prolongada, donde detectan los problemas. regresa las fases ingeniería subsistemas integración del sistema para reparar dichos problemas, corregir rendimiento del sistema implementar nuevos requerimientos. las pruebas del sistema pueden requerir tanto las pruebas por parte del desarrollador del sistema, como pruebas aceptación/usuario por parte organización que procuró sistema. . implementación del sistema éste proceso poner sistema disposición sus usuarios, transferir datos los sistemas existentes establecer comunica-ciones con otros sistemas entorno. proceso culmina con una “inauguración”, después cual los usuarios comienzan usar sistema para apoyar trabajo. aunque proceso global está derivado plan, los procesos desarrollo requerimientos diseño del sistema encuentran inevitablemente ligados. los reque-rimientos diseño alto nivel desarrollan manera concurrente. las restriccio-nes impuestas por los sistemas existentes llegan limitar las opciones diseño éstas pueden especificarse los requerimientos. probablemente deba realizar cierto diseño inicial para estructurar organizar proceso ingeniería requerimientos. conforme continúa proceso diseño, descubrirían problemas con los requerimientos existen-tes surgirían nuevos requerimientos. consecuencia, considera que estos procesos vinculan forma espiral, como indica figura .. espiral refleja realidad que los requerimientos afectan las decisiones diseño viceversa , por tanto, tiene sentido entremezclar dichos procesos. partir del centro, cada vuelta espiral puede agregar detalle los requerimientos diseño. algunas vueltas suelen enfocarse los requerimientos otras diseño. veces, nuevo conocimiento recolectado durante los requerimientos proceso diseño signi-fica que debe cambiarse enunciado del problema . para casi todos los sistemas, existen muchos diseños posibles que cumplen con los requerimientos. éstos cubren una variedad soluciones que combinan hardware, software las operaciones humanas. solución que usted elija para más desarrollo sería solución técnica más adecuada que cubra los requerimientos. sin embargo, considera-ciones organizativas políticas más amplias llegan influir opción solución. por ejemplo, cliente gubernamental quizá prefiera para sistema uso proveedores nacionales vez extranjeros, incluso los productos nacionales son técnicamente inferiores. dichas influencias tienen por general efecto fase revisión valora-ción del modelo espiral, donde diseños requerimientos pueden aceptarse rechazarse. -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos proceso termina cuando una revisión decide que los requerimientos diseño alto nivel están suficientemente detallados para especificación diseño sub-sistemas. fase ingeniería subsistemas implementan los componentes hardware software del sistema. para algunos tipos sistema, como las aeronaves, todos los componentes hardware software pueden diseñarse construirse durante proceso desarrollo. sin embargo, mayoría los sistemas, algunos componentes son sistemas comerciales (cots). suele ser mucho más barato comprar productos existentes que desarrollar componentes con propósito especial. por general, los subsistemas desarrollan paralelo. cuando encuentran pro-blemas que cruzan través las fronteras del subsistema, debe hacerse una petición para modificar sistema. cuando los sistemas requieran una extensa ingeniería del hard-ware, realizar modificaciones después que comenzó fabricación generalmente muy costoso. menudo, para compensar problema tienen que encontrarse “solucio-nes”. éstas casi siempre implican cambios software, debido flexibilidad inherente del mismo. durante integración sistemas toman los subsistemas desarrollados manera independiente reúnen para constituir sistema completo. esta integración puede formarse usar enfoque “big-bang”, donde todos los subsistemas integran mismo tiempo. sin embargo, por razones técnicas administrativas, mejor opción proceso integración incremental que los subsistemas integren uno vez: . generalmente imposible programar desarrollo los subsistemas modo que todos terminen mismo tiempo. . integración incremental reduce costo localización del error. numero-sos subsistemas integran simultáneamente, error que surja durante las pruebas podría estar cualquiera dichos subsistemas. cuando solo subsistema figura . espiral requerimientos diseñodocumentación requerimientos diseño del sistemarevisión valoracióndiseño arquitectónicoinicioadquisición análisis requerimientoscomprensión dominio problema -.indd -.indd // :: // :: . ■ operación del sistema integra con sistema operación, los errores que ocurran probablemente esta- rán subsistema recientemente integrado, bien, las interacciones entre los subsistemas existentes nuevo subsistema. conforme más sistemas construyen mediante integración componentes cots hardware software, cada vez más difusa distinción entre implementación integración. algunos casos, hay necesidad desarrollar nuevo hardware software, integración , esencia, fase implementación del sistema. durante después del proceso integración, sistema pone prueba. hacerlo, hay que enfocarse poner prueba las interfaces entre componentes comporta-miento del sistema como todo. inevitablemente, esto también revelará problemas con subsistemas individuales que deban repararse. las fallas subsistema son una consecuencia suposiciones inválidas sobre otros subsistemas que, con frecuencia, revelarán durante integración del sistema. esto conduciría disputas entre los contratistas responsables implementación dife-rentes subsistemas. cuando descubren problemas interacción subsistemas, los contratistas pueden estar acuerdo sobre cuál subsistema defectuoso. tal vez las negociaciones referentes cómo resolver los problemas duren semanas meses. etapa final del proceso desarrollo del sistema entrega implementación del mismo. software instala hardware está listo para operación. esto podría requerir más configuración del sistema para reflejar entorno local donde usa, transferencia datos sistemas existentes preparación documentación capa-citación del usuario. esta etapa quizá también deban reconfigurar otros sistemas entorno, con finalidad garantizar que nuevo sistema interopere con ellos. aunque directa principio, ocasiones durante implementación surgen varias difi-cultades. entorno del usuario puede ser diferente del anticipado por los desarrollado-res del sistema tal vez sea difícil adaptar sistema para enfrentar diversos entornos usuario. los datos existentes quizá requieran una limpieza fondo las partes los mismos pueden perderse. las interfaces hacia otros sistemas tal vez estén documentadas forma adecuada. clara influencia los procesos desarrollo del sistema sobre confiabilidad seguridad. durante tales procesos, cuando toman decisiones sobre los reque-rimientos confiabilidad seguridad, así como sobre las negociaciones entre costos, fecha, rendimiento confiabilidad. los errores humanos todas las etapas del proceso desarrollo suelen conducir introducción fallas sistema que, opera-ción, llevarían una falla del sistema. los procesos prueba validación están inevita-blemente restringidos por los costos tiempo disponible. como resultado, sistema quizá pruebe manera adecuada. deja los usuarios probar sistema con-forme utilicen. finalmente, los problemas implementación del sistema podrían significar que hay una falta concordancia entre sistema entorno operacional. esto puede conducir errores humanos usar sistema. . operación del sistema los procesos operacionales son aquellos que están relacionados con uso del sistema para propósito definido. por ejemplo, los operadores sistema control tráfico aéreo siguen procesos específicos cuando una aeronave entra sale del espacio aéreo, -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos cuando tienen que cambiar altura velocidad, cuando ocurre una emergencia, etcétera. para los nuevos sistemas, dichos procesos operacionales deben definirse documentarse durante proceso desarrollo del sistema. tal vez deba capacitar los operadores adaptar otros procesos laborales para usar nuevo sistema manera efectiva. esta etapa podrían surgir problemas descubiertos, porque especificación del sistema tenga errores omisiones. así, aunque sistema desempeñe acuerdo con las especifica-ciones, probablemente sus funciones cubran las necesidades operacionales reales. consecuencia, los operadores quizá usen sistema como pretendían los diseñadores. beneficio clave contar con operadores sistemas que las personas tienen una capacidad única responder efectivamente ante situaciones inesperadas, aunque nunca hayan tenido una experiencia directa con tales situaciones. por tanto, cuando las cosas salen mal, los operadores con frecuencia rescatan situación, aunque ocasiones ello signifique que infrinja proceso definido. los operadores también emplean conocimiento local para adaptar mejorar los procesos. normalmente, los procesos ope-racionales reales son diferentes los anticipados por los diseñadores del sistema. por consiguiente, requiere diseñar procesos operacionales que sean flexibles adaptables. los procesos operacionales tienen que ser demasiado restrictivos, requerir que las operaciones realicen orden específico, tampoco software del sistema debe apoyarse seguimiento proceso específico. los operadores por regular mejoran proceso, que saben qué funciona qué funciona una situación real. problema que surge sólo después que sistema entra operación opera-ción del nuevo sistema junto con los sistemas existentes. pueden existir problemas físicos incompatibilidad quizá resulte difícil transferir datos sistema otro. también surgirían problemas más sutiles debido que diferentes sistemas tienen distintas interfa-ces usuario. introducir nuevo sistema puede aumentar tasa error del operador, que los operadores usan comandos interfaz usuario para sistema equivocado. .. error humano las primeras páginas del capítulo sugirió que determinismo era conflicto importante los sistemas sociotécnicos, que una razón para ello obedecía que las personas sistema comportan siempre misma forma. algunas veces cometen errores usar sistema esto tiene potencial provocar fallas del sistema. por ejemplo, operador olvida registrar que realizó cierta acción, otro operador (erróneamente) repetiría dicha acción. acción, por ejemplo, deducción acre-ditación una cuenta bancaria, entonces ocurre una falla del sistema, pues incorrecta cantidad cuenta. como afirma reason (), los errores humanos ocurrirán siempre existen dos formas considerar problema del error humano: . enfoque personal . los errores consideran responsabilidad del individuo los “actos inseguros” (como operador que falla implementar una barrera seguridad) son consecuencia descuido individual comportamiento impru-dente. las personas que adoptan este enfoque creen que los errores humanos suelen reducirse con amenazas disciplinarias, procedimientos más rigurosos, capacitación adicional, etcétera. visión que error culpa del individuo responsable por cometer falla. -.indd -.indd // :: // :: . ■ operación del sistema . enfoque sistemas . supuesto básico que las personas son falibles equivocarán. los errores que gente comete por general son consecuencia deci- siones diseño del sistema, que llevan formas erróneas trabajar, bien, facto-res organización, que afectan los operadores del sistema. los sistemas eficaces tienen que reconocer posibilidad del error humano, incluir barreras protecciones que los detecten, permitir sistema recuperarse antes que ocurra falla. cuando ésta sucede, prioridad encontrar individuo para echarle culpa, sino enten-der cómo por qué las protecciones del sistema pasaron por alto error. considera que enfoque sistemas correcto, que los ingenieros siste-mas deben admitir que ocurrirán errores humanos durante operación del sistema. por ello, para mejorar seguridad confiabilidad sistema, los diseñadores deben pensar las protecciones barreras error humano que tienen que incluirse sistema. también necesario considerar dichas barreras tienen que edificarse los procedimientos técnicos del sistema. así, serían parte los procesos procedi-mientos para usar sistema, serían los lineamientos del operador los que dependen verificación reflexión humanas. los siguientes son ejemplos protecciones que pueden incluirse sistema: . sistema control tráfico aéreo podría incluir sistema automatizado alerta conflicto. cuando controlador instruya una aeronave cambiar velocidad altitud, sistema extrapola trayectoria para saber podría coli-sionar contra alguna otra aeronave. así, activa una alarma. . mismo sistema podría tener procedimiento claramente definido para registrar las instrucciones control emitidas. dichas acciones ayudan controlador com-probar emitieron correctamente instrucción disponer información para que verifiquen otros. . control tráfico aéreo comúnmente implica equipo controladores que, manera continua, monitorizan trabajo los demás. por consiguiente, cuando comete error, probable que detecte corrija antes que ocurra incidente. inevitablemente, todas las barreras presentan debilidades algún tipo. reason las llama “condiciones latentes”, pues usualmente sólo contribuyen falla del sistema cuando ocurre algún otro problema. por ejemplo, sobre las defensas, punto débil sistema alerta conflicto que puede conducir muchas falsas alarmas. por tanto, los controladores ignorarían las advertencias del sistema. una inconsistencia sistema procedimental sería que información inusual, pero esencial, registre con facilidad. revisión humana suele fallar cuando todas las personas que intervienen enfrentan mucho estrés cometen mismo error. las condiciones latentes conducen falla del sistema cuando las defensas construidas éste detectan una falla activa por parte operador del sistema. error humano activador falla, pero debe considerarse como razón exclusiva ella. reason explica anterior utilizando muy conocido modelo “queso suizo” falla del sistema (figura .). este modelo, las defensas construidas sistema comparan con rebanadas queso suizo. algunos tipos queso suizo, como emmental, tienen orificios , por -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos consiguiente, analogía que las condiciones latentes son comparables con los orificios las rebanadas queso. posición dichas aberturas estática, sino que cambia según estado del sistema sociotécnico global. cada rebanada representa una barrera, las fallas podrían ocurrir cuando los orificios alinean mismo tiempo que error ope-rativo humano. una falla activa operación del sistema pasa través los agujeros, conduce una falla global del sistema. por general, claro, los agujeros deben alinearse modo que sistema detecte las fallas operacionales. para reducir probabilidad que las fallas del sistema sean producto del error humano, los diseñadores tienen que: . diseñar sistema que incluya diferentes tipos barreras. esto significa que los “orificios” probablemente estarán diferentes lugares , por tanto, hay una posi-bilidad menor que los orificios alineen fracasen para detectar error. . minimizar número condiciones latentes sistema. efectivamente, esto significa reducir número tamaño los “orificios” del sistema. desde luego, diseño del sistema como totalidad también debe tratar evitar que las fallas activas originen una falla del sistema. esto implicaría diseño los procesos operacionales sistema para garantizar que los operadores trabajen exceso, distraigan les presenten cantidades excesivas información. .. evolución del sistema los sistemas grandes complejos tienen una vida muy larga. durante ella, cambian para corregir errores los requerimientos originales del sistema implementar los nuevos requerimientos que hayan surgido. probable que las computadoras del sistema susti-tuyan por máquinas nuevas más rápidas. organización que usa sistema puede reor-ganizarse misma , por consiguiente, usar sistema una forma diferente. entorno externo del sistema llega variar, cual forzaría los cambios sistema. consecuencia, evolución, donde sistema modifica para acomodar cambio ambiental, pro-ceso que funciona junto con los procesos operacionales normales del sistema. evolución del sistema implica reingresar proceso desarrollo para realizar cambios extensiones hardware, software los procesos operacionales del sistema.figura . modelo queso suizo reason falla del sistema falla del sistemafalla activa (error humano) barreras -.indd -.indd // :: // :: . ■ operación del sistema evolución del sistema, como evolución del software (estudiado capítulo ), inherentemente costosa por varias razones: . los cambios propuestos tienen que analizarse con sumo cuidado, desde una pers- pectiva empresarial técnica. los cambios deben contribuir las metas del sistema simplemente tener motivaciones técnicas. . puesto que los subsistemas nunca son totalmente independientes, los cambios subsistema podrían afectar modo adverso rendimiento comportamiento otros subsistemas. por ende, quizá requieran cambios consecuentes dichos subsistemas. . las razones para las decisiones diseño original registran con frecuen-cia. los responsables evolución del sistema tienen que reflexionar por qué tomaron decisiones específicas diseño. . conforme aumenta antigüedad los sistemas, estructura general puede haberse corrompido progresivamente por las modificaciones, modo que aumen-tan los costos realizar más cambios. los sistemas que evolucionaron con tiempo dependen menudo tecnología obsoleta hardware software. tienen papel crítico una organización, cono-cen como “sistemas heredados”. por general, trata sistemas que organización quisiera sustituir, pero hace que los riesgos costos sustitución son justificables. desde una perspectiva confiabilidad seguridad, los cambios sistema con frecuencia son una fuente problemas vulnerabilidades. las personas que imple-mentan los cambios son las mismas que desarrollaron sistema, quizá estén tanto que una decisión diseño tomó por razones confiabilidad seguridad. consecuencia, podrían cambiar sistema perder parte las protecciones que implementaron deliberadamente cuando construyó sistema. más aún, dado que las pruebas son costosas, volver probar por completo sería casi imposible después cada cambio sistema. tal caso, probablemente descubran los efectos colaterales adversos los cambios, que introducen exponen fallas otros componentes del sistema.sistemas heredados los sistemas heredados son sistemas sociotécnicos basados computadoras que desarrollaron pasado, usando con frecuencia tecnología más antigua obsoleta. dichos sistemas incluyen sólo hardware software, sino también procesos procedimientos heredados, añejas formas hacer las cosas que son difíciles transformar porque apoyan software heredado. los cambios una parte del sistema requieren inevitablemente variaciones otros componentes. los sistemas heredados usualmente son sistemas empresariales críticos. mantienen porque muy arriesgado sustituirlos. http:// -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos puntos clave ■ los sistemas sociotécnicos incluyen hardware, software personal cómputo, que sitúan dentro una organización. éstos diseñan para apoyar las metas los objetivos empresariales organización. ■ los factores humanos organización, como estructura las políticas organización, tienen efecto significativo sobre operación los sistemas sociotécnicos. ■ las propiedades emergentes sistema son características del sistema como todo, sus partes componentes. incluyen propiedades como rendimiento, fiabilidad, usabilidad, seguridad protección. éxito fracaso sistema dependen con frecuencia dichas propiedades emergentes. ■ los procesos fundamentales ingeniería sistemas son procuración, desarrollo operación del sistema. ■ procuración del sistema cubre todas las actividades que intervienen decidir qué sistema comprar quién debe suministrar dicho sistema. los requerimientos alto nivel desarrollan como parte del proceso procuración. ■ desarrollo del sistema incluye especificación requerimientos, diseño, construcción, integración pruebas. integración del sistema, donde los subsistemas con más proveedor deben reunirse para trabajar juntos, particularmente crítica. ■ cuando sistema pone funcionamiento, los procesos operacionales sistema deben variar para reflejar los cambiantes requerimientos empresariales. ■ los errores humanos son inevitables los sistemas deben incluir barreras para detectar dichos errores, antes que deriven una falla del sistema. modelo queso suizo reason explica cómo error humano los defectos latentes las barreras pueden conducir fallas del sistema. lecturas sugeridas “airport : automated baggage system”. estudio caso excelente comprensible que puede salir mal con proyecto ingeniería sistemas cómo software tiende culparse por fallas sistemas más amplias. (acm software engineering notes, , marzo .)http:/ /doi. acm. org/ . / . . “software system engineering: tutorial”. amplio panorama general ingeniería sistemas, aunque thayer enfoca exclusivamente los sistemas basados computadora, sin examinar los temas sociotécnicos. (. . thayer. ieee computer, abril .) http:/ /. doi. org/ . / . . . trust technology: socio-technical perspective. este libro conjunto ensayos, los cuales tratan, cierta forma, confiabilidad los sistemas sociotécnicos. (. clarke, . hardstone, . rouncefield . sommerville (eds.), springer, .) “fundamentals systems engineering”. éste capítulo introductorio del manual ingeniería sistemas nasa. presenta una visión del proceso ingeniería sistemas para sistemas -.indd -.indd // :: // :: pmcapítulo ■ ejercicios espaciales. aunque trata sistemas técnicos principalmente, hay temas sociotécnicos por considerar. desde luego, confiabilidad primordial. ( nasa systems engineering handbook, nasa--, .) http:/ /education. ksc. nasa. gov/ esmdspacegrant/ documents/ nasa%--%%%%. pdf. ejercicios .. dos ejemplos funciones gubernamentales que reciban soporte sistemas sociotécnicos complejos, explique por qué, futuro previsible, dichas funciones serán completamente automatizadas. .. exponga por qué entorno donde instaló sistema basado computadora tendría efectos anticipados sobre sistema, que conduzcan falla del mismo. ilustre respuesta con ejemplo diferente del que usó este capítulo. .. ¿por qué imposible inferir las propiedades emergentes sistema complejo partir las propiedades los componentes del sistema? .. ¿por qué ocasiones difícil decidir hubo una falla sistema sociotécnico? aclare respuesta con ejemplos del mhc-pms que estudió capítulos anteriores. .. ¿qué “problema malvado”? explique por qué desarrollo sistema nacional registros médicos tiene que considerarse como “problema malvado”. .. sistema museo multimedia que ofrece experiencias virtuales antigua grecia desarrollará para consorcio museos europeos. sistema debe proporcionar los usuarios facilidad ver modelos - antigua grecia través navegador web estándar, también tiene que soportar una experiencia realidad virtual inmersión. ¿qué dificultades políticas organizacionales surgirían cuando sistema instale los museos que constituyen consorcio? .. ¿por qué integración sistema una parte especialmente crítica del proceso desarrollo sistemas? sugiera tres conflictos sociotécnicos que causen dificultades proceso integración del sistema. .. exprese por qué ocasiones los sistemas heredados son críticos para operación una empresa. .. ¿cuáles son los argumentos favor contra considerar ingeniería sistemas como una profesión por derecho propio, como ingeniería eléctrica ingeniería software? .. usted ingeniero que participa desarrollo sistema financiero. durante instalación, descubre que este sistema hará redundantes número significativo individuos. las personas entorno niegan acceso información esencial para completar instalación del sistema. ¿ qué medida debe, como ingeniero sistemas, involucrarse esta situación? ¿ responsabilidad profesional completar instalación como contrató? ¿simplemente debe abandonar trabajo hasta que organización compradora resuelva problema? -.indd -.indd // :: // :: capítulo ■ sistemas sociotécnicos referencias ackroyd, ., harper, ., hughes, . . shapiro, . (). information technology and practical police work. milton keynes: open university press. anderson, . ., hughes, . . sharrock, . . (). working for profit: the social organization calculability entrepreneurial firm. aldershot: avebury.checkland, . (). systems thinking, systems practice. chichester: john wiley & sons.checkland, . scholes, . (). soft systems methodology action. chichester: john wiley & sons. mumford, . (). “user participation changing environment—why need ”. participation systems development. knight, . (.). londres: kogan page. reason, . (). “human error: models and management”. british medical ., –.rittel, . webber, . (). “dilemmas general theory planning”. policy sciences, , –.stevens, ., brook, ., jackson, . arnold, . (). systems engineering: coping with complexity. londres: prentice hall. suchman, . (). plans and situated actions: the problem human-machine communication . nueva york: cambridge university press.swartz, . . (). “airport : automated baggage system?” acm software engineering notes, (), –.thayer, . . (). “software system engineering: tutorial.” ieee computer, (), –. thomé, . (). “systems engineering: principles and practice computer-based systems engineering”. chichester: john wiley & sons. white, ., alford, ., holtzman, ., kuehl, ., mccay, ., oliver, ., owens, ., tully, . willey, . (). “systems engineering computer-based systems”. ieee computer, (), –. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo confiabilidad seguridad del software. estudiar este capítulo: ■ comprenderá por qué confiabilidad seguridad son, por general, más importantes que las características funcionales sistema software; ■ entenderá las cuatro principales dimensiones confiabilidad, decir: disponibilidad, fiabilidad, protección seguridad; ■ conocerá terminología especializada que usa cuando analiza seguridad confiabilidad; ■ sabrá que, para lograr software confiable seguro, necesita evitar errores durante desarrollo sistema, detectarlos eliminarlos cuando sistema esté uso, así como reducir daño causado por fallas operativas. contenido . propiedades confiabilidad . disponibilidad fiabilidad . protección . seguridad confiabilidad seguridad -.indd -.indd // :: // :: capítulo ■ conﬁ abilidad seguridad conforme los sistemas cómputo insertan profundamente las vidas empresariales personales, incrementan los problemas que derivan las fallas del sistema del software. una falla del software del servidor una empresa comercio electrónico podría conducir dicha compañía hacia una gran pérdida ingresos , posiblemente, también clientes. error software sistema control embebido auto-móvil provocaría costosas devoluciones ese modelo por reparación , los peores casos, sería factor que contribuya los accidentes. infección compañía las con malware requiere costosas operaciones limpieza para solventar problema quizá como resultado pérdida daño información sensible. puesto que los sistemas intensivos software son tan importantes para los gobier-nos, las compañías los individuos, esencial que este tipo software sea digno con-fianza. software debe estar disponible cuando requiera ejecutarse correctamente sin efectos colaterales indeseables, como circulación información autorizada. término “confiabilidad” fue propuesto por laprie () para cubrir los atributos rela-cionados con sistemas disponibilidad, fiabilidad, protección seguridad. como estudia sección ., dichas propiedades están inextricablemente vinculadas, así que tiene sentido disponer solo término para tratarlas todas. confiabilidad los sistemas ahora usualmente más importante que funciona-lidad detallada por las siguientes razones: . las fallas del sistema afectan gran número individuos muchos sistemas incluyen funcionalidad que usa rara vez. esta funcionalidad retirara del sis- tema, tan sólo número menor usuarios resultarían afectados. las fallas del sistema, que afectan disponibilidad sistema, gravitarían potencialmente todos los usuarios del sistema. falla significaría que imposible continuar con normalidad del negocio. . los usuarios rechazan menudo los sistemas que son poco fiables, carecen pro-tecciones son inseguros los usuarios descubren que sistema poco fiable inseguro, rechazarán. más aún, ellos también pueden negarse adquirir usar otros productos compañía que desarrolló sistema que fiable, porque considera-rán que dichos productos tienen misma probabilidad ser fiables seguros. . los costos por las fallas del sistema suelen ser enormes para ciertas aplicaciones, como sistema control reactor sistema navegación aeronaves, costo por falla del sistema una orden magnitud mayor que costo del sis-tema control. . los sistemas confiables pueden causar pérdida información los datos son muy costosos recolectar mantener; por general, valen mucho más que sistema cómputo donde procesan. costo por recuperar datos perdidos con-taminados generalmente muy alto. como observó capítulo , software siempre parte sistema más amplio. ejecuta entorno operacional que incluye hardware donde produce software, los usuarios dicho software los procesos organización empresa que utiliza software. por tanto, diseñar sistema confiable debe considerar: . falla del hardware hardware del sistema puede fallar por errores diseño, componentes que averían por errores fabricación porque los componentes lle-garon final vida operativa. -.indd -.indd // :: // :: . ■ propiedades conﬁ abilidad . falla desarrollo software software del sistema puede fallar debido errores especificación, diseño implementación. . falla operación los usuarios fallan usar ejecutar sistema correctamente. conforme hardware software vuelven más confiables, las fallas ope-ración son ahora, quizá, principal causa individual fallas del sistema. dichas fallas suelen estar interrelacionadas. componente hardware que falla sig-nificaría que los operadores del sistema tengan que lidiar con una situación inesperada una carga trabajo adicional, que los pone bajo estrés; así, las personas cometen errores con frecuencia. esto llega provocar que falle software, que genera más trabajo para los operadores, incluso más estrés, entre otras contrariedades. como resultado, importante sobre todo que los diseñadores sistemas confiables con software intensivo adquieran una perspectiva holística los sistemas, vez enfocarse solo aspecto del sistema, como software hardware. estos últimos, además los procesos operacionales diseñan por separado, sin considerar las debi-lidades potenciales otras partes del sistema, entonces muy probable que ocurran errores las interfaces entre las diferentes partes del sistema. . propiedades confiabilidad todos estamos familiarizados con problema falla los sistemas cómputo. por razones que son evidentes, ocasiones las computadoras fallan descompo-nen alguna forma. los programas que operan estas computadoras quizá operen como espera , ocasiones, contaminan los datos que administra sistema. uno aprende vivir con tales fallas, aunque pocos confían por completo las computadoras que usan normalmente. confiabilidad sistema cómputo una propiedad del sistema que refleja fiabilidad. aquí, esta última significa esencia grado confianza que usuario tiene que sistema ejecutará como espera, que sistema “fallará” uso nor-mal. significativo expresar numéricamente confiabilidad. vez ello, usansistemas críticos algunas clases sistemas son “sistemas críticos” los que falla del sistema podría derivar una lesión individuos, daño ambiente pérdidas económicas mayores. los ejemplos sistemas críticos incluyen sistemas embebidos dispositivos médicos, como una bomba insulina (crítica para protección), sistemas navegación aeronaves (críticos para misión) sistemas transferencia dinero línea (críticos para empresa). los sistemas críticos son muy costosos desarrollar. sólo tienen que diseñarse modo que sean muy raras las fallas, sino también deben incluir mecanismos recuperación que usen ocurrir las fallas. http:// -.indd -.indd // :: // :: capítulo ■ conﬁ abilidad seguridad términos relativos como “ confiable”, “muy confiable” “ultraconfiable”, para reflejar los grados confianza que uno espera sistema. desde luego, fiabilidad utilidad son mismo. autor del libro considera que procesador texto que usó para escribirlo sea sistema muy confiable. algunas veces congela tiene que reiniciarse. obstante, puesto que muy útil, autor preparó para tolerar fallas esporádicas. sin embargo, para reflejar falta confianza sistema, frecuentemente guarda trabajo mantiene múltiples copias respaldo. para compensar falta confiabilidad del sistema, toma acciones que limitan daño que resultaría falla del sistema. hay cuatro dimensiones principales confiabilidad, como indica figura .. . disponibilidad manera informal, disponibilidad sistema probabi- lidad que momento dado éste funcionará, ejecutará ofrecerá servicios útiles los usuarios. . fiabilidad manera informal, fiabilidad sistema probabilidad, durante tiempo determinado, que sistema brindará correctamente servicios como espera usuario. . protección modo convencional, protección sistema juicio cuán probable que sistema causará daños las personas ambiente. . seguridad informalmente, seguridad sistema juicio cuán proba-ble que sistema pueda resistir intrusiones accidentales deliberadas. las propiedades confiabilidad que muestran figura . son propiedades complejas que podrían fragmentarse algunas otras propiedades más simples. por ejem-plo, seguridad incluye “integridad” (garantiza que los programas datos del sistema dañen) “confidencialidad” (garantiza que sólo personas autorizadas accedan información). fiabilidad incluye “exactitud” (garantiza que los servicios del sistema sean los especificados), “precisión” (garantiza que información entregue nivel detalle adecuado) “oportunidad” (garantiza que información entregue cuando requiera).figura . principales propiedades confiabilidadconfiabilidad capacidad del sistema para entregar servicios cuando requieracapacidad del sistema para entregar servicios según especifiquecapacidad del sistema para ejecutar sin fallas catastróficascapacidad del sistema para protegerse contra intrusión accidental deliberadafiabilidad protección disponibilidad seguridad -.indd -.indd // :: // :: . ■ propiedades conﬁ abilidad naturalmente, todas esas propiedades confiabilidad son aplicables todos los sistemas. para sistema bomba insulina, que trató capítulo , las propiedades más importantes son disponibilidad (debe funcionar cuando requiere), fiabilidad (tiene que suministrar dosis correcta insulina) protección (nunca debe entregar una dosis peligrosa insulina). seguridad problema, pues bomba mantiene información confidencial. está red , por consiguiente, puede ser atacada manera maliciosa. para sistema meteorológico campo abierto, disponibilidad fiabilidad son las propiedades más importantes, porque los costos reparación suelen ser muy altos. tanto, para sistema información pacientes, seguridad esencialmente importante, debido que mantiene los datos privados sensibles. además estas cuatro propiedades básicas confiabilidad, también pueden con-siderar las siguientes: . reparabilidad las fallas del sistema son inevitables; obstante, desajuste causado por falla podría minimizarse siempre que sistema logre repararse rápi-damente. para que ello ocurra, puede diagnosticar problema, acceder compo-nente que falló hacer cambios para corregir dicho componente. reparabilidad software mejora cuando organización que usa sistema tiene acceso código fuente cuenta con las habilidades para cambiarlo. software fuente abierta faci-lita esta labor, aunque reutilización componentes suele dificultarlo más. . mantenibilidad mientras usan los sistemas, surgen nuevos requerimientos importante mantener utilidad sistema cambiarlo para acomodar estos nuevos requerimientos. software mantenible aquel que económicamente adapta para lidiar con los nuevos requerimientos, donde existe una baja probabili-dad que los cambios insertarán nuevos errores sistema. . supervivencia atributo muy importante para sistemas basados internet supervivencia (ellison ., ). supervivencia habilidad sistema para continuar entregando servicio tanto está bajo ataque mientras que, poten-cialmente, parte del sistema deshabilita. trabajo sobre supervivencia enfoca identificación los componentes clave del sistema garantía que ellos puedan entregar servicio mínimo. para mejorar supervivencia usan tres estra-tegias: resistencia ataque, reconocimiento del ataque recuperación del daño cau-sado por ataque (ellison ., ; ellison ., ). capítulo examina esto con más detalle. . tolerancia para error esta propiedad considera como parte usabilidad refleja medida que sistema diseñó modo que eviten toleren los errores entrada usuario. cuando ocurren errores usuario, sistema debe, medida posible, detectar dichos errores corregirlos automáticamente solicitar usuario que reintroduzca sus datos. noción confiabilidad del sistema como propiedad que abarca disponibilidad, seguridad, fiabilidad protección, introdujo porque estas propiedades están estrecha-mente relacionadas. operación segura del sistema depende, por general, que éste halle disponible opere manera fiable. sistema volvería fiable cuando curioso corrompa sus datos. los ataques negación servicio sobre sistema tienen -.indd -.indd // :: // :: capítulo ■ conﬁ abilidad seguridad intención comprometer disponibilidad sistema. sistema infecta con virus, entonces estaría seguro fiabilidad protección, dado que virus podría cambiar comportamiento. por tanto, para desarrollar software confiable, necesario garantizar que: . evite entrada errores accidentales sistema durante especificación desarrollo del software. . diseñen procesos verificación validación que sean efectivos descubri-miento errores residuales que afecten confiabilidad del sistema. . desarrollen mecanismos protección contra ataques externos que comprometan disponibilidad seguridad del sistema. . configuren correctamente sistema utilizado software apoyo para entorno operacional. además, conviene suponer que software por general perfecto que pue-den ocurrirle fallas. por consiguiente, software debe incluir mecanismos recupera-ción que hagan posible restauración del servicio normal del sistema tan rápido como sea posible. necesidad para tolerar fallas significa que los sistemas confiables deben incluir código redundante que los ayude monitorizarse mismos, detectar estados erró-neos recuperarse las fallas desarrollo antes que ocurran fallas opera-ción. ello afecta rendimiento los sistemas, pues requiere verificación adicional cada vez que ejecuta sistema. por consiguiente, los diseñadores comúnmente deben negociar entre rendimiento confiabilidad. tal vez necesite dejar las com-probaciones del sistema porque éstas ralentizan. sin embargo, aquí consecuencia del riesgo que ocurran algunas fallas operación causa que detectó error. debido costos diseño, implementación validación adicionales, incrementa confiabilidad sistema aumentar significativamente los costos desarrollo. particular, los costos validación son altos para sistemas que deben ser ultracon-fiables, como los sistemas control críticos para protección. además validar que sistema cumpla con sus requerimientos, proceso validación debería ser probado por regulador externo para que sistema sea seguro. por ejemplo, los sistemas las aeronaves tienen que probar los reguladores, como federal aviation authority, que probabilidad una falla catastrófica del sistema, que afecte seguridad aero-nave, extremadamente baja. figura . muestra relación entre los costos las mejoras incrementales confiabilidad. software muy confiable, quizás obtenga mejoras considerables costos relativamente bajos usando mejor ingeniería software. sin embargo, usa buenas prácticas, los costos mejorar son mucho mayores aun cuando los bene-ficios dicha mejora sean modestos. también está problema probar software para demostrar que confiable. esto apoya ejecutar muchas pruebas observar número fallas que ocurren. conforme software vuelva más confiable, verá cada vez menos fallas. consecuencia, necesitan cada vez más pruebas para tratar eva-luar cuántos problemas permanecen software. como las pruebas son muy costosas, esto aumenta drásticamente costo los sistemas alta confiabilidad. -.indd -.indd // :: // :: . ■ disponibilidad abilidad . disponibilidad fiabilidad disponibilidad fiabilidad del sistema son propiedades estrechamente relacionadas que expresan también como probabilidades numéricas. disponibilidad sistema probabilidad que sistema funcionará ejecutará para entregar los usuarios sus servicios bajo pedido. fiabilidad sistema probabilidad que los servicios del sistema entregarán como definió especificación del sistema. , prome-dio, entradas cada , causan fallas, entonces fiabilidad, que expresa como una tasa ocurrencia falla .. disponibilidad ., esto significa que, durante cierto tiempo, sistema está disponible para .% ese tiempo. fiabilidad disponibilidad están estrechamente relacionadas, pero ocasiones una más importante que otra. los usuarios esperan sistema servicio continuo, sistema tal caso tiene alto requerimiento disponibilidad. debe estar disponible siempre que realice una demanda. sin embargo, son bajas las pérdidas que resultan una falla sistema éste recupera rápidamente, entonces las fallas afectan seriamente los usuarios del sistema. tales sistemas, los requerimientos fiabilidad suelen ser relativamente bajos. conmutador telefónico que enruta llamadas telefónicas ejemplo sistema donde disponibilidad más importante que fiabilidad. los usuarios esperan tono marcado cuando levantan auricular, así que sistema tiene altos requerimientos dis-ponibilidad. ocurre una falla del sistema mientras establece una conexión, esto con fre-cuencia rápidamente recuperable. los conmutadores por general restablecen sistema reintentan conexión. ello puede hacerse tan rápidamente que los usuarios del teléfono incluso quizá enteren que ocurrió una falla. más aún, una llamada incluso inte-rrumpe, las consecuencias regularmente son serias. por consiguiente, disponibilidad más que fiabilidad principal requerimiento confiabilidad para este tipo sistema. fiabilidad disponibilidad del sistema pueden definirse manera más precisa como sigue: . fiabilidad probabilidad operación libre falla durante cierto tiempo, entorno dado, para propósito específico. costo bajo medio alto muy altoexorbitante confiabilidadfigura . curva costo/confiabilidad -.indd -.indd // :: // :: capítulo ■ conﬁ abilidad seguridad . disponibilidad probabilidad que sistema, momento tiempo, sea operativo brinde los servicios solicitados. uno los problemas prácticos desarrollo sistemas fiables que las nociones intuitivas fiabilidad disponibilidad ocasiones son más amplias que estas defini-ciones limitadas. definición fiabilidad establece que deben tomarse cuenta tanto entorno donde usa sistema, como propósito para que utiliza. mide fiabilidad sistema entorno, puede suponer que ésta será misma sistema usa una forma diferente. por ejemplo, suponga que mide fiabilidad procesador texto entorno oficina, donde mayoría los usuarios interesan operación del software. ellos seguirán las instrucciones para uso, pero tratarán experimentar con sistema. luego mide fiabilidad del mismo sistema entorno universi-tario, entonces fiabilidad sería bastante diferente. aquí, quizá los estudiantes exploren las fronteras del sistema usen formas inesperadas, cual podría resultar fallas del sistema que ocurrirían ambiente más restringido oficina. estas definiciones estándar disponibilidad fiabilidad consideran severidad falla las consecuencias indisponibilidad. aun cuando las personas aceptan con frecuencia fallas menores del sistema, preocupan más por fallas serias que deri- ven altos costos. por ejemplo, son menos aceptables las fallas cómputo que corrompen datos almacenados, que las fallas que congelan máquina que resuelven reiniciar computadora. una definición estricta fiabilidad relaciona implementación del sistema con especificación. esto , sistema conduce manera fiable, comportamiento consistente con definido especificación. sin embargo, una causa común fali-bilidad percibida que especificación del sistema coincide con las expectativas los usuarios del sistema. por desgracia, muchas especificaciones están incompletas son incorrectas, deja los ingenieros software interpretar cómo debería comportarse sistema. como son expertos dominio, pueden implementar, por consiguiente, comportamiento que esperan los usuarios. desde luego, también cierto que los usua-rios leen las esp ecificaciones del sistema, manera que quizá tengan expectativas irreales del sistema. evidentemente, disponibilidad fiabilidad están vinculadas, pues las fallas del sistema pueden colapsar sistema. obstante, disponibilidad sólo depende del -mero caídas del sistema, sino también del tiempo necesario para reparar los compo-nentes que causaron falla. por ello, sistema falla una vez año sistema falla una vez mes, entonces todas luces más fiable que . sin embargo, suponga que sistema tarda tres días reiniciarse después una falla, mientras que sis-tema tarda sólo minutos reiniciar. disponibilidad del sistema durante año ( minutos tiempo muerto) mucho mejor que del sistema (, minutos tiempo muerto). alteración provocada por sistemas indisponibles refleja simple métrica disponibilidad que especifica porcentaje tiempo que sistema está dispo-nible. momento que falla sistema también significativo. sistema está disponible durante una hora cada día, entre las mañana, quizá afecte muchos usuarios. pero, mismo sistema está indisponible durante minutos largo del día laboral, indisponibilidad del sistema probablemente tendrá efecto mucho mayor. -.indd -.indd // :: // :: . ■ disponibilidad abilidad los problemas fiabilidad disponibilidad del sistema originan principalmente por caídas éste. algunas estas caídas sistema son una consecuencia errores especificación fallas otros sistemas relacionados, como sistema comunicación. pesar ello, muchas fallas operación son resultado del comportamiento erróneo del sistema que derivan fallas desarrollo del sistema. cuando discute fiabili-dad, útil usar terminología precisa distinguir entre los términos “falla desarrollo”, “error del sistema” “caída del sistema”. figura . definen dichos términos, cada definición ilustra con ejemplo estación meteorológica campo abierto. cuando una entrada una secuencia entradas provocan ejecución código defectuoso sistema, crea estado erróneo que podría conducir una falla operación del software. figura ., derivada littlewood (), muestra sistema software como mapeo conjunto entradas conjunto salidas. dada una entrada secuencia entradas, programa responde por producción una salida correspondiente. por ejemplo, dada una entrada una url, navegador web produce una salida que despliegue página web solicitada. mayoría las entradas conducen caídas del sistema. sin embargo, algunas entradas combinaciones entradas, que muestran elipse sombreada figura ., causan generación caídas del sistema salidas erróneas. fiabilidad del programa depende del número entradas del sistema que son miembros del con-junto entradas que conducen una salida errónea. las entradas conjunto ejecutan para usar regularmente partes del sistema, entonces las caídas serán frecuentes. obstante, las entradas efectúan por código que rara vez usa, entonces los usuarios difícilmente verán alguna vez las caídas. puesto que cada usuario sistema utiliza manera diferente, tienen diversas percepciones fiabilidad. las fallas desarrollo que afectan fiabilidad del sistema para usuario pueden nunca revelarse bajo modo trabajo alguien más (figura .). esta misma figura, conjunto entradas erróneas corresponde elipse marcada figura .. conjunto entradas producido por usuario interseca con este conjunto entradas erróneas. por tanto, usuario experimentafigura . terminología fiabilidadtérmino descripción error equivocación humanoel comportamiento humano que resulta introducción fallas desarrollo sistema. por ejemplo, estación meteorológica campo abierto, programador podría decidir que forma calcular hora para siguiente transmisión agregar una hora hora actual. esto funciona salvo cuando hora transmisión entre : medianoche (medianoche : reloj horas). falla desarrollo del sistemauna característica sistema software que puede conducir error del sistema. falla desarrollo inclusión del código para agregar una hora hora última transmisión, sin una verificación para saber hora mayor igual :. error del sistema estado erróneo del sistema que puede conducir comportamiento sistema que inesperado para los usuarios del mismo. valor hora transmisión establece manera incorrecta ( . vez .), cuando ejecuta código defectuoso. caída del sistema evento que ocurre algún punto del tiempo, cuando sistema entrega servicio como espera usuario. transmiten datos meteorológicos porque hora inválida. -.indd -.indd // :: // :: capítulo ■ conﬁ abilidad seguridad algunas caídas del sistema. sin embargo, usuario usuario nunca usan entradas del conjunto erróneo. para ellos, software siempre será fiable. fiabilidad práctica programa depende del número entradas que causan sali-das erróneas (caídas), durante uso normal del sistema por mayoría los usuarios. las fallas desarrollo software que sólo ocurren situaciones excepcionales tienen poco efecto práctico sobre fiabilidad del sistema. consecuencia, eliminar las fallas del software quizá mejore significativamente fiabilidad total del sistema. mills sus colaboradores () descubrieron que eliminar % los errores conocidos software llevó una mejoría del % fiabilidad. adams (), estudio pro-ductos software ibm, notó que muchos defectos los productos sólo era probable que causaran caídas después cientos miles meses uso del producto. las fallas desarrollo siempre derivan errores del sistema, los errores del sistema necesariamente originan caídas del sistema. las razones para esto son las siguientes: . todo código programa ejecuta. código que incluye una falla desarrollo (por ejemplo, equivocarse inicializar una variable) tal vez nunca ejecute debido forma que usa programa.conjunto salida salidas erróneasoeconjunto entrada programaentradas que causansalidas erróneas figura . sistema como mapeo entrada/salida posibles entradas usuario usuario erróneas figura . patrones uso software -.indd -.indd // :: // :: . ■ protección . los errores son transitorios. una variable estado puede tener valor incorrecto causado por ejecución código defectuoso. sin embargo, antes que acceda ésta origine una caída del sistema, factible procesar alguna otra entrada del sistema que restablezca estado valor válido. . sistema puede incluir mecanismos detección fallas protección, que aseguran que comportamiento erróneo descubra corrija antes que resulten afectados los servicios del sistema. otra razón por que las fallas sistema pueden conducir caídas del sistema que, práctica, los usuarios adaptan comportamiento para evitar uso entra-das que saben que causan caídas del programa. los usuarios experimentados “soslayan” las características software que descubren que son falibles. por ejemplo, autor evita ciertas características, tales como numeración automática sistema procesa-miento texto que usó para escribir este libro. cuando usaba autonumeración, ésta normalmente salía mal. reparación las fallas desarrollo las características sin usar muestra una diferencia práctica con fiabilidad del sistema. medida que los usuarios comparten información sobre problemas soluciones alternativas, redu-cen los efectos los problemas del software. distinción entre fallas desarrollo, errores caídas, que explica figura ., ayuda identificar tres enfoques complementarios usados para mejorar fiabilidad sistema: . prevención fallas desarrollo usan técnicas desarrollo que minimizan posibilidad los errores humanos / captan las equivocaciones antes que resulten fallas desarrollo del sistema. los ejemplos estas técnicas incluyen evitar códigos del lenguaje programación proclives error, como punteros uso análisis estático para descubrir anomalías del programa. . detección eliminación fallas desarrollo uso técnicas verifica-ción validación que incrementan las oportunidades que detecten eliminen las fallas desarrollo antes que use sistema. las pruebas depuración sistemáticas son ejemplo una técnica detección este tipo fallas. . tolerancia fallas desarrollo refiere las técnicas que aseguran que las fallas desarrollo sistema deriven errores del sistema que los erro-res del sistema deriven caídas del sistema. incorporación mecanismos autocomprobación sistema uso módulos sistema redundantes son ejemplos técnicas tolerancia fallas desarrollo. aplicación práctica estas técnicas trata capítulo , que examina las técnicas para ingeniería software confiable. . protección los sistemas críticos para protección son aquellos los que resulta esencial que operación del sistema sea segura todo momento; esto , sistema nunca debe dañar las personas entorno, incluso cuando falle. los ejemplos sistemas críticos para protección incluyen los sistemas control monitorización las aeronaves, los -.indd -.indd // :: // :: capítulo ■ conﬁ abilidad seguridad sistemas control procesos plantas químicas farmacéuticas, los sistemas control automotores. control hardware los sistemas críticos para protección más fácil implementar analizar que control del software. pesar ello, ahora construyen sistemas tal complejidad que pueden controlarse tan sólo con hardware. con-trol del software esencial debido necesidad manejar gran cantidad sensores actuadores con leyes control complejas. por ejemplo, una aeronave militar avanzada, aerodinámicamente inestable, requiere ajuste continuo, controlado por software, sus superficies vuelo para garantizar que desplome. software crítico para protección divide dos clases: . software primario crítico para protección éste software embebido que sirve como controlador sistema. mal funcionamiento tal software puede repe-tirse hardware, cual derivaría una lesión humana daño ambiental. soft-ware bomba insulina, que trató capítulo , ejemplo sistema primario crítico para protección. falla del sistema puede conducir una lesión usuario. . software secundario crítico para protección software que podría repercutir indirectamente una lesión. ejemplo dicho software consiste sistema diseño ingeniería auxiliado por computadora, cuyo mal funcionamiento ocasionaría error diseño objeto por desarrollar. esta equivocación quizá cauce una lesión los individuos, sistema diseñado funciona mal. otro ejemplo sis-tema secundario crítico para protección sistema administración atención salud mental, mhc-pms. falla este sistema cuando paciente inestable trata manera adecuada podría llevar que éste lesione mismo otros. fiabilidad protección del sistema relacionan, pero sistema fiable puede ser inseguro viceversa. software todavía suele comportarse tal forma que compor-tamiento resultante del sistema conduzca accidente. hay cuatro razones por las que los sistemas software que son fiables necesariamente son seguros: . nunca puede tener una total certeza que sistema software esté libre fallas desarrollo sea tolerante los mismos. las fallas desarrollo detectadas pueden estar inactivas durante mucho tiempo las fallas operación del software pueden ocurrir después muchos años operación infalible. . especificación podría estar incompleta cuanto que describe compor-tamiento requerido del sistema algunas situaciones críticas. alto porcentaje mal funcionamiento del sistema (boehm ., ; endres, ; lutz, ; nakajo kume, ) resultado errores especificación más que diseño. estudio errores sistemas embebidos, lutz concluye: . . . las dificultades con los requerimientos son clave principal los errores software que relacionan con seguridad, los cuales persisten hasta integración las pruebas del sistema. . mal funcionamiento del hardware origina que sistema comporte forma impredecible, presente software con entorno anticipado. cuando los com-ponentes hallan cerca falla física, éstos pueden comportarse manera errá-tica generar señales fuera los rangos para manejo del software. -.indd -.indd // :: // :: . ■ protección . los operadores del sistema pueden generar entradas que son individualmente incorrectas, pero que, ciertas situaciones, conducirían mal funcionamiento del sistema. ejemplo anecdótico esto sucedió cuando tren aterrizaje una aeronave colapsó mientras nave estaba tierra. parecer, técnico pre-sionó botón que ordenó software gestión utilidades elevar tren ate-rrizaje. software realizó instrucción del mecánico perfección. sin embargo, sistema debía desactivar comando menos que avión estuviera aire. vocabulario especializado evolucionó con finalidad discutir los sistemas crí-ticos para seguridad, así como para comprender importancia los términos especí-ficos utilizados. figura . resume algunas definiciones vocablos importantes, con ejemplos tomados del sistema bomba insulina. clave para garantizar seguridad consiste cerciorarse que ocurrirán accidentes que serán mínimas las consecuencias accidente. esto logrará mediante tres formas complementarias: . evitar peligro sistema está diseñado modo que eviten los riesgos. por ejemplo, sistema corte, donde requiera operador usar las dos manos figura . terminologíade seguridadtérmino definición accidente ( contratiempo) evento planeado secuencia eventos que derivan muerte lesión individuo, daño propiedad ambiente. una sobredosis insulina ejemplo accidente. peligro condición con potencial para causar contribuir accidente. ejemplo riesgo una falla del sensor que mide glucosa sanguínea. daño una medida pérdida que resulta contratiempo. daño puede variar desde hecho que muchas personas mueran como resultado accidente, hasta una lesión daño menor propiedad. daño, producto una sobredosis insulina, sería una lesión grave muerte del usuario que utiliza bomba insulina. severidad del peligro una valoración del peor daño posible que resultaría peligro particular. severidad del peligro puede ser desde catastrófico, cuando muchas personas mueren, hasta menor, cuando sólo ocurre daño mínimo. cuando muerte individuo una posibilidad, valoración razonable severidad del peligro “muy alta”. probabilidad del peligro probabilidad que ocurran eventos que causen peligro. los valores probabilidad tienden ser arbitrarios, pero varían “probable” (por ejemplo, / posibilidad que ocurra peligro) “improbable” ( son probables situaciones concebibles que pudiera ocurrir peligro). baja probabilidad que falla sensor bomba insulina como resultado una sobredosis. riesgo ésta una medida probabilidad que sistema causará accidente. riesgo valora considerar posibilidad, severidad verosimilitud que peligro conduzca accidente. riesgo una sobredosis insulina quizá medio bajo. -.indd -.indd // :: // :: capítulo ■ conﬁ abilidad seguridad para presionar simultáneamente dos botones separados, evita peligro que las manos del operador estén ruta las cuchillas. . detectar eliminar peligro sistema diseña modo que los peligros detecten eliminen antes que ocasionen accidente. por ejemplo, cuando sistema una planta química detecta presión excesiva abre una válvula des-carga para reducir presión antes que ocurra estallido. . limitar daño sistema puede incluir características protección que mini-micen daño que resulte accidente. por ejemplo, motor avión, por general, incluye extintores automáticos. ocurre incendio, generalmente suele controlar antes que represente una amenaza para aeronave. los accidentes ocurren con mayor frecuencia cuando muchas cosas salen mal mismo tiempo. análisis accidentes serios (perrow, ) indica que casi todos debieron una combinación fallas diferentes partes sistema. las combina-ciones anticipadas fallas subsistemas conducen interacciones que derivaron una falla global del sistema. por ejemplo, falla sistema aire acondicio-nado podría conducir sobrecalentamiento, que luego haría que hardware del sistema generara señales incorrectas. perrow también refiere que imposible anticipar todas las combinaciones posibles fallas. por tanto, los accidentes son parte inevitable del uso sistemas complejos. algunas personas usan esta explicación como argumento contra control del soft-ware. causa complejidad del software, existen más interacciones entre las diferen-tes partes sistema, cual significa que probablemente existirán más combinaciones fallas desarrollo que podrían conducir una falla operación del sistema. sin embargo, los sistemas controlados por software pueden monitorizar una varie-dad más amplia condiciones que los sistemas electromecánicos. pueden adaptarse manera relativamente sencilla. usan hardware que tiene fiabilidad inherente muy alta además físicamente pequeño ligero. los sistemas controlados por software ofrecen seguridad sofisticada entrelazada. soportan estrategias control que disminuyan can-tidad tiempo que necesitan emplear las personas ambientes peligrosos. aunque control por software puede introducir más formas las que sistema podría salir mal, también permite mejor monitorización protección , consecuencia, contribuirá mejoras seguridad del sistema. todos los casos, importante mantener sentido proporción sobre seguridad del sistema. imposible hacer sistema cien por ciento seguro, así que sociedad debe decidir las consecuencias accidente ocasional valen los beneficios que pro-vienen del uso tecnologías avanzadas. asimismo, una decisión social política sobre cómo implementar recursos nacionales limitados para reducir riesgo población. . seguridad seguridad atributo del sistema que refleja habilidad éste para protegerse mismo ataques externos, que podrían ser accidentales deliberados. estos ataques externos son posibles puesto que mayoría las computadoras propósito general -.indd -.indd // :: // :: . ■ seguridad ahora están red , consecuencia, son accesibles personas externas. ejemplos ataques pueden ser instalación virus caballos troya, uso sin autorización servicios del sistema modificación aprobada sistema sus datos. real mente quiere sistema seguro, mejor conectarlo internet. siendo así, sus problemas seguridad estarán limitados garantizar que usuarios autorizados abusen del sistema. sin embargo, práctica, existen enormes beneficios del acceso red para los sistemas más grandes, modo que desconectarlos internet efectivo costo. para algunos sistemas, seguridad dimensión más importante confiabili-dad del sistema. los sistemas militares, los comercio electrónico los que requieren procesamiento intercambio información confidencial deben diseñarse modo que logren alto nivel seguridad. por ejemplo, sistema reservaciones una aerolínea está disponible, causará inconvenientes ciertas demoras emisión boletos. sin embargo, sistema inseguro, entonces atacante podría borrar todos los libros sería prácticamente imposible que continuaran las operaciones normales aerolínea. igual que con otros aspectos confiabilidad, existe una terminología espe-cializada asociada con seguridad. algunos términos importantes, como los analiza pfleeger (pfleeger pfleeger, ), definen figura .. figura . incluye los conceptos seguridad descritos figura . muestra cómo relacionan con siguiente escenario extraído del mhc-pms: personal clínico ingresa mhc-pms con nombre usuario contra-seña. sistema requiere que las contraseñas sean menos ocho caracteres; sin embargo, permite sin mayor verificación establecimiento cualquier con-traseña. delincuente descubre que una figura deportiva bien pagada recibe tratamiento por problemas salud mental. gustaría conseguir acceso ilegal información este sistema, modo que pueda extorsionar estrella.figura . terminología seguridadtérmino definición activo algo valor que debe protegerse. activo sería sistema software los datos usados por dicho sistema. exposición posible pérdida daño sistema cómputo. esto sería pérdida daño los datos, bien, una pérdida tiempo esfuerzo necesaria recuperación después una violación seguridad. vulnerabilidad una debilidad sistema basado computadora que puede aprovecharse para causar pérdida daño. ataque aprovechamiento una vulnerabilidad del sistema. por general, desde afuera del sistema intento deliberado por causar cierto daño. amenaza circunstancias que tienen potencial para causar pérdida daño. puede pensar ellas como una vulnerabilidad sistema que está sujeta ataque. control medida protección que reduce vulnerabilidad sistema. encriptación ejemplo control que reduce vulnerabilidad sistema control acceso débil. -.indd -.indd // :: // :: capítulo ■ conﬁ abilidad seguridad pasar como pariente preocupado hablar con las enfermeras clínica salud mental, descubre cómo ingresar sistema información personal sobre las enfermeras. revisar listas, descubre los nombres algunas las perso-nas quienes permite acceso. entonces trata ingresar sistema con dichos nombres descifrar sistemáticamente posibles contraseñas (como nom-bres los hijos). cualquier sistema red, existen tres principales tipos amenazas seguridad: . amenazas confidencialidad del sistema sus datos pueden difundir infor- mación individuos programas que están autorizados tener acceso dicha información. . amenazas integridad del sistema sus datos tales amenazas pueden dañar corromper software sus datos. . amenazas disponibilidad del sistema sus datos dichas amenazas pueden restringir acceso software sus datos usuarios autorizados. desde luego, dichas amenazas son interdependientes. ataque provoca que sistema esté disponible, entonces podrá actualizar información que cambia con tiempo. esto significa que integridad del sistema puede estar comprometida; entonces, tal vez deba desmantelarse para reparar problema. por ello, reduce disponibilidad del sistema. práctica, mayoría las vulnerabilidades los sistemas sociotécnicos obe-decen fallas humanas más que problemas técnicos. las personas eligen contraseñas figura . ejemplos terminología seguridadtérmino definición activo los registros cada paciente que recibe recibió tratamiento. exposición potencial pérdida financiera futuros pacientes, quienes buscan tratamiento porque confían que clínica conserve sus datos. pérdida financiera por acción legal estrella deportiva. pérdida reputación. vulnerabilidad sistema contraseña débil que facilita los usuarios establecer contraseñas sencillas adivinar. identificaciones usuario que son iguales los nombres. ataque imitación usuario autorizado. amenaza usuario autorizado conseguirá acceso sistema descifrar las credenciales (nombre contraseña ingreso) usuario autorizado. control sistema comprobación contraseña que deshabilita las contraseñas usuario que sean nombres propios palabras que normalmente incluyan diccionario. -.indd -.indd // :: // :: . ■ seguridad fáciles descifrar escriben sus contraseñas lugares sencillos encontrar. los administradores sistemas cometen errores establecer control acceso archivos configuración, tanto que los usuarios instalan usan software protección. sin embargo, como estudió sección ., debe tener mucho cuidado cuando clasifique problema como error usuario. los problemas humanos reflejan con frecuencia malas decisiones diseño sistemas que requieren, por ejemplo, cam-bios contraseñas menudo ( modo que los usuarios escriben sus contraseñas) complejos mecanismos configuración. los controles que deben implementar para mejorar seguridad del sistema son comparables con los fiabilidad protección: . evitar vulnerabilidad controles cuya intención sea garantizar que los ataques tengan éxito. aquí, estrategia diseñar sistema modo que eviten los problemas seguridad. por ejemplo, los sistemas militares sensibles están -nectados redes públicas, forma que imposible acceso externo. también hay que pensar encriptación como control basado evitación. cualquier acceso autorizado datos encriptados significa que atacante puede leerlos. práctica, muy costoso consume mucho tiempo romper una encriptación fuerte. . detectar neutralizar ataques controles cuya intención sea detectar repeler ata-ques. dichos controles implican inclusión funcionalidad sistema que monitoriza operación verifica patrones actividad inusuales. detectan, entonces toman acciones, como desactivar partes del sistema, restringir acceso ciertos usuarios, etcétera. . limitar exposición recuperación controles que soportan recuperación los problemas. éstos varían desde estrategias respaldo automatizadas “réplica” información, hasta pólizas seguros que cubran los costos asociados con ataque exitoso sistema. sin nivel razonable seguridad, puede confiar disponibilidad, fiabili-dad protección sistema. los métodos para certificar disponibilidad, fiabilidad seguridad suponen que software operación mismo que software que ins-taló originalmente. sistema atacado software compromete alguna forma (por ejemplo, software modifica incluir gusano), entonces son insosteni-bles los argumentos fiabilidad protección. los errores desarrollo sistema pueden conducir lagunas seguridad. sistema responde entradas inesperadas verifican los límites vectoriales, entonces los atacantes aprovecharían tales debilidades para conseguir acceso sistema. los principales incidentes seguridad, como gusano internet original (spafford, ) gusano code red más años después (berghel, ) sacaron ventaja misma vulnerabilidad. los programas # incluyen comprobación límites vectoriales, manera que posible sobrescribir parte memoria con código que permita acceso autorizado sistema. -.indd -.indd // :: // :: capítulo ■ conﬁ abilidad seguridad puntos clave ■ las fallas los sistemas cómputo críticos pueden conducir grandes pérdidas económicas, pérdidas serias información, daño físico amenazas vida humana. ■ confiabilidad sistema cómputo una propiedad del sistema que refleja grado confianza del usuario sistema. las dimensiones más importantes confiabilidad son disponibilidad, fiabilidad, protección seguridad. ■ disponibilidad sistema probabilidad que sistema entregará los servicios sus usuarios cuando soliciten. fiabilidad probabilidad que los servicios del sistema entregarán como especificó. ■ fiabilidad percibida relaciona con probabilidad que uso operacional ocurra error. programa puede contener fallas desarrollo conocidas, pero aun así percibirse como fiable por parte sus usuarios. tal vez nunca usen características del sistema que sean afectadas por las fallas desarrollo. ■ protección sistema atributo que refleja habilidad mismo para ejecutar, normal anormalmente, sin lesionar los individuos dañar ambiente. ■ seguridad refleja habilidad sistema para protegerse mismo contra ataques externos. las fallas seguridad pueden conducir pérdidas disponibilidad, daño sistema sus datos, bien, fuga información personas autorizadas. ■ sin nivel razonable seguridad, disponibilidad, fiabilidad protección del sistema estarían comprometidas ataques externos dañan sistema. sistema fiable, difícil garantizar protección seguridad del sistema, que comprometería por fallas del sistema. lecturas sugeridas “the evolution information assurance”. excelente artículo que analiza necesidad proteger, contra accidentes ataques, información crítica una organización. (. cummings, ieee computer, (), diciembre .) http:/ /. doi. org/ . / . . . “designing safety critical computer systems”. una buena introducción campo los sistemas críticos para protección, que analiza los conceptos fundamentales peligros riesgos. más accesible que libro dunn sobre sistemas críticos para protección. (. . dunn, ieee computer, (), noviembre .) http:/ /. doi. org/ . / . . . secrets and lies: digital security networked world . excelente libro, muy comprensible, acerca seguridad computadoras, que examina tema desde enfoque sociotécnico. también son muy atractivas las columnas schneier relación con los conflictos seguridad general (url siguiente). (. schneier, john wiley & sons, .)http:/ /www. schneier. com/ essays. html. capítulo ■ conﬁ abilidad seguridad -.indd -.indd // :: // :: . ■ propiedades conﬁ abilidad ejercicios .. sugiera seis razones por las que confiabilidad del software importante mayoría los sistemas sociotécnicos. .. ¿cuáles son las dimensiones más significativas confiabilidad sistema? .. ¿por qué los costos para garantizar confiabilidad aumentan exponencialmente conforme incrementan los requerimientos fiabilidad? .. ofrezca razones para respuesta sugiera cuáles atributos confiabilidad probable que sean más críticos para los siguientes sistemas: servidor internet proporcionado por isp con miles clientes bisturí controlado por computadora usado cirugía laparoscópica sistema control direccional usado vehículo lanzamiento satélites sistema administración financiera personal basado internet .. identifique seis productos consumo que sea probable que estén controlados mediante sistemas software críticos para protección. .. fiabilidad protección son atributos confiabilidad relacionados, pero distintos. describa diferencia más importante entre dichos atributos explique por qué posible que sistema fiable sea inseguro, viceversa. .. sistema médico que diseña para emitir radiación tratamiento tumores, sugiera riesgo potencial proponga una característica software que sirva para garantizar que peligro identificado origine accidente. .. términos seguridad computadoras, explique las diferencias entre ataque una amenaza. .. con mhc-pms como ejemplo, identifique tres amenazas este sistema (además las mostradas figura .). sugiera controles que puedan aplicarse para reducir las posibilidades ataque exitoso con base dichas amenazas. .. una organización que aboga por los derechos las víctimas tortura pone contacto con usted, como experto seguridad computacional, solicita ayuda para conseguir acceso autorizado los sistemas cómputo una compañía estadounidense. esto los ayudará confirmar negar que esta compañía vende equipo que usa directamente tortura prisioneros políticos. discuta los dilemas éticos que plantean esta petición cómo reaccionaría ante misma.capítulo ■ ejercicios -.indd -.indd // :: // :: capítulo ■ conﬁ abilidad seguridad referencias adams, . . (). “optimizing preventative service software products”. ibm . res & dev., (), –. berghel, . (). “the code red worm”. comm. acm, (), –.boehm, . ., mcclean, . . urfig, . . (). “some experience with automated aids the design large-scale reliable software”. ieee trans. software engineering., - (), –. ellison, ., linger, ., lipson, ., mead, . moore, . (). “foundations survivable systems engineering”. crosstalk: the journal defense software engineering , , –. ellison, . ., fisher, . ., linger, . ., lipson, . ., longstaff, . . mead, . . (). “survivability: protecting your critical systems”. ieee internet computing, (), –. ellison, . ., linger, . ., longstaff, . mead, . . (). “survivable network system analysis: case study”. ieee software, (), –. endres, . (). “ analysis errors and their causes system programs”. ieee trans. software engineering., - (), –.laprie, .-. (). “dependable computing: concepts, limits, challenges”. ftcs- : ieee symposium fault-tolerant computing, pasadena, calif.: ieee press. littlewood, . (). “software reliability growth models”. software reliability handbook. rook, . (.). amsterdam: elsevier. –.lutz, . . (). “analysing software requirements errors safety-critical embedded systems”. ’, san diego, calif: ieee. mills, . ., dyer, . linger, . (). “cleanroom software engineering”. ieee software, (), –.nakajo, . kume, . (). “ case history analysis software error-cause relationships”. ieee trans. software eng., (), –. perrow, . (). normal accidents: living with high-risk technology . nueva york: basic books. pfleeger, . . pfleeger, . . (). security computing, edition. boston: addison-wesley.spafford, . (). “the internet worm: crisis and aftermath”. comm. acm, (), –. capítulo ■ conﬁ abilidad seguridad -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo conocer cómo especifican los requerimientos confiabilidad seguridad funcionales funcionales. estudiar este capítulo: ■ comprenderá cómo usar enfoque dirigido por riesgos para identificar analizar los requerimientos protección, fiabilidad seguridad; ■ entenderá cómo utilizar los árboles fallas para ayudar analizar riesgos derivar requerimientos seguridad; ■ introducirá las métricas para especificación fiabilidad cómo usan éstas para especificar los requerimientos fiabilidad mensurables; ■ identificará los diferentes tipos requerimientos seguridad que requieren sistema complejo; ■ conocerá las ventajas las desventajas usar las especificaciones matemáticas formales sistema. contenido . especificación requerimientos dirigida por riesgos . especificación protección . especificación fiabilidad . especificación seguridad . especificación formal especificación confiabilidad seguridad -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad septiembre , avión aterrizó aeropuerto varsovia, polonia, medio una tormenta. durante nueve segundos, después del aterrizaje, funcionaron los frenos sistema frenado controlado por computadora. sistema frenado reconoció que avión había aterrizado operó como aeronave aún estuviera aire. una característica seguridad aeronave detuvo despliegue del sistema empuje inverso, que desacelera aeronave, cual muy peligroso cuando avión encuentra aire. avión salió por extremo pista, golpeó banco tierra incendió. investigación del accidente demostró que software del sistema frenado operó según especificación. por tanto, había errores programa. sin embargo, especificación del software estaba incompleta consideró una situación extraña, que surgió este caso. software funcionó, pero sistema falló. esto demuestra que confiabilidad del sistema sólo depende buena ingeniería, sino también requiere atención los detalles cuando derivan los requerimientos del sistema inclusión requerimientos especiales software que ajustan para garantizar confiabilidad seguridad sistema. estos requerimientos confiabili-dad seguridad son dos tipos: . requerimientos funcionales, definen mecanismos comprobación recuperación que deben incluirse sistema las características que ofrecen protección contra fallas sistema ataques externos. . requerimientos funcionales, definen confiabilidad disponibilidad requeridas del sistema. punto partida para generar requerimientos funcionales confiabilidad segu-ridad con frecuencia conjunto reglas, políticas regulaciones empresariales dominio alto nivel. trata requerimientos alto nivel que tal vez describen mejor como requerimientos “ debe”. contraste con los requerimientos funcionales normales que delimitan conducta del sistema, los requerimientos “ debe” definen comportamiento del sistema que inaceptable. ejemplos requerimientos “ debe” son: “ sistema debe permitir que los usuarios modifiquen los permisos acceso sobre algún archivo que hayan creado” (seguridad). “ sistema debe permitir selección del modo empuje inverso cuando aero- nave está vuelo” (protección). “ sistema debe permitir activación simultánea más tres señales alarma” (protección). estos requerimientos “ debe” pueden implementarse directamente, sino que tie-nen que descomponerse requerimientos funcionales software más específicos, bien, aplicarse través decisiones diseño sistema, como una decisión para usar tipos particulares equipo sistema. -.indd -.indd // :: // :: . ■ especificación requerimientos dirigida por riesgos . especificación requerimientos dirigida por riesgos los requerimientos confiabilidad seguridad pueden considerarse como requerimien- tos protección. especifican cómo sistema debe protegerse mismo fallas inter-nas, detener fallas sistema que causen daño entorno, contener los accidentes ataques del entorno que dañen sistema, así como facilitar recuperación caso falla. para descubrir tales requerimientos protección, necesario entender los riesgos sistema entorno. enfoque dirigido por riesgos para especificación requeri-mientos toma cuenta los eventos peligrosos que pudieran ocurrir, probabilidad que realmente sucedan, posibilidad que daño derivará tal evento grado del daño causado. tal caso, pueden establecerse requerimientos seguridad confiabilidad, con base análisis posibles causas eventos peligrosos. especificación dirigida por riesgos enfoque que usan ampliamente los desa-rrolladores sistemas protección los sistemas críticos seguridad. dirigen aquellos eventos que podrían causar más daño que quizás ocurran con frecuencia. posible ignorar aquellos eventos que tienen sólo consecuencias menores que son considerablemente inusuales. los sistemas protección críticos, los riesgos aso-cian con peligros que podrían derivar accidentes; los sistemas críticos para seguridad, los riesgos provienen ataques internos externos sobre sistema cuya intención aprovechar las posibles vulnerabilidades. proceso general especificación dirigida por riesgos (figura .) incluye com-prensión riesgos que enfrenta sistema, descubrimiento sus causas raíz gene-ración requerimientos para gestionar dichos riesgos. las etapas este proceso son: . identificación del riesgo identifican los riesgos potenciales sistema. éstos dependen del entorno que usa sistema. pueden surgir riesgos interac-ciones entre sistema las condiciones extrañas entorno operacional. accidente varsovia descrito anteriormente ocurrió cuando vientos cruzados gene-rados durante una tormenta produjeron (inusualmente) que avión inclinara modo que aterrizó sobre una rueda lugar dos. . análisis clasificación del riesgo cada riesgo considera por separado. aquéllos potencialmente serios improbables seleccionan para mayor análisis. valoración del riesgorequerimientos confiabilidadanálisis causa raízdescripción del riesgoidentificación del riesgoanálisis del riesgodescomposición del riesgoreducción del riesgo figura . especificación dirigida por riesgos -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad esta etapa, los riesgos pueden eliminarse porque improbable que surjan porque pueden detectar con software (por ejemplo, una reacción alérgica sensor sistema bomba insulina). . descomposición del riesgo cada riesgo analiza para descubrir las causas raíz potenciales dicho riesgo. dichas causas son las razones por las que posible que falle sistema. pueden ser errores software, hardware vulnerabilidades inherentes que son consecuencia decisiones diseño del sistema. . reducción del riesgo hacen proposiciones formas para reducir eliminar los riesgos identificados. ello contribuye con los requerimientos confiabilidad del sistema que definen las defensas contra riesgo cómo manejará éste. para sistemas grandes, análisis riesgo puede estructurarse fases (leveson, ), donde cada fase considera diferentes tipos riesgos: . análisis preliminar del riesgo, que identifican los principales riesgos del entorno del sistema. tales análisis son independientes tecnología utilizada para desarrollo del sistema. meta del análisis preliminar del riesgo desarrollo conjunto inicial requerimientos seguridad confiabilidad para sis-tema. . análisis riesgo ciclo vida, que tiene lugar durante desarrollo del sistema dirige principalmente los riesgos surgidos por decisiones diseño del sis-tema. diferentes tecnologías arquitecturas sistema contienen sus propios ries-gos asociados. esta etapa, deben extender los requerimientos para protegerse contra estos riesgos. . análisis riesgo operativo, cual preocupa por interfaz usuario del sis-tema los riesgos error del operador. nuevo, una vez que toman las deci-siones sobre diseño interfaz del usuario, posible que deban agregarse más requerimientos protección. estas fases son necesarias porque imposible tomar todas las decisiones confiabi-lidad seguridad sin información completa implementación del sistema. los reque-rimientos seguridad confiabilidad particular ven afectados por elección tecnología las decisiones diseño. tienen que incluirse comprobaciones del sis-tema para garantizar que los componentes terceras partes operen manera correcta. los requerimientos seguridad tal vez deban modificarse entrar conflicto con las características seguridad que brinda sistema comercial. por ejemplo, requerimiento seguridad sería que los usuarios deban identificarse frente sistema mediante una frase paso (passphrase) vez una contraseña palabra paso (password). las passphrases consideran más seguras que las pass-words. son más difíciles descifrar por atacante descubrir través sistema automatizado rompimiento contraseñas. sin embargo, toma una decisión usar sistema existente que sólo soporte autenticación basada password, tal caso puede sostenerse este requerimiento seguridad. entonces sería necesario incluir funcionalidad adicional sistema, con finalidad compensar los riesgos crecien-tes usar passwords lugar passphrases. -.indd -.indd // :: // :: . ■ especificación protección . especificación protección los sistemas críticos protección, las fallas llegan afectar entorno del sistema causar lesiones muerte los individuos este ambiente. preocupación principal especificación protección identificar los requerimientos que reducirán pro-babilidad que ocurran tales fallas sistema. los requerimientos protección son básicamente requerimientos seguridad interesan por operación normal del sistema. podrían especificar que sistema debe desactivarse modo que conserve protección. por tanto, derivar requerimientos protección, necesita encontrar equilibrio aceptable entre seguridad funcionalidad para evitar sobreprotección. hay razón para construir sistema altamente seguro resulta efectivo cuanto costo. según discusión capítulo , los sistemas críticos protección usan una terminología especializada, que peligro algo que podría (aunque necesa-riamente) derivar muerte lesión una persona, riesgo probabilidad que sistema entre estado peligroso. por consiguiente, especificación protección enfoca usualmente los riesgos que surgen una situación dada, los eventos que conducen dichos peligros. las actividades proceso especificación general basado riesgos, mostrado figura ., mapean proceso especificación protección del siguiente modo: . identificación del riesgo especificación protección, éste proceso identificación del peligro que identifica los riesgos que amenazarían sistema. . análisis riesgo proceso valoración del peligro que permite determinar qué riesgos son los más peligrosos / los que tienen mayor probabilidad ocurrir. éstos deben priorizarse derivar los requerimientos protección. . descomposición del riesgo este proceso enfoca descubrimiento los eventos que quizá conduzcan que ocurra peligro. especificación pro-tección, proceso conoce como análisis peligro. . reducción del riesgo este proceso basa resultado del análisis del peligro lleva identificación requerimientos protección. puede inclinar por aseguramiento que surja peligro conduzca accidente que, ocurre, daño asociado sea mínimo. estándar iec para manejo protección iec (comisión electrotécnica internacional) definió estándar para manejo seguridad los sistemas protección ( decir, sistemas que tienen intención activar salvaguardias cuando surge alguna situación peligrosa). ejemplo sistema protección aquel que detiene automáticamente tren pasa por una señal roja. este estándar incluye guías extensas acerca del proceso especificación seguridad. http:// -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad .. identificación peligro los sistemas críticos protección, los riesgos principales provienen los peligros que conducirían accidente. posible tratar problema identificación del riesgo considerar los diferentes tipos, como los físicos, eléctricos, biológicos, radiación, falla servicio, etcétera. entonces, cada una estas clases puede analizarse para descubrir peligros específicos que podrían ocurrir. también deben identificarse aquellas posibles combinaciones riesgos que sean potencialmente peligrosas. sistema bomba insulina usado como ejemplo capítulos anteriores sistema crítico protección, porque falla ocasionaría usuario del sistema lesiones incluso muerte. los accidentes que posiblemente ocurran cuando usa esta máquina incluyen que usuario sufra las consecuencias largo plazo inadecuado control azúcar sangre (problemas oculares, cardiacos renales); disfunción cognitiva como resultado bajos niveles azúcar sangre; aparición algunas otras condiciones médicas, como una reacción alérgica. algunos los peligros sistema bomba insulina son:  cálculo sobredosis insulina (falla servicio);  cálculo subdosis insulina (falla servicio); falla del sistema monitorización del hardware (falla servicio); falla energía debido batería baja (eléctrico); interferencia eléctrica con otro equipo médico como marcapasos cardiaco (eléc- trico);  mal contacto entre sensor accionador causado por ajuste incorrecto (físico); partes máquina que rompen cuerpo del paciente (físico); infección provocada por introducción máquina (biológico); reacción alérgica los materiales insulina usada máquina (biológico). los ingenieros experimentados, que trabajan con expertos dominio consejeros seguridad profesional, identifican los peligros partir experiencia desde aná-lisis del dominio aplicación. pueden utilizarse técnicas trabajo grupal, como lluvia ideas, donde grupo individuos intercambian ideas. para sistema bomba insulina, las personas que intervendrían incluyen médicos, físicos médicos ingenieros diseñadores software. los peligros relacionados con software relacionan con frecuencia con las fallas para entregar servicio sistema, con las fallas los sistemas monitorización protec-ción. los sistemas monitorización protección incluyen dispositivo para detec-tar condiciones, como niveles bajos batería, que conducirían una falla del dispositivo. .. valoración del peligro proceso valoración del peligro enfoca comprender probabilidad que sobrevenga peligro las consecuencias que ocurriera accidente incidente aso-ciado con dicho peligro. necesario hacer este análisis para comprender peligro -.indd -.indd // :: // :: . ■ especificación protección constituye una seria amenaza sistema entorno. análisis proporciona también una base para decidir sobre cómo manejar riesgo asociado. para cada peligro, resultado del proceso análisis clasificación enunciado aceptabilidad. esto expresa términos riesgo, donde riesgo considera pro-babilidad accidente sus consecuencias. existen tres categorías que utilizan valoración del riesgo: . los riesgos intolerables los sistemas críticos protección son aquellos que ame- nazan vida humana. sistema debe diseñarse forma que tales peligros puedan surgir , caso, las características del sistema garantizarán que éstos detectan antes que produzca accidente. cuanto bomba insulina, riesgo intolerable que suministre una sobredosis. . los riesgos “tan bajos como sea razonablemente práctico” (alarp, por las siglas low reasonably practical) son aquellos que tienen consecuencias menos serias que, aun cuando son graves, tienen una muy baja probabilidad ocurren-cia. sistema debe diseñarse modo que minimice posibilidad que suscite accidente debido peligro, sujeto otras consideraciones tales como costo entrega. riesgo alarp para una bomba insulina sería falla del sistema monitorización del hardware. las consecuencias esto son, peor contexto, una subdosis insulina corto plazo. aunque ésta una situación que conduciría grave accidente. . los riesgos aceptables son aquellos que los accidentes asociados derivan por general daño menor. los diseñadores del sistema deben dar todos los pasos nece-sarios para reducir los riesgos “aceptables”, tanto esto aumente los costos, tiempo entrega otros atributos funcionales del sistema. riesgo aceptable caso bomba insulina puede ser una reacción alérgica que presente usuario. con frecuencia, esto sólo causa irritación menor piel. valdría pena usar materiales especiales más costosos dispositivo para reducir tal riesgo. figura . (brazendale bell, ), desarrollada para sistemas críticos seguri-dad, muestra estas tres regiones. forma del diagrama refleja los costos para garantizarregión inaceptable puede tolerarse riesgo riesgo tolerado sólo reducción del riesgo prácticao excesivamente costosa regiónaceptable riesgo despreciableregión alarp figura . triángulo riesgo -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad peligro identificado probabilidad del riesgoseveridad del accidenteriesgo estimado aceptabilidad . cálculo sobredosis insulinamedia alta alto intolerable . cálculo subdosis insulinamedia baja bajo aceptable . falla del sistema monitorización del hardwaremedia media bajo alarp . falla energía alta baja bajo aceptable . máquina ajustada incorrectamentealta alta alto intolerable . máquina que descompone pacientebaja alta medio alarp . máquina que causa infección media media medio alarp . interferencia eléctrica baja alta medio alarp . reacción alérgica baja baja bajo aceptable que los riesgos deriven incidentes accidentes. costo del diseño del sistema para lidiar con riesgo indica mediante ancho del triángulo. los costos más altos generan por los riesgos parte superior del diagrama, los costos más bajos, por los riesgos vértice del triángulo. las fronteras entre las regiones figura . son técnicas, sino más bien depen-den factores sociales políticos. con tiempo, sociedad vuelto más reacia riesgo, modo que las fronteras han recorrido hacia abajo. aunque los costos financieros aceptar riesgos pagar por cualquier accidente que resulte podrían ser menores que los prevención accidentes, opinión pública preferiría que gaste dinero para reducir probabilidad accidente sistema , por tanto, incurre costos adicionales. por ejemplo, sería más barato que una compañía limpie contaminación que ocurra alguna muy rara ocasión, vez instalar sistemas para prevenir contaminación. sin embargo, virtud que público prensa tolerarán tales accidentes, aceptable reparar daño vez prevenir accidente. tales eventos conducirían también una reclasificación del riesgo. por ejemplo, los riesgos que consideraban improbables ( por ello región alarp) reclasificarían como intolerables debido eventos, como los ataques terroristas los accidentes que han ocurrido. valoración del peligro implica estimar probabilidad del peligro severidad del riesgo. por general esto difícil, pues los peligros los accidentes son inusuales, modo que los ingenieros implicados quizá tengan experiencia directa incidentes accidentes previos. las probabilidades severidades asignan mediante términos relativos como “probable”, “improbable”, “raro” “alto”, “medio” “bajo”. sólo posible cuantificar estos términos para análisis estadístico está disponible suficiente información los accidentes incidentes.figura . clasificación del riesgo para bomba insulina -.indd -.indd // :: // :: . ■ especificación protección figura . muestra una clasificación riesgo sobre los peligros identificados sección previa para sistema entrega insulina. los peligros que relacionan con cálculo incorrecto insulina separaron sobredosis subdosis insulina. una sobredosis insulina potencialmente más grave que una subdosis insulina corto plazo. sobredosis insulina podría derivar disfunción cognitiva, coma , final cuentas, muerte. subdosis insulina conduce altos niveles azúcar sangre. corto plazo, causa fatiga, pero sus consecuencias son muy graves; sin embargo, largo plazo, conduciría severos problemas cardiacos, renales oculares. los peligros figura . relacionan con software; sin embargo, éste desempeña papel detección peligros. software que monitoriza hardware debe monitorizar estado del sistema advertir acerca problemas potenciales. con frecuencia, las advertencias permitirán detección del peligro antes que ocurra accidente. los ejemplos peligros que pueden detectarse son falla energía, que descubre monitorizar batería, ubicación incorrecta máquina, que suele detectarse monitorizar señales del sensor azúcar sangre. desde luego, software monitorización sistema relaciona con protec-ción. falla para detectar peligro podría derivar accidente. sistema monitorización falla, pero hardware funciona manera correcta, entonces ésta una falla grave. obstante, sistema monitorización falla , consecuencia, falla del hardware detecta, esto tendría consecuencias más drásticas. .. análisis del peligro análisis del peligro proceso que descubre las causas raíz los peligros sistema protección crítico. meta detectar qué eventos combinaciones even-tos causarían una falla sistema que derive peligro. para hacerlo, puede usar enfoque descendente uno ascendente. las técnicas deductivas descendentes, que tienden ser más fáciles usar, comienzan con peligro trabajan con éste hasta posible falla sistema. las técnicas inductivas ascendentes comienzan con una falla sistema propuesta identifican qué peligros resultarían por dicha falla. han planteado varias técnicas como posibles enfoques para descomposición análisis del peligro, las cuales resume storey (). incluyen revisiones listas veri-ficación, técnicas formales como análisis red petri (peterson, ), lógica for-mal (jahanian mok, ) análisis árbol fallas (leveson stolzy, ; storey, ). como tiene espacio para estudiar aquí todas esas técnicas, examinará enfoque ampliamente usado para análisis peligro basado árboles fallas. esta técnica bastante sencilla entender sin conocimiento especializado del dominio. para hacer análisis árbol fallas, comience con los peligros identificados. para cada peligro puede trabajar entonces retroceso, con finalidad descubrir las posi-bles causas dicho peligro. coloque peligro raíz del árbol identifique los esta-dos del sistema que podrían conducir tal peligro. para cada uno dichos estados, posible identificar entonces más estados sistema que conduzcan hacia ellos. continúe con esta descomposición hasta que llegue las causas raíz del riesgo. los peligros que sólo pueden surgir partir una combinación causas raíz son, por general, menos probables conducir accidente, que aquellos peligros con una sola causa raíz. figura . árbol fallas sobre los peligros relacionados con software sistema entrega insulina que podrían llevar administrar una dosis incorrecta insulina. este caso, fusionaron subdosis insulina sobredosis insulina -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad solo peligro: “administración dosis incorrecta insulina”. esto reduce número árboles fallas requeridos. desde luego, cuando especifica cómo debe reac-cionar software ante este peligro, debe distinguir entre una subdosis una sobredosis insulina. como comentó, son igualmente graves: corto plazo, una sobredosis peligro más severo. figura . observa que: . hay tres condiciones que podrían conducir administración una dosis inco- rrecta insulina. nivel azúcar sangre pudo medirse manera incorrec-, modo que requerimiento insulina calculó con una entrada errónea. sistema entrega quizá responda acertadamente los comandos que especifican cantidad insulina inyectada. bien, dosis puede calcularse manera correcta, pero ésta entrega muy pronto demasiado tarde. . rama izquierda del árbol fallas, que ocupa medición incorrecta del nivel azúcar sangre, busca cómo podría ocurrir esto. ello sucedería porque figura . ejemplo árbol fallasmedición incorrecta del nivel azúcaradministración dosis incorrecta insulina dosis correcta entregada tiempo equivocado falla del sensoro error cálculo del azúcarfalla del cronómetroseñales bomba incorrectaso cálculo incorrecto insulinafalla del sistema entrega error aritméticoo error algoritmoerror aritméticoo error algoritmo -.indd -.indd // :: // :: . ■ especificación protección falló sensor que proporciona una entrada para calcular nivel azúcar, porque realizó manera incorrecta cálculo del nivel azúcar sangre. nivel azúcar calcula partir medición cierto parámetro, como conducti-vidad piel. cálculo incorrecto podría derivar algoritmo incorrecto error aritmético producto del uso números con punto flotante. . rama central del árbol interesa por los problemas temporización concluye que éstos sólo pueden resultar falla del cronómetro del sistema. . rama derecha del árbol, que inclina por falla del sistema entrega, exa-mina posibles causas esta falla. esto surgiría cálculo incorrecto del reque-rimiento insulina, bien, una falla enviar las señales correctas bomba que entrega insulina. nuevo, cálculo inexacto puede provocar una falla algoritmo errores aritméticos. los árboles fallas usan también para identificar problemas potenciales hard-ware. los árboles fallas hardware pueden brindar comprensión los requerimien-tos para que software detecte , quizá, corrija dichos problemas. por ejemplo, las dosis insulina administran una frecuencia muy alta, más dos tres veces por hora , ocasiones, con menos periodicidad que esto. por consiguiente, capacidad del procesador está disponible para operar programas diagnóstico autoverificación. quizá descubran errores hardware, como los sensor, bomba cronómetro, emitirse advertencias antes que tengan grave efecto sobre paciente. .. reducción del riesgo una vez identificados los riesgos potenciales sus causas raíz, entonces podrán deri-var requerimientos seguridad que administren los riesgos garanticen que ocurran los incidentes accidentes. existen tres posibles estrategias por utilizar: . evitar peligro sistema diseña modo que pueda ocurrir peligro. . detectar eliminar peligro sistema diseña forma que los peligros detecten neutralicen antes que suceda accidente. . limitar daño sistema diseña manera que minimicen las consecuen- cias accidente. normalmente, los diseñadores sistemas críticos combinan dichos enfoques. sistema crítico seguridad, los peligros intolerables pueden manejarse disminuir probabilidad agregar sistema protección que brinde respaldo seguridad. por ejemplo, sistema control planta química, sistema tratará detectar evitar una presión excesiva reactor. sin embargo, también podría haber sistema protección independiente que monitorice presión abra una válvula desfogue alivio detectarse presión alta. sistema entrega insulina, “estado seguro” uno desactivado, donde inyecta insulina. durante breve periodo, amenaza salud del diabético. -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad : sistema debe entregar una dosis individual insulina mayor que una dosis máxima especificada para usuario del sistema. : sistema debe entregar una dosis diaria almacenada insulina mayor que una dosis diaria máxima especificada para usuario del sistema. : sistema debe incluir una instalación diagnóstico hardware que tiene que ejecutarse menos cuatro veces por hora. : sistema debe incluir manipulador excepción para todas las excepciones que identifiquen tabla . : alarma audible tiene que activarse cuando descubra cualquier anomalía hardware software, hay que desplegar mensaje diagnóstico, como define tabla . : caso una alarma, entrega insulina debe suspenderse hasta que usuario reestablezca sistema desactive las alarmas. caso las fallas del software que pudieran conducir una dosis incorrecta insulina, consideran las siguientes posibles “soluciones”: . error aritmético éste puede ocurrir cuando cálculo aritmético causa una falla representación. especificación tiene que identificar todos los posibles errores aritméticos que ocurrirían, informar que debe incluirse manipulador excep-ción para cada posible error. especificación tiene que establecer acción tomar cada uno dichos errores. acción seguridad predeterminada desactivar sistema entrega activar una alarma advertencia. . error algorítmico ésta una situación más difícil, pues hay una clara excep-ción del programa que deba manejarse. podría detectarse este tipo error com-parar dosis insulina requerida calculada con dosis entregada anteriormente. mucho mayor, esto significaría que cantidad calculó forma incorrecta. sistema también puede hacer seguimiento secuencia dosis. después entrega algunas dosis por arriba del promedio, tiene que emitirse una adverten-cia limitarse las dosis posteriores. figura . muestran algunos los requerimientos seguridad que resul-tan para software bomba insulina. trata requerimientos usuarios , por supuesto, expresarían con más detalle especificación requerimientos del sis-tema. misma figura, las referencias las tablas , que muestran aquí, relacionan con las tablas incluidas documento requerimientos. . especificación fiabilidad como estudió capítulo , fiabilidad global sistema depende fiabilidad del hardware, fiabilidad del software fiabilidad los operadores del sistema. debe tomar cuenta software del sistema , además, incluir requeri-figura . ejemplos requerimientos seguridad -.indd -.indd // :: // :: . ■ especificación fiabilidad mientos que compensen falla software. también puede haber requerimientos rela- cionados fiabilidad para ayudar detectar recuperar fallas hardware errores del operador. fiabilidad diferente seguridad protección, pues considera atri-buto mensurable del sistema. esto , puede especificar comprobar logró fiabilidad requerida. por ejemplo, requerimiento fiabilidad sería que las fallas sistema que requieran reinicio (reboot) deben ocurrir más una vez por semana. cuando tal falla presenta, conviene anotarlo una bitácora comprobar logró nivel fiabilidad requerido. caso contrario, modifica requeri-miento fiabilidad, bien, envía una petición cambio para enfrentar los proble-mas subyacentes del sistema. puede aceptar nivel más bajo fiabilidad debido los costos cambiar sistema para mejorar fiabilidad, porque corregir problema haya efectos colaterales adversos, como rendimiento una producción totales más bajos. contraste, seguridad protección tratan evitar situaciones indeseables, vez especificar “nivel” deseado seguridad protección. incluso sería inaceptable una estas situaciones durante vida sistema , ocurre, tienen que realizarse cambios sistema. tiene sentido hacer enunciados como: “las fallas del sistema podrían dar como resultado menos lesiones por año”. tan pronto como suceda una lesión, debe corregirse problema del sistema. por consiguiente, los requerimientos fiabilidad son dos tipos: . requerimientos funcionales, que definen número fallas aceptables durante uso normal del sistema, tiempo que sistema está disponible para uso. trata requerimientos fiabilidad cuantitativos. . requerimientos funcionales, que definen las funciones del sistema software que evitan, detectan toleran fallas del software , ese modo, aseguran que esto conduzca fallas sistema. los requerimientos fiabilidad cuantitativa conducen requerimientos sistema funcionales relacionados. para lograr cierto nivel fiabilidad requerido, los requeri-mientos funcionales diseño del sistema deben especificar las fallas detectar las acciones que deben tomarse para garantizar que éstas conduzcan fallas sistema. figura . muestra que proceso especificación fiabilidad puede basarse proceso general especificación dirigido por riesgo: . identificación del riesgo esta etapa examinan los tipos fallas sistema que originarían pérdidas económicas cierto tipo. por ejemplo, cuando siste- comercio electrónico está disponible tal modo que los clientes pue-den realizar pedidos, una falla que corrompa datos requiera tiempo para restaurar base datos del sistema desde respaldo volver operar transacciones que hayan procesado. lista posibles tipos fallas, que muestra figura ., sirve como punto partida identificación del riesgo. . análisis del riesgo implica estimación los costos las consecuencias dife-rentes tipos fallas software selecciona para análisis ulterior las fallas graves consecuencias. -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad . descomposición riesgo esta etapa, realiza análisis causa raíz las graves probables fallas sistema. sin embargo, esto sería casi imposible etapa requerimientos, pues las causas raíz suelen depender decisiones diseño del sistema. tal vez usted tenga que regresar esta actividad durante diseño desarrollo. . reducción del riesgo esta etapa, deben generarse especificaciones cuantitativas fiabilidad que establezcan las probabilidades aceptables los diferentes tipos fallas. desde luego, hay que tomar cuenta los costos las fallas. pueden usar diferentes probabilidades para distintos servicios del sistema, así como generar requerimientos fiabilidad funcionales. nuevo, esto tal vez deba esperar hasta que tomen las decisiones diseño del sistema. obstante, como estudia sección .., ocasiones difícil crear especificaciones cuantitativas. quizás usted sólo pueda identificar los requerimientos funcionales fiabilidad. .. métricas fiabilidad términos generales, fiabilidad puede especificarse como una probabilidad que una falla del sistema ocurrirá cuando sistema está uso dentro entorno ope-racional especificado. está dispuesto aceptar, por ejemplo, que pueda fallar una las , transacciones, entonces especificará probabilidad falla como .. claro, esto significa que verá una falla cada , transacciones. quiere decir que, observa mil transacciones, número fallas que observe debe estar alrededor . posible corregir esto para diferentes tipos fallas diferentes partes del sistema. puede decidir que los componentes críticos deben tener una probabilidad más baja falla que los críticos. existen dos importantes métricas que usan para especificar fiabilidad, además una métrica adicional que utiliza para especificar atributo sistema relacionado con disponibilidad. elección métrica depende del tipo sistema especificado los requerimientos del dominio aplicación. las métricas son: . probabilidad falla pedido (pofod, por las siglas probability failure demand) usa esta métrica, defina probabilidad que demanda por servicio sistema derive una falla del sistema. este modo, pofod = . . tipos fallas del sistematipo falla descripción pérdida servicio sistema está disponible puede entregar sus servicios los usuarios. esto divide pérdida servicios críticos pérdida servicios críticos; evidentemente, son menores las consecuencias una falla los servicios críticos, que las consecuencias una falla servicios críticos. entrega incorrecta servicioel sistema entrega correctamente servicio los usuarios. nuevo, esto podría especificarse términos errores menores mayores, bien, errores entrega servicios críticos críticos. corrupción sistema datos falla del sistema causa daño sistema sus datos. por general, aunque necesariamente, esto estará conjunción con otros tipos fallas. -.indd -.indd // :: // :: . ■ especificación fiabilidad significa que hay una probabilidad /, que ocurra una falla hacer una petición. . tasa ocurrencia fallas (rocof, por las siglas rate occurrence failu- res) esta métrica establece número probable fallas sistema que observan relación con cierto tiempo (por ejemplo, una hora), número ejecuciones del sistema. ejemplo anterior, rocof /,. recíproco rocof tiempo medio para falla (mttf, por las siglas main time failure), que veces usa como una métrica fiabilidad. mttf promedio unidades tiempo entre las fallas observadas sistema. por tanto, una rocof dos fallas por hora significa que tiempo medio falla minutos. . disponibilidad (avail) disponibilidad sistema refleja capacidad entregar servicios cuando solicitan. avail probabilidad que siste- esté operación cuando haga una demanda por servicio. consecuencia, una disponibilidad . significa que, promedio, sistema estará disponible .% del tiempo operación. figura . muestra qué significan prác-tica los diferentes niveles disponibilidad. pofod debe usarse como una métrica fiabilidad situaciones donde una falla sobre demanda podría conducir una falla grave del sistema. esto aplica sin importar frecuencia las demandas. por ejemplo, sistema protección que monitoriza reactor químico, desactiva reacción cuando sobrecalienta, debe especificar fia-bilidad mediante pofod. general, son raras las demandas sistema protección, que sistema última línea defensa, una vez que fallan todas las demás estra-tegias recuperación. por ello, una pofod . ( falla , demandas) quizá parezca riesgosa, pero vida sólo hay dos tres demandas del sistema, entonces probablemente nunca verá una falla sistema. rocof métrica más adecuada para usar situaciones donde las demandas sistema hacen con regularidad vez esporádicamente. por ejemplo, sis-tema que maneja una gran cantidad transacciones, usted puede especificar una rocof fallas por día. esto significa que está dispuesto aceptar que promedio transacciones por día completen exitosamente, tendrán que cancelarse. bien, posible especificar una rocof como número fallas por , transacciones. importante tiempo absoluto entre fallas, puede especificar fiabilidad como tiempo medio entre fallas. por ejemplo, especifica fiabilidad requerida para sistema con transacciones grandes (como sistema diseño asistido por computadora), figura . especificación disponibilidaddisponibilidad explicación . sistema está disponible % del tiempo. esto significa que, durante periodo horas (, minutos), sistema estará disponible por minutos. . durante periodo horas, sistema estará disponible por . minutos. . sistema estará disponible durante segundos, periodo horas. . sistema estará disponible durante . segundos periodo horas. casi minuto por semana. -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad debe especificar fiabilidad con tiempo medio largo para falla. mttf debe ser mucho más largo que tiempo promedio que usuario trabaja sus modelos sin guar-dar sus resultados. esto podría representar que sería improbable que los usuarios pierdan trabajo por una falla del sistema cualquier sesión. para valorar fiabilidad sistema, debe capturar datos sobre operación. los datos requeridos incluyen: . número fallas sistema dado número peticiones por servicios del sis- tema. esto usa para medir pofod. . tiempo número transacciones entre fallas sistema, más tiempo total transcurrido número total transacciones. esto usa para medir rocof mttf. . tiempo reparación reanudación después una falla sistema que conduzca pérdida servicio. utiliza para medir disponibilidad. disponibilidad sólo depende del tiempo entre fallas, sino también del tiempo requerido para hacer que sistema esté nuevamente operación. las unidades tiempo que pueden usarse son tiempo calendario, tiempo pro-cesador una unidad discreta como número transacciones. los sistemas que pasan buena parte tiempo esperando una respuesta una petición servicio, como los sistemas conmutación telefónica, unidad tiempo que debe usarse tiempo procesador. usa tiempo calendario, entonces esto incluirá tiempo cuando sistema hacía nada. debe usar tiempo calendario para los sistemas que estén operación continua. los sistemas monitorización, como los sistemas alarma otros tipos sistemas control proceso sitúan esta categoría. los sistemas que procesan transacciones como los cajeros automáticos los sistemas reservación las aerolíneas tienen car-gas variables sobre ellos, las cuales dependen hora del día. estos casos, unidad “tiempo” que usa podría ser número transacciones ( decir, rocof sería número transacciones fallidas por cada mil transacciones). .. requerimientos fiabilidad funcionales los requerimientos fiabilidad funcionales son especificaciones cuantitativas fiabilidad disponibilidad requeridas sistema, calculadas mediante uso una las métricas descritas sección anterior. las especificaciones cuantitativas fia-bilidad disponibilidad han empleado durante muchos años los sistemas críticos seguridad, rara vez utilizan sistemas empresariales críticos. sin embargo, con-forme más compañías demandan servicios sus sistemas las horas día los siete días semana, factible que tales técnicas utilicen cada vez más. existen varias ventajas para derivar especificaciones fiabilidad cuantitativas: . proceso decidir qué nivel fiabilidad requiere ayuda clarificar qué nece- sitan realmente los participantes. contribuye que éstos comprendan que existen diferentes tipos fallas sistema, deja claro que los niveles superiores fiabilidad son muy costosos lograr. -.indd -.indd // :: // :: . ■ especificación fiabilidad . proporciona una base para valorar cuándo dejar probar sistema. detiene cuando sistema obtiene nivel requerido fiabilidad. . medio para valorar diferentes estrategias diseño, cuya intención sea mejo-rar fiabilidad del sistema. puede hacer juicio sobre cómo cada estrategia llega conducir niveles requeridos fiabilidad. . regulador tiene que aprobar sistema antes entrar servicio (por ejem-plo, están regulados todos los sistemas críticos para seguridad del vuelo una aeronave), entonces importante evidencia que alcanzó objetivo fiabilidad requerido para certificación del sistema. para establecer nivel requerido fiabilidad del sistema, hay que considerar las pér-didas asociadas que resultarían una falla del sistema. éstas son simplemente pérdidas financieras para una empresa, sino también pérdidas reputación. esto último significa que los clientes irán algún otro lado. aunque las pérdidas corto plazo por una falla sistema suelen ser relativamente pequeñas, las pérdidas plazo más largo serían mucho más significativas. por ejemplo, usted trata acceder sitio comercio electrónico cuenta que éste encuentra disponible, entonces vez esperar que sistema esté disponible tratará buscar que quiere algún otro lado. esto ocurre más una vez, seguramente comprará nuevo dicho sitio. problema con especificación fiabilidad usando métricas como pofod, rocof avail que posible sobreespecificar fiabilidad , por ende, incurrir altos costos desarrollo validación. razón que los participantes del sistema descubren que difícil traducir experiencia práctica especificaciones cuantitati-vas. pueden considerar que una pofod . ( falla , demandas) representa sistema relativamente poco fiable. sin embargo, como explicó, las demandas por servicio son escasas, realidad representa nivel fiabilidad muy alto. fiabilidad especifica como una métrica, evidentemente importante valorar que logró nivel fiabilidad requerido. esta valoración hace como parte las pruebas del sistema. para valorar estadísticamente fiabilidad sistema, hay que observar algunas fallas. , por ejemplo, tiene una pofod . ( falla , deman-das), entonces tal vez haya que diseñar pruebas que realicen mil demandas sobre sistema donde observen numerosas fallas. prácticamente sería imposible diseñar implementar este número pruebas. por tanto, sobreespecificación fiabilidad conduce costos pruebas muy elevados. cuando especifique disponibilidad sistema, probable que tenga proble-mas similares. aun cuando parece ser deseable nivel disponibilidad muy elevado, mayoría los sistemas tienen patrones demanda muy intermitentes (por ejemplo, sistema empresarial usará básicamente durante horas laborales normales) una sola cifra disponibilidad refleja realmente las necesidades del usuario. necesita alta disponibilidad sólo cuando sistema usa, pero otros momentos. desde luego, dependiendo del tipo sistema, podría haber diferencias prácticas reales entre una disponibilidad . una .. problema fundamental con sobreespecificación que sería casi imposible demostrar que logró nivel fiabilidad disponibilidad muy alto. por ejemplo, suponga que sistema pretendía usarse una aplicación crítica para protección que luego requirió fallar nunca durante vida total. imagine que instalarán , copias del sistema que sistema ejecutará , veces por segundo; vida -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad proyectada del sistema años. por tanto, número total ejecuciones del sis- tema aproximadamente *. hay razón para especificar que tasa ocurrencia fallas deba ser / ejecuciones (esto permite algún factor seguridad), pues factible probar sistema por largo tiempo para validar este nivel fiabilidad. consecuencia, las organizaciones deben ser realistas sobre vale pena espe-cificar validar nivel fiabilidad muy alto. los niveles fiabilidad altos justifican claramente los sistemas donde crítica operación fiable, como los siste-mas conmutación telefónica, donde falla del sistema daría como resultado grandes pérdidas económicas. quizá justifiquen para muchos tipos empresas siste-mas científicos. estos sistemas tienen requerimientos fiabilidad modestos, pues los costos una falla son simplemente demoras procesamiento, proceso recupe-ración directo relativamente económico. hay varios pasos para evitar sobreespecificación fiabilidad del sistema: . especifique los requerimientos disponibilidad fiabilidad para diferentes tipos fallas. debe haber una probabilidad ocurrencia más baja para fallas graves que para fallas menores. . especifique por separado los requerimientos disponibilidad fiabilidad para dife-rentes servicios. las fallas que afectan los servicios más críticos tienen que especi-ficarse como menos probables que aquellas sólo con efectos locales. puede tomar decisión limitar especificación fiabilidad cuantitativa los servicios del sistema más críticos. . decida realmente necesita fiabilidad sistema software las metas confiabilidad globales del sistema logran otras formas. por ejemplo, puede usar mecanismos detección errores para verificar las salidas sistema disponer procesos para corregir errores. entonces, tal vez haya necesidad nivel alto fiabilidad sistema que genera las salidas. para ilustrar este último caso, considere los requerimientos fiabilidad para sis-tema cajero automático que otorgue efectivo ofrezca otros servicios los clientes. hay problemas del hardware software del cajero automático, entonces éstos conduci-rán entradas incorrectas base datos cuenta del cliente. esto podría evitarse especificar nivel muy alto fiabilidad del hardware software dicho cajero. sin embargo, los bancos tienen muchos años experiencia sobre cómo identificar corregir las transacciones incorrectas las cuentas. usan métodos contabilidad para detectar cuándo funcionan mal las cosas. mayoría las transacciones que fallan pueden simplemente cancelarse, cual deriva alguna pérdida para banco sólo causa inconvenientes menores cliente. consecuencia, los bancos que operan redes cajeros automáticos aceptan que las fallas éstos podrían significar que número pequeño transacciones sean incorrectas; sin embargo, consideran más efectivo cuanto costos corregir estas últimas que incurrir costos muy elevados evitar algu-nas transacciones fallidas. para banco ( para sus clientes), disponibilidad red los cajeros auto-máticos más importante que fallan transacciones individuales cajero. falta disponibilidad significa más demanda por servicios del cliente, insatisfacción del cliente, costos ingeniería para reparar red, etcétera. por tanto, para sistemas basa-dos transacciones, como los sistemas bancarios comercio electrónico, enfoque -.indd -.indd // :: // :: . ■ especificación fiabilidad especificación fiabilidad, por general, está especificación disponi- bilidad del sistema. para especificar disponibilidad una red cajeros automáticos, hay que identi-ficar los servicios del sistema especificar disponibilidad requerida para cada uno ellos. éstos son:  servicio base datos cuenta del cliente;  los servicios individuales proporcionados por cajero automático, como “retiro efectivo”, “proporcionar información cuenta”, etcétera. aquí, servicio base datos más crítico, pues falla este servicio signifi- caría que todos los cajeros automáticos red estén fuera operación. por tanto, necesario especificar esto para tener alto nivel disponibilidad. tal caso, una cifra aceptable para disponibilidad base datos ( ignoran conflictos como man-tenimiento actualizaciones programadas) probablemente sería alrededor ., entre las .. las .. ello significa tiempo muerto menos minuto por semana. práctica, significa que muy pocos clientes resultarían afectados sólo conduciría inconvenientes menores para éstos. para cajero automático individual, disponibilidad global depende fiabilidad mecánica del hecho que pueda quedarse sin efectivo. probable que los conflictos software tengan menos efecto que factores como éstos. consecuencia, aceptable menor nivel disponibilidad para software del cajero automático. por consiguiente, disponibilidad global del software del cajero puede especificarse como ., cual significa que una máquina quizá esté disponible diariamente entre uno dos minutos. para ilustrar especificación fiabilidad basada fallas, considere los requeri-mientos fiabilidad para software control bomba insulina. este sistema entrega insulina varias veces día monitoriza glucosa sangre del usuario muchas veces por hora. puesto que uso del sistema intermitente las consecuencias falla son graves, métrica fiabilidad más adecuada pofod (probabilidad fallas petición). existen dos posibles tipos fallas bomba insulina: . fallas transitorias software que pueden repararse mediante acciones del usuario, como restablecimiento recalibración máquina. para estos tipos fallas, valor relativamente bajo pofod (por ejemplo, .) sería aceptable. esto sig-nifica que una falla puede ocurrir cada demandas hechas máquina. ello representa aproximadamente una vez cada . días, porque azúcar sangre verifica casi cinco veces por hora. . fallas permanentes del software que requieren reinstalación del software por parte del fabricante. probabilidad este tipo fallas debe ser mucho menor. alrededor una vez año cifra mínima, modo que pofod debe ser mayor que .. sin embargo, falla para administrar insulina tiene implicaciones inmediatas seguridad, modo que factores comerciales, más que los seguridad, controlan nivel fiabilidad requerida. los costos del servicio son altos porque los usuarios nece-sitan reparación sustitución rápida. interés del fabricante limitar número fallas permanentes que requieran reparación. -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad : debe definirse rango predefinido para todas las entradas operador; asimismo, sistema debe verificar que todas las entradas operador sitúen dentro este rango predefinido. (comprobación) : tienen que conservarse copias base datos del paciente dos servidores separados que alojen mismo edificio. (recuperación, redundancia) : debe usarse programación -versión para implementar sistema control frenado. (redundancia) : sistema debe implementarse subconjunto seguro ada comprobarse mediante análisis estático. (proceso) .. especificación fiabilidad funcional especificación fiabilidad funcional incluye identificar los requerimientos que definen las restricciones las características que contribuyen fiabilidad del sis-tema. para sistemas donde fiabilidad especifica cuantitativamente, pueden ser necesarios tales requerimientos funcionales para garantizar logro nivel reque-rido fiabilidad. existen tres tipos requerimientos fiabilidad funcional para sistema: . requerimientos comprobación tales requerimientos identifican las comproba- ciones las entradas sistema, para garantizar que las entradas incorrectas fuera rango detecten antes que las procese sistema. . requerimientos recuperación dichos requerimientos implementan para ayu-dar sistema recuperarse luego que ocurre una falla. por general, estos requerimientos relacionan con hecho conservar copias del sistema sus datos, especificar forma que restauran los servicios del sistema después una falla. . requerimientos redundancia especifican las características redundantes del sistema que aseguran que falla solo componente conduzca una pérdida completa del servicio. esto estudia con más detalle siguiente capítulo. además, los requerimientos fiabilidad pueden incluir requerimientos proceso para fiabilidad. trata requerimientos que aseveran que buena práctica, conocida porque reduce número fallas sistema, usa proceso desarrollo. figura . muestran algunos ejemplos requerimientos fiabilidad proceso funcional. hay reglas simples para derivar requerimientos fiabilidad funcional. las organizaciones que desarrollan sistemas críticos, usualmente existe conocimiento orga-nizacional sobre posibles requerimientos fiabilidad cómo repercuten fiabilidad real sistema. estas organizaciones pueden especializarse tipos específicos sistemas, tales como los sistemas control ferroviario, manera que los requerimien-tos fiabilidad pueden reutilizarse mediante rango sistemas.figura . ejemplos requerimientos fiabilidad funcional -.indd -.indd // :: // :: . ■ especificación seguridad . especificación seguridad especificación requerimientos seguridad para sistemas tiene algo común con los requerimientos protección. resulta práctico especificarlos manera cuantita-tiva, los requerimientos seguridad con frecuencia son requerimientos enunciados como “ debe” que definen comportamiento inaceptable del sistema, lugar funcionalidad requerida del sistema. sin embargo, seguridad problema que exige mayor esfuerzo que protección, por diversas razones: . cuando considera protección, puede suponer que entorno donde sis- tema instala hostil. nadie trata causar incidente relacionado con seguridad. cuando considera seguridad, uno debe suponer que son deliberados los ataques sistema que atacante puede conocer las debilidades del sistema. . cuando ocurren fallas sistema que plantean riesgo protección, buscan los errores las omisiones que produjeron falla. los ataques deliberados ocasio-nan fallas sistema, encontrar causa raíz suele ser más difícil, que atacante puede tratar encubrir motivo falla. . por general aceptable desactivar degradar los servicios del sistema para evi-tar una falla relacionada con protección. sin embargo, los ataques sistema pueden ser los llamados ataques negación servicio, que tienen intención apagar sistema. desactivar sistema significa que ataque fue exitoso. . los eventos relacionados con protección los genera adversario inteligente. atacante puede indagar las defensas sistema través una serie ata-ques, modificar éstos conforme aprende más sobre sistema sus respuestas. tales distinciones significan que los requerimientos seguridad suelen ser más extensos que los requerimientos protección. los requerimientos protección con-ducen generación requerimientos funcionales del sistema que suministran pro-tección contra eventos fallas que podrían originar fallas operación vinculadas con protección. básicamente enfocan comprobación problemas toma acciones ocurren dichos problemas. contraste, existen muchos tipos requerimientos seguridad que protegen contra las diferentes amenazas que enfrenta sistema. firesmith () identificó tipos requerimientos seguridad que pueden incluirse una especificación sistema: . los requerimientos identificación especifican sistema debe debe iden- tificar sus usuarios antes interactuar con ellos. . los requerimientos autenticación explican cómo identifica los usuarios. . los requerimientos autorización detallan los privilegios permisos acceso los usuarios identificados. . los requerimientos inmunidad definen cómo sistema debe protegerse mismo contra virus, gusanos amenazas similares. . los requerimientos integridad describen cómo puede evitarse corrupción datos. -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad . los requerimientos detección intrusiones puntualizan qué mecanismos deben usarse para detectar ataques sistema. . los requerimientos repudio especifican que una parte una transacción puede negar involucramiento dicha transacción. . los requerimientos privacidad refieren cómo mantiene privacidad los datos. . los requerimientos auditoría seguridad plantean cómo puede auditarse veri-ficarse uso del sistema. . los requerimientos seguridad mantenimiento del sistema especifican cómo una aplicación puede evitar cambios autorizados partir inhabilitación acci-dental sus mecanismos seguridad. desde luego, usted verá cada sistema todos estos tipos requerimientos seguridad. los requerimientos particulares dependen del tipo sistema, situación uso los usuarios esperados. proceso análisis valoración del riesgo, que estudia sección ., puede utilizarse para identificar requerimientos seguridad del sistema. existen tres etapas este proceso: . análisis preliminar del riesgo esta etapa todavía toman decisiones sobre los requerimientos detallados del sistema, diseño del sistema tecnología implementación. meta este proceso valoración derivar requerimien-tos seguridad para sistema conjunto. . análisis del riesgo del ciclo vida esta valoración riesgo tiene lugar durante ciclo vida desarrollo del sistema, después tomarse elecciones diseño. los requerimientos adicionales seguridad toman cuenta las tecnologías usadas construcción del sistema, así como las decisiones diseño implementación del sistema. . análisis del riesgo operativo esta valoración riesgo considera los riesgos sistema operativo impuestos por ataques maliciosos los usuarios, con sin cono-cimiento interno del sistema. los procesos valoración análisis riesgo que usan especificación requerimientos seguridad son variantes del proceso especificación genérico dirigido por riesgos que estudió sección .. figura . muestra proceso degestión riesgos seguridad protección tema legal las empresas están condiciones negarse participar creación sistemas seguros. sin embargo, algunos aspectos seguridad son asuntos empresariales: una compañía quizá decida implementar ciertas medidas seguridad cubrir las pérdidas que resulten dicha decisión. gestión del riesgo proceso para decidir qué activos deben protegerse cuánto puede gastarse protección. http:// -.indd -.indd // :: // :: . ■ especificación seguridad requerimientos seguridad dirigido por riesgos. esto parecería diferente del proceso dirigido por riesgos figura ., pero indica cómo cada etapa corresponde las etapas proceso genérico incluir entre corchetes actividad del proceso genérico. las etapas del proceso son: . identificación del activo, que identifican los activos del sistema que podrían requerir protección. sistema funciones particulares del sistema pueden identificarse como activos, igual que los datos asociados con sistema (identifi-cación riesgos). . estimación del valor del activo, donde evalúa valor los activos identificados (análisis riesgos). . valoración exposición, cual permite valorar las pérdidas potenciales asocia-das con cada activo. deben tomarse cuenta las pérdidas directas, como robo información, los costos recuperación posible pérdida reputación (análisis riesgos). . identificación amenazas, donde identifican las amenazas los activos del sis-tema (análisis riesgos). . valoración del ataque, que cada amenaza descompone ataques que pue-den hacerse sistema las posibles formas que dichos ataques podrían ocurrir. posible usar árboles ataque (schneier, ) para analizar las posibles embes-tidas. son similares los árboles fallas, pues comienzan con una amenaza como raíz del árbol identifican los posibles ataques causales cómo éstos podrían realizarse (descomposición del riesgo). . identificación del control, donde proponen los controles que pueden instalarse para proteger activo. los controles son los mecanismos técnicos, como encrip-tación, que sirven para proteger los activos (reducción del riesgo). . valoración factibilidad, cual permite valorar factibilidad técnica los costos los controles propuestos. vale pena tener controles muy caros para proteger los activos que tienen gran valor (reducción del riesgo). . definición requerimientos seguridad, que usa conocimiento las valoraciones exposición, amenazas control, para derivar requerimientos deidentificación del activo estimación del valor activo identificación amenazasvaloración del ataquevaloración exposición definición req. seguridad identificación del controlvaloración factibilidadfigura . proceso valoración preliminar del riesgo para requerimientos seguridad -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad seguridad del sistema. éstos pueden ser requerimientos para infraestructura del sistema sistema aplicación (reducción del riesgo). una importante entrada proceso valoración gestión del riesgo política seguridad organización. una política seguridad organizacional aplica todos los sistemas ella establece que debe debe permitirse. por ejemplo, aspecto una política seguridad militar establecería siguiente: “los lectores pue-den examinar sólo los documentos cuya clasificación sea misma esté por abajo del nivel inspección del lector”. esto significa que, lector tiene nivel inspección “secreto”, puede acceder documentos que estén clasificados como “secretos”, “confi-denciales” “abiertos”, pero documentos clasificados como “ultrasecretos”. política seguridad establece condiciones que sistema seguridad debe man-tener siempre, que ayudan identificar amenazas que puedan presentar. las ame-nazas son cualquier intrusión que vulnere seguridad empresa. práctica, las políticas seguridad son por general documentos informales que definen que permite permite. sin embargo, bishop () discute posibilidad expresar las políticas seguridad lenguaje formal generar verificaciones automatizadas para garantizar que sigue política. como una forma ilustrar este proceso análisis riesgo seguridad, consi-dere sistema información hospitalario para atención salud mental, mhc-pms. aquí tiene espacio donde analizar una valoración riesgo completa, pero, lugar, delinearía sistema como una fuente ejemplos. esto muestra como fragmento reporte (figuras . .) que podría generarse partir del pro-ceso valoración preliminar del riesgo. reporte resultante usa para definir los requerimientos seguridad. partir del análisis riesgo para sistema información hospitalario, pueden derivar requerimientos seguridad. algunos ejemplos tales requerimientos son: . información del paciente debe descargarse, inicio una sesión clínica, desde base datos área segura sistema cliente.figura . análisis activos reporte valoración preliminar del riesgo para mhc-pmsactivo valor exposición sistema información alto. requerido para apoyar todas las consultas clínicas. potencialmente crítico para seguridad.alta. pérdidas financieras que posible que deban cerrarse clínicas. costos sistemas restauración. posible daño paciente logran prescribirse tratamientos. base datos pacientes alto. requerido para apoyar todas las consultas clínicas. potencialmente crítico para seguridad.alta. pérdidas financieras, pues posible que deban cerrarse clínicas. costos sistemas restauración. posible daño paciente prescriben tratamientos. registro paciente individual normalmente bajo, aunque puede ser alto para pacientes específicos perfil alto.pérdidas directas bajas, aunque posible pérdida reputación. -.indd -.indd // :: // :: . ■ especificación formal . debe encriptarse sistema cliente toda información los pacientes. . información del paciente tiene que subirse base datos terminar una sesión clínica borrarla computadora cliente. . bitácora todos los cambios realizados base datos del sistema ini-ciador dichos cambios deberían mantenerse una computadora separada del servidor base datos. los primeros dos requerimientos están relacionados: información del paciente descarga una máquina local, modo que las consultas continúen aun cuando ser-vidor base datos del paciente sea atacado encuentre disponible. sin embargo, esta información tiene que borrarse, forma que los usuarios posteriores computadora cliente logren acceder información. cuarto requerimiento requerimiento recuperación auditoría. ello significa que los cambios pueden recu-perarse reproducir bitácora cambios que posible descubrir quién realizó los cambios. esto desalienta mal uso del sistema por parte del personal autorizado. . especificación formal durante más años, muchos investigadores han dedicado uso métodos for-males para desarrollo software. los métodos formales son aproximaciones con base matemática desarrollo del software, donde define modelo formal del software. entonces factible analizar formalmente este modelo usarlo como base para una espe-cificación formal del sistema. principio, posible iniciar con modelo formal para software probar que programa desarrollado congruente con dicho modelo, cual, por consiguiente, elimina las fallas software que resultan errores programación.amenaza probabilidad control factibilidad usuario sin autorización tiene acceso como administrador del sistema hace sistema disponible.baja sólo permite administración del sistema desde ubicaciones específicas que sean físicamente seguras.bajo costo implementación, pero debe tenerse cuidado con distribución claves garantizar que éstas hallen disponibles acontecimiento emergencia. usuario sin autorización tiene acceso como usuario del sistema logra entrar información confidencial.alta exigir todos los usuarios autenticarse con uso mecanismos biométricos. registrar todos los cambios información del paciente para rastrear uso del sistema. técnicamente factible, pero con una solución alto costo. posible resistencia del usuario. simple transparente para implementar también soportar recuperación. figura . análisis amenaza control reporte valoración preliminar del riesgo -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad punto partida para todos los procesos desarrollo formal modelo sistema formal, que sirve como una especificación sistema. para crear este modelo, traduzca los requerimientos usuario del sistema, que expresan lenguaje natural, diagramas tablas, lenguaje matemático que tenga semántica definida formalmente. especificación formal una descripción sin ambigüedades qué debe hacer sis-tema. usar métodos manuales soportados por herramientas, posible comprobar que comportamiento programa congruente con especificación. las especificaciones formales sólo son importantes para una verificación del diseño implementación del software, sino también son forma más precisa especi-ficar sistemas , por ende, reducir ámbito para las malas interpretaciones. más aún, construir una especificación formal fuerza análisis detallado los requerimientos ésta una forma efectiva descubrir problemas requerimientos. una especifica-ción lenguaje natural, los errores pueden ocultarse mediante imprecisión del léxico. éste caso sistema especifica formalmente. las especificaciones formales desarrollan con frecuencia como parte proce- software basado plan, que sistema especifica completamente antes desarrollo. los requerimientos del sistema diseño definen detalle, analizan comprueban cuidadosamente antes comenzar implementación. desarrolla una especificación formal del software, esto viene por general después que especifi-caron los requerimientos del sistema, pero antes del diseño detallado del sistema. hay estrecho ciclo retroalimentación entre especificación detallada requerimientos especificación formal. figura . muestra las etapas especificación software interfaz con diseño software proceso software basado plan. como costoso desarrollar especificaciones formales, posible decidir limitar uso este enfoque aquellos componentes que son críticos para operación del sistema. éstos identifican diseño arquitectónico del sistema. hace pocos años desarrolló apoyo automatizado para analizar una especificación formal. los comprobadores modelos (clarke ., ) son herramientas soft-ware que toman una especificación formal basada estado ( modelo sistema) como una entrada, junto con especificación algunas propiedades deseables formal-mente expresadas, tales como “ hay estados inalcanzables”. programa compro-bación modelo analiza exhaustivamente especificación, cualquier reporte que modelo satisface propiedad del sistema, presenta ejemplo que muestra que satisface. comprobación del modelo relaciona estrechamente con noción análisis estático, capítulo estudian estos enfoques generales para verifica-ción del sistema.técnicas especificación formal las especificaciones formales del sistema expresan mediante dos enfoques fundamentales, como modelos las interfaces del sistema (especificaciones algebraicas) modelos del estado del sistema. sugiere descargar capítulo web adicional sobre este tema, donde muestran ejemplos ambos enfoques. capítulo incluye una especificación formal parte del sistema bomba insulina. http:// -.indd -.indd // :: // :: . ■ especificación formal las ventajas desarrollar una especificación formal usar ésta proceso desarrollo formal son: . mientras desarrolla una especificación formal detalle, obtiene una compren- sión profunda pormenorizada los requerimientos del sistema. incluso usa especificación proceso desarrollo formal, detección del error requerimientos potente argumento para elaborar una especificación formal (hall, ). los problemas requerimientos que descubren con antelación son, por general, mucho menos costosos corregir, que encuentran etapas posteriores proceso desarrollo. . conforme especificación expresa lenguaje con semántica definida for-malmente, puede analizarse manera automática para descubrir inconsistencias aquello que completó. . usa método como método , puede transformar especificación for-mal programa, través una secuencia transformaciones que preserven exactitud. consecuencia, garantiza que programa resultante cumpla especificación. . los costos las pruebas del programa suelen reducirse porque programa veri-ficó contra especificación. pesar estas ventajas, los métodos formales tienen efecto limitado sobre desa-rrollo práctico del software, incluso para sistemas críticos. consecuencia, existe muy poca experiencia comunidad del desarrollo uso las especificaciones formales del sistema. los argumentos que esgrimen contra desarrollo una especificación formal del sistema son: . problema que los propietarios expertos dominio entiendan una especi- ficación formal, modo que pueden comprobar que representa con precisión sus requerimientos. los ingenieros software, que entienden especificación formal, quizá comprendan dominio aplicación, así que tampoco estarían seguros que especificación formal una reflexión precisa los requerimientos del sistema. . bastante sencillo cuantificar los costos crear una especificación formal, pero más difícil estimar posible ahorro los costos que resultará uso. como resul-tado, los administradores están dispuestos asumir riesgo adoptar este enfoque.creciente involucramiento del contratista decreciente involucramiento del contratista especificación diseñodefinición requerimientos del usuarioespecificación requerimientos del sistemadiseño arquitectónicoespecificación formaldiseño alto nivel figura . especificación formal proceso software basado plan -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad . mayoría los ingenieros software han sido capacitados para usar lengua- jes especificación formal. por tanto, muestran renuentes proponer uso procesos desarrollo. . difícil escalar los enfoques actuales especificación formal para sistemas muy grandes. cuando usa especificación formal, básicamente para especificar soft-ware núcleo (kernel) crítico lugar sistemas completos. . especificación formal compatible con los métodos desarrollo ágiles. obstante, momento escribir este texto, han usado métodos formales desarrollo algunas aplicaciones críticas para protección seguridad. también pue-den utilizarse efectivamente términos costo desarrollo validación partes críticas sistema software más grande complejo (badeau amelot, ; hall, ; hall chapman, ; miller ., ; wordworth, ). son base las herramientas utilizadas verificación estática, tales como sistema verificación controlador que usa microsoft (ball ., ; ball ., ) lenguaje spark/ ada (barnes, ) para ingeniería sistemas críticos. puntos clave ■ análisis riesgos una actividad importante especificación requerimientos seguridad confiabilidad. implica identificación riesgos que pueden derivar accidentes incidentes. entonces generan requerimientos sistema para garantizar que dichos riesgos ocurran que, ocurren, conduzcan incidente accidente. ■ puede usarse enfoque dirigido por peligros para comprender los requerimientos seguridad sistema. identifican los peligros potenciales desglosan (con métodos tales como análisis árbol fallas) para descubrir sus causas raíz. luego especifican los requerimientos para evitar dichos problemas recuperarse ellos. ■ los requerimientos fiabilidad pueden definirse manera cuantitativa especificación requerimientos del sistema. las métricas fiabilidad incluyen probabilidad fallas petición (pofod), tasa ocurrencia fallas (rocof) disponibilidad (avail).costos especificación formal desarrollo una especificación formal proceso costoso, puesto que necesita mucho tiempo para traducir los requerimientos lenguaje formal comprobar especificación. experiencia demuestra que puede ahorrar las pruebas verificación del sistema , parecer, especificar sistema manera formal aumenta significativamente los costos globales desarrollo. sin embargo, cambia equilibrio costos, pues incurre más costos anticipados proceso desarrollo. http:// -.indd -.indd // :: // :: pmcapítulo ■ ejercicios ■ importante sobreespecificar fiabilidad requerida del sistema, pues ello conduce costos adicionales innecesarios los procesos desarrollo validación. ■ más difícil identificar los requerimientos seguridad que los requerimientos protección, puesto que atacante del sistema podría usar conocimiento las vulnerabilidades del sistema para planear ataque éste, aprender sobre las vulnerabilidades partir ataques exitosos. ■ para especificar requerimientos seguridad, tienen que identificar los activos que deben protegerse determinar cómo usar las técnicas seguridad tecnología para proteger dichos activos. ■ los métodos formales desarrollo software apoyan una especificación sistema que expresa como modelo matemático. desarrollo una especificación formal ofrece beneficio clave estimular examen análisis detallado los requerimientos del sistema. lecturas sugeridas safeware: system safety and computers. trata una discusión integral todos los aspectos desistemas críticos protección. texto particularmente sólido descripción del análisis peligro derivación requerimientos partir esto. (. leveson, addison-wesley, .) “security use cases.” buen artículo, disponible web, que enfoca cómo pueden usarse casos uso especificación seguridad. autor también tiene algunos interesantes artículos acerca especificación seguridad que citan este artículo. (. . firesmith, journal object technology, (), mayo-junio .) http:/ /www. jot. / issues/ issue_/ column/. “ten commandments formal methods . . .ten years later.” conjunto lineamientos para uso métodos formales que propuso por primera vez que revisan este ensayo. atractivo resumen los conflictos prácticos torno uso los métodos formales. (. . bowen . . hinchey, ieee computer, (), enero .) http:/ /. doi. org/ . / . . . “security requirements for the rest : survey.” buen punto partida para leer sobre especificación requerimientos seguridad. los autores interesan los enfoques ligeros, por encima los formales. (. . tøndel, . . jaatun, . . meland, ieee software, (), enero/febrero .) http:/ /. doi. org/ . / . . . ejercicios .. explique por qué las fronteras triángulo riesgo que muestra figura . son proclives modificarse con tiempo con las actitudes sociales cambiantes. .. explique por qué enfoque basado riesgos interpreta diferentes formas cuando especifican seguridad protección. -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad .. sistema bomba insulina, usuario debe cambiar aguja suministro insulina intervalos regulares, también puede modificar dosis individual máxima dosis diaria máxima por administrarse. sugiera tres errores usuario que puedan ocurrir proponga requerimientos protección que evitarían que dichos errores deriven accidente. .. sistema software crítico protección para tratar pacientes con cáncer tiene dos componentes principales: ■ una máquina terapia radiación que entrega dosis controladas radiación los sitios del tumor. esta máquina está controlada por sistema software embebido. ■ una base datos tratamiento que incluye detalles del tratamiento dado cada paciente. los requerimientos tratamiento ingresan esta base datos descargan automáticamente máquina terapia radiación. identifique tres peligros que puedan surgir este sistema. para cada peligro, sugiera requerimiento defensivo que reduzca probabilidad que dichos peligros deriven accidente. explique por qué probable que defensa sugerida reduzca riesgo asociado con peligro. .. sugiera métricas fiabilidad adecuadas para las siguientes clases sistemas software. ofrezca razones para elección métrica. prevea uso dichos sistemas sugiera valores adecuados para las métricas fiabilidad. ■ sistema que monitorice pacientes una unidad hospitalaria cuidado intensivo. ■ procesador texto. ■ sistema control para una máquina expendedora automatizada. ■ sistema para controlar frenado automóvil. ■ sistema para controlar una unidad refrigeración. ■ generador reportes administrativos. .. sistema protección ferroviario aplica automáticamente los frenos tren supera límite rapidez para segmento vía, tren entra segmento vía que actualmente está señalado con una luz roja ( decir, debe entrar segmento). ofrezca razones para respuesta, elija una métrica fiabilidad que pueda usarse especificación fiabilidad requerida para tal sistema. .. existen dos requerimientos esenciales seguridad para sistema protección ferroviario: ■ tren debe entrar segmento vía que esté señalizado con una luz roja. ■ tren debe superar límite rapidez especificado para una sección vía. suponiendo que estatus señal límite rapidez para segmento vía transmiten software bordo del tren antes que entre segmento vía, proponga cinco posibles requerimientos funcionales del sistema para software bordo, que puedan generarse partir los requerimientos protección del sistema. -.indd -.indd // :: // :: pmcapítulo ■ referencias .. explique por qué hay necesidad tanto una valoración preliminar riesgos seguridad como una valoración riesgo seguridad ciclo vida durante desarrollo sistema. .. extienda tabla figura . para identificar dos amenazas más mhc-pms, junto con controles asociados. úselos como base para generar más requerimientos seguridad software que implementen los controles propuestos. .. ¿los ingenieros software que trabajan especificación desarrollo sistemas relacionados con protección deben certificarse profesionalmente alguna forma? explique razonamiento. referencias badeau, . amelot, . (). “using high level programming language industrial project: roissy val”. proc. : formal specification and development and , guildford, : springer. ball, ., bounimova, ., cook, ., levin, ., lichtenberg, ., mcgarvey, ., ondrusek, ., rajamani, . . ustuner, . (). “thorough static analysis device drivers”. proc. eurosys , leuven, belgium. ball, ., cook, ., levin, . rajamani, . . (). “slam and static driver verifier: technology transfer formal methods inside microsoft”. proc. integrated formal methods , canterbury, : springer. barnes, . . (). high-integrity software: the spark approach safety and security . harlow, : addison-wesley.bishop, . (). introduction computer security. boston: addison-wesley.brazendale, . bell, . (). “safety-related control and protection systems: standards update”. iee computing and control engineering ., (), –. clarke, . ., grumberg, . peled, . . (). model checking. cambridge, mass.: mit press.firesmith, . . (). “engineering security requirements”. journal object technology, (), –.hall, . (). “seven myths formal methods”. ieee software, (), –. hall, . (). “using formal methods develop atc information system”. ieee software, (), –.hall, . chapman, . (). “correctness construction: developing commercially secure system”. ieee software, (), –. jahanian, . mok, . . (). “safety analysis timing properties real-time systems”. ieee trans. software engineering., - (), –. -.indd -.indd // :: // :: capítulo ■ especificación confiabilidad seguridad leveson, . stolzy, . (). “safety analysis using petri nets”. ieee transactions software engineering, (), –. leveson, . . (). safeware: system safety and computers. reading, mass.: addison-wesley.miller, . ., anderson, . ., wagner, . ., whalen, . . heimdahl, . . . (). “formal verification flight control software”. proc. aiaa guidance, navigation and control conference, san francisco. peterson, . . (). petri net theory and the modeling systems. nueva york: mcgraw-hill. schneier, . (). “attack trees”. dobbs journal, (), –.storey, . (). safety-critical computer systems. harlow, : addison-wesley.wordsworth, . (). software engineering with . wokingham: addison-wesley. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo estudiar los procesos técnicas para desarrollo sistemas ampliamente confiables. estudiar este capítulo: ■ comprenderá cómo confiabilidad del sistema puede lograrse mediante componentes redundantes diversos; ■ conocerá cómo los procesos software confiables contribuyen desarrollo software confiable; ■ identificará cómo diferentes estilos arquitectónicos favorecen desarrollo software redundante diverso; ■ conocerá las buenas prácticas programación que deben usarse ingeniería sistemas confiables. contenido . redundancia diversidad . procesos confiables . arquitecturas sistemas confiables . programación confiable ingeniería confiabilidad -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad uso técnicas ingeniería software, mejores lenguajes programación - jor calidad gestión conducen beneficios considerables confiabilidad para mayoría del software. obstante, aún generan fallas sistema que afectan dis-ponibilidad del sistema que llevan producción resultados incorrectos. algu-nos casos, tales fallas simplemente causan inconvenientes menores. los proveedores sistemas pueden decidir sólo coexistir con dichas fallas, sin corregir los errores sus sistemas. sin embargo, algunos sistemas, falla podría causar pérdidas vidas, bien, grandes pérdidas económicas reputación. éstos conocen como “sistemas críticos”, para los cuales resulta esencial alto nivel confiabilidad. los ejemplos sistemas críticos comprenden sistemas control procesos, sistemas protección que desactivan otros sistemas caso falla, sistemas médi-cos, conmutadores telecomunicaciones sistemas control vuelo. para mejorar con fiabilidad del software sistema crítico, utilizan herramientas técnicas desarrollo especial. aun cuando tales herramientas técnicas aumentan generalmente los costos desarrollo del sistema, también reducen riesgo fallas sistema las pérdi-das derivadas tales fallas. ingeniería confiabilidad interesa por las técnicas usadas para mejorar con-fiabilidad los sistemas tanto críticos como críticos. dichas técnicas apoyan tres enfoques complementarios que emplean desarrollo del software confiable: . evitación fallas desarrollo proceso diseño implementación del soft ware debe usar enfoques para desarrollo software que ayuden evitar erro-res diseño programación , además, que minimicen número fallas que sea factible que surjan ejecutar sistema. menos fallas desarrollo significan menos oportunidades fallas durante tiempo ejecución. . detección corrección fallas desarrollo los procesos verificación validación diseñan para descubrir eliminar fallas desarrollo pro-grama, antes desplegarlo para uso operacional. los sistemas críticos requieren verificación validación muy costosa para descubrir mayor número posible fallas antes del despliegue , asimismo, para convencer los participantes que sistema confiable. este tema expone capítulo . . tolerancia fallas desarrollo sistema diseñó modo que detectan las fallas desarrollo comportamiento inesperado del sistema tiempo ejecución, gestionan para que ocurra una falla sistema. todos los sistemas pueden incluirse enfoques simples tolerancia fallas desarrollo basados comprobación del tiempo ejecución interna. sin embargo, las técni-cas más especializadas tolerancia fallas (como uso arquitecturas sistema tolerantes fallas) sólo usan por general cuando requiere nivel muy alto disponibilidad fiabilidad del sistema. por desgracia, aplicar técnicas para evitar, detectar tolerar fallas desarrollo conduce una situación baja rendimientos. costo para encontrar eliminar las fallas desarrollo restantes sistema software eleva exponencialmente medida que descubren eliminan las fallas del programa (figura .). conforme software vuelve más confiable, necesario emplear mayor tiempo esfuerzo para encontrar cada vez menos fallas. cierta etapa, incluso para los sistemas críticos, vuelven injustificables los costos del esfuerzo adicional. -.indd -.indd // :: // :: como resultado, las compañías desarrollo software aceptan que software siempre presentará algunas fallas residuales. nivel fallas depende del tipo sis-tema. los productos empacados tienen nivel fallas relativamente alto, tanto que los sistemas críticos tienen mucho menor densidad fallas. razón para aceptar fallas desarrollo que, caso falla del sistema, menos costoso pagar por las consecuencias que descubrir eliminar las fallas desarrollo antes entregar sistema. sin embargo, como estudió capítulo , decisión liberar software defectuoso simplemente una medida económica. también debe considerarse aceptación social política falla sistema. muchos sistemas críticos, como los aeronaves, médicos contabilidad, usan dominios sistematizados como son transporte aéreo, medicina las finanzas. los gobiernos definen las medidas que aplican dichos dominios designan cuerpo organizador para garantizar que las compañías sigan dichas regulaciones. práctica, esto significa que regulador con frecuencia tiene que convencerse que los sistemas software críticos son confiables, esto requiere una clara evidencia que muestre que dichos sistemas son confiables. por consiguiente, proceso desarrollo para sistemas críticos sólo interesa elaboración sistema confiable, sino también producir evidencia que logre convencer regulador sobre confiabilidad del sistema. producción tal evidencia consume una proporción significativa los costos desarrollo para sistemas críticos , también, factor importante que contribuye los altos costos los siste-mas críticos. capítulo examinan los conflictos sobre producir casos seguri-dad confiabilidad. . redundancia diversidad redundancia diversidad son estrategias fundamentales para aumentar confia-bilidad cualquier tipo sistema. redundancia significa que espacio incluye capacidad repuesto que está disponible falla parte dicho sistema. diversidadfigura . aumento costos por eliminación fallas residuales desarrollo costo por error detectado pocos número errores residualesmuchos muy pocos. ■ redundancia diversidad -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad quiere decir que los componentes del sistema son diferentes tipos, cual también aumenta las probabilidades que fallen exactamente misma forma. redundancia diversidad usan para mejorar confiabilidad vida coti-diana. como ejemplo redundancia, mayoría los consumidores tienen bombillas eléctricas repuesto sus hogares, para que puedan recuperarse rápidamente falla una bombilla que estaba uso. comúnmente, para asegurar las casas usa más una cerradura (redundancia) , con frecuencia, las cerraduras suelen ser tipos diferentes (diversidad). esto significa que, intruso encuentra una forma inhabili-tar alguna las cerraduras, antes conseguir acceso, debería descubrir una manera diferente inhabilitar otra cerradura. como tema rutinario, todos deben respaldar sus computadoras además mantener copias redundantes los datos. para evitar problemas con falla discos, los respaldos deben mantenerse dispositivo externo, inde-pendiente diverso. los sistemas software que diseñan para confiabilidad pueden incluir componen-tes redundantes con misma funcionalidad que otros componentes del sistema. éstos sustituyen sistema fallar los componentes primarios. los componentes redun-dantes son diversos (esto , distintos otros componentes), una falla común los componentes replicados derivará una falla sistema. también proporciona redundancia agregar código comprobación adicional, cual estrictamente necesario para función del sistema. este código puede detectar ciertos tipos fallas antes que causen daños. posible que requieran mecanismos recuperación para garantizar que sistema continúe ejecución. los sistemas para los que disponibilidad requerimiento crítico, por gene-ral usan servidores redundantes. éstos entran operación automáticamente fallar servidor designado. algunas veces, para garantizar que los ataques sistema pue-dan detonar una vulnerabilidad común, dichos servidores son diversos tipos fun-cionan con sistemas operativos distintos. uso diferentes sistemas operativos ejemplo diversidad redundancia del software, donde funcionalidad comparable ofrece diferentes formas. sección .. discute con más detalle diversidad del software. diversidad redundancia sirven también para lograr procesos confiables garan-tizar que las actividades del proceso, como validación software, apoyen proceso método únicos. esto aumenta confiabilidad del software reducir las posibilidades falla del proceso, que los errores humanos cometidos durante pro-ceso desarrollo software conducen errores éste. por ejemplo, las actividades validación pueden incluir pruebas del programa, inspecciones manuales del mismo análisis estático, como las técnicas para detección fallas desarrollo. trata técnicas complementarias que permiten encontrar fallas desarrollo que soslayen los demás métodos. más aún, diferentes miembros del equipo serían responsables por explosión del ariane , cohete ariane , agencia espacial europea, estalló segundos después del despegue vuelo inaugural. falla fue causada por error los sistemas software. había sistema respaldo, pero éste era diverso , además, software computadora respaldo falló exactamente igual. cohete satélite carga fueron destruidos. http:// -.indd -.indd // :: // :: pmmisma actividad del proceso (por ejemplo, una inspección programa). las personas rea- lizan las tareas diferentes formas, dependiendo personalidad, experiencia educa-ción, modo que este tipo redundancia ofrece una perspectiva distinta sistema. como estudia sección .., lograr diversidad software pro-ceso sencillo. diversidad redundancia vuelven los sistemas más complejos , por tanto, más difíciles entender. sólo hay código adicional para escribir verificar, también debe agregarse sistema funcionalidad adicional, con finalidad detectar falla del componente cambiar control componentes alternativos. esta complejidad adicional significa que más probable que los programadores cometan errores que sea menos factible que las personas que comprueban sistema encuentren dichos errores. como consecuencia, algunas personas consideran que mejor evitar redundancia diversidad del software. visión que enfoque más adecuado diseñar software tan sencillo como sea posible, con procedimientos muy rigurosos verificación valida-ción (parnas ., ). posible gastar más verificación validación gracias los ahorros que resultan tener que desarrollar componentes software redundantes. ambos enfoques adoptan sistemas comerciales críticos para seguridad. por ejemplo, hardware software control vuelo del airbus tan diverso como redundante (storey, ). software control vuelo del boeing basa hardware redundante, pero cada computadora opera mismo software, que validó ampliamente. los diseñadores del sistema control vuelo del boeing centra-ron simplicidad redundancia. estas dos aeronaves son muy confiables, así que los enfoques diverso simple para confiabilidad pueden ser claramente exitosos. . procesos confiables los procesos software confiables están diseñados para producir software confiable. una compañía que emplea proceso confiable puede estar segura que proceso realizó documentó adecuadamente, que utilizaron técnicas desarrollo adecuadas para diseño sistemas críticos. razón para invertir los procesos confiables que probable que buen proceso software conduzca entregar software con menos errores , además, menos probable que yerre ejecución. figura . muestra algunos los atributos los procesos software confiables. evidencia que usó proceso confiable con frecuencia importante para convencer regulador que aplicó práctica ingeniería software más efectiva desarrollo del software. por general, los desarrolladores software presentarán modelo del proceso regulador, junto con evidencia que siguióprocesos operacionales confiables este capítulo analiza los procesos desarrollo confiables, aunque factor contribuyente igualmente importante para confiabilidad del sistema proceso operacional del sistema. diseñar tales procesos operacionales, deben considerar los factores humanos pensar siempre que los individuos son proclives cometer errores cuando usan sistema. proceso confiable tiene que diseñarse para evitar errores humanos , cometerse éstos, software debe detectar los errores permitir corrección. http:// ■ procesos confiables -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad proceso. regulador debe convencerse también que los participantes proceso ponen práctica manera consistente que éste puede usarse diferentes proyec-tos desarrollo. esto significa que proceso tiene que definirse explícitamente ser repetible: . proceso definido explícitamente aquel que sigue modelo proceso definido usado para orientar proceso producción software. debe haber recopilación datos durante proceso, que demuestre que siguieron todos los pasos necesarios modelo proceso. . proceso repetible aquel que apoya interpretación juicio indivi-duales. vez ello, proceso suele repetirse través proyectos con diferentes miembros equipo, sin importar quién esté involucrado desarrollo. esto muy importante para sistemas críticos, que menudo tienen largo ciclo desa-rrollo durante cual con frecuencia existen cambios significativos equipo desarrollo. los procesos confiables utilizan redundancia diversidad para lograr fiabilidad. tales procesos incluyen diferentes actividades que tienen misma meta; por ejemplo, inspecciones pruebas programa dirigidos descubrir errores uno éstos. los enfoques son complementarios, además que probable que juntos descubran una mayor proporción errores los que encontrarían usando una sola técnica. evidentemente, las actividades que usan los procesos confiables dependen del tipo software que desarrollar. sin embargo, general, dichas actividades deberían constituir engranaje para evitar introducción errores sistema, para detectar eliminar errores, mantener información sobre proceso . los ejemplos actividades que incluyen proceso confiable son: . revisiones requerimientos para comprobar que, medida posible, los requerimientos estén completos sean consistentes.característica del proceso descripción documentable proceso debe tener modelo proceso definido que establezca las actividades proceso documentación que debe producirse durante dichas actividades. estandarizado tiene que estar disponible conjunto amplio estándares desarrollo software que cubren producción documentación del software. auditable proceso debería ser comprensible para los individuos los participantes del proceso, quienes pueden verificar seguimiento dichos estándares proceso hacer sugerencias para mejora del proceso. diverso proceso debe comprender actividades verificación validación redundante diversa. robusto proceso tiene que recuperarse fallas actividades proceso individual. figura . atributos procesos confiables -.indd -.indd // :: // :: . gestión requerimientos para asegurarse que los cambios los requerimientos controlan que efecto los cambios propuestos los requerimientos sea com-prendido por aquellos desarrolladores afectados por cambio. . especificación formal, donde crea analiza modelo matemático del software. capítulo estudiaron los beneficios especificación formal. quizá bene-ficio más importante sea que obliga análisis muy detallado los requerimientos del sistema. este análisis, por mismo, probable que descubra problemas reque-rimientos que pudieron perderse durante las revisiones los requerimientos. . modelado sistema, que diseño del software documenta explícitamente como conjunto modelos gráficos; también documentan dichos modelos los vínculos entre los requerimientos. . inspecciones diseño programa, las cuales consisten que diferentes perso-nas inspeccionan comprueban diversas descripciones del sistema. con frecuen-cia, las inspecciones realizan con base listas verificación errores comunes diseño programación. . análisis estático, que implica realizar comprobaciones automatizadas sobre código fuente del programa. buscan anomalías que pudieran indicar errores omisiones programación. capítulo estudia análisis estático. . planeación administración pruebas, que implica diseñar conjunto global pruebas del sistema. proceso pruebas tiene que administrarse cuidadosa-mente para demostrar que tales pruebas ofrecen una cobertura los requerimientos del sistema que aplican correctamente. así como hay actividades proceso que enfocan desarrollo las pruebas del sistema, también debe haber procesos administración calidad del cambio bien defi-nidos. aunque las actividades específicas proceso confiable pueden variar una compañía otra, necesidad administración calidad del cambio universal. los procesos administración calidad (que examinan capítulo ) establecen conjunto estándares proceso producto. también incluyen activida-des que captan información del proceso, con finalidad demostrar que siguieron dichos estándares. por ejemplo, podría haber estándar definido para realizar inspec-ciones programa. líder del equipo inspección responsable documentar proceso para demostrar que siguió estándar inspección. ciclo vida seguridad international electrotechnical commission dispuso estándar proceso (iec ) para ingeniería sistemas protección. éste basa noción ciclo vida seguridad, que hace una clara distinción entre ingeniería seguridad ingeniería sistemas. las primeras etapas del ciclo vida seguridad iec definen alcance del sistema, valoran los peligros potenciales del sistema estiman los riesgos que plantean. esto sigue especificación los requerimientos seguridad asignación diferentes subsistemas. idea limitar extensión funcionalidad crítica protección para permitir aplicación técnicas específicas ingeniería sistemas críticos desarrollo del sistema crítico protección. http:// ■ procesos confiables -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad administración del cambio, que estudia capítulo , interesa por admi- nistrar los cambios sistema, cual garantiza que los cambios aceptados realidad implementen, confirma que las versiones planeadas del software incluyan los cam-bios programados. problema común con software que incluyan componentes equivocados construcción sistema. esto llevaría una situación que sistema ejecución incluya componentes que verificaron durante proceso desarrollo. los procedimientos administración configuración tienen que defi-nirse como parte del proceso administración del cambio, con finalidad asegurar que esto suceda. existe una visión muy difundida que los enfoques ágiles, que estudiaron capítulo , realidad son adecuados para los procesos confiabilidad (boehm, ). los enfoques ágiles enfocan desarrollo software documentar que hizo. con frecuencia tienen enfoque bastante informal para administración del cam-bio calidad. por general, prefieren los enfoques basados plan desarrollo sistemas confiables, que crean documentación fácil entender por parte los regula-dores otros participantes externos del sistema. obstante, los beneficios los enfoques ágiles son igualmente aplicables los sistemas críticos. esta área han presentado reportes éxito aplicación métodos ágiles (lindvall ., ) probable que desarrollen variantes los métodos ágiles que sean adecuadas para ingeniería sistemas críticos. . arquitecturas sistemas confiables como vimos, desarrollo sistemas confiables debe basarse proceso confia-ble. aunque probablemente necesite proceso confiable para crear sistemas igualmente confiables, esto suficiente para garantizar confiabilidad. también requiere diseñar una arquitectura sistema para confiabilidad, sobre todo cuando precisa tolerancia fallas. esto significa que arquitectura tiene que diseñarse para incluir componentes mecanismos redundantes, que permitan cambiar control componente otro. los ejemplos sistemas que pueden requerir arquitecturas tolerantes fallas son los sistemas las aeronaves, que deben estar operación durante todo vuelo, los siste-mas telecomunicación, los sistemas comando control críticos. pullum () describe los diferentes tipos arquitectura tolerante fallas que han propuesto, torres-pomales estudia las técnicas tolerancia fallas software (). realización más simple una arquitectura confiable está los servidores repli-cados, cuando dos más servidores realizan misma tarea. las peticiones para proce-samiento canalizan través componente gestión servidor que enruta cada petición hacia servidor específico. este componente también hace seguimiento las respuestas del servidor. caso falla éste, que por general detecta mediante falta respuesta, servidor defectuoso desconecta del sistema. las peti-ciones procesadas envían otros servidores para procesamiento. este enfoque servidor replicado usa ampliamente para los sistemas procesa-miento transacciones, donde fácil mantener copias las transacciones procesar. los sistemas procesamiento transacción diseñan para que sólo actualicen una vez terminada correctamente transacción, manera que las demoras procesa- -.indd -.indd // :: // :: pmmiento afecten integridad del sistema. ésta puede ser una forma efectiva usar hardware, servidor respaldo que usa normalmente para tareas baja prioridad. ocurre problema con servidor primario, procesamiento trans-fiere servidor respaldo, que otorga dicho trabajo mayor prioridad. los servidores replicados proporcionan redundancia, aunque usualmente aportan diversidad. hardware, general, idéntico opera misma versión del software. por tanto, los servidores son capaces lidiar con fallas hardware software que localizan una sola máquina. pueden contender con problemas diseño soft-ware que hacen que todas las versiones del software fallen mismo tiempo. para manejar fallas diseño software, sistema debe incluir software hardware diversos, como expone sección .. diversidad redundancia del software pueden implementarse algunos estilos arquitectónicos diferentes. resto esta sección describen algunos ellos. .. sistemas protección sistema protección sistema especializado que asocia con algún otro siste-. por común, éste sistema control para algunos procesos, tales como pro-ceso manufactura química sistema control equipo, por ejemplo sistema tren sin conductor. ejemplo sistema protección sería sistema tren que detecte éste pasa por una señal roja. así, hay indicios que sistema control del tren desacelera, entonces sistema protección aplica auto-máticamente los frenos del tren para detenerlo. los sistemas protección monitorizan manera independiente ambiente , los sensores indican problema que sistema controlado detecta, entonces activa sistema protección para desactivar pro-ceso equipo. figura . ilustra relación entre sistema protección sistema contro-lado. sistema protección monitoriza tanto equipo controlado como ambiente. detecta problema, emite comandos actuador para desactivar sistema solicitar otros mecanismos protección, como apertura una válvula desfogue. observe que existen dos conjuntos sensores. conjunto usa para monitorización normal del sis-tema otro específicamente para sistema protección. caso falla del sensor existen respaldos que permitirán sistema protección continuar operación. también hay actuadores redundantes sistema. sistema protección sólo incluye funcionalidad crítica que requiere para cambiar sistema estado potencialmente inseguro estado seguro (desacti-vación del sistema). ejemplo más general una arquitectura tolerante fallas, donde sistema principal recibe apoyo sistema respaldo más pequeño más simple que sólo incluye funcionalidad esencial. por ejemplo, software control del transbordador espacial tiene sistema respaldo que incluye funcionalidad “llevar casa”; esto , falla sistema control principal, sistema respaldo logrará aterrizar vehículo. ventaja este tipo arquitectura que software del sistema protección suele ser mucho más sencillo que software que controla proceso proteger. única función del sistema protección operación monitorizar asegurar que sis-tema lleve estado seguro caso una emergencia. por tanto, posible inver-tir más esfuerzo evitar detectar fallas. puede comprobar que especificación. ■ arquitecturas sistemas confiables -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad del software acertada consistente, que software correcto con respecto especificación. meta garantizar que fiabilidad del sistema protección sea tal que tiene una probabilidad muy baja fallas petición ( decir, .). puesto que las demandas sobre sistema protección deben ser escasas, una probabilidad falla petición /, significa que las fallas del sistema protección, hecho, deben ser muy extrañas. .. arquitecturas automonitorización una arquitectura automonitorización una arquitectura sistema que éste diseña para monitorizar propia operación tomar alguna acción detectar pro-blema. esto logra realizar cálculos sobre canales separados comparar las salidas dichos cálculos. las salidas son idénticas están disponibles mismo tiempo, entonces juzga que sistema opera correctamente. las salidas son diferentes, tal caso supone una falla. cuando sucede esto último, sistema normalmente declarará una excepción falla línea salida estatus, que conducirá transferencia control otro sistema. esto ilustra figura .. para ser efectivos detección fallas hardware software, los sistemas automonitorización tienen que diseñarse forma que: . hardware utilizado cada canal sea diverso. práctica, esto significaría que cada canal use tipo procesador diferente para realizar los cálculos requeridos, que los chips auxiliares que constituyen sistema puedan provenir diferentes fabricantes. esto reduce probabilidad fallas comunes diseño del procesa-dor que afecten cálculo. . software usado cada canal diverso. otro modo, podría surgir mis- error software cada canal mismo tiempo. sección .. exami-nan las dificultades lograr software verdaderamente diverso.actuadores equipo controladoentorno del sistema sistema controlsistema protecciónsensores protecciónsensores figura . arquitectura sistema protección -.indd -.indd // :: // :: por sola, esta arquitectura puede usarse situaciones donde importante que los cálculos sean correctos, pero donde disponibilidad sea esencial. las respuestas cada canal difieren, sistema simplemente desactiva. para muchos sistemas tratamiento diagnóstico médico, fiabilidad más importante que disponibilidad, pues una respuesta incorrecta del sistema podría conducir que paciente reciba tratamiento equivocado. sin embargo, sistema sencillamente desactiva caso error, esto constituye inconveniente, aunque paciente por general resulta dañado por sistema. situaciones donde requiere alta disponibilidad, tienen que usar muchos siste-mas autoverificación forma paralela. necesita una unidad conmutación que detecte las fallas seleccione resultado uno los sistemas, donde ambos canales produzcan una respuesta consistente. tal enfoque usa sistema control vuelo para serie airbus aeronaves, donde utilizan cinco computadoras autoveri-ficación. figura . diagrama simplificado que ilustra esta organización. sistema control vuelo del airbus, cada una las computadoras control vuelo realiza los cálculos paralelo usa las mismas entradas. las salidas conec-tan filtros hardware que detectan estatus indica una falla , así, hacen que salida dicha computadora desactive. entonces, salida toma sistema alternativo. por ello, posible que cuatro computadoras fallen que operación aeronave continúe. más años operación, habido reportes situaciones donde control aeronave haya perdido debido una falla total del sistema control vuelo. los diseñadores del sistema airbus trataron lograr diversidad muchas formas diferentes: . las computadoras primarias control vuelo usan procesador diferente los sistemas secundarios control vuelo. . los chips auxiliares que usan cada canal los sistemas primario secundario son suministrados por fabricantes diferentes. . software los sistemas secundarios control vuelo sólo ofrece funcionali-dad crítica: menos complejo que software primario. . software para cada canal, tanto los sistemas primarios como los secundarios, desarrolla mediante diferentes lenguajes programación por distintos equipos. . usan diversos lenguajes programación los sistemas secundario primario. como estudia siguiente sección, esto garantiza diversidad, pero reduce probabilidad fallas comunes diferentes canales.canal canal comparadorvalor entrada valor salidaestatus figura . arquitectura automonitorización. ■ arquitecturas sistemas confiables -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad .. programación -versión las arquitecturas automonitorización son ejemplos sistemas los que usa pro- gramación multiversión, con finalidad ofrecer redundancia diversidad software. esta noción programación multiversión derivó los sistemas hardware, los cuales durante muchos años usó noción redundancia modular triple (tmr, por las siglas triple modular redundancy) para construir sistemas que son tolerantes las fallas hardware (figura .). sistema tmr, unidad hardware replica tres veces ( más ocasiones). salida cada unidad pasa comparador salida que implementa por general como sistema votación. este sistema compara todas sus entradas , dos más son iguales, entonces dicho valor salida. una las unidades falla pro - misma salida que las otras unidades, salida ignora. administrador fallas desarrollo puede tratar reparar automáticamente unidad defectuosa, pero, esto imposible, sistema reconfigura forma automática para sacar servicio unidad. entonces sistema continúa función con dos unidades trabajando. este enfoque tolerancia fallas apoya que mayoría las fallas hard-ware son resultado fallas los componentes más que fallas diseño. conse-cuencia, probable que los componentes fallen manera independiente. supone que, cuando son completamente operativas, todas las unidades hardware desempe-ñan acuerdo con las especificaciones. por consiguiente, hay baja probabilidad falla simultánea componentes todas las unidades hardware.canal canal comparadorsalidaestatussistema primario control vuelo sistema secundario control vuelo primario control vuelo sistema primario control vuelo filtrosalida salidaestatus filtro salidaestatus filtro sistema secundario control vuelo filtrocanal canal comparadorsalidaestatus filtro figura . arquitectura del sistema control vuelo del airbus -.indd -.indd // :: // :: desde luego, todos los componentes podrían tener una falla diseño común , además, producir todos misma respuesta (equivocada). usar unidades hardware que tienen una especificación común, pero que diseñan construyen por fabricantes diferentes, reducen modo común las posibilidades tal falla. supone que mínima probabi-lidad que diferentes equipos cometan mismo error diseño fabricación. enfoque similar puede usarse para software tolerante fallas, donde versiones diversas sistema software ejecutan paralelo (avizienis, ; avizienis, ). este enfoque tolerancia fallas software, que ilustra figura ., usa sistemas señalización ferroviaria, sistemas aeronaves sistemas protec-ción reactores. usar una especificación común, mismo sistema software implementa por algunos equipos. dichas versiones ejecutan computadoras separadas. sus salidas comparan usar sistema votación, rechazan las salidas inconsistentes las que producen tiempo. menos tres versiones del sistema deben estar disponibles, modo que dos versiones tienen que ser consistentes caso una falla individual. programación -versión suele ser menos costosa que las arquitecturas auto-verificación, sistemas para los cuales requiere alto nivel disponibilidad. sin embargo, todavía requieren muchos equipos diferentes para desarrollar diferentes versiones del software. esto conduce costos desarrollo software muy elevados. como resultado, este enfoque sólo usa sistemas donde resulta práctico ofrecer sistema protección que proteja contra fallas críticas seguridad. .. diversidad software todas las arquitecturas anteriores tolerantes fallas apoyan diversidad del software para lograr tolerancia fallas. esto basa suposición que son independientes las implementaciones diversas misma especificación ( una parte especificación, para sistemas protección). deben incluir errores comunes , además, fallarán salidaentrada figura . redundancia modular triple versión versión versión salida gestor fallas versiones softwareresultado acordadoentrada figura . programación -versión. ■ arquitecturas sistemas confiables -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad misma forma mismo tiempo. esto requiere que software escriban diferen- tes equipos que comuniquen durante proceso desarrollo, cual, por consi-guiente, reduce las posibilidades malos entendidos malas interpretaciones comunes especificación. compañía que procura sistema puede incluir políticas explícitas diversidad que tengan intención maximizar las diferencias entre versiones del sistema. por ejemplo: . incluir requerimientos que deben usarse diferentes métodos diseño. para ilustrar anterior, puede solicitar equipo que produzca diseño orientado objeto otro equipo diseño orientado una función (estructurado). . estipular que las implementaciones deben escribirse diferentes lenguajes programación. por ejemplo, sistema tres versiones, podrían usarse ada, ++ java para escribir las versiones del software. . requerir uso diferentes herramientas entornos desarrollo para sistema. . solicitar explícitamente uso diferentes algoritmos algunas partes implementación. sin embargo, esto limita libertad del equipo diseño puede ser difícil reconciliar con los requerimientos rendimiento del sistema. cada equipo desarrollo debe trabajar con una especificación detallada del sistema ( ocasiones llamada -spec), que deriva especificación requerimientos del sistema (avizienis, ). ésta debe ser suficientemente detallada como para garantizar que haya ambigüedades especificación. además especificar funcionalidad del sistema, especificación detallada debe definir dónde deben generarse las salidas del sistema para comparación. manera ideal, las diversas versiones del sistema deben tener dependencias , además, deberían fallar formas completamente diferentes. éste caso, entonces fiabilidad global sistema diverso obtiene multiplicar las fiabilidades cada canal. este modo, cada canal tiene una probabilidad fallas petición ., entonces pofod global sistema tres canales (con todos los canales indepen-dientes) millón veces mayor que fiabilidad sistema solo canal. sin embargo, práctica, imposible lograr completa independencia del canal. demostrado experimentalmente que equipos diseño independientes cometen con fre-cuencia los mismos errores interpretan mal las mismas partes especificación (brilliant ., ; knight leveson, ; leveson, ). existen muchas razones para ello: . los miembros diferentes equipos suelen tener mismo antecedente cultural posible que hayan educado con mismo enfoque con los mismos libros texto. esto significa que pueden encontrar difícil entender las mismas cosas, tener dificultades comunes para comunicarse con expertos dominio. muy posible que, independientemente, cometan los mismos errores diseñen los mismos algoritmos para resolver problema. . los requerimientos son incorrectos basan interpretaciones equivocadas acerca del entorno del sistema, entonces dichos errores reflejarán cada imple-mentación del sistema. . sistema crítico, -spec documento detallado con base los reque-rimientos del sistema, que ofrece detalles completos los equipos sobre cómo debe -.indd -.indd // :: // :: . ■ programación conﬁ able comportarse sistema. puede haber espacio para interpretación por parte los desarrolladores del software. existen errores este documento, entonces presentarán todos los equipos desarrollo implementarán todas las ver-siones del sistema. una forma reducir posibilidad errores comunes especificación desarrollar independientemente especificaciones detalladas para sistema, definir las especifica-ciones diferentes lenguajes. equipo desarrollo puede trabajar desde una especi-ficación formal, otro desde modelo sistema basado estado, tercero desde una especificación lenguaje natural. esto ayuda evitar algunos errores interpretación especificación, aunque evita problema los errores especificación. también introduce posibilidad errores traducción los requerimientos, cual conduce especificaciones inconsistentes. análisis los experimentos, hatton () concluye que sistema tres canales era entre cinco nueve veces más fiable que sistema solo canal. concluye que las mejoras fiabilidad que podrían obtenerse dedicar más recursos una sola versión coincidirían con esto , además, probable que los enfoques -versión conduzcan sistemas más fiables que los enfoques versión sencilla. sin embargo, que está claro las mejoras fiabilidad sistema mul-tiversión ameritan los costos desarrollo adicionales. para muchos sistemas, los cos-tos adicionales quizá sean justificables, que sistema versión sencilla bien realizado sería suficientemente bueno. sólo los sistemas críticos para seguridad misión, donde los costos las fallas son muy elevados, requeriría software mul-tiversión. incluso tales situaciones (por ejemplo, sistema nave espacial), sería suficiente proporcionar simple respaldo con funcionalidad limitada, hasta que sistema principal pueda reparase reiniciarse. . programación confiable por general, este libro evitan las discusiones programación, porque casi imposible discutir este tema sin entrar detalles lenguaje programación espe-cífico. ahora existen tantos enfoques lenguajes distintos usados desarrollo software, que evita uso solo lenguaje para los ejemplos este libro. sin embargo, cuando considera ingeniería confiabilidad, hay conjunto prácti-cas programación recomendables aceptadas, que son bastante universales ayudan reducir las fallas los sistemas entregados. figura . presenta una lista buenos lineamientos prácticos. pueden apli-carse cualquier lenguaje programación que use para desarrollo sistemas, aunque forma que utilizan depende los lenguajes las notaciones específicos que empleen para desarrollo del sistema. lineamiento : controlar visibilidad información programa principio seguridad que adoptan las organizaciones militares principio “necesidad conocer”. sólo aquellos individuos que necesiten conocer una par- información particular, para realizar sus labores, otorga dicha información. oculta aquella información que directamente relevante para trabajo. -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad lineamientos programación confiable . controlar visibilidad información programa. . comprobar validez todas las entradas.. proporcionar manejador para todas las excepciones.. minimizar uso códigos proclives error.. ofrecer capacidades reinicio.. comprobar los límites.. incluir interrupciones cuando soliciten componentes externos.. nombrar todas las constantes que representan valores del mundo real. cuando uno programa debe adoptar principio análogo para controlar acceso las variables estructuras datos que utilizan. los componentes del programa sólo les debe permitir acceso los datos que necesitan para implementación. otros datos programa deben ser inaccesibles ocultarse ellos. oculta información, ésta puede corromper por componentes programa que supone que deben usarlos. interfaz permanece invariable, representación datos debería cambiarse sin afectar otros componentes sistema. esto logra implementar estructuras datos programa como tipos datos abstractos. tipo datos abstractos tipo datos que estructura interna representación una variable dicho tipo están ocultas. estructura los atributos del tipo son visibles externamente todo acceso los datos través operaciones. por ejemplo, puede tener tipo datos abstractos que represente una cola peticio-nes servicio. las operaciones deben incluir get (conseguir) put (poner), que agregan eliminan objetos cola, una operación que regrese número objetos cola. inicialmente implementaría cola como arreglo, pero posteriormente cambiaría implementación una lista entrelazada. esto logra sin cambio alguno código que usa cola, porque nunca accede manera directa representación cola. también pueden usar tipos datos abstractos para implementar comprobaciones que valor asignado esté dentro del rango. por ejemplo, suponga que quiere representar temperatura proceso químico, que las temperaturas permitidas hallan dentro del rango grados celsius. incluir una comprobación del valor asignar den-tro operación tipo datos abstractos, garantizaría que valor temperatura nunca está fuera del rango requerido. algunos lenguajes orientados objetos posible implementar tipos datos abs-tractos mediante definiciones interfaz, las que declara interfaz objeto sin referencia implementación. por ejemplo, puede definir una interfaz queue (cola), que soporta métodos para colocar objetos cola, eliminarlos ésta consultar tamaño misma. clase objetos que implementa esta interfaz, los atributos los métodos para dicha clase deben ser privados. lineamiento : comprobar validez todas las entradas todos los programas toman entradas entorno las procesan. especificación hace suposiciones sobre dichas entradas, que reflejan uso mundo real. por ejem-plo, supone que número cuenta bancaria siempre entero positivo ocho dígitos. sin embargo, muchos casos, especificación del sistema define qué accio-figura . lineamientos buena práctica para programación confiable -.indd -.indd // :: // :: . ■ programación conﬁ able nes deberían tomarse entrada incorrecta. inevitablemente, los usuarios cometerán errores algunas veces ingresarán datos equivocados. ocasiones, como estudia capítulo , ataques maliciosos sistema apoyan hecho ingresar deli-beradamente entrada incorrecta. aun cuando entrada provenga sensores otros sistemas, estos sistemas pueden estar equivocados proporcionar valores incorrectos. por consiguiente, siempre debe verificar validez las entradas tan pronto como éstas lean del entorno los programas operación. naturalmente, las comprobacio-nes implicadas dependen las mismas entradas, pero las posibles comprobaciones que pueden usarse son las siguientes: . comprobaciones rango puede esperar que las entradas estén dentro rango específico. por ejemplo, una entrada que represente una probabilidad debe -tar dentro del rango . .; una entrada que represente temperatura agua líquida debería estar entre grados celsius, etcétera. . comprobaciones tamaño puede esperar que las entradas sean número dado caracteres (por ejemplo, ocho caracteres para representar una cuenta bancaria). otros casos, tamaño quizá sea fijo, pero debe haber límite superior real. por ejemplo, improbable que nombre una persona tenga más caracteres. . comprobaciones representación cabe esperar que una entrada sea tipo particular, que representa forma estándar. por ejemplo, los nombres las personas incluyen caracteres numéricos, las direcciones correo electrónico constan dos partes, separadas por signo @, etcétera. . comprobaciones racionalidad una entrada una serie usted conoce algo sobre las relaciones entre los miembros ésta, entonces, podrá comprobar que valor entrada razonable. por ejemplo, valor entrada representa lec-tura del medidor electricidad doméstico, tal caso esperaría que cantidad energía eléctrica consumida sea casi misma que periodo correspondiente del año anterior. desde luego, habrá variaciones, pero diferencias orden magni-tud sugieren que surgió problema. las acciones que toman falla una comprobación validación entrada depen-den del tipo sistema que implementar. algunos casos, usuario reporta problema solicita reingreso del valor. cuando valor provenga sensor, puede usar valor válido más reciente. los sistemas embebidos tiempo real, quizá deba estimar valor con base historia, modo que sistema pueda continuar operación. lineamiento : proporcionar manejador para todas las excepciones durante ejecución del programa, inevitablemente ocurren errores eventos inespe- rados. éstos surgirían debido una falla desarrollo del programa podrían ser resultado circunstancias externas impredecibles. error evento inesperado que ocurre durante ejecución programa llama “excepción”. ejemplos excep-ciones son una falla eléctrica del sistema, intento por ingresar datos inexistentes, desbordamiento subdesbordamiento numéricos. -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad las excepciones suelen originarse por las condiciones del hardware software. cuando ocurre una excepción, debe ser gestionada por sistema. esto puede hacerse dentro del mismo programa realizar transferencia del control mecanis- manejo excepción del sistema. por regular, mecanismo gestión excepciones del sistema reporta error desactiva ejecución. por consiguiente, para garantizar que las excepciones programa causen falla sistema, hay que definir manejador excepciones para todas las posibles excepciones que surjan, asegurarse que todas las excepciones detecten manejen explícitamente. lenguajes programación como , deben usarse enunciados para detectar excepciones transferir control código manejo excepciones. esto significa que hay que comprobar explícitamente las excepciones que ocurran cualquier parte del programa. sin embargo, este enfoque agrega complejidad significativa tarea del manejo excepciones, cual aumenta las posibilidades que cometan errores , por consiguiente, que manejen inadecuadamente las excepciones. algunos lenguajes programación, como java, ++ ada, incluyen constructos que soportan manejo excepciones, además que necesitan enunciados condicio-nales adicionales para comprobar las excepciones. dichos lenguajes programación incluyen tipo interno especial (llamado con frecuencia exception), diferentes excep- ciones pueden declararse como este tipo. cuando ocurre una situación excepcional, señala excepción lenguaje del sistema tiempo ejecución transfiere control manejador excepciones. ésta una sección código que enuncia los nombres excepciones las acciones adecuadas para manejar cada una (figura .). observe que manejador excepciones está afuera del flujo control normal, que este flujo control normal reanuda después manejar excepción. los manejadores excepciones, por general, efectúan una más las siguientes tres acciones: . indicar componente nivel superior que ocurrió una excepción, brindar información dicho componente sobre tipo excepción. este enfoque usa cuando componente solicita otro, componente solicitante necesita saber componente solicitado ejecutó exitosamente. , queda manos del compo-nente solicitante tomar acciones para recuperarse del problema.sección código código manejo excepciónflujo control normal detección excepción salida normal procesamiento excepción figura . manejo excepción -.indd -.indd // :: // :: . ■ programación conﬁ able . realizar algún procesamiento alternativo que originalmente pretendía. así, manejador excepciones realiza algunas acciones para recuperarse del problema. entonces capaz continuar procesamiento normal, bien, manejador excepciones indica que ocurrió una excepción, modo que componente solici-tante está tanto del problema. . pasar control sistema apoyo tiempo ejecución que maneje excep-ción. con frecuencia esto sucede cuando ocurren fallas programa (por ejem-plo, cuando desborda valor numérico). acción común del sistema tiempo ejecución detener procesamiento. sólo debe usarse este enfoque cuando sea posible llevar sistema estado seguro inactivo, antes guiar control sistema tiempo ejecución. manejo excepciones dentro programa posibilita detección recupe-ración algunos errores entrada eventos externos inesperados. como tal, ofrece grado tolerancia falla: programa detecta las fallas toma acciones para recu-perarse ellas. como mayoría los errores entrada eventos externos inespe-rados por general son transitorios, menudo posible continuar operación normal después procesar excepción. lineamiento : minimizar uso sentencias proclives error las fallas los programas , por consiguiente, muchas fallas operación del pro-grama, comúnmente son consecuencia error humano. los programadores cometen errores porque pierden pista las numerosas relaciones entre las variables estado. escriben enunciados programa que dan como resultado comportamiento inespe-rado cambios estado del sistema. las personas siempre cometerán errores, pero finales década quedó claro que algunos enfoques programación tenían más probabilidad introducir errores programa que otros. algunos constructos lenguaje programación técnicas programación son inherentemente proclives error , por tanto, deben evitarse , menos, usarse mínimo que sea posible. los constructos potencialmente proclives error incluyen: . enunciados ramificación incondicional (-) los peligros los enuncia- dos - reconocieron desde (dijkstra, ) , consecuencia, exclu- yen los lenguajes programación modernos. sin embargo, todavía permiten lenguajes como . uso enunciados - conduce “código espagueti” que está enmarañado dificulta comprensión depuración. . números con punto flotante representación números con punto flotante una palabra memoria longitud fija inherentemente imprecisa. éste problema específico cuando los números comparan, porque imprecisión representa-ción conduce comparaciones inválidas. por ejemplo, . puede represen-tarse veces como . ocasiones como .. una comparación mostraría que son iguales. los números con punto fijo, donde número repre-senta número dado lugares decimales, por general son más seguros porque permiten comparaciones exactas. . apuntadores los lenguajes programación como ++ soportan sentencias bajo nivel llamados apuntadores, que retienen direcciones que refieren directamente -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad áreas memoria máquina (apuntan una ubicación memoria). los erro- res uso apuntadores suelen ser devastadores establecen manera -correcta , consecuencia, apuntan área memoria equivocada. también hacen más difícil implementación comprobaciones límites otras estructuras. . asignación memoria dinámica memoria del programa puede asignarse tiempo ejecución, vez tiempo compilación. peligro con esto que posible desasignar memoria adecuadamente, modo que con tiempo agota memoria disponible. quizás esto sea error muy difícil detectar, porque sistema podría operar exitosamente durante mucho tiempo antes que ocurra problema. . paralelismo cuando los procesos ejecutan concurrentemente, puede haber suti-les dependencias temporización entre ellos. los problemas temporización por general suelen detectarse mediante inspección del programa, tanto que combinación peculiar circunstancias que causan problema temporización quizá ocurra durante las pruebas sistema. paralelismo puede ser inevita-ble, pero uso tiene que controlarse cuidadosamente para minimizar las dependen-cias entre procesos. . recursión cuando procedimiento método solicita mismo solicita otro procedimiento, que entonces solicita procedimiento solicitante original, esto llama “recursión”. uso recursión puede derivar programas concisos; sin embargo, sería difícil seguir lógica los programas recursivos. por tanto, los errores programación son más difíciles detectar. los errores recursión podrían dar como resultado asignación toda memoria del sistema conforme crean variables pilas temporales. . interrupciones trata medio para forzar transferencia del control una sec-ción código, sin importar código ejecuta actualidad. los peligros esto son evidentes; interrupción llega provocar terminación una operación crítica. . herencia problema con herencia programación orientada objetos que código asociado con objeto está todo lugar. esto hace más difí-cil entender comportamiento del objeto. ahí que sea más probable que pierdan errores programación. más aún, cuando combina con enlaces dinámi-cos, herencia puede causar problemas temporización tiempo ejecución. diferentes instancias método pueden ligarse una petición, dependiendo los tipos parámetro. consecuencia, emplearán diferentes cantidades tiempo busca instancia del método correcto. . alias esto ocurre cuando usa más nombre para referirse misma entidad programa; por ejemplo, cuando dos apuntadores con diferentes nombres seña-lan misma ubicación memoria. fácil que los lectores del programa pierdan enunciados que cambian entidad cuando tienen varios nombres por considerar. . arreglos sin límites lenguajes como , los arreglos simplemente son formas acceder memoria usted puede hacer asignaciones más allá del final arre-glo. sistema tiempo ejecución comprueba que las asignaciones refieran realmente elementos arreglo. desbordamiento buffer, que atacante construye deliberadamente programa para escribir memoria más allá del final buffer implementado como arreglo, una conocida vulnerabilidad seguridad. -.indd -.indd // :: // :: . ■ programación conﬁ able . procesamiento entrada por defecto algunos sistemas ofrecen procesamiento entrada por defecto, sin importar entrada que presente sistema. éste hueco seguridad que atacante aprovecharía presentar programa con entradas inesperadas que rechaza sistema. algunos estándares para desarrollo sistemas seguridad críticos prohíben por completo uso estos constructos. sin embargo, tal posición extrema generalmente práctica. todos estos constructos técnicas son útiles, aunque deben usarse con cuidado. siempre que sea posible, sus efectos potencialmente riesgosos deben contro-larse mediante uso tipos datos abstractos objetos, que actúan como “firewalls” naturales que limitan daño causado ocurren errores. lineamiento : ofrecer capacidades reinicio muchos sistemas información organizacional basan transacciones cortas, las que procesamiento entradas del usuario tarda tiempo relativamente breve. dichos sistemas diseñan modo que los cambios base datos del sistema sólo finalizan después que todos los demás procesamientos completan con éxito. algo sale mal durante procesamiento, base datos actualiza , así, vuelve inconsistente. prácticamente todos los sistemas comercio electrónico (-commerce), donde uno sólo compromete con compra pantalla final, trabajan esta forma. las interacciones del usuario con los sistemas comercio electrónico duran por general algunos minutos requieren procesamiento mínimo. las transacciones base datos son breves con frecuencia completan menos segundo. sin embargo, otros tipos sistemas, como los sistemas cad los procesamiento texto, nece-sitan transacciones amplias. sistema transacción amplia, tiempo entre comen-zar usar sistema terminar trabajar tomaría varios minutos incluso horas. sistema falla durante una transacción larga, entonces podría perderse todo trabajo. igual modo, sistemas computacionalmente intensivos, como algunos sistemas ciencia electrónica (-science), tal vez requieran minutos horas procesamiento para completar cálculo. todo este tiempo pierde caso una falla del sistema. todos estos tipos sistemas debe proporcionar una capacidad reinicio, que basa conservación copias los datos que recopilan generan durante proce-samiento. instalación reinicio tiene que permitir sistema reiniciar mediante dichas copias, vez tener que comenzar todo desde principio. dichas copias conocen ocasiones como checkpoints (punto control verificación). por ejemplo: . sistema comercio electrónico pueden conservar copias los formularios llenados por usuario, permitir éste acceso envío dichos formularios sin tener que llenarlos nuevamente. . una transacción larga sistema computacionalmente intensivo pueden guardar automáticamente los datos cada determinada cantidad minutos , caso falla del sistema, reiniciar con los datos guardados más recientemente. también deben permitir errores usuario proporcionar una forma que los usuarios regresen checkpoint más reciente comiencen nuevo desde ahí. ocurre una excepción imposible continuar operación normal, puede mane-jar excepción mediante recuperación error hacia atrás. esto significa que resta- -.indd -.indd // :: // :: capítulo ■ ingeniería conﬁ abilidad blece estado del sistema estado guardado checkpoint reinicia ejecución partir dicho punto. lineamiento : comprobar los límites los arreglos todos los lenguajes programación permiten especificación arreglos: estructuras datos secuenciales los que accede través índice numérico. dichos arreglos suelen encontrar áreas contiguas dentro memoria operativa programa. los arreglos especifican tamaño particular, que refleja cómo usan. por ejem-plo, quieren representar las edades hasta , personas, entonces declara arreglo con , ubicaciones para contener los datos edad. algunos lenguajes programación, como java, siempre comprueban que, cuando ingresa valor arreglo, índice esté dentro dicho arreglo. este modo, arreglo está indexado ,, intento por ingresar valores los elementos [-] [] conducirá surgimiento una excepción. sin embargo, lengua-jes programación como ++ incluyen automáticamente comprobaciones límite arreglo sólo calculan corrimiento (offset) desde comienzo del arreglo. por consiguiente, [] accedería palabra que tuviera ubicación desde comienzo del arreglo, sin importar ésta era parte del arreglo . razón por que estos lenguajes incluyen comprobación automática límite arreglo que ello introduce una sobrecarga cada vez que accede arreglo. mayoría los accesos arreglo son correctos, modo que comprobación límite gene-ralmente innecesaria aumenta tiempo ejecución del programa. obstante, falta comprobación límites conduce vulnerabilidades seguridad, como desbordamiento buffer, que estudia capítulo . manera más general, introduce una vulnerabilidad sistema que puede derivar falla sistema. usa lenguaje que incluye comprobación límite arreglo, siempre debe incluir código adicional que garantice que índice del arreglo está dentro los límites. esto logra con facilidad implementar arreglo como tipo datos abstractos, como analizó lineamiento . lineamiento : incluir interrupciones cuando soliciten componentes externos los sistemas distribuidos, los componentes del sistema ejecutan diferentes computadoras las peticiones realizan través red componente com-ponente. para recibir algún servicio, componente pedirá componente . espera respuesta antes continuar ejecución. sin embargo, compo-nente falla responder por alguna razón, entonces componente continúa. tan sólo espera indefinidamente una respuesta. una persona que espere una respuesta del sistema observa una falla sistema silenciosa, sin respuesta del sistema. tiene alternativa más que aniquilar proceso espera reiniciar sistema. para evitar anterior, siempre hay que incluir interrupciones cuando soliciten componentes externos. una interrupción (timeout) una suposición automática que componente solicitado falló producirá una respuesta. define periodo durante cual espera recibir una respuesta componente solicitado. recibe una respuesta ese lapso, supone una falla retira control del componente solicitado. entonces puede tratar recuperarse falla indicar usuario del sistema que sucedió permitirle decidir qué hacer. -.indd -.indd // :: // :: pmlineamiento : nombrar todas las constantes que representan valores del mundo real todos los programas triviales incluyen número valores constantes que represen- tan los valores entidades del mundo real. dichos valores modifican conforme ejecuta programa. ocasiones, trata constantes absolutas que nunca cambian (por ejemplo, velocidad vuelo), sino que con más frecuencia son valores que cam-bian con relativa lentitud tiempo. por ejemplo, programa para calcular impuestos personales incluirá constantes que son las tasas impositivas actuales. esto cambia año otro , por consiguiente, programa debe actualizarse con los nuevos valores constantes. siempre debería incluir programa una sección donde mencionen todos los valores constantes que usan del mundo real. cuando utilizan las constantes, hay que referirse éstas por sus nombres por valor. esto tiene dos ventajas, cuanto concierne confiabilidad: . existe menos probabilidad cometer errores usar valor equivocado. fácil escribir mal número sistema con frecuencia podrá detectar error. por ejem-plo, suponga que una tasa fiscal del por ciento. error transposición simple llevaría que esto escribiera mal como por ciento. sin embargo, escribe mal nombre (como tasa fiscal estándar), esto usualmente detecta compilador como una variable sin declarar. . cuando cambia valor, hay que buscar través todo programa para des-cubrir dónde tiene que usar dicho valor. todo que necesita cambiar valor asociado con declaración constante. entonces, nuevo valor incluye automá-ticamente todas las partes donde necesite. puntos clave ■ confiabilidad programa puede lograrse evitar introducción fallas, detectar eliminar éstas antes implementación del sistema, incluir mecanismos tolerancia fallas que permitan sistema permanecer operacional después que una falla desarrollo causó una falla operación del sistema. ■ empleo redundancia diversidad hardware, los procesos software los sistemas software esencial para desarrollo sistemas confiables. ■ uso proceso repetible bien definido esencial las fallas sistema tienen que minimizarse. proceso debe incluir todas las etapas actividades verificación validación, desde definición requerimientos hasta implementación del sistema. ■ las arquitecturas sistema confiable son aquellas que diseñan para tolerancia fallas. existen algunos estilos arquitectónicos que soportan tolerancia fallas incluyen sistemas protección, arquitecturas automonitorización programación -versión. ■ diversidad software difícil lograr, que prácticamente imposible garantizar que cada versión del software sea verdad independiente.capítulo ■ puntos clave -.indd -.indd // :: // :: ■ programación confiable apoya inclusión redundancia programa, con finalidad verificar validez las entradas los valores las variables del programa. ■ algunas sentencias técnicas programación, como enunciados -, apuntadores, recursión, herencia números punto flotante, son inherentemente proclives error. hay que tratar evitar dichos constructos para desarrollar sistemas confiables. lecturas sugeridas software fault tolerance techniques and implementation . análisis global técnicas para lograr tolerancia fallas software arquitecturas tolerantes las fallas. libro también cubre temas generales confiabilidad del software. (. . pullum, artech house, .) “software reliability engineering: roadmap”. este ensayo por parte investigador líder fiabilidad del software resume vanguardia ingeniería fiabilidad del software, así como estudio futuros retos investigación. (. . lyu, proc. future software engineering, ieee computer society, .) http:/ /. doi. org/ . / fose. . . ejercicios .. mencione cuatro razones por las que difícilmente sería efectivo cuanto costo hecho que las compañías garanticen que software esté libre fallas. .. explique por qué razonable suponer que uso procesos confiables conducirá creación software confiable. .. ofrezca dos ejemplos actividades diversas redundantes que puedan incorporarse los procesos confiables. .. ¿cuál característica común todos los estilos arquitectónicos que conjuntan para soportar tolerancia fallas software? .. imagine que usted implementa sistema control basado software. sugiera circunstancias las cuales sería adecuado usar una arquitectura tolerante fallas explique por qué requeriría este enfoque. .. usted responsable del diseño conmutador comunicaciones que tiene que ofrecer disponibilidad /, pero que crítico para protección. ofrezca razones para respuesta sugiera estilo arquitectónico para dicho sistema. .. sugiere que software control para una máquina terapia radiación, usado para tratar pacientes con cáncer, debe implementarse mediante programación -versión. comente sobre considera que ésta una buena sugerencia . capítulo ■ ingeniería conﬁ abilidad -.indd -.indd // :: // :: pmcapítulo ■ referencias .. mencione dos razones por las que diferentes versiones sistema, basadas diversidad software, podrían fallar forma similar. .. explique por qué deben manejar explícitamente todas las excepciones sistema cuya intención lograr nivel disponibilidad alto. .. uso técnicas para producción software seguro, como estudió este capítulo, naturalmente incluye considerables costos adicionales. ¿qué costos adicionales justificarían vidas salvarían durante los años vida sistema? ¿los mismos costos justificarían salvaran vidas? ¿cuánto vale una vida? ¿las capacidades ingreso las personas afectadas hacen una diferencia este juicio? referencias avizienis, . (). “the -version approach fault-tolerant software”. ieee trans. software eng., - (), –. avizienis, . . (). “ methodology -version programming”. software fault tolerance. lyu, . . (.). chichester: john wiley & sons. –.boehm, . (). “get ready for agile methods, with care”. ieee computer, (), –. brilliant, . ., knight, . . leveson, . . (). “analysis faults -version software experiment”. ieee trans. software engineering, (), –. dijkstra, . . (). “goto statement considered harmful”. comm. acm., (), –. hatton, . (). “-version design versus one good version”. ieee software, (), –. knight, . . leveson, . . (). “ experimental evaluation the assumption independence multi-version programming”. ieee trans. software engineering., - (), –. leveson, . . (). safeware: system safety and computers. reading, mass.: addison-wesley.lindvall, ., muthig, ., dagnino, ., wallin, ., stupperich, ., kiefer, ., may, . kahkonen, . (). “agile software development large organizations”. ieee computer, (), –. parnas, . ., van schouwen, . shu, . . (). “evaluation safety-critical software”. comm. acm, (), –. pullum, . . (). software fault tolerance techniques and implementation . norwood, mass.: artech house.storey, . (). safety-critical computer systems. harlow, : addison-wesley.torres-pomales, . (). “software fault tolerance: tutorial.” http://ntrs.nasa.gov/archive/nasa/casi./.pdf. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo los temas que deben considerarse cuando diseñan sistemas aplicación segura. estudiar este capítulo: ■ comprenderá diferencia entre seguridad aplicación seguridad infraestructura; ■ identificará cómo valoración del riesgo del ciclo vida valoración del riesgo operativo permiten entender los conflictos seguridad que afectan diseño sistema; ■ tendrá cuenta las arquitecturas software los lineamientos diseño para desarrollo sistemas seguros; ■ aprenderá noción supervivencia del sistema por qué importante análisis supervivencia para sistemas software complejos. contenido . gestión del riesgo seguridad . diseño para seguridad . supervivencia del sistema ingeniería seguridad -.indd -.indd // :: // :: pmel uso extendido internet década planteó nuevo reto los ingenieros software: diseñar implementar sistemas que fueran seguros. conforme más más sistemas conectaban internet, emprendió una variedad ataques externos para amenazar estos sistemas. los problemas para generar sistemas confiables aumentaron considerablemente. los ingenieros sistemas debían tomar cuenta las amenazas atacantes maliciosos técnicamente hábiles, además los problemas resultantes erro-res accidentales proceso desarrollo. ahora esencial diseñar sistemas para soportar ataques externos recuperarse ellos. sin precauciones seguridad, casi inevitable que los atacantes comprometerán sistema red. los atacantes pueden hacer mal uso del hardware del sistema, robar datos confidenciales dificultar los servicios que ofrece sistema. por tanto, inge-niería seguridad sistemas aspecto cada vez más importante del proceso ingeniería sistemas. ingeniería seguridad interesa por desarrollo evolución los sistemas que pueden hacer frente ataques maliciosos, cuya intención perjudicar sistema los datos. ingeniería seguridad software parte más general del campo seguridad computacional. ésta convertido una prioridad para las compañías los individuos, pues más más transgresores tratan aprovecharse los sistemas red con propósitos ilícitos. los ingenieros software deben conocer tanto las amenazas seguridad que enfrentan los sistemas, como las formas las que posible neutrali-zar tales amenazas. intención este capítulo presentar ingeniería seguridad los ingenie-ros software, enfocándose los conflictos diseño que afectan seguridad aplicación. este apartado trata seguridad computadora conjunto cubre temas como encriptación, control acceso, mecanismos autorización, virus caballos troyanos, etcétera, sino que describe detalle textos generales sobre seguridad computacional (anderson, ; bishop, ; pfleeger pfleeger, ). capítulo suma análisis seguridad que presenta otras partes del libro. este material debe leerse junto con:  sección ., que explica cómo seguridad confiabilidad están estrechamente relacionadas;  sección ., que introduce terminología seguridad;  sección ., que expone noción general especificación dirigida por riesgo; sección ., que analiza los conflictos generales especificación reque- rimientos seguridad;  sección ., que describe algunos enfoques las pruebas seguridad. considerar los conflictos seguridad, debe contemplarse tanto software apli- cación ( sistema control, sistema información, etcétera) como infraestructura sobre que construye sistema (figura .). infraestructura para aplicaciones complejas incluye:  una plataforma sistema operativo, tal como linux windows;  otras aplicaciones genéricas que operan dicho sistema, tales como navegadores web clientes correo electrónico;  sistema gestión base datos;capítulo ■ ingeniería seguridad -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad  middleware, que soporta computación distribuida acceso base datos;  librerías componentes reutilizables, que usa software aplicación. mayoría los ataques externos enfocan infraestructuras sistema debido que los componentes infraestructura (por ejemplo, navegadores web) son bien conocidos ampliamente disponibles. los atacantes pueden probar dichos sistemas para localizar puntos débiles buscar información compartida sobre las vulnerabili-dades descubiertas. puesto que muchas personas usan mismo software, los ataques tienen amplia aplicabilidad. las vulnerabilidades infraestructura pueden conducir que los atacantes obtengan sin autorización acceso sistema aplicación los datos. práctica, existe una importante diferencia entre seguridad aplicación segu-ridad infraestructura: . seguridad aplicación problema ingeniería software; los ingenieros software deben asegurarse que sistema diseñó para soportar ataques. . seguridad infraestructura problema gestión que los administra-dores del sistema configuran infraestructura para resistir ataques. los adminis-tradores sistema deben configurar infraestructura con finalidad usar manera más efectiva cualquier característica seguridad infraestructura dispo-nible. también deben corregir las vulnerabilidades seguridad infraestructura que salgan luz conforme use software. gestión seguridad del sistema una tarea sencilla, sino que debe incluir rango actividades como gestión usuarios permisos, implementación manteni-miento del software del sistema, monitorización, detección recuperación ataque. . gestión usuarios permisos implica agregar eliminar usuarios del sistema, asegurar que coloquen mecanismos adecuados autenticación usuarios, configurar los permisos sistema forma que los usuarios sólo tengan acceso los recursos que necesitan. . implementación mantenimiento del software del sistema comprenden ins-talación del software middleware del sistema configurar éste manera ade-cuada, además evitar las vulnerabilidades seguridad. asimismo, incluyen lasistema operativoaplicaciones genéricas compartidas (navegadores, correo electrónico, etc.)gestión base datosmiddlewarecomponentes librerías reutilizablesaplicación figura . capas sistema donde puede comprometerse seguridad -.indd -.indd // :: // :: . ■ gestión del riesgo seguridad actualización regular este software con nuevas versiones parches, que reparen los problemas seguridad descubiertos. . monitorización del ataque, detección recuperación incluyen actividades que monitorizan sistema relación con acceso autorizado, detectan instauran estrategias para resistir ataques, así como actividades respaldo manera que, después ataque externo, pueda reanudarse operación normal. gestión seguridad tiene una importancia vital, pero suele considerarse como parte ingeniería seguridad aplicación. vez ello, este tipo inge-niería interesa por diseño sistema que sea tan seguro como sea posible, dadas las restricciones presupuestales uso. parte este proceso consiste “diseñar para administrar”, decir, diseñar sistemas para minimizar las probabilidades errores administración seguridad que permitan ataques sistema. sistemas control crítico sistemas embebidos, práctica normal seleccionar una infraestructura adecuada para apoyar sistema aplicación. por ejemplo, los desa-rrolladores sistemas embebidos eligen por general sistema operativo tiempo real que ofrezca aplicación embebida las facilidades que necesita. deben conside-rarse las vulnerabilidades conocidas los requerimientos seguridad, que significa que para ingeniería seguridad puede adoptarse enfoque holístico. los reque-rimientos seguridad aplicación implementan mediante infraestructura aplicación . sin embargo, los sistemas aplicación una organización por general implemen-tan utilizando infraestructura existente (sistema operativo, base datos, etcétera). por tanto, deben considerarse los riesgos utilizar dicha infraestructura las característi-cas seguridad como parte del proceso diseño del sistema. . gestión del riesgo seguridad para ingeniería seguridad efectiva son esenciales tanto valoración como ges-tión del riesgo seguridad. esta última encarga evaluar las posibles pérdidas que derivan ataques los activos sistema, equilibrar dichas pérdidas frente ataques internos ingeniería social los ataques internos son ataques sistema realizados por individuo confianza ( empleado organización) que abusa situación. por ejemplo, una enfermera que trabaja hospital puede tener acceso registros médicos confidenciales pacientes quienes atiende. los ataques internos son difíciles contrarrestar porque las técnicas adicionales seguridad que pudieran usarse afectarían los usuarios confiables del sistema. ingeniería social una forma engañar los usuarios acreditados para que muestren sus credenciales. consecuencia, atacante puede comportarse como empleado organización cuando ingresa sistema. http:// -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad los costos los procedimientos seguridad encaminados reducir las pérdidas. las compañías tarjetas crédito actúan continuamente esa forma. relativamente sencillo introducir nueva tecnología para reducir probabilidad fraude con las tar-jetas crédito. sin embargo, con frecuencia más económico que las empresas com-pensen los usuarios por sus pérdidas como consecuencia los fraudes, que comprar implementar tecnología que permita reducir estos últimos. conforme los costos disminu-yen aumentan los ataques, este balance puede cambiar. por ejemplo, las compañías tarjetas crédito ahora codifican información chip sobre tarjeta sobre banda magnética. esto hace que sea mucho más difícil copiar tarjeta. gestión del riesgo conflicto empresarial más que conflicto técnico, así que los ingenieros software son quienes deben decidir qué controles incluir sistema. responsabilidad los altos ejecutivos empresa decidir aceptan costo seguridad exponen las consecuencias una falta procedimientos seguridad. cambio, papel los ingenieros software ofrecer guía orientación técnica informada acerca conflictos seguridad. por tanto, ellos son participantes esenciales dentro del proceso gestión del riesgo. como explicó capítulo , una entrada crítica proceso valoración gestión del riesgo política seguridad organización. ésta aplica todos los sistemas establece que debe permitirse que . política seguridad esta-blece las condiciones que deben mantenerse siempre mediante sistema seguridad, además ayuda identificar los riesgos las amenazas que pudieran surgir. consecuen-cia, política seguridad define que permite que permite. proceso ingeniería seguridad diseñan los mecanismos para aplicar esta política. valoración del riesgo inicia antes decidir adquisición del sistema debe continuar largo del proceso desarrollo éste, después que pone uso (alberts dorofee, ). capítulo introdujo idea que esta valoración del riesgo proceso por etapas: . valoración preliminar del riesgo esta etapa aún toman decisiones sobre los requerimientos detallados del sistema, del diseño tecnología imple- mentación. meta este proceso valoración decidir puede lograrse nivel adecuado seguridad costo razonable. éste caso, entonces posible establecer requerimientos seguridad específicos para sistema. tiene información las vulnerabilidades potenciales sistema los controles que incluyen componentes reutilizados del sistema middleware. . valoración del riesgo del ciclo vida esta valoración del riesgo tiene lugar durante ciclo vida desarrollo del sistema, informe las decisiones técnicas diseño implementación del sistema. los resultados valoración pue-den conducir cambios los requerimientos seguridad agregar otros. iden-tifican las vulnerabilidades conocidas potenciales. este conocimiento emplea para toma decisiones informada sobre funcionalidad del sistema cómo ésta implementará, probará desplegará. . valoración del riesgo operativo después que sistema implementa pone operación, debe realizar una valoración del riesgo para tomar cuenta cómo usa sistema las propuestas para los nuevos cambiantes requerimientos. las suposiciones referentes los requerimientos operativos que hicieron cuando -.indd -.indd // :: // :: . ■ gestión del riesgo seguridad sistema especificaba pueden ser incorrectas. los cambios organización significan que sistema podría utilizarse diferentes formas las planeadas ori-ginalmente. por consiguiente, valoración del riesgo operativo conduce nuevos requerimientos seguridad que deben implementarse medida que evoluciona sistema. valoración preliminar del riesgo enfoca derivación requerimientos seguridad. capítulo mostró cómo puede derivarse conjunto inicial requerimientos seguridad partir una valoración preliminar del riesgo. esta sec-ción concentra valoración del riesgo del ciclo vida operacional, para ilustrar cómo especificación diseño sistema reciben influencia tecnología las formas como utiliza sistema. para realizar una valoración del riesgo, necesario identificar las posibles amenazas sistema. una forma hacerlo desarrollar conjunto “casos mal uso” (alexander, ; sindre opdahl, ). examinó cómo utilizar los casos uso, decir, las interacciones típicas con sistema, para derivar los requerimientos este último. los casos mal uso son escenarios que representan interacciones mali-ciosas con sistema. desarrollar casos mal uso posible analizar identificar posibles amenazas , por tanto, también determinar los requerimientos seguridad del sistema. pueden usarse junto con los casos uso para establecer los requerimientos del sistema. pfleeger pfleeger () clasifican las amenazas cuatro categorías, las cuales constituyen punto partida para identificar posibles casos mal uso. esas catego-rías son las siguientes: . amenazas intercepción, que permiten atacante conseguir acceso activo. este modo, posible caso mal uso para mhc-pms puede ser una situa-ción que atacante logra tener acceso los registros paciente que una celebridad. . amenazas interrupción, las cuales permiten atacante tomar parte indis-posición del sistema. por ejemplo, posible caso mal uso ataque nega-ción servicio servidor base datos del sistema. . amenazas modificación, que permiten atacante sabotear activo del sis-tema. mhc-pms, esto podría representarse con caso mal uso que atacante cambia información registro paciente. . amenazas fabricación, las cuales permiten atacante insertar información falsa sistema. posiblemente ésta una amenaza verosímil mhc-pms, pero sin duda sería una amenaza sistema bancario, donde podrían agre-garse transacciones falsas sistema para transferir dinero cuenta bancaria del transgresor. los casos mal uso sólo son útiles valoración preliminar del riesgo, sino también pueden usarse para analizar seguridad términos del riesgo del ciclo vida riesgo operativo. proporcionan una base útil para efectuar ataques hipotéticos sis-tema valorar las implicaciones seguridad las decisiones diseño realizadas. -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad .. valoración del riesgo del ciclo vida con base las políticas seguridad organización, valoración preliminar del riesgo debe identificar los requerimientos seguridad más importantes para sistema. ello refleja cómo debe implementar política seguridad dicha aplicación, permite identificar los activos proteger ayuda decidir qué enfoque podría usarse para ofrecer tal protección. mantener seguridad implica poner atención detalle. sin embargo, imposible que los requerimientos iniciales seguridad tomen cuenta todos los detalles que afectan seguridad. valoración del riesgo del ciclo vida identifica los detalles diseño imple-mentación que afectan seguridad. ésta diferencia importante entre valoración del riesgo del ciclo vida valoración preliminar del riesgo. valoración del riesgo del ciclo vida afecta interpretación los requerimientos seguridad existentes, genera nuevos requerimientos influye diseño global del sistema. cuando valoran riesgos esta etapa, indispensable tener información mucho más detallada sobre qué necesita proteger, también conocer algo referente las vul-nerabilidades del sistema. algunas estas vulnerabilidades serán inherentes las deci-siones que tomen materia diseño. por ejemplo, una vulnerabilidad todos los sistemas basados contraseñas que algún usuario autorizado revele contraseña otro usuario autorizado. bien, una organización tiene una política para desarrollar software , sabrá que aplicación puede tener vulnerabilidades, pues lenguaje incluye comprobación límite arreglo. valoración del riesgo seguridad debe ser parte las actividades del ciclo vida ingeniería, desde ingeniería requerimientos hasta implementación del sistema. proceso que sigue similar proceso valoración preliminar del riesgo con adición actividades concernientes identificación valoración vulnera-bilidad del diseño. resultado valoración del riesgo conjunto decisiones ingeniería que afectan diseño implementación del sistema, limitan forma que usa.estimación del valor del activo identificación amenazavaloración del ataquevaloración exposición cambios diseño requerimientosopciones tecnologíarepresentación organización del activo controles disponiblesidentificación control figura . análisis del riesgo del ciclo vida -.indd -.indd // :: // :: . ■ gestión del riesgo seguridad figura . muestra modelo del proceso análisis del riesgo del ciclo vida, basado proceso análisis preliminar del riesgo que describe figura .. diferencia más importante entre dichos procesos que ahora tiene información representación distribución información, así como organi-zación base datos para los activos alto nivel que deben protegerse. también está tanto importantes decisiones diseño, tales como software reutilizar, los controles protección infraestructura, etcétera. con base esta información, análisis permite identificar cambios necesarios los requerimientos seguridad diseño del sistema para brindar protección adicional los activos importantes del sistema. dos ejemplos ilustran cómo los requerimientos protección reciben influencia las decisiones concernientes representación distribución información: . posible tomar una decisión diseño para separar información personal paciente información los tratamientos recibidos mediante una clave que vin-cule ambos registros. información del tratamiento mucho menos sensible que información personal del paciente, manera que quizá necesite una protec-ción tan profunda. clave está protegida, entonces atacante sólo podrá tener acceso información rutina, sin poder vincular esto con los datos individuales paciente. . suponga que, comienzo sesión, toma una decisión diseño para copiar registros pacientes sistema cliente local. esto permite que trabajo continúe servidor está disponible. ello posibilita que empleado atención salud tenga acceso los registros los pacientes desde una laptop, incluso está disponible una conexión red. sin embargo, ahora tiene dos conjuntos regis-tros para proteger las copias del cliente están sujetas riesgos adicionales, como robo laptop. por tanto, habrá que pensar qué controles ayudarían reducir riesgo. por ejemplo, posible que deban encriptarse los registros del cliente laptop. para ilustrar cómo las decisiones sobre las tecnologías desarrollo influyen seguridad, suponga que proveedor atención salud decide construir mhc-pms mediante sistema información comercial para mantener registros pacien-tes. este sistema tiene que configurarse para cada tipo clínica que utilice. esta decisión toma porque parece ofrecer funcionalidad más amplia términos del costo desarrollo más bajo tiempo despliegue más rápido. cuando elabora una aplicación con reutilización sistema existente, deben aceptarse las decisiones diseño tomadas por los desarrolladores dicho sistema. suponga que algunas tales decisiones diseño son las siguientes: . los usuarios del sistema autentican través una combinación nombre/con- traseña acceso. existe otro método autenticación. . arquitectura del sistema cliente-servidor, los clientes acceden los datos mediante navegador web estándar una cliente. . información presenta los usuarios como formato web editable. ellos pue-den cambiar información lugar subir servidor información revisada. -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad para sistema genérico, estas decisiones diseño son perfectamente aceptables, pero análisis del riesgo del ciclo vida revela que tienen vulnerabilidades asociadas. figura . presentan ejemplos posibles vulnerabilidades. una vez identificadas las vulnerabilidades, debe tomarse entonces una decisión sobre qué pasos habrá que dar para reducir los riesgos asociados. con frecuencia, esto implicará toma decisiones respecto los requerimientos seguridad sistema adicional proceso operacional usar sistema. aun cuando aquí hay espacio para analizar todos los requerimientos que pueden proponerse examinar las vulnerabilidades inhe-rentes, algunos ejemplos requerimientos son los siguientes: . programa comprobación contraseña debe estar disponible funcionar con- tinuamente. las contraseñas los usuarios que aparezcan diccionario del sis-tema deben identificarse; los usuarios con contraseñas vulnerables deben reportarse los administradores del sistema. . acceso sistema sólo debe permitirse computadoras cliente que aprobaron registraron los administradores del sistema. . todas las computadoras cliente deben tener solo navegador web instalado, éste debe recibir aprobación los administradores del sistema. conforme use sistema comercial, será posible incluir verificador con-traseña sistema aplicación , manera que debe usar sistema separado. los verificadores contraseñas analizan fortaleza las contraseñas los usuarios cuando configuran, notifican los usuarios eligieron contraseñas vulnerables. por consiguiente, las contraseñas vulnerables pueden identificarse manera relativamente autenticación acceso/contraseñacontraseñas adivinables del conjunto usuariosusuarios autorizados revelan sus contraseñas usuarios autorizadosopción tecnología vulnerabilidades arquitectura cliente/ servidor que usa navegador webservidor sujeto ataque negación servicioinformación confidencial puede quedar caché navegador hueco seguridad navegador conduce acceso autorizado uso formatos editables webes imposible acceso cambios grano finola autorización puede variar acuerdo con rol del usuariofigura . vulnerabilidades asociadas con las opciones tecnología -.indd -.indd // :: // :: . ■ diseño para seguridad rápida después que configuraron, entonces será posible emprender una acción para garantizar que los usuarios cambien sus contraseñas. segundo requerimiento tercero significan que todos los usuarios siempre acce-derán sistema través del mismo navegador. puede decidir cuál navegador más seguro cuando sistema despliega instala todas las computadoras cliente. las actualizaciones seguridad simplifican porque hay necesidad actualizar diferentes navegadores cuando descubren corrigen vulnerabilidades seguridad. .. valoración del riesgo operativo valoración del riesgo seguridad podría continuar largo vida del sistema con finalidad identificar riesgos emergentes cambios sistema que puedan reque-rirse para lidiar con tales riesgos. este proceso llama valoración del riesgo operativo. probable que surjan nuevos riesgos debido requerimientos cambiantes del sistema, cam-bios infraestructura del sistema, cambios entorno donde utiliza sistema. proceso valoración del riesgo operativo similar proceso valoración del riesgo del ciclo vida, pero implica agregar más información acerca del entorno que emplea sistema. entorno importante porque sus características pue-den conducir sistema nuevos riesgos. por ejemplo, suponga que sistema usará entorno donde los usuarios son interrumpidos con frecuencia. riesgo que interrupción signifique que usuario deje prestar atención computadora. tal caso, posible que una persona autorizada consiga acceso información sistema. entonces esto podría generar requerimiento para que protector pantalla solicite una contraseña para operar después breve periodo inactividad. . diseño para seguridad general, cierto que resulta muy difícil adicionar seguridad sistema después que implementó. por tanto, deben tomar cuenta los riesgos seguridad durante proceso diseño del sistema. esta sección enfocará principalmente los conflictos del diseño sistema, porque, por regular, los libros seguridad computacional concede este tema atención que merece. los conflictos errores imple-mentación también tienen una gran repercusión sobre seguridad, pero éstos dependen normalmente tecnología específica utilizada. recomienda leer libro viega mcgraw (), como una buena introducción programación para seguridad. aquí enfoque será sobre algunos conflictos generales, independientes aplica-ción, relevantes para diseño sistemas seguros: . diseño arquitectónico: ¿cómo afectan las decisiones diseño arquitectónico seguridad sistema? . buena práctica: ¿qué acepta como buena práctica diseñar sistemas seguros? . diseño para implementación: ¿qué soporte debe diseñarse los sistemas para evi-tar introducción vulnerabilidades cuando sistema despliega para uso? -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad desde luego, éstos son los únicos conflictos diseño importantes para seguri- dad. toda aplicación diferente diseño seguridad también debe tomar cuenta propósito, carácter crítico entorno operacional aplicación. por ejemplo, diseña sistema militar, necesario adoptar modelo clasificación seguri-dad (secreto, ultrasecreto, etcétera). diseña sistema que mantiene información personal, debe considerarse legislación sobre protección datos que impone restric-ciones respecto cómo administra información. existe una relación estrecha entre confiabilidad seguridad. uso redundancia diversidad, que fundamental para lograr confiabilidad, puede significar que sis-tema resista recupere ataques dirigidos características diseños específicos implementación. mecanismos apoyo alto nivel disponibilidad pueden ayudar sistema recuperarse los llamados ataques negación servicio, los que meta del atacante hacer caer sistema detener funcionamiento correcto. diseñar sistema para que sea seguro implica inevitablemente compromiso. desde luego, posible desarrollar múltiples medidas seguridad sistema, las cuales reducirán las probabilidades que ataque logre cometido. sin embargo, las medidas seguridad requieren menudo una gran labor adicional computación , además, afectan rendimiento global sistema. por ejemplo, pueden reducir las posibilidades que muestre información confidencial encriptar dicha información. obstante, esto significa que los usuarios información tienen que esperar que ésta desencripte, cual hará más lento trabajo. también existen tensiones entre seguridad usabilidad. ocasiones, las medidas seguridad requieren que usuario recuerde proporcione información adicional (por ejemplo, contraseñas múltiples). sin embargo, algunas veces usuario olvida dicha infor-mación, manera que seguridad adicional significa que puede usar sistema. por consiguiente, los diseñadores deben encontrar equilibrio entre seguridad, rendimiento usabilidad. esto dependerá del tipo sistema dónde utilizará. por ejemplo, sistema militar, los usuarios están familiarizados con los sistemas alta seguridad, también están deseosos aceptar seguir procesos que requieren comprobaciones perió-dicas. sin embargo, sistema comercio acciones, las interrupciones opera-ción para comprobaciones seguridad serían completamente inaceptables. .. diseño arquitectónico como estudió capítulo , elección arquitectura software puede tener profundos efectos sobre las propiedades emergentes sistema. usa una arqui-tectura inadecuada, tal vez sea muy difícil mantener sistema confidencialidad ataques negación servicio los ataques negación servicio tratan derrumbar sistema red bombardearlo con enorme número peticiones servicio. esto supone una carga adicional sobre sistema, para cual está diseñado, excluye las peticiones legítimas servicio. consecuencia, sistema puede volverse inaccesible porque cae ante enorme carga, bien, los administradores del sistema deben sacarlo línea para detener flujo peticiones. http:// -.indd -.indd // :: // :: . ■ diseño para seguridad integridad información, garantizar nivel requerido disponibilidad del sis- tema. diseñar una arquitectura sistema que conserve seguridad, deben considerar dos temas fundamentales: . protección: ¿cómo debe organizarse sistema manera que puedan protegerse los activos críticos contra ataques externos? . distribución: ¿cómo deben distribuirse los activos del sistema manera que sean mínimos los efectos ataque? estos temas son potencialmente conflictivos. colocan todos los activos lugar, entonces posible construir capas protección torno ellos. puesto que debe construir solo sistema protección, posible costear sistema fuerte con muchas capas protección. pesar ello, dicha protección fracasa, entonces todos los activos estarán comprometidos. añadir más capas protección también afecta usabilidad sistema, que puede significar que sea más difícil satisfacer los reque-rimientos usabilidad rendimiento del sistema. por otra parte, distribuyen los activos, será más costoso protegerlos, que deben implementarse sistemas protección para cada copia. normalmente, posi-ble costear tantas capas protección. hay más posibilidades que protección rompa. pero, esto sucede, habrá una pérdida total. posible duplicar distribuir activos información manera que, una copia corrompe inaccesible, puede usarse entonces otra copia. obstante, información confidencial, con-servar copias adicionales aumenta riesgo que intruso obtenga acceso esta información. para sistema registros pacientes, adecuado usar una arquitectura base datos centralizada. para brindar protección, emplea una arquitectura capas con los activos críticos protegidos nivel más bajo del sistema, con varias capas protección torno ellos. figura . ilustra esto para sistema registros pacientes que los activos críticos proteger son los registros individuales cada paciente. atacante quiere tener acceso los registros pacientes modificarlos, debe penetrar tres capas del sistema: . protección nivel plataforma nivel superior controla acceso plata- forma donde opera sistema registro pacientes. por general, esto implica ingreso usuario una computadora particular. plataforma también incluirá comúnmente soporte para mantener integridad los archivos sistema, res-paldos, etcétera. . protección nivel aplicación siguiente nivel protección construye aplicación . implica acceso usuario aplicación, autenticación obtención permiso para realizar acciones como ver modificar datos. puede estar disponible soporte gestión integridad específico aplicación. . protección nivel registro este nivel demanda cuando requiere acceso registros específicos, incluye comprobar que usuario está autorizado para reali-zar las operaciones solicitadas sobre tal registro. protección este nivel también -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad podría implicar encriptado para garantizar que sea imposible consultar los registros utilizando navegador archivo. comprobación integridad mediante sumas verificación criptográficas, por ejemplo, permite detectar cambios que hayan realizado fuera los mecanismos normales actualización registro. número capas protección que necesitan cualquier aplicación particular depende del carácter crítico los datos. todas las aplicaciones requieren protección nivel registro , por tanto, usa comúnmente control acceso grano más grueso. para lograr seguridad, debe permitirse uso las mismas credenciales usuario cada nivel. ideal sería que tiene sistema basado contraseñas, entonces contraseña aplicación debe ser diferente tanto contraseña del sistema como contraseña nivel registro. sin embargo, difícil que los usuarios recuerden múltiples contraseñas encuentran molestas las reiteradas peticiones autenticación. por ende, con frecuencia tendrá que comprometer seguridad favor usabili-dad del sistema. protección datos requerimiento crítico, debe usarse tal caso una arquitectura cliente-servidor, con los mecanismos protección construidos servi-dor. obstante, compromete protección, probable que las pérdidas asociadas con ataque sean altas, igual que los costos recuperación (por ejemplo, tienen que emitirse nuevamente todas las credenciales usuario). sistema vulnerable los ataques negación servicio, que sobrecargan servidor hacen imposible que alguien acceda base datos del sistema. considera que los ataques negación servicio son riesgo mayor, puede optar por una arquitectura objeto distribuida para aplicación. esta situación, que ilustra figura ., los activos del sistema distribuyen través algunas pla-taformas diferentes, con mecanismos protección separados para cada una ellas. protección nivel plataforma protección nivel aplicación protección nivel registro registros pacientesautenticación del sistemagestión integridad archivos gestión integridad del registroingreso base datosautorización base datosgestión transacciónrecuperación base datos autorización acceso registroencriptado del registroautorización del sistema figura . arquitectura protección capas -.indd -.indd // :: // :: . ■ diseño para seguridad ataque nodo puede significar que algunos activos estén disponibles, pero toda- vía posible ofrecer algunos servicios del sistema. posible duplicar datos través los nodos sistema, forma que simplifica recuperación ataques. figura . muestra arquitectura sistema bancario para comerciar acciones fondos los mercados nueva york, londres, frankfurt hong kong. sistema distribuido, así que los datos cada mercado mantienen por separado. los activos requeridos para soportar actividad crítica comercio acciones (cuentas usua-rios precios) duplican están disponibles todos los nodos. nodo del sistema sufre ataque deja estar disponible, actividad crítica del comercio acciones puede transferirse otro país , por tanto, seguir disponible para los usuarios. habló del problema encontrar equilibrio entre seguridad rendimiento del sistema. problema diseño seguro del sistema que muchos casos estilo arqui-tectónico, que más adecuado para satisfacer los requerimientos seguridad, tal vez sea mejor para satisfacer los requerimientos rendimiento. por ejemplo, suponga que una aplicación tiene requerimiento absoluto para mantener confidencialidad una datos acciones europeashistoria del comercio europeo precios internacionales accionesdatos fondos europeoscuentas usuarios europeoscuentas internacionales usuariossistema comercio frankfurtautenticación autorización datos acciones asiáticashistoria comercial precios internacionales accionesdatos fondos asiáticoscuentas usuarios hkcuentas internacionales usuariossistema comercio hong kongautenticación autorizacióndatos acciones euahistoria del comercio eua precios internacionales accionesdatos fondos euacuentas usuarios euacuentas internacionales usuariossistema comercio nueva yorkautenticación autorización datos acciones del ruhistoria del comercio del precios internacionales accionesdatos fondos del rucuentas usuarios del rucuentas internacionales usuariossistema comercio londresautenticación autorización figura . activos distribuidos sistema comercio acciones -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad gran base datos, otro requerimiento para acceso muy rápido dichos datos. alto nivel protección sugiere necesidad capas protección, que significa que debe haber comunicaciones entre las capas del sistema. esto tiene una inevitable sobrecarga rendimiento, que hace más lento acceso los datos. usa una arquitectura alternativa, entonces quizá sea más difícil costoso implementar protección garantizar confidencialidad. ante tal situación, necesario discutir los conflictos inherentes con cliente del sistema acordar cómo resolverán. .. lineamientos diseño existen reglas rígidas rápidas sobre cómo lograr seguridad del sistema. diferentes tipos sistemas requieren distintas medidas técnicas para lograr nivel seguridad que sea aceptable para propietario del sistema. las actitudes los requerimientos diversos grupos usuarios afectan profundamente que aceptable que . por ejemplo, banco, probable que los usuarios acepten alto nivel seguri-dad, más procedimientos seguridad anti-intrusos comparación con los usuarios una universidad. sin embargo, existen lineamientos generales con amplia aplicabilidad diseñar solu-ciones seguridad sistema, los cuales encapsulan buenas prácticas diseño para ingeniería sistemas seguros. los lineamientos generales diseño para seguridad, como los que analizan más adelante, tienen dos usos principales: . ayudan crear conciencia acerca los temas seguridad equipo inge- niería software. los ingenieros software enfocan con frecuencia meta corto plazo hacer software operativo entregarlo los clientes. para ellos fácil pasar por alto los temas seguridad. conocimiento dichos lineamien-tos puede significar que los temas seguridad consideren cuando toman las decisiones diseño software. . pueden usarse como una lista verificación que será útil proceso valida-ción del sistema. partir los lineamientos nivel superior estudiados aquí, posible derivar cuestiones más específicas que examinen cómo sometió inge-niería seguridad sistema. los lineamientos diseño, que resumen figura ., resultaron varias fuentes (schneier, ; viega mcgraw, ; wheeler, ). aquí enfoque sobre los lineamientos que son aplicables particular los procesos especificación diseño del software. principios más generales, como “asegura vínculo más débil del sistema”, “hazlo simple” “evita seguridad mediante oscuridad” también son importan-tes, pero menos relevantes directamente para toma decisiones ingeniería. lineamiento : decisiones seguridad con base una política explícita seguridad una política seguridad enunciado alto nivel que establece las condiciones fundamentales seguridad para una organización. define “qué” seguridad lugar del “cómo”, manera que política debe definir los mecanismos usar para -.indd -.indd // :: // :: . ■ diseño para seguridad ofrecer seguridad reforzarla. inicio, todos los aspectos políticos seguridad deben reflejarse los requerimientos del sistema. práctica, especial usa proceso rápido desarrollo aplicación, improbable que esto suceda. por tanto, los diseñadores deben consultar política seguridad, que ésta constituye marco para tomar evaluar las decisiones diseño. por ejemplo, suponga que diseña sistema control acceso para mhc-pms. política seguridad del hospital puede establecer que sólo personal médico acreditado está autorizado para modificar los registros electrónicos los pacientes. ahí que sistema deba incluir mecanismos que comprueben acreditación cual-quiera que intente modificar sistema, que rechacen modificaciones personas acreditadas. problema que enfrenta que muchas organizaciones tienen una política explícita seguridad sistemas. con tiempo, pueden hacerse cambios los sistemas respuesta problemas identificados, aunque sin documento política global que guíe evolución sistema. ante tales situaciones, requiere trabajar documentar política partir ejemplos, confirmarla con los administradores compañía. lineamiento : evite solo punto falla cualquier sistema crítico, una buena práctica diseño tratar evitar solo punto falla. esto significa que una sola falla parte del sistema debe dar por resultado una falla global del sistema. términos seguridad, significa que debe apoyarse solo mecanismo para garantizar seguridad; vez ello, deben emplear muchas técnicas diferentes. ocasiones esto conoce como “defensa profundidad”. por ejemplo, solicita una contraseña para autenticar los usuarios sistema, también puede incluirse mecanismo autenticación pregunta/respuesta donde los usuarios deban registrar previamente preguntas respuestas sistema. después autenticación contraseña, deben responder correctamente las preguntas antes que lineamientos seguridad . decisiones seguridad con base una política explícita seguridad. . evite solo punto falla. . seguridad caso falla. . equilibrio entre seguridad usabilidad. . registre las acciones del usuario. . use redundancia diversidad para reducir riesgo. . valide todas las entradas. . compartimente sus activos. . diseñe para implementar. . diseñe para facilitar recuperabilidad.figura . lineamientos diseño para ingeniería sistemas seguros -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad les permita acceso. para proteger integridad los datos sistema, hay que mantener una bitácora ejecutable los cambios realizados los datos (véase linea-miento ). caso una falla, podrá reproducirse bitácora para recrear conjunto datos. también conveniente hacer una copia todos los datos que modifiquen antes realizar algún cambio. lineamiento : seguridad caso falla las fallas son inevitables todos los sistemas , misma forma que los sistemas críticos protección siempre deben ser prueba fallas, los sistemas críticos para seguridad siempre deben ser “seguros caso falla”. cuando falle sistema, deben usar procedimientos estado emergencia que sean menos seguros que sis-tema . falla del sistema tampoco debe significar que atacante acceda datos los que normalmente tendría acceso. por ejemplo, sistema información pacientes sugiere requerimiento que los datos los pacientes deben descargarse sistema cliente comienzo una sesión clínica. esto acelera acceso significa que acceso posible servidor está disponible. por general, servidor borra estos datos final sesión clíni-. sin embargo, servidor falla, entonces existe posibilidad que información conserve cliente. método seguridad caso falla dichas circunstan-cias consiste encriptar todos los datos almacenados los pacientes cliente. esto significa que usuario autorizado podrá leer los datos. lineamiento : equilibrio entre seguridad usabilidad las demandas seguridad usabilidad menudo son contradictorias. para hacer seguro sistema, debe introducir comprobaciones que los usuarios están autorizados para utilizar sistema que actúan concordancia con políticas seguras. inevitablemente, todo ello supone hacer peticiones los usuarios: deben recordar nombres contraseñas acceso, usar solamente sistema ciertas computadoras, etcétera. esto significa que los usuarios tardan más tiempo para iniciar sistema usarlo manera efectiva. conforme agregan características seguridad sistema, inevitable que éste vuelva menos usable. recomienda lectura del libro cranor garfinkel (), que examina amplio rango conflictos área general seguridad usabilidad. llega punto que contraproducente seguir agregando nuevas caracterís-ticas seguridad costa usabilidad. por ejemplo, requiere que los usuarios ingresen múltiples contraseñas que cambien sus contraseñas intervalos frecuentes por cadenas caracteres imposibles recordar, simplemente anotarán algún lugar dichas contraseñas. atacante ( especial uno interno) podría encontrar las contrase-ñas que anotaron así conseguir acceso sistema. lineamiento : registre las acciones del usuario prácticamente posible hacerlo, debe mantener siempre una bitácora las acciones del usuario. esta bitácora, menos, debe registrar quién hizo qué, los activos que utilizó, hora fecha acción. como explicó lineamiento , mantiene esto como lista comandos ejecutables, tendrá opción reproducir bitácora para recuperarse las fallas. desde luego, también necesita herramientas que permitan analizar bitácora detectar acciones potencialmente anómalas. dichas herramientas pueden esca- -.indd -.indd // :: // :: . ■ diseño para seguridad near bitácora descubrir las acciones anómalas, además ayudar detectar ataques rastrear cómo atacante consiguió acceso sistema. además ayudar recuperarse falla, una bitácora acciones del usuario útil porque actúa como disuasivo los ataques internos. las personas saben que sus acciones registran, entonces menos probable que intenten actuar formas autorizadas. esto más efectivo para ataques casuales, como una enfermera que busca registros pacientes, para detectar ataques donde robaron credenciales usuario legí-timas mediante ingeniería social. desde luego, esto infalible, que los internos técni-camente habilidosos también pueden tener acceso bitácora modificarla. lineamiento : use redundancia diversidad para reducir riesgo redundancia significa conservar más una versión del software los datos sistema. diversidad, cuando aplica software, significa que las diferentes versiones deben apoyarse misma plataforma implementarse usando las mismas tecno-logías. por tanto, una vulnerabilidad plataforma tecnología afectará todas las versiones , consecuencia, conducirá una falla común. capítulo explicó cómo redundancia diversidad son mecanismos fundamentales que usan ingeniería confiabilidad. estudiaron ejemplos redundancia: mantener información pacientes tanto servidor como cliente, primero sistema atención salud mental, luego sistema distribuido comercio acciones que muestra figura .. sistema registro pacientes, podría usar varios sistemas operativos cliente servidor (por ejemplo, linux servidor, windows cliente). esto garantiza que ataque basado una vulnerabilidad sistema operativo afectará tanto servidor como cliente. desde luego, habrá que negociar tales beneficios contra creciente costo administrativo mantener diferentes sistemas operativos una orga-nización. lineamiento : valide todas las entradas ataque común sistema implica proporcionar sistema entradas inesperadas que hacen que comporte forma anticipada. esto simplemente puede causar caída sistema, que deriva pérdida servicio, bien, las entradas podrían constituir código malicioso que ejecute sistema. las vulnerabilidades desborda-miento buffer, que primero demostraron gusano internet (spafford, ) que utilizan comúnmente los atacantes (berghel, ), pueden activarse mediante cade-nas largas entrada. otro ataque bastante común llamado “envenenamiento sql”, que usuario malicioso ingresa fragmento sql que interpreta servidor. como explicó capítulo , posible evitar muchos estos problemas diseñar validación entrada sistema. esencia, nunca debe aceptar cualquier entrada sin aplicar algunas verificaciones. como parte los requerimientos, tiene que definir las comprobaciones que apliquen. debe usar conocimiento entrada para definir dichas comprobaciones. por ejemplo, ingresa sobrenombre, puede comprobar que existen espacios embebidos que único signo puntuación uti-lizado guión. también puede verificar número caracteres entrada recha-zar las entradas muy largas. por ejemplo, nadie tiene nombre familiar con más caracteres direcciones con más caracteres largo. usa menús para pre-sentar entradas permitidas, evitará algunos los problemas validación entrada. -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad lineamiento : compartimente sus activos compartimentar significa que debe permitir acceso información sistema con criterio todo nada. vez ello, debe organizar compartimentos información sistema. los usuarios sólo deben tener acceso información que necesitan, toda información sistema. esto significa que posible que los efectos ataque contengan. tal vez pierda dañe alguna información, pero improbable que resulte afectada toda información sistema. por ejemplo, sistema información pacientes, debe diseñar sistema manera que, cualquier clínica, personal hospitalario tenga normalmente sólo acceso los registros los pacientes que tienen una cita esa clínica. por general, deben tener acceso todos los registros pacientes sistema. esto sólo limita pérdida potencial ataques internos, sino también significa que, intruso roba sus creden-ciales, cantidad daño que pueda causar será limitada. por otro lado, tal vez también deba tener mecanismos sistema para garantizar acceso inesperado, por ejemplo, paciente seriamente enfermo que requiere tra-tamiento urgente sin tener cita. tales circunstancias, puede usar algún mecanismo seguro alternativo para superar compartimentación sistema. esas situaciones, donde seguridad relaja para mantener disponibilidad del sistema, esencial con-tar con mecanismo acceso para registrar uso del sistema. siendo así, puede comprobar las bitácoras con finalidad rastrear cualquier uso autorizado. lineamiento : diseñe para implementar muchos problemas seguridad surgen porque sistema está configurado correctamente implementarse entorno operacional. por tanto, siempre debe diseñar sistema forma que incluyan instalaciones para simplificar implementación entorno del cliente, comprobar errores omisiones potenciales configuración sistema imple-mentado. éste tema importante, que analiza detalle sección ... lineamiento : diseñe para facilitar recuperabilidad sin importar cuánto esfuerzo use mantener seguridad los sistemas, siempre debe diseñar sistema con idea que podría ocurrir una falla seguridad. ahí que deba pensar cómo recuperarse posibles fallas restaurar sistema estado operativo seguro. por ejemplo, podría incluir sistema autenticación respaldo caso que comprometa autenticación contraseña. suponga que una persona autorizada, externa clínica, consigue acceso sis-tema registros los pacientes, usted sabe cómo obtuvo una combinación nombre contraseña válida. necesita reiniciar sistema autenticación sólo cam-biar las credenciales usadas por intruso. esto esencial, porque intruso también puede conseguir acceso otras contraseñas usuario. por tanto, preciso asegurarse que todos los usuarios autorizados cambien sus contraseñas. también debe cercio-rarse que persona sin autorización tiene acceso mecanismo cambio contraseñas. consecuencia, debe diseñar sistema para negar acceso todos (hasta que cambien sus contraseñas autentique los usuarios reales para cambiar contra-seña), suponer que sus contraseñas seleccionadas pueden ser seguras. una forma hacer esto mediante mecanismo pregunta/respuesta, donde los usuarios deben responder preguntas para las cuales tienen respuestas previamente registradas. esto sólo -.indd -.indd // :: // :: . ■ diseño para seguridad solicita cambiar las contraseñas, que permite recuperación ataque con relativamente poca perturbación del usuario. .. diseño para implementar implementación sistema implica configurar software para funcionar entorno operacional, instalar sistema las computadoras ese entorno , poste-riormente, configurar sistema instalado para dichas computadoras (figura .). configuración puede ser proceso simple que implique establecer algunos parámetros internos software para reflejar las preferencias del usuario. sin embargo, ocasio-nes, configuración compleja requiere definición específica los modelos las reglas empresariales que afectan ejecución del software. con frecuencia, esta etapa del proceso introducen accidentalmente vulnerabili-dades software. por ejemplo, durante instalación, software tiene menudo que configurarse con una lista usuarios permitidos. cuando esta lista entrega, consta simplemente acceso administrador genérico como “admin” una contraseña por defecto, como “password”. anterior facilita que administrador configure sis-tema. primera acción debe ser introducir nuevo nombre acceso contraseña, borrar nombre acceso genérico. obstante, fácil olvidar hacer esto. atacante que conozca acceso por defecto podrá obtener acceso privilegiado sistema. configuración implementación ven menudo como temas administración del sistema , por consiguiente, consideran fuera del ámbito los procesos ingenie-ría software. desde luego, buena práctica administrativa ayuda evitar muchos problemas seguridad que surgen errores configuración implementación. sin embargo, los diseñadores software tienen responsabilidad “diseñar para imple-mentación”. siempre debe brindar soporte interno para implementación, cual reducirá probabilidad que los administradores del sistema ( usuarios) cometan errores configurar software. recomiendan cuatro formas incorporar soporte implementación sis-tema: . incluir soporte para ver analizar las configuraciones siempre conveniente adicionar instalaciones sistema que permitan los administradores los usuarios examinar configuración actual del sistema. manera sorprendente, esta facilidad está ausente mayoría los sistemas software, los usuarios frustran ante las dificultades encontrar parámetros configuración. por ejemplo, versión del procesador texto que usó para escribir este capítulo, impo-sible ver imprimir una sola pantalla los parámetros todas las preferencias del sistema. obstante, administrador capaz obtener una imagen completa comprender definir entorno operacional del software configurar software con detalles del entornoinstalar software las computadoras donde operará configurar software con detalles computadora figura . implementación del software -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad una configuración, más probable que especifique los errores las omisiones. ideal que una pantalla configuración también pueda destacar los aspectos configuración que sean potencialmente inseguros, por ejemplo, esta-bleció una contraseña. . minimizar los privilegios por defecto software debe diseñarse forma que configuración por defecto sistema ofrezca mínimos privilegios esenciales. esta forma, daño que cualquier atacante pudiera hacer quedará limitado. por ejemplo, autenticación por defecto del administrador del sistema sólo debe per-mitir acceso programa que permita administrador establecer nuevas credenciales. debe prohibir acceso alguna otra instalación del sistema. una vez establecidas las nuevas credenciales, deben borrarse automáticamente por defecto nombre contraseña. . localizar parámetros configuración cuando diseñe soporte para configu-ración del sistema, habrá que asegurarse que todo una configuración que afecte misma parte sistema configure mismo lugar. nuevamente con ejemplo del procesador texto, versión que utilizó, pudo configurarse alguna información seguridad, como una contraseña para controlar acceso documento, menú preferencias/seguridad. otra información configura menú herramientas/proteger documento. localiza información con-figuración, fácil olvidar configurarla , algunos casos, siquiera estará tanto que sistema incluyen algunas instalaciones seguridad. . proporcionar formas sencillas corregir vulnerabilidades seguridad hay que incluir mecanismos directos para actualizar sistema reparar las vulnerabilidades seguridad que hayan descubierto. éstos podrían incluir comprobación auto-mática para actualizaciones seguridad, descarga dichas actualizaciones tan pronto como estén disponibles. importante que los usuarios puedan pasar por alto dichos mecanismos pues, inevitablemente, considerarán otro trabajo como más importante. existen muchos ejemplos registrados problemas seguridad mayores que surgen (por ejemplo, falla completa una red hospitalaria) porque los usuarios actualizaron software cuando les pidió que hicieran. . supervivencia del sistema hasta momento, estudió ingeniería seguridad desde perspectiva una apli-cación que está bajo desarrollo. proveedor desarrollador del sistema tienen control sobre todos los aspectos del sistema que pudieran atacarse. realidad, como sugiere figura ., los modernos sistemas distribuidos apoyan necesariamente una infraestructura que incluye sistemas comerciales componentes reutilizables desarrolla-dos por diferentes organizaciones. seguridad dichos sistemas depende sólo las decisiones diseño locales, sino también seguridad aplicaciones externas, servicios web infraestructura red. esto significa que, sin importar cuánta atención ponga seguridad, posible garantizar que sistema podrá resistir ataques externos. consecuencia, para sistemas complejos red, debe suponerse que posible penetración que integridad del sistema está garantizada. por tanto, debe pensar cómo hacer que sistema sea resistente, manera que sobreviva para entregar servicios esenciales los usuarios. -.indd -.indd // :: // :: . ■ supervivencia del sistema supervivencia resiliencia (westmark, ) una propiedad emergente sistema como totalidad, una propiedad componentes individuales, que mis-mos podrían ser supervivientes. supervivencia sistema refleja capacidad para continuar entrega servicios empresariales esenciales críticos para misión, para legitimar los usuarios mientras está bajo ataque después que dañó parte del sistema. daño podría ser causado por ataque una falla del sistema. trabajo supervivencia del sistema apunta hecho que las vidas económica social dependen una infraestructura crítica controlada por computadoras. ésta incluye infraestructura para entregar servicios públicos (electricidad, agua, gas, etcétera) infra-estructura para entregar gestionar información (teléfonos, internet, servicio postal, etcé-tera). sin embargo, supervivencia simplemente asunto crítico infraestructura . cualquier organización que apoye sistemas cómputo críticos red debe interesarse por forma como resultaría afectada sus sistemas sobreviven ataque malicioso una falla catastrófica del sistema. por tanto, para sistemas empresariales críticos, análisis diseño supervivencia deben ser parte del proceso ingeniería seguridad. conservar disponibilidad los servicios críticos esencia supervivencia. esto significa que usted debe conocer:  los servicios del sistema más críticos para una empresa;  calidad mínima del servicio preservar; cómo pueden comprometerse dichos servicios; cómo pueden protegerse tales servicios; cómo recuperarse rápidamente los servicios dejan estar disponibles. por ejemplo, sistema que administra salida ambulancias respuesta llamadas emergencia, los servicios críticos son aquellos relacionados con recepción llamadas envío ambulancias emergencia médica. otros servicios, como registro las llamadas administración ubicación las ambulancias, son menos críticos, sea porque requieren procesamiento tiempo real porque exis-ten mecanismos alternativos. por ejemplo, para encontrar ubicación una ambulan-cia posible llamar personal unidad preguntarle ubicación. ellison sus colaboradores (; ; ) diseñaron método análisis llamado survivable systems analysis (análisis sistemas supervivientes). usa para valorar las vulnerabilidades los sistemas apoyar diseño arquitecturas caracte-rís ticas los sistemas que promueven supervivencia éstos. estos investigadores argumentan que logro supervivencia depende tres estrategias complementarias: . resistencia evitar los problemas mediante construcción capacidades sistema para repeler ataques. por ejemplo, sistema puede usar certificados digi-tales para autenticar los usuarios, que dificulta hecho que usuarios autorizados tengan acceso. . reconocimiento detectar los problemas mediante construcción capacidades sistema para descubrir ataques fallas, además valorar daño resultante. por ejemplo, podrían asociarse sumas verificación con datos críticos, manera que pueda detectarse corrupción los datos. . recuperación tolerar los problemas por medio construcción capacidades sistema para entregar servicios esenciales mientras está bajo ataque, recuperar -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad funcionalidad plena después ataque. por ejemplo, los mecanismos tolerancia fallas desarrollo que usan diversas implementaciones misma funcionali-dad pueden incluirse para lidiar con una pérdida servicio una parte del sistema. análisis sistemas supervivientes proceso cuatro etapas (figura .), que analiza los requerimientos arquitectura actual las propuestas del sistema; iden-tifica servicios críticos, escenarios ataque “puntos débiles” del sistema, propone cambios para mejorar supervivencia sistema. las actividades clave cada una dichas etapas son las siguientes: . comprensión del sistema para sistema existente propuesto, revisan las metas del sistema (llamadas ocasiones “objetivos misión”), los requerimien-tos arquitectura del sistema. . identificación servicios críticos identifican los servicios que siempre deben mantenerse los componentes que requieren para conservar dichos servicios. . simulación ataque identifican los escenarios casos uso para posibles ataques, junto con los componentes del sistema que resultarían afectados por -chos ataques. . análisis supervivencia identifican los componentes que son esenciales que podrían resultar comprometidos por ataque, así como las estrategias supervi-vencia basadas resistencia, reconocimiento recuperación. ellison sus colaboradores presentan excelente estudio caso del método basado sistema para apoyar tratamiento salud mental (). este sistema similar mhc-pms que usó como ejemplo este libro. vez repetir análisis, utiliza sistema comercio acciones, que muestra figura ., para ilustrar algunas las características del análisis supervivencia. como observa figura ., este sistema hizo alguna provisión supervi-vencia. las cuentas usuarios los precios las acciones duplican través los servidores, manera que pueden realizarse pedidos incluso servidor local está disponible. suponga que capacidad que usuarios autorizados realicen pedidos acciones servicio clave que debe mantenerse. para garantizar que los usuarios con-fíen sistema, esencial mantener integridad. los pedidos deben ser precisos reflejar las ventas compras reales hechas por usuario del sistema.. revisar los requerimientos arquitectura del sistema . identificar servicios componentes críticos . identificar ataques componentes comprometidos. identificar puntos débiles estrategias supervivencia figura . etapas análisis supervivencia -.indd -.indd // :: // :: . ■ supervivencia del sistema para mantener este servicio pedidos, existen tres componentes del sistema que utilizan: . autenticación usuario esto permite que usuarios autorizados ingresen sistema. . cotización precios esto permite cotización del precio compra venta una acción. . colocación pedidos esto permite realización pedidos compra venta precio dado. obviamente, dichos componentes usan los activos datos esenciales, como base datos cuentas usuarios, una base datos precios una base datos transac-ción pedidos. éstos deben sobrevivir los ataques desea mantener servicio. existen muchos tipos diferentes ataques sobre este sistema que podrían cometerse. considere aquí dos posibilidades: . usuario malicioso siente rencor contra usuario acreditado del sistema. consigue acceso sistema usando sus credenciales. coloca pedidos maliciosos compra vende acciones, con intención causar problemas usuario autorizado. . usuario autorizado corrompe base datos transacciones conseguir permiso para emitir directamente comandos sql. por tanto, imposible reconciliación ventas compras. figura . muestra ejemplos estrategias resistencia, reconocimiento recu-peración que ayudan contrarrestar estos ataques.ataque resistencia reconocimiento recuperación usuario autorizado realiza pedidos maliciosospara realizar pedidos, solicita una contraseña negociación diferente acceso.enviar por correo electrónico copia del pedido usuario autorizado, con número telefónico contacto ( forma que puedan detectarse pedidos maliciosos). mantener historial pedidos usuario verificar patrones negociación inusuales.proporcionar mecanismos para “deshacer” automáticamente las negociaciones restaurar las cuentas usuario. reembolsar los usuarios las pérdidas que deben negociación maliciosa. adquirir seguros contra pérdidas derivadas ello. corrupción base datos transaccionesrequerir autorización usuarios privilegiados mediante mecanismo autenticación más confiable, como certificados digitales. mantener copias sólo lectura las transacciones para una oficina servidor internacional. comparar periódicamente las transacciones para detectar casos corrupción. mantener sumas verificación criptográficas con todos los registros transacción para detectar corrupción.recuperar base datos partir copias respaldo. ofrecer mecanismo para reproducir las negociaciones desde una hora especificada para recrear base datos transacciones. figura . análisis supervivencia sistema comercio acciones -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad desde luego, aumentar supervivencia resiliencia sistema cuesta dinero. las compañías tal vez muestren renuentes invertir supervivencia nunca han sufrido ataque serio pérdidas asociadas. sin embargo, así como mejor comprar buenas cerraduras una alarma para evitar que introduzcan ladrones casa, tam-bién mejor invertir supervivencia antes sufrir ataque. análisis supervi-vencia todavía parte mayoría los procesos ingeniería software pero, conforme más sistemas convierten críticos para empresa, probable que tales análisis usen más ampliamente. puntos clave ■ ingeniería seguridad enfoca cómo desarrollar mantener sistemas software capaces resistir ataques maliciosos, los cuales tienen intención dañar sistema basado computadoras sus datos. ■ las amenazas seguridad pueden ser amenazas confidencialidad, integridad disponibilidad sistema sus datos. ■ gestión del riesgo seguridad implica diseñar una arquitectura segura sistema, seguir buenas prácticas para diseñar sistemas seguros incluir funcionalidad para minimizar posibilidad introducir vulnerabilidades implementar sistema. ■ diseño seguridad implica diseñar una arquitectura sistema que conserve seguridad, seguir buenas prácticas para diseño sistemas seguros incluir funcionalidad para minimizar posibilidad introducir vulnerabilidades cuando despliega sistema. ■ los temas clave cuando diseña una arquitectura segura sistemas incluyen organizar estructura del sistema para proteger los activos clave distribuir los activos del sistema para minimizar las pérdidas que podría ocasionar ataque. ■ los lineamientos diseño seguridad sensibilizan los diseñadores del sistema ante los asuntos seguridad que quizá pasaron por alto. ofrecen una base para elaborar listas verificación que permitan revisar seguridad. ■ para apoyar implementación segura debe existir una forma implementar analizar las configuraciones del sistema, localizar parámetros configuración forma que olviden configuraciones importantes, minimizar los privilegios por defecto asignados los usuarios del sistema, ofrecer formas para reparar vulnerabilidades seguridad. ■ supervivencia del sistema refleja capacidad continuar entrega servicios esenciales para empresa críticos para misión, con finalidad legitimar los usuarios mientras sistema encuentra bajo ataque, después que parte del sistema dañado. lecturas sugeridas “survivable network system analysis: case study.” excelente ensayo que introduce noción supervivencia del sistema; refiere estudio caso sistema registros tratamiento -.indd -.indd // :: // :: pmcapítulo ■ referencias salud mental para ilustrar aplicación método supervivencia. (. . ellison, . . linger, . longstaff . . mead, ieee software, (), julio/agosto .) building secure software: how avoid security problems the right way . buen libro práctico que analiza seguridad desde una perspectiva programación. (. viega . mcgraw, addison- wesley, .) security engineering: guide building dependable distributed systems, edition . trata una discusión amplia profunda los problemas para construir sistemas seguros. enfoca los sistemas ingeniería del software; ofrece una amplia cobertura hardware redes, mediante excelentes ejemplos extraídos fallas sistemas reales. (. anderson, john wiley & sons, .) ejercicios .. explique las importantes diferencias entre ingeniería seguridad aplicación ingeniería seguridad infraestructura. .. para mhc-pms, sugiera ejemplo activo, exposición, vulnerabilidad, ataque, amenaza control. .. explique por qué hay necesidad que valoración del riesgo sea proceso continuo, desde las primeras etapas ingeniería requerimientos hasta uso operativo sistema. .. con base sus respuestas pregunta acerca del mhc-pms, valore los riesgos asociados con ese sistema proponga dos requerimientos sistema que permitan reducir tales riesgos. .. explique, con una analogía extraída contexto ingeniería, software, por qué debe usarse enfoque capas para protección activos. .. explique por qué importante usar tecnologías diversas para dar soporte sistemas distribuidos situaciones que disponibilidad del sistema asunto crítico. .. ¿qué ingeniería social? ¿por qué difícil protegerse contra ella las organizaciones grandes? .. para cualquier sistema software comercial que use (por ejemplo, microsoft word), analice las instalaciones seguridad incluidas examine cualquier problema que encuentre. .. explique cómo pueden usarse las estrategias complementarias resistencia, reconocimiento recuperación para mejorar supervivencia sistema. .. para sistema comercio acciones que describe sección .., cuya arquitectura ilustra figura ., sugiera dos posibles ataques ulteriores sobre sistema proponga algunas estrategias que pudieran contrarrestar dichos ataques. referencias alberts, . dorofee, . (). managing information security risks: the octave approach . boston: addison-wesley. -.indd -.indd // :: // :: capítulo ■ ingeniería seguridad alexander, . (). “misuse cases: use cases with hostile intent”. ieee software, (), –. anderson, . (). security engineering, edition. chichester: john wiley & sons. berghel, . (). “the code red worm”. comm. acm, (), –.bishop, . (). introduction computer security. boston: addison-wesley.cranor, . garfinkel, . (). security and usability: designing secure systems that people can use. sebastopol, calif.: ’reilly media inc. ellison, ., linger, ., lipson, ., mead, . moore, . (). “foundations survivable systems engineering”. crosstalk: the journal defense software engineering , , –. ellison, . ., fisher, . ., linger, . ., lipson, . ., longstaff, . . mead, . . (). “survivability: protecting your critical systems”. ieee internet computing, (), –. ellison, . ., linger, . ., longstaff, . mead, . . (). “survivable network system analysis: case study”. ieee software, (), –. pfleeger, . . pfleeger, . . (). security computing, edition. boston: addison-wesley.schneier, . (). secrets and lies: digital security networked world. nueva york: john wiley & sons. sindre, . opdahl, . . (). “eliciting security requirements through misuse cases”. requirements engineering, (), –. spafford, . (). “the internet worm: crisis and aftermath”. comm acm, (), –. viega, . mcgraw, . (). building secure software. boston: addison-wesley.westmark, . . (). “ definition for information system survivability”. hawaii int. conf. system sciences, hawaii: –. wheeler, . . (). secure programming for linux and unix howto. web published: http:// -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo describir las técnicas verificación validación usadas desarrollo sistemas críticos. estudiar este capítulo: ■ comprenderá cómo pueden utilizarse los diferentes enfoques del análisis estático verificación sistemas software críticos; ■ entenderá los fundamentos las pruebas confiabilidad seguridad, así como los problemas inherentes las pruebas los sistemas críticos; ■ conocerá por qué importante aseguramiento del proceso, especial para software que debe certificar organismo regulador; ■ introducirá casos protección confiabilidad que presenten argumentos evidencia protección confiabilidad del sistema. contenido . análisis estático . pruebas fiabilidad . pruebas seguridad . aseguramiento del proceso . casos protección confiabilidad garantía confiabilidad seguridad -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad garantizar confiabilidad seguridad una actividad que interesa por comprobar que sistema crítico cubra los requerimientos confiabilidad. esto requiere proce-sos verificación validación (&) que buscan errores especificación, diseño programa que puedan afectar disponibilidad, protección, fiabilidad seguridad sistema. verificación validación sistema crítico tienen mucho común con validación cualquier otro sistema software. los procesos & deben demos-trar que sistema cumple especificación, que los servicios comportamiento del sistema apoyan los requerimientos del cliente. hacerlo, descubren por general errores requerimientos diseño, así como bugs programa que deben repararse. sin embargo, por dos razones, los sistemas críticos requieren pruebas análisis especial-mente rigurosos: . costos falla los costos las consecuencias falla los sistemas críti- cos son potencialmente mucho mayores que los sistemas críticos. los riesgos falla del sistema reducen invertir más verificación validación del sistema. menudo menos costoso encontrar eliminar los defectos antes que sis-tema entregue, que sufragar los costos derivados accidentes interrupciones servicio del sistema. . validación atributos confiabilidad tal vez usted deba elaborar argumento formal para los clientes para organismo regulador que sistema satisface los requerimientos confiabilidad especificados (disponibilidad, fiabilidad, pro-tección seguridad). algunos casos, posible que reguladores externos, tales como las autoridades aviación nacional, deban certificar que sistema seguro antes implementarse. para obtener esta certificación, deberá demostrarse cómo validó sistema. tal caso, quizá tenga que diseñar realizar procedimientos & especiales que recopilen evidencia sobre confiabilidad del sistema. por estas razones, los costos verificación validación para sistemas críticos con frecuencia son mucho mayores que para otras clases sistemas. normalmente, más mitad los costos desarrollo sistema crítico destinan procesos &. aunque los costos & son altos, justifican, que por común son considera-blemente menores que las pérdidas originadas por accidente. por ejemplo, , sistema software crítico para una misión cohete ariane falló, numerosos satélites fueron destruidos. aunque nadie resultó lesionado, las pérdidas totales ese accidente fueron cientos millones dólares. una investigación descubrió que las deficiencias sistema & fueron parte responsables esta falla. revisiones más efectivas, relativamente poco costosas, habrían descubierto problema que causó accidente. aun cuando enfoque principal para garantizar confiabilidad seguridad encuentra validación del sistema , actividades relacionadas deben verificar que siga proceso definido para desarrollo del sistema. como explicó capítulo , calidad del sistema resulta afectada por calidad los procesos utilizados para desarrollar sistema. resumen, buenos procesos conducen buenos sistemas. resultado los procesos para garantizar confiabilidad seguridad con-junto evidencia tangible, tal como los reportes revisión, resultados pruebas, etcétera, acerca confiabilidad sistema. esta evidencia puede utilizarse posteriormente para justificar una decisión que sistema bastante confiable seguro -.indd -.indd // :: // :: . ■ análisis estático para implementar usar. ocasiones, evidencia confiabilidad del sistema integra caso confiabilidad protección. esto usa para convencer cliente regulador externo confiabilidad protección del sistema. . análisis estático las técnicas análisis estático son técnicas verificación del sistema que inclu-yen ejecución programa. vez ello, funcionan sobre una representación fuente del software: modelo especificación diseño, código fuente del pro-grama. las técnicas análisis estático pueden usarse para comprobar especificación los modelos diseño sistema con finalidad buscar errores antes que esté disponible una versión ejecutable del sistema. también tienen ventaja que presen-cia errores interrumpe comprobación del sistema. cuando prueba progra-, los defectos pueden enmascarar ocultar otros defectos, manera que debe eliminar defecto detectado luego repetir proceso prueba. como estudió capítulo , tal vez técnica análisis estático usada con más frecuencia sea revisión inspección por pares, que grupo personas encar-gan comprobar una especificación, diseño programa. ellos analizan detalle diseño código, examinan posibles errores omisiones. otra técnica consiste utilizar herramientas modelado diseño para comprobar anomalías uml, por ejemplo, hecho que mismo nombre sea usado por diferentes objetos. sin embargo, para sistemas críticos, pueden emplearse técnicas adicionales análisis estático: . verificación formal, que producen argumentos matemáticamente rigurosos que programa conforma especificación. . comprobación modelo, que usa verificador teoremas para revisar una descripción formal del sistema busca inconsistencias. . análisis automatizado programa, que código fuente programa revi- por patrones que, según sabe, son potencialmente erróneos. dichas técnicas están estrechamente relacionadas. comprobación modelos apo modelo formal del sistema que puede crearse partir una especificación formal. los analizadores estáticos utilizan aseveraciones formales incrustadas pro-grama como comentarios, para comprobar que código asociado inconsistente con dichas aseveraciones. .. verificación métodos formales los métodos formales del desarrollo software, como estudió capítulo , apoyan modelo formal que sirve como especificación del sistema. dichos métodos formales interesan principalmente por análisis matemático especificación, por transformar especificación una representación más detallada, semánticamente equi-valente, por verificar manera formal que una representación del sistema semán-ticamente equivalente otra representación. -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad los métodos formales pueden usarse diferentes etapas durante proceso &: . una especificación formal del sistema puede desarrollarse analizarse matemática- mente para identificar inconsistencias. esta técnica efectiva para detectar errores omisiones especificación. comprobación del modelo, que explica siguiente sección, enfoque análisis especificación. . posible verificar formalmente, mediante argumentos matemáticos, que código sistema software consistente con esta especificación, pero ello requiere una especificación formal. esto permite descubrir errores programación algu-nos diseño. dada amplia brecha semántica entre una especificación sistema formal código del programa, difícil probar que programa desarrollado por separado con-sistente con especificación. consecuencia, ahora trabajo verificación del programa basa desarrollo transformacional. proceso desarrollo trans-formacional, una especificación formal transforma mediante una serie representa-ciones código programa. las herramientas software apoyan desarrollo las transformaciones ayudan verificar que las correspondientes representaciones del sistema sean consistentes. tal vez método sea método transformacional formal usado más ampliamente (abrial, ; wordsworth, ). utilizado para desa-rrollo sistemas control ferroviario software aviones. los defensores los métodos formales afirman que uso dichos métodos con-duce sistemas más confiables seguros. verificación formal demuestra que pro-grama desarrollado satisface especificación que los errores implementación comprometerán confiabilidad del sistema. desarrolla método formal sistemas concurrentes mediante uso una especificación escrita lenguaje como csp (schneider, ), posible descubrir condiciones que quizá den por resultado bloqueos programa final, que permitirá resolverlos, algo muy difícil lograr sólo con las pruebas. sin embargo, especificación formal las pruebas garantizan que software sea fiable uso práctico. las razones son las siguientes: . especificación tal vez refleje los requerimientos reales los usuarios del sis- tema. como estudió capítulo , los usuarios del sistema rara vez entienden las notaciones formales, manera que pueden leer directamente especifica-ción formal para encontrar errores omisiones. esto significa que hay una consi-derable probabilidad que especificación formal contenga errores sea una representación precisa los requerimientos del sistema.desarrollo cleanroom desarrollo software cleanroom (cuarto limpio) basa una verificación del software formal pruebas estadísticas. objetivo del proceso cleanroom obtener software con cero defectos para garantizar que los sistemas entregados tengan alto nivel fiabilidad. proceso cleanroom, cada incremento software especifica formalmente, esta especificación transforma una implementación. corrección del software demuestra mediante enfoque formal. proceso hay prueba unidad por defectos, las pruebas del sistema enfocan valoración fiabilidad del sistema. http:// -.indd -.indd // :: // :: . ■ análisis estático . prueba puede contener errores. las pruebas del programa son extensas complejas, manera que, como programas extensos complejos, por general contienen errores. . prueba puede hacer suposiciones incorrectas sobre forma utilizar sistema. éste utiliza como anticipaba, prueba podría ser inválida. verificar sistema software trivial requiere gran cantidad tiempo expe- riencia matemática, así como herramientas software especializadas, tales como los demostradores teoremas. por tanto, proceso costoso , conforme aumenta tamaño del sistema, los costos verificación formal incrementan manera des-proporcionada. consecuencia, muchos ingenieros software consideran que verifi-cación formal efectiva términos costo. suponen que puede lograrse mismo nivel confianza sistema, manera menos costosa, utilizan otras técnicas validación, tales como las inspecciones las pruebas del sistema. pesar sus desventajas, posición este texto que los métodos formales verificación formal desempeñan importante papel desarrollo los sistemas software críticos. las especificaciones formales son bastante efectivas para descubrir aquellos problemas especificación que son las causas más comunes falla del sis-tema. aunque verificación formal todavía práctica para sistemas grandes, puede usarse verificación los componentes críticos para protección seguridad. .. comprobación del modelo verificar manera formal programa mediante enfoque deductivo difícil cos-toso, pero han desarrollado enfoques alternativos análisis formal que basan una noción más restringida corrección. más exitoso estos enfoques llama comprobación del modelo (baier katoen, ). éste usa ampliamente para com-probar diseños sistemas hardware cada vez más sistemas software críticos, como software control los vehículos nasa para explorar superficie marte (regan hamilton, ) software procesamiento llamadas telefónicas (chandra ., ). comprobación del modelo implica creación modelo sistema com-probación corrección dicho modelo mediante herramientas especializadas software. han desarrollado muchas diferentes herramientas comprobación del -delo; para software, tal vez que utiliza más ampliamente sea spin (holzmann, ). figura . muestran las etapas que comprende comprobación del modelo. proceso comprobación del modelo implica construir modelo formal sistema, por general como una máquina estado finito extendida. los modelos expresan lenguaje cualquier sistema usado comprobación del modelo: por ejemplo, comprobador modelo spin emplea lenguaje llamado promela. con-junto propiedades deseables del sistema identifica escribe una notación formal, por general con base lógica temporal. ejemplo tal propiedad sistema estación meteorológica campo abierto que sistema siempre llegará estado “trans-mitir” desde estado “registrar”. tal caso, comprobador modelo explora todas las rutas largo del modelo ( decir, todas las posibles transiciones estado) comprueba que sostenga pro-piedad para cada ruta. hace, entonces comprobador modelo confirma que modelo correcto con respecto dicha propiedad. sostiene para una ruta particular, comprobador del modelo presenta contraejemplo que ilustra dónde verdadera propiedad. comprobación del modelo particularmente útil -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad validación sistemas concurrentes, que son notoriamente difíciles probar debido sensibilidad tiempo. comprobador puede explorar transiciones concurrentes entremezcladas descubrir problemas potenciales. conflicto clave comprobación modelos creación del modelo del sistema. modelo debe crearse manualmente ( partir documento requeri-mientos diseño), proceso costoso, pues elaboración del modelo requiere gran cantidad tiempo. además, existe posibilidad que modelo creado sea modelo preciso los requerimientos del diseño. por tanto, mejor modelo puede diseñarse automáticamente partir del código fuente del programa. sistema java pathfinder (visser ., ) ejemplo sistema comprobación modelo que trabaja directamente desde una representación código java. comprobación del modelo muy costosa desde punto vista computacional, pues usa enfoque exhaustivo para comprobar todas las rutas largo del modelo del sistema. conforme aumenta tamaño del sistema, sucede mismo con número estados, con consecuente aumento número rutas comprobar. esto significa que, para sistemas grandes, comprobación del modelo podría resultar impráctica, debido tiempo cómputo requerido para operar las comprobaciones. sin embargo, medida que mejoran los algoritmos que identifican aquellas partes del estado que han explorado para comprobar una propiedad particular, volverá cada vez más práctico usar con frecuencia comprobación del modelo desarrollo sistemas críticos. realidad, aunque aplicable sistemas organizacionales orientados datos, puede usarse para verificar sistemas software embebidos que modelan como máquinas estado. .. análisis estático automático como estudió capítulo , las inspecciones programa están dirigidas con regularidad por listas verificación errores heurística. éstas identifican errores comunes diferentes lenguajes programación. para algunos errores heurísticas, posible automatizar proceso comprobar programas contra dichas listas, que por resultado desarrollo analizadores estáticos automatizados que posible encontrar fragmentos código que sean incorrectos. las herramientas análisis estático trabajan sobre código fuente sistema , almenos para ciertos tipos análisis, requieren más entradas. esto significa que los programadores necesitan aprender notaciones especializadas para escribir especificacio-nes programa para que los beneficios del análisis sean claros inmediato. esto hace que análisis estático automatizado introduzca con más facilidad proceso desarrollo, que verificación formal comprobación modelo. por tanto, quizás técnica análisis estático mayor uso.construcción del modelo requerimientos, diseño programa especificación propiedadmodelo sistema estado finito extendido propiedades deseadas del sistemacomprobador modelo confirmación contraejemplo figura . comprobación del modelo -.indd -.indd // :: // :: . ■ análisis estático los analizadores estáticos automatizados son herramientas software que exploran texto fuente programa detectan posibles fallas desarrollo anomalías. examinan sintácticamente texto del programa , además, reconocen los diferentes tipos enunciados programa. esta forma, pueden detectar los enunciados están bien formulados , hacer inferencias acerca del flujo control programa , muchos casos, calcular conjunto todos los posibles valores para datos del programa. éstos complementan las instalaciones detección error que proporciona compilador lenguaje, pueden usarse como parte del proceso inspección como una actividad proceso & separada. análisis estático automatizado más rápido menos costoso que las revisiones código detalladas. sin embargo, capaz descubrir algunas cla-ses errores que pudieran identificarse sesiones inspección del programa. intención del análisis estático automatizado llamar atención lector código ante anomalías programa, tales como variables que usan sin inicializa-ción, variables que emplean datos cuyo valor pudiera estar fuera rango. figura . muestran ejemplos los problemas susceptibles detección mediante análisis estático. desde luego, las comprobaciones específicas realizadas son específicas del lenguaje programación dependen qué permite qué permite lenguaje. con frecuencia, las anomalías son resultado errores omisiones pro-gramación, manera que destacan aquello que pudiera salir mal cuando ejecuta programa. sin embargo, debe quedar claro que dichas anomalías necesariamente son fallas desarrollo del programa; pueden ser instrucciones deliberadas introducidas por programador, posible que anomalía tenga consecuencias adversas. existen tres niveles comprobación que pueden implementarse analizadores estáticos: . comprobación error característico este nivel, analizador estático sabe acerca errores comunes que cometen los programadores lenguajes como java . herramienta analiza código busca patrones que sean característicos ese problema los destaca para programador. aunque relativamente simple, clase fallas desarrollo comprobación análisis estático fallas datos variables usadas antes inicialización. variables declaradas pero nunca usadas.variables asignadas dos veces pero nunca usadas entre asignaciones.posibles violaciones límites arreglo.variables declaradas. fallas control código inalcanzable.ramas incondicionales ciclos. fallas entrada/salida variables salida dobles sin intervención asignación. fallas interfaz incompatibilidad del tipo parámetro.incompatibilidad del número parámetro. usan resultados funciones.funciones procedimientos llamados. fallas gestión almacenamiento apuntadores asignados.aritmética apuntadores.fuga memoria. figura . comprobaciones análisis estático automatizado -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad análisis basado errores comunes puede ser muy efectivo términos costo. zheng sus colaboradores () estudiaron uso análisis estático contra una gran base código ++, descubrieron que % los errores los programas resultaron tipos error característico. . comprobación error definido por usuario este enfoque, los usuarios del analizador estático pueden definir patrones error, por tanto, extienden los tipos error que pueden detectarse. esto particularmente útil situaciones donde debe mantenerse orden (por ejemplo, método siempre debe llamarse antes que método ). con tiempo, una organización podrá recolectar información acerca bugs comunes que ocurren sus programas extender análisis estático para destacar dichos errores. . comprobación aserción éste enfoque más general poderoso del análisis estático. los desarrolladores incluyen aserciones formales (escritas con frecuencia comentarios estilizados) programa, las cuales establecen relaciones que deben sostenerse dicho punto del programa. por ejemplo, puede incluirse una aserción que establezca que valor cierta variable debe encontrarse rango ... analizador ejecuta simbólicamente código destaca los enunciados donde sostiene aserción. este enfoque usa analizadores como splint (evans larochelle, ) spark examiner (croxford sutton, ). análisis estático efectivo para encontrar errores programas, pero por regular genera gran número “falsos positivos”. trata secciones código donde hay errores, pero donde las reglas del analizador estático detectaron potencial error. posible reducir número falsos positivos agregar más información programa forma aserciones; desde luego, esto requiere trabajo adicional por parte del desarro-llador del código. habrá que trabajar tamizado esos falsos positivos antes que código pueda comprobarse busca errores. análisis estático particularmente valioso para comprobación seguridad (evans larochelle, ). los analizadores estáticos pueden ajustarse medida para comprobar problemas bien conocidos, como desbordamiento buffer entradas sin verificar, que podrían aprovechar los atacantes. comprobación problemas bien conocidos efectiva para mejorar seguridad, pues mayoría los intrusos basan sus ataques vulnerabilidades comunes. como estudiará más adelante, las pruebas seguridad son difíciles porque los ata-cantes menudo actúan forma inesperada, que dificulta que los examinadores pue-dan anticipar comportamiento. posible que los analizadores estáticos incorporen experiencia seguridad detallada que esté fuera del alcance los examinadores, que ésta aplique antes que programa ponga prueba. usa análisis estático, pueden hacer afirmaciones que sean verdaderas para todas las posibles ejecuciones del programa, sólo para aquellas que correspondan las pruebas que diseñaron. muchas organizaciones utilizan ahora análisis estático manera rutinaria sus procesos desarrollo software. microsoft introdujo análisis estático desa-rrollo controladores dispositivo (larus ., ), donde las fallas programa podrían tener efecto serio. ahora extendió enfoque través rango mucho más amplio software para buscar problemas seguridad, así como errores que afectan fiabilidad del programa (ball ., ). muchos sistemas críticos, incluidos siste-mas aviones nucleares, someten por regular análisis estático como parte del proceso & (nguyen ourghanlian, ). -.indd -.indd // :: // :: . ■ pruebas fiabilidad . pruebas fiabilidad las pruebas fiabilidad son proceso pruebas cuya meta consiste precisamente medir fiabilidad sistema. como explicó capítulo , existen -chas métricas fiabilidad, como pofod, probabilidad falla pedido, rocof, tasa ocurrencia falla. dichas métricas permiten especificar cuantitativamente fiabi-lidad requerida del software. durante proceso pruebas fiabilidad posible com-probar sistema logró nivel fiabilidad requerido. figura . ilustra proceso para medir fiabilidad sistema. este pro-ceso incluye cuatro etapas: . inicia con estudio los sistemas existentes del mismo tipo para entender cómo usan práctica. esto importante, pues trata medir fiabilidad como usuario del sistema. meta definir perfil operativo. este último identi-fica clases entradas del sistema probabilidad que dichas entradas ocurran uso normal. . luego construye conjunto datos prueba que reflejan perfil operativo, que significa que crean datos prueba con misma distribución probabili-dad que los datos prueba para los sistemas que estudiaron. normalmente, usará generador datos prueba para apoyar este proceso. . sistema prueba usando estos datos número cuenta, así como tipo fallas que ocurren. también registran los tiempos dichas fallas. como estu-dió capítulo , las unidades tiempo elegidas deben ser adecuadas para métrica fiabilidad que usa. . después observar número estadísticamente significativo fallas, posi- ble calcular fiabilidad del software trabajar con valor adecuado métrica fiabilidad. este proceso cuatro pasos ocasiones conoce como “prueba estadística”. - prueba estadística valorar fiabilidad del sistema. esto contrasta con las prue-bas defectos, estudiadas capítulo , donde meta descubrir fallas desarrollo del sistema. prowell sus colaboradores (), libro sobre ingeniería software cleanroom, ofrecen una amplia descripción las pruebas estadísticas. este enfoque conceptualmente atractivo para medición fiabilidad fácil aplicar práctica. las principales dificultades que surgen son: . incertidumbre del perfil operativo los perfiles operativos basados experiencia con otros sistemas tal vez sean reflejo preciso del uso real del sistema. . altos costos generación datos prueba menos que proceso sea totalmente automatizado, será muy costoso generar gran volumen datos reque-ridos perfil operativo.calcular fiabilidad observadaaplicar pruebas sistemapreparar conjunto datos pruebaidentificar perfiles operativosfigura . medición fiabilidad -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad . incertidumbre estadística cuando especifica alta fiabilidad debe generarse número estadísticamente significativo fallas para permitir mediciones fiabili-dad precisas. cuando software fiable, ocurren muy pocas fallas difícil generar nuevas fallas. . reconocimiento falla siempre evidente ocurrió una falla sistema. tiene una especificación formal, posible identificar desviaciones dicha especificación, pero especificación está lenguaje natural, podría haber ambigüedades que signifiquen que los observadores estén acuerdo torno hecho que haya fallado sistema. con mucho, mejor forma generar gran conjunto datos requeridos para medición fiabilidad usar generador datos prueba, cual puede configu-rarse para producir automáticamente entradas que coincidan con perfil operativo. sin embargo, por regular posible automatizar producción todos los datos prueba para sistemas interactivos, porque las entradas con frecuencia son una respuesta salidas del sistema. los conjuntos datos para dichos sistemas tienen que generarse forma manual, con los correspondientes costos más elevados. incluso donde posible automatización completa, podría necesitarse una cantidad significativa tiempo para escribir los comandos para generador datos prueba. las pruebas estadísticas pueden usarse conjunto con inyección fallas desa-rrollo para reunir datos acerca cuán efectivo sido proceso pruebas defecto. inyección fallas desarrollo (voas, ) introducción deliberada errores programa. cuando programa ejecuta, ello conduce fallas programa fallas asociadas. entonces analizan las fallas para descubrir raíz causa uno los errores agregados programa. descubre que % las fallas desa-rrollo inyectadas conduce fallas operación, entonces los defensores inyección fallas desarrollo argumentarán que esto sugiere que proceso pruebas defec- también habrá descubierto % las fallas desarrollo reales programa. desde luego, ello supone que distribución tipo fallas desarrollo inyec-tadas coinciden con las fallas desarrollo reales que surgen práctica. razo-nable pensar que esto cierto para fallas desarrollo que deben errores programación, pero inyección fallas efectiva para predecir número fallas desarrollo que surgen errores requerimientos diseño. prueba estadística revela con frecuencia errores software que descubrieron mediante otros procesos &. tales errores pueden significar que fiabilidad sis-tema cubre los requerimientos que deben hacerse reparaciones. después completar dichas reparaciones, sistema pone nuevamente prueba para revalorar fiabilidad. luego repetir muchas veces este proceso reparación nuevas pruebas, posible extrapolar los resultados predecir cuándo logrará cierto nivel requerido fiabilidad. esto requiere ajustar los datos extrapolados modelo crecimiento fiabilidad, que muestre cómo fiabilidad tiende mejorar con tiempo, que ayuda con planeación pruebas. ocasiones, modelo crecimiento revela que nunca alcanzará nivel fiabilidad, forma que deberán renegociarse los requerimientos. .. perfiles operativos perfil operativo sistema software refleja cómo éste usará prácti-. consta una especificación clases entrada probabilidad ocurrencia. cuando nuevo sistema software sustituye sistema automatizado existente, -.indd -.indd // :: // :: . ■ pruebas fiabilidad razonablemente sencillo valorar patrón probable uso del nuevo software. debe corresponder uso existente, con cierta concesión para nueva funcionalidad que (pre-sumiblemente) incluye nuevo software. por ejemplo, posible especificar perfil operativo para sistemas conmutación telefónica, porque las compañías tele-comunicaciones conocen los patrones llamadas que deben manejar dichos sistemas. normalmente, perfil operativo tal que las entradas con mayor probabilidad generarse caen número reducido clases, como muestra izquierda figura .. existe gran número clases que las entradas son sumamente improba-bles, pero imposibles. éstas muestran derecha figura .. elipsis (. . .) significa que existen muchas más entradas inusuales las que presentan. musa () analiza desarrollo los perfiles operativos los sistemas teleco-municación. como dicho dominio hay gran historial recopilación datos uso, proceso desarrollo perfil operativo relativamente directo. forma simple, refleja historial datos uso. para obtener sistema que requirió casi personas-año esfuerzo, desarrolló perfil operativo aproximadamente persona-mes. otros casos, generación del perfil operativo tarda más tiempo (dos tres personas-año), pero costo distribuye sobre algunas versiones del sistema. musa considera que compañía tenía menos rendimiento que rebasaba veces inversión requerida para desarrollo perfil operativo. sin embargo, cuando sistema software nuevo innovador, resulta difícil anti-cipar cómo usará. por consiguiente, prácticamente imposible crear perfil opera-tivo preciso. numerosos diferentes usuarios, con distintas expectativas, antecedentes experiencia pueden usar nuevo sistema. hay historial uso base datos. dichos usuarios pueden utilizar sistema formas que los desarrolladores del sistema anticiparon. desde luego, posible desarrollar perfil operativo preciso para algunos tipos sistema, tales como los sistemas telecomunicación, que tienen patrón estandarizado uso. obstante, para otro tipo sistemas, existen muchos diferentes usuarios, cada uno con forma peculiar usar sistema. como estudió capítulo , diferen-tes usuarios tendrán impresiones muy disímiles fiabilidad, porque usan sistema distintas formas. problema complica más porque los perfiles operativos son estáticos, sino cambiantes conforme usa sistema. medida que los usuarios aprenden sobre nuevo sistema sienten más confianza con , comienzan usarlo formas más sofisticadas. debido esto, muchas veces imposible desarrollar perfil operativo confiable. consecuencia, posible estar seguro precisión algunas medi-ciones fiabilidad, pues éstas podrían basarse suposiciones incorrectas acerca las formas que usa sistema.modelado crecimiento fiabilidad modelo crecimiento fiabilidad modelo cómo cambia con tiempo fiabilidad del sistema durante proceso pruebas. conforme descubren fallas del sistema, las fallas desarrollo subyacentes que causan dichas fallas operación reparan, manera que fiabilidad del sistema debe mejorar durante las pruebas depuración del sistema. para predecir fiabilidad, modelo conceptual crecimiento fiabilidad debe traducirse ese caso modelo matemático. http:// -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad . pruebas seguridad valoración seguridad del sistema cada vez más importante, pues más más sistemas críticos habilitan internet, por que cualquier persona con una conexión red podría ingresar ellos. todos los días presentan historias ataques siste-mas basados web, virus gusanos distribuyen regularmente mediante protocolos internet. todo esto significa que los procesos verificación validación para sistemas basa-dos web deben enfocarse evaluación seguridad, que pone prueba habilidad del sistema para resistir diferentes tipos ataques. sin embargo, como explica anderson (), este tipo valoración seguridad muy difícil reali-zar. por ende, los sistemas implementan menudo con vacíos seguridad. los ata-cantes aprovechan esos vacíos para lograr acceso sistema, causar daño sistema sus datos. esencia, existen dos razones que hacen muy difíciles las pruebas seguridad: . los requerimientos seguridad, como algunos requerimientos protección, enuncian como “ debe”. esto , especifican que debe ocurrir, que algo que opone funcionalidad comportamiento requerido del sistema. por regla general, posible definir este comportamiento deseado como simples restric-ciones comprobar por sistema. hay recursos disponibles, posible demostrar, menos principio, que sistema cumple con sus requerimientos funcionales. sin embargo, imposible pro-bar que sistema hace algo. sin importar cantidad pruebas, las vulne-rabilidades seguridad pueden permanecer sistema después que implementa. desde luego, posible generar requerimientos funcionales diseñados para proteger sistema contra algunos tipos conocidos ataques. obstante, imposible derivar requerimientos para tipos ataques desconocidos anticipa-dos. incluso sistemas que hayan usado durante años, atacante ingenioso capaz descubrir nuevas formas ataque penetrar que consideraba sistema seguro....número entradas clases entradafigura . perfil operativo -.indd -.indd // :: // :: . ■ pruebas seguridad . las personas que atacan sistema son inteligentes buscan activamente vulnerabili- dades que puedan aprovechar. quieren experimentar con sistema utilizan artilugios que alejan mucho actividad uso normales del sistema. por ejemplo, campo apellido podrían ingresar , caracteres con una mezcla letras, signos puntuación números. más aún, una vez que encuentran una vulnerabilidad, podrían intercambiar información sobre ésta aumentar número atacantes potenciales. los atacantes menudo intentan descubrir las suposiciones que hacen los desarro-lladores del sistema, para entonces contradecir dichas suposiciones observar que sucede. están una posición para usar explorar sistema durante cierto periodo analizarlo mediante herramientas software para descubrir vulnerabilidades que pue-dan aprovechar. hecho, muy probable que tengan más tiempo para buscar vulne-rabilidades que los ingenieros pruebas del sistema, pues estos últimos también deben enfocarse realizar las pruebas del sistema. por esta razón, análisis estático particularmente útil como herramienta prueba seguridad. análisis estático programa puede guiar rápidamente equipo prueba hacia áreas programa que incluyen errores vulnerabilidades. las anoma-lías reveladas análisis estático pueden corregirse directamente, bien, ayudan identificar pruebas necesarias para revelar dichas anomalías representan realidad riesgo para sistema. para comprobar seguridad sistema, puede usarse una combinación prue-bas, análisis basado herramientas verificación formal: . pruebas basadas experiencia este caso, sistema analiza contra tipos ataque que conoce equipo validación. esto implica desarrollo casos prueba examen del código fuente sistema. por ejemplo, para comprobar que sistema susceptible bien conocido ataque envenenamiento sql, prueba sistema usando entradas que incluyan comandos sql. para comprobar que ocurrirán errores desbordamiento buffer, examinan todos los buffers entrada para ver programa comprueba que las asignaciones los elementos del buffer están dentro los límites. este tipo validación realiza habitualmente conjunto con validación basada herramientas, donde estas últimas brindan información que ayuda enfocar las pruebas del sistema. pueden crearse listas verificación conocidos problemas seguridad para auxiliar proceso. figura . brinda algunos ejemplos preguntas que ayudan impulsar las pruebas basadas experiencia. una lista verificación problemas seguridad también deberían incluirse las comprobaciones acerca siguieron los lineamientos diseño programación para seguridad (capítulo ). . equipos tigre ésta una forma pruebas basadas experiencia las que posible apoyarse experiencia externa equipo desarrollo para probar sistema aplicación. establece “equipo tigre”, que impone obje-tivo violar seguridad del sistema. ellos simulan ataques sistema usan ingenio para descubrir nuevas formas comprometer seguridad del sistema. los miembros del equipo tigre deben tener experiencia previa con pruebas seguridad descubrir debilidades seguridad los sistemas. . pruebas basadas herramientas para este método usan varias herramientas seguridad, tales como verificadores contraseña que permiten analizar sis-tema. los verificadores contraseñas detectan contraseñas inseguras, por ejemplo, los nombres comunes las cadenas letras consecutivas. este enfoque realidad -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad una extensión validación basada experiencia, donde experiencia con las fallas seguridad concentra las herramientas utilizadas. desde luego, análisis estático otro tipo prueba basada herramientas. . verificación formal sistema puede verificarse contra una especificación -guridad formal. sin embargo, como otras áreas, verificación formal segu-ridad usa manera amplia. inevitablemente, las pruebas seguridad están limitadas por tiempo los recur-sos disponibles del equipo pruebas. esto significa que, por regular, conveniente adoptar enfoque basado riesgo para las pruebas seguridad enfocarse que consideran los riesgos más significativos que enfrenta sistema. dispone análisis los riesgos seguridad para sistema, puede usarse para impulsar proceso pruebas. así como las pruebas del sistema contra los requerimientos segu-ridad derivan dichos riesgos, equipo pruebas también debería tratar romper sistema adoptar enfoques alternativos que amenacen los activos del sistema. muy difícil para los usuarios finales sistema verificar seguridad. por con-siguiente, algunos órganos gubernamentales estados unidos europa han establecido conjuntos criterios evaluación seguridad que los evaluadores especializados pueden revisar (pfleeger pfleeger, ). los proveedores productos software envían sus productos para que sean evaluados certificados acuerdo con dichos cri-terios. por tanto, usted tiene requerimiento para nivel particular seguridad, recomendable elegir producto que haya validado dicho nivel. sin embargo, práctica, esos criterios usan principalmente sistemas militares , por momento, aún logran mucha aceptación comercial. . aseguramiento del proceso como estudió capítulo , experiencia demuestra que los procesos confia-bles conducen sistemas confiables. esto , proceso basa buenas prácticas lista verificación seguridad . ¿todos los archivos que crean aplicación tienen permisos adecuados acceso? los permisos erróneos acceso pueden conducir que usuarios autorizados tengan acceso esos archivos. . ¿ sistema termina automáticamente las sesiones usuario luego periodo inactividad? las sesiones que mantienen activas permiten acceso autorizado través una computadora sin atender. . sistema está escrito lenguaje programación sin comprobación límites arreglo, ¿existen situaciones donde pueda explotarse desbordamiento buffer? desbordamiento buffer permite que los atacantes envíen cadenas código sistema que luego ejecutan. . establecen contraseñas, ¿ sistema comprueba que éstas sean “fuertes”? las contraseñas fuertes constan letras, números signos puntuación mezclados, son entradas normales diccionario. resultan más difíciles romper que las contraseñas simples. . ¿las entradas del entorno del sistema siempre comprueban contra una especificación entradas? procesamiento incorrecto entradas mal formadas una causa común vulnerabilidades seguridad. figura . ejemplos entradas una lista verificación seguridad -.indd -.indd // :: // :: . ■ aseguramiento del proceso ingeniería software, entonces más probable que producto software resultante sea confiable. desde luego, buen proceso garantiza confiabilidad. sin embargo, evi-dencia que usa proceso confiable aumenta confianza global que sistema confiable. aseguramiento del proceso ocupa tanto recolección informa-ción sobre los procesos usados durante desarrollo del sistema, como los resultados dichos procesos. esta información proporciona evidencia del análisis, las revisiones las pruebas que realizaron durante desarrollo del software. aseguramiento del proceso incluye dos aspectos: . ¿ tienen los procesos correctos? ¿los procesos desarrollo del sistema usados organización incluyen controles adecuados subprocesos & para tipo sistema desarrollar? . ¿los procesos realizan manera correcta? ¿ organización efectuó trabajo desarrollo como definió sus descripciones proceso software, obtuvieron los resultados definidos partir los procesos software? las compañías que tienen amplia experiencia ingeniería sistemas críticos hicieron evolucionar sus procesos para reflejar una buena práctica verificación vali-dación. algunos casos, esto implicó discusiones con regulador externo para acordar qué procesos debían utilizarse. aunque hay considerable grado variación los procesos entre compañías, las actividades que esperaría ver los procesos desa-rrollo sistemas críticos incluyen gestión requerimientos, administración del cambio control configuración, modelado sistemas, revisiones inspecciones, planea-ción pruebas análisis cobertura pruebas. noción mejora del proceso, que introducen institucionalizan las buenas prácticas los procesos, estudia capítulo . otro aspecto del aseguramiento del proceso comprobar que los procesos realiza-ron manera adecuada. por regular, esto implica asegurar que los procesos documen-ten adecuadamente, verificar esta documentación del proceso. por ejemplo, parte proceso confiable puede implicar inspecciones formales programa. documentación cada inspección debe incluir listas verificación para impulsar inspección, una lista las personas implicadas, los problemas identificados durante inspección las acciones requeridas. consecuencia, demostrar que usó proceso confiable incluye generar gran cantidad evidencia documental sobre proceso software desarrollar. necesi-dad esta amplia documentación significa que los procesos ágiles rara vez emplean regulación del software los gobiernos crearon organismos reguladores para garantizar que industria privada beneficie del incumplimiento los estándares nacionales protección seguridad algunos otros. existen organismos reguladores muchas industrias, como energía nuclear, aviación banca. conforme los sistemas software vuelven cada vez más importantes infraestructura fundamental los países, dichos reguladores ocupan cada vez más los casos protección confiabilidad para sistemas software. http:// -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad los sistemas donde requiere certificación protección confiabilidad. los procesos ágiles enfocan software argumentan (correctamente) que una gran cantidad documentación proceso nunca usa realidad después que produce. sin embargo, necesario crear actividades proceso evidencia docu-mentos usar información proceso como parte caso protección confiabili-dad sistema. .. procesos para garantizar protección mayor parte del trabajo aseguramiento del proceso realizó área desa-rrollo sistemas críticos protección. por dos razones, importante que proceso desarrollo sistemas críticos protección incluya procesos & que concuerden con análisis garantía protección: . como los accidentes son acontecimientos inusuales los sistemas críticos, puede ser prácticamente imposible simularlos durante las pruebas sistema. conveniente apoyarse pruebas extensas para reproducir las condiciones que podrían conducir accidente. . ocasiones, como estudió capítulo , los requerimientos protección son requerimientos enunciados como “ debe”, que excluyen comportamiento protegido del sistema. imposible demostrar manera concluyente, mediante las pruebas otras acciones validación, que cumplen dichos requerimientos. todas las etapas del proceso desarrollo software deberían incluirse actividades específicas para garantizar protección. dichas actividades registran los análisis realiza-dos persona personas responsables dichos análisis. las actividades para garan-tizar protección que incorporan los procesos software incluyen las siguientes: . registro monitorización peligros que rastrean los riesgos partir análisis preliminares peligros, mediante pruebas validación del sistema. . revisiones protección, que efectúan largo del proceso desarrollo. . certificación protección, que legitima formalmente protección los componentes críticos. esto implica grupo externo equipo desarrollo del concesión licencias para ingenieros software algunas áreas ingeniería, los especialistas protección sistemas deben ser ingenieros con licencia; los ingenieros sin experiencia mal calificados están autorizados para asumir responsabilidad seguridad. esto aplica actualmente los ingenieros software, aunque existe mucha controversia acerca concesión licencias los ingenieros software muchos lugares estados unidos (knight leveson, ). sin embargo, futuros estándares proceso para desarrollo software crítico para protección requerirán que los ingenieros encargados estos proyectos seguridad sean ingenieros certificados, con nivel mínimo definido capacitación experiencia. http:// -.indd -.indd // :: // :: . ■ aseguramiento del proceso sistema que examina evidencia disponible decide sistema componente debe considerarse protegido antes que esté disponible para utilizarse. con finalidad apoyar tales procesos para garantizar protección, debe designarse los ingenieros encargados proteger proyecto que tengan responsabilidad explícita para los aspectos protección sistema. esto significa que dichos profesionales serán responsables ocurre una falla sistema relacionada con protección. ellos -ben demostrar que las actividades para garantizar protección realizaron manera adecuada. los ingenieros encargados protección trabajan con los responsables calidad con propósito garantizar que usó sistema administración configu-ración detallado para rastrear toda documentación relacionada con protección, para mantener paso con documentación técnica asociada. esto esencial todos los procesos confiables. tiene mucho sentido mantener procedimientos validación rigurosos una falla administración configuración significa que entrega sistema equivocado cliente. los capítulos cubre tema administra-ción configuración calidad. proceso análisis del peligro, que parte esencial del desarrollo sistemas críticos para protección, ejemplo proceso para garantizar protección. análisis del peligro ocupa identificar los riesgos, probabilidad ocurrencia probabilidad que cada uno ellos conduzca accidente. existe código programa que compruebe maneje cada peligro, entonces posible argumentar que dichos peligros derivarán accidentes. tales explicaciones pueden comple-mentarse con argumentos protección, como estudia más adelante este capítu-. ahí donde requiera certificación externa antes usar sistema (por ejemplo, una aeronave), hecho que pueda documentarse este seguimiento por general una condición certificación. documento central protección que debe elaborarse bitácora peligro. este documento proporciona evidencia cómo consideraron los peligros identifica-dos durante desarrollo del software. esta bitácora peligro usa cada etapa del proceso desarrollo del software para documentar cómo dicha etapa toma cuenta los peligros. figura . muestra ejemplo simplificado una entrada bitá-cora peligro para sistema administración insulina. este formato documenta proceso análisis peligro muestra los requerimientos diseño que generaron durante proceso. tales requerimientos diseño tienen intención garantizar que sistema control nunca administre una sobredosis insulina mediante una bomba especial. como muestra figura ., los individuos que tienen responsabilidades materia protección deben identificarse manera explícita. esto importante por dos razones: . cuando identifica las personas, éstas aparecen como responsables sus accio- nes. esto significa que verán inducidas tener más cuidado, porque cualquier problema puede rastrearse hacia trabajo. . caso accidente, podría haber procedimientos legales una demanda. importante identificar quién fue responsable garantizar protección, forma que pueda rendir cuentas sus acciones. -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad . casos protección confiabilidad los procesos para garantizar seguridad confiabilidad generan mucha información. ésta incluye resultados pruebas, información sobre los procesos desarrollo utiliza-dos, registros reuniones revisión, etcétera. tal información proporciona evidencia seguridad confiabilidad sistema, usa para ayudar decidir sistema suficientemente confiable para uso operacional. los casos protección confiabilidad son documentos estructurados que establecen argumentos evidencias detallados que sistema está protegido, que logró nivel requerido seguridad confiabilidad. algunas veces llaman casos asegu-ramiento. esencia, caso protección confiabilidad reúne toda evidencia dis-ponible que indica que sistema confiable. para muchos tipos sistemas críticos, producción caso protección requerimiento legal. caso debe satisfacer órgano regulador certificación antes que sistema pueda implementarse. responsabilidad del organismo regulador radica comprobar que sistema com-pletado tan seguro confiable como ejecutable, manera que papel principal entra juego cuando completa proyecto desarrollo. sin embargo, los reguladores figura . entrada simplificada una bitácora peligrobitácora peligro página : impresa .. sistema: sistema bomba insulinaingeniero seguridad: james brownarchivo: bomba insulina/protección/bitácora peligro bitácora versión: / peligro identificado sobredosis insulina administrada paciente identificado por jane williams clase criticidad riesgo identificado alto árbol fallas identificado fecha .. ubicación bitácora peligro, página creadores árbol fallas jane williams bill smith árbol fallas verificado fecha .. verificador james brown requerimientos diseño protección del sistema . sistema debe incluir software autocomprobación que probará sistema sensores, reloj sistema administración insulina. . software autocomprobación debe ejecutarse una vez por minuto. . caso que software autocomprobación descubra una falla desarrollo alguno los componentes del sistema, debe emitirse una advertencia audible pantalla bomba debe indicar nombre del componente donde descubrió falla. debe suspenderse administración insulina. . sistema debe incorporar sistema modificación manual que permita usuario del sistema modificar dosis calculada insulina que debe administrar sistema. . cantidad modificación debe ser mayor valor preestablecido (maxoverride), que determina cuando personal médico configura sistema. -.indd -.indd // :: // :: . ■ casos protección confiabilidad desarrolladores rara vez trabajan aislamiento; comunican con equipo desa- rrollo para establecer que debe incluirse caso protección. regulador los desarrolladores, conjunto, examinan los procesos procedimientos para asegurarse que realicen documenten satisfacción del organismo regulador. los casos confiabilidad diseñan por general durante después del proceso desarrollo del sistema. ocasiones esto puede causar problemas las actividades del proceso desarrollo producen evidencia confiabilidad del sistema. graydon sus colaboradores () argumentan que desarrollo caso protección con-fiabilidad debe integrarse estrechamente con diseño implementación del sistema. esto significa que las decisiones acerca del diseño del sistema pueden estar influidas por los requerimientos del caso confiabilidad. posible evitar las opciones diseño que pueden aumentar significativamente las dificultades los costos del desarrollo del caso. los casos confiabilidad son generalizaciones casos seguridad del sistema. caso protección conjunto documentos que incluyen una descripción del sistema certificar, información sobre los procesos empleados para desarrollar sis-tema , manera esencial, argumentos lógicos que demuestren que probable que sistema esté protegido. manera más sucinta, bishop bloomfield () definen caso protección como: una recopilación evidencia documentada que ofrece argumento convin-cente válido que sistema está adecuadamente protegido para una aplica-ción dada entorno determinado. organización los contenidos caso protección confiabilidad dependen del tipo sistema que deba certificarse contexto operación. figura . muestra una posible estructura para caso protección, pero esta área hay estándares industria-les que utilicen ampliamente para los casos protección. las estructuras casos protección varían, dependiendo industria madurez del dominio. por ejemplo, los casos protección nuclear han requerido durante muchos años. son muy completos presentan una forma que familiar para los ingenieros nucleares. sin embargo, los casos protección para dispositivos médicos introdujeron mucho más recientemente. estructura más flexible suelen estar menos detallados que los casos nucleares. desde luego, software peligroso. sólo cuando incrusta gran sis-tema basado computadora sociotécnico que las fallas software pueden generar fallas otro equipo procesos que pueden causar lesión muerte. por tanto, caso protección software siempre parte caso protección sistema más amplio que demuestra protección del sistema global. cuando elabore caso pro-tección software, deberá relacionar las fallas del software con fallas sistema más amplias demostrar que dichas fallas software ocurrirán, que propagarán tal forma que generen fallas peligrosas del sistema. .. argumentos estructurados decisión sistema suficientemente confiable para emplearse debe basarse argumentos lógicos. dichos argumentos deben demostrar que evidencia presentada apoya las afirmaciones sobre seguridad confiabilidad sistema. tales afirmacio-nes pueden ser absolutas ( evento ocurrirá ocurrirá) probabilísticas ( probabili-dad ocurrencia del evento .). argumento vincula evidencia afirmación. -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad como muestra figura ., argumento una relación entre que piensa que caso ( afirmación) cuerpo evidencia que recolectó. argumento, esencia, explica por qué afirmación, que una aseveración acerca seguridad confiabilidad del sistema, puede inferirse partir evidencia disponible. por ejemplo, bomba insulina dispositivo esencial para protección, cuya falla podría causar lesiones usuario. muchos países, esto significa que una autori- dad reguladora ( reino unido, medical devices directorate) debe cerciorarse protección del sistema antes que dispositivo pueda venderse usarse. para tomar esta decisión, organismo regulador valora caso protección del sistema, que presenta argu-mentos estructurados que operación normal del sistema causará daño usuario. los casos protección apoyan por general argumentos estructurados basa-dos afirmaciones. por ejemplo, siguiente argumento puede usarse para justificar una afirmación que los cálculos realizados por software control conducirán administración una sobredosis insulina usuario del dispositivo. desde luego, éste argumento muy simplificado. caso protección real más detallado, presentarían informes sobre evidencia.capítulo descripción descripción del sistema panorama del sistema una descripción sus componentes críticos. requerimientos protecciónlos requerimientos protección extraídos especificación requerimientos del sistema. también pueden incluirse detalles otros requerimientos relevantes sistema. análisis peligro riesgo documentos que describen los peligros riesgos que identificaron, las medidas tomadas para reducir riesgo. análisis peligro bitácoras peligro. análisis diseño conjunto argumentos estructurados (véase sección ..) que justifican por qué seguro diseño. verificación validación descripción los procedimientos & utilizados , caso, los planes pruebas para sistema. resúmenes los resultados las pruebas que muestran defectos detectados corregidos. usaron métodos formales, una especificación formal del sistema cualquier análisis dicha especificación. registros análisis estáticos del código fuente. reportes revisión registros todas las revisiones diseño protección. competencias equipo evidencia competencia todos los miembros del equipo implicados desarrollo validación los sistemas relacionados con protección. proceso registros los procesos aseguramiento calidad (véase capítulo ) realizados durante desarrollo del sistema. procesos administración del cambioregistros todos los cambios propuestos, acciones tomadas , caso, justificación protección tales cambios. información acerca procedimientos administración configuración bitácoras administración configuración. casos protección asociados referencias otros casos protección que puedan repercutir caso protección. figura . contenido caso protección software -.indd -.indd // :: // :: . ■ casos protección confiabilidad afirmación: máxima dosis individual calculada por bomba insulina supe- rará maxdose, donde maxdose valoró como una dosis individual segura para paciente particular. evidencia: argumento protección para programa control del software bomba insulina (más adelante esta sección analizan los argumentos pro-tección). evidencia: conjuntos datos prueba para bomba insulina. pruebas, valor currentdose calculó correctamente nunca superó maxdose. evidencia: reporte análisis estático para programa control bomba insulina. análisis estático del software control reveló anomalías que afectaran valor currentdose, variable del programa que contiene dosis insulina administrar. argumento: evidencia presentada indica que máxima dosis insulina que puede calcularse igual maxdose. por tanto, razonable suponer, con alto nivel confianza, que evidencia justifica afirmación que bomba insulina calcularía una dosis insulina administrar que supere máxima dosis individual. observe que evidencia presentada tanto redundante como diversa. software verifica mediante numerosos diferentes mecanismos con significativo traslape entre ellos. como estudió capítulo , uso procesos redundantes diversos aumenta confianza. hay omisiones errores que detectan por medio proceso validación, hay una buena oportunidad que encuentren por uno los otros. por supuesto, normalmente habrá muchas afirmaciones acerca confiabilidad seguridad sistema, que validez una afirmación depende con frecuen-cia que otras afirmaciones sean válidas . por consiguiente, las afirmaciones pueden organizarse una jerarquía. figura . señala parte esa jerarquía afirma-ción para bomba insulina. con finalidad demostrar que válida una afirmación alto nivel, primero debe trabajar por medio los argumentos para afirmaciones nivel más bajo. posible probar que cada una tales afirmaciones nivel inferior está justificada, entonces posible inferir que están justificadas las afirmaciones nivel superior.<<argumento afirmación apoyosapoyos apoyosjustificaevidenciaevidencia evidenciafigura . argumentos estructurados -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad .. argumentos estructurados protección los argumentos estructurados protección son tipo argumento estructurado, que señala que programa cumple sus obligaciones protección. argumento protección, necesario probar que programa funciona como pretende. sólo necesario demostrar que ejecución del programa derivará estado inseguro. esto significa que los argumentos protección son menos costosos elaborar que los argu-mentos corrección. deben considerarse todos los estados del programa, simplemente habrá que concentrarse estados que podrían conducir accidente. una suposición general que subyace trabajo referente protección del sistema que número fallas desarrollo del sistema que pueden conducir peligros críticos para protección considerablemente menor que número total fallas desarrollo que pueden existir sistema. garantía protección puede concentrarse aquellas fallas desarrollo con peligro potencial. posible probar que dichas fallas ocurrirán que, ocurren, peligro asociado causará accidente, enton-ces sistema seguro. ésta base los argumentos estructurados protección. los argumentos estructurados protección tienen intención demostrar que, condiciones ejecución normales, programa debería ser seguro. por general, basan contradicción. los pasos recomendados para elaborar argumento protec-ción son los siguientes: . comience por suponer que estado inseguro, cual identificó mediante análi- sis peligro del sistema, puede alcanzarse ejecutar programa. . escriba predicado (una expresión lógica) que defina ese estado inseguro. . luego analice metódicamente modelo del sistema programa, pruebe que, para todas las rutas del programa que conduzcan dicho estado, condición fina- lización dichas rutas contradice predicado estado protegido. éste caso, incorrecta suposición inicial estado inseguro. máxima dosis individual calculadapor software labomba superarámaxdose.maxdose establececorrectamente cuandose configura bomba. maxdose una dosissegura para usuariode bomba insulina. bomba insulinano administrará una dosisindividual insulina queno sea segura. operaciónnormal, lamáxima dosiscalculada nosuperará maxdose. falla software, máxima dosiscalculada nosuperará maxdose.figura . jerarquía afirmaciones protección para bomba insulina -.indd -.indd // :: // :: . ■ casos protección confiabilidad . cuando repite este análisis para todos los peligros identificados, entonces existe clara evidencia que sistema seguro. los argumentos estructurados protección pueden aplicarse diferentes niveles, desde los requerimientos través los modelos diseño hasta código. nivel requerimientos, trata demostrar que hay requerimientos protección faltantes, que los requerimientos hacen suposiciones inválidas acerca del sistema. nivel del diseño, conveniente analizar modelo estado del sistema para encontrar estados inseguros. nivel código, considere todas las rutas con código crítico protección para demostrar que ejecución todas las rutas conduce una contradicción. como ejemplo, considere código figura ., que puede ser parte imple-mentación del sistema administración insulina. código calcula dosis insulina administrar, luego aplica algunas comprobaciones protección para reducir proba-bilidad que inyecte una sobredosis insulina. desarrollar argumento pro-tección para este código implica probar que dosis insulina administrada nunca será mayor que máximo nivel seguro para una dosis individual. esto establece para cada usuario diabético tratamiento con sus consejeros médicos. para demostrar que existe protección, tiene que probar que sistema administra dosis “correcta”, simplemente que nunca administra una sobredosis paciente. trabaja sobre suposición que maxdose nivel protegido para dicho usuario del sistema. para elaborar argumento protección, identifique predicado que defina estado inseguro, que currentdose maxdose. luego demuestre que todas las rutas del pro-grama conducen una contradicción esta afirmación. éste caso, condición figura . cálculo dosis insulina mediante comprobaciones protección— dosis insulina administrar función del — nivel azúcar sangre, dosis previa administrada — momento administración dosis previa currentdose = computeinsulin () ; // comprobación protección – ajustar currentdose necesario. // enunciado (previousdose == ) { (currentdose maxdose/) rrentdose = maxdose/ ; }else (currentdose (previousdose * ) ) currentdose = previousdose * ; // enunciado ( currentdose < minimumdose ) currentdose = ; else ( currentdose maxdose ) currentdose = maxdose ; administerinsulin (currentdose) ; -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad insegura puede ser verdadera. posible hacer esto, podemos estar seguros que programa calculará una dosis inadecuada insulina. figura . estruc-turan presentan gráficamente los argumentos protección. para elaborar argumento estructurado programa que efectúa cálculo inseguro, primero identifique todas las posibles rutas largo del código que podrían conducir estado potencialmente protegido. trabaje hacia atrás partir ese estado protegido considere última asignación todas las variables estado cada ruta que conduzca dicho estado protegido. posible probar que ninguno los valo-res esas variables inseguro, entonces demostrará que suposición inicial ( que cálculo inseguro) incorrecta. trabajar hacia atrás importante porque significa que usted puede ignorar todos los estados, además los estados finales, que conduzcan condición salida para código. los valores anteriores son importantes para protección del sistema. este ejemplo, sólo necesita preocuparse por conjunto posibles valores currentdose currentdose = currentdose = ejecución enunciado rama thencurrentdose = maxdose currentdose = maxdose ejecución enunciado rama elseenunciado ejecutadocurrentdose = minimumdose currentdose <= maxdoseocurrentdose maxdose administerinsulin contradicción contradicción contradicciónprecondición estado insegurosobredosis administrada asignar asignar figura . argumentos protección informales basados contradicciones demostración -.indd -.indd // :: // :: pmcapítulo ■ puntos clave inmediatamente antes que ejecute método administerinsulin. puede ignorar los cálculos, como enunciado figura ., argumento protección, por-que sus resultados están sobrescritos posteriores enunciados del programa. argumento protección que muestra figura ., existen tres posi-bles rutas del programa que conducen solicitud del método administerinsulin. debe demostrarse que cantidad insulina administrada nunca supera maxdose. considere todas las posibles rutas del programa hacia administerdose: . ninguna rama del enunciado ejecuta. esto sólo puede ocurrir currentdose mayor que igual minimumdose menor que igual maxdose. ésta post-condición: una afirmación que verdadera después que ejecuta enun-ciado. . ejecuta rama then del enunciado . este caso, ejecuta asignación establecer currentdose cero. por tanto, post-condición currentdose . . ejecuta rama else- del enunciado . este caso, ejecuta asignación establecer currentdose maxdose. por tanto, después ejecutar este enunciado, sabe que post-condición currentdose maxdose. los tres casos, las post-condiciones contradicen precondición insegura que dosis administrada mayor que maxdose. por consiguiente, puede afirmarse que cálculo seguro. los argumentos estructurados usan misma forma para demostrar que ciertas propiedades seguridad sistema son verdaderas. por ejemplo, usted quiere demostrar que cálculo nunca conducirá cambio permisos sobre recurso, podrá usar argumento seguridad estructurado para comprobarlo. sin embargo, eviden-cia los argumentos estructurados menos confiable para validación seguridad. debe que hay una posibilidad que atacante logre corromper código del sis-tema. tal caso, código ejecutado código que usted consideró como seguro. puntos clave ■ análisis estático enfoque & que examina código fuente ( otra presentación) sistema, que busca errores anomalías. permite que todas las partes programa verifiquen, sólo aquellas que ejercitan mediante pruebas del sistema. ■ comprobación del modelo enfoque formal análisis estático que comprueba exhaustivamente todos los estados sistema busca errores potenciales. ■ las pruebas estadísticas usan para evaluar fiabilidad del software. apoyan probar sistema con conjunto datos prueba que reflejen perfil operativo del software. los datos prueba pueden generarse automáticamente. -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad ■ validación seguridad difícil porque los requerimientos seguridad establecen que debe ocurrir sistema, lugar que debe ocurrir. más aún, los atacantes del sistema son inteligentes , para sondear las debilidades, dedican más tiempo que que destina las pruebas seguridad. ■ validación seguridad puede realizarse mediante análisis basados experiencia, análisis basados herramientas “equipos tigre”, que simulan ataques sistema. ■ importante tener proceso certificado bien definido para desarrollo sistemas críticos protección. proceso debe incluir identificación monitorización peligros potenciales. ■ los casos protección confiabilidad reúnen toda evidencia que demuestre que sistema seguro confiable. los casos protección requieren cuando regulador externo debe certificar sistema antes uso. ■ por general, los casos protección basan argumentos estructurados. los argumentos estructurados protección demuestran que una condición peligrosa identificada nunca ocurrirá, considerar todas las rutas del programa que conduzcan una condición protegida probar que condición insostenible. lecturas sugeridas software reliability engineering: more reliable software, faster and cheaper, edition . probablemente este libro sea clave para uso perfiles operativos modelos fiabilidad para valoración fiabilidad. incluye detalles experiencias con pruebas estadísticas. (. . musa, mcgraw-hill, .) “nasa’ mission reliable”. una explicación cómo nasa usa análisis estático comprobación modelos para asegurar fiabilidad del software sus naves espaciales. (. regan . hamilton, ieee computer, (), enero .) http:/ /. doi. org/ . / . . . dependability cases. introducción basada ejemplos definición caso confiabilidad. (. . weinstock, . . goodenough, . . hudak, software engineering institute, cmu/sei---, .) http:/ /www. sei. cmu. edu/ publications/ documents/ . reports/ . html. how break web software: functional and security testing web applications and web services . libro breve que ofrece buenos prácticos consejos sobre cómo correr pruebas seguridad aplicaciones red. (. andrews . . whittaker, addison-wesley, .) “using static analysis find bugs”. este ensayo describe findbugs, analizador estático java que utiliza técnicas sencillas para encontrar violaciones potenciales seguridad errores tiempo operación. (. ayewah ., ieee software, (), sept/oct .) http:/ /. doi. org/ . / . . . -.indd -.indd // :: // :: pmcapítulo ■ ejercicios ejercicios .. explique cuándo resulta efectivo términos costos usar especificación verificación formales desarrollo sistemas software críticos protección. ¿por qué considera que los ingenieros sistemas críticos están contra del uso los métodos formales? .. sugiera una lista condiciones que pudieran detectarse mediante analizador estático para java, ++ cualquier otro lenguaje programación que utilice. comente acerca esta lista comparación con lista presentada figura .. .. explique por qué prácticamente imposible validar las especificaciones fiabilidad cuando expresan términos número muy pequeño fallas durante vida total sistema. .. mencione por qué asegurar fiabilidad sistema una garantía protección. .. con ejemplos, explique por qué las pruebas seguridad son proceso muy difícil. .. sugiera cómo validaría sistema protección contraseñas para una aplicación que desarrolló. explique función cualquier herramienta que considere útil. .. mhc-pms tiene que asegurarse contra ataques que puedan revelar información confidencial los pacientes. algunos esos ataques analizaron capítulo . con esa información, extienda lista verificación figura . para guiar los examinadores del mhc-pms. .. mencione cuatro tipos sistemas que requieran casos protección software exponga por qué requieren. .. mecanismo control cerrado puerta una instalación almacenamiento desechos nucleares está diseñado para una operación protegida. garantiza que entrada almacén sólo permita cuando colocan los escudos radiación cuando nivel radiación lugar cae por debajo cierto valor dado (dangerlevel). este modo: . los escudos radiación control remoto encuentran lugar dentro del recinto, operador autorizado podrá abrir puerta. . nivel radiación recinto está por debajo valor especificado, operador autorizado podrá abrir puerta. iii. operador autorizado identifica mediante ingreso código entrada autorizado. código que muestra figura . (véase continuación) controla mecanismo cerrado puerta. observe que estado seguro que entrada permite. con enfoque que explicó sección .., desarrolle argumento protección para este código. use los números línea para referirse enunciados específicos. encuentra que código está protegido, sugiera cómo debe modificarse para protegerlo. -.indd -.indd // :: // :: capítulo ■ garantía confiabilidad seguridad .. suponga que usted parte equipo que desarrolló software para una planta química, cual falló causó serio problema contaminación. jefe entrevistan televisión afirma que proceso validación fue exhaustivo que hubo fallas desarrollo del software. asegura que los problemas pueden deberse procedimientos operacionales erróneos. periodista acude usted para recabar opinión. explique cómo manejaría entrevista. referencias abrial, . . (). the book: assigning programs meanings. cambridge, : cambridge university press. anderson, . (). security engineering: guide building dependable distributed systems . chichester, : john wiley & sons.baier, . katoen, .-. (). principles model checking. cambridge, mass.: mit press.ball, ., bounimova, ., cook, ., levin, ., lichtenberg, ., mcgarvey, ., ondrusek, ., . ., . ustuner, . (). “thorough static analysis device drivers”. proc. eurosys , leuven, bélgica. bishop, . bloomfield, . . (). “ methodology for safety case development”. proc. safety- critical systems symposium, birmingham, : springer. entrycode = lock.getentrycode () ; (entrycode == lock.authorizedcode) { shieldstatus = shield.getstatus (); radiationlevel = radsensor.get (); (radiationlevel < dangerlevel) state = safe; else state = unsafe; (shieldstatus == shield.inplace() ) state = safe; (state == safe) { door.locked = false ; door.unlock (); } else { door.lock ( ); door.locked := true ; } } figura . código cerrado puerta -.indd -.indd // :: // :: pmchandra, ., godefroid, . palm, . (). “software model checking practice: industrial case study”. proc. int. conf. software eng. (icse ), orland, fla.: ieee computer society, –. croxford, . sutton, . (). “breaking through the and bottleneck”. proc. int. eurospace—ada-europe symposium ada europe, frankfurt, alemania: springer-lncs, –. evans, . larochelle, . (). “improving security using extensible lightweight static analysis”. ieee software, (), –. graydon, . ., knight, . . strunk, . . (). “assurance based development critical systems”. proc. annual ieee conf. dependable systems and networks , edimburgo, escocia: –. holzmann, . . (). the spin model checker. boston: addison-wesley.knight, . . leveson, . . (). “should software engineers licensed?” comm. acm, (), –.larus, . ., ball, ., das, ., deline, ., fahndrich, ., pincus, ., rajamani, . . venkatapathy, . (). “righting software”. ieee software, (), –. musa, . . (). software reliability engineering: more reliable software, faster development and testing. nueva york: mcgraw-hill. nguyen, . ourghanlian, . (). “dependability assessment safety-critical system software static analysis methods”. proc. ieee conf. dependable systems and networks (dsn’) , san francisco, calif.: ieee computer society, –. pfleeger, . . pfleeger, . . (). security computing, edition. boston: addison-wesley. prowell, . ., trammell, . ., linger, . . poore, . . (). cleanroom software engineering: technology and process. reading, mass.: addison-wesley.regan, . hamilton, . (). “nasa’ mission reliable”. ieee computer, (), –. schneider, . (). concurrent and real-time systems: the csp approach . chichester, : john wiley and sons.visser, ., havelund, ., brat, ., park, . lerda, . (). “model checking programs”. automated software engineering ., (), –. voas, . (). “fault injection for the masses”. ieee computer, (), –.wordsworth, . (). software engineering with . wokingham: addison-wesley.zheng, ., williams, ., nagappan, ., snipes, ., hudepohl, . . vouk, . . (). “ the value static analysis for fault detection software”. ieee trans. software eng., (), –.capítulo ■ referencias -.indd -.indd // :: // :: pmm-.indd -.indd // :: // :: pmesta parte del libro titula “ingeniería software avanzada” porque lector debe comprender las bases disciplina, estudiadas los capí-tulos , para enriquecerse información que aquí expone. muchos los temas examinados reflejan práctica ingeniería software industrial desarrollo sistemas distribuidos tiempo real. reutilización software convertido ahora paradigma desarrollo dominante para los sistemas información basados web los sistemas empresariales. enfoque más común reutilización cots, que gran sistema configura para las necesidades una organización que requiere poco nada desarrollo soft-ware original. capítulo introduce tema general reutiliza-ción enfoca reutilización sistemas cots. capítulo refiere también reutilización componentes software vez sistemas software completos. ingeniería soft-ware basada componentes proceso configuración, donde desarrolla nuevo código para integrar los componentes reutilizables. este capítulo explica que entiende por componente por qué necesitan modelos componente estándar para reutilización efectiva componentes. además, analiza proceso general ingenie-ría software basada componentes los problemas composi-ción componentes.parte software avanzada -.indd -.indd // :: // :: pmla mayoría los grandes sistemas son actualmente sistemas distribui- dos, capítulo ocupa los conflictos problemas construir sistemas distribuidos. introduce enfoque cliente-servidor como paradigma fundamental ingeniería sistemas distribuidos, exponen varias formas implementar este estilo arquitectónico. sección final este capítulo refiere cómo hecho proporcionar software, para servicio aplicación distribuido, cambiará forma radical mercado los productos software. capítulo introduce tema relacionado las arquitecturas orien- tadas servicio, que vinculan las nociones distribución reutiliza-ción. los servicios son componentes software reutilización, cuya funcionalidad está disponible través internet para una amplia gama clientes. este capítulo explica qué implica creación servi-cios (ingeniería servicios) composición servicios para elaborar nuevos sistemas software. los sistemas embebidos son los ejemplos sistemas software usa- dos más ampliamente, capítulo ocupa este importante tema. presenta concepto sistema embebido tiempo real describe tres patrones arquitectónicos utilizados diseño siste-mas embebidos. más adelante, detalla proceso análisis tempori-zación (timing) concluye con estudio los sistemas operativos tiempo real. finalmente, capítulo versa sobre desarrollo software orien- tado aspectos (aosd, por las siglas aspect-oriented software deve-lopment). aosd relaciona también con reutilización propone nuevo enfoque, basado aspectos, para organizar estructurar siste-mas software. aun cuando todavía una corriente principal ingeniería software, aosd tiene potencial mejorar significati-vamente los enfoques actuales para implementación software. -.indd -.indd // :: // :: pmobjetivos los objetivos este capítulo son introducir lector reutilización software describir los enfoques para desarrollo sistemas basados reutilización sistemas gran escala. estudiar este capítulo: ■ comprenderá los beneficios problemas reutilización del software cuando desarrollan nuevos sistemas; ■ entenderá concepto framework (estructura) aplicación como conjunto objetos reutilizables cómo pueden usarse los frameworks desarrollo aplicaciones; ■ introducirá las líneas producto software, que constituyen con una arquitectura central común componentes configurables reutilización; ■ aprenderá cómo pueden desarrollarse sistemas configurar componer sistemas software aplicación comercial. contenido . panorama reutilización . frameworks aplicación . líneas productos software . reutilización productos cots reutilización software -.indd -.indd // :: // :: capítulo ■ reutilización software ingeniería software basada reutilización una estrategia que engrana proceso desarrollo para reutilizar software existente. aunque reutilización propuso como una estrategia desarrollo hace más años (mcilroy, ), sólo partir cuando “desarrollo con reutilización” convirtió norma los nue-vos sistemas empresariales. movimiento hacia desarrollo basado reutilización fue respuesta las demandas para reducir los costos producción mantenimiento del software, entregar los sistemas con mayor rapidez aumentar calidad del software. cada vez más compañías consideran software como activo valioso. así, promueven reutilización para incrementar rendimiento las inversiones software. disponibilidad software reutilizable aumentó drásticamente. movimiento fuente abierta significó que dispone una enorme base código reutilización bajo costo. esto puede ser forma librerías programa aplicaciones completas. existen muchos sistemas aplicación dominio específico disponibles que pueden ajustarse adaptarse las necesidades una compañía específica. algunas grandes com-pañías ofrecen varios componentes reutilización para sus clientes. los estándares, como los estándares servicios web, han facilitado desarrollo servicios generales reutilización través varias aplicaciones. ingeniería software basada reutilización enfoque desarrollo que trata maximizar reutilización del software existente. las unidades software que reutilizan pueden ser tamaños sustancialmente diferentes. por ejemplo: . reutilización del sistema aplicación todo sistema aplicación puede reuti- lizarse incorporarlo sin cambios otros sistemas configurar aplicación para diferentes clientes. manera alternativa, pueden desarrollarse familias aplica-ción que, aunque tengan una arquitectura común, ajustan clientes específicos. más adelante, este capítulo, hablará reutilización componentes. . reutilización componentes los componentes una aplicación, que varían tamaño desde subsistemas hasta objetos individuales, pueden reutilizarse. por ejem-plo, sistema identificación patrones desarrollado como parte sistema procesamiento texto puede reutilizarse sistema administración base datos. reutilización componentes desarrolla los capítulos . . reutilización objetos funciones pueden reutilizarse los componentes soft-ware que implementan una sola función, tal como una función matemática, una clase objeto. esta forma reutilización torno librerías estándar sido común durante los últimos años. muchas librerías funciones clases están dis-ponibles manera gratuita. las clases funciones dichas librerías reutilizan vincularlas con código aplicación desarrollo reciente. este enfoque particularmente efectivo áreas como algoritmos matemáticos gráficas, donde necesita experiencia especializada para desarrollar objetos funciones eficientes. los sistemas componentes software son entidades potencialmente reutilizables, pero naturaleza específica significa que ocasiones costoso modificarlos para una nueva situación. una forma complementaria reutilización “reutilización con-cepto” que, vez reutilizar componente software, reutiliza una idea, una vía, funcionamiento algoritmo. concepto que reutiliza representa una notación abstracta (por ejemplo, modelo sistema), que incluye detalles implementación. por tanto, puede configurarse adaptarse para varias situaciones. concepto reutilización puede incorporarse como diseño patrones diseño (que estudiaron capítulo ), productos sistema configurables generadores -.indd -.indd // :: // :: pmcapítulo ■ reutilización software programa. cuando reutilizan conceptos, proceso reutilización incluye una activi- dad donde los conceptos abstractos ejemplifican para crear componentes ejecutables reutilización. una ventaja evidente reutilización software que deberían reducirse los costos totales desarrollo. habrá que especificar, diseñar, implementar validar menos componentes software. sin embargo, reducción del costo sólo una ventaja reutilización. figura . mencionan otras ventajas reutilización los activos software. obstante, existen costos problemas asociados con reutilización (figura .). hay costo significativo asociado con entender componente adecuado para reutilización una situación particular, probar dicho componente para garanti-zar confiabilidad. tales costos adicionales significan que las reducciones los costos totales del desarrollo mediante reutilización pueden ser menores que previsto. como estudió capítulo , los procesos desarrollo software deben adap-tarse para tomar cuenta reutilización. particular, debe haber una etapa correc-ción requerimientos que modifiquen los requerimientos del sistema para reflejar software reutilización disponible. las etapas diseño implementación del sistema pueden incluir también actividades explícitas para buscar evaluar compo-nentes candidatos para reutilización. reutilización software más efectiva cuando planea como parte pro-grama reutilización toda organización. programa reutilización implica creación activos reutilizables adaptación procesos desarrollo para incorporar dichos activos software nuevo. importancia planeación reutilización reconoce desde hace varios años japón (matsumoto, ), donde reutilización era parte integral del enfoque “fabril” japonés desarrollo software (cusamano, ). beneficio explicación confiabilidad creciente software reutilización, que experimentó ensayó sistemas operativos, debe ser más confiable que software nuevo. sus fallas diseño implementación debieron descubrirse corregirse. reducción riesgo procesose conoce costo del software existente, mientras que desarrollo siempre una cuestión juicio. éste factor importante para gestión del proyecto, que reduce margen error estimación costos del proyecto. esto particularmente cierto cuando reutilizan componentes software relativamente grandes, como los subsistemas. uso efectivo especialistas lugar hacer mismo trabajo una otra vez, los especialistas aplicación pueden desarrollar software reutilización que encapsule conocimiento. cumplimiento estándares algunos estándares, como los interfaz usuario, pueden implementarse como conjunto componentes reutilización. por ejemplo, los menús una interfaz usuario implementan con componentes reutilizables, todas las aplicaciones presentan los usuarios los mismos formatos menú. uso interfaces usuario estándar mejora confiabilidad, porque los usuarios cometen menos errores cuando les presenta una interfaz familiar. desarrollo acelerado llevar sistema mercado tan rápido como sea posible con frecuencia más importante que los costos totales desarrollo. reutilización software puede acelerar producción del sistema, que pueden reducirse los tiempos desarrollo validación. figura . beneficios reutilización software -.indd -.indd // :: // :: capítulo ■ reutilización software compañías tales como hewlett-packard han tenido también mucho éxito sus progra- mas reutilización (griss wosser, ), experiencia documentó libro jacobson . (). . panorama reutilización durante los últimos años, han desarrollado muchas técnicas para apoyar reutili-zación software. dichas técnicas aprovechan hecho que los sistemas mismo dominio aplicación son similares tienen potencial reutilización (esa reutilización posible diferentes niveles desde simples funciones hasta completas aplicaciones), hecho que estándares para componentes reutilizables facilitan reutilización. figura . establece algunas formas posibles implementar reutilización soft-ware, figura . describe brevemente cada una ellas. teniendo cuenta este arreglo técnicas para reutilización, pregunta clave : ¿cuál técnica más adecuada para usar una situación particular? desde luego, esto depende los requerimientos del sistema desarrollar, tecnología los activos reutilizables disponibles, experiencia del equipo desarrollo. los factores clave que deben considerarse planear reutilización son: . calendario desarrollo para software software debe desarrollar- rápidamente, usted debe tratar reutilizar sistemas comerciales vez problema explicación costos crecientes mantenimientosi está disponible código fuente sistema componente software reutilización, entonces los costos mantenimiento podrían ser superiores, porque los elementos reutilizados del sistema pueden volverse cada vez más incompatibles con los cambios del sistema. falta apoyo herramientasalgunas herramientas software apoyan desarrollo con reutilización. tal vez sea difícil imposible integrar dichas herramientas con sistema librería componentes. proceso software supuesto por dichas herramientas quizá tome cuenta reutilización. esto particularmente cierto para herramientas que dan apoyo ingeniería sistemas embebidos, aunque menos cierto para herramientas desarrollo orientadas objetos. síndrome “ inventó aquí”algunos ingenieros software prefieren rescribir los componentes, porque consideran que pueden mejorarlos. esto parte tiene que ver con confianza parte con hecho que escribir software original observa como más desafiante que reutilizar software alguien más. creación, mantenimiento uso una librería componentessuele ser costoso dotar una librería componentes reutilización garantizar que los desarrolladores software puedan utilizar esta librería. hay que adaptar procesos desarrollo para asegurar que use librería. descubrimiento, comprensión adaptación componentes reutilización deben descubrirse componentes software una librería, entenderse , ocasiones, adaptarse para trabajar nuevo entorno. los ingenieros deben estar ampliamente seguros encontrar componente librería antes incluir una búsqueda componentes como parte proceso desarrollo normal. figura . problemas con reutilización -.indd -.indd // :: // :: . ■ panorama reutilización componentes individuales. éstos son activos reutilizables grano grueso. aunque ajuste con los requerimientos tal vez sea imperfecto, este enfoque minimiza cantidad desarrollo requerido. . vida esperada del software usted desarrolla sistema prolongada dura-ción, debe enfocarse capacidad mantenimiento del sistema. sólo debe considerar los beneficios inmediatos reutilización, sino también las implicacio-nes largo plazo. durante vida útil, podrá adaptar sistema nuevos requerimientos, que sig- nificará hacer cambios partes del sistema. tiene acceso código fuente, preferible evitar los componentes cots (véase sección .) los sistemas proveedores externos, pues éstos tal vez sean capaces continuar con servicio apoyo para software reutilización. . los antecedentes, las habilidades experiencia del equipo desarrollo todas las tecnologías reutilización son bastante complejas, necesario mucho tiempo para entenderlas usarlas manera efectiva. por consiguiente, equi- desarrollo tiene habilidades área particular, probablemente ahí donde deban enfocarse. . criticidad del software sus requerimientos funcionales para sistema crítico que deba certificarse mediante regulador externo, quizá deba crear caso confiabilidad para sistema (como estudió capítulo ). esto difícil tiene acceso código fuente del software. software cuenta con requerimientos rigurosos rendimiento, tal vez sea imposible usar estrategias tales como reutilización basada generador, donde código forma partir una representación reutilización específica dominio sistema. estos sistemas menudo crean código relativamente ineficiente. . dominio aplicación algunos dominios aplicación, tales como los sis-temas fabricación información médica, existen muchos productos genéricos que pueden reutilizarse configurarlos para una situación local. trabaja tal dominio, siempre debe considerarlo como una opción.patrones diseño ingeniería software basada componentesframeworks aplicación sistemas orientados serviciointegración cotslíneas producto software encadenamiento sistemas heredados librerías programageneradores programadesarrollo software orientado aspectosaplicaciones verticales configurablespatrones arquitectónicos sistemas erp ingeniería dirigida por modelo figura . panorama reutilización -.indd -.indd // :: // :: capítulo ■ reutilización software . plataforma que operará sistema algunos modelos componentes, como .net, especifican para plataformas microsoft. igual modo, sistemas genéricos aplicación pueden ser específicos plataforma sólo podrá reutilizar-los sistema está diseñado para misma plataforma.enfoque descripción patrones arquitectónicos usan arquitecturas software estándar que apoyan tipos comunes sistemas aplicación, tales como base las aplicaciones. describen los capítulos , . patrones diseño las abstracciones genéricas que ocurren través las aplicaciones representan como patrones diseño que muestran objetos interacciones abstractas concretas. detallan capítulo . desarrollo basado componentesse desarrollan sistemas integrar componentes (colecciones objetos) que conforman estándares modelo componentes. estudian capítulo . frameworks aplicación colecciones clases abstractas concretas adaptadas extendidas para crear sistemas aplicación. encadenamiento sistemas heredadoslos sistemas heredados (véase capítulo ) “enlazan” definir conjunto interfaces proporcionar acceso estos sistemas heredados través dichas interfaces. sistemas orientados servicios desarrollan sistemas mediante vinculación servicios compartidos, que pueden proporcionarse externamente. tratan capítulo . líneas producto software tipo aplicación generaliza torno una arquitectura común, forma que pueda adaptarse para diferentes clientes. reutilización productos cots los sistemas desarrollan configurar integrar sistemas aplicación existentes. sistemas erp los sistemas gran escala que encapsulan funcionalidad empresarial genérica reglas configuran para una organización. aplicaciones verticales configurablesse diseñan sistemas genéricos manera que puedan configurarse las necesidades específicas clientes del sistema. librerías programa librerías clase función que implementan abstracciones uso común están disponibles para reutilización. ingeniería dirigida por modelo software representa como modelos dominio modelos independientes implementación, genera código partir dichos modelos. refiere capítulo . generadores programa sistema generador incrusta conocimiento tipo aplicación usa para generar sistemas dicho dominio partir modelo sistema suministrado por usuario. desarrollo software orientado aspectos cuando compila programa, los componentes compartidos hilvanan dentro una aplicación lugares diferentes. expone capítulo . figura . enfoques que apoyan reutilización software -.indd -.indd // :: // :: . ■ frameworks aplicación gama técnicas disponibles reutilización tal que, mayoría las situa- ciones, existe posibilidad cierta reutilización software. sea que logre reutilización, con frecuencia conflicto administrativo más que técnico. los administradores pueden estar ansiosos comprometer sus requerimientos para permi-tir uso componentes reutilización. posible que comprendan los riesgos asociados con reutilización, tanto como entienden los riesgos del desarrollo original. aunque los riesgos del desarrollo nuevo software pueden ser elevados, algunos admi-nistradores prefieren los riesgos conocidos los desconocidos. . frameworks aplicación los primeros entusiastas del desarrollo orientado objetos sugerían que uno los bene-ficios clave usar enfoque orientado objetos era que éstos pudieran reutilizarse diferentes sistemas. sin embargo, experiencia demostró que los objetos normalmente son muy pequeños están especializados para una aplicación particular. entender adaptar objeto tarda más tiempo que volver implementarlo. ahora vuelto claro que reutilización orientada objetos tiene mejor apoyo proceso desarrollo orientado objetos través abstracciones grano más grueso, llamadas frameworks (estructuras). como sugiere nombre, framework una estructura genérica que extiende para crear una aplicación subsistema más específico. schmidt sus colaboradores () definen framework como: . . . conjunto integrado artefactos software (tales como clases, objetos componentes), que colaboran facilitación una arquitectura reutiliza-ción para una familia aplicaciones relacionadas. los frameworks brindan soporte para características genéricas que probable que sean utilizadas todas las aplicaciones tipo similar. por ejemplo, framework interfaz usuario ofrecerá soporte para manejo evento interfaz, incluirá con-junto artilugios que pueden usarse para construir despliegues. entonces permite desarrollador especializar éstos agregar funcionalidad específica para una aplicación par-ticular. por ejemplo, framework interfaz usuario, desarrollador define planti-llas despliegue adecuadas para aplicación implementar. los frameworks apoyan reutilización diseño que ofrecen una arquitectura que sirve esqueleto para aplicación, así como reutilización clases específicas reutilización basada generador reutilización basada generador consiste incorporar conceptos conocimiento reutilizables herramientas automatizadas, ofrecer una forma sencilla que los usuarios herramienta integren código específico con este conocimiento genérico. por general, este enfoque más efectivo aplicaciones específicas dominio. soluciones conocidas los problemas dicho dominio incrustan sistema generador usuario las selecciona para crear nuevo sistema. http:// -.indd -.indd // :: // :: capítulo ■ reutilización software sistema. arquitectura define por las clases objetos sus interacciones. las clases reutilizan directamente pueden extenderse utilizando características como herencia. los frameworks implementan como una colección clases objetos concretos abstractos lenguaje programación orientado objetos. por tanto, los fra-meworks son específicos del lenguaje. existen frameworks disponibles todos los len-guajes programación orientados objetos uso común (por ejemplo, java, #, ++, así como lenguajes dinámicos como ruby python). hecho, framework puede incorporar muchos otros frameworks, cada uno los cuales diseña para soportar desarrollo parte aplicación. posible usar framework para crear una aplicación completa implementar parte una aplicación, como interfaz usuario gráfica. fayad schmidt () analizan tres clases frameworks: . frameworks infraestructura sistema dichos frameworks apoyan desa- rrollo infraestructuras sistema como comunicaciones, interfaces usuario compiladores (schmidt, ). . frameworks integración middleware consisten conjunto están- dares clases objetos asociados que soportan comunicación componentes intercambio información. los ejemplos este tipo framework incluyen .net microsoft enterprise java beans (ejb). dichos frameworks brindan soporte para modelos estandarizados componentes, como estudia capítulo . . frameworks aplicación empresarial ocupan dominios aplicación específicos, tales como los sistemas telecomunicaciones financieros (baumer ., ). conocimiento del dominio aplicación integra apoya desa-rrollo aplicaciones usuario final. los frameworks aplicación web (waf) son tipo framework más reciente importante. ahora los waf, que apoyan construcción sitios web dinámicos, están ampliamente disponibles. arquitectura waf basa por general -trón compuesto modelo-vista-controlador (mvc) (gamma ., ), que muestra figura .. patrón mvc propuso originalmente década , como enfo-que diseño gui que permitía múltiples presentaciones objeto separaba estilos interacción con cada una estas presentaciones. permite separación del estado métodos del controlador métodos vistaentradas usuariover mensajes modificación edición del modeloconsultas actualizacionesdel modeloestado del controlador estado vista métodos del modeloestado del modelo figura . patrón modelo-vista- controlador -.indd -.indd // :: // :: . ■ frameworks aplicación aplicación interfaz usuario aplicación. framework mvc permite pre- sentación datos diferentes formas admite interacción con cada una dichas presentaciones. cuando los datos modifican través una las presentaciones, modifica modelo del sistema los controladores asociados con cada punto vista actualizan presentación. menudo, los frameworks son implementaciones patrones diseño, como estu-dió capítulo . por ejemplo, framework mvc incluye patrón observer, patrón strategy, patrón composite algunos otros que analizan gamma sus colabora-dores (). naturaleza general los patrones uso clases abstractas concre-tas permite extensibilidad. casi seguro que, sin patrones, los frameworks serían poco prácticos. los frameworks aplicación web incorporan regularmente uno más frameworks especializados que apoyen las características específicas aplicación. aunque cada fra-mework incluye funcionalidad sutilmente diferente, mayoría los frameworks aplicación web soportan las siguientes características: . seguridad los waf pueden incluir clases para ayudar implementar autentica- ción usuario (login) control acceso para garantizar que los usuarios sólo puedan tener acceso funcionalidad que permite sistema. . páginas web dinámicas ofrecen clases para ayudar definir las plantillas página web dotar dinámicamente éstas con datos específicos base datos del sistema. . soporte base datos los frameworks usualmente incluyen una base datos, sino suponen que usará una base datos separada, como mysql. fra-mework puede proporcionar clases que ofrezcan una interfaz abstracta diferentes bases datos. . gestión sesión clases para crear administrar sesiones (algunas interacciones con sistema por parte usuario) por general son parte waf. . interacción usuarios mayoría los frameworks web brindan ahora soporte ajax (holdener, ), que permite creación páginas web más interactivas. para extender framework necesario cambiar código éste. vez ello, usted agrega clases concretas que heredan operaciones clases abstractas frame-work. además, quizá deba definir callbacks (comunicaciones regreso). los callbacks son métodos que solicitan respuesta eventos reconocidos por framework. schmidt sus colaboradores () llaman esto “inversión control”. los objetos framework, los objetos específicos aplicación, son los responsables del control sistema. respuesta eventos interfaz del usuario, base datos, etcétera, dichos objetos framework recurren “métodos gancho” que entonces vinculan funciona-lidad que proporciona usuario. funcionalidad específica aplicación responde una forma adecuada evento (figura .). por ejemplo, framework tendrá método que manipule clic del ratón desde entorno. este método llama método gancho, que usted debe configurar con finalidad llamar los métodos aplicación adecuados para manejar clic del ratón. las aplicaciones que construyen utilizando frameworks pueden ser base para una posterior reutilización través del concepto líneas producto software familias -.indd -.indd // :: // :: capítulo ■ reutilización software aplicación. puesto que dichas aplicaciones construyen mediante framework, modificación los miembros familia para crear instancias del sistema con fre-cuencia proceso directo. implica rescribir clases métodos concretos que deberán adicionarse framework. sin embargo, los frameworks usualmente son más generales que las líneas pro-ducto software, enfocadas una familia específica sistemas aplicación. por ejemplo, posible usar framework basado web para construir diversos tipos aplicaciones basadas web. uno éstos podría ser una línea productos software que soporte escritorios ayuda basados web. entonces esta “línea productos escritorio ayuda” puede especializarse aún más para ofrecer tipos particulares soporte escritorio ayuda. los frameworks son enfoque efectivo reutilización, aunque costosos para intro-ducirse procesos desarrollo software. consideran inherentemente complejos, aprender usarlos una actividad que tal vez dure muchos meses. también posible que sea difícil costoso evaluar frameworks disponibles para elegir los más adecuados. depurar las aplicaciones basadas frameworks resulta complicado, porque tal vez comprenda cómo interactúan los métodos framework. éste problema general con software reutilización. las herramientas depuración pueden brindar datos sobre los componentes del sistema reutilización que desarrollador entiende. . líneas productos software uno los enfoques más efectivos para reutilización creación líneas pro-ductos software familias aplicación. una línea productos software conjunto aplicaciones con una arquitectura común componentes compartidos, con cada aplicación especializada para reflejar diferentes requerimientos. sistema central diseña para configurarse adaptarse las necesidades los diferentes clientes del sistema. esto puede implicar configuración algunos componentes, implementar componentes adicionales modificar varios los componentes acuerdo con nuevos requerimientos.clases específicas aplicación base datosciclo eventocallbacks callbackscallbacks plataformaciclo eventoguiciclo evento figura . inversión control frameworks -.indd -.indd // :: // :: . ■ líneas productos software desarrollar aplicaciones mediante adaptación una versión genérica apli- cación significa que reutiliza una alta proporción del código aplicación. además, experiencia aplicación muchas veces transferible sistema otro. consecuencia, cuando los ingenieros software reúnen equipo desarrollo, acorta proceso aprendizaje. las pruebas simplifican porque éstas también pue-den reutilizarse para gran parte aplicación, que consecuencia reduce tiempo total del desarrollo aplicación. las líneas producto software surgen por general aplicaciones existentes. esto , una organización desarrolla una aplicación , luego, cuando requiere sistema similar, código ésta reutiliza manera informal nueva aplicación. mismo proceso usa conforme desarrollan otras aplicaciones similares. sin embargo, cam-bio tiende corromper estructura aplicación, así que, medida que desarrollan más instancias nuevas, vuelve cada vez más difícil crear una nueva versión. por consi-guiente, puede tomarse entonces una decisión para diseñar una línea productos genéri-cos. esto implica identificar funcionalidad común instancias producto incluirla una aplicación base, que después usa para desarrollo futuro. esta aplicación base estructura deliberadamente para simplificar reutilización reconfiguración. desde luego, los frameworks aplicación las líneas productos software tienen mucho común. ambos soportan una arquitectura componentes comunes, requieren nuevo desarrollo para crear una versión específica sistema. las prin-cipales diferencias entre dichos enfoques son las siguientes: . los frameworks aplicación apoyan características orientadas objetos, como herencia polimorfismo, para implementar extensiones framework. por general, código framework modifica las posibles modificaciones están limitadas que permite framework. las líneas producto software necesariamente crean mediante enfoque orientado objetos. los componentes aplicación cambian, borran rescriben. hay límites, menos principio, para que puedan realizarse cambios. . los frameworks aplicación enfocan principalmente brindar apoyo técnico antes que dominio específico. por ejemplo, existen frameworks aplicación para crear aplicaciones basadas web. una línea productos software por gene-ral incrusta información detallada dominio plataforma. por ejemplo, podría haber una línea productos software que ocupe aplicaciones basadas web para administración registros salud. . las líneas producto software generalmente son aplicaciones control para equipo. por ejemplo, puede haber una línea productos software para una fami-lia impresoras. esto significa que línea productos debe dar soporte para interfaz hardware. los frameworks aplicación con frecuencia están orientados software, pocas veces ofrecen soporte para interfaz hardware. . las líneas productos hardware constituyen una familia aplicaciones relaciona- das, propiedad misma organización. cuando usted crea una nueva aplicación, punto partida habitualmente miembro más cercano familia aplicación, aplicación central genérica. desarrolla una línea productos software usando lenguaje programación orientado objetos, ese momento puede usar framework aplicación como base del -.indd -.indd // :: // :: capítulo ■ reutilización software sistema. usted crea núcleo línea productos extender framework con com- ponentes específicos dominio, través sus mecanismos internos. entonces hay una segunda fase desarrollo, donde crean versiones del sistema para diferentes clientes. pueden desarrollarse varios tipos especialización una línea productos software: . especialización plataforma elaboran versiones aplicación para dife- rentes plataformas. por ejemplo, pueden existir versiones aplicación para plata-formas windows, mac linux. este caso, funcionalidad aplicación por regular cambia; sólo modifican aquellos componentes que hacen inter-faz con hardware sistema operativo. . especialización entorno crean versiones aplicación para manejar entornos operacionales particulares dispositivos periféricos. por ejemplo, sistema para los servicios emergencia puede existir diferentes versiones, dependiendo del sistema comunicaciones los vehículos. este caso, los componentes del sis-tema cambian para reflejar funcionalidad del equipo comunicación utilizado. . especialización funcional crean versiones aplicación para clientes especí-ficos que tengan diferentes requerimientos. por ejemplo, sistema automati-zación bibliotecario podrá modificar función utiliza una biblioteca pública, una biblioteca consulta una biblioteca universitaria. tal caso, posible variar los componentes que implementan funcionalidad agregar sis-tema nuevos componentes. . especialización proceso sistema adapta para hacer frente los procesos empresariales específicos. por ejemplo, sistema pedidos puede adaptarse para enfrentarse con proceso pedidos centralizado una compañía con pro-ceso distribuido otra. arquitectura una línea productos software con frecuencia refleja estilo patrón arquitectónico general, específico para una aplicación. por ejemplo, considere sistema línea productos que diseñe con finalidad manejar salidas vehículos para servicios emergencia. los operadores este sistema reciben las lla-madas los incidentes, localizan vehículo adecuado para responder emergencia envían vehículo sitio del incidente. los desarrolladores tal sistema pueden comercializar versiones éste para los servicios policía, bomberos ambulancias. este sistema envío vehículos ejemplo una arquitectura gestión recursos (figura .). figura . ejemplifica dicha estructura cuatro capas, muestran los módulos que posible incluir una línea productos sistemas envío vehículos. los componentes cada nivel sistema línea productos son los siguientes: . nivel interacción, existen componentes que ofrecen una interfaz pantalla operador una interfaz con los sistemas comunicaciones usados. . nivel gestión / (nivel ), hay componentes que manejan autenticación del operador, generan reportes incidentes vehículos enviados, permiten salida mapas planeación rutas, ofrecen mecanismo para que los operadores consul-ten las bases datos del sistema. -.indd -.indd // :: // :: . ■ líneas productos software . nivel gestión recursos (nivel ) existen componentes que permiten locali- zación envío vehículos, componentes para actualizar estatus los vehícu- los equipo, componente para registrar detalles incidentes. . nivel base datos, además del apoyo gestión transacción usual, existen bases datos separadas vehículos, equipo mapas.interfaz usuario rastreo recursospolítica control recursosasignación recursosautenticación usuariosgestión consultaentrega recursos gestión transacción base datos recursosinteracción gestión / gestión recursos gestión base datos figura . arquitectura sistema asignación recursos autenticación operadores gestor estatus vehículosbitácora incidentesdespachador vehículosgestor equipolocalizador vehículosplaneador mapas rutasgestor consultagenerador reportesinterfaz del operadorinterfaz sistemas comunicaciones base datos equipobase datos vehículos base datos mapasbitácora incidentes gestión transacciónfigura . arquitectura línea productos sistema envío vehículos -.indd -.indd // :: // :: capítulo ■ reutilización software para crear una versión específica este sistema, habrá que modificar los componen- tes individuales. por ejemplo, policía tiene mayor número vehículos, pero menor número tipos vehículos, mientras que los bomberos cuentan con muchos tipos vehículos especializados. consecuencia, tal vez sea necesario definir una estructura diferente base datos vehículos cuando implemente sistema para esos dis-tintos servicios. figura . muestra los pasos considerados extensión una línea produc-tos software para crear una nueva aplicación. tales pasos este proceso general son los siguientes: . adquirir requerimientos las partes interesadas puede comenzar con proceso ingeniería requerimientos normal. sin embargo, puesto que existe sis-tema, éste deberá comprobarse para luego hacer que los interesados experimenten expresen sus requerimientos como modificaciones las funciones ofrecidas. . seleccionar sistema existente que ajuste más los requerimientos cuando crea nuevo miembro una línea productos, puede comenzar con instan-cia más cercana producto. analizan los requerimientos elige modificar miembro familia más cercano. . renegociar los requerimientos conforme surgen más detalles cambios reque-ridos proyecto planea, puede haber alguna renegociación requerimientos para minimizar los cambios necesarios. . adaptar sistema existente desarrollan nuevos módulos para sistema exis-tente, los módulos sistema existentes adaptan para cumplir con los nuevos requerimientos. . entregar nuevo miembro familia entrega cliente nueva instancia línea producto. esta etapa, usted debería documentar las características clave, manera que pueda usarse futuro como base para otros desarrollos sistema. cuando usted crea nuevo miembro una línea productos, probable que encuentre compromiso entre reutilizar mayor cantidad aplicación genérica posible satisfacer los requerimientos detallados las partes interesadas. cuanto más detallados sean los requerimientos del sistema, menos probabilidad tendrá que los componentes existentes cumplan tales requerimientos. sin embargo, las partes inte-resadas desean ser flexibles limitar las modificaciones que requiera sistema, por general podrá entregar sistema más rápido menor costo. las líneas productos software diseñan para reconfigurarse, esta reconfigura-ción puede implicar agregar eliminar componentes del sistema, definir parámetros adquirir requerimientos las partes interesadaselegir instancia sistema más cercana entregar nueva instancia sistemarenegociar requerimientos adaptar sistema existente figura . desarrollo instancias producto -.indd -.indd // :: // :: . ■ líneas productos software restricciones para componentes del sistema, incluir conocimiento procesos empresa- riales. esta configuración puede ocurrir diferentes etapas proceso desarrollo: . configuración tiempo diseño organización que desarrolla software modifica una línea común productos básicos mediante desarrollo, selección adaptación componentes para crear nuevo sistema para cliente. . configuración tiempo implementación diseña sistema genérico para configuración por parte cliente algún consultor que trabaje con cliente. conocimiento los requerimientos específicos del cliente entorno operacio-nal del sistema incrustan conjunto archivos configuración que usa sistema genérico. cuando sistema configura tiempo diseño, proveedor comienza sea con sistema genérico con una instancia producto existente. modificar extender los módulos este sistema crea sistema específico que entrega funcionalidad requerida por cliente. esto implica, por general, cambiar extender código fuente del sistema, manera que posible mayor flexibilidad que con configuración tiempo implementación. configuración tiempo implementación supone usar una herramienta para crear una configuración específica del sistema que registre una base datos como conjunto archivos configuración (figura .). sistema ejecución consulta esta base datos cuando ejecuta, así que funcionalidad puede especializarse para contexto ejecución. existen muchos niveles configuración tiempo implementación que sistema puede proveer: . selección componentes, donde seleccionan los módulos sistema que ofrecen funcionalidad requerida. por ejemplo, sistema información pacientes, posible seleccionar componente gestión imagen que permita vincular imágenes médicas (rayos , tomografías, etcétera) con registro médico del paciente. . definición flujo trabajo reglas, donde definen los flujos trabajo (cómo procesa información, etapa por etapa) reglas validación que deben apli-carse información que los usuarios ingresen que genere sistema.configuración base datos sistema base datos sistema genéricoconfiguración herramienta planeación figura . configuración tiempo diseño -.indd -.indd // :: // :: capítulo ■ reutilización software . definición parámetros, donde detallan los valores parámetros específicos del sistema, que reflejan instancia aplicación que crea. por ejemplo, puede especificarse longitud máxima los campos para entrada datos por parte usuario las características del hardware unido sistema. configuración implementación través despliegue pantalla puede ser muy compleja, labor configurar sistema para cliente tal vez tarde muchos meses. los grandes sistemas configurables pueden apoyar proceso configuración ofrecer herramientas software, tales como herramientas planeación configu-ración, para apoyar proceso configuración. sección .. estudia con más detalle configuración implementación través despliegue pantalla. esto cubre reutilización sistemas cots que deben configurarse para trabajar diferen-tes entornos potenciales. configuración tiempo diseño usa cuando imposible utilizar las instalacio-nes existentes configuración implementación través despliegue pantalla sistema para desarrollar una nueva versión del sistema. sin embargo, con tiempo, cuando crean varios miembros familia con funcionalidad comparable, puede decidir refactoriza línea central productos para incluir funcionalidad que haya implementado varios miembros familia aplicación. entonces hace configu-rable esta nueva funcionalidad cuando implementa sistema. . reutilización productos cots producto cots (por las siglas comercial-off-the-shelf ) sistema soft- ware que puede adaptarse las necesidades diferentes clientes sin cambiar código fuente del sistema. prácticamente todo software escritorio una gran variedad productos del servidor son software cots. puesto que este software diseña para uso general, incluye regularmente muchas características funciones. por consiguiente, tiene potencial reutilización diferentes entornos como parte diversas aplicaciones. torchiano morisio () descubrieron que los productos código abierto usaron menudo como productos cots. esto , los sistemas abiertos empleaban sin cambiar observar código fuente. los productos cots adaptan usar mecanismos configuración internos que permiten que funcionalidad del sistema adecue necesidades específicas del cliente. por ejemplo, sistema registro pacientes hospital, pueden definirse for-matos entrada reportes salida separados para diferentes tipos pacientes. otras características configuración permiten sistema aceptar plug-ins que extiendan funcionalidad comprueben las entradas del usuario para garantizar que son válidas. este enfoque para reutilización del software adoptó ampliamente grandes compañías durante los últimos años, puesto que ofrece beneficios significativos sobre desarrollo software personalizado: . igual que sucede con otros tipos reutilización, posible implementación más rápida sistema fiable. -.indd -.indd // :: // :: . ■ reutilización productos cots . posible ver qué funcionalidad ofrece aplicación, manera que más fácil juzgar probable que sea adecuada . quizás otras compañías usen las aplicaciones, manera que existen antecedentes experiencia con sistema. . evitan algunos riesgos desarrollo usar software existente. sin embargo, este enfoque tiene sus propios riesgos, como verá más adelante. . las empresas pueden enfocarse actividad central sin tener que dedicar muchos recursos desarrollo sistemas . . conforme evolucionan las plataformas operativas, las actualizaciones tecnología pueden simplificar, pues éstas son responsabilidad del proveedor del producto cots del cliente. desde luego, este enfoque ingeniería software entraña ciertos problemas: . tienen que adaptarse los requerimientos para reflejar funcionalidad modo operación del producto cots. esto puede conducir cambios bruscos los proce- sos empresariales existentes. . producto cots puede basarse suposiciones que sean casi imposibles cambiar. por tanto, cliente debe adaptar empresa para reflejar dichas supo-siciones. . elegir sistema cots correcto para una empresa puede ser proceso difícil, especial porque muchos productos cots están debidamente documentados. tomar decisión equivocada podría ser desastroso, que tal vez sea imposible hacer funcionar nuevo sistema como requiere. . quizá haya experiencia local para apoyar desarrollo los sistemas. con- secuencia, cliente deberá apoyarse proveedor consultores externos para obtener consejos desarrollo. estos consejos podrían estar sesgados dirigidos vender productos servicios, satisfacer las necesidades reales del cliente. . los proveedores productos cots controlan soporte evolución del sistema. pueden salir del negocio, perder control incluso hacer cambios que ocasionen dificultades los clientes. reutilización software basado cots cada vez vuelto más común. vasta mayoría los nuevos sistemas procesamiento información empresarial construyen ahora utilizando cots, vez emplear enfoque orientado objetos. aunque con frecuencia hay problemas con este enfoque para desarrollo sistemas (tracz, ), las historias éxito (baker, ; balk kedia, ; brownsword morris, ; pfarr reis, ) indican que reutilización basada cots reduce esfuerzo tiempo para implementar sistema. existen dos tipos reutilización productos cots, saber: sistemas solución cots sistemas integrados cots. los primeros consisten una aplicación genérica solo proveedor que configura acuerdo con los requerimientos del cliente. los sistemas integrados cots implican integración dos más sistemas cots (quizá -.indd -.indd // :: // :: capítulo ■ reutilización software diferentes proveedores) para crear sistema aplicación. figura . resume las diferencias entre estos diferentes enfoques. .. sistemas solución cots los sistemas solución cots son sistemas aplicación genéricos que pueden dise-ñarse para dar apoyo tipo empresa particular, actividad empresarial , oca-siones, toda empresa. por ejemplo, posible generar sistema solución cots para los dentistas que encargue registrar citas, llevar expedientes, programar lla-madas pacientes, etcétera. mayor escala, sistema planeación recursos empresariales (erp, por las siglas enterprise resource planning ) puede apoyar todas las actividades fabricación, pedidos servicio atención clientes una compañía grande. los sistemas solución cots específicos dominio, como los sistemas que brin-dan apoyo una función empresarial (por ejemplo, manejo documentos), ofrecen funcionalidad que requieren algunos usuarios potenciales. sin embargo, tales sistemas incorporan también suposiciones internas acerca cómo trabajan los usuarios, esto puede causar problemas situaciones específicas. por ejemplo, sistema que apoye tarea registrar estudiantes las universidades puede suponer que los estudiantes registrarán para obtener grado determinado una universidad. sin embargo, varias universidades colaboran para ofrecer grados conjuntos, entonces será casi imposi-ble representar esto sistema. los sistemas erp, como los producidos por sap bea, son sistemas integrados gran escala, diseñados para dar apoyo prácticas empresariales, tales como pedidos facturación, manejo inventarios fechas producción (’leary, ). proceso configuración para estos sistemas incluye recopilación información detallada acerca empresa los procesos empresariales del cliente, incrustan esto una base datos configuración. con frecuencia, ello requiere conocimiento detallado anotaciones herramientas configuración, por general realizan consultores que trabajan junto con los clientes del sistema.sistemas solución cots sistemas cots integrados solo producto que ofrece funcionalidad requerida por cliente.muchos productos heterogéneos sistema integran para ofrecer funcionalidad personalizada. basados una solución genérica procesos estandarizados.pueden desarrollarse soluciones flexibles para procesos del cliente. desarrollo enfoca configuración del sistema. desarrollo enfoca integración del sistema. proveedor del sistema responsable del mantenimiento. dueño del sistema responsable del mantenimiento. proveedor del sistema ofrece plataforma para sistema. dueño del sistema ofrece plataforma para sistema. figura . sistemas solución cots cots integrados -.indd -.indd // :: // :: . ■ reutilización productos cots sistema erp genérico contiene algunos módulos que pueden componerse diferentes formas con finalidad crear sistema para cliente. proceso configuración implica elegir cuáles módulos deben incluirse, configurar dichos módu-los individuales, definir los procesos las reglas empresariales, definir estructura organización base datos del sistema. figura . presenta modelo arquitectura global sistema erp que apoya algunas funciones empresariales. las características clave esta arquitectura son: . algunos módulos para dar apoyo diferentes funciones empresariales. estos módu- los grano grueso pueden apoyar departamentos divisiones enteros empresa. ejemplo que señala figura ., los módulos seleccionados para inclusión sistema son: módulo que apoya las compras, módulo que apoya gestión cadena abastecimiento, módulo logístico que apoya entrega bienes, módulo gestión atención cliente (crm, por las siglas customer relationship management) para mantener información sobre clientela. . conjunto definido procesos empresariales, asociados con cada módulo, que relaciona con actividades dicho módulo. por ejemplo, puede haber una definición del proceso pedidos que especifique cómo crear aprobar los pedidos. esto pre-cisará los roles las actividades implicados levantamiento pedidos. . una base datos común que mantiene información acerca todas las funcio- nes empresariales relacionadas. esto significa que debe ser necesario duplicar información, como los detalles cliente, diferentes partes empresa. . conjunto reglas empresariales que aplican todos los datos base datos. por tanto, cuando ingresan datos desde una función, dichas reglas deben garantizar que esto consistente con los datos requeridos por otras funciones. por ejemplo, tal vez exista una regla empresarial que establece que alguien mayor jerarquía que persona que hace solicitud debe aprobar todas las solicitudes gastos. los sistemas erp usan casi todas las grandes compañías para apoyar algu-nas todas sus funciones. por consiguiente, trata una forma reutilización base datos del sistemareglas empresarialescompras procesoscadena abastecimiento procesoslogística procesoscrm procesos figura . arquitectura sistema erp -.indd -.indd // :: // :: capítulo ■ reutilización software software ampliamente difundida. obstante, limitación evidente este enfoque reutilización que funcionalidad del sistema restringe funcionalidad del núcleo genérico. más aún, los procesos las operaciones una compañía tienen que expresarse lenguaje configuración del sistema, puede haber desajuste con-cordancia entre los conceptos empresa los conceptos incluidos lenguaje configuración. por ejemplo, sistema erp que vendió una universidad, debía definirse concepto cliente. esto causó grandes dificultades cuando configuró sistema. sin embargo, las universidades tienen múltiples tipos clientes, como estudiantes, agencias que patrocinan investigaciones, instituciones que proveen fondos educativos, etcétera, cada uno los cuales posee diferentes características. ninguno ellos realmente comparable noción cliente comercial (esto , una persona empresa que adquiere productos servicios). una discordancia seria entre modelo empresarial usado por sistema del comprador del sistema hace altamente probable que sis-tema erp cumpla con las necesidades reales del comprador (scott, ). tanto los productos dominio específico cots como los sistemas erp por gene-ral requieren una extensa configuración para adaptarlos los requerimientos cada organización donde instalan. esta configuración puede implicar: . seleccionar funcionalidad requerida del sistema (por ejemplo, decidir qué módulos deben incluirse). . establecer modelo datos que defina cómo estructurarán los datos orga- nización base datos del sistema. . definir las reglas empresariales que aplican dichos datos. . definir las interacciones esperadas con sistemas externos.. diseñar los formatos entrada los reportes salida generados por sistema.. diseñar nuevos procesos empresariales que conformen modelo proceso sub- yacente apoyado por sistema. . establecer parámetros que definan cómo implementará sistema plata- forma subyacente. una vez completados los escenarios configuración, sistema solución cots está listo para las pruebas. las pruebas son gran problema cuando los sistemas con-figuran vez programarse con lenguaje convencional. puesto que dichos sistemas construyen mediante una plataforma fiable, las fallas caídas evidentes del sistema son relativamente excepcionales. más bien, los problemas con frecuencia son sutiles relacionan con las interacciones entre los procesos operacionales configuración del sistema. esto sólo puede ser detectable por parte los usuarios finales , por tanto, tal vez pase inadvertido durante proceso pruebas del sistema. además, pueden usarse las pruebas automatizadas unidad, apoyadas por los frameworks pruebas como junit. improbable que sistema subyacente soporte algún tipo automatiza-ción pruebas, posible que haya especificación completa del sistema que pueda usarse para derivar pruebas del sistema. -.indd -.indd // :: // :: . ■ reutilización productos cots .. sistemas cots integrados los sistemas cots integrados son aplicaciones que incluyen dos más productos cots , ocasiones, sistemas aplicación heredados. usted podrá usar este enfoque cuando existan sistemas cots individuales que cumplan todas sus necesidades, cuando quiera integrar nuevo producto cots con los sistemas que utiliza. los productos cots pueden interactuar largo sus interfaces programación aplicación (api, por las siglas application programming interfaces) interfaces servicio están defini-das. alternativamente, pueden componerse conectar salida sistema entrada otro actualizar las bases datos usadas por las aplicaciones cots. para desarrollar sistemas usando productos cots, debe hacer algunas elecciones diseño: . ¿cuáles productos cots ofrecen funcionalidad más adecuada? por general, habrá varios productos cots disponibles, que pueden combinarse diferentes formas. aún tiene experiencia con producto cots, tal vez resulte difícil decidir cuál producto más adecuado. . ¿cómo intercambiarán los datos? por general, diferentes productos usan estructuras formatos datos únicos. usted tendrá que escribir adaptadores que conviertan una representación otra. dichos adaptadores son sistemas tiempo ejecución que operan junto con los productos cots. . ¿qué características producto usarán realmente? los productos cots tal vez incluyan más funcionalidad necesaria, funcionalidad puede dupli-carse través diferentes productos. usted tendrá que decidir cuáles características cuál producto son las más adecuadas para sus requerimientos. posible, tam-bién debe negar acceso funcionalidad utilizada, porque esto podría interferir con operación normal del sistema. falla del primer vuelo del cohete ariane (nuseibeh, ) fue consecuencia problema sistema navegación iner-cial del sistema ariane que reutilizó. sin embargo, funcionalidad que falló requería realidad ariane . considere siguiente escenario como una ilustración integración cots. una gran organización pretende desarrollar sistema compras que permita perso-nal realizar pedidos desde escritorio. introducir este sistema organización, compañía estima que puede ahorrar cinco millones dólares año. centralizar las compras, nuevo sistema adquisición puede garantizar que los pedidos siempre realicen desde proveedores que ofrecen los mejores precios, que reduzcan los costos papeleo asociados con los pedidos. como sucede con los sistemas manuales, sis-tema implica elegir los bienes disponibles proveedor, planear pedido, aprobarlo, enviar solicitud proveedor, recibir los bienes confirmar pago. compañía tiene sistema pedidos heredado que utiliza una oficina central compras. este software procesamiento pedidos está integrado con sistema existente facturación entrega. para crear nuevo sistema pedidos, sistema heredado integra con una plataforma comercio electrónico basada web sistema correo electrónico que maneje las comunicaciones con los usuarios. -.indd -.indd // :: // :: capítulo ■ reutilización software figura . muestra estructura final del sistema compras, construida usando cots. este sistema compras basa cliente-servidor , lado del cliente, usa navegación web software correo electrónico estándar. servidor, plataforma comercio electrónico debe integrarse con sistema pedidos existente través adaptador. sistema comercio electrónico tiene propio formato para los pedi-dos, confirmaciones entrega, etcétera, éstos convierten formato que usa sistema pedidos. sistema comercio electrónico utiliza sistema correo elec-trónico para enviar notificaciones los usuarios, pero sistema pedidos nunca diseñó para ello. por tanto, debe escribirse otro adaptador para convertir las notificaciones del sistema pedidos mensajes correo electrónico. posible ahorrar meses, veces años, esfuerzo implementación, tiempo desarrollo implementación sistema puede reducirse drásticamente usando enfoque cots integrado. sistema compras descrito anteriormente implementó desplegó una compañía muy grande nueve meses, vez los tres años que requerirían, acuerdo con las estimaciones, para desarrollar sistema java. integración cots puede simplificarse usar enfoque orientado servicios. esencia, enfoque orientado servicios significa permitir acceso funcionalidad del sistema aplicación mediante una interfaz servicio estándar, con servicio para cada unidad discreta funcionalidad. algunas aplicaciones pueden ofrecer una interfaz servicio, pero, ocasiones, ésta debe implementarse mediante integrador sistema. esencia, debe programarse una capa ( wrapper) que oculte aplicación ofrezca servicios claros exterior (figura .). este enfoque valioso par-ticular para los sistemas heredados que deben integrarse con sistemas aplicación más recientes. principio, integración los productos cots igual que integración cual-quier otro componente. deben entenderse las interfaces del sistema usarlas forma exclusiva para comunicarse con software; habrá que negociar requerimientos específi-cos contra desarrollo rápido reutilización, diseñar una arquitectura sistema que permita los sistemas cots operar conjunto. sin embargo, hecho que tales productos por regular sean sistemas grandes por derecho propio, que vendan con frecuencia como sistemas independientes, entraña cliente navegador web sistema correo electrónico servidor sistema comercio electrónicosistema pedido facturaciónadaptador adaptador sistema correo electrónicofigura . sistema procuración cots integrado -.indd -.indd // :: // :: . ■ reutilización productos cots problemas adicionales. boehm abts () examinan cuatro problemas importantes integración sistemas cots: . falta control sobre funcionalidad rendimiento aunque interfaz publi- cada producto indique que ofrece las facilidades requeridas, éstas tal vez implementen manera adecuada desempeñen mínimamente. pro-ducto podría tener operaciones ocultas que interfieran con uso una situación específica. corregir dichos problemas puede ser una prioridad para integrador productos cots, pero tal vez sea una preocupación real para proveedor del producto. posible que los usuarios simplemente tengan que encontrar una solu-ción los problemas quieren reutilizar producto cots. . problemas con interoperabilidad del sistema cots veces difícil hacer que los productos cots funcionen conjunto, porque cada producto establece sus propias suposiciones sobre cómo utilizará. garlan sus colaboradores (), reportar experiencia para tratar integrar cuatro productos cots, descubrieron que tres estos productos basaban eventos, pero cada uno usaba modelo diferente eventos. cada sistema supuso que tenía acceso exclusivo cola eventos. consecuencia, integración fue muy difícil. proyecto requirió cinco veces más esfuerzo que que pronosticó originalmente. fecha entrega extendió dos años lugar los seis meses previstos. análisis retrospec-tivo trabajo años después, garlan sus colaboradores () concluyeron que habían resuelto los problemas integración descubiertos. torchiano morisio () encontraron que falta cumplimiento con los estándares algu-nos productos cots significaba que integración era más difícil que esperado. . ningún control sobre evolución del sistema respuesta presiones del mer-cado, los proveedores productos cots toman sus propias decisiones acerca cambios sistema. particular para productos , generan menudo nuevas versiones, aunque tal vez sean compatibles con todas las versiones anteriores. las nuevas versiones pueden tener funcionalidad adicional deseada, las versio-nes anteriores podrían quedar fuera disposición recibir servicios apoyo. . soporte los proveedores cots nivel soporte disponible los provee- dores cots varía ampliamente. servicio soporte del proveedor específica-mente importante cuando surgen problemas, pues los desarrolladores tienen acceso código fuente documentación detallada del sistema. aunque quizá sistema aplicacióncapa servicio servicios serviciosfigura . capas aplicación -.indd -.indd // :: // :: capítulo ■ reutilización software los proveedores comprometan brindar servicios asesoría, tanto mercado cambiante como las circunstancias económicas podrían dificultar cumplimiento este compromiso. por ejemplo, proveedor sistemas cots tal vez decida dis-continuar producto debido una demanda limitada, quizás otra firma tome con-trol compañía proveedora quiera dar servicios apoyo los clientes que adquirieron ciertos productos. boehm abts suponen que, muchos casos, costo mantenimiento evolución del sistema mayor para los sistemas cots integrados. todas las dificultades anterio-res son problemas del ciclo vida que sólo afectan desarrollo inicial del sistema. cuanto mayor sea número personas implicadas mantenimiento del sistema que distancie los desarrolladores originales del sistema, más probable será que surjan dificultades reales con los productos cots integrados. puntos clave ■ actualidad, mayoría los nuevos sistemas software empresariales desarrollan con reutilización conocimiento código sistemas aplicados anteriormente. ■ existen muchas diferentes formas reutilizar software. esto varía desde reutilización clases métodos las librerías hasta reutilización sistemas completos aplicación. ■ las ventajas reutilización software son costos más bajos, desarrollo software más rápido menores riesgos. además, aumenta confiabilidad del sistema. los especialistas pueden trabajar manera más efectiva concentrar experiencia diseño componentes reutilización. ■ los frameworks (estructuras) aplicación son colecciones objetos concretos abstractos que diseñan para reutilizarse través especialización adición nuevos objetos. por general, incorporan buena práctica diseño mediante patrones diseño. ■ las líneas productos software son aplicaciones relacionadas que desarrollan partir una más aplicaciones base. sistema genérico adapta especializa para satisfacer requerimientos específicos funcionalidad, plataforma objetivo configuración operativa. ■ reutilización productos cots ocupa reutilización sistemas comerciales gran escala. éstos ofrecen amplia funcionalidad, posible que reutilización reduzca radicalmente los costos tiempo desarrollo. pueden diseñarse sistemas configurar solo producto cots genérico integrar dos más productos cots. ■ los sistemas planeación recursos empresariales son ejemplos gran escala reutilización cots. crea una instancia sistema erp configurar sistema genérico con información acerca los procesos las reglas empresariales del cliente. ■ los problemas potenciales con reutilización basada cots incluyen falta control sobre funcionalidad rendimiento, falta control sobre evolución del sistema, necesidad servicios soporte proveedores externos, dificultades para garantizar que los sistemas puedan operar manera conjunta. -.indd -.indd // :: // :: pmcapítulo ■ ejercicios lecturas sugeridas reuse-based software engineering. análisis completo los diferentes enfoques para reutilización software. los autores examinan los conflictos reutilización técnica administración los procesos reutilización. (. mili, . mili, . yacoub . addy, john wiley & sons, .) “overlooked aspects cots-based development”. interesante artículo que examina una encuesta desarrolladores que usan enfoque basado cots los problemas encontrados. (. torchiano . morisio, ieee software, (), marzo-abril .) http:/ /. doi. org/ . / . . . “construction configuration: new challenge for software engineering”. trata artículo que escribió autor, que analiza los problemas dificultades construir una nueva aplicación configurar sistemas existentes. (. sommerville, proc. australian software engineering conference, .) http:/ /. doi. org/ . / aswec. . . “architectural mismatch: why reuse still hard”. este artículo revisa ensayo anterior que estudia los problemas reutilización integración algunos sistemas cots. los autores concluyeron que, aunque realizado cierto progreso, aún hay problemas las suposiciones conflictivas que hicieron los diseñadores los sistemas individuales. (. garlan ., ieee software, (), julio-agosto .) http:/ /. doi. org/ /. / . . . ejercicios .. ¿cuáles son los principales factores técnicos técnicos que impiden reutilización software? ¿usted reutiliza mucho software? así, ¿por qué? .. sugiera por qué los ahorros costo reutilizar software existente son proporcionales tamaño los componentes que reutilizan. .. describa cuatro circunstancias donde desaconseje reutilización software. .. explique qué entiende por “inversión control” los frameworks aplicación. describa por qué este enfoque podría causar problemas integran dos sistemas separados que crearon originalmente usando mismo framework aplicación. .. con ejemplo del sistema estación meteorológica descrito los capítulos , sugiera una arquitectura línea productos para una familia aplicaciones que ocupen monitorización remota recolección datos. debe presentar arquitectura como modelo capas, que muestre los componentes que puedan incluirse cada nivel. .. mayoría del software escritorio, como software procesamiento textos, puede configurarse algunas formas diferentes. examine software que usa regularmente mencione las opciones configuración para dicho software. sugiera las dificultades que podrían enfrentar los usuarios para configurar software. usa microsoft office open office, son buenos ejemplos para usar este ejercicio. -.indd -.indd // :: // :: capítulo ■ reutilización software .. ¿por qué numerosas compañías grandes eligieron sistemas erp como base para sistema información organizacional? ¿qué problemas podrían surgir implementar gran escala sistema erp una organización? .. identifique seis posibles riesgos que puedan surgir cuando los sistemas construyen usando cots. ¿qué acciones recomendaría emprender una compañía para reducir esos riesgos? .. exponga por qué necesitan generalmente adaptadores cuando construyen sistemas mediante integración productos cots. describa tres problemas prácticos que pudieran surgir escribir software adaptador para vincular dos productos aplicación cots. .. reutilización software plantea algunos conflictos derechos autor propiedad intelectual. cliente paga contratista software para desarrollar sistema, ¿quién tiene derecho reutilizar código desarrollado? ¿ contratista software tiene derecho usar dicho código como base para componente genérico? ¿qué mecanismos pago podrían usar para compensar los proveedores componentes reutilizables? analice estos temas otros conflictos éticos asociados con reutilización software. referencias baker, . (). “lessons learned integrating cots into systems”. proc. iccbss ( int. conf cots-based software systems), orlando, fla:: springer, –. balk, . . kedia, . (). “ppt: cots integration case study”. proc. int. conf. software eng., limerick, irlanda: acm press, –.baumer, ., gryczan, ., knoll, ., lilienthal, ., riehle, . zullighoven, . (). “framework development for large systems”. comm. acm, (), –. boehm, . abts, . (). “cots integration: plug and pray?” ieee computer, (), –. brownsword, . morris, . (). “the good news about cots”. http:// cusamano, . (). “the software factory: historical interpretation”. ieee software, (), –. fayad, . . schmidt, . . (). “object-oriented application frameworks”. comm. acm, (), –.gamma, ., helm, ., johnson, . vlissides, . (). design patterns: elements reusable object-oriented software. reading, mass.: addison-wesley. garlan, ., allen, . ockerbloom, . (). “architectural mismatch: why reuse hard”. ieee software, (), –. garlan, ., allen, . ockerbloom, . (). “architectural mismatch: why reuse still hard”. ieee software, (), –. griss, . . wosser, . (). “making reuse work hewlett-packard”. ieee software, (), –. -.indd -.indd // :: // :: pmcapítulo ■ referencias holdener, . . (). ajax: the definitive guide. sebastopol, calif.: ’reilly and associates. jacobson, ., griss, . jonsson, . (). software reuse. reading, mass.: addison-wesley.matsumoto, . (). “some experience promoting reusable software: presentation higher abstract levels”. ieee. trans. software engineering, - (), –. mcilroy, . . (). “mass-produced software components”. proc. nato conf. software eng., garmisch, alemania: springer-verlag. nuseibeh, . (). “ariane : who dunnit?” ieee software, (), –.’leary, . . (). enterprise resource planning systems: systems, life cycle, electronic commerce and risk. cambridge, : cambridge university press. pfarr, . reis, . . (). “the integration cots/gots within nasa’ hst command and control system”. proc. iccbss ( int. conf cots-based software systems) , orlando, fla.: springer, –. schmidt, . . (). “applying design patterns and frameworks develop object-oriented communications software”. handbook programming languages, vol. . (.). nueva york: macmillan computer publishing. schmidt, . ., gokhale, . natarajan, . (). “leveraging application frameworks”. acm queue, ( (julio/agosto)), –.scott, . . (). “the foxmeyer drug’ bankruptcy: was failure erp”. proc. association for information systems americas conf. information systems , milwaukee, . torchiano, . morisio, . (). “overlooked aspects cots-based development”. ieee software, (), –. tracz, . (). “cots myths and other lessons learned component-based software development”. component-based software engineering. heineman, . . councill, . . (.). boston: addison-wesley, –. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo describir enfoque reutilización software basado composición componentes estandarizados reutilización. estudiar este capítulo: ■ sabrá que ingeniería software basada componentes ocupa del desarrollo componentes estandarizados con base modelo componentes, organización éstos sistemas aplicación; ■ entenderá qué componente modelo componentes; ■ conocerá las principales actividades proceso cbse para reutilización proceso cbse con reutilización; ■ comprenderá algunas las dificultades que surgen durante proceso composición componentes. contenido . componentes modelos componentes . procesos cbse . composición componentes ingeniería software basada componentes -.indd -.indd // :: // :: pmcomo explicó capítulo , numerosos nuevos sistemas empresariales desa- rrollan ahora configurar sistemas comerciales cots. sin embargo, cuando una com-pañía puede usar sistema cots porque cubre sus requerimientos, software que requiere debe desarrollarse especialmente. para software personalizado, inge-niería software basada componentes una forma efectiva orientada reutiliza-ción para desarrollar nuevos sistemas empresariales. ingeniería software basada componentes (cbse, por las siglas compo-nent-based software engineering) surgió finales década como -foque desarrollo sistemas software basado reutilización componentes software. creación fue motivada por frustración los diseñadores percatarse que desarrollo orientado objetos conducía una reutilización extensa, como había sugerido originalmente. las clases objetos individuales eran muy detalladas específi-cas con frecuencia tenían que acotarse con una aplicación momento compilar. para usarlas, debe tener conocimiento detallado las clases, por general esto significa tener código fuente del componente. por consiguiente, era casi imposible vender distri-buir objetos como componentes reutilización individuales. los componentes son abstracciones alto nivel comparación con los objetos definen mediante sus interfaces. por general, son más grandes que los objetos individua-les todos los detalles implementación ocultan otros componentes. cbse proceso definir, implementar integrar componer los componentes independientes imprecisos los sistemas. constituido importante enfoque desarrollo soft-ware porque los sistemas software son cada vez más amplios complejos. los clientes demandan software más confiable que entregue implemente más rápidamente. única forma enfrentar complejidad entregar mejor software con mayor rapidez reutilizar lugar implementar una vez más los componentes software. los fundamentos ingeniería software basada componentes son: . componentes independientes que especifican por completo mediante sus interfa- ces. debe existir una separación clara entre interfaz del componente imple- mentación. esto significa que implementación componente puede sustituirse por otra, sin cambiar otras partes del sistema. . estándares componentes que facilitan integración éstos. tales estándares incrustan modelo componentes. definen, nivel mínimo, cómo deben especificarse las interfaces componentes cómo comunican estos últimos. algunos modelos van más allá definen las interfaces que deben implementarse por todos los componentes integrantes. los componentes conforman los estándares, entonces ejecución independiente lenguaje programación. los compo-nentes escritos diferentes lenguajes pueden integrarse mismo sistema. . middleware que brinda soporte software para integración componentes. para hacer que componentes independientes distribuidos trabajen conjunto, nece-sario soporte middleware que maneje las comunicaciones componentes. middleware para soporte componentes maneja eficientemente los conflictos bajo nivel permite enfocarse problemas relacionados con aplicación. además, middleware para soporte componentes puede brindar apoyo para asignación recursos, gestión transacciones, seguridad concurrencia. . proceso desarrollo que engrana con ingeniería software basada componentes. usted necesita proceso desarrollo que permita evolución capítulo ■ ingeniería software basada componentes -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes requerimientos, dependiendo funcionalidad los componentes disponibles. sección . estudian los procesos desarrollo cbse. desarrollo basado componentes implica una buena práctica ingeniería soft-ware. tiene sentido diseñar sistema mediante componentes, incluso usted debe desa-rrollarlos vez reutilizarlos. base cbse existen firmes principios diseño que apoyan construcción software comprensible mantenible: . los componentes son independientes, manera que sus ejecuciones interfieren entre . ocultan los detalles implementación. implementación com-ponentes puede cambiar sin afectar resto del sistema. . los componentes comunican través interfaces bien definidas. dichas inter-faces mantienen, posible sustituir componente por otro, que ofrece fun-cionalidad adicional mayor. . las infraestructuras componentes ofrecen varios servicios estándar que pueden usarse sistemas aplicación. esto reduce cantidad código nuevo que debe desarrollarse. motivación inicial para cbse fue necesidad brindar apoyo tanto inge-niería software reutilización como distribuida. componente considera como elemento sistema software que podría acceder, mediante meca-nismo llamado procedimiento remoto, por parte otros componentes que ejecutan computadoras independientes. cada sistema que reutiliza componente debe incorporar propia copia dicho componente. esta idea componente extiende noción objetos distribuidos, como define modelos sistemas distribuidos, tales como especificación corba (pope, ). para apoyar esta visión componente, han desarrollado muchos diferentes protocolos estándares, como enterprise java beans (ejb) sun, com .net microsoft, ccm corba (lau wang, ). práctica, estos estándares múltiples obstaculizan aceptación cbse. era imposible que componentes desarrollados mediante diferentes enfoques funcionaran jun-tos. los componentes diseñados para distintas plataformas, tales como .net , pueden interoperar. más aún, los estándares protocolos propuestos consideraban complejos difíciles entender. esto también presentaba como una barrera para adopción. respuesta tales problemas, desarrolló noción componente como servi-cio, propusieron estándares para apoyar ingeniería software orientada servicios. problemas con cbse cbse ahora enfoque mantenimiento ingeniería software: una buena forma construir sistemas. sin embargo, cuando usa como enfoque para reutilización, los problemas relacionan con fiabilidad certificación los componentes, los compromisos requerimientos predicción las propiedades los componentes, especial integrarse con otros. http:// -.indd -.indd // :: // :: . ■ componentes modelos componentes diferencia más significativa entre componente como servicio noción original componente que los servicios son entidades independientes externas programa que los usa. cuando construye sistema orientado servicio, hace referencia servicio externo vez incluir sistema una copia dicho servicio. por tanto, ingeniería software orientada servicio, que estudia capí-tulo , tipo ingeniería software basada componentes. utiliza una noción más simple componente que propuesto originalmente cbse. los estándares impulsaron esto desde comienzo. situaciones que práctica reutilización basada cots, cbse orientada servicio convierte enfoque dominante para desarrollo sistemas empresariales. . componentes modelos componentes comunidad cbse existe acuerdo general que componente una unidad software independiente que puede organizarse con otros componentes para crear sistema software. sin embargo, más allá eso, hay quienes proponen definiciones variables componente software. council heineman () definen com-ponente como: elemento software que conforma modelo componentes están-dar puede desplegarse componerse independientemente sin modificación, acuerdo con estándar composición. esencia, esta definición basa estándares, manera que una unidad soft-ware conformada dichos estándares componente. obstante, szyperski () menciona estándares definición componente; vez ello, enfoca características clave los componentes: componente software una unidad composición con interfaces especi-ficadas contractualmente sólo con dependencias contexto explícitas. com-ponente software puede implementarse manera independiente está sujeto composición por terceras partes. ambas definiciones basan noción componente como elemento que incluye sistema, más que servicio que hace referencia sistema. con todo, también son compatibles con idea servicio como componente. szyperski establece además que componente tiene estado observable externo. esto significa que las copias los componentes son indistinguibles. obstante, algu-nos modelos componentes, tales como modelo enterprise java beans, permiten componentes estado, así que corresponden definición szyperski. aunque los componentes sin estado son más simples usar, existen algunos sistemas que los componentes estado son más convenientes reducen complejidad del sistema. que tienen común las definiciones anteriores que concuerdan que los componentes son independientes, los consideran unidad fundamental composi-ción sistema. visión del autor que puede obtenerse una mejor definición -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes componente combinar estas propuestas. figura . muestra que autor consi- dera como las características esenciales componente, como usa cbse. una forma útil pensar componente como proveedor uno más servicios. cuando sistema necesita servicio, llama componente que brinde que usó para desarrollarlo. por ejemplo, componente sistema biblioteca puede ofrecer servicio búsqueda que permita los usuarios examinar diferentes catálogos biblioteca. componente que convierte formato gráfico otro (por ejemplo, tiff jpeg) ofrece servicio conversión datos, etcétera. visualizar componente como proveedor servicio pone relieve dos carac-terísticas críticas componente reutilización: . componente una entidad ejecutable independiente definida mediante sus interfa- ces. para usarlo necesita conocimiento alguno código fuente. puede hacerse referencia como servicio externo incluirse directamente programa. . los servicios ofrecidos por componente ponen disposición mediante una inter-faz, todas las interacciones por dicha interfaz. interfaz del componente expresa términos operaciones parametrizadas nunca expone estado interno.característica del componente descripción estandarizado estandarización componentes significa que componente utilizado durante proceso cbse debe ajustarse modelo componentes estándar. este modelo puede definir interfaces componentes, metadatos componentes, documentación, composición implementación. independiente componente debe ser independiente; debe ser factible componerlo implementarlo sin usar otros componentes específicos. situaciones que componente necesita brindar servicios externos, esto debería plantearse claramente una especificación interfaz “requiere”. componible para que componente sea componible, todas las interacciones externas deben tener lugar mediante interfaces definidas públicamente. además, debe permitir acceso externo información acerca mismo, así como sus métodos atributos. implementable para que sea implementable, componente debe estar autocontenido. debe ser capaz ejecutarse como entidad independiente una plataforma componente que permita una implementación del modelo componentes. por general, esto significa que componente binario tiene que compilarse antes implementación. componente implementa como servicio, tiene que implementarse por parte usuario componente. vez ello, implementa por parte del proveedor del servicio. documentado los componentes deben implementarse por completo, para que los usuarios potenciales puedan decidir los componentes cumplen sus necesidades. debe especificarse sintaxis , manera ideal, semántica todas las interfaces componente. figura . características los componentes -.indd -.indd // :: // :: . ■ componentes modelos componentes los componentes tienen dos interfaces relacionadas, como muestra figura .. dichas interfaces reflejan los servicios que proveen los componentes los servicios que componente requiere para ejecutarse correctamente:  interfaz “proporciona” define los servicios que ofrece componente. esencia, esta interfaz componente api. define los métodos que puede solicitar usuario del componente. diagrama componentes uml, interfaz “proporciona” para componente indica mediante círculo final una línea desde icono del componente.  interfaz “requiere” especifica qué servicios deben ofrecer otros componentes sistema para que componente opere correctamente. están disponibles, entonces componente funcionará. esto compromete independencia carácter implementable componente, porque interfaz “requiere” define cómo deben proporcionarse dichos servicios. uml, símbolo para una inter-faz “requiere” semicírculo final una línea desde icono del componente. observe que los iconos las interfaces “proporciona” “requiere” pueden encajar como una articulación rótula. para ilustrar estas interfaces, figura . muestra modelo componente que diseñó para recopilar intercalar información desde arreglo sensores. ejecuta manera autónoma para recopilar datos durante cierto tiempo , petición, proporciona datos intercalados componente que solicite. interfaz “proporciona” incluye méto-dos para agregar, remover, iniciar, detener probar los sensores. método report regresa los datos del sensor que recopilaron, método listall brinda información los sen-sores unidos. aunque esto muestra aquí, dichos métodos tienen parámetros asociados que especifican los identificadores del sensor, así como sus ubicaciones, etcétera. interfaz “requiere” usa para conectar componente los sensores. supone que los sensores tienen una interfaz datos, los que accede través sensordata, componente objetos los componentes implementan con frecuencia lenguajes orientados objetos , algunos casos, acceso interfaz “proporciona” componente realiza través solicitudes método. sin embargo, los componentes las clases objetos son mismo. diferencia las clases objetos, los componentes implementan manera independiente, son tipos definidos, sino independientes del lenguaje basan modelo componentes estándar. http:// interfaz requiere define los servicios que necesitan ydeben proporcionarotros componentesinterfaz proporciona define los serviciosque ofreceel componentea otros componentefigura . interfaces componentes -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes una interfaz gestión, que accede través sensormanagement. esta interfaz diseñó para conectarse diferentes tipos sensor, así que incluye operaciones sensor específicas, tales como test, providereading, etcétera. vez ello, los coman-dos que usa tipo específico sensor incrustan una cadena, que parámetro para las operaciones interfaz “requiere”. los componentes adaptador analizan gramaticalmente ( parse) esta cadena traducen los comandos incrustados interfaz control específica cada tipo sensor. más adelante este capítulo estudia uso los adaptadores, muestra cómo los componentes recolectores datos vin-culan con sensor (figura .). una diferencia crucial entre componente como servicio externo componente como elemento programa que los servicios son entidades independientes por com-pleto. tienen una interfaz “requiere”. diferentes programas pueden usar dichos servi-cios sin necesidad implementar soporte adicional requerido por servicio. .. modelos componentes modelo componentes una definición estándares para implementación, docu-mentación despliegue componentes. estos estándares establecen con finalidad que los desarrolladores componentes aseguren que éstos pueden interoperar. también funcionan para proveedores infraestructuras ejecución componentes que ofrecen middleware para apoyar ejecución componentes. han propuesto muchos modelos componentes, pero ahora los modelos más importantes son modelo webservices, modelo enterprise java beans (ejb) sun, modelo .net microsoft (lau wang, ). weinreich sametinger () analizan los elementos básicos modelo ideal componentes. figura . resumen esos elementos modelo. este diagrama muestra que los elementos modelo componentes definen las interfaces com-ponentes, información que necesita usar componente programa cómo debe implementarse componente: . interfaces los componentes definen especificar sus interfaces. modelo componentes especifica cómo deben definirse las interfaces los elementos, tales como los nombres operación, los parámetros las excepciones que deben incluirse definición interfaz. modelo también debe especificar len-guaje usado para definir las interfaces componentes. para servicios web, éste sensordatasensormanagementaddsensor removesensorstartsensorstopsensortestsensor listallreportinitializeinterfaz proporciona interfaz requiere recolector datos figura . modelo componente recopilador datos -.indd -.indd // :: // :: . ■ componentes modelos componentes wsdl, que estudia capítulo ; ejb específico java, manera que usa java como lenguaje definición interfaz; .net, las interfaces definen con common intermediate language (cil, lenguaje intermedio común). algunos modelos componentes requieren interfaces específicas que deben defi-nirse por componente. usan para componer componente con infraestruc-tura modelo componentes, que ofrece servicios estandarizados, tales como seguridad gestión transacción. . uso para que los componentes distribuyan acceda ellos manera remota, deben tener nombre único asociado. éste debe ser totalmente único, por ejemplo, ejb genera nombre jerárquico con raíz basada nombre dominio internet. los servicios tienen uri único (uniform resource identifier, esto , identificador recursos uniforme). los metadatos componente son datos acerca del componente , tales como información acerca sus interfaces atributos. los metadatos son importantes por-que permiten los usuarios del componente determinar qué servicios proporcio-nan requieren. las implementaciones modelos componentes por general incluyen formas específicas (tales como uso una interfaz reflexión java) para acceder los metadatos este componente. los componentes son entidades genéricas , cuando implementan, deben confi- gurarse para ajustarse sistema aplicación. por ejemplo, podría configurar componente recolector datos (figura .) definir número máximo sen-sores arreglo. por tanto, modelo componentes puede especificar cómo pueden personalizarse los componentes binarios para entorno implementación particular. . implementación modelo componentes incluye una especificación cómo deben empacarse los componentes para implementación como entidades ejecuta-bles independientes. puesto que los componentes son entidades independientes, deben empacarse con todo software soporte que proporcione infraestructura componente, que esté definido una interfaz “requiere”. información implementación incluye información sobre contenido paquete orga-nización binaria. inevitablemente, conforme surjan nuevos requerimientos, los componentes deberán cambiarse sustituirse. por consiguiente, modelo componentes puede incluir modelo componentesinformación usodefinición interfazinterfaces específicascomposiciónconvención nomenclatura acceso metadatospersonalización empacadodocumentación soporte evolución interfacesimplementación uso figura . elementos básicos modelo componentes -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes reglas que rigen cuándo cómo permite sustitución componentes. finalmente, modelo componentes puede definir documentación componentes que deba producirse. esto usa para encontrar componente decidir adecuado. para componentes que implementen como unidades programa como servi-cios externos, modelo componentes establece los servicios ofrecer por parte del middleware que apoye los componentes ejecución. weinreich sametinger () usan analogía sistema operativo para explicar los modelos componentes. sistema operativo brinda conjunto servicios genéricos que pueden usar las aplicaciones. implementación modelo componentes ofrece servicios compartidos comparables para los componentes. figura . muestra algunos los servicios que puede ofrecer una implementación modelo componentes. los servicios brindados por una implementación modelo componentes divi-den dos categorías: . servicios plataforma, los cuales permiten los componentes comunicarse inter- operar entorno distribuido. trata servicios fundamentales que deben estar disponibles todos los sistemas basados componentes. . servicios apoyo, que son servicios comunes que probablemente requieran muchos componentes diversos. por ejemplo, numerosos componentes requieren autentica-ción para garantizar que usuario los servicios del componente está autorizado. tiene sentido ofrecer conjunto estándar servicios middleware para uso todos los componentes. esto reduce los costos del desarrollo componentes permite evitar las incompatibilidades potenciales los componentes. middleware implementa los servicios componentes ofrece interfaces dichos servicios. para usar los servicios ofrecidos por infraestructura modelo compo-nentes, puede considerar los componentes como implementados “contenedor”. contenedor una implementación los servicios apoyo más una definición las interfaces que debe proporcionar componente para integrarlo con contenedor. incluir componente contenedor significa que componente puede ingresar los servicios apoyo, contenedor puede acceder las interfaces componente. cuando usan, otros componentes acceden directamente las interfaces del componente; vez servicios plataformaservicios apoyo concurrenciagestión componentegestión transacción persistencia seguridadgestión recursos direccionamientodefinición interfazcomunicaciones componentesgestión excepciónfigura . servicios middleware definidos modelo componentes -.indd -.indd // :: // :: . ■ procesos cbse ello, accede éstas través una interfaz contenedor que recurre código para acceder interfaz del componente embebido. los contenedores son grandes complejos, cuando componente implementa contenedor consigue acceso todos los servicios middleware. sin embargo, los componentes simples tal vez necesiten todas las instalaciones que ofrece middleware apoyo. por tanto, poco diferente enfoque que toma los servicios web para suministro servicio común. caso los servicios web han definido estándares para servicios comunes como gestión transaccio-nes seguridad, dichos estándares implementan como librerías programa. usted implementa componente servicio, sólo utiliza los servicios comunes que necesita. . procesos cbse los procesos cbse son procesos software que brindan soporte ingeniería software basada componentes. toman cuenta las posibilidades reutilización las diferentes actividades proceso implicadas desarrollo uso componentes reutilizables. figura . (kotonya, ) ilustra panorama los procesos cbse. nivel más alto, existen dos tipos procesos cbse: . desarrollo para reutilización este proceso ocupa del desarrollo componen- tes servicios que reutilizarán otras aplicaciones. por regular, implica generalización los componentes existentes. . desarrollo con reutilización éste proceso para desarrollar nuevas aplicacio-nes usando los componentes servicios existentes. dichos procesos tienen diferentes objetivos , por consiguiente, incluyen distintas actividades. proceso desarrollo para reutilización, objetivo producir uno más componentes reutilizables. usted conoce los componentes con los que trabajará tiene acceso código fuente para generalizarlos. desarrollo con reutilización, sabe cuáles componentes están disponibles, así que necesita descubrir dichos componen-tes diseñar sistema para utilizarlos manera más efectiva. puede tener acceso código fuente del componente. figura . observa que los procesos básicos cbse con para reutiliza-ción tienen procesos soporte que ocupan adquisición, gestión certificación componentes: . adquisición componentes proceso adquirir componentes para reutiliza- ción desarrollo componente reutilizable. puede implicar acceso compo-nentes servicios desarrollados localmente, encontrar dichos componentes una fuente externa. . gestión componentes ocupa gestión los componentes reutili-zación una compañía, asegurándose que estén adecuadamente catalogados, almacenados dispuestos para reutilizarse. -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes . certificación componentes proceso comprobar componente asegu- rarse que cumple especificación. los componentes que conserva una organización pueden almacenarse reposito-rio componentes que incluya tanto los componentes como información uso. .. cbse para reutilización cbse para reutilización proceso desarrollar componentes reutilizables ponerlos disposición para reutilizarlos través sistema gestión componen-tes. visión los primeros defensores cbse (szyperski, ) fue que desa-rrollaría floreciente mercado componentes. habría proveedores especializados componentes vendedores que organizarían venta componentes diferentes desa-rrolladores. los desarrolladores software comprarían componentes para incluir sistema pagarían por servicios conforme los utilizaran. sin embargo, esta visión materializado. existen relativamente pocos proveedores componentes, compra componentes poco común. momento escribir este texto, mercado servicios también está poco desarrollado, aunque hay predicciones que expandirá significati-vamente durante los próximos años. consecuencia, más probable que cbse para reutilización tenga lugar dentro una organización que realizó compromiso con ingeniería software dirigida por reutilización. esas circunstancias, desea aprovechar los activos software que desarrollaron diferentes partes compañía. sin embargo, tales componen-tes desarrollados internamente por general son reutilizables sin cambios. con fre-cuencia incluyen características interfaces específicas aplicación que improbable que requieran otros programas donde reutilice componente.procesos cbse especificador, diseñador,integrador,mantenedor bibliotecario,vendedor,corredor bibliotecario certificadorlocal oexternofuente externaanalista dominio,diseñador,implementador,mantenedor,analista mercadocbse para reutilizacióncbse con reutilización adquisición componentes certificación componentes repositorio componentegestión componentes figura . procesos cbse -.indd -.indd // :: // :: . ■ procesos cbse para elaborar componentes reutilización, deben adaptarse extenderse componen- tes específicos aplicación para crear versiones más genéricas , por tanto, más reuti-lizables. evidentemente, esta adaptación tiene costo asociado. así que primero habrá que decidir probable que componente reutilice , segundo, los ahorros costo futura reutilización justifican los costos hacer reutilizable componente. para responder primera estas preguntas, debe decidir componente imple-menta una más abstracciones dominio estables. las abstracciones dominio estables son elementos fundamentales del dominio aplicación que cambian lenta-mente. por ejemplo, sistema bancario, las abstracciones dominio pueden incluir cuentas, poseedores cuentas enunciados. sistema administración hospi-tales, las abstracciones dominio pueden incluir pacientes, tratamientos enfermeros. ocasiones, tales abstracciones dominio les llama “objetos empresariales”. componente una implementación una abstracción dominio grupo objetos empresariales relacionados comúnmente usados, tal vez puedan reutilizarse. para responder pregunta acerca efectividad términos costo, habrá que valorar los costos los cambios que requieren para hacer reutilizable componente. éstos son los costos documentación validación del componente, los asociados con hecho hacerlo más genérico. los cambios que pueden hacer compo-nente para volverlo más reutilizable incluyen:  eliminar métodos específicos aplicación;  cambiar los nombres para hacerlos más generales; agregar métodos para brindar cobertura funcional más completa; hacer manejadores excepción consistentes para todos los métodos; adicionar una interfaz “configuración” para permitir adaptación los compo- nentes diferentes situaciones uso;  integrar los componentes requeridos para aumentar independencia. problema del manejo excepción particularmente difícil. los componentes deben manejar las excepciones por mismos, porque cada aplicación tendrá sus propios requerimientos para manejo excepción. vez ello, componente debe definir qué excepciones pueden surgir éstas deben publicarse como parte interfaz. por ejemplo, componente simple que implemente una estructura datos pila debe detectar publicar excepciones desbordamiento (overflow) pilas cuando quiere extraer pila vacía (underflow). sin embargo, práctica, existen dos problemas con esto: . publicar todas las excepciones conduce interfaces infladas que son difíciles entender. esto podría alejar usuarios potenciales del componente. . ejecución del componente puede depender del manejo excepciones locales, cambiar esto tal vez tenga serias implicaciones para funcionalidad del compo-nente. mili sus colaboradores () discuten formas estimar los costos hacer reuti-lizable componente los rendimientos dicha inversión. los beneficios reu-tilización antes volver desarrollar componente son simplemente ganancias -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes términos productividad. también existen ganancias calidad, porque com- ponente reutilización debe ser más confiable, hay ganancias tiempo salida mercado. trata aumento los rendimientos que acrecientan implementar software más rápidamente. mili sus colaboradores muestran varias fórmulas para estimar dichas ganancias, como modelo cocomo que estudia capítulo (boehm ., ). sin embargo, los parámetros tales fórmulas son difíciles evaluar con precisión, las fórmulas deben adaptarse circunstancias locales, que las hace más difíciles usar. posible que pocos administradores proyecto software usen estos modelos para estimar rendimiento sobre inversión partir reutiliza-ción componentes. desde luego, componente susceptible reutilización, , depende dominio aplicación funcionalidad. conforme agrega generalidad com-ponente, aumenta probabilidad reutilización. obstante, esto por regular significa que componente tiene más operaciones más complejidades, las cuales hacen difícil entender emplear. sin embargo, esto intercambio inevitable entre reutilización uso componente. para hacer reutilizable componente, usted deberá proporcionar conjunto interfaces genéricas con operaciones que incluyan todas las formas que componente podría usar. hacer componente utilizable significa ofrecer una interfaz simple mínima, que sea fácil entender. reutilización agrega complejidad , por eso, dificulta hecho entender componente. por consiguiente, más difícil decidir cuándo cómo reutilizar dicho componente. consecuencia, cuando diseñe componente reutilización, debe encontrar compromiso entre generalidad comprensibilidad. una fuente potencial componentes está constituida por los sistemas heredados existentes. como estudió capítulo , trata sistemas que cumplen una impor-tante función empresarial, pero que están escritos con tecnologías software obsoletas. por ello, tal vez sea difícil usarlos con sistemas nuevos. sin embargo, estos sistemas antiguos convierten componentes, funcionalidad puede reutilizarse nuevas aplicaciones. desde luego, estos sistemas heredados tienen normalmente interfaces “requiere” “proporciona” bien definidas. para hacer reutilizables dichos componentes, debe crear una envoltura (wrapper) que defina las interfaces componente. envoltura oculta complejidad del código subyacente ofrece una interfaz para que los componentes externos accedan los servicios que brindan. aunque esta envoltura una pieza software bastante compleja, con frecuencia costo desarrollarlo mucho menor que costo volver implementar sistema heredado. capítulo examina con más detalle este enfoque, explica cómo puede accederse las características del sistema heredado través servicios. una vez que desarrollado probado componente servicio reutilización, entonces debe gestionarse para una reutilización futuro. gestión implica decidir cómo clasificar componente forma que pueda descubrirse, hacer componente dis-ponible sea repositorio como servicio, mantener información acerca uso, hacer seguimiento las diferentes versiones del componente. componente fuente abierta, puede hacer disponible repositorio público como sourceforge. pretende utilizarlo una compañía, entonces puede usar sistema depósito interno. una compañía con programa reutilización puede realizar alguna forma cer-tificación componente antes que éste encuentre disponible para reutilización. -.indd -.indd // :: // :: . ■ procesos cbse certificación significa que alguien, aparte del desarrollador, verifica calidad del componente. prueba componente certifica que alcanza estándar calidad aceptable, antes ponerlo disposición para reutilización. sin embargo, éste puede ser proceso costoso muchas compañías simplemente dejan las pruebas compro-bación calidad manos los desarrolladores del componente. .. cbse con reutilización reutilización exitosa componentes requiere proceso desarrollo ajustado cbse. cbse con proceso reutilización debe incluir actividades que encuentren integren componentes reutilizables. estructura tal proceso trató capítulo , figura . muestra las principales actividades dentro ese proceso. algunas las actividades dentro este proceso, como descubrimiento inicial los requeri-mientos usuario, realizan misma forma que otros procesos software. sin embargo, las diferencias esenciales entre cbse con reutilización procesos software para desarrollo software original son: . los requerimientos del usuario inicialmente desarrollan bosquejos detalle, alienta las partes interesadas ser tan flexibles como sea posible para definir sus requerimientos. los requerimientos que son demasiado específicos limitan número componentes que pueden satisfacer dichos requerimientos. sin embargo, diferencia del desarrollo incremental, necesita conjunto completo requerimientos para poder identificar tantos componentes como sea posible para reutilización. . los requerimientos afinan modifican oportunamente durante proceso, depen-diendo los componentes disponibles. los requerimientos del usuario pueden cumplirse partir los componentes disponibles, deberán analizar los requeri-mientos relacionados que puedan cumplirse. los usuarios tal vez tengan voluntad cambiar mentalidad esto significa entrega sistema menor costo más rápidamente. . después diseñar arquitectura del sistema, hay una actividad adicional bús-queda componentes clarificación diseño. algunos componentes aparente-mente utilizables quizá resulten inadecuados funcionen como debido con otros componentes elegidos. aunque ilustra figura ., esto implica que pueden ser necesarios posteriores cambios requerimientos.identificar componentes candidatosbosquejar los requerimientos del sistemamodificar requerimientos acuerdo con componentes descubiertos diseño arquitectónicocomponer componentes para crear sistema identificar componentes candidatos figura . cbse con reutilización -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes . desarrollo proceso composición que integran los componentes des- cubiertos. esto implica integrar los componentes con infraestructura del modelo componentes , con frecuencia, desarrollar adaptadores que reconcilien las inter-faces componentes incompatibles. desde luego, también puede requerirse funcio-nalidad adicional por encima que ofrecen los componentes reutilización. etapa diseño arquitectónico particularmente importante. jacobson sus colabo-radores () descubrieron que definir una arquitectura robusta crucial para tener éxito reutilización. durante actividad diseño arquitectónico, puede elegir modelo componentes una plataforma implementación. sin embargo, muchas compañías tienen una plataforma desarrollo estándar (por ejemplo, .net), así que modelo componentes está predeterminado. como estudió capítulo , esta etapa establece también organización alto nivel del sistema toman decisiones acerca distribución control del sistema. una actividad que única para proceso cbse identificar los componentes servicios candidatos para reutilización. esto implica algunas actividades específicas, como muestra figura .. inicialmente, enfoque debe estar búsqueda selección. necesario cerciorarse que hay componentes disponibles para cumplir los requerimientos. desde luego, debe hacer una comprobación inicial que com-ponente adecuado, aunque posible que requieran pruebas detalladas. última etapa, después diseñada arquitectura del sistema, debe dedicarse más tiempo validación componentes. hay que estar seguros que los componentes identifi-cados son realmente adecuados para aplicación; , entonces habrá que repetir los procesos búsqueda selección. primer paso identificación los componentes buscar aquellos que estén disponibles localmente con proveedores confiables. como dijo sección ante-rior, existen relativamente pocos vendedores componentes, por eso usted tiene más probabilidades buscar los componentes desarrollados propia compañía. las compañías desarrollo software pueden construir propia base datos com-ponentes reutilización sin los riesgos inherentes usar componentes proveedo-res externos. alternativamente, posible buscar librerías código disponibles web, como sourceforge google code, para saber está disponible código fuente para componente que necesita. usted busca servicios, ese caso están disponibles varios motores búsqueda web especializados que pueden descubrir servicios web públicos. una vez que proceso búsqueda permite identificar los posibles componentes, deben seleccionar componentes candidatos para valoración. algunos casos, ésta será una labor sencilla. los componentes lista implementarán directamente los requerimientos del usuario habrá componentes competidores que coincidan con estos requerimientos. sin embargo, otros casos, proceso selección mucho más complejo. existirá mapa claro requerimientos los componentes habrá que integrar muchos componentes para cumplir requerimiento específico conjunto validación componentesselección componentesbúsqueda componentesfigura . proceso identificación componentes -.indd -.indd // :: // :: . ■ procesos cbse requerimientos. consecuencia, debe decidir cuáles composiciones ofrecen mejor cobertura los requerimientos. una vez seleccionados los componentes para posible inclusión sistema, deben validar para comprobar que comportan como espera. extensión vali-dación requerida depende fuente los componentes. usted usa componente que haya desarrollado una fuente conocida confiable, puede decidir que necesaria prueba componentes. usted simplemente analiza los componentes cuando inte-gran con otros. por otra parte, utiliza componente otras fuentes desconocidas, siempre deberá comprobar probar dicho componente antes incluirlo sistema. validación componentes implica desarrollar conjunto casos prueba para componente (, posiblemente, extender los casos prueba suministrados con dicho componente) desarrollar conjunto pruebas para ejecutar pruebas componente. principal problema con validación componentes que especificación compo-nentes tal vez esté suficientemente detallada para permitirle desarrollar conjunto com-pleto pruebas componentes. por general, los componentes especifican manera informal, única documentación formal especificación interfaz. ésta quizá incluya suficiente información para desarrollar conjunto completo pruebas que convencerían que interfaz anunciada del componente que requiere. además probar que componente para reutilización logra que requiere, posible que tenga que verificar también que componente incluya algún código una funcionalidad maliciosos innecesarios. los desarrolladores profesionales pocas veces usan componentes fuentes confiables, especial esas fuentes proporcio-nan código fuente. por tanto, problema código malicioso surge habitualmente. sin embargo, los componentes con frecuencia pueden contener funcionalidad innecesaria debe comprobar que esta funcionalidad interfiera con uso del componente. problema con funcionalidad innecesaria que puede activarse por componente . esto podría volver lento componente, hacer que produzca resultados inesperados , algunos casos, provocar fallas graves sistema. figura . resume una situación que funcionalidad innecesaria sistema reutilización causó una falla catas-trófica del software. falla del lanzador ariane mientras desarrollaba cohete espacial ariane , los diseñadores decidieron reutilizar software referencia inercial que desempeñó con éxito ariane . software referencia inercial mantiene estabilidad del cohete. decidieron reutilizarlo sin cambios (como haría con los componentes), aun cuando incluía funcionalidad adicional que requería ariane . primer lanzamiento del ariane falló software navegación inercial pudo controlarse cohete. los controladores tierra instruyeron lanzador autodestruirse; así, cohete carga fueron destruidos. causa del problema fue una excepción considerada cuando una conversión número punto fijo entero dio por resultado desbordamiento numérico. esto hizo que sistema tiempo ejecución desactivara sistema referencia inercial, manera que pudo mantenerse estabilidad del lanzador. falla nunca ocurrió ariane porque tenía motores menos poderosos, valor que convirtió podía ser suficientemente grande para que conversión desbordara. falla ocurrió código que requería ariane . las pruebas validación para software reutilización basaron los requerimientos del ariane . puesto que había requerimientos para función que falló, desarrollaron pruebas. consecuencia, problema con software nunca descubrió durante las pruebas simulación del lanzamiento. figura . ejemplo falla validación con software reutilizado -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes problema lanzador ariane surgió porque las suposiciones acerca del soft- ware para ariane eran inválidas para ariane . éste problema general con los componentes reutilización. originalmente implementan para entorno aplica-ción , como natural, incrustan suposiciones acerca ese entorno. tales conjeturas documentan pocas veces, así que, cuando reutiliza componente, imposible efectuar pruebas para comprobar las suposiciones todavía son válidas. usted reuti-liza componente entorno distinto, posible que descubra las suposiciones ambientales incrustadas sino hasta que use componente sistema operativo. . composición componentes composición componentes proceso integrar componentes uno con otro con “código pegamento” especialmente escrito para crear sistema otro componente. existen muchas formas diferentes las que pueden componer componentes, como muestra figura .. izquierda derecha, dichos diagramas ilustran com-posición secuencial, composición jerárquica composición aditiva. siguiente análisis suponga que compone dos componentes ( ) para crear uno nuevo: . composición secuencial situación () figura .. usted crea nuevo componente partir dos componentes existentes llamar secuencia los componentes existentes. puede considerar composición como una composi-ción las “interfaces proporciona”. esto , llaman los servicios ofrecidos por componente luego los resultados emitidos por usan llamada los servicios que ofrece componente . los componentes llaman mutuamente composición secuencial. requiere algún código pegamento adicional para lla-mar los servicios del componente orden correcto asegurar que los resultados entregados por componente sean compatibles con las entradas esperadas por componente . interfaz “proporciona” composición depende fun-cionalidad combinada , pero generalmente será una composición sus “interfaces proporciona”. este tipo composición puede usarse con componentes que son elementos programa con componentes que son servicios. . composición jerárquica situación () figura .. este tipo compo-sición ocurre cuando componente llama directamente los servicios que ofrece otro componente. componente llamado proporciona los servicios que requiere componente que llama. por tanto, interfaz “proporciona” del componente lla-mado debe ser compatible con interfaz “requiere” del componente que llama. componente llama componente directamente , sus interfaces coinciden, tal vez haya necesidad código adicional. sin embargo, existe una discordan-cia entre interfaz “requiere” interfaz “proporciona” , entonces puede requerirse algún código conversión. como los servicios tienen una interfaz “requiere”, este modo composición usa cuando los componentes imple-mentan como servicios web. . composición aditiva corresponde situación () figura .. esto ocurre cuando dos más componentes juntan ( suman) para crear nuevo -.indd -.indd // :: // :: . ■ composición componentes componente, que combina funcionalidad. interfaz “proporciona” inter- faz “requiere” del nuevo componente una combinación las correspondientes interfaces los componentes . los componentes llaman por separado mediante interfaz externa del componente compuesto. son dependientes llaman mutuamente. este tipo composición puede usarse con componen-tes que son unidades programa con componentes que son servicios. usted puede usar todas las formas composición componentes cuando crea sistema. todos los casos, tal vez tenga que escribir “código pegamento” que vincule los componentes. por ejemplo, para composición secuencial, salida del componente convierte por general entrada componente . necesitará enunciados intermedios que llamen componente , recolecten resultado luego llamen com-ponente con dicho resultado como parámetro. cuando componente llama otro, tal vez necesite introducir componente intermedio que asegure que interfaz “propor-ciona” interfaz “requiere” sean compatibles. cuando escriba nuevos componentes especialmente para composición, deberá diseñar las interfaces dichos componentes manera que sean compatibles con otros compo-nentes sistema. por consiguiente, puede componer fácilmente dichos componentes una sola unidad. obstante, cuando los componentes desarrollan manera inde-pendiente para reutilización, con frecuencia usted enfrentará con incompatibilida-des interfaz. esto significa que las interfaces los componentes que desea componer son iguales. posible que ocurran tres tipos incompatibilidades: . incompatibilidad parámetro las operaciones cada lado interfaz tienen mismo nombre, pero sus tipos parámetro número parámetros son dife-rentes. . incompatibilidad operación los nombres las operaciones las interfaces “proporciona” “requiere” son diferentes. . operación incompleta interfaz “proporciona” componente subcon-junto interfaz “requiere” otro componente viceversa. todos los casos, problema incompatibilidad resuelve escribir adap-tador que reconcilie las interfaces los dos componentes reutilizar. componente adaptador convierte una interfaz otra. forma precisa del adaptador depende del tipo ) ) ) figura . tipos composición componente -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes composición. ocasiones, como siguiente ejemplo, adaptador toma resul- tado componente convierte una forma que puede usarse como entrada otro. otros casos, adaptador puede llamarse por componente como proxy para componente . esta situación ocurre quiere llamar , pero los detalles interfaz “requiere” coinciden con los detalles interfaz “proporciona” . adaptador reconcilia dichas diferencias convertir sus parámetros entrada desde los parámetros entrada requeridos por . entonces llama para entregar los servicios requeridos por . para ilustrar los adaptadores, considere los dos componentes que muestran figura ., cuyas interfaces son incompatibles. esto puede ser parte sistema usado por los servicios emergencia. cuando operador emergencia recibe una llamada, número telefónico ingresa componente addressfinder para localizar dirección. entonces, usar componente mapper, operador imprime mapa para mandarlo vehículo que acude emergencia. hecho, los componentes tendrían interfaces más complejas que las mostradas aquí, pero versión simplificada ilustra concepto adaptador. primer componente, addressfinder , encuentra dirección que coincide con número telefónico. también puede regresar dueño propiedad asociada con -mero telefónico tipo propiedad. componente mapper toma código postal ( estados unidos, código zip estándar con los cuatro dígitos adicionales que iden-tifican ubicación propiedad) muestra imprime mapa las calles del área que rodean dicho código una escala específica. tales componentes pueden componer, principio, porque ubicación pro-piedad incluye código postal zip. sin embargo, debe escribir componente adaptador llamado postcodestripper que toma los datos ubicación del addressfinder consigue código postal. entonces este código postal usa como entrada mapper, mapa las calles muestra una escala :,. siguiente código, que ejemplo composición secuencial, ilustra secuencia llamadas que requieren para implementar esto: address = addressfinder.location (phonenumber) ; postcode = postcodestripper.getpostcode (address) ;mapper.displaymap(postcode, ) ;phonedatabase (cadena command)cadena location (cadena ) cadena owner (cadena ) cadena propertytype (cadena ) mapdb (cadena command)displaymap (cadena postcode, scale) printmap (cadena postcode, scale)addressfinder mapperfigura . componentes con interfaces incompatibles -.indd -.indd // :: // :: . ■ composición componentes otro caso que puede usarse componente adaptador composición jerárquica, donde componente quiere usar otro, pero existe una incompatibilidad entre interfaz “proporciona” interfaz “requiere” los componentes composición. figura . ilustra uso adaptador que vincula recolector datos componente sensor. esto podría usarse implementación sistema esta-ción meteorológica campo abierto, como estudió capítulo . los componentes sensor recolector datos componen usando adaptador que reconcilia interfaz “requiere” del componente recolección datos con interfaz “proporciona” del componente sensor. componente recolector datos diseñó con una interfaz “requiere” genérica que brinda soporte recolección datos del sensor gestión del sensor. para cada una dichas operaciones, pará-metro una cadena texto que representa los comandos sensor específicos. por ejemplo, para emitir comando recolección (collect), diría sensordata (“collect”). como muestra figura ., sensor tiene operaciones separadas como start, stop getdata. adaptador analiza gramaticalmente cadena entrada, identifica comando (por ejemplo, collect) luego llama sensor.getdata para recolectar valor del sensor. luego, regresa resultado (como una cadena caracteres) componente recolector datos. este estilo interfaz significa que recolector datos puede interactuar con diferentes tipos sensor. adaptador separado, que convierte los comandos del sensor recolector datos interfaz sensor real, implementa para cada tipo sensor. análisis anterior composición supone que usted puede decir, partir docu-mentación del componente, las interfaces son compatibles . desde luego, defi-nición interfaz incluye nombre operación los tipos parámetro, manera que puede hacer cierta valoración compatibilidad partir esto. sin embargo, usted depende documentación del componente para decidir las interfaces son semánticamente compatibles. para ilustrar este problema, considere composición que ilustra figura .. dichos componentes usan para implementar sistema que descargue imá-genes una cámara digital las almacene una fototeca. usuario del sistema puede dar información adicional para describir catalogar fotografía. para evitar confu-sión, aquí muestran todos los métodos interfaz. vez ello, simplemente addsensor removesensorstartsensorstopsensortestsensor listallreportinitializesensormanagement sensordataadaptador sensorstart getdatastoprecolector datos figura . adaptador que vincula recolector datos sensor -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes indican los métodos que necesitan para ejemplificar problema documentación componentes. los métodos interfaz fototeca son: public void additem (identifier pid ; photograph ; catalogentry photodesc) ;public photograph retrieve (identifier pid) ;public catalogentry catentry (identifier pid); suponga que documentación para método additem fototeca : este método agrega una fotografía fototeca asocia identificador fotografía, cataloga descriptor con fotografía. esta descripción explica qué hace componente; sin embargo, considere las siguientes preguntas:  ¿qué sucede identificador fotografía está asociado con una fotografía fototeca?  ¿ descriptor fotografía está asociado con entrada catálogo, igual que fotografía? esto , borra fotografía, ¿también borra información del catá- logo? hay suficiente información descripción informal additem para responder dichas preguntas. desde luego, posible agregar más información descripción lenguaje natural del método, pero, general, mejor forma resolver ambigüedades usar lenguaje formal para describir interfaz. especificación que muestra figura . parte descripción interfaz fototeca que agrega infor- mación descripción informal. especificación figura . usa precondiciones post-condiciones que defi-nen una notación con base lenguaje restricción objeto (ocl), que parte del uml (warmer kleppe, ). ocl está diseñado para describir restricciones modelos objetos uml; permite expresar predicados que deben ser verdaderos siem-pre, que deben ser verdaderos antes ejecutar método, qué deben ser verdaderos fototecaadaptador gestor imagengetimage interfaz usuariogetcatalogentryadditem retrieve catentry figura . composición fototeca -.indd -.indd // :: // :: . ■ composición componentes después ejecutar método. trata invariantes, precondiciones post-condiciones. para acceder valor una variable antes una operación, agregue @pre después nombre. por tanto, usar edad como ejemplo: age = age@pre + este enunciado significa que valor edad después una operación uno más del que era antes dicha operación. los enfoques basados ocl usan cada vez más para agregar información semán-tica modelos uml, las descripciones ocl pueden usarse para derivar generadores código ingeniería dirigida por modelo. enfoque general derivó del enfoque diseño por contrato, meyer (meyer, ), que las interfaces obligaciones los objetos comunicación especifican formalmente refuerzan por sistema tiempo ejecución. meyer sugiere que usar diseño por contrato esencial usted debe desarrollar componentes confiables (meyer, ). figura . incluye una especificación para los métodos additem delete fototeca . método especificar indica mediante contexto palabra clave, las precondiciones post-condiciones mediante las palabras clave pre post. las precondi-ciones para additem afirman que: . debe haber una fotografía fototeca con mismo identificador que foto- grafía ingresar. . debe existir fototeca: suponga que crear una fototeca agrega solo ítem ella, manera que tamaño una fototeca siempre mayor que cero.— palabra clave del contexto menciona componente que aplican las condiciones context additem — las precondiciones especifican qué debe ser verdadero antes ejecutar additem pre: photolibrary.libsize() photolibrary.retrieve(pid) = null — las post-condiciones especifican qué verdadero después ejecución post: libsize () = libsize()@pre + photolibrary.retrieve(pid) = photolibrary.catentry(pid) = photodesc context deletepre: photolibrary.retrieve(pid) <null ;post: photolibrary.retrieve(pid) = null photolibrary.catentry(pid) = photolibrary.catentry(pid)@pre photolibrary.libsize() = libsize()@pre— figura . descripción ocl interfaz fototeca -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes . las post-condiciones para additem afirman que: tamaño fototeca aumentó por ( manera que únicamente realizó una sola entrada). usted recupera usando mismo identificador, entonces recupera fotografía que agregó. busca catálogo usando dicho identificador, recupera entrada catálogo que realizó. especificación delete brinda más información. precondición afirma que, para borrar ítem, éste debe estar fototeca , después del borrado, fotografía podrá recuperarse tamaño fototeca reducirá . sin embargo, delete borra entrada catálogo: todavía posible recuperarla después borrar fotografía. razón esto que tal vez usted quiera mantener información catálogo acer por qué borró una fotografía, nueva ubicación, etcétera. cuando usted crea sistema componer componentes, puede descubrir que hay conflictos potenciales entre requerimientos funcionales funcionales, entre nece-sidad entregar sistema tan rápidamente como sea posible necesidad crear sistema que puede evolucionar conforme cambian los requerimientos. las decisiones donde puede tomar cuenta negociaciones son: . ¿qué composición más efectiva para entregar los requerimientos funcionales del sistema? . ¿qué composición facilitará adaptación del componente cuando cambien los requerimientos? . ¿cuáles serán las propiedades emergentes del sistema compuesto? trata pro-piedades como rendimiento confiabilidad. sólo podrá valorarlos una vez que implemente sistema completo. por desgracia, existen muchas situaciones donde las soluciones los problemas composición podrían estar conflicto. por ejemplo, considere una situación como que ilustra figura ., donde puede crear sistema mediante dos composi-ciones alternativas. sistema una colección datos sistema reporte donde recopilan datos diferentes fuentes, almacenan una base datos luego generan diferentes informes que resumen dichos datos. aquí, existe conflicto potencial entre adaptabilidad rendimiento. composi-ción ) más adaptable, pero composición ) tal vez más rápida más fiable. las ventajas composición ) son que los reportes gestión datos están sepa-rados, manera que hay más flexibilidad para cambio futuro. sistema gestión datos podría sustituirse , requieren reportes que actual componen- reporte puede generar, también posible sustituir dicho componente sin tener que cambiar componente gestión datos. composición ) usa componente base datos con instalaciones reporte incorporadas (por ejemplo, microsoft access). ventaja clave composi-ción ) que existen menos componentes, manera que será una implementación más -.indd -.indd // :: // :: pmcapítulo ■ puntos clave rápida porque hay cargas comunicación del componente. más aún, las reglas integridad datos que aplican base datos también aplicarán los reportes. dichos reportes podrán combinar datos formas incorrectas. composición ), hay tales restricciones, manera que podrían ocurrir errores los reportes. general, buen principio composición seguir principio separación asuntos. esto , debe tratar diseñar sistema tal forma que cada componente tenga papel claramente definido que, manera ideal, dichos roles traslapen. sin embargo, quizá sea menos costoso comprar componente multifuncional vez dos tres componentes separados. más aún, podría haber sanciones términos confiabilidad rendimiento cuando usan múltiples componentes. puntos clave ■ ingeniería software basada componentes enfoque fundado reutilización para definir, implementar componer componentes independientes imprecisos los sistemas. ■ componente una unidad software cuya funcionalidad dependencias están completamente definidas por conjunto interfaces públicas. los componentes pueden componerse con algunos otros, sin conocimiento implementación pueden aplicarse como una unidad ejecutable. ■ los componentes pueden implementarse como unidades programa que incluyen sistema como servicios externos los que hace referencia dentro del sistema. ■ modelo componentes define conjunto estándares para componentes, incluidos estándares interfaz, estándares uso estándares implementación. implementación del modelo componentes brinda conjunto servicios comunes que pueden usarse por parte todos los componentes. ■ durante proceso cbse, usted tiene que entremezclar los procesos ingeniería requerimientos del diseño del sistema. debe negociar requerimientos deseables contra los servicios que están disponibles partir componentes reutilización existentes. ■ composición componentes proceso “organizar” componentes para crear sistema. los tipos composición incluyen composición secuencial, composición jerárquica composición aditiva.)recolección datos )gestión datosgenerador reporte recolección datosbase datosreporte reportefigura . componentes recolección datos generación reporte -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes ■ cuando componen componentes reutilización que escribieron para aplicación que usted desea, tal vez sea necesario escribir adaptadores “código pegamento” para reconciliar las interfaces los diferentes componentes. ■ cuando elija composiciones, deberá considerar funcionalidad requerida del sistema, los requerimientos funcionales facilidad con que puede sustituirse componente cuando cambie sistema. lecturas sugeridas component-based software engineering: putting the pieces together. este libro una colección ensayos varios autores acerca diferentes aspectos cbse. como todas las colecciones, una mezcla temas, pero tiene mejor cobertura los conflictos generales ingeniería software con componentes que libro szyperski. (. . heineman . . councill, addison-wesley, .) component software: beyond object-oriented programming, . esta edición actualizada del primer libro acerca cbse trata conflictos técnicos técnicos cbse. contiene más detalles sobre tecnologías específicas que libro heineman councill, incluye profundo análisis los conflictos mercado. (. szyperski, addison-wesley, .) “specification, implementation and deployment components”. una buena introducción los fundamentos cbse. mismo conflicto del cacm incluye artículos acerca componentes desarrollo basado componentes. (. crnkovic, . hnich, . jonsson . kiziltan, comm. acm, (), octubre .) http:/ /. doi. org/ . / . . “software component models”. éste análisis amplio los modelos componentes comerciales investigación que clasifican dichos modelos explican las diferencias entre ellos. (-. lau . wang, ieee transactions software engineering, (), octubre .) http:/ /. doi. org/ . / tse. . . ejercicios .. ¿por qué importante que todas las interacciones los componentes definan mediante interfaces “requiere” “proporciona”? .. principio independencia componentes significa que debe ser posible sustituir componente con otro que implemente una forma completamente diferente. usando ejemplo, explique cómo tal sustitución componentes podría tener consecuencias indeseables conducir una falla del sistema. -.indd -.indd // :: // :: pmcapítulo ■ referencias .. ¿cuáles son las diferencias fundamentales entre componentes como elementos programa componentes como servicios? .. ¿por qué importante que los componentes basen modelo componentes estándar? .. con ejemplo componente que implemente tipo datos abstracto, como una pila una lista, demuestre por qué por general necesario extender adaptar componentes para reutilización. .. explique por qué difícil validar componente reutilización sin código fuente del componente. ¿ qué formas especificación formal componente simplificaría los problemas validación? .. diseñe interfaz “proporciona” interfaz “requiere” componente reutilización que pueda usarse para representar paciente mhc-pms. .. con ejemplos, ilustre los diferentes tipos adaptador necesarios para soportar composición secuencial, composición jerárquica composición aditiva. .. diseñe las interfaces los componentes que puedan usarse sistema para una sala control emergencias. debe diseñar interfaces para componente registro llamadas que registre las llamadas realizadas, componente descubrimiento vehículo que, partir código postal (zip code) tipo incidente, encuentre vehículo adecuado más cercano para enviarlo lugar del incidente. .. sugerido que debe establecerse una autoridad certificación independiente. los proveedores enviarían sus componentes esta autoridad, cual validaría que componente confiable. ¿cuáles serían las ventajas desventajas tal autoridad certificación? referencias boehm, . ., abts, ., brown, . ., chulani, ., clark, . ., horowitz, ., madachy, ., reifer, . steece, . (). software cost estimation with cocomo . upper saddle river, .: prentice hall. councill, . . heineman, . . (). “definition software component and its elements”. component-based software engineering. heineman, . . councill, . . (.). boston: addison-wesley, –. jacobson, ., griss, . jonsson, . (). software reuse. reading, mass.: addison-wesley.kotonya, . (). “the cbse process: issues and future visions”. proc. cbsenet workshop, budapest, hungría.lau, .-. wang, . (). “software component models”. ieee trans. software eng., (), –. meyer, . (). “design contract”. ieee computer, (), –. -.indd -.indd // :: // :: capítulo ■ ingeniería software basada componentes meyer, . (). “the grand challenge trusted components”. icse : int. conf. software eng., portland, oregon: ieee press. mili, ., mili, ., yacoub, . addy, . (). reuse-based software engineering. nueva york: john wiley & sons. pope, . (). the corba reference guide: understanding the common object request broker architecture. harlow, : addison-wesley. szyperski, . (). component software: beyond object-oriented programming, . harlow, : addison-wesley.warmer, . kleppe, . (). the object constraint language: getting your models ready for mda. boston: addison-wesley. weinreich, . sametinger, . (). “component models and component services: concepts and principles”. component-based software engineering. heineman, . . councill, . . (.). boston: addison-wesley, –. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo ingeniería sistemas distribuidos las arquitecturas sistemas distribuidos. estudiar este capítulo: ■ conocerá los conflictos clave que debe considerar diseñar implementar los sistemas software distribuidos; ■ comprenderá modelo cómputo cliente-servidor arquitectura capas los sistemas cliente-servidor; ■ introducirá los patrones uso común para las arquitecturas sistemas distribuidos reconocerá los tipos sistema más aplicables para cada arquitectura; ■ entenderá noción software como servicio proporcionará acceso basado web sistemas aplicación implementación remota. contenido . conflictos los sistemas distribuidos . computación cliente-servidor . patrones arquitectónicos para sistemas distribuidos . software como servicio ingeniería software distribuido -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido prácticamente todos los grandes sistemas basados computadora son ahora sistemas distribuidos. sistema distribuido aquel que implica numerosas computadoras, contraste con los sistemas centralizados que todos los componentes sistema ejecutan una sola computadora. tanenbaum van steen () definen sistema distribuido como: . . .una colección computadoras independientes que aparecen usuario como solo sistema coherente. evidente que ingeniería los sistemas distribuidos tiene mucho común con ingeniería cualquier otro software. sin embargo, existen conflictos específicos que deben considerarse diseñar este tipo sistema. éstos surgen porque los componen-tes del sistema pueden estar ejecución computadoras con administración inde-pendiente éstas comunican través una red. coulouris sus colaboradores () identifican las siguientes ventajas usar enfoque distribuido para desarrollo sistemas: . compartición recursos sistema distribuido permite compartir los recursos hardware software, tales como discos, impresoras, archivos compiladores, que asocian con computadoras una red. . apertura los sistemas distribuidos, por general, son sistemas abiertos, cual significa que están diseñados torno protocolos estándar que permiten combi-nación equipo software diferentes proveedores. . concurrencia sistema distribuido, grandes procesos pueden ejecutarse mismo tiempo computadoras independientes red. dichos procesos pueden (pero necesario) comunicarse uno con otro durante operación normal. . escalabilidad menos principio, los sistemas distribuidos son escalables cuan- las capacidades del sistema pueden aumentarse agregar nuevos recursos para enfrentar nuevas demandas del sistema. práctica, red que vincula las compu-tadoras individuales sistema puede limitar escalabilidad del sistema. . tolerancia fallas disponibilidad muchas computadoras potencial reproducir información significa que los sistemas distribuidos pueden tolerar algu-nas fallas hardware software (véase capítulo ). mayoría los sis-temas distribuidos, puede darse servicio degradado ocurrir fallas; pérdida completa servicio sólo sucede cuando hay una falla red. para sistemas organizacionales gran escala, estas ventajas representan que los sis-temas distribuidos han sustituido, especial, los sistemas heredados mainframe desa-rrollados década . sin embargo, existen numerosos sistemas aplicación para computadora personal (por ejemplo, sistemas edición fotografía), que son distribuidos que ejecutan solo sistema cómputo. mayoría los sistemas embebidos también son sistemas procesador individual. los sistemas distribuidos son inherentemente más complejos que los sistemas cen-tralizados. esto los hace más difíciles diseñar, implementar poner prueba. más complicado entender las propiedades emergentes los sistemas distribuidos debido complejidad las interacciones entre los componentes infraestructura del sistema. -.indd -.indd // :: // :: . ■ conflictos los sistemas distribuidos por ejemplo, vez que rendimiento del sistema dependa velocidad ejecu- ción procesador, depende del ancho banda red, carga red velo-cidad todas las computadoras que forman parte del sistema. trasladar los recursos una parte del sistema otra puede afectar significativamente rendimiento del sistema. más aún, como saben todos los usuarios www, los sistemas distribuidos son impredecibles respuesta. tiempo respuesta depende carga total del sis-tema, arquitectura carga red. puesto que todo esto puede cambiar corto plazo, tiempo para responder petición usuario puede variar drásticamente una petición otra. desarrollo más importante que afectado los sistemas software distribuidos los años anteriores enfoque orientado servicios. gran parte este capítulose enfoca los conflictos generales los sistemas distribuidos, pero sección . setrata noción aplicaciones implementadas como servicios. esto complementa material del capítulo , que enfoca los servicios como componentes una arqui-tectura orientada servicios, los conflictos más generales ingeniería soft-ware orientada servicios. . conflictos los sistemas distribuidos como explicó introducción este capítulo, los sistemas distribuidos son más complejos que los sistemas que ejecutan solo procesador. esta complejidad surge porque prácticamente imposible tener modelo descendente control dichos sis-temas. los nodos sistema que entregan funcionalidad con frecuencia son sistemas independientes sin una sola autoridad encargada ellos. red que conecta dichos nodos sistema gestión independiente. sistema complejo por derecho propio puede controlarse por los propietarios los sistemas que usan red. por tanto, existe una imprevisibilidad inherente operación los sistemas distribuidos que debe con-siderar diseñador del sistema. algunos los conflictos diseño más importantes que deben considerarse ingeniería sistemas distribuidos son: . transparencia ¿ qué medida sistema distribuido debe aparecer usuario como solo sistema? ¿cuándo útil para los usuarios entender que sistema distribuido? . apertura ¿ sistema debe diseñarse usando protocolos estándar que soporten interoperabilidad deben usarse protocolos más especializados que restrinjan libertad del diseñador? . escalabilidad ¿cómo puede construirse sistema para que sea escalable? esto , ¿cómo podría diseñarse sistema global para que capacidad pueda aumentar respuesta demandas crecientes hechas sobre sistema? . seguridad ¿cómo pueden definirse implementarse políticas seguridad útiles que apliquen través conjunto sistemas administrados manera inde-pendiente? -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido . calidad servicio ¿cómo debe especificarse calidad del servicio que entrega los usuarios del sistema cómo debe implementarse sistema para entre- gar una calidad servicio aceptable para todos los usuarios? . gestión fallas ¿cómo pueden detectarse las fallas del sistema, contenerse ( modo que tengan efectos mínimos sobre otros componentes del sistema) repararse? mundo ideal, hecho que sistema sea distribuido sería transparente para los usuarios. esto significa que los usuarios verían sistema como solo sistema cuyo comportamiento resulta afectado por forma que distribuye sistema. práctica, esto imposible lograr. improbable control central sistema distribuido , como resultado, las computadoras individuales sistema pueden com-portarse manera diferente distintos momentos. más aún, las demoras red son ineludibles, puesto que hecho que las señales viajen través red siempre tiene una duración finita tiempo. duración dichas demoras depende ubicación los recursos sistema, calidad conexión red del usuario carga red. enfoque diseño para lograr transparencia depende creación abstraccio-nes los recursos sistema distribuido, modo que realización física dichos recursos puede cambiar sin tener que realizar variaciones sistema aplicación. middleware (estudiado sección ..) usa para trazar mapa los recursos lógicos referidos por programa sobre los recursos físicos reales, gestionar las inte-racciones entre dichos recursos. práctica, imposible hacer sistema por completo transparente los usua-rios, por general, están tanto que enfrentan con sistema distribuido. por consiguiente, usted puede decidir que mejor exponer distribución para los usuarios. así, ellos podrán prepararse para algunas las consecuencias distribución, como las demoras red, fallas del nodo remoto, etcétera. los sistemas distribuidos abiertos son sistemas que construyen acuerdo con estándares generalmente aceptados. esto significa que los componentes cualquier proveedor pueden integrarse sistema interoperar con los otros componentes del sistema. nivel red, los sistemas abiertos conforman acuerdo con los protoco-los internet, pero nivel componente apertura aún universal. apertura implica que los componentes del sistema pueden desarrollarse manera independiente cualquier lenguaje programación , ajustan las normas, funcionarán con otros componentes.corba (common object request broker architecture), arquitectura común intermediario peticiones objetos corba una especificación bien conocida para sistema middleware que object management group desarrolló década . estaba previsto como estándar abierto que permitiría desarrollo middleware para soporte comunicaciones ejecución componentes distribuidos, además proporcionar conjunto servicios estándar que pudieran usar dichos componentes. produjeron varias implementaciones corba, pero sistema nunca logró masa crítica. los usuarios prefirieron sistemas propietarios trasladaron arquitecturas orientadas servicios. http:// -.indd -.indd // :: // :: . ■ conflictos los sistemas distribuidos estándar corba (pope, ) desarrollado década tenía intención conseguir esto, aunque nunca logró una cantidad suficiente que adoptaran. vez ello, muchas compañías eligieron desarrollar sistemas utilizando estándares propieta-rios para componentes compañías como sun microsoft. ello proporcionó mejores implementaciones soporte software, largo plazo mejor soporte para protocolos industriales. los estándares servicio web (que estudian capítulo ) para arquitecturas orientadas servicios desarrollaron para ser estándares abiertos. sin embargo, existe significativa resistencia dichos estándares debido percibida ineficiencia. algunos desarrolladores sistemas basados servicio optaron por los llamados protocolos restful, que tienen una sobrecarga inferior los protocolos servicio web. escalabilidad sistema refleja disponibilidad para entregar una alta calidad servicio conforme aumentan las demandas sistema. neuman () identifica tres dimensiones escalabilidad: . tamaño debe ser posible agregar más recursos sistema para enfrentar cre- ciente número usuarios. . distribución debe ser posible dispersar geográficamente los componentes sistema sin reducir rendimiento. . manejabilidad debe ser posible administrar sistema conforme aumenta tamaño, incluso las partes del sistema ubican organizaciones independientes. términos tamaño, hay una distinción entre expandir (scaling ) ampliar (scaling out). primero significa sustituir recursos sistema con recursos más poderosos. por ejemplo, posible expandir aumentar memoria servidor . cambio, ampliar significa agregar recursos adicionales sistema (por ejem-plo, servidor web adicional para trabajar junto servidor existente). ampliar menudo más efectivo costo que expandir, aun cuando, por general, representa que sistema debe diseñarse para que sea posible procesamiento concurrente. parte este libro analizaron los conflictos generales seguridad los conflictos ingeniería seguridad. sin embargo, cuando distribuye sistema, número formas que éste puede ser atacado aumenta considerablemente, compa-ración con los sistemas centralizados. una parte del sistema atacada con éxito, enton-ces atacante podrá usar esto como una “puerta trasera” otras partes del sistema. los tipos ataques contra los que debe defenderse sistema distribuido son los siguientes: . intercepción, que atacante intercepta las comunicaciones entre las partes del sistema, para que haya poca confidencialidad. . interrupción, que sucede cuando los servicios del sistema son atacados pueden entregarse como esperaba. los ataques negación servicio implican bom-bardeo nodo con peticiones servicio ilegítimas, modo que puede hacer frente peticiones legítimas. . modificación, que presenta cuando atacante cambia los datos servicios del sistema. . fabricación, que sucede cuando atacante genera información que debe existir luego usa para conseguir ciertos privilegios. por ejemplo, atacante puede gene-rar una falsa entrada contraseña usarla para obtener acceso sistema. -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido principal dificultad los sistemas distribuidos establecimiento una política seguridad que pueda aplicarse manera fiable todos los componentes del sistema. como refirió capítulo , conjunto políticas seguridad establece nivel seguridad que debe alcanzar sistema. los mecanismos seguridad, tales como -criptación autenticación, usan para reforzar política seguridad. las dificultades sistema distribuido surgen debido que diferentes organizaciones pueden poseer partes del sistema. tales organizaciones podrían tener políticas mecanismos seguri-dad incompatibles entre . tal vez sea necesario hacer compromisos seguridad para permitir sistema trabajar conjunto. calidad del servicio (qos, por las siglas quality service) ofrecida por sis-tema distribuido refleja capacidad del sistema para entregar sus servicios manera confiable con tiempo respuesta rendimiento total que sean aceptables para sus usuarios. manera ideal, los requerimientos qos deben especificarse por adelantado sistema debe diseñarse configurarse para entregar dicha qos. por desgracia, esto siempre posible, por dos razones: . tal vez sea efectivo términos costos diseñar configurar sistema para que entregue una qos bajo carga pico. esto podría implicar poner disposición recursos que usan durante gran parte del tiempo. uno los principales argu-mentos para “computación nube” que enfrenta parcialmente este problema. usar una nube, fácil agregar recursos conforme aumente demanda. . los parámetros qos pueden ser contradictorios entre . por ejemplo, creciente fia-bilidad puede significar reducción rendimiento total, puesto que introducen procedimientos comprobación para garantizar que son válidas todas las entradas del sistema. qos particularmente importante cuando sistema enfrenta datos críticos tiempo, tales como difusión sonido video. ante estas circunstancias, qos cae por abajo valor umbral, entonces sonido video puede quedar tan degradado que imposible entender. los sistemas que enfrentan con sonido video deben incluir negociación componentes gestión qos. éstos deberían evaluar los requerimientos qos frente los recursos disponibles , son insuficientes, negociar más recursos una reducción qos establecida como meta. sistema distribuido, inevitable que ocurran fallas, así que sistema debe diseñarse para ser resistente dichas fallas. las fallas son tan omnipresentes, que una definición poco seria sistema distribuido sugerida por leslie lamport, destacado investigador los sistemas distribuidos, siguiente: usted sabe que tiene sistema distribuido cuando caída sistema que nunca escuchó impide que usted realice cualquier trabajo. gestión fallas operación implica aplicación técnicas tolerancia fallas que estudiaron capítulo . consecuencia, los sistemas distribuidos deben incluir mecanismos para descubrir falló componente del sistema, deben seguir entregando tantos servicios como sea posible pesar dicha falla , medida posible, recuperarse automáticamente falla. -.indd -.indd // :: // :: . ■ conflictos los sistemas distribuidos .. modelos interacción existen dos tipos fundamentales interacción que pueden tener lugar entre las compu- tadoras sistema cómputo distribuido: interacción procedimental interacción basada mensajes. primera implica una computadora que solicita servicio cono-cido ofrecido por alguna otra computadora (por general) espera entrega dicho servicio. interacción basada mensajes implica que computadora “emisora” defina mensaje información acerca que requiere, cual envía entonces otra computadora. por general, los mensajes transmiten más información una sola interacción que solicitud procedimiento otra máquina. para ilustrar diferencia entre interacción procedimental basada mensajes, considere una situación donde usted solicita los alimentos que desea restaurante. cuando tiene una conversación con camarero, participa una serie interacciones sincrónicas procedimentales que definen pedido. usted hace una solicitud; cama-rero reconoce dicha solicitud; usted hace otra solicitud, que reconocida; así sucesiva-mente. esto comparable los componentes que interactúan sistema software donde componente solicita métodos otros componentes. camarero toma nota pedido junto con las órdenes los demás comensales. entonces comunica pedido, que incluye detalles todo que solicitó, personal cocina para que prepare comida. esencia, camarero transmite mensaje personal cocina que define comida preparar. ésta una interacción basada mensajes. esto ilustra figura ., cual muestra proceso solicitud sincrónico como una serie solicitudes, figura ., donde refiere hipotético mensaje xml que define una orden expedida por mesa tres personas. clara diferen-cia entre estas formas intercambio información. camarero toma orden como una serie interacciones, que cada interacción define parte orden. sin embargo, sopa tomate, por favor.camarero comensal ¿qué apetece? ¿ para seguir? filete res. ¿qué término prefiere? medio cocido, por favor. ¿con ensalada papas francesa? ensalada, por favor. etc.figura . interacción procedimental entre comensal camarero -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido camarero tiene una sola interacción con cocina, donde mensaje define orden completa. comunicación procedimental sistema distribuido implementa con frecuen-cia usando solicitudes procedimiento remoto (rpc, por las siglas remote procedure calls). rpc, componente solicita otro componente como fuera procedimiento método local. middleware sistema intercepta esta solicitud transmite componente remoto. éste realiza computación requerida , por medio del middleware, regresa resultado componente solicitante. java, las solicitudes método remoto (rmi, por las siglas remote method invocations) son comparables con rpc, aunque idénticas. framework rmi maneja petición métodos remotos programa java. rpc requiere “stub” (talonario) para que procedimiento solicitado sea accesible computadora que inicia solicitud. solicita stub éste traduce los paráme-tros del procedimiento una representación estándar para transmisión procedimiento remoto. través del middleware, envía entonces petición ejecución procedi-miento remoto. éste usa funciones librería para convertir los parámetros formato requerido, realiza los cálculos luego comunica los resultados requeridos vía “stub” que representa que solicita. interacción basada mensajes implica normalmente componente que crea mensaje, cual detalla los servicios requeridos por otro componente. mediante sistema middleware, éste envía componente recepción. receptor analiza men-saje, efectúa los cálculos diseña mensaje para componente emisor con los resulta-dos requeridos. entonces esto transmite middleware para que, vez, transmita componente emisor. problema con enfoque rpc interacción que tanto solicitante como solicitado tienen que estar disponibles momento comunicación, deben saber cómo refieren uno otro. esencia, una rpc tiene los mismos requerimientos que una solicitud procedimiento método local. contraste, enfoque basado mensajes, puede tolerarse indisponibilidad, pues mensaje simplemente perma-nece una cola hasta que receptor esté disponible. más aún, necesario que emisario receptor estén tanto uno del otro. ellos simplemente comunican con middleware, que responsable garantizar que los mensajes transmitan sistema adecuado.<starter <dish name = “soup” type = “tomato” / <dish name = “soup” type = “fish” / <dish name = “pigeon salad” /</starter<main course <dish name = “steak” type = “sirloin” cooking = “medium” / <dish name = “steak” type = “fillet” cooking = “rare” / <dish name = “sea bass”</main<accompaniment <dish name = “french fries” portions = “” / <dish name = “salad” portions = “” /</accompaniment figura . interacción basada mensajes entre camarero personal cocina -.indd -.indd // :: // :: . ■ conflictos los sistemas distribuidos .. middleware los componentes sistema distribuido pueden implementarse distintos lengua- jes programación ejecutarse tipos procesador diferentes por completo. modelos datos, representación información protocolos para comunicación pueden ser todos distintos. por tanto, sistema distribuido requiere software que pueda gestionar esas diversas partes, garantizar que puedan comunicarse intercambiar datos. término “middleware” usa para referirse este software: encuentra cen-tro, entre los componentes distribuidos del sistema. esto ilustra figura ., cual muestra que middleware una capa entre sistema operativo los programas aplicación. por general, middleware implementa como conjunto librerías, que instalan cada computadora distribuida, además sistema tiempo operación para gestionar las comunicaciones. bernstein () describe tipos middleware que están disponibles para soportar computación distribuida. middleware software propósito general que com-pra comúnmente tiendas lugar que desarrolladores aplicación los escriban especialmente. los ejemplos middleware incluyen software para gestionar comuni-caciones con bases datos, gestores transacciones, convertidores datos contro-ladores comunicación. sistema distribuido, middleware por general brinda dos distintos tipos soporte: . soporte interacción, que middleware coordina las interacciones entre diferentes componentes del sistema. middleware proporciona transparencia ubicación cuanto que necesario que los componentes conozcan las ubi-caciones físicas los otros componentes. también puede soportar conversión parámetros usan diferentes lenguajes programación para implementación componentes, detección eventos comunicación, etcétera. . provisión servicios comunes, que middleware proporciona implemen-taciones reutilización servicios que pueden requerir varios componentes sistema distribuido. usar dichos servicios comunes, los componentes pueden interoperar fácilmente ofrecer los usuarios servicios una forma consistente.interacción lógicaintercambio información servicios comunesoperación coordinadacomponentes aplicación middleware sistema operativo red sistema aplicación middleware sistema operativo red sistema físicafigura . middleware sistema distribuido -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido sección .. presentaron ejemplos del soporte interacción que puede ofre- cer middleware. este último usa para soportar procedimientos remotos solicitudes métodos remotos, intercambio mensajes, etcétera. los servicios comunes son aquellos que pueden requerir diferentes componentes con independencia funcionalidad dichos componentes. como describió capítulo , pueden incluir servicios seguridad (autenticación autorización), servicios noti-ficación nomenclatura, servicios gestión transacción, etcétera. usted puede considerar que estos servicios comunes los brinda contenedor middleware. entonces usted implementa componente dicho contenedor puede acceder usar dichos servicios comunes. . computación cliente-servidor los sistemas distribuidos los que accede por internet organizan normalmente como sistemas cliente-servidor. sistema cliente-servidor, usuario interactúa con programa que ejecuta computadora local (por ejemplo, navegador web una aplicación basada telefonía). éste interactúa con otro programa que ejecuta una computadora remota (por ejemplo, servidor web). computadora remota proporciona servicios, como acceso páginas web, que están disponibles clientes externos. este modelo cliente-servidor, como estudió capítulo , modelo arquitectónico muy general una aplicación. está restringido aplicaciones distri-buidas través varias máquinas. también puede usar como modelo interac-ción lógica donde cliente servidor operan misma computadora. una arquitectura cliente-servidor, una aplicación modela como conjunto servicios que proporcionan los servidores. los clientes pueden acceder dichos servicios presentar resultados usuarios finales (orfali harkey, ). los clientes deben estar tanto los servidores que están disponibles, pero conocen existencia otros clientes. clientes servidores son procesos separados, como muestra figura .. ésta ilustra una situación donde existen cuatro servidores (-), que entregan diferen-tes servicios. cada servicio tiene conjunto clientes asociados que acceden dichos servicios. proceso clienteproceso servidor figura . interacción cliente-servidor -.indd -.indd // :: // :: . ■ computación cliente-servidor figura . muestra procesos cliente servidor vez procesadores. nor- mal que muchos procesos cliente ejecuten solo procesador. por ejemplo, , usted puede ejecutar cliente correo que descargue mensajes servidor correo remoto. también puede ejecutar navegador web que interactúe con servidor web remoto cliente impresión que envíe documentos una impresora remota. figura . ilustra situación donde los clientes lógicos que muestran figura . operan seis computadoras. los cuatro procesos servidor mapean sobre dos computadoras servidor físicas. varios procesos servidor diferentes pueden ejecutar mismo procesador, pero, con frecuencia, los servidores implementan como sistemas multiprocesador los que una instancia independiente del proceso servidor ejecuta cada máquina. software balanceo carga distribuye las peticiones servicio los clientes diferentes ser-vidores, modo que cada servidor realiza misma cantidad trabajo. esto permite manejo mayor volumen transacciones con los clientes, sin degradar respuesta clientes individuales. los sistemas cliente-servidor dependen que exista una separación clara entre presentación información los cálculos que crea procesa esa información. con-secuencia, debe diseñar arquitectura los sistemas distribuidos cliente-servidor para que estructuren varias capas lógicas, con interfaces claras entre dichas capas. esto permite que cada capa distribuya diferentes computadoras. figura . ilus-tra este modelo muestra una aplicación estructurada cuatro capas:  una capa presentación que ocupa presentar información usuario ges- tionar todas las interacciones usuario;  una capa gestión datos que gestiona los datos que pasan hacia desde cliente. esta capa puede implementar comprobaciones los datos, generar páginas web, etcétera;  una capa procesamiento aplicación que ocupa implementar lógica aplicación , este modo, proporciona funcionalidad requerida los usuarios finales;  una capa base datos que almacena los datos ofrece servicios gestión transacción, etcétera. siguiente sección explica cómo diferentes arquitecturas cliente-servidor distribu-yen dichas capas lógicas diversas formas. modelo cliente-servidor también destaca noción software como servicio (saas, por las siglas software service), una manera cada vez más importante implementar software acceder través internet. esto estudia sección ..redcc servidor computadora clientec , , , , , , , , . mapeo clientes servidores para computadoras red -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido . patrones arquitectónicos para sistemas distribuidos como explicó introducción este capítulo, los diseñadores sistemas dis- tribuidos deben organizar sus diseños sistema para encontrar equilibrio entre rendimiento, confiabilidad, seguridad manejabilidad del sistema. hay modelo universal organización sistemas adecuado todas las circunstancias, así que han surgido varios estilos arquitectónicos distribuidos. cuando diseñe una aplicación distri-buida, deberá elegir estilo arquitectónico que soporte los requerimientos funciona-les críticos sistema. esta sección describen cinco estilos arquitectónicos: . arquitectura maestro-esclavo, que usa sistemas tiempo real los que requiere garantía tiempos respuesta interacción. . arquitectura cliente-servidor dos niveles, que usa para sistemas cliente-servi-dor simple, situaciones donde importante centralizar sistema por razones seguridad. tales casos, comunicación entre cliente servidor por general está encriptada. . arquitectura cliente-servidor multinivel, que usa cuando existe enorme volu-men transacciones procesar por servidor. . arquitectura componentes distribuidos, que usa cuando necesario combinar los recursos diferentes sistemas bases datos, como modelo imple-mentación para sistemas cliente-servidor multinivel. . arquitectura peer--peer (entre pares punto punto, par par), que usa cuando los clientes intercambian manera local información almacenada, papel del servidor presentar los clientes entre . también puede usarse cuando deba elaborar amplio número cálculos independientes. .. arquitecturas maestro-esclavo las arquitecturas maestro-esclavo para sistemas distribuidos usan comúnmente sistemas tiempo real donde puede haber procesadores separados asociados con capa procesamiento aplicacióncapa gestión datoscapa presentación capa base datosfigura . modelo arquitectónico capas para una aplicación cliente-servidor -.indd -.indd // :: // :: . ■ patrones arquitectónicos para sistemas distribuidos adquisición datos del entorno del sistema, procesamiento datos computación actuador gestión. los actuadores, como estudia capítulo , son dispositi-vos controlados mediante sistema software que actúan para cambiar entorno del sistema. por ejemplo, actuador puede controlar una válvula cambiar estado “abierto” “cerrado”. proceso “maestro” por general responsable compu-tación, coordinación las comunicaciones, controla los procesos “esclavos”. estos procesos esclavos dedican acciones específicas, tales como adquisición datos arreglo sensores. figura . ilustra este modelo arquitectónico. modelo sistema con-trol tráfico una ciudad tiene tres procesos lógicos que ejecutan procesadores independientes. proceso maestro proceso sala control, que comunica con procesos esclavo independientes que son responsables recolectar datos tráfico administrar operación los semáforos. conjunto sensores distribuidos recolecta información acerca del flujo del tránsito. proceso control sensores consulta los sensores periódicamente para capturar información del flujo del tránsito coteja esta información para mayor pro-cesamiento. procesador sensores consulta habitualmente para obtener información por parte del proceso maestro, que ocupa desplegar estatus tránsito los operadores, calcular las secuencias los semáforos aceptar los coman-dos del operador para modificar dichas secuencias. sistema sala control envía comandos proceso control semáforos que los convierte señales para con-trolar hardware los semáforos. sistema maestro sala control está organi-zado como sistema cliente-servidor, los procesos cliente ejecutan las consolas del operador. este modelo maestro-esclavo sistema distribuido usa situaciones que posible predecir procesamiento distribuido que requiere, que procesa-miento puede asignarse fácilmente procesadores esclavos. esta situación común los sistemas tiempo real, los que importante cumplir con los plazos procesamiento. los procesadores esclavos pueden usarse para operaciones cómputo intensivo, como procesamiento señales administración equipo controlado por sistema.semáforosproceso control del semáforoprocesador control semáforos consolas operadoresclavoproceso coordinación despliegueprocesador sala control maestro proceso control sensoresprocesador sensor esclavo sensores cámaras flujo tráfico figura . sistema gestión tráfico con una arquitectura maestro-esclavo -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido .. arquitecturas cliente-servidor dos niveles sección . explicó forma general los sistemas cliente-servidor los que parte del sistema aplicación ejecuta computadora del usuario ( cliente) parte ejecuta una computadora remota ( servidor). también presentó modelo aplicación capas (figura .) que las diferentes capas del sistema pueden ejecutarse diferentes computadoras. una arquitectura cliente-servidor dos niveles forma más simple arquitec-tura cliente-servidor. sistema implementa como solo servidor lógico más número indefinido clientes que usan dicho servidor. esto ejemplifica figura ., que indica dos formas este modelo arquitectónico: . modelo cliente ligero, que capa presentación implementa cliente, todas las otras capas (gestión datos, procesamiento aplicación bases datos) implementan servidor. software cliente puede ser programa escrito especialmente cliente para manejar presentación. sin embargo, usa con más frecuencia navegador web computadora cliente para presentar los datos. . modelo cliente pesado, que parte todo procesamiento aplicación realiza cliente. las funciones gestión datos base datos implementan servidor. ventaja del modelo cliente ligero consiste que simple manejar por los clientes. esto representa gran conflicto existe considerable número clientes, pues puede ser difícil costoso instalar nuevo software todos ellos. usa navegador web como cliente, hay necesidad instalar software alguno. obstante, desventaja del enfoque cliente ligero que puede colocarse una fuerte carga procesamiento tanto servidor como red. servidor respon-sable toda computación esto puede conducir generación tráfico red sig-nificativo entre cliente servidor. por tanto, implementar sistema que use este modelo puede requerir inversión adicional capacidad red servidor. sin embargo, los navegadores pueden realizar parte del procesamiento local ejecutar scripts (por ejemplo, javascript) página web que ingresa mediante navegador. modelo cliente pesado utiliza poder procesamiento disponible compu-tadora que ejecuta software cliente, distribuye parte todo procesamiento aplicación presentación cliente. esencia, servidor servidor transacción modelo cliente ligero modelo cliente pesadoclienteclienteservidor base datos gestión datosprocesamiento aplicaciónpresentación servidor base datosgestión datosprocesamiento aplicación presentación figura . modelos arquitectónicos cliente pesado cliente ligero -.indd -.indd // :: // :: . ■ patrones arquitectónicos para sistemas distribuidos que gestiona todas las transacciones base datos. gestión datos directa, pues hay necesidad gestionar interacción entre cliente sistema procesamiento aplicación. desde luego, problema con modelo cliente pesado que requiere gestión sistema adicional para implementar mantener software computadora cliente. ejemplo una situación que usa una arquitectura cliente pesado sistema cajero automático, que entrega efectivo otros servicios bancarios los usuarios. cajero computadora cliente servidor , por general, main-frame que opera base datos cuentas los clientes. una computadora mainframe una máquina poderosamente diseñada para procesamiento transacciones. por con-siguiente, capaz manejar gran volumen las transacciones generadas por los cajeros automáticos, otros sistemas cajeros banca línea. software cajero realiza mucho procesamiento relacionado con cliente asociado con una transacción. figura . muestra una versión simplificada organización del sistema del cajero automático. observe que los cajeros conectan directamente base datos cliente, sino que, vez ello, conecta monitor teleprocesamiento. monitor teleprocesamiento () sistema middleware que organiza las comuni-caciones con clientes remotos pone serie las transacciones del cliente para proce-samiento base datos. esto garantiza que las transacciones sean independientes interfieran unas con otras. usar transacciones seriales significa que sistema puede recuperarse fallas sin corromper los datos del sistema. mientras que modelo cliente pesado distribuye procesamiento más efectiva-mente que modelo cliente ligero, más compleja gestión del sistema. funcio-nalidad aplicación dispersa través muchas computadoras. cuando software aplicación debe cambiarse, esto implica reinstalación cada computadora cliente. esto podría representar costo mayor existen cientos clientes sistema. quizá deba diseñar sistema para soportar actualizaciones software remoto tal vez sea necesario desactivar todos los servicios del sistema hasta sustituir software cliente. .. arquitecturas cliente-servidor multinivel problema fundamental con enfoque cliente-servidor dos niveles que las capas lógicas del sistema (presentación, procesamiento aplicación, gestión datos base datos) deben mapearse dos sistemas cómputo: cliente servidor. esto puede conducir problemas con escalabilidad rendimiento elige modelo servidor cuenta base datos cuenta del clientemonitor tele- procesamientoatm atm atm atmfigura . arquitectura cliente pesado para sistema cajero automático -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido cliente ligero, problemas gestión sistema usa modelo cliente pesado. para evitar algunos estos problemas, puede usar una arquitectura “cliente-servidor multinivel”. esta arquitectura, las diferentes capas del sistema (esto , presentación, gestión datos, procesamiento aplicación base datos) son procesos separados que pueden ejecutarse diferentes procesadores. sistema banca por internet (figura .) ejemplo una arquitectura cliente-servidor multinivel, donde existen tres niveles sistema. base datos clientes del banco (por general ubicada una computadora mainframe, como expuso anteriormente) brinda servicios base datos. servidor web ofrece servi-cios gestión datos, tales como generación páginas web algunos servicios aplicación. los servicios aplicación, tales como las instalaciones para transferir efec-tivo, generar estados cuenta, pagar facturas así sucesivamente, implementan servidor web como scripts que ejecutan por cliente. propia computadora del cliente con navegador cliente. este sistema escalable porque relativamente sencillo agregar servicios (ampliar) conforme aumenta número clientes. este caso, uso una arquitectura tres niveles permite optimizar transfe-rencia información entre servidor web servidor base datos. las comuni-caciones entre dichos sistemas pueden usar rápidos protocolos intercambio datos bajo nivel. para manejar recuperación información base datos, usa middleware eficiente que soporta consultas base datos lenguaje consulta estructurado (sql, por las siglas structured query language). modelo cliente-servidor tres niveles puede extenderse una variante multinivel, donde agregan servidores adicionales sistema. esto podría implicar uso servidor web para gestión datos servidores separados para procesamiento aplica-ción servicios base datos. los sistemas multinivel también pueden usarse cuando las aplicaciones necesitan tener acceso utilizar datos diferentes bases datos. este caso, tal vez requiera agregar servidor integración sistema. servidor integración recolecta los datos distribuidos los presenta servidor aplicación como fuera una sola base datos. como estudiará siguiente sección, las arqui-tecturas componentes distribuidos pueden usarse para implementar sistemas cliente-servidor multinivel. los sistemas cliente-servidor multinivel que distribuyen procesamiento aplica-ción través varios servidores son inherentemente más escalables que las arquitecturas dos niveles. procesamiento aplicación con frecuencia parte más volátil del servidor webclientecliente provisión servicio cuentaservidor base datos base datos cuentas clientessqlconsulta sqlinteracción https cliente clientenivel . presentación nivel . procesamiento aplicación gestión datosnivel . procesamiento base datos figura . arquitectura tres niveles para sistema banca por internet -.indd -.indd // :: // :: . ■ patrones arquitectónicos para sistemas distribuidos sistema puede actualizarse fácilmente, que ubica centralmente. procesamiento, algunos casos, puede distribuirse entre lógica aplicación los servidores gestión datos; por tanto, conduce una respuesta más rápida las solicitudes del cliente. los diseñadores arquitecturas cliente-servidor deben tomar cuenta varios fac-tores cuando elijan arquitectura distribución más adecuada. figura . describen las situaciones las que probable que sean adecuadas las arquitecturas cliente-servidor discutidas aquí. .. arquitecturas componentes distribuidos organizar procesamiento capas, como muestra figura ., cada capa sistema puede implementarse como servidor lógico separado. este modelo fun-ciona bien para muchos tipos aplicación. sin embargo, limita flexibilidad los diseñadores del sistema cuanto que deben decidir cuáles servicios incluir cada capa. obstante, práctica, siempre claro servicio gestión datos, uno aplicación uno base datos. los diseñadores también deben planear escalabilidad así ofrecer ciertos medios para que los servidores repliquen con-forme agregan más clientes sistema. enfoque más general diseño sistemas distribuidos diseñar sistema como conjunto servicios, sin tratar asignar dichos servicios capas sistema. cada servicio, grupo servicios relacionados, implementa usando componen- separado. una arquitectura componentes distribuida (figura .), sistema está organizado como conjunto componentes objetos interacción. dichos componen-tes proporcionan una interfaz conjunto servicios que ofrecen. otros componentes arquitectura aplicaciones arquitectura cliente- servidor dos niveles con clientes ligerosaplicaciones sistema heredado que usan cuando práctica separación procesamiento aplicación gestión datos. los clientes pueden tener acceso ellos como servicios, tal como refiere sección .. aplicaciones cómputo intensivo, como los compiladores con poca ninguna gestión datos. aplicaciones intensivas datos (navegación consulta) con procesamiento aplicación intensivo. navegar web ejemplo más común una situación donde emplea esta arquitectura. arquitectura cliente-servidor dos niveles con clientes pesadosaplicaciones donde procesamiento aplicación proporciona software comercial (por ejemplo, microsoft excel) cliente. aplicaciones que requiere procesamiento datos cómputo intensivo (por ejemplo, visualización datos). aplicaciones móviles las que puede garantizarse conectividad internet. por tanto, posible algún procesamiento local usando información caché base datos. arquitectura cliente-servidor multinivel aplicaciones grandes con cientos miles clientes. aplicaciones que tanto los datos como aplicación son volátiles.aplicaciones que integran datos fuentes múltiples. figura . uso patrones arquitectónicos cliente-servidor -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido solicitan dichos servicios través middleware, usando solicitudes procedimiento remoto llamadas métodos. los sistemas componentes distribuidos dependen del middleware, que gestiona las interacciones componentes, reconcilia las diferencias entre tipos parámetros transmi-tidos entre componentes, ofrece conjunto servicios comunes que pueden usar los componentes aplicación. corba (orfali ., ) fue ejemplo temprano tal middleware, pero ahora usa ampliamente. fue sustituido sobre todo por software propietario como enterprise java beans (ejb) .net. los beneficios usar modelo componentes distribuidos para implementar sis-temas distribuidos son los siguientes: . permite diseñador del sistema demorar las decisiones acerca dónde cómo deben proporcionarse los servicios. los componentes que brindan servicios pueden ejecutarse cualquier nodo red. hay necesidad decidir por adelantado servicio parte una capa gestión datos, una capa aplicación, etcétera. . una arquitectura sistema muy abierta que permite adicionar nuevos recursos conforme requiera. pueden agregarse fácilmente nuevos servicios sistema sin grandes perturbaciones sistema existente. . sistema flexible escalable. pueden añadirse nuevos componentes compo-nentes replicados medida que aumente carga del sistema, sin perturbar otras partes éste. . posible, según requiera, reconfigurar dinámicamente sistema con compo-nentes que migran través red. esto puede ser importante donde existan patro-nes fluctuantes demanda servicios. componente prestación servicios puede migrar hacia mismo procesador que solicitó servicio como objeto, por que mejora rendimiento del sistema. una arquitectura componentes distribuidos puede usarse como modelo lógico que permita estructurar organizar sistema. este caso, piense cómo ofrecer funcionalidad aplicación exclusivamente términos servicios combinacio-nes servicios. entonces calcule cómo ofrecer dichos servicios mediante conjun- componentes distribuidos. por ejemplo, una aplicación ventas, puede haber middleware comunicacióncomp servicios comunescomp servicios comunescomp servicios comunescomp servicios comunes cliente cliente cliente clientefigura . arquitectura componentes distribuida -.indd -.indd // :: // :: . ■ patrones arquitectónicos para sistemas distribuidos componentes aplicación que ocupen del control almacenes, comunicaciones con los clientes, pedidos, etcétera. los sistemas minería datos son buen ejemplo tipo sistema que una arquitectura componentes distribuidos mejor patrón arquitectónico usar. sistema minería datos busca relaciones entre los datos que almacenan algunas bases datos (figura .). los sistemas minería datos por general obtienen información varias bases datos separadas, realizan procesamiento inten-sivo cómputo despliegan sus resultados forma gráfica. ejemplo tal aplicación minería datos puede ser sistema para nego-cio que vende alimentos libros. departamento marketing quiere encontrar relacio-nes entre las compras alimentos libros cliente. por ejemplo, una proporción relativamente alta personas que compran pizzas quizá también compren novelas poli-ciacas. con este conocimiento, empresa puede dirigirse específicamente clientes que realicen compras alimentos específicas con información acerca nuevas novelas cuando publican. este ejemplo, cada base datos ventas puede encapsularse como compo-nente distribuido con una interfaz que proporcione acceso sólo lectura sus datos. los componentes integrador dedican cada uno tipos específicos relaciones, recolectan información todas las bases datos para tratar deducir las relaciones. podría haber componente integrador que ocupe las variaciones estacionales los bienes vendidos, otro que trate con las relaciones entre diferentes tipos bienes. los componentes visualizador interactúan con los componentes integrador para producir una visualización reporte acerca las relaciones que descubrieron. debido los grandes volúmenes datos que manejan, los componentes visualizador con frecuencia presentan sus resultados gráficamente. para concluir, componente des-pliegue puede ser responsable entrega los modelos gráficos los clientes para presentación final. una arquitectura componentes distribuidos, lugar una arquitectura capas, adecuada para este tipo aplicaciones, porque posible agregar nuevas bases clientesbase datos base datos base datos integrador reporte visualizador despliegue figura . arquitectura componentes distribuida para sistema minería datos -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido datos sistema sin causar grandes perturbaciones. cada nueva base datos accede simplemente agregar otro componente distribuido. los componentes acceso base datos proporcionan una interfaz simplificada que controla acceso los datos. las bases datos las que ingresa pueden residir diferentes máquinas. arqui-tectura facilita también extraer nuevos tipos relaciones agregar nuevos componen-tes integrador. las arquitecturas componentes distribuidos enfrentan dos grandes desventajas: . son más complejas diseñar que los sistemas cliente-servidor. los sistemas clien- -servidor multinivel parecen ser una forma bastante intuitiva pensar los sis-temas. ellos reflejan muchas transacciones humanas donde las personas solicitan reciben servicios otras personas que especializan ofrecer dichos servicios. contraste, para las personas, las arquitecturas componentes distribuidos son más difíciles visualizar entender. . middleware estandarizado para sistemas componentes distribuidos nunca aceptado por comunidad. lugar, distintos proveedores, como microsoft sun, han desarrollado middleware diferente incompatible. middleware incrementa complejidad general los componentes los sistemas distribuidos. como resultado estos problemas, las arquitecturas orientadas servicios (que estudian capítulo ) sustituyen las arquitecturas componentes distribuidos muchas situaciones. sin embargo, los sistemas componentes distribuidos tienen bene-ficios rendimiento sobre los sistemas orientados servicios. las comunicaciones rpc, por general, son más rápidas que interacción basada mensajes que usa los sistemas orientados servicios. por tanto, las arquitecturas basadas componentes son más adecuadas para sistemas alto rendimiento global los que gran número tran-sacciones debe procesarse rápidamente. .. arquitecturas entre pares (peer--peer) modelo cliente-servidor computación que analizó las secciones anteriores del capítulo hace una clara distinción entre servidores, que son los proveedores servicios, clientes, que son los receptores los servicios. este modelo conduce regularmente una distribución desigual carga sistema, que los servidores realizan más trabajo que los clientes. esto puede conducir que las organizaciones gasten mucho capacidad servidor mientras que existe una capacidad procesamiento utilizada los cientos miles que usan para acceder los servidores del sistema. los sistemas entre pares ( punto punto, ) son sistemas descentralizados los que los cálculos pueden realizarse cualquier nodo red. menos principio, hacen distinciones entre clientes servidores. las aplicaciones entre pares, sistema global está diseñado para sacar ventaja del poder computacional almace-namiento disponible través una red computadoras potencialmente enorme. los estándares protocolos que permiten las comunicaciones través los nodos embe-ben aplicación cada nodo debe ejecutar una copia dicha aplicación. las tecnologías par par han usado principalmente para sistemas personales más que empresariales (oram, ). por ejemplo, los sistemas para compartir archivos basa- -.indd -.indd // :: // :: . ■ patrones arquitectónicos para sistemas distribuidos dos los protocolos gnutella bittorrent usan para intercambiar archivos las los usuarios. los sistemas mensajería instantánea como icq jabber proporcionan comunicaciones directas entre usuarios sin servidor intermediario. seti@home proyecto hace mucho tiempo que procesa datos radiotelescopios computadoras domésticas para buscar indicios vida extraterrestre. freenet una base datos des-centralizada diseñada para facilitar publicación información manera anónima, dificultar que las autoridades supriman esta información. los servicios telefónicos voz sobre (voice over , voip), como skype, dependen comunicación par par entre los participantes llamada conferencia telefónica. sin embargo, los sistemas par par usan también las empresas para aprovechar poder sus redes computadoras (mcdougall, ). intel boeing implementaron sistemas para aplicaciones cómputo intensivo. esto saca ventaja capacidad procesamiento utilizada computadoras locales. lugar comprar costoso hardware alto rendimiento, los cálculos ingeniería pueden ejecutarse durante noche cuando utilizan las computadoras escritorio. las empresas también usan manera extensa los sistemas comerciales, tales como los sistemas mensajería voip. adecuado usar modelo arquitectónico punto punto para sistema dos circunstancias: . donde sistema cómputo intensivo posible separar procesamiento requerido gran número cálculos independientes. por ejemplo, sistema punto punto que soporta descubrimiento computacional medicamentos dis-tribuye los cálculos que buscan tratamientos potenciales cáncer analizar enorme número moléculas para ver tienen las características requeridas para suprimir crecimiento tumores cancerosos. cada molécula puede considerarse por separado, modo que hay necesidad que los pares sistema comu-niquen. . donde sistema principalmente implica intercambio información entre compu-tadoras individuales una red hay necesidad que esta información alma-cene gestione manera centralizada. los ejemplos tales aplicaciones incluyen sistemas para compartir archivos que permiten los pares intercambiar archivos locales, tales como música películas, sistemas telefónicos que soportan comuni-caciones voz video entre computadoras. principio, cada nodo una red podría estar tanto cualquier otro nodo. los nodos podrían conectarse intercambiar datos directamente con cualquier otro nodo red. práctica, desde luego, esto imposible, pues los nodos están organizados “loca-lidades” con algunos nodos actuando como puentes hacia otras localidades nodos. figura . muestra esta arquitectura descentralizada. una arquitectura descentralizada, los nodos red son simplemente elemen-tos funcionales, sino también conmutadores comunicaciones que pueden dirigir datos controlar señales nodo otro. por ejemplo, suponga que figura . repre-senta sistema descentralizado gestión documentos. este sistema utiliza consorcio investigadores para compartir documentos, cada miembro del consorcio mantiene propio almacén documentos. sin embargo, cuando recupera docu-mento, nodo que recupera también pone disposición otros nodos. -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido alguien necesita documento que almacene alguna otra parte red, ellos emiten comando búsqueda, que envía los nodos “localidad”. dichos nodos comprueban tienen documento , así, devuelven solicitante. tienen, dirigen búsqueda hacia otros nodos. por tanto, emite una búsqueda para documento que almacena , esta búsqueda dirige través los nodos , hasta . cuando finalmente encuentra documento, nodo que contiene documento envía nodo solicitante directamente hacer una conexión punto punto. esta arquitectura descentralizada tiene ventajas cuanto que considerablemente redundante , por consiguiente tolerante, fallas tolerante los nodos que desconec-tan red. sin embargo, aquí las desventajas son que muchos nodos diferentes pueden procesar misma búsqueda, también existe significativa carga trabajo replicar las comunicaciones los pares. modelo arquitectónico alternativo, que parte una arquitectura pura, una arquitectura semicentralizada donde, dentro red, uno más nodos actúan como servidores para facilitar las comunicaciones entre nodos. esto reduce cantidad trá-fico entre nodos. figura . ilustra este modelo. una arquitectura semicentralizada, papel del servidor (llamado ocasiones superpar) ayudar establecer contacto entre pares red, coordinar los resultados cálculo. por ejemplo, figura . representa sistema mensajería instan-tánea, entonces los nodos red comunican con servidor (indicado mediante las líneas punteadas) para descubrir qué otros nodos están disponibles. una vez descubiertos dichos nodos, pueden establecerse comunicaciones directas conexión servidor necesaria. por tanto, los nodos , , están comunicación directa. sistema computacional , donde cómputo intensivo procesador dis-tribuye través gran número nodos, normal que algunos nodos sean superpa-res. papel distribuir trabajo hacia otros nodos cotejar verificar los resultados computación. las arquitecturas par par permiten uso eficiente capacidad través red. sin embargo, las principales preocupaciones que inhiben uso son los conflictos seguridad confianza. las comunicaciones par par implican abrir computadora interacciones directas con otros pares esto significa que dichos sistemas podrían, potencialmente, acceder cualquiera sus recursos. para contrarrestar anterior, necesario organizar sistema manera que dichos recursos estén protegidos. esto hace manera incorrecta, entonces sistema puede ser inseguro. . arquitectura descentralizada -.indd -.indd // :: // :: . ■ software como servicio también pueden ocurrir problemas cuando los pares una red deliberadamente comportan forma maliciosa. por ejemplo, han reportado casos donde compañías musicales que consideraban que sus derechos autor eran violados, deliberadamente crearon “pares envenenados” disponibles. cuando otro par descarga que considera que una pieza música, archivo real entregado malware que puede ser una versión deliberadamente corrompida música una advertencia usuario violaciones derecho autor. . software como servicio las secciones anteriores estudiaron los modelos cliente-servidor cómo distri-buye funcionalidad entre cliente servidor. para implementar sistema clien--servidor, tal vez tenga que instalar programa computadora cliente, que comunique con servidor, aplique funcionalidad lado del cliente gestione inter-faz usuario. por ejemplo, cliente correo, como outlook mac mail, proporciona características gestión correo computadora. esto evita problema algunos sistemas cliente ligero, que todo procesamiento realiza servidor. sin embargo, los problemas sobrecarga del servidor pueden reducirse significa-tivamente usar navegador moderno como software cliente. las tecnologías web, como ajax (holdener, ), soportan gestión eficiente presentación página web computación local mediante scripts. esto significa que navegador puede configurarse usarse como cliente, con significativo procesamiento local. software aplicación puede considerarse tal como servicio remoto, que puede accederse desde cualquier dispositivo capaz ejecutar navegador estándar. ejemplos bien conocidos son los sistemas correo basados web, como yahoo! gmail, aplicaciones oficina, como google docs. esta noción saas implica alojar software remotamente proporcionar acceso mismo través internet. los elementos clave saas son los siguientes: . software despliega servidor (, más comúnmente, algunos servidores) accede través navegador web. implementa una computa-dora local. . software propiedad proveedor software, quien administra, lugar las organizaciones que usan software. descubierto (superpar) figura . arquitectura semicentralizada -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido . los usuarios pueden pagar por software acuerdo con cantidad uso que hagan mediante una suscripción anual mensual. ocasiones, software gratuito para quien utilice, pero entonces los usuarios deben estar acuerdo aceptar publicidad, que financia servicio del software. para usuarios software, beneficio saas que los costos para administrar software transfieren proveedor. proveedor responsable corregir los bugs ins-talar las actualizaciones software, enfrentar los cambios plataforma del sistema ope-rativo asegurar que capacidad del hardware pueda cumplir demanda. los costos gestión licencia del software son iguales cero. alguien tiene muchas computadoras, hay necesidad autorizar las licencias del software para todas ellas. una aplicación software sólo usa ocasionalmente, modelo “pago por uso” puede ser más barato que comprar una aplicación. posible acceder software desde dispositivos móviles, tales como los teléfonos inteligentes (smart phones), desde cualquier parte del mundo. por supuesto, este modelo provisión software tiene algunas desventajas. prin-cipal problema, posiblemente, costo transferir datos servicio remoto. trans-ferencia datos acuerdo con las velocidades red, por que transferir una gran cantidad datos puede tardar mucho tiempo. también posible que deba pagar proveedor del servicio acuerdo con cantidad transferida. otros problemas son falta control sobre evolución del software ( proveedor puede cambiar software cuando desee) problemas con legislación las regulaciones. muchos países tienen leyes que regulan almacenamiento, gestión, conservación accesibilidad los datos, transferir datos servicio remoto puede quebrantar dichas leyes. noción saas arquitecturas orientadas servicios (soa, por las siglas ser-vice-oriented architectures), que estudian capítulo , evidentemente relacio-nan, aunque son mismo: . saas una forma proporcionar funcionalidad servidor remoto, con acceso clientes mediante navegador web. servidor conserva los datos estado del usuario durante una sesión interacción. por regular, las transacciones son largas (por ejemplo, edición documento). . soa enfoque estructuración sistema software como conjunto servicios independientes, sin estado. éstos pueden proporcionarse mediante múl-tiples proveedores distribuirse. por general, las transacciones son transacciones cortas donde solicita servicio, hace algo luego devuelve resultado. saas una forma entregar funcionalidad aplicación los usuarios, mientras que soa una tecnología implementación para sistemas aplicación. funciona-lidad implementada con uso soa necesita aparecer los usuarios como servi-cios. igual modo, los servicios usuario tienen que implementarse usando soa. sin embargo, saas implementa mediante soa, posible que las aplicaciones usen api servicio para acceder funcionalidad otras aplicaciones. entones pueden integrarse sistemas más complejos. éstos les llama mashups (remezcla aplica-ción híbrida) representan otro enfoque reutilización software desarrollo software rápido. desde una perspectiva desarrollo software, proceso desarrollo servicios tiene mucho común con otros tipos desarrollo software. sin embargo, cons-trucción servicio, por regular, está dirigida por los requerimientos del usuario, -.indd -.indd // :: // :: . ■ software como servicio sino por las suposiciones del proveedor del servicio acerca que necesitan los usua- rios. por tanto, preciso que software pueda evolucionar rápidamente después que proveedor obtiene retroalimentación los usuarios acerca sus requerimientos. por consiguiente, desarrollo ágil con entrega incremental enfoque usado común-mente para software que debe implementarse como servicio. cuando implemente saas debe considerar que puede tener usuarios del software varias organizaciones diferentes. debe tener cuenta tres factores: . configurabilidad ¿cómo configura usted software para los requerimientos específicos cada organización? . multitenencia ¿cómo presenta cada usuario del software impresión que trabaja con propia copia del sistema mientras, mismo tiempo, hace uso efi-ciente los recursos del sistema? . escalabilidad ¿cómo diseña sistema modo que pueda escalarse para alojar número impredeciblemente grande usuarios? noción arquitecturas línea producto, que expuso capítulo , una forma configurar software para usuarios con requerimientos que traslapan, aunque son idénticos. usted comienza con sistema genérico adapta acuerdo con los requerimientos específicos cada usuario. sin embargo, esto funciona para saas, pues significaría implementar una copia diferente del servicio para cada organización que use software. vez ello, necesario diseñar configurabilidad sistema proporcionar una interfaz confi-guración que permita los usuarios especificar sus preferencias. luego esto usa para ajustar dinámicamente comportamiento del software conforme utilice. las instala-ciones configuración pueden permitir siguiente: . marca: los usuarios cada organización les presenta una interfaz que refleja propia organización. . reglas flujos trabajo empresariales: cada organización define sus propias reglas que regulan uso del servicio sus datos. . extensiones base datos: cada organización define cómo extiende modelo datos del servicio genérico para cubrir sus necesidades específicas. . control acceso: los clientes del servicio crean cuentas individuales para perso-nal definen los recursos funciones que son accesibles cada uno sus usuarios.usuario usuario usuario usuario usuario servicio aplicaciónperfil perfil perfil figura . configuración sistema software ofrecido como servicio -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido figura . ilustra esta situación. este diagrama muestra cinco usuarios del servicio aplicación, quienes trabajan para tres clientes diferentes del proveedor del servicio. los usuarios interactúan con los servicios mediante perfil cliente que define configura-ción del servicio para empleador. multitenencia una situación que muchos usuarios diferentes acceden mismo sistema arquitectura del sistema define para permitir que hecho com-partir los recursos del sistema sea eficiente. sin embargo, debe parecer cada usuario que tiene uso exclusivo del sistema. multitenencia implica diseñar sistema modo que exista una separación absoluta entre funcionalidad los datos del sis-tema. por tanto, debe diseñar sistema manera que todas las operaciones sean sin estados. los datos deben proporcionarse por parte del cliente estar disponibles sistema almacenamiento base datos que pueda accederse desde cualquier instancia del sistema. las bases datos relacionales son ideales para proporcionar multitenencia, los grandes proveedores servicio, tales como google, implementaron bases datos más simples para datos usuarios. problema particular los sistemas multitenencia gestión datos. forma más sencilla proporcionar gestión datos que cada cliente tenga propia base datos, cual pueden usar configurar como desee. sin embargo, esto requiere que proveedor del servicio conserve numerosas instancias base datos diferentes (una por cliente) las ponga disposición demanda. esto ineficiente términos capacidad servidor aumenta costo global del servicio. como alternativa, proveedor del servicio puede usar una sola base datos que diferentes usuarios estén prácticamente aislados dentro dicha base datos. esto ilustra figura ., donde observa que las entradas base datos tienen tam-bién “identificador tenencia”, que vincula dichas entradas usuarios específicos. usar vistas base datos, posible extraer las entradas para cada cliente del servicio así presentar los usuarios dicho cliente una base datos personal virtual. esto puede extenderse para cubrir las necesidades específicas del cliente usando las caracterís-ticas configuración discutidas anteriormente. escalabilidad capacidad del sistema hacer frente número creciente usuarios sin reducir qos global que entrega cualquier usuario. por gene-ral, cuando considera escalabilidad contexto saas, toma cuenta “ampliación”, lugar “expansión”. recuerde que “ampliación” significa agregar servidores adicionales para así incrementar número transacciones que pueden pro-cesarse paralelo. escalabilidad tema complejo que aquí puede tratarse con detalle, pero algunos lineamientos generales para implementar software escalable son: . desarrolle aplicaciones las que cada componente implemente como simple servicio sin estado que pueda ejecutarse cualquier servidor. por consiguiente, tenencia clave nombre dirección xyz corp , anystreet, sometown bigcorp , main , motown . bowie , mill , starville . burns alloway, ayrshire figura . base datos multitenencia -.indd -.indd // :: // :: pmcapítulo ■ puntos clave curso una sola transacción, usuario puede interactuar con instancias del mismo servicio que operan varios servidores diferentes. . diseñe sistema usando interacción asíncrona, para que aplicación tenga que esperar resultado una interacción (como una solicitud lectura). esto permite que aplicación realice trabajo útil mientras espera que termine interacción. . gestione los recursos, tales como conexiones red bases datos, como depó-sito para que ningún servidor individual tenga probabilidad agotar sus recursos. . diseñe base datos para permitir bloqueo grano fino. esto , bloquee registros completos base datos cuando esté uso sólo parte registro. noción saas gran cambio paradigma para computación distribuida. lugar que una organización aloje aplicaciones múltiples sus servidores, saas permite que diferentes proveedores proporcionen externamente dichas aplicaciones. está medio una transición modelo otro , futuro, probable que esto tenga efecto muy significativo sobre ingeniería los sistemas software empre-sariales. puntos clave ■ los beneficios los sistemas distribuidos son que pueden escalarse para hacer frente demanda creciente, pueden seguir proporcionando servicios usuario (aun fallan algunas partes del sistema) permitir almacenamiento recursos. ■ los conflictos considerar diseño los sistemas distribuidos incluyen transparencia, apertura, escalabilidad, seguridad, calidad servicio gestión fallas. ■ los sistemas cliente-servidor son sistemas distribuidos los que sistema estructura capas, con capa presentación implementada una computadora cliente. los servidores ofrecen servicios gestión datos, aplicación base datos. ■ los sistemas cliente-servidor pueden tener varios niveles, con diferentes capas del sistema distribuidas diferentes computadoras. ■ los patrones arquitectónicos para sistemas distribuidos incluyen arquitecturas maestro-esclavo, arquitecturas cliente-servidor dos niveles multinivel, arquitecturas componentes distribuidos arquitecturas entre pares (par par punto punto). ■ los sistemas componentes distribuidos requieren que middleware maneje las comunicaciones los componentes que permitan que agreguen eliminen componentes del sistema. ■ las arquitecturas entre pares son arquitecturas descentralizadas las que hay distinción entre clientes servidores. computación puede distribuir entre muchos sistemas diferentes organizaciones. ■ software como servicio una forma implementar aplicaciones como sistemas cliente-servidor ligero, que cliente navegador web. -.indd -.indd // :: // :: capítulo ■ ingeniería software distribuido lecturas sugeridas “middleware: model for distributed systems services”. aunque poco arcaico algunas partes, éste excelente ensayo panorámico que resume papel del middleware sistemas distribuidos analiza rango servicios middleware que pueden proporcionarse. (. . bernstein, comm. acm, (), febrero .) http:/ /. doi. org/ . / . . peer--peer: harnessing the power disruptive technologies . aun cuando este libro tiene mucha información sobre arquitecturas , una excelente introducción computación que explica organización enfoque utilizados algunos sistemas . (. oram (.), ’reilly and associates inc., .) “turning software into service”. buen ensayo que analiza los principios computación orientada servicios. diferencia muchos ensayos acerca este tema, oculta los principios detrás una discusión los estándares implicados. (. turner, . budgen . brereton, ieee computer, (), octubre .) http:/ /. doi. org/ . / . . . distributed systems: principles and paradigms, edition . libro texto completo que describe todos los aspectos del diseño implementación sistemas distribuidos. sin embargo, incluye una amplia discusión del paradigma orientado servicios. (.. tanenbaum . van steen, addison-wesley, .) “software service; the spark that will change software engineering”. ensayo breve que argumenta que llegada saas llevará todo desarrollo software modelo iterativo. (. goth, distributed systems online, (), julio .) http:/ /. doi. org/ . / mdso. . . ejercicios .. ¿qué entiende por “escalabilidad”? discuta las diferencias entre “expansión” ( scaling ) “ampliación” (scaling out) explique cuándo pueden usarse estos diferentes enfoques escalabilidad. .. explique por qué los sistemas software distribuidos son más complejos que los sistemas software centralizados, donde toda funcionalidad del sistema implementa una sola computadora. .. use ejemplo una solicitud procedimiento remoto para explicar cómo middleware coordina interacción las computadoras sistema distribuido. .. ¿cuál diferencia fundamental entre enfoque cliente pesado uno cliente ligero para las arquitecturas sistemas cliente-servidor? .. lector pide diseñar sistema seguro que requiera autenticación autorización. sistema debe diseñarse forma que las comunicaciones entre partes del sistema puedan interceptarse leerse por atacante. sugiera arquitectura cliente-servidor más adecuada para este sistema , argumentando razones para respuesta, proponga cómo debe distribuirse funcionalidad del sistema entre cliente servidor. .. cliente quiere desarrollar sistema para información acciones donde los operadores puedan acceder información compañías evaluar varios escenarios inversión -.indd -.indd // :: // :: pmcapítulo ■ referencias mediante sistema simulación. cada operador usa esta simulación una forma diferente, acuerdo con experiencia tipo acciones cuestión. sugiera una arquitectura cliente-servidor para este sistema que muestre dónde ubica funcionalidad. justifique modelo cliente-servidor que haya elegido. .. con enfoque componentes distribuidos, proponga una arquitectura para sistema boletaje nacional teatros. los usuarios pueden verificar disponibilidad asientos reservarlos grupo teatros. sistema debe soportar devoluciones boletos manera que las personas puedan devolver último minuto sus boletos para reventa otros clientes. .. indique dos ventajas dos desventajas las arquitecturas entre pares descentralizada semicentralizada. .. explique por qué implementar software como servicio puede reducir los costos soporte para una compañía. ¿qué costos adicionales pueden surgir usa este modelo implementación? .. compañía quiere abandonar uso aplicaciones escritorio para acceder misma funcionalidad forma remota como servicio. identifique tres riesgos que podrían surgir sugiera cómo pueden reducirse tales riesgos. referencias bernstein, . . (). “middleware: model for distributed system services”. comm. acm, (), –. coulouris, ., dollimore, . kindberg, . (). distributed systems: concepts and design, edition. harlow, .: addison-wesley. holdener, . . (). ajax: the definitive guide. sebastopol, calif.: ’reilly and associates.mcdougall, . (). “the power peer--peer”. information week ( agosto ). neuman, . . (). “scale distributed systems”. readings distributed computing systems. casavant, . singal, . (.). los alamitos, calif.: ieee computer society press. oram, . (). “peer--peer: harnessing the benefits disruptive technology”. orfali, . harkey, . (). client/server programming with java and corba . nueva york: john wiley & sons.orfali, ., harkey, . edwards, . (). instant corba. chichester, : john wiley & sons.pope, . (). the corba reference guide: understanding the common request broker architecture. boston: addison-wesley. tanenbaum, . . van steen, . (). distributed systems: principles and paradigms, edition. upper saddle river, : prentice hall. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo arquitectura software orientada servicios como una forma construir aplicaciones distribuidas mediante servicios web. estudiar este capítulo: ■ comprenderá las nociones básicas servicio web, estándares servicio web arquitectura orientada servicios; ■ conocerá proceso ingeniería servicio cuya intención producir servicios web reutilización; ■ introducirá concepto composición servicios como medio desarrollo aplicaciones orientadas servicios; ■ entenderá cómo pueden usarse los modelos proceso empresarial como base para diseño sistemas orientados servicios. contenido . servicios como componentes reutilización . ingeniería servicio . desarrollo software con servicios arquitectura orientada servicios -.indd -.indd // :: // :: pmel desarrollo web década revolucionó intercambio información organizacional. las computadoras cliente podían obtener acceso información ser-vidores remotos fuera sus organizaciones. sin embargo, acceso era exclusivamente través navegador web era práctico acceso directo información por parte otros programas. esto significó que fueran imposibles las conexiones oportunis-tas entre servidores donde, por ejemplo, programa consultaba algunos catálogos diferentes proveedores. para solucionar este problema propuso noción servicio web. usar servicio web, las organizaciones que querían hacer accesible información para otros programas podían lograrlo definir publicar una interfaz servicio web. esta inter-faz define los datos disponibles cómo puede acceder ellos. manera más gene-ral, servicio web una representación estándar para cierto recurso computacional información que pueden usar otros programas. éstos pueden ser recursos información (como catálogo partes), recursos computadora (como procesador especiali-zado), recursos almacenamiento. por ejemplo, podría implementarse servicio archivo que almacenara forma permanente fiable datos organización que, por ley, deben conservarse durante muchos años. servicio web una instancia una noción más general servicio, que define (lovelock ., ) como: acto una función ofrecidos por una parte otra. aunque proceso puede asociarse proceso físico, función esencialmente intangible , por general, por resultado propiedad alguno los factores producción. por consiguiente, particularidad servicio que hecho proveer servicio independiente aplicación que usa servicio (turner ., ). los proveedores servicio pueden desarrollar servicios especializados ofrecer éstos varios usuarios servicio diferentes organizaciones. las arquitecturas orientadas servicios (soa, por las siglas service-oriented archi- tectures) son una forma desarrollar sistemas distribuidos que los componentes del sistema son servicios independientes ejecutan computadoras distribuidas geo-gráficamente. los protocolos estándar basados xml, tales como soap wsdl, diseñaron para dar soporte servicio comunicación intercambio informa-ción. por consiguiente, los servicios son independientes plataforma del lenguaje implementación. los sistemas software pueden construirse componer servicios locales servicios externos diferentes proveedores, con interacción uniforme entre los servicios del sistema. figura . resume idea una soa. los proveedores servicio diseñan implementan servicios especifican las interfaces estos últimos. también transmi-ten información acerca dichos servicios registro accesible. los solicitantes servicio (llamados ocasiones clientes) que quieren usar servicio detectan espe-cificación éste ubican proveedor del servicio. entonces pueden unir aplica-ción con dicho servicio específico comunicarse con , mediante protocolos servicio estándar. desde principio hay proceso estandarización activo para soa, que trabaja junto los desarrollos técnicos. todas las grandes compañías hardware software comprometen con dichos estándares. como resultado, soa sufrido las incom-capítulo ■ arquitectura orientada servicios -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios patibilidades que surgen comúnmente con las innovaciones técnicas, cuando diferentes proveedores mantienen versión privada tecnología. figura . muestra pila estándares clave que establecieron para dar soporte los servicios web. debido este inicio estandarización, los problemas discutidos capítulo , tales como los modelos múltiples componentes incompatibles cbse, aún surgen desarrollo sistemas orientados servicios. los protocolos servicios web cubren todos los aspectos soa, desde los mecanismos básicos para servicio intercambio información (soap) hasta están-dares lenguaje programación (-bpel). dichos estándares basan xml, una notación humana legible para una máquina que permite definición datos estructurados donde texto etiqueta con identificador significativo. xml tiene una gama tecnologías apoyo, tal como xsd para definición esquemas, que usan para extender manipular descripciones xml. erl () aporta buen compen-dio sobre tecnologías xml función los servicios web. brevemente, los estándares clave las soa web son los siguientes: . soap éste estándar intercambio mensajes que soporta comuni- cación entre servicios. define componente esencial opcional los mensajes transmitidos entre los servicios. . wsdl lenguaje definición servicio web (wsdl, por las siglas web service definition language) estándar para definición interfaz servi-cio. establece cómo deben definirse las operaciones servicios (nombres opera-ción, parámetros sus tipos) los enlaces servicio. . -bpel éste estándar para lenguaje flujo trabajo que usa para definir programas proceso que implican varios servicios diferentes. sección . explica noción programas proceso. también propuso estándar descubrimiento servicio, uddi, pero esto adoptado ampliamente. estándar uddi (por las siglas universal description, discovery and integration, decir, descripción, descubrimiento integración univer-sales) define los componentes una especificación servicio, que puede usarse para descubrir existencia servicio. incluye información del proveedor, los servicios proporcionados, ubicación descripción wsdl interfaz servicio infor-mación sobre las relaciones empresariales. intención era que este estándar permitiría establecer las compañías registros con descripciones uddi que definen los servicios que éstas ofrecen.registro servicio proveedor del serviciosolicitante del servicioservicioencontrar transmitir unir (soap) (wsdl)figura . arquitectura orientada servicios -.indd -.indd // :: // :: pmcapítulo ■ arquitectura orientada servicios algunas compañías, como microsoft, establecieron registros uddi durante los primeros años del siglo xxi, aunque ahora todos están cerrados. las mejoras tecnología motores búsqueda los hicieron redundantes. descubrimiento servicios usando motor búsqueda estándar para examinar descripciones wsdl comentadas manera adecuada, ahora enfoque preferido descubrimiento servicios externos. los principales estándares soa están soportados por una variedad estándares apoyo que enfocan aspectos más especializados soa. existe gran número estándares soporte porque tienen intención soportar soa diferentes tipos aplicación empresarial. algunos ejemplos estos estándares incluyen los siguientes: . -reliable messaging (mensajería confiable ), estándar para intercambio mensajes que garantiza que los mensajes entregarán una vez sólo una vez. . -security (seguridad ), conjunto estándares que soportan seguridad del servicio web, incluyendo estándares que especifican definición políticas estándares seguridad que cubren uso firmas digitales. . -addressing (direccionamiento ), que define cómo debe representarse información dirección mensaje soap. . -transactions (transacciones ), que definen cómo coordinan las transac-ciones través los servicios distribuidos. los estándares servicio web son tema muy amplio aquí hay espacio para estudiarlos detalle. para conocer panorama dichos estándares, recomienda libro erl (; ). sus descripciones detalladas están disponibles también como documentos públicos web. los actuales estándares servicios web les critica como estándares “pesados”, que son muy generales ineficientes. implementación tales estándares requiere una considerable cantidad procesamiento para crear, transmitir interpretar los mensajes xml asociados. por esta razón, algunas organizaciones, tales como amazon, utilizan enfoque más simple eficiente para atender comunicación utilizando los llamados servicios restful (richardson ruby, ). enfoque restful soporta interacción servicio eficiente, pero soporta características nivel empresa como transporte (http, https, smtp, …)mensajería (soap)definición servicio (uddi, wsdl)proceso (-bpel)soporte [-security, -addressing, ...)tecnologías xml (xml, xsd, xslt, ...) figura . estándares servicio web -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios -reliability (fiabilidad ) -transactions. pautasso sus colaboradores () comparan enfoque restful con los servicios web estandarizados. construir aplicaciones con base servicios permite las compañías otras organi-zaciones cooperar usar manera mutua las funciones empresariales. por tanto, los sistemas que implican amplio intercambio información través las fronteras una compañía, tales como los sistemas cadena abastecimiento los que una compañía solicita los bienes otra, pueden automatizarse fácilmente. las aplicacio-nes basadas servicios pueden construirse vincular los servicios varios provee-dores con uso lenguaje programación estándar lenguaje flujo trabajo especializado, como examina sección .. las soa son arquitecturas acopladas holgadas, las que los enlaces servicio pueden cambiar durante ejecución. esto significa que una versión distinta del servi-cio, pero equivalente, puede ejecutarse diferentes momentos. algunos sistemas cons-truirán exclusivamente utilizando servicios web otros combinarán servicios web con componentes desarrollados localmente. para ejemplificar cómo pueden organizarse las aplicaciones que usan una mezcla servicios componentes, considere siguiente escenario: sistema información bordo automóvil ofrece conductor datos sobre clima, las condiciones del tránsito, información local así sucesiva-mente. sistema vincula radio del automóvil, modo que informa-ción entrega como una señal canal radio específico. automóvil está equipado con receptor gps para detectar posición , con base dicha posición, sistema accede una gama servicios información. entonces información puede entregarse lenguaje específico del conductor. figura . ilustra una posible organización tal sistema. software bordo automóvil incluye cinco módulos. éstos manejan las comunicaciones con conduc-tor, con receptor gps que reporta posición del auto con radio del automóvil. los módulos transmisor receptor manejan todas las comunicaciones con los servicios externos.servicios web restful rest (acrónimo representational state transfer, decir, transferencia estado representacional) estilo arquitectónico basado transferencia representaciones recursos servidor cliente. estilo que subyace web como todo usado como método mucho más simple que soap/wsdl para implementar servicios web. servicio web restful identifica mediante uri (identificador universal recurso) comunica través del protocolo html. responde métodos html como get, put, post delete regresa una representación recurso cliente. manera sencilla, post significa crear; get, leer; put, actualizar delete, borrar. los servicios restful implican una carga más baja que los llamados “grandes servicios web” los utilizan muchas organizaciones que implementan sistemas basados servicios que dependen servicios ofrecidos manera externa. http:// -.indd -.indd // :: // :: pmcapítulo ■ arquitectura orientada servicios automóvil comunica con servicio información móvil externo que agrega información muchos otros servicios, proporciona información acerca del clima, las condiciones del tránsito servicios públicos locales. diferentes proveedores diversos lugares ofrecen tales servicios, sistema bordo usa servicio descu-brimiento para localizar los servicios información adecuados los enlaza. servi-cio información móvil también utiliza servicio descubrimiento para conectar los servicios adecuados clima, tránsito servicios públicos. los servicios intercam-bian mensajes soap que incluyen información posición gps usada por los servi-cios para seleccionar información adecuada. entonces información añadida envía automóvil mediante servicio que traduce dicha información lenguaje preferido del conductor. este ejemplo ilustra una las ventajas clave del enfoque orientado servicios. necesario decidir cuándo programa despliega sistema, qué proveedor servi-cio debe elegir qué servicios específicos debe ingresar. conforme vehículo avanza, software bordo usa servicio descubrimiento servicios para encontrar servicio información más adecuado enlazarlo con . gracias uso servicio traducción, posible cruzar fronteras , por consiguiente, poner disposición infor-mación local para las personas que hablan idioma. enfoque orientado servicios para ingeniería software nuevo para-digma ingeniería software que, desde perspectiva del autor, desarrollo figura . sistema información bordo automóvil basado serviciossistema software bordo vehículoinf. servicios públicosinf. del clima traductor comando gps coord.inf. idiomaflujo inf.inf. del tránsito carretero localizador inf. del tránsito servicio inf. móvil coteja informacióndescubrimiento servicio encuentra servicios disponibles localizador ubica posicióndel autointerfaz usuario recibe peticiónde usuarioreceptor recibe flujode información deserviciostransmisor envía posicióne informaciónsolicitada servicios radio traduce flujode inf. digitala señal radiogps coordgps coord gps coord -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios tan importante como ingeniería software orientada objetos. este cambio para- digma acelerará mediante desarrollo “computación nube” (carr, ), que los servicios ofrecen una infraestructura computación utilitaria instalada por los grandes proveedores, como google amazon. esto tenido, seguirá teniendo, pro-fundos efectos sobre los productos sistemas los procesos empresariales. newcomer lomow (), libro acerca soa, resumen potencial los enfoques orien-tados servicios: impulsada por convergencia tecnologías clave adopción universal servicios web, empresa orientada servicios promete mejorar significativa-mente agilidad corporativa, acelerar tiempo llegada mercado para los nuevos productos servicios, reducir los costos mejorar eficiencia operativa. aún está una etapa relativamente temprana cuanto desarrollo aplica-ciones orientadas servicios las que accede través web. sin embargo, vislumbran grandes cambios las formas que implementa despliega soft-ware, con surgimiento sistemas como google apps salesforce.com. los enfoques orientados servicios tanto nivel aplicaciones como implementación, signi-fican que web evoluciona desde almacén información hacia una plataforma implementación sistemas. . servicios como componentes reutilización capítulo introdujo ingeniería software basada componentes (cbse), que los sistemas software construyen combinar componentes software que basan modelo componentes estándar. los servicios son desarrollo natural los componentes software donde modelo componentes , esencia, conjunto estándares asociados con servicios web. por tanto, servicio puede definirse como: componente software reutilización, debidamente ajustado, que ofrece discreta funcionalidad, cual puede distribuirse que accede manera programática. servicio web servicio que accede mediante protoco-los estándar internet basados xml.ingeniería software orientada servicios orientada componentes evidentemente, los servicios componentes tienen mucho común. ambos son elementos reutilización , como estudió capítulo , posible considerar componente como proveedor servicios. sin embargo, existen importantes diferencias entre servicios componentes, entre enfoque ingeniería software orientada servicios una orientada componentes. http:// -.indd -.indd // :: // :: . ■ servicios como componentes reutilización una distinción fundamental entre servicio componente software, como define cbse, que los servicios deben ser independientes ajustarse debidamente; esto , siempre deben operar misma forma, sin importar entorno ejecución. sus interfaces son una interfaz “proporciona” que permite acceso funcionalidad del servicio. los servicios tienen intención ser independientes utilizables diferen-tes contextos. por consiguiente, tienen una interfaz “requiere” que, cbse, define los otros componentes del sistema que deben estar presentes. los servicios comunican mediante intercambio mensajes, expresados xml, dichos mensajes distribuyen con protocolos estándar transporte internet como http tcp/. sección .. estudió este enfoque basado mensajes comunicación componentes. servicio define que necesita otro servicio establecer sus requerimientos mensaje enviarlo dicho servicio. servicio receptor analiza los mensajes, realiza cálculo , concluir, envía una respuesta, como mensaje, servicio solicitante. entonces este servicio examina respuesta para extraer información requerida. diferencia los componentes software, los servicios usan solicitudes procedimiento método remotos para acceder funcionalidad asociada con otros servicios. cuando usted trata usar servicio web, debe saber dónde ubica servicio ( uri) los detalles interfaz. éstos detallan una descripción servicio expre-sada lenguaje basado xml llamado wsdl. especificación wsdl define tres cosas acerca servicio web: qué hace servicio, cómo comunica dónde encontrarlo: . parte “qué” documento wsdl, llamada interfaz, especifica qué operacio- nes soporta servicio, define formato los mensajes que envían reciben por parte del servicio. . parte “cómo” documento wsdl, llamado enlace, mapea interfaz abs-tracta conjunto concreto protocolos. enlace especifica los detalles técni-cos cómo comunicarse con servicio web. . parte “dónde” documento wsdl describe ubicación una implemen-tación servicio web específica ( punto final). modelo conceptual wsdl (figura .) muestra los elementos una descripción servicio. cada uno ellos expresa xml puede proporcionarse archivos separados. dichas partes son: . una parte introductoria que define por general los espacios nombre (names- paces) xml utilizados cuáles puede incluir una sección documentación que brinde información adicional sobre servicio. . una descripción opcional los tipos que usan los mensajes intercambiados por servicio. . una descripción interfaz servicio; esto , las operaciones que ofrece servicio para otros servicios usuarios. . una descripción los mensajes entrada salida procesados por servicio. -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios . una descripción los enlaces usados por servicio ( decir, protocolo men- sajería que utilizará para enviar recibir mensajes). por defecto, soap, pero también pueden especificarse otros enlaces. enlace establece cómo los mensajes entrada salida asociados con servicio deben empaquetarse mensaje, especifica los protocolos comunicación utilizados. enlace también puede espe-cificar cómo incluye soporte información, como credenciales seguridad identificadores transacción. . una especificación punto final, que ubicación física del servicio, expresada como identificador universal recursos (uri): dirección recurso que puede acceder través internet. las descripciones completas servicio, escritas xml, son largas, detalladas tediosas leer. por general, incluyen definiciones namespaces xml, que son calificadores nombres. identificador namespace puede preceder cualquier iden-tificador usado descripción xml, que posibilita distinguir entre identificadores con mismo nombre definidos diferentes partes una descripción xml. aquí necesario comprender los detalles los namespaces para entender los ejemplos. basta con saber que dichos nombres pueden prefijarse con identificador namespace que par namespace:nombre debe ser único. las especificaciones wsdl ahora escriben pocas veces mano mayor parte información una especificación puede generarse automáticamente. necesario conocer los detalles una especificación para comprender los principios wsdl, manera que aquí enfoque está sobre descripción interfaz abstracta. ésta parte una especificación wsdl que igual interfaz “proporcionar” com-ponente software. figura . muestra parte interfaz para servicio simple que, partir una fecha lugar, especificado como una ciudad dentro país, indica temperatura máxima mínima registrada tal lugar esa fecha. mensaje entrada especifica también dichas temperaturas desplegarán grados celsius grados fahrenheit. figura ., primera parte descripción muestra aspecto del ele-mento definición tipo que usa especificación servicio. ésta define los elementos placeanddate (lugar fecha), maxmintemp (temperaturas máxima mínima) indatafault (falla datos entrada). sólo incluyó especificación placeanddate, que puede considerar como registro con tres campos: ciudad, país fecha. enfoque similar usaría para definir maxmintemp indatafault.definición del servicio wsdl declaraciones namespace xml declaraciones tipo declaraciones interfazdeclaraciones mensaje declaraciones enlacedeclaraciones punto finalintro interfaz abstracta implementación concretafigura . organización una especificación wsdl -.indd -.indd // :: // :: . ■ servicios como componentes reutilización segunda parte descripción indica cómo define interfaz servicio. este ejemplo, servicio weatherinfo tiene una sola operación, aunque hay restric-ciones sobre número operaciones que pueden definirse. operación weatherinfo tiene patrón asociado -out que significa que toma mensaje entrada genera mensaje salida. especificación wsdl . permite que algunos mensajes diferen-tes intercambien patrones, como -only (sólo entrada), -out (entrada-salida), out-only (sólo salida), -optional-out (entrada-opcional-salida), out- (salida-entrada), etcétera. entonces definen los mensajes entrada salida, que refieren las definiciones hechas anteriormente sección tipos. principal problema con wsdl que definición interfaz servicio clu información alguna acerca semántica del servicio sus características fun-cio nales, como rendimiento confiabilidad. simplemente una descripción firma del servicio ( decir, las operaciones sus parámetros). programador que planea usar define algunos los tipos usados. supone que prefijo namespace “” refiere namespace uri para esquemas xml prefijo namespace asociado con esta definición weathns <types <: schema targetnamespace = “http://.../weathns” xmlns: weathns = “http://. . ./weathns” <:element name = “placeanddate” type = “pdrec” /<:element name = “maxmintemp” type = “mmtrec” /<:element name = “indatafault” type = “errmess” / <:complextype name = “pdrec” <:sequence <:element name = “town” type = “:string”/<:element name = “country” type = “:string”/<:element name = “day” type = “:date” / </:complextype definiciones aquí maxmintype indatafault </schema </typesahora defina interfaz sus operaciones. este caso, sólo hay una sola operación para regresar temperatura máxima mínima. <interface name = “weatherinfo” <operation name = “getmaxmintemps” pattern = “wsdlns: -out” <input messagelabel = “” element = “weathns: placeanddate” /<output messagelabel = “out” element = “weathns:maxmintemp” /<outfault messagelabel = “out” element = “weathns:indatafault” / </operation</interface figura . parte una descripción wsdl para servicio web -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios servicio debe calcular qué hace realmente servicio qué significan los diferentes campos los mensajes entrada salida. rendimiento confiabilidad tienen que descubrirse mediante experimentación con servicio. nombres significativos docu-mentación ayudan comprender funcionalidad que ofrece, aun cuando todavía posible que los lectores malinterpreten servicio. . ingeniería servicio ingeniería servicio proceso desarrollo servicios para reutilización aplicaciones orientadas servicios. tiene mucho común con ingeniería com-ponentes. los ingenieros servicio deben garantizar que servicio represente una abstracción reutilización que podría ser útil diferentes sistemas. deben diseñar desarrollar funcionalidad generalmente útil asociada con dicha abstracción, garantizar que servicio robusto fiable. deben documentar servicio modo que puedan descubrir comprender los usuarios potenciales. existen tres etapas lógicas proceso ingeniería servicio, como muestra figura .. trata las siguientes: . identificación candidatos servicio, donde identifican los posibles servicios que podrían implementar definen los requerimientos del servicio. . diseño del servicio, donde diseñan las interfaces lógica servicio wsdl. . implementación despliegue del servicio, donde servicio implementa, prueba pone disposición del usuario. como estudió capítulo , desarrollo componente reutilización puede comenzar con componente existente que haya implementado usado una aplicación. mismo verdadero para los servicios: punto partida este pro-ceso será con frecuencia servicio existente componente que convertirá servi-cio. esta situación, proceso diseño implica generalizar componente existente manera que eliminen características específicas aplicación. implementación significa adaptar componente agregar interfaces servicio implementar las gene-ralizaciones requeridas. .. identificación candidatos servicio noción básica computación orientada servicios que tales servicios deben soportar procesos empresariales. puesto que toda organización tiene una gran variedad procesos, existen muchos posibles servicios que pueden implementarse. por tanto, identificación los candidatos servicio implica comprender analizar los procesos empresariales organización para decidir cuáles servicios reutilización podrían implementarse para soportar dichos procesos. -.indd -.indd // :: // :: . ■ ingeniería servicio erl señala que existen tres tipos fundamentales servicios que pueden identificarse: . servicios utilitarios trata servicios que implementan alguna funcionalidad general que pueden usar diferentes procesos empresariales. ejemplo servicio utilitario servicio conversión divisas que puede accederse para calcu-lar conversión una divisa (por ejemplo, dólares) otra (por ejemplo, euros). . servicios empresariales trata servicios asociados con una función empresa-rial específica. ejemplo una función empresarial una universidad sería inscripción estudiantes para curso. . servicios coordinación proceso trata servicios que soportan proceso empresarial más general que por general implican diferentes actores activida-des. ejemplo servicio coordinación una compañía servicio pedidos que permite colocación pedidos con proveedores, bienes aceptados pagos realizados. erl también plantea que los servicios pueden considerarse como orientados tareas orientados entidades. los servicios orientados tareas son aquellos asociados con alguna actividad, mientras que los servicios orientados entidades son como objetos. asocian con una entidad empresarial, como, por ejemplo, formato solicitud empleo. figura . muestra algunos ejemplos servicios orientados tareas entidades. los servicios utilitarios empresariales pueden orientarse entidades tareas, pero los servicios coordinación siempre son orientados tareas. meta identificación candidatos servicio debe ser identificar los servi-cios que sean lógicamente coherentes, independientes reutilización. clasificación erl útil este aspecto, pues sugiere cómo descubrir servicios reutilización observar entidades actividades empresariales. sin embargo, identificar los candidatos servicio ocasiones difícil, pues debe vislumbrar cómo usarán los servicios. debe pensar los posibles candidatos luego plantear una serie preguntas acerca ellos para ver probable que los servicios sean útiles. las posibles preguntas que pueden plantear para identificar servicios reutilización potencial son: . para servicio orientado entidades, ¿ servicio está asociado con una sola enti- dad lógica que usa diferentes procesos empresariales? ¿qué operaciones que deban soportarse realizan usualmente sobre dicha entidad?diseño del servicioidentificación candidato servicioimplementación despliegue del servicio requerimientos del servicioespecificación interfaz del servicioservicio validado implementadofigura . proceso ingeniería servicio -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios . para servicio orientado tareas, ¿ trata una tarea que realizan diferentes per- sonas organización? ¿querrán aceptar inevitable estandarización que ocu-rrirá cuando brinde solo servicio soporte? . ¿ servicio independiente? ( decir, ¿ qué medida depende disponibili-dad otros servicios?). . para operación, ¿ servicio debe mantener estado? los servicios tienen estado, que significa que mantienen estado interno. requiere información estado, debe usarse una base datos esto puede limitar reutilización del sistema. general, los servicios que estado pasa servicio son más fáciles reutilizar, pues requiere enlace base datos. . ¿ servicio podrían usarlo clientes fuera organización? por ejemplo, tanto usuarios internos como externos podrían ingresar servicio orientado entidades asociado con catálogo. . ¿ probable que diferentes usuarios del servicio tengan distintos requerimientos funcionales? los tienen, entonces esto sugiere que quizá deba implementarse más una versión servicio. las respuestas tales preguntas ayudan seleccionar refinar abstracciones que pudieran implementarse como servicio. sin embargo, hay fórmulas mágicas para decidir cuáles son los mejores servicios , por tanto, identificación servicios proceso basado habilidad experiencia. resultado del proceso selección servicios conjunto servicios identifica-dos requerimientos asociados para dichos servicios. los requerimientos funcionales del servicio deben definir qué debe hacer servicio. los requerimientos funcionales deben definir los requerimientos seguridad, rendimiento disponibilidad del servicio. para ayudar entender proceso identificación implementación candidatos servicio, considere siguiente ejemplo: una compañía grande, que vende equipo cómputo, dispuso precios especia-les para configuraciones aprobadas algunos clientes. para facilitar auto-matización los pedidos, compañía desea producir servicio catálogo que permita los clientes seleccionar equipo que necesitan. diferencia catálogo consumidor, los pedidos realizan directamente través una interfaz catalogo. vez ello, los bienes solicitan mediante sistema procuración cada compañía basado web, que accede catálogo como servicio web. mayoría las compañías tienen sus propios procedimientos figura . clasificación serviciosutilitaria empresarial coordinación tarea convertidor divisaslocalizador empleoformato validación reclamocomprobación calificación crediticiaproceso reclamode gastospago proveedor externo entidad verificador estilo documento convertidor formato web xml formato gastosformato solicitud estudiantil -.indd -.indd // :: // :: . ■ ingeniería servicio presupuesto aprobación para los pedidos, deben seguir sus propios procesos cuando realice pedido. servicio catálogo ejemplo servicio orientado entidades que soporta operaciones empresariales. los siguientes son los requerimientos funcionales del servi-cio catálogo: . cada compañía usuaria debe contar con una versión específica del catálogo. éste debe incluir las configuraciones los equipos que pueden solicitar los empleados compañía cliente los precios acordados para los artículos del catálogo. . catálogo debe permitir empleado cliente descargar una versión del catálogo para consulta fuera línea. . catálogo debe permitir los usuarios comparar las especificaciones los precios hasta seis artículos del catálogo. . catálogo debe proporcionar instalaciones navegación búsqueda para los usuarios. . los usuarios del catálogo podrán descubrir fecha entrega prevista para número dado artículos específicos del catálogo. . los usuarios del catálogo podrán colocar “pedidos virtuales” donde los artículos requeridos guardarán durante horas. los pedidos virtuales deberán confir-marse mediante pedido real efectuado través sistema procuración. éste debe recibirse dentro horas después del pedido virtual. además estos requerimientos funcionales, catálogo tiene algunos requerimien-tos funcionales: . acceso servicio catálogo está restringido empleados organizaciones acreditadas. . los precios las configuraciones ofrecidos cliente deben ser confidenciales estarán disponibles para los empleados algún otro cliente. . catálogo estará disponible sin interrupción servicio gmt gmt. . servicio catálogo podrá procesar hasta solicitudes por segundo carga pico. observe que hay requerimientos funcionales relacionados con tiempo respuesta del servicio del catálogo. esto depende del tamaño del catálogo del número esperado usuarios simultáneos. puesto que éste servicio crítico términos tiempo, hay necesidad especificarlo esta etapa. .. diseño interfaces del servicio una vez seleccionados los servicios candidatos, siguiente etapa proceso ingenie-ría servicios diseñar las interfaces del servicio. esto implica definir las operaciones asociadas con servicio sus parámetros. también debe considerar cuidadosamente -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios diseño las operaciones los mensajes del servicio. meta consiste minimizar número intercambios mensajes que deben tener lugar para completar petición del servicio. usted tiene que garantizar que tanta información como sea posible pase servicio mensaje lugar usar interacciones servicio sincrónicas. también debe recordar que los servicios tienen estado que gestión del esta- aplicación específica del servicio responsabilidad del usuario del servicio, del servicio . por tanto, tendrá que transmitir esta información del estado hacia desde los servicios mensajes entrada salida. existen tres etapas diseño interfaz del servicio: . diseño interfaz lógica, donde identifican las operaciones asociadas con servicio, sus entradas salidas, así como las excepciones asociadas con dichas ope-raciones. . diseño mensajes, donde diseña estructura los mensajes que envía recibe servicio. . desarrollo wsdl, donde diseño lógico mensajes traducen una descrip-ción interfaz abstracta escrita wsdl. primera etapa, diseño interfaz lógica, comienza con los requerimientos del servicio define los nombres parámetros operación. esta etapa también deben definir las excepciones que podrían surgir cuando invoca una operación servicio. las figuras . . muestran las operaciones que implementan los requerimientos, así como las entradas, salidas excepciones para cada una las operaciones del catá-logo. esta etapa hay necesidad que las especificaciones sean minuciosas; los detalles agregan siguiente etapa del proceso diseño. definición excepciones cómo éstas comunican los usuarios del servicio son particularmente importantes. los ingenieros servicio saben cómo usarán sus figura . descripciones funcionales las operaciones del servicio catálogooperación descripción makecatalog crea una versión del catálogo ajustada cliente específico. incluye parámetro opcional para crear una versión pdf que descargue del catálogo. compare proporciona una comparación hasta seis características (por ejemplo, precio, dimensiones, rapidez procesamiento, etc.) hasta cuatro artículos del catálogo. lookup despliega todos los datos asociados con artículo específico del catálogo. search esta operación toma una expresión lógica busca catálogo acuerdo con dicha expresión. muestra una lista todos los artículos que coinciden con expresión búsqueda. checkdelivery indica fecha entrega prevista para artículo solicita ese día. makevirtualorder reserva número artículos que puede solicitar cliente brinda información del artículo para sistema procuración del cliente. -.indd -.indd // :: // :: . ■ ingeniería servicio servicios. por general, aconsejable hacer conjeturas que los usuarios del servi- cio tendrán comprensión completa especificación éste. los mensajes entrada pueden ser incorrectos, modo que habrá que definir excepciones que reporten las entradas incorrectas cliente del servicio. desarrollo componentes reutili-zación, comúnmente una buena práctica dejar todo manejo excepciones usua-rio del componente. desarrollador del servicio debe imponer visión acerca cómo deben manejarse las excepciones. una vez establecida una descripción lógica informal que debe hacer servi-cio, siguiente etapa definir estructura los mensajes entrada salida, así como los tipos utilizados dichos mensajes. xml una notación inconveniente para usar esta etapa. mejor representar los mensajes como objetos definirlos usando uml lenguaje programación, como java. entonces pueden convertirse manual automáticamente xml. figura . muestra estructura los mensajes entrada salida para operación getdelivery servicio catálogo. observe cómo agregaron detalles descripción anotar diagrama uml con restricciones. éstas definen longitud las cadenas que representan compañía artículo catálogo, especifican que número artículos debe ser mayor que cero que entrega debe ser posterior fecha actual. las notaciones también muestran cuáles códigos error asocian con cada posible falla. etapa final del proceso diseño servicio traducir diseño interfaz del servicio wsdl. como discutió sección previa, una representación wsdl amplia detallada, por tanto hace manualmente fácil cometer errores esta etapa. sin embargo, mayoría los entornos programación que soportan desarro-llo orientado servicios (por ejemplo, entorno eclipse) incluyen herramientas que pueden traducir una descripción interfaz lógica correspondiente representación wsdl.gdin cid: cadena catnum: cadenanumitems: enterosize (cid) = (catnum) = gdout catnum: cadenadelivdate: fechasize (catnum) = today gdfault errcode: enteroid compañía inválido errcode = catálogo inválido errcode = disponible errcode = ítems solicitados errcode = figura . diseño interfaz catálogo -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios .. implementación despliegue del servicio una vez identificados los servicios candidatos diseñadas sus interfaces, etapa final del proceso ingeniería servicios implementación del servicio. esta implemen-tación puede implicar programación del servicio usando lenguaje programación estándar como java #. ambos lenguajes incluyen librerías con extenso soporte para desarrollo del servicio. alternativamente, los servicios pueden desarrollarse implementar las interfaces del servicio componentes existentes , como discutió anteriormente, sistemas hereda-dos. esto significa que los activos software que probaron ser útiles pueden hacerse más disponibles. caso sistemas heredados, tal vez signifique que posible acceder funcionalidad del sistema mediante nuevas aplicaciones. también pueden desarrollar nuevos servicios definir composiciones los servicios existentes. este enfoque desarrollo servicios analiza sección .. una vez implementado servicio, tiene que probarse antes desplegarse. esto supone exploración partición las entradas del servicio (como explicó figura . definición uml los mensajes entrada salidaoperación entradas salidas excepciones makecatalog mcinid compañíabandera pdfmcouturl del catálogo para dicha compañíamcfaultid compañía inválido compare compinid compañíaatributo entrada (hasta )número catálogo (hasta )compouturl página que muestra tabla comparacióncompfaultid compañía inválidonúmero catálogo inválidoatributo desconocido lookup lookinid compañíanúmero catálogolookouturl página con información del artículolookfaultid compañía inválidonúmero catálogo inválido search searchinid compañíacadena búsquedasearchouturl página web con resultados búsquedasearchfaultid compañía inválidocadena búsqueda mal formada checkdelivery gdinid compañíanúmero catálogonúmero artículos solicitadosgdoutnúmero catálogofecha entrega esperadagdfaultid compañía inválidonúmero catálogo inválidono disponiblecero artículos solicitados placeorder poinid compañíanúmero artículos solicitadosnúmero catálogo pooutnúmero catálogonúmero artículos solicitadosfecha entrega predichaprecio unitario estimadoprecio total estimadopofaultid compañía inválidonúmero catálogo inválidocero artículos solicitados -.indd -.indd // :: // :: . ■ ingeniería servicio capítulo ), crear mensajes entrada que reflejen dichas combinaciones entrada, entonces comprobar que las salidas son las esperadas. siempre debe tratar generar excepciones durante prueba para comprobar que servicio puede hacer frente entra-das inválidas. están disponibles herramientas prueba que permiten examinar verificar los servicios, que generan pruebas partir especificación wsdl. sin embargo, éstas sólo pueden probar conformidad interfaz del servicio con wsdl. pueden poner prueba comportamiento funcional del servicio. despliegue del servicio, etapa final del proceso, implica poner disposición servicio para uso servidor web. mayoría del software servidor hace esto muy simple. sólo hay que instalar archivo que contiene servicio ejecutable direc-torio específico. entonces, automáticamente queda disponible para uso. servicio tiene intención estar disposición pública, debe proporcionar tal caso infor-mación para usuarios externos del servicio. esta información ayuda los usuarios poten-ciales externos decidir probable que servicio cubra sus necesidades pueden confiar usted, como proveedor del servicio, para entregar este último manera fiable con seguridad. información que posible incluir una descripción del servicio puede ser siguiente: . información acerca empresa, detalles contacto, etcétera. esto importante por razones confianza. los usuarios servicio deben estar seguros que comportará maliciosamente. información acerca del proveedor del servicio les permite comprobar sus acreditaciones con agencias información empresarial. . una descripción informal funcionalidad proporcionada por servicio. esto ayuda los usuarios potenciales decidir servicio que esperan. sin embargo, descripción funcional está lenguaje natural, modo que una descripción semántica sin ambigüedades sobre que hace servicio. . una descripción detallada los tipos interfaz semántica. . información suscripción que permite los usuarios registrarse mediante informa-ción sobre actualizaciones servicio. como expuso, problema general con las especificaciones del servicio que comportamiento funcional del servicio especifica manera regular informal, como una descripción lenguaje natural. las descripciones lenguaje natural son fáciles leer, pero están sujetas malas interpretaciones. para enfrentar este problema, existe una activa comunidad investigación preocupada por indagar cómo puede especificarse semántica los servicios. enfoque más prometedor especificación semántica basa una descripción sustentada ontología, que significado específico los términos una descripción define una ontología. las ontologías son una manera estandarizar las formas que usa dicha terminología definen las relaciones entre diferentes términos. emplean cada vez más para ayudar asignar semántica des-cripciones lenguaje natural. lenguaje llamado owl- desarrolló para describir ontologías servicio web (owl_services_coalition, ). .. servicios sistemas heredados los sistemas heredados son sistemas software antiguos que emplea una organiza-ción. por general, dependen tecnología obsoleta, pero todavía son esenciales para -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios empresa. tal vez sea efectivo términos costo reescribir sustituir dichos sistemas, muchas organizaciones quisieran usarlos conjunción con sistemas más modernos. uno los usos más importantes los servicios implementar envolturas (wrappers) para sistemas heredados que brinden acceso las funciones datos sistema. entonces puede acceder dichos sistemas través web integrarlos con otras aplicaciones. para ilustrar esto, imagine que una compañía grande mantiene inventario equipo una base datos asociada que sigue huella del mantenimiento las repara-ciones del equipo. esta forma, seguimiento qué peticiones mantenimiento han realizado para diferentes piezas equipo, qué mantenimiento regular está pro-gramado, cuándo realizó servicio mantenimiento, cuánto tiempo empleó éste, etcétera. este sistema heredado usó originalmente para generar listas trabajo diarias para personal mantenimiento, pero, con tiempo, agregaron nuevas ins-talaciones. éstas proporcionan datos acerca cuánto gastado mantenimiento cada pieza equipo información para ayudar costear trabajo mantenimien- realizar por contratistas externos. sistema funciona como sistema cliente-servi-dor con software cliente propósito especial que ejecuta una . ahora compañía quiere ofrecer acceso tiempo real este sistema desde termina-les portátiles utilizadas por personal mantenimiento. ellos actualizarán sistema directamente con tiempo los recursos empleados mantenimiento, consulta-rán sistema para encontrar siguiente labor mantenimiento. además, personal del centro telefónico requiere acceso sistema para registrar las peticiones manteni-miento verificar estatus. prácticamente imposible mejorar sistema para soportar dichos requerimientos, manera que compañía decide ofrecer nuevas aplicaciones para personal man-tenimiento del centro telefónico. dichas aplicaciones apoyan los sistemas here-dados, que usan como base para implementar algunos servicios. esto ilustra figura ., donde usó estereotipo uml para indicar servicio. las aplicaciones nuevas intercambian mensajes con dichos servicios para acceder funcionalidad del sistema heredado. algunos los servicios ofrecidos son los siguientes: . servicio mantenimiento esto incluye operaciones para recuperar una labor mantenimiento acuerdo con número trabajo, prioridad ubicación geo-gráfica, para subir base datos detalles del mantenimiento que realizó. soporte mantenimiento aplicación heredada“servicio” mantenimiento getjob suspendjobcompletejob“servicio” instalaciones addequipmentdeleteequipmenteditequipment“servicio” bitácora addrequestdeleterequestqueryrequests figura . servicios que proporcionan acceso sistema heredado -.indd -.indd // :: // :: . ■ desarrollo software con servicios servicio también ofrece operaciones que permiten suspender reiniciar una labor mantenimiento que inició, pero que está incompleta. . servicio instalaciones incluye operaciones para agregar borrar nuevo equipo modificar información asociada con equipo base datos. . servicio bitácora implica operaciones para agregar una nueva petición servicio, borrar peticiones mantenimiento consultar estatus peticiones atrasadas. observe que sistema heredado existente representa simplemente como solo servicio. vez ello, los servicios que desarrollan para acceder sistema heredado son coherentes soportan una sola área funcionalidad. esto reduce com-plejidad los hace más fáciles entender reutilizar otras aplicaciones. . desarrollo software con servicios desarrollo software utilizando servicios basa idea que usted combina configura servicios para crear nuevos servicios compuestos. éstos pueden integrarse con una interfaz usuario implementada navegador para crear una aplicación web, pueden usarse como componentes algún otro servicio composición. los servi-cios implicados composición pueden desarrollarse especialmente para aplicación, pueden ser servicios empresariales desarrollados dentro una compañía pueden ser servicios proveedor externo. muchas compañías ahora convierten sus aplicaciones empresariales sistemas orien-tados servicios, donde bloque constructor básico aplicación servicio vez componente. esto abre posibilidad reutilización más difundida dentro compañía. siguiente etapa será desarrollo aplicaciones interorganizacionales entre proveedores confiables, quienes intercambiarán servicios. realización final visión largo plazo soa dependerá del desarrollo “mercado servicios”, donde los servicios compran proveedores externos. composición servicios puede usarse elaboración procesos empresa-riales separados para dar proceso integrado que ofrezca funcionalidad más exten-. suponga que una aerolínea quiere ofrecer paquete vacacional completo para los viajeros. además reservar sus vuelos, los viajeros también pueden reservar hoteles destino preferido, ordenar renta automóviles reservar taxi desde aeropuerto, navegar una guía viaje hacer reservaciones para visitar lugares atractivos. para crear esta aplicación, aerolínea combina servicio reservaciones con los servicios que ofrece una agencia reservaciones hoteleras, agencias alquiler autos compa-ñías taxis, con los servicios reservación que ofrecen los propietarios los lugares interés. resultado final solo servicio que integra los servicios diferentes proveedores. este proceso puede considerar como una secuencia pasos separados como muestra figura .. información transmite paso siguiente: por ejem-plo, compañía alquiler autos está informada hora que llegará vuelo. secuencia pasos llama flujo trabajo (workflow): conjunto actividades orde-nadas tiempo, que cada actividad realiza parte del trabajo. flujo trabajo -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios modelo proceso empresarial ( decir, establece los pasos necesarios para alcan- zar una meta particular que sea importante para empresa). este caso, proceso empresarial servicio reservación vacacional que ofrece aerolínea. flujo trabajo una idea simple escenario anterior para reservar unas vaca-ciones parece ser directo. práctica, combinación servicios mucho más com-pleja que implica este modelo simple. por ejemplo, debe considerar posibilidad falla del servicio incorporar mecanismos para manejar dichas fallas. también deben tomar cuenta demandas excepcionales hechas por los usuarios aplicación. suponga que viajero tiene discapacidad requiere renta una silla ruedas entrega ésta aeropuerto. esto requeriría implementación combinación servicios adicio-nales, por que flujo trabajo agregarían otros pasos. usted debe ser capaz enfrentar estas situaciones las que flujo trabajo deba modificarse porque ejecución normal uno los servicios deriva, por general, una incompatibilidad con ejecución algún otro servicio. por ejemplo, suponga que reserva vuelo que saldrá junio regresará junio. entonces flujo trabajo procede etapa reservación hotel. sin embargo, hotel tendrá una gran convención hasta junio, modo que hay habitaciones disponibles. servicio reservaciones del hotel reporta esta falta disponibilidad. ésta una falla; falta disponibilidad una situación común. por tanto, hay que “deshacer” reservación del vuelo transmitir información acerca falta disponibilidad usuario. entonces, deberá decidir cambia sus fechas hotel. terminología flujo trabajo, esto conoce como “acción compensación”. las acciones compensación usan para deshacer acciones que completaron, pero que deben cam-biar como resultado posteriores actividades flujo trabajo. esencia, proceso diseñar nuevos servicios reutilizando los servicios existentes proceso diseño software con reutilización (figura .). diseño con reuti-lización implica inevitablemente compromisos requerimientos. deben modificarse los requerimientos “ideales” del sistema para reflejar los servicios que están realmente disponibles, cuyos costos hallan dentro del presupuesto cuya calidad servicio aceptable. figura . muestran seis etapas clave del proceso construcción servi-cio mediante composición: . formular bosquejo flujo trabajo esta etapa inicial del diseño del ser- vicio, usan los requerimientos para servicio compuesto como base para crea-ción diseño servicio “ideal”. esta etapa debe crear diseño bastante abstracto con intención agregar detalles una vez que conozca más acerca los servicios disponibles. . descubrimiento servicios durante esta etapa del proceso buscan registros catálogos servicios para descubrir cuáles servicios existen, quién los proporciona los detalles provisión del servicio.reservar vuelosreservar hotelsolicitar auto taxiver atracciones reservar atracciones llegadas/salidas fechas/horarios ubicación hotelfechas/preferenciasfigura . flujo trabajo paquete vacacional -.indd -.indd // :: // :: . ■ desarrollo software con servicios . seleccionar posibles servicios partir del conjunto posibles candidatos servi- cio que haya descubierto, seleccionan entonces los posibles servicios que puedan implementar actividades flujo trabajo. desde luego, sus criterios selección incluirán funcionalidad los servicios ofrecidos. también pueden comprender costo los servicios calidad del servicio ofrecido (respuesta, disponibilidad, etcétera). posible decidir elegir algunos servicios con funcionalidad equivalente, que pudieran vincularse con una actividad flujo trabajo, dependiendo los detalles costo calidad del servicio. . refinar flujo trabajo sobre base información acerca los servicios que seleccionó, refina flujo trabajo. esto implica añadir detalles descrip-ción abstracta , tal vez, agregar eliminar actividades flujo trabajo. entonces pueden repetir las etapas descubrimiento selección del servicio. una vez que eligió conjunto estable los servicios estableció diseño flujo trabajo final, paso siguiente etapa proceso. . crear programa flujo trabajo durante esta etapa, diseño del flujo trabajo abstracto transforma programa ejecutable define interfaz del servicio. puede usar lenguaje programación convencional, como java #, para implementación del servicio, lenguaje flujo trabajo, como -bpel. como discutió sección anterior, especificación interfaz servicio debe escribirse wsdl. esta etapa también puede implicar crea-ción interfaces usuario basadas web para permitir acceso los nuevos servicios desde navegador web. . prueba servicio aplicación terminada proceso probar servicio ter- minado compuesto más complejo que prueba componentes situaciones donde usan servicios externos. sección .. analizan los conflictos las pruebas. resto del capítulo nos ocuparemos del diseño las pruebas del flujo tra-bajo. práctica, descubrimiento servicio parece ser gran problema. pero todavía caso que mayor parte reutilización servicios dentro las organizaciones, donde pueden descubrirse los servicios usando registros internos comunicaciones informales entre ingenieros software. posible usar motores bús-queda estándar para descubrir servicios disposición pública. .. diseño implementación del flujo trabajo diseño del flujo trabajo implica analizar los procesos empresariales existentes planeados para comprender las diferentes actividades que realizan cómo éstas formular bosquejo flujo trabajo diseñar flujo trabajodescubrir servicios lista serviciosespecificaciones serviciosseleccionar servicios diseñar flujo trabajorefinar flujo trabajocrear programa flujo trabajo flujo trabajo ejecutableprobar servicio servicio implementar figura . construcción servicio mediante composición -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios intercambian información. luego, define nuevo proceso empresarial una nota- ción diseño flujo trabajo. esto establece las etapas implicadas para realizar proceso información que transmite entre las diferentes etapas del proceso. sin embargo, los procesos existentes pueden ser informales depender las habilidades capacidades las personas implicadas: quizá haya una forma “normal” trabajar una definición proceso. tales casos, usted deberá usar conocimiento del proceso actual para diseñar flujo trabajo que logre las mismas metas. los flujos trabajo constituyen modelos proceso empresarial , por general, representan usando una notación gráfica, como los diagramas actividad uml bpmn (business process modeling notation) (white, ; white miers, ). esto ofrece características similares (white, ). probable que futuro inte-gren bpmn los diagramas actividad uml, que defina estándar modelado flujo trabajo con base este lenguaje integrado. autor usa bpmn para los ejemplos este capítulo. bpmn lenguaje gráfico que razonablemente fácil entender. los mapeos definen para traducir lenguaje descripciones bajo nivel basadas xml, -bpel. por tanto, bpmn conforma con pila estándares servicio web que mostraron figura .. figura . ejemplo modelo bpmn simple parte del escenario del paquete vacacional anterior. modelo ilustra flujo trabajo simplificado para reservación hotel supone existencia servicio hotels con operaciones aso-ciadas llamadas getrequirements, checkavailability, reserverooms, noavailability, confirmreservation cancelreservation. proceso incluye obtener requerimientos del cliente, verificar disponibilidad habitación, después, hay habitaciones dispo-nibles, hacer una reservación para las fechas requeridas. este modelo introduce algunos los conceptos centrales bpmn que usan para crear modelos flujo trabajo: . las actividades representan mediante rectángulo con esquinas redondeadas. una actividad puede ejecutarse por una persona mediante servicio automatizado.hotels. getrequirements clientehotels. checkavailabilityhotels. noavailability hotels. reserverooms hotels. confirmreservationrecuperar cancelar rooms okno hay habitaciones figura . fragmento flujo trabajo reservación hotel -.indd -.indd // :: // :: . ■ desarrollo software con servicios . los eventos representan por medio círculos. evento algo que sucede durante proceso empresarial. círculo sencillo usa para representar evento inicial círculo más oscuro para evento final. círculo doble ( ilustra) usa para representar evento intermedio. los eventos pueden ser eventos reloj, que consecuencia permite que los flujos trabajo ejecuten periódicamente manera cronometrada. . diamante usa para representar una compuerta. una compuerta una etapa proceso donde hace una elección. por ejemplo, figura ., hay una elección tomada con base existen habitaciones disponibles. . una flecha sólida usa para mostrar secuencia actividades, mientras que una flecha punteada representa mensajes que fluyen entre actividades. figura . dichos mensajes transmiten entre servicio reservación hotel cliente. estas características clave son suficientes para describir esencia mayoría los flujos trabajo. sin embargo, bpmn incluye muchas características adiciona-les que aquí pueden describir por falta espacio. éstas agregan información una descripción proceso empresarial que permite traducción automática servi-cio ejecutable. por tanto, los servicios web, basados las composiciones servicio descritas bpmn, pueden generarse directamente partir modelo proceso empresarial. figura . ilustra proceso que realiza una organización, compañía que proporciona servicio reservaciones. sin embargo, beneficio clave -foque orientado servicios que soporta computación entre organizaciones. esto signi-fica que cómputo implica servicios diferentes compañías. anterior representa bpmn mediante desarrollo flujos trabajo separados para cada una las orga-nizaciones implicadas con las interacciones entre ellas. para ilustrar esto usa aquí ejemplo diferente, extraído computación alto rendimiento. propuesto enfoque orientado servicios para permitir que com-partan recursos como las computadoras. este ejemplo, suponga que una computadora procesamiento vector (una máquina que puede realizar computaciones paralelas sobre arreglos valores) ofrece como servicio ( vectorprocservice ) por parte laboratorio investigación. ella accede través otro servicio llamado setupcomputation . figura . muestran dichos servicios sus interacciones. este ejemplo, flujo trabajo para servicio setupcomputation solicita acceso procesador vectores , está disponible procesador, establece cómputo requerido descarga datos servicio procesamiento. una vez completo cómputo, los resultados almacenan computadora local. flujo traba- para vectorprocservice verifica está disponible algún procesador, asigna recursos para cómputo, inicia sistema, realiza cómputo regresa los resultados servicio cliente. términos bpmn, flujo trabajo para cada organización representa una pool separada. muestra manera gráfica encerrar rectángulo flujo trabajo para cada participante proceso, con nombre escrito verticalmente arista izquierda. los flujos trabajo definidos cada pool coordinan mediante intercambio mensajes; permite flujo secuencia entre las actividades diferentes pools. situaciones donde diferentes partes una organización están impli-cadas flujo trabajo, esto puede mostrarse mediante separación pools -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios “carriles” (lanes) nombrados. cada carril muestra las actividades dicha parte organización. una vez diseñado modelo proceso empresarial, debe redefinirse dependiendo los servicios descubiertos. como sugiere análisis figura ., modelo puede pasar por algunas iteraciones hasta que cree diseño que permita máxima reutilización posible los servicios disponibles. está disponible diseño final, debe convertirse entonces programa ejecuta-ble. esto puede implicar dos actividades: . implementar los servicios que están disponibles para reutilización. puesto que los servicios son independientes del lenguaje implementación, dichos servicios pue-den escribirse cualquier lenguaje. los entornos desarrollo java # brindan soporte para composición servicios web. . generar una versión ejecutable del modelo flujo trabajo. por general, esto implica traducir modelo -bpel, manera manual automática. aunque existen muchas herramientas disponibles para automatizar proceso bpmn--bpel, también hay algunas circunstancias donde difícil generar códi- -bpel legible desde modelo flujo trabajo. para brindar soporte directo implementación las composiciones servicios web, han desarrollado muchos estándares servicio web. como explicó introducción del capítulo, lenguaje estándar basado xml -bpel (business process execution language, esto , lenguaje ejecución proceso empresarial), que “lenguaje programación” para controlar interacciones entre servicios. éste solicitar procesadorestablecer parámetros tareadescarga datosiniciar cómputo almacenar resultadosreportar conclusiónreiniciar fallasetup computation verificar disponibilidadasignar recursosiniciar computar regresar resultadosokno hay procesador okvectorprocservice figura . flujos trabajo interacción -.indd -.indd // :: // :: . ■ desarrollo software con servicios recibe apoyo estándares adicionales como -coordination (cabrera ., ), que usa para especificar cómo coordinan los servicios -cdl (choreography description language, decir, lenguaje descripción coreografía) (kavantzas ., ), que medio para definir los intercambios mensaje entre participan-tes (andrews ., ). .. pruebas del servicio las pruebas son importantes todos los procesos desarrollo sistemas, pues demuestran que sistema cumple con sus requerimientos funcionales funciona-les, detectan defectos introducidos durante proceso desarrollo. muchas técnicas prueba, como las inspecciones del programa las pruebas cobertura, dependen del análisis del código fuente del software. sin embargo, cuando proveedor externo ofrece sus servicios, está disponible código fuente implementación del servicio. por tanto, las pruebas del sistema basado servicios pueden usar técnicas probadas basadas código fuente. además los problemas comprender implementación del servicio, los exami-nadores pueden enfrentar también más dificultades cuando prueban los servicios combinación servicios: . los servicios externos están bajo control del proveedor del servicio del usua- rio del servicio. proveedor del servicio puede retirar dichos servicios cualquier momento puede modificarlos, que invalida cualquier prueba previa apli-cación. dichos problemas manejan los componentes software mantener diferentes versiones del componente. sin embargo, actualidad, hay estánda-res propuestos para lidiar con las versiones del servicio. . visión largo plazo soa para que los servicios vinculen manera dinámica aplicaciones orientadas servicios. esto significa que una aplicación siempre puede usar mismo servicio cada vez que ejecuta. consecuencia, las pruebas pueden ser exitosas cuando una aplicación enlaza servicio particular, pero puede garantizar que dicho servicio usará durante una ejecución real del sistema. . comportamiento funcional servicio depende simplemente cómo usa por parte aplicación que pone prueba. servicio puede desempeñarse bien durante las pruebas porque opera bajo una carga pesada. práctica, comportamiento servicio observado podría ser diferente debido las demandas hechas por otros usuarios del servicio. . modelo pago para servicios podría hacer que las pruebas del servicio sean muy costosas. existen diferentes modelos pago posibles: algunos servicios pueden estar disposición gratuita, por algunos hay que pagar una suscripción, otros pagan sobre una base “por uso”. los servicios son gratuitos, entonces proveedor del servicio querrá que carguen aplicaciones sujetas prueba; requiere una suscripción, entonces tal vez usuario del servicio podría estar renuente comprometerse acuerdo suscripción antes probar servicio. igual modo, servicio basa pago con base uso, los usuarios del servicio pueden descubrir que costo las pruebas resulta prohibitivo. -.indd -.indd // :: // :: . discutió noción acciones compensación que invocan cuando ocu- rre una excepción los compromisos previos realizados (como una reservación vuelo) deben revocarse. existe problema poner prueba tales acciones, pues dependen falla otros servicios. asegurar que estos servicios realmente fallan durante proceso pruebas puede ser muy difícil. dichos problemas son particularmente agudos cuando usan servicios externos. son menos serios cuando los servicios emplean dentro misma compañía cuando compañías cooperativas confían los servicios ofrecidos por sus socios. tales casos, puede estar disponible código fuente para guiar proceso pruebas, improbable que sea problema pago por servicios. resolución estos problemas pruebas elaboración lineamientos, herramientas técnicas para probar las aplicaciones orientadas servicios siguen siendo importante tema investigación. puntos clave ■ arquitectura orientada servicios enfoque ingeniería software donde servicios estandarizados reutilización son los bloques constructores básicos para los sistemas aplicación. ■ las interfaces servicio pueden definirse lenguaje que base xml llamado wsdl. una especificación wsdl incluye una definición los tipos interfaz operaciones, protocolo enlace que usa servicio ubicación del servicio. ■ los servicios pueden clasificarse como utilitarios que ofrecen una funcionalidad propósito general, empresariales que implementan parte proceso empresarial, coordinación que regulan ejecución otros servicios. ■ proceso ingeniería servicio implica identificación servicios candidatos para implementación, definición interfaz del servicio, implementación, prueba despliegue del servicio. ■ pueden definirse interfaces servicio para sistemas software heredado que siguen siendo útiles para una organización. entonces funcionalidad los sistemas heredados puede reutilizarse otras aplicaciones. ■ desarrollo software usando servicios basa idea que los programas crean combinar configurar servicios para desarrollar nuevos servicios compuestos. ■ los modelos proceso empresarial definen las actividades intercambio información que tienen lugar proceso empresarial. las actividades proceso empresarial pueden implementarse mediante servicios, manera que modelo proceso empresarial representa una composición servicios. lecturas sugeridas existe muchísimo material tutoriales web que cubre todos los aspectos los servicios web. sin embargo, los siguientes dos libros thomas erl ofrecen las mejores perspectivas descripciones los servicios los estándares servicio. diferencia mayoría los libros, capítulo ■ arquitectura orientada servicios -.indd -.indd // :: // :: pmcapítulo ■ ejercicios erl incluye cierta discusión los conflictos ingeniería software computación orientada servicios. también escrito libros más especializados acerca del diseño servicios patrones diseño soa, aunque por general dirigen lectores con experiencia implementación soa. service-oriented architecture: field guide integrating xml and web services . enfoque principal este libro radica las tecnologías subyacentes basadas xml (soap, wsdl, bpel, etcétera), que son marco referencia para soa. (. erl, prentice hall, .) service-oriented architecture: concepts, technology and design . trata libro más general acerca ingeniería sistemas orientados servicios. hay poco traslape con texto anterior, pero erl concentra principalmente explicar cómo puede usarse enfoque orientado servicios todas las etapas del proceso software. (. erl, prentice hall, .) “soa realization: service design principles”. este breve artículo web excelente panorama los conflictos considerar diseño servicios. (. . . artus, ibm, .) http:/ /www. ibm. com/ developerworks/ webservices/ library/ -soa-design/. ejercicios .. ¿cuáles son las distinciones más importantes entre servicios componentes software? .. explique por qué las soa deben basarse estándares. .. con misma notación, extienda figura . para incluir definiciones para maxmintype indatafault. las temperaturas deben representarse como enteros con campo adicional que indique temperatura está grados fahrenheit grados celsius. indatafault debe ser tipo sencillo que consta código error. .. defina una especificación interfaz para los servicios convertidor divisas comprobación calificación crediticia que muestran figura .. .. diseñe posibles mensajes entrada salida para los servicios que muestran figura .. puede especificarlos uml xml. .. fundamentando con razones respuesta, sugiera dos tipos aplicación importantes donde recomendaría uso arquitectura orientada servicios. .. sección .. introdujo ejemplo una compañía que desarrolló servicio catálogo que usan los sistemas procuración basados web los clientes. con bpmn, diseñe flujo trabajo que use este servicio catálogo para buscar realizar pedidos para equipo cómputo. .. explique qué entiende por “acción compensación” , con ejemplo, demuestre por qué estas acciones deben incluirse los flujos trabajo. .. para ejemplo del servicio reservación paquete vacacional, diseñe flujo trabajo que reservará transporte terrestre para grupo pasajeros que llegan aeropuerto. debe ofrecer opción reservar taxi rentar auto. puede suponer que las compañías taxis alquiler autos ofrecen servicios web para hacer una reservación. .. con ejemplo, explique con detalle por qué son difíciles las pruebas extensas los servicios que incluyen acciones compensación. -.indd -.indd // :: // :: capítulo ■ arquitectura orientada servicios referencias andrews, ., curbera, ., goland, ., klein, . ., . (). “business process execution language for web services”. http://www-.ibm.com/developerworks/library/-bpel/. cabrera, . ., copeland, . ., . . “web services coordination (-coordination)”. ftp:// carr, . (). the big switch: rewiring the world from edison google, reprint edition. nueva york: .. norton & .erl, . (). service-oriented architecture: field guide integrating xml and web services . upper saddle river, : prentice hall.erl, . (). service-oriented architecture: concepts, technology and design . upper saddle river, : prentice hall.kavantzas, ., burdett, . ritzinger, . . “web services choreography description language version .”. http:// lovelock, ., vandermerwe, . lewis, . (). services marketing. englewood cliffs, : prentice hall. newcomer, . lomow, . (). understanding soa with web services. boston: addison-wesley.owl_services_coalition. . “owl-: semantic markup for web services”. http:// pautasso, ., zimmermann, . leymann, . (). “restful web services ‘big’ web services: making the right architectural decision”. proc. www , beijing, china: –. richardson, . ruby, . (). restful web services. sebastopol, calif.: ’reilly media inc.turner, ., budgen, . brereton, . (). “turning software into service”. ieee computer, (), –.white, . . (). “ introduction bpmn”. http:// white, . . (). “process modelling notations and workflow patterns”. workflow handbook . fischer, . (.). lighthouse point, fla.: future strategies inc. –.white, . . miers, . (). bpmn modeling and reference guide: understanding and using bpmn. lighthouse point, fla.: future strategies inc. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo algunas las características los sistemas embebidos tiempo real ingeniería software tiempo real. estudiar este capítulo: ■ comprenderá concepto software embebido, que usa para controlar sistemas que deben reaccionar frente eventos externos entorno; ■ introducirá proceso diseño para sistemas tiempo real, que los sistemas software organizan como conjunto procesos cooperativos; ■ conocerá tres patrones arquitectónicos utilizados comúnmente diseño sistemas embebidos tiempo real; ■ entenderá organización los sistemas operativos tiempo real papel que éstos desempeñan sistema embebido tiempo real. contenido . diseño sistemas embebidos . patrones arquitectónicos . análisis temporización . sistemas operativos tiempo real software embebido -.indd -.indd // :: // :: capítulo ■ software embebido las computadoras utilizan para controlar una amplia gama sistemas, desde máqui- nas domésticas simples controladores juego, hasta total las plantas manufac-tureras. estas computadoras interactúan directamente con dispositivos hardware. software debe reaccionar eventos generados por hardware emitir menudo señales control respuesta tales eventos. estas señales dan por resultado una acción, como inicio una llamada telefónica, movimiento carácter pantalla, aper-tura una válvula despliegue del estatus del sistema. software dichos sistemas está embebido hardware del sistema, con frecuencia memoria sólo lectura, por general responde, tiempo real, eventos del entorno del sistema. por tiempo real entiende que sistema software tiene plazo para responder los eventos externos. éste cumple, entonces sistema hardware-software global funcio-nará correctamente. software embebido muy importante desde punto vista económico, porque ahora casi todos los dispositivos eléctricos incluyen software. por consiguiente, existen muchos más sistemas software embebido que otros tipos. quizás usted tenga casa tres cuatro computadoras personales, pero probable que cuente también con sistemas embebidos, como sistemas teléfonos, hornos microondas, etcétera. respuesta tiempo real diferencia crítica entre los sistemas embebidos otros sistemas software, tales como los sistemas información, los basados web los software personal, cuyo propósito fundamental procesamiento datos. para sistemas que son tiempo real, corrección sistema puede defi-nir especificar cómo las entradas del sistema mapean las salidas correspondientes que debe producir sistema. respuesta una entrada, sistema debe generar una salida correspondiente , muchas veces, deben almacenarse algunos datos. por ejemplo, elige comando create sistema información pacientes, entonces res-puesta correcta del sistema crear una base datos nuevo registro del paciente, confirmar que hecho; dentro límites razonables, importa cuánto tarde. sin embargo, sistema tiempo real, corrección depende tanto res-puesta una entrada como del tiempo que tarda generar dicha respuesta. sistema aplaza mucho respuesta, entonces respuesta requerida puede resultar ineficaz. por ejemplo, software embebido que controla sistema frenado automóvil muy lento, puede ocurrir accidente ser imposible detener tiempo vehículo. por consiguiente, tiempo inseparable definición sistema software tiempo real: sistema software tiempo real sistema cuya correcta operación depende tanto los resultados producidos por sistema como del tiempo que producen dichos resultados. “sistema blando tiempo real” sistema cuya operación degrada los resultados producen acuerdo con los requerimientos tiempo especificados. los resultados producen según especificación tiempo “sistema duro tiempo real”, considera una falla del sistema. respuesta oportuna factor importante todos los sistemas embebidos, aun-que todos estos sistemas requieren una respuesta muy rápida. por ejemplo, software bomba insulina que usó como modelo varios capítulos este libro sistema embebido. obstante, aun cuando requiere verificar nivel glucosa inter-valos periódicos, precisa responder muy rápidamente eventos externos. software -.indd -.indd // :: // :: pmcapítulo ■ software embebido estación meteorológica campo abierto también sistema embebido, aunque, nuevo, requiere una respuesta rápida eventos externos. además necesidad respuesta tiempo real, existen entre los sistemas embe-bidos otras diferencias importantes otros tipos sistema software: . los sistemas embebidos por general operan manera continua, decir, ope- ración tiene fin. comienzan cuando hardware activa deben ejecutarse hasta que hardware desactiva. esto significa que también pueden usarse técni-cas para ingeniería software fiable, como explicó capítulo , para garan-tizar operación continua. sistema tiempo real puede incluir mecanismos actualización que soporten reconfiguración dinámica, forma que sistema pueda actualizarse mientras encuentra servicio. . las interacciones con entorno del sistema son incontrolables impredecibles. sistemas interactivos ritmo interacción controla mediante sistema , limitar las opciones del usuario, los eventos procesar conocen por adelantado. contraste, los sistemas embebidos tiempo real deben responder cualquier momento sucesos inesperados. esto conduce diseño sistemas tiempo real basado concurrencia, con algunos procesos que ejecutan paralelo. . puede haber limitaciones físicas que afecten diseño sistema. ejemplos esto incluyen las limitaciones energía disponible sistema espacio físico que ocupa hardware. dichas limitaciones pueden generar requerimientos para software embebido, tal como necesidad conservar energía así prolongar vida batería. las limitaciones tamaño peso pueden significar que soft-ware debe hacerse cargo algunas funciones hardware debido necesidad restringir número chips usados sistema. . tal vez requiera interacción directa con hardware. los sistemas interactivos los sistemas información, hay una capa software (los controladores del dispositivo) que ocultan hardware del sistema operativo. esto posible porque sólo puede conectar ciertos tipos dispositivos dichos sistemas, tales como teclados, ratones, pantallas, etcétera. contraste, los sistemas embebidos deben interactuar con una amplia gama dispositivos hardware que tienen contro-ladores dispositivos separados. . los conflictos protección fiabilidad pueden dominar diseño del sistema. muchos sistemas embebidos controlan dispositivos cuyas fallas pueden tener altos costos humanos económicos. por tanto, confiabilidad crítica diseño del sistema debe garantizar comportamiento crítico para protección todo momento. con frecuencia, esto conduce diseño enfoque conservador, que usan técnicas probada eficacia vez técnicas más recientes que pueden introducir nuevos modos falla. los sistemas embebidos pueden considerarse como sistemas reactivos; esto , deben reaccionar ante los eventos velocidad ese entorno (berry, ; lee, ). menudo, los tiempos respuesta rigen por las leyes física vez ser elegidos por conveniencia humana. esto está contraste con otros tipos software que sistema controla velocidad interacción. por ejemplo, procesador texto, -.indd -.indd // :: // :: capítulo ■ software embebido usado para escribir presente libro, puede comprobar ortografía gramática, hay límites prácticos tiempo que tarda ello. . diseño sistemas embebidos proceso diseño para sistemas embebidos proceso ingeniería sistemas que los diseñadores software deben considerar detalle diseño rendimiento del hardware del sistema. parte del proceso diseño del sistema puede comprender decisión cuáles capacidades del sistema han implementarse software cuáles hardware. para numerosos sistemas tiempo real embebidos productos consu-midor, como los sistemas los teléfonos celulares, los costos consumo energía del hardware son críticos. para soportar sistemas embebidos pueden usarse procesadores específicos, algunos sistemas tal vez deba diseñarse construirse hardware pro-pósito especial. ello significa que, mayoría los sistemas tiempo real, poco práctico proceso diseño software descendente, que diseño comience con modelo abstracto que descomponga desarrolle una serie etapas. las decisiones bajo nivel hardware, software soporte temporización (timing) del sistema deben considerarse inicio del proceso. esto limita flexibilidad los diseñadores del sis-tema puede significar que funcionalidad software adicional, como batería administración energía, deba incluirse sistema. puesto que los sistemas embebidos son sistemas reactivos que reaccionan los even-tos entorno, enfoque más general diseño software embebido tiempo real basa modelo estímulo-respuesta. estímulo evento que ocurre entorno sistemas software que hace que sistema reaccione alguna forma; una respuesta una señal mensaje que envía software entorno. posible definir comportamiento sistema tiempo real elaborar una lis- los estímulos recibidos por sistema, las respuestas asociadas momento cuando debe producirse respuesta. por ejemplo, figura . muestra posibles estímulos respuestas sistema para sistema alarma contra robo. sección .. encuentra más información sobre este sistema. los estímulos presentan dos clases: . estímulos periódicos ocurren intervalos predecibles. por ejemplo, sistema puede examinar sensor cada milisegundos actuar (responder) partir del valor dicho sensor ( estímulo). . estímulos periódicos ocurren manera irregular impredecible, por general señalan mediante mecanismo interrupción computadora. ejemplo tal estímulo sería una interrupción que indique que completó una transferencia / que había datos disponibles buffer. los estímulos provienen sensores entorno del sistema, las respuestas envían actuadores, como muestra figura .. lineamiento diseño general -.indd -.indd // :: // :: . ■ diseño sistemas embebidos para los sistemas tiempo real tener dos procesos independientes para cada tipo sensor actuador (figura .). dichos actuadores controlan equipo, tal como una bomba, que hace entonces cambios entorno del sistema. los mismos actuadores tam-bién pueden generar estímulos. los estímulos los actuadores indican con frecuencia que ocurrió algún problema, cual debe manejar sistema. para cada tipo sensor puede haber proceso gestión sensor que maneje recolección datos los sensores. los procesamientos datos calculan las res-puestas requeridas para los estímulos recibidos por sistema. los procesos control figura . estímulos respuestas para sistema alarma contra robo sistema control tiempo real actuador actuador actuador actuadorsensor sensor sensor sensor sensor sensor estímulos respuestas figura . modelo general sistema embebido tiempo realestímulos respuesta sensor individual positivo iniciar alarma; encender luces alrededor del sitio del sensor positivo. dos más sensores positivos iniciar alarma; encender luces alrededor los sitios los sensores positivos; llamar policía con ubicación entrada forzada del sospechoso. caída voltaje entre % cambiar batería respaldo; efectuar prueba suministro energía. caída voltaje más del % cambiar batería respaldo; iniciar alarma; llamar policía; efectuar prueba suministro energía. falla suministro energía llamar servicio técnico. falla sensor llamar servicio técnico. consola botón pánico positivo iniciar alarma; encender luces alrededor consola; llamar policía. inicializar valores alarma apagar todas las alarmas activas; apagar todas las luces que hayan encendido. -.indd -.indd // :: // :: capítulo ■ software embebido del actuador asocian con cada actuador gestionan operación ese actuador. este modelo permite rápida recopilación datos desde sensor (antes que sobrescriba entrada siguiente) hace posible que después realicen procesamiento res-puesta asociada del actuador. sistema tiempo real debe responder estímulos que ocurren diferentes momentos. por tanto, debe organizar arquitectura del sistema para que, tan pronto como reciba estímulo, control transfiera manejador correcto. esto poco práctico programas secuenciales. por consiguiente, los sistemas software tiempo real diseñan por general como conjunto procesos cooperativos concurrentes. para apoyar gestión dichos procesos, plataforma ejecución que efectúa sistema tiempo real puede incluir sistema operativo tiempo real (que explica sección .). accede las funciones proporcionadas por este sistema operativo través del sistema soporte tiempo ejecución para lenguaje programación tiempo real utilizado. existe proceso diseño del sistema embebido estándar. vez ello, usan diferentes procesos que dependen del tipo sistema, hardware disponible organización que desarrolle sistema. las siguientes actividades pueden incluirse proceso diseño software tiempo real: . selección plataforma esta actividad elige una plataforma ejecución para sistema ( decir, hardware sistema operativo tiempo real utili-zar). los factores que influyen dichas elecciones comprenden restricciones tem-porización sobre sistema, limitaciones energía disponible, experiencia del equipo desarrollo precio tope para sistema entregado. . identificación estímulos/respuestas esto implica identificar los estímulos que debe procesar sistema respuesta respuestas asociadas para cada estímulo. . análisis temporización para cada estímulo respuesta asociada identifican las restricciones temporización que aplican tanto estímulo como pro-cesamiento respuesta. usan para establecer los plazos los procesos del sistema. . diseño procesos esta etapa agrega estímulo procesamiento respuesta algunos procesos concurrentes. buen punto partida para diseñar arquitectura del proceso constituyen los patrones arquitectónicos descritos sección .. posteriormente, optimiza arquitectura del proceso para reflejar los requerimientos específicos que deben implementarse. . diseño algoritmo para cada estímulo respuesta diseñan algoritmos que rea-lizan los cálculos requeridos. tal vez deban desarrollar los diseños algoritmo procesador datoscontrol actuadoractuador control sensorsensor estímulo respuesta figura . procesos sensor actuador -.indd -.indd // :: // :: . ■ diseño sistemas embebidos etapas relativamente tempranas del proceso diseño, para dar indicio cantidad procesamiento requerido del tiempo necesario para completar dicho procesamiento. esto especialmente importante para tareas cómputo intenso, como procesamiento señales. . diseño datos especifica información que intercambian los procesos eventos que coordinan intercambio información, diseñan las estructuras datos para administrar este intercambio información. varios procesos concurren-tes pueden compartir estas estructuras datos. . planeación del proceso diseña sistema planeación que garantice que los procesos iniciarán tiempo para cumplir sus plazos. orden dichas actividades proceso diseño software tiempo real depende del tipo sistema desarrollar, así como sus requerimientos proceso plataforma. algunos casos podrá seguir enfoque bastante abstracto, que comience con los estímulos procesamiento asociado, decidir final del proceso sobre las plataformas hardware ejecución. otros casos, elección del hard-ware del sistema operativo efectúa antes comenzar diseño del software. ante tal situación, debe diseñar software para considerar las restricciones impuestas por las capacidades del hardware. los procesos sistema tiempo real deben coordinarse compartir informa-ción. los mecanismos coordinación proceso garantizan exclusión mutua para los recursos compartidos. cuando proceso modifica recurso compartido, otros procesos podrán cambiar dicho recurso. los mecanismos para probar exclusión mutua incluyen semáforos (dijkstra, ), monitores (hoare, ) regiones críti-cas (brinch-hansen, ). estos mecanismos sincronización proceso descri-ben mayoría los textos acerca sistemas operativos (silberschatz ., ; tanenbaum, ). diseñar intercambio información entre procesos, debe considerar hecho que tales procesos pueden ejecutarse diferentes velocidades. proceso genera información; otro proceso consume esa información. productor ejecuta más rápido que consumidor, nueva información podría sobrescribir ítem información leído previamente antes que proceso consumidor lea información original. proceso consumidor ejecuta más rápido que proceso productor, mismo ítem podría leerse dos veces. para solucionar este problema, debe implementar intercambio información mediante buffer compartido usar mecanismos exclusión mutua para controlar acceso ese buffer. esto significa que información puede sobrescribirse antes leerse que información debe leerse dos veces. figura . ilustra noción buffer compartido. por general, esto implementa como una cola circular, manera que falta concordancia velocidades entre los procesos productor consumidor pueda acomodarse sin tener que demorar ejecución del proceso. proceso productor siempre ingresa datos ubicación del buffer final cola (representada como figura .). proceso consumidor recupera todo momento información del inicio cola (representada como figura .). después que proceso consumidor recupera información, inicio cola ajusta para apuntar siguiente ítem (). luego que proceso productor agrega información, final cola ajusta para apuntar siguiente espacio (slot) libre cola. -.indd -.indd // :: // :: capítulo ■ software embebido desde luego, importante garantizar que los procesos productor consumidor tra- ten acceder mismo ítem mismo tiempo ( decir, cuando inicio = final). también debemos asegurarnos que proceso productor agregue ítems buffer lleno que proceso consumidor tome ítems desde buffer vacío. para ello, implemente buffer circular como proceso con las operaciones get put para acceder buffer. operación put (ingresar) llamada por proceso productor operación get (obtener) por proceso consumidor. las primitivas sincronización, como los semáforos las regiones críticas, usan para asegurar que las operaciones get put están sincroni-zadas, manera que accedan misma ubicación mismo tiempo. buffer está lleno, proceso put debe esperar hasta que espacio (slot) esté libre; buffer está vacío, proceso get debe esperar hasta hacer una entrada. una vez que elegido plataforma ejecución para sistema, diseñado una arquitectura proceso determinado una política planeación, nece-sario comprobar que sistema cumplirá sus requerimientos temporización. esto puede hacer mediante análisis estático del sistema través del conocimiento del compor-tamiento temporización los componentes, por medio simulación. este análisis puede revelar que sistema desempeñará manera adecuada. arquitectura del proceso, política planeación, plataforma ejecución todo ello, pueden rediseñarse entonces para mejorar rendimiento del sistema. las restricciones temporización otros requerimientos ocasiones pueden sig-nificar que mejor implementar hardware algunas funciones del sistema, tales como procesamiento señales, hardware. los modernos componentes hard-ware, como los fpga (por las siglas field programmable gate array), son flexibles, así que pueden adaptarse diferentes funciones. los componentes hardware ofrecen mucho mejor rendimiento que software equivalente. los cuellos botella proce-samiento del sistema pueden identificarse sustituirse por hardware, manera que evita costosa optimización software. .. modelado sistemas tiempo real los eventos los que sistema tiempo real debe reaccionar causan con frecuencia que sistema mueva estado otro. por esta razón, usan por general los mode-los estado, que exponen capítulo , para describir los sistemas tiempo real. proceso consumidorproceso productorbuffer circular iniciofinal figura . procesos productor/consumidor que comparten buffer circular -.indd -.indd // :: // :: . ■ diseño sistemas embebidos modelo estado sistema supone que, cualquier momento, sistema está uno ciertos estados posibles. cuando recibe estímulo, esto puede provocar una transición estado diferente. por ejemplo, sistema que controla una válvula puede moverse desde estado “válvula abierta” estado “válvula cerrada” cuando recibe comando operador ( estímulo). los modelos estado son una forma independiente lenguaje para representar diseño sistema tiempo real , por tanto, son una parte integral los métodos diseño sistemas tiempo real (gomaa, ). uml soporta desarrollo -delos estado basados diagramas estado ( statecharts) (harel, ; harel, ). los diagramas estado son modelos formales máquinas estado que soportan estados jerárquicos, modo que grupos estados pueden considerarse como una sola entidad. douglass analiza uso del uml desarrollo sistemas tiempo real (douglass, ). los modelos estado usan ingeniería dirigida por modelo, que estudió capítulo , para definir operación sistema. pueden transformarse automática-mente programa ejecutable. este enfoque ilustró modelado sistemas también capítulo , que usó ejemplo modelo horno microondas simple. figura . otra muestra modelo máquinas estado que presenta operación sistema software embebido para entrega combustible una bomba petróleo (gasolina). los rectángulos redondeados representan estados del sistema, mientras que las flechas representan estímulos que fuerzan una transición estado otro. los nombres elegidos diagrama máquina estado son descriptivos. informa-ción asociada indica las acciones tomadas por los actuadores del sistema información que despliega. observe que este sistema nunca termina, pero encuentra pasivo estado espera cuando bomba está funcionando.insertar tarjeta lector pausa restablecer : desplegar error cciniciar : iniciar despliegue detenerlectura : obtener detalles (credit card) espera : desplegar bienvenida pagodo: entregar combustible,actualizar pantalla reconocer pagolistoentregar activador boquilla encendidoactivadorde laboquillaapagadoactivadorde laboquillaencendido manguera soportedo: validar tarjeta créditovalidar tarjetainválidaremovertarjeta tarjeta okmanguera fuerade soporte manguera soportepausa : deducir cuenta figura . modelo máquinas estado una bomba petróleo (gasolina) -.indd -.indd // :: // :: capítulo ■ software embebido sistema entrega combustible está diseñado para permitir funcionamiento sin atención. comprador inserta una tarjeta crédito lector tarjetas colocado bomba. esto provoca una transición estado lectura donde leen detalles tarjeta, entonces pide comprador retirar tarjeta. retirarla activa una transi-ción hacia estado validar donde valida tarjeta. tarjeta válida, sistema pone acción bomba , cuando manguera combustible retira soporte, traslada hacia estado entregar, donde está lista para suministrar combustible. accionar activador boquilla bombea combustible; esto detiene cuando suelta activador (por simplicidad, ignoró interruptor presión diseñado para detener derrame combustible). después completar entrega combustible que comprador coloca manguera soporte, sistema mueve hacia estado pago donde carga cuenta del usuario. después del pago, software bomba regresa estado espera. .. programación tiempo real los lenguajes programación para desarrollo sistemas tiempo real deben incluir instalaciones para acceder hardware del sistema, debe ser factible predecir tem-porización operaciones particulares dichos lenguajes. los sistemas tiempo real duros programan todavía ocasiones lenguaje ensamblador, modo que pueda cumplirse con los plazos ajustados. también usan ampliamente los lenguajes nivel sistemas, tales como , que permiten generación código eficiente. ventaja usar lenguaje programación sistemas como que permite desarrollo programas muy eficientes. sin embargo, dichos lenguajes incluyen sen-tencias para soportar concurrencia gestión recursos compartidos. concurrencia gestión recursos implementan través llamadas primitivas proporcionadas por sistema operativo tiempo real, tales como semáforos para exclusión mutua. dichas llamadas pueden probarse por compilador, así que son más probables los errores programación. con frecuencia, los programas también son difíciles comprender, por-que los lenguajes incluyen características tiempo real. además comprender pro-grama, lector debe conocer cómo brinda soporte tiempo real mediante llamadas sistema. puesto que los sistemas tiempo real deben satisfacer sus restricciones tempori-zación, podrán usar desarrollo orientado objetos para sistemas tiempo real duros. desarrollo orientado objetos implica ocultar representaciones datos dar acceso valores atributos través operaciones definidas con objeto. esto quiere decir que hay una significativa carga rendimiento los sistemas orientados objetos, debido que requiere código adicional para mediar acceso los atributos manejar las lla-madas las operaciones. consecuente pérdida rendimiento puede hacer imposible cumplir con los plazos tiempo real. diseñó una versión java para desarrollo sistemas embebidos (dibble, ), con implementaciones diferentes compañías, como ibm sun. este lenguaje incluye mecanismo hilo modificado, que permite especificar hilos que interrumpi-rán por mecanismo recolección basura del lenguaje. también deben incluir -nejo eventos asíncronos especificación temporización. sin embargo, momento escribir libro, esto usado principalmente plataformas con representativa capacidad procesador memoria (por ejemplo, teléfono celular), siste-mas embebidos más simples, con recursos más limitados. estos sistemas generalmente siguen implementando . -.indd -.indd // :: // :: . ■ patrones arquitectónicos . patrones arquitectónicos los patrones arquitectónicos, que explicaron capítulo , son descripciones abs- tractas estilizadas buenas prácticas diseño. contienen conocimiento acerca organización las arquitecturas del sistema, cuándo deben usarse dichas arquitecturas, sus ventajas desventajas. con todo, debe pensar patrón arquitectónico como tratara diseño genérico representarse mediante casos. vez ello, patrón usa para comprender una arquitectura , como punto partida, crea-ción propio diseño arquitectónico específico. como esperaría, las diferencias entre software embebido interactivo significan que, para los sistemas embebidos, utilizan diferentes patrones arquitectónicos, vez los patrones arquitectónicos expuestos capítulo . los patrones los siste-mas embebidos son orientados procesos más que orientados objetos componentes. esta sección analizan tres patrones arquitectónicos tiempo real que emplean comúnmente: . observar reaccionar este patrón utiliza cuando conjunto sensores monitorizan despliegan manera rutinaria. momento que los sensores indican que sucedió cierto evento (por ejemplo, una llamada entrante teléfono celular), sistema reacciona iniciando proceso para manejar dicho evento. . control ambiental este patrón emplea cuando sistema incluye sensores que proporcionan información sobre entorno los actuadores que pueden cambiar entorno. respuesta los cambios ambientales detectados por sensor, envían señales control los actuadores del sistema. . segmentación proceso ( process pipeline) este patrón usa transformarse datos una representación otra antes que puedan procesarse. transforma-ción implementa como una secuencia pasos procesamiento, que pueden realizarse manera concurrente. esto permite procesamiento datos muy rápido, debido que núcleo procesador separado puede ejecutar cada trans-formación. desde luego, los patrones pueden combinarse usted percibirá con frecuencia más uno ellos solo sistema. por ejemplo, cuando usa patrón control ambiental, muy común que los actuadores monitoricen mediante patrón observar reaccionar. caso falla actuador, sistema puede reaccionar desplegando java tiempo real lenguaje programación java modificó varias formas para adecuarlo desarrollo sistemas tiempo real. tales modificaciones comprenden comunicaciones asíncronas; adición tiempo, incluido tiempo absoluto relativo; nuevo modelo hilo donde los hilos pueden interrumpirse por recolección basura; nuevo modelo gestión memoria, cual evita las demoras impredecibles que pueden resultar recolección basura. http:// -.indd -.indd // :: // :: capítulo ■ software embebido mensaje advertencia, desactivando actuador, conmutando sistema respaldo, etcétera. los patrones estudiados aquí son patrones arquitectónicos que describen estructura global sistema embebido. douglass () refiere patrones diseños bajo nivel tiempo real que usan para ayudar tomar decisiones más detalladas diseño. dichos patrones incluyen patrones diseño para control ejecución, comunicaciones, asignación recursos, seguridad fiabilidad. estos patrones arquitectónicos deben ser inicio para diseño sistemas embe-bidos; sin embargo, son plantillas diseño. usan como tales, probablemente terminará con una arquitectura proceso ineficiente. por tanto, deberá optimizar estructura del proceso para garantizar que tiene demasiados procesos. también debe probar que existe una correspondencia clara entre los procesos sensores los actuadores del sistema. .. observar reaccionar los sistemas monitorización son una importante clase sistemas embebidos tiempo real. sistema monitorización examina entorno mediante conjunto sensores , por general, despliega alguna forma estado del entorno. esto podría ser una pantalla interna, paneles instrumentos propósito especial una pantalla remota. sistema detecta cierto evento estado sensor excepcional, sistema monitorización toma alguna acción. con frecuencia, esto implica emitir una alarma para llamar atención operador hacia evento. ocasiones, sistema puede iniciar alguna otra acción preventiva, como desactivar sistema para protegerlo del daño. patrón observar reaccionar (figuras . .) patrón que usa común-mente los sistemas monitorización. observan los valores los sensores , figura . patrón observar reaccionarnombre observar reaccionar descripción recopilan analizan los valores entrada conjunto sensores los mismos tipos. dichos valores despliegan alguna forma. los valores sensor indican que surgió alguna condición excepcional, entonces inician acciones para llamar atención del operador hacia dicho valor , ciertos casos, realizar acciones respuesta valor excepcional. estímulos valores los sensores unidos sistema. respuestas salidas desplegar, activadores alarma, señales sistemas que reaccionan. procesos observador, análisis, despliegue, alarma, reactor. usado sistemas monitorización, sistemas alarma. -.indd -.indd // :: // :: . ■ patrones arquitectónicos cuando detectan valores particulares, sistema reacciona alguna manera. los sis- temas monitorización pueden componerse varias instancias del patrón observar reaccionar, una para cada tipo sensor sistema. según los requerimientos del sistema, podrá optimizar diseño combinar los procesos (por ejemplo, puede usar solo proceso despliegue para mostrar información todos los diferentes tipos sensores). como ejemplo del uso este patrón, considere diseño sistema alarma antirrobos que puede instalarse edificio oficinas: como parte sistema alarma antirrobos, implementará sistema software para edificios comerciales. sistema usa varios tipos sensores dife-rentes, que incluyen: detectores movimiento habitaciones individuales, sen-sores que detectan apertura puertas del corredor, sensores ventanas nivel del suelo que pueden detectar cuándo abre alguna éstas. cuando sensor detecta presencia intruso, sistema automáticamente llama policía local , mediante sintetizador voz, reporta ubicación alarma. enciende las luces las habitaciones alrededor del sensor activo suena una alarma. por general, sistema sensor alimenta del sistema electricidad principal, pero está equipado con una batería respaldo. pérdida electricidad detecta con monitor circuito eléctrico separado que revisa voltaje principal. detecta una caída voltaje, sistema supone que intrusos interrumpieron suministro eléctrico, modo que activa alarma. figura . muestra una posible arquitectura del proceso para sistema alarma. este diagrama, las flechas representan señales enviadas proceso otro. este sistema sistema tiempo real “blando” que tiene requerimientos tem-porización rigurosos. los sensores necesitan detectar eventos alta velocidad, por que sólo deben consultarse con poca frecuencia. sección . explican los requerimientos temporización para este sistema. figura . presentaron los estímulos las respuestas para este sistema alarma, usados como punto partida diseño del sistema. este diseño usa proceso análisisproceso observador proceso reactorproceso alarmavalores sensor proceso desplieguevalores desplegarpantalla sensores alarmaotro equipofigura . estructura del proceso observar reaccionar -.indd -.indd // :: // :: capítulo ■ software embebido patrón observar reaccionar. existen procesos observadores asociados con cada tipo sensor, procesos reactor para cada tipo reacción. hay solo proceso análisis que verifica los datos todos los sensores. los procesos despliegue patrón combinan solo proceso despliegue. .. control ambiental tal vez uso más difundido del software embebido encuentre los sistemas control. dichos sistemas, software controla operación del equipo, con base estímulos del entorno del equipo. por ejemplo, sistema frenado antiderrapante automóvil monitoriza las ruedas sistema frenos del vehículo ( entorno del sistema). busca signos que las ruedas derrapan cuando aplica presión freno. caso, sistema ajusta presión del freno para evitar bloqueo las ruedas reducir probabilidad deslizamiento. los sistemas control pueden usar patrón control ambiental, que patrón control general que incluye procesos sensor actuador. este patrón describe figura . con arquitectura proceso que muestra figura .. una variante este patrón deja fuera proceso despliegue. esta variante usa situaciones que hay requerimientos para intervención del usuario tasa control tan alta que una pantalla sería significativa. este patrón puede ser base diseño sistema control con una reformu-lación del patrón control ambiental para cada actuador ( tipo actuador) que controla. entonces optimiza diseño para reducir número procesos. por ejemplo, posible combinar procesos monitorización actuador control actuador, tener solo proceso monitorización control para varios actuadores. las optimiza-ciones que elija dependerán los requerimientos temporización. tal vez necesite monitorizar sensores con más frecuencia que envían señales control; tal caso, será poco práctico combinar procesos control monitorización. también puede haber retroalimentación directa entre control del actuador proceso monitoriza-proceso del control iluminaciónproceso alerta externacontrolador del sistemaproceso despliegue consolaproceso sensor puerta proceso monitor voltajeproceso del detector movimiento proceso del sensor ventana proceso alarma audibleproceso del panel controlproceso prueba proceso gestor eléctrico figura . estructura proceso para sistema alarma antirrobos -.indd -.indd // :: // :: . ■ patrones arquitectónicos ción del actuador, que permite tomar decisiones control grano fino mediante proceso control del actuador. figura . puede ver cómo usa este patrón; ahí muestra ejemplo controlador para sistema frenado automóvil. punto partida para diseño asociar una instancia del patrón con cada tipo actuador sistema. este caso, hay cuatro actuadores, cada uno los cuales controla freno una rueda. los procesos sensor individuales combinan solo proceso monitorización rueda que monitoriza los sensores todas las ruedas. esto monitoriza estado cada figura . patrón control ambiental pantalla proceso controlproceso monitor proceso del monitor actuadorproceso del controlador actuadorvalores sensor proceso desplieguevalores desplieguesensores actuadorinstrucciones controlestado actuador figura . estructura del proceso control ambientalnombre control ambiental descripción sistema analiza información conjunto sensores que recopilan datos del entorno del sistema. también puede recopilar más información del estado los actuadores que conectan sistema. con base datos los sensores actuadores, envían señales control los actuadores, que ese momento provocan cambios entorno del sistema. puede desplegarse información los valores del sensor estado los actuadores. estímulos valores los sensores unidos sistema estado los actuadores del sistema. respuestas señales control actuadores, despliegue información. procesos monitor, control, despliegue, controlador actuador, monitor actuador. usado sistemas control. -.indd -.indd // :: // :: capítulo ■ software embebido rueda para comprobar rueda gira está bloqueada. proceso separado monitoriza presión pedal del freno ejercida por conductor del automóvil. sistema incluye una característica antiderrapante, que activa los sensores indican que una rueda bloquea aplicar freno. esto significa que existe insuficiente fricción entre camino llanta; otras palabras, automóvil derrapa. rueda está bloqueada, conductor puede girar volante. para contrarrestar esto, sis-tema envía una secuencia rápida señales encendido/apagado (/off) freno dicha rueda, que permite que rueda gire recupere control. .. segmentación proceso ( process pipelineprocess pipeline) muchos sistemas tiempo real ocupan recopilar datos del entorno del sistema, luego los transforman, representación original, alguna otra representación digi-tal que sistema pueda analizar procesar más fácilmente. sistema también puede convertir los datos digitales datos analógicos, que entonces envían entorno. por ejemplo, software radio acepta paquetes entrantes datos digitales que represen-tan transmisión radio los transforman una señal sonora que puede escuchar gente. procesamiento datos implicado muchos estos sistemas debe realizarse muy rápidamente. otro modo, los datos entrantes podrían perderse las señales salida pueden romperse, por falta información esencial. patrón segmentación proceso ( process pipeline) hace posible este rápido procesamiento, descomponer procesamiento datos requerido una secuencia transformaciones separadas, que cada transformación realiza proceso independiente. ésta una arquitectura muy eficiente para sistemas que usan procesadores múltiples procesadores multinú-cleo. cada proceso segmentación ( pipeline, literalmente: tubería) puede asociarse con procesador núcleo separado, modo que los pasos del procesamiento pueden realizarse paralelo.proceso análisis monitor ruedamonitor pedal proceso freno proceso freno freno freno proceso freno freno presión pedal sensores ruedasfigura . arquitectura sistema control para sistema frenado antiderrapante -.indd -.indd // :: // :: . ■ patrones arquitectónicos figura . una breve descripción del patrón segmentación datos, figura . muestra arquitectura proceso para este patrón. observe que los pro-cesos implicados pueden generar consumir información. están vinculados mediante buffers sincronizados, como estudió sección .. esto permite que los procesos productor consumidor operen diferentes velocidades sin pérdida datos. ejemplo sistema que puede usar una segmentación proceso sistema adquisición datos alta velocidad. los sistemas adquisición datos recolectan datos los sensores para posterior procesamiento análisis. dichos sistemas usan situaciones que los sensores recolectan muchos datos del entorno del sistema posible necesario procesar dichos datos tiempo real. vez ello, recolec-tan almacenan para análisis posterior. con frecuencia, los sistemas adquisición datos usan experimentos científicos sistemas control proceso que los procesos físicos, como las reacciones químicas, son muy rápidos. estos sistemas, los sensores pueden generar datos muy rápidamente, sistema adquisición datos debe garantizar que recopile lectura sensor antes que cambie valor del sensor. figura . modelo simplificado sistema adquisición datos que puede ser parte del software control reactor nuclear. éste sistema que reco-pila datos sensores que monitorizan flujo neutrones ( densidad neutrones) reactor. los datos del sensor colocan buffer desde cual extraen pro-cesan. nivel flujo promedio muestra una pantalla del operador almacena para procesamiento futuro.figura . patrón segmentación proceso proceso bufferproceso productordatos producidos proceso consumidordatos consumidos...figura . estructura proceso segmentación procesonombre segmentación proceso descripción una segmentación ( pipeline) procesos establece con datos que mueven secuencia extremo “tubería” otro. con frecuencia, los procesos están vinculados mediante buffers sincronizados para permitir que los procesos productor consumidor ejecuten diferentes velocidades. culminación una segmentación puede desplegarse almacenar los datos, “tubería” puede terminar actuador. estímulos valores entrada del entorno algún otro proceso respuestas valores salida entorno buffer compartido procesos productor, buffer, consumidor usado sistemas adquisición datos, sistemas multimedia -.indd -.indd // :: // :: capítulo ■ software embebido . análisis temporización como estudió introducción, exactitud sistema tiempo real depende sólo exactitud sus salidas, sino también del tiempo que produjeron dichas salidas. esto significa que una actividad importante proceso desarrollo soft-ware embebido tiempo real análisis temporización. tal análisis, calcula con qué frecuencia debe ejecutarse cada proceso sistema para garantizar que todas las entradas procesen que todas las respuestas del sistema produzcan forma oportuna. los resultados del análisis temporización usan para decidir con qué con-tinuidad debe ejecutarse cada proceso cómo sistema operativo tiempo real debe organizar temporalmente dichos procesos. análisis temporización (timing) para sistemas tiempo real particularmente difícil cuando los sistemas deben hacer frente una mezcla estímulos respuestas periódicos periódicos. puesto que los estímulos periódicos son impredecibles, usted tendrá que hacer suposiciones acerca probabilidad que dichos estímulos ocurran , por tanto, que requiera servicio algún momento particular. dichos supuestos pueden ser incorrectos rendimiento del sistema después entrega podría ser inadecuado. libro cooling () examina técnicas para análisis rendimiento los sistemas tiempo real que toman cuenta eventos periódicos. sin embargo, conforme las computadoras vuelven más rápidas sido posible, muchos sistemas, diseñar usando sólo estímulos periódicos. cuando los procesadores son lentos, deben usarse estímulos periódicos para garantizar que los eventos críticos proce-sen antes sus plazos, pues las demoras procesamiento suponen, por general, alguna pérdida sistema. por ejemplo, falla una fuente energía sistema embebido puede significar que sistema debe apagar equipo vinculado una forma controlada, dentro tiempo muy corto (por ejemplo, milisegundos). esto podría implementarse como una interrupción “falla energía”. sin embargo, también puede implementar- usando proceso periódico que opere muy frecuentemente compruebe energía. siempre cuando tiempo entre invocaciones procesos sea corto, todavía habrá tiempo para realizar apagado controlado del sistema antes que falta energía cause daños. por esta razón, tratarán los conflictos temporización para procesos periódicos. cuando analizan los requerimientos temporización los sistemas embebidos tiempo real diseñan sistemas para cumplir dichos requerimientos, existen tres factores clave que deben considerar: . plazos los tiempos que deben procesarse los estímulos producir alguna res- puesta por parte del sistema. sistema cumple plazo, entonces, buffer valor flujoprocesamiento flujobuffer datos brutosconvertidor -didentificador sensor valor flujonivel flujo procesadoalmacenamiento desplieguesensores flujo neutrones figura . adquisición datos flujo neutrones -.indd -.indd // :: // :: . ■ análisis temporización sistema tiempo real duro, trata una falla sistema; sistema tiempo real blando, resultado servicio sistema degradado. . frecuencia número veces por segundo que debe ejecutarse proceso para tener seguridad que siempre puede cumplir los plazos. . tiempo ejecución tiempo requerido para procesar estímulo producir una respuesta. con frecuencia deben tomar cuenta dos tiempos ejecución: tiempo ejecución promedio proceso tiempo ejecución del peor escenario para dicho proceso. siempre tiempo ejecución mismo, debido ejecución condicional del código, demoras espera otros procesos, etcétera. sistema tiempo real duro, tal vez deba hacer suposiciones con base tiempo ejecución del peor escenario para asegurarse que venzan los plazos. los sistemas tiempo real blandos, quizá deba basar sus cálculos tiempo ejecución promedio. para continuar con ejemplo una falla suministro energía, suponga que, después evento falla, transcurren para que voltaje suministrado caiga nivel que pueda dañarse equipo. por tanto, proceso apagado del equipo debe comenzar menos luego evento falla energía. ante tales casos, sería prudente establecer plazo más corto , debido las variaciones físicas equipo. esto significa que las instrucciones apagado para todo equipo conectado que esté riesgo deben emitirse procesarse dentro , suponiendo que equipo tam-bién depende falla del suministro energía. usted detecta una falla energía monitorizar nivel voltaje, debe hacer más una observación para detectar que cae voltaje. usted ejecuta proceso veces por segundo, esto significa que ejecuta cada pueden requerirse hasta dos periodos para detectar caída voltaje. por consiguiente, tarda hasta detectar problema. con-secuencia, tiempo ejecución del peor escenario del proceso apagado debe superar los para garantizar que cumpla plazo . esta cifra calcula restando los periodos proceso ( ) del plazo ( ) dividiendo resultado entre dos, puesto que necesitan dos ejecuciones proceso. realidad, por general uno inclinaría hacia lapso considerablemente menor que para dar margen seguridad caso que los cálculos estuvieran equi-vocados. hecho, tiempo requerido para examinar sensor comprobar que hay pérdida significativa voltaje debe ser mucho menor que . esto sólo implica una comparación simple dos valores. tiempo ejecución promedio del proceso del monitor eléctrico debe ser menor que . punto partida del análisis temporización sistema tiempo real constituyen los requerimientos temporización, que deben establecer los plazos para cada respuesta requerida sistema. figura . muestra posibles requerimientos temporización para sistema alarma antirrobo del edificio oficinas que estu-dió sección ... para simplificar este ejemplo, ignore los estímulos generados por los procedimientos prueba del sistema las señales externas para restablecer sistema caso una falsa alarma. esto significa que hay sólo dos tipos estímulo procesar por parte del sistema: . falla energía ésta detecta observar una caída voltaje más del por ciento. respuesta requerida encender circuito energía respaldo enviando una señal dispositivo electrónico conmutación energía, que cambia electricidad principal batería respaldo. -.indd -.indd // :: // :: capítulo ■ software embebido . alarma contra intrusos éste estímulo generado por uno los sensores del sistema. respuesta este estímulo determinar número habitación del sensor activo, establecer llamado policía, iniciar sintetizador voz para gestionar llamada, emitir una alarma audible intrusos encender las luces área. como muestra figura ., deben listar las restricciones tiempo para cada clase sensor por separado, aun cuando (como este caso) sean iguales. considerar-las por separado, deja espacio para cambios futuros facilita cálculo del número veces que debe ejecutarse por segundo proceso control. asignar las funciones del sistema procesos concurrentes siguiente etapa del diseño. existen cuatro tipos sensores que deben revisarse periódicamente, cada uno con proceso asociado. trata del sensor voltaje, sensores puertas, sensores ventanas detectores movimiento. por general, los procesos asociados con sensor ejecutarán muy rápidamente, pues todo que hacen comprobar sensor cam-bió estatus (por ejemplo, apagado encendido). razonable suponer que tiempo ejecución para comprobar valorar estado sensor más . para garantizar que cumplen los plazos definidos por los requerimientos tem-porización, hay que decidir con qué frecuencia ejecutan los procesos relacionados cuántos sensores deben examinarse durante cada ejecución del proceso. aquí existen ventajas desventajas obvias entre frecuencia tiempo ejecución: . usted examina sensor durante cada ejecución proceso, entonces, hay sensores tipo particular, debe programar proceso veces por segundo con finalidad garantizar que cumpla plazo para detectar cambio estado dentro . segundos.figura . requerimientos temporización para sistema alarma antirroboestímulo/respuesta requerimientos temporización falla energía cambio energía respaldo debe completarse dentro plazo . alarma puerta cada alarma puerta debe revisarse dos veces por segundo. alarma ventana cada alarma ventana debe revisarse dos veces por segundo. detector movimiento cada detector movimiento debe revisarse dos veces por segundo. alarma audible alarma audible debe encenderse dentro del medio segundo posterior que sensor emite una alarma. encendido luces las luces deben encenderse dentro del medio segundo posterior que sensor emite una alarma. comunicaciones llamado policía debe iniciarse dentro los segundos posteriores los que sensor emite una alarma. sintetizador voz mensaje sintetizado debe estar disponible dentro los segundos posteriores los que sensor emite una alarma. -.indd -.indd // :: // :: . ■ análisis temporización . usted examina cuatro sensores, por ejemplo, durante cada ejecución proceso, entonces tiempo ejecución aumenta , pero sólo necesita ejecutar pro-ceso veces/segundo para satisfacer requerimiento temporización. este caso, puesto que los requerimientos del sistema definen acciones cuando dos más sensores son positivos, conveniente examinar sensores grupos, con grupos basa-dos proximidad física los sensores. intruso entra edificio, entonces probable-mente habrá sensores adyacentes que sean positivos. una vez que completado análisis temporización, entonces puede anotar modelo proceso con información sobre frecuencia ejecución tiempo ejecución esperado (véase como ejemplo figura .). aquí, anotan los procesos periódicos con frecuencia, los procesos que comienzan respuesta estímulo anotan con , proceso prueba proceso segundo plano, anotado con . esto significa que sólo ejecuta cuando está disponible tiempo del procesador. general, más sencillo diseñar sistema manera que exista número pequeño frecuen-cias proceso. los tiempos ejecución representan los tiempos ejecución del peor escenario requeridos los procesos. paso final proceso diseño diseñar sistema planeación que garan-tice que siempre debe programar proceso para cumplir con sus plazos. esto sólo posible conocen los enfoques planeación que soporta sistema operativo tiempo real utilizado (burns wellings, ). planificador sistema operativo tiempo real asigna proceso procesador durante una cantidad tiempo dada. tiempo puede fijarse, variar dependiendo prioridad del proceso. asignar prioridades proceso deben considerar los plazos cada uno, modo que aquellos con plazos cortos reciban tiempo procesador para cumplir dichos plazos. por ejemplo, proceso del monitor voltaje alarma antirrobo necesita programarse forma que puedan detectarse las caídas voltaje realice cambio energía respaldo antes que falle sistema. consecuencia, esto tiene mayor prioridad que los procesos que comprueban los valores sensor, pues éstos tienen plazos bastante relaja-dos comparación con tiempo ejecución esperado.figura . temporización del proceso alarmab proceso control iluminaciónproceso alerta externacontrolador del sistemaproceso despliegue consolaproceso sensor puerta proceso monitor voltajeproceso detector movimiento proceso sensor ventana proceso alarma audibleproceso panel controlproceso prueba proceso gestor eléctrico (. ) ( ) (. ) (. ) (. ) ( ) ( ) ( ) ( ) ( ) ( ) -.indd -.indd // :: // :: capítulo ■ software embebido . sistemas operativos tiempo real plataforma ejecución para mayoría los sistemas aplicación sistema operativo que gestiona recursos compartidos brinda características tales como sis-tema archivo, gestión proceso tiempo ejecución, etcétera. sin embargo, amplia funcionalidad sistema operativo convencional toma gran cantidad espa-cio vuelve lenta ejecución los programas. más aún, las características gestión proceso sistema pueden estar diseñadas para permitir control grano fino sobre planeación procesos. por estas razones, los sistemas operativos estándar, como linux windows, usan por general como plataforma ejecución para sistemas tiempo real. los sistemas embebidos muy simples pueden implementarse como sistemas “metal descu-bierto”. los sistemas incluyen arranque apagado sistema, gestión proceso recursos, planeación proceso. sin embargo, más comúnmente, las aplicaciones embebidas construyen parte superior sistema operativo tiempo real (rtos, por las siglas real-time operating system ), cual sistema operativo eficiente que ofrece las características que necesitan los sistemas tiempo real. ejemplos rtos son windows/, vxworks rtlinux. sistema operativo tiempo real gestiona asignación procesos recursos para sistema tiempo real. inicia detiene procesos modo que los estímulos puedan manejarse, asigna memoria recursos procesador. los componentes rtos (figura .) dependen del tamaño complejidad del sistema tiempo real desarro-llar. salvo para los sistemas más simples, generalmente incluyen: . reloj tiempo real, que proporciona información requerida para programar los procesos periódicamente. . manipulador interrupciones, cual gestiona peticiones periódicas ser-vicios. . planificador, que responsable examinar los procesos que pueden ejecutarse elegir uno ellos para ejecución. . gestor recursos, cual asigna memoria adecuada recursos procesador para aquellos procesos que programaron para ejecución. . despachador, que responsable iniciar ejecución los procesos. los sistemas operativos tiempo real para sistemas grandes, como los sistemas control proceso los telecomunicaciones, pueden tener instalaciones adicionales, saber: gestión almacenamiento disco, instalaciones para gestión fallas que detecten reporten fallas del sistema, gestor configuración que soporte recon-figuración dinámica aplicaciones tiempo real. .. gestión proceso los sistemas tiempo real tienen que manejar rápidamente los eventos externos , algunos casos, cumplir con los plazos para procesamiento dichos eventos. esto -.indd -.indd // :: // :: . ■ sistemas operativos tiempo real significa que los procesos manejo eventos deben programarse para ejecución tiempo detectar evento. también deben asignar suficientes recursos procesador para cumplir sus plazos. gestor proceso rtos responsable elegir los procesos para ejecución, asignar recursos procesador memoria, iniciar detener ejecución del proceso procesador. gestor proceso debe tratar los procesos con diferentes prioridades. para algu-nos estímulos, como los asociados con ciertos eventos excepcionales, esencial que procesamiento deba completarse dentro los límites tiempo especificados. otros procesos pueden demorarse forma segura proceso más crítico requiere servicio. consecuencia, rtos debe gestionar menos dos niveles prioridad para los procesos del sistema: . nivel interrupción éste nivel prioridad más alto. asigna procesos que necesitan una respuesta muy rápida. uno dichos procesos será proceso reloj tiempo real. . nivel reloj este nivel prioridad asigna los procesos periódicos. puede haber nivel prioridad adicional que asigna los procesos segundo plano (como los procesos autoverificación) que necesitan cumplir plazos tiempo real. dichos procesos programan para ejecutarse cuando capacidad procesador está disponible. dentro cada uno dichos niveles prioridad, diferentes clases proceso pue-den asignarse distintas prioridades. por ejemplo, puede haber varias líneas interrupción. requerimientos recurso procesoplanificadorinformación planeación gestor recursos despachadorreloj tiempo real procesos que esperan recursos lista preparadosmanipulador interrupción lista recursos disponibles lista procesador ejecución procesoprocesos listosrecursos liberados figura . componentes sistema operativo tiempo real -.indd -.indd // :: // :: capítulo ■ software embebido una interrupción dispositivo muy rápido tal vez tenga que invalidar proceso una interrupción parte dispositivo más lento para evitar pérdidas informa-ción. asignación prioridades proceso, para que todos los procesos atiendan tiempo, requiere por general análisis extensos simulación. los procesos periódicos son procesos que deben ejecutarse intervalos específicos para adquisición datos control actuador. mayoría los sistemas tiem real, habrá muchos tipos proceso periódico. usar los requerimientos tem zación especificados programa aplicación, rtos ordena ejecución los procesos periódicos para que todos puedan cumplir con sus plazos. figura . muestran las acciones tomadas por sistema operativo para gestión procesos periódicos. planificador examina lista procesos periódicos selecciona proceso ejecutar. elección depende prioridad del proceso, perio-dos del proceso, tiempos ejecución esperados plazos los procesos listos. oca-siones, dos procesos con diferentes plazos deben ejecutarse mismo instante del reloj; tal situación, proceso debe demorarse. comúnmente, sistema elegirá retrasar proceso con plazo más largo. los procesos que deben responder rápidamente eventos asíncronos pueden estar dirigidos por interrupciones. mecanismo interrupción computadora hace que control transfiera una ubicación memoria predeterminada. esta ubicación con-tiene una instrucción para saltar una rutina servicio interrupción simple rápida. rutina servicio deshabilita más interrupciones para evitar interrumpirse misma. entonces descubre causa interrupción inicia, con una alta prioridad, proceso para manejar estímulo que provocó interrupción. algunos sistemas adquisición datos alta velocidad, manipulador interrupción guarda los datos que inte-rrupción señaló como disponibles buffer para procesamiento posterior. luego, las interrupciones habilitan nuevamente control regresa sistema operativo. cualquier momento puede haber varios procesos, todos con diferentes prioridades, que podrían ejecutarse. planificador procesos implementa políticas planeación del sistema que determinan orden ejecución del proceso. existen dos estrategias planeación usadas generalmente: . planeación sustitutiva una vez que planea proceso para ejecución, ejecuta hasta completarse bloquearse por alguna razón, como espera una entrada. sin embargo, esto puede causar problemas cuando existen procesos con diferentes prioridades, así que proceso alta prioridad debe esperar para que termine proceso baja prioridad. . planeación sustitutiva posible detener ejecución proceso operación proceso mayor prioridad requiere servicio. proceso prioridad más alta sustituye ejecución del proceso prioridad más baja asigna procesador.gestor recursos asigna memoria procesadorplanificador elige procesopara ejecucióndespachador inicia ejecución unprocesador disponiblecola proceso mapa memoria lista procesador lista preparados figura . acciones rtos requeridas para iniciar proceso -.indd -.indd // :: // :: pmcapítulo ■ puntos clave dentro dichas estrategias han desarrollado diferentes algoritmos planea- ción. ellos incluyen planeación circular (round-robin), que cada proceso ejecuta turnos; planeación tasa monotónica, que otorga prioridad pro-ceso con periodo más corto (frecuencia más alta); planeación prioritaria del plazo más corto, que programa proceso cola con plazo más corto (burns wellings, ). información acerca del proceso ejecutar transmite gestor recursos. gestor recursos asigna memoria , sistema multiprocesador, también agrega procesador este proceso. entonces proceso coloca “lista preparados”, una lista procesos que están preparados para ejecución. cuando procesador termina ejecutar proceso queda disponible, recurre despachador. éste explora lista preparados para encontrar proceso que pueda ejecutarse procesador disponi-ble comienza ejecución. puntos clave ■ sistema software embebido parte sistema hardware/software que reacciona eventos entorno. software “embebe” hardware. los sistemas embebidos, por general, son sistemas tiempo real. ■ sistema tiempo real sistema software que debe responder eventos tiempo real. exactitud del sistema sólo depende los resultados que produce, sino también del tiempo que producen dichos resultados. ■ los sistemas tiempo real implementan por general como conjunto procesos comunicación que reaccionan ante estímulos para producir respuestas. ■ los modelos estado son una importante representación diseño para sistemas embebidos tiempo real. usan para mostrar cómo reacciona sistema entorno conforme los eventos activación cambian estado del sistema. ■ existen varios patrones estándar que pueden observarse diferentes tipos sistemas embebidos. ellos incluye patrón que monitoriza entorno del sistema para eventos adversos, patrón para control actuador patrón procesamiento datos. ■ los diseñadores sistemas tiempo real tienen que hacer análisis temporización (timing), que dirigido por los plazos para procesar los estímulos responder ellos. tienen que decidir con qué frecuencia debe ejecutar cada proceso sistema tiempo ejecución esperado del peor escenario para los procesos. ■ sistema operativo tiempo real responsable gestión los procesos los recursos. siempre incluye planificador, que componente responsable decidir cuál proceso debe programarse para ejecución. -.indd -.indd // :: // :: capítulo ■ software embebido lecturas sugeridas software engineering for real-time systems. escrito desde una perspectiva ingeniería más que las ciencias computación, este libro una excelente guía práctica para ingeniería los sistemas tiempo real. tiene amplia cobertura los conflictos hardware, así que acertado complemento libro burns wellings (véase siguiente obra citada). (. cooling, addison-wesley, .) real-time systems and programming language: ada, real-time java and /real-time posix, edition. extraordinario completo texto que brinda una vasta cobertura todos los aspectos los sistemas tiempo real. (. burns . wellings, addison-wesley, .) “trends embedded software engineering”. este artículo sugiere que desarrollo orientado por modelo (como estudió capítulo este libro), convertirá importante enfoque para desarrollo sistemas embebidos. éste parte número especial sobre los sistemas embebidos, usted también descubrirá que otros artículos son lecturas útiles. ( ieee software, (), mayo-junio .) http:/ /. doi. org/ . / . . . ejercicios .. con ejemplos, explique por qué los sistemas tiempo real por general tienen que implementarse mediante procesos concurrentes. .. identifique posibles estímulos respuestas esperadas para sistema embebido que controle refrigerador una lavadora domésticos. .. con enfoque basado estado para modelado, como estudió sección .., modele operación sistema software embebido para sistema correo voz incluido una línea telefónica fija. éste debe mostrar número mensajes grabados una pantalla led permitir usuario marcar números telefónicos escuchar los mensajes grabados. .. explique por qué enfoque orientado objetos para desarrollo software puede ser adecuado para sistemas tiempo real. .. muestre cómo podría usarse patrón control ambiental como base del diseño sistema para controlar temperatura invernadero. temperatura debe estar entre grados celsius. cae por abajo grados, debe encenderse sistema calefacción; rebasa los , deben abrirse automáticamente las ventanas. .. diseñe una arquitectura proceso para sistema monitorización ambiental que recopile datos conjunto sensores calidad del aire colocados alrededor ciudad. hay , sensores organizados vecindarios. cada sensor debe consultarse cuatro veces por segundo. cuando más del % los sensores vecindario particular indiquen que calidad del aire está por abajo nivel aceptable, activan luces advertencia locales. todos los sensores envían las lecturas una computadora central, cual genera reportes cada minutos sobre calidad del aire ciudad. -.indd -.indd // :: // :: pmcapítulo ■ ejercicios sistema protección ferroviario  sistema adquiere información acerca del límite velocidad segmento desde transmisor lado vía, que transmite continuamente identificador del segmento límite velocidad. mismo transmisor también transfiere información sobre estatus señal que controla segmento vía. tiempo requerido para transmitir segmento vía información señal .  tren puede recibir información del transmisor vía cuando está dentro .  velocidad máxima tren kph.  los sensores tren ofrecen información acerca velocidad actual del tren (actualizada cada ) estatus frenado del tren (actualizado cada ).  velocidad del tren supera más kph límite velocidad del segmento actual, emite una advertencia sonora cabina del conductor. velocidad del tren supera más kph límite velocidad del segmento actual, aplican automáticamente los frenos del tren hasta que disminuye límite velocidad del segmento. los frenos del tren deben aplicarse dentro los primeros partir del momento que detectó excesiva velocidad del tren.  tren entra una vía señalada con una luz roja, sistema protección aplica los frenos del tren reduce velocidad cero. los frenos del tren deben aplicarse dentro los primeros partir del momento que recibió señal luz roja.  sistema actualiza continuamente una pantalla estatus cabina del conductor. figura . requerimientos para sistema protección ferroviario .. sistema protección ferroviario aplica automáticamente los frenos tren excede límite velocidad para segmento vía tren entra segmento vía que actualmente señala con una luz roja (esto , debe entrar segmento). figura . muestran los detalles. identifique los estímulos que debe procesar sistema control bordo del tren las respuestas asociadas dichos estímulos. .. sugiera una posible arquitectura proceso para este sistema. .. proceso periódico sistema protección bordo del tren usa para recopilar datos del transmisor lado vía, ¿con qué frecuencia debe programarse para asegurar que sistema garantice recolección información del transmisor? explique cómo llegó respuesta. .. ¿por qué los sistemas operativos propósito general, como linux windows, son adecuados como plataformas sistemas tiempo real? considere experiencia usar sistema propósito general para ayudarse responder esta pregunta. -.indd -.indd // :: // :: capítulo ■ software embebido referencias berry, . (). “real-time programming: special-purpose general-purpose languages”. information processing. ritter, . (.). amsterdam: elsevier science publishers, –. brinch-hansen, . (). operating system principles. englewood cliffs, : prentice-hall.burns, . wellings, . (). real-time systems and programming languages: ada, real-time java and /real-time posix. boston: addison-wesley. cooling, . (). software engineering for real-time systems. harlow, : addison-wesley.dibble, . . (). real-time java platform programming, edition . charleston, : booksurge publishing.dijkstra, . . (). “cooperating sequential processes”. programming languages. genuys, . (.). londres: academic press, –.douglass, . . (). real-time uml: developing efficient objects for embedded systems, edition. boston: addison-wesley. douglass, . . (). real-time design patterns: robust scalable architecture for real-time systems. boston: addison-wesley. gomaa, . (). software design methods for concurrent and real-time systems . reading, mass.: addison-wesley.harel, . (). “statecharts: visual formalism for complex systems”. sci. comput. programming, (), –. harel, . (). “ visual formalisms”. comm. acm, (), –.hoare, . . . (). “monitors: operating system structuring concept”. comm. acm, (), –.lee, . . (). “embedded software”. advances computers. zelkowitz, . (.). londres: academic press. silberschatz, ., galvin, . . gagne, . (). operating system concepts, edition. new york: john wiley & sons. tanenbaum, . . (). modern operating systems, edition. englewood cliffs, : prentice hall. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo desarrollo software orientado aspectos, que basa separación competencias, intereses, asuntos propiedades del sistema (separation concerns). estudiar este capítulo: ■ comprenderá por qué separación intereses buen principio guía para desarrollo software; ■ introducirá las ideas fundamentales que subyacen los aspectos desarrollo software orientado aspectos; ■ conocerá cómo puede usar enfoque orientado aspectos para ingeniería requerimientos, diseño software programación; ■ estará tanto las dificultades poner prueba sistemas orientados aspectos. contenido . separación intereses . aspectos, puntos enlace puntos corte . ingeniería software con aspectos ingeniería software orientada aspectos -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos mayoría los grandes sistemas, las relaciones entre los requerimientos com- ponentes del programa son complejas. solo requerimiento puede implementarse mediante algunos componentes cada uno éstos puede incluir elementos varios requerimientos. práctica, esto significa que implementar cambio los reque-rimientos implica comprender modificar varios componentes. otra posibilidad que componente puede proporcionar alguna funcionalidad central, pero también incluir código que implemente muchos requerimientos sistema. aun cuando parezca haber significativo potencial reutilización, podría ser costoso reutilizar tales com-ponentes. reutilización tal vez implique modificarlos para eliminar código adicional manera que asocie con funcionalidad central del componente. ingeniería software orientada aspectos (aose, por las siglas aspect-orien-ted software engineering) enfoque desarrollo software que está destinado enfrentar este problema así elaborar programas más fáciles mantener reutilizar. aose basa abstracciones llamadas aspectos, que ponen marcha funcionali-dad sistema que pueden requerirse varios lugares diferentes programa. los aspectos encapsulan funcionalidad que atraviesa coexiste con otra funcionalidad que incluye sistema. usan lado otras abstracciones como objetos métodos. programa ejecutable orientado aspectos crea automáticamente combinar (tejer, weave) objetos, métodos aspectos, acuerdo con las especificaciones comprendidas código fuente del programa. una importante característica los aspectos que incluyen una definición sobre dónde deben incluirse programa, además del código que implementa com-petencia que atraviesa. puede especificar que código transversal ( cross-cutting ) debe incluirse antes después una llamada método específico acceder atributo. esencia, aspecto entrelaza programa central para crear nuevo sistema aumentado. beneficio principal enfoque orientado aspectos que soporta separación competencias. como explica sección ., separación competencias elementos independientes, vez incluir diferentes competencias misma abs-tracción lógica, una buena práctica ingeniería software. representar las competencias transversales como aspectos, éstas pueden comprenderse, reutilizarse modificarse manera independiente, sin tomar cuenta dónde use código. por ejemplo, autenticación usuario puede representarse como aspecto que solicite nombre usuario una contraseña. esto puede integrarse automáticamente programa siempre que requiera autenticación. considere que tiene requerimiento que precise autenticación del usuario antes realizar cualquier cambio información personal una base datos. puede describir esto aspecto enunciar que debe incluir código autenticación antes cada solicitud métodos que actualicen datos personales. posteriormente, puede ampliar requerimiento autenticación todas las actualizaciones base datos. esto implementa fácilmente modificar aspecto. sólo cambia definición dónde debe incorporarse código autenticación sistema. tiene que buscar través del sistema para encontrar todas las incidencias dichos métodos. por consiguiente, tendrá menor probabilidad cometer errores introducir vulnerabilidades seguridad acciden-tales programa. investigación desarrollo orientación aspectos enfocaron esencialmente programación orientada aspectos. han diseñado lenguajes programación orien-tados aspectos, como aspectj (colyer clement, ; colyer ., ; kiczales ., ; laddad, ; laddad, ), que extienden programación orientada -.indd -.indd // :: // :: . ■ separación intereses objetos para incluir aspectos. las grandes compañías usan programación orienta- aspectos sus procesos producción software (colyer clement, ). sin embargo, las competencias transversales son igualmente problemáticas otras etapas del proceso desarrollo software. ahora los investigadores indagan sobre cómo utilizar orientación aspectos ingeniería requerimientos sistema diseño sistemas, forma poner prueba verificar programas orientados aspectos. aquí incluye una discusión aose porque enfoque separación las competencias una importante manera pensar estructurar sistema soft-ware. aunque han implementado algunos sistemas gran escala mediante enfoque orientado aspectos, uso aspectos todavía parte ingeniería soft-ware convencional. como todas las nuevas tecnologías, sus defensores enfocan los beneficios más que los problemas costos. aunque transcurrirá algún tiempo antes que aose emplee modo rutinario lado otros enfoques inge-niería software, importante idea separar las competencias que subyacen aose. considerar separación las competencias buen enfoque general para ingeniería software. las secciones restantes del capítulo tratan los conceptos que son parte aose, examinan las ventajas desventajas usar enfoque orientado aspectos diferentes etapas del proceso desarrollo software. como meta del capítulo ayudar comprender los conceptos subyacentes aose, nos adentraremos detalles algún enfoque específico lenguaje programación orientado aspectos. . separación intereses separación competencias intereses ( concerns) principio clave del diseño implementación software. significa que usted debe organizar software modo que cada elemento programa (clase, método, procedimiento, etcétera) realice una función sólo una función. entonces podrá enfocarse ese elemento sin considerar los otros elementos programa. posible comprender cada parte del programa conocer competencia, sin necesidad entender otros elementos. cuando requieren cambios, éstos localizan pequeño número elementos. importancia separar las competencias reconoció las etapas iniciales ciencia computación. las subrutinas, que encapsulan una unidad funciona-lidad, inventaron principios década , han diseñado mecanismos subsecuentes estructuración del programa, tales como procedimientos clases objetos, con finalidad proporcionar mejores mecanismos para realizar separación competencias. sin embargo, todos estos mecanismos tienen problemas para hacer frente ciertos tipos competencias que cruzan otras competencias. tales competen-cias transversales pueden ubicarse mediante mecanismos estructuración como objetos funciones. los aspectos inventaron para ayudar gestionar estas competen-cias transversales. aunque general acordó que separación competencias una buena práctica ingeniería software, resulta muy difícil identificar con exactitud que entiende realmente por competencia. ocasiones, ésta define como una noción funcional ( decir, una competencia algún elemento funcional sistema). como alternativa, puede definirse manera muy general como “cualquier pieza interés propósito -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos programa”, aunque ninguna estas definiciones particularmente útil prác- tica. sin duda, las competencias son más que simplemente elementos funcionales, pero una definición más general tan vaga, que realidad resulta inútil. según autor, mayoría los intentos por definir las competencias son problemá-ticos porque tratan relacionar las competencias programas. hecho, como explican jacobson (), las competencias consideran realidad como reflejos los requerimientos las prioridades las partes interesadas sistema. rendimiento del sistema puede ser una competencia porque los usuarios quieren tener una respuesta rápida sistema; algunas partes interesadas tal vez preocupen porque sistema incluya una particular funcionalidad; las compañías que soportan sistema pueden inclinarse que sea fácil mantener. por tanto, una competencia puede definirse como algo que interés significado para participante grupo participantes. piensa las competencias como una forma organizar los requerimientos, observará por qué una buena práctica enfoque implementación que separa las competencias diferentes elementos programa. considera más fácil rastrear las competencias, expresadas como requerimiento conjunto relacionado requeri-mientos, partir los componentes del programa, que implementar dichas competen-cias. los requerimientos cambian, entonces evidente parte del programa que debe cambiar. existen varios tipos diferentes competencias intereses para participante: . competencias funcionales, que relacionan con funcionalidad específica incluir sistema. por ejemplo, sistema control ferroviario, una compe-tencia funcional específica consiste frenado del tren. . competencias calidad del servicio, las cuales relacionan con comporta-miento funcional sistema. éstas incluyen características como rendimiento, fiabilidad disponibilidad. . competencias política, que relacionan con políticas generales que rigen uso sistema. las limitaciones políticas incluyen competencias seguridad protección, las competencias relacionadas con las reglas negocio. . competencias sistema, las cuales relacionan con atributos del sistema como todo, tales como mantenibilidad configurabilidad. . competencias organizacionales, que relacionan con las metas prioridades organización. entre ellas incluyen producir sistema dentro presupuesto, usar los activos software existentes mantener imagen organización. las competencias centrales sistema son aquellas competencias funcionales rela-cionadas con propósito primario. así, para sistema información pacientes hospital, las competencias funcionales centrales son creación, edición, recuperación gestión registros pacientes. además las competencias centrales, los grandes sistemas tienen también competencias funcionales secundarias. éstas pueden incluir fun-cionalidad que comparte información con las competencias centrales, que requiere para que sistema pueda cumplir con sus requerimientos funcionales. por ejemplo, considere sistema que tenga requerimiento para ofrecer acceso con-currente buffer compartido. proceso agrega datos buffer otro proceso toma datos del mismo buffer. este buffer compartido parte sistema adquisición -.indd -.indd // :: // :: . ■ separación intereses datos que proceso productor pone datos buffer proceso consumidor toma los datos éste. aquí competencia central mantener buffer compartido manera que funcionalidad central está asociada con agregar eliminar elementos del buffer. sin embargo, para garantizar que los procesos productor consumidor inter-fieran entre , existe una competencia secundaria esencial sincronización. sistema debe diseñarse forma que proceso productor pueda sobrescribir datos que hayan consumido, proceso consumidor pueda tomar datos buffer vacío. aparte estas competencias secundarias, otras competencias como calidad servi-cio políticas organizacionales reflejan requerimientos esenciales del sistema. gene-ral, trata competencias del sistema: aplican sistema como todo lugar implementarse requerimientos individuales realización dichos requerimientos programa. son las llamadas competencias transversales (cross-cutting), para dis-tinguirlas las competencias centrales. las competencias funcionales secundarias tam-bién pueden ser transversales, aunque siempre atraviesan todo sistema; vez ello, asocian con agrupamientos competencias centrales que ofrecen funcionalidad relacionada. las competencias transversales muestran figura ., cual basa ejemplo sistema banca por internet. este sistema tiene requerimientos relacio-nados con nuevos clientes, como comprobación crédito verificación dirección. asimismo, posee requerimientos relacionados con administración los clientes exis-tentes gestión cuentas los clientes. todas ellas son competencias centrales que asocian con propósito primario del sistema: proveer servicio banca por internet. sin embargo, sistema también cuenta con requerimientos seguridad con base política seguridad del banco, requerimientos recuperación para garanti-zar que los datos pierdan caso una falla del sistema. trata competencias transversales, que pueden influir implementación todos los otros requerimien-tos del sistema. las abstracciones lenguaje programación, tales como procedimientos cla-ses, son mecanismo que usa normalmente para organizar estructurar las compe-tencias centrales sistema. obstante, implementación las competencias centrales lenguajes programación convencionales incluye por general código adicional para implementar las competencias transversales, funcionales, calidad servicio políticas. esto conduce dos fenómenos indeseables: enredos ( tangling) dispersión (scattering).requerimientos seguridad requerimientos recuperación competencias centralesrequerimientos cliente nuevorequerimientos gestión clientesrequerimientos cuenta competencias transversales figura . competencias transversales -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos enredo (tangling) ocurre cuando módulo sistema incluye código que implementa diferentes requerimientos sistema. ejemplo figura ., que una implementación simplificada parte del código para sistema buffer limitado, ilustra este fenómeno. figura . una implementación operación put (poner) que añade ítem buffer. sin embargo, buffer está lleno, debe esperar hasta que una correspondiente operación get (conseguir) elimine ítem del buffer. los detalles tienen importancia; esencia, usan las llamadas wait() notify() para sincronizar las operaciones put get. código que soporta principal competencia ( este caso, poner registro buffer) está enredado con código que implementa sincronización. código sincronización, que asocia con competencia secundaria asegurar exclusión mutua, debe incluirse todos los métodos que acceden buffer compartido. código asociado con competencia sincronización muestra figura .. fenómeno relacionado dispersión (scattering) ocurre cuando implementación una competencia individual ( requerimiento lógico conjunto requerimien-tos) dispersa través varios componentes del programa. probablemente esto ocu-rre cuando implementan requerimientos relacionados con competencias funcionales secundarias competencias política. por ejemplo, suponga que sistema gestión registros médicos, como mhc-pms, tiene algunos componentes que ocupan gestionar información del personal, los medicamentos, las consultas, las imágenes médicas, los diagnósticos tratamien-tos. decir, implementan competencia central del sistema: mantener registros los pacientes. sistema puede configurarse para diferentes tipos clínicas seleccionar los componentes que proporcionan funcionalidad necesaria para clínica. sin embargo, suponga que existe también una importante competencia secundaria que mantenimiento información estadística; proveedor código salud quiere registrar detalles cuántos pacientes admiten dan alta cada mes, cuántos pacientes mueren, qué medicamentos prescriben, las razones las consultas, etcétera. dichos requerimientos tienen que implementarse agregando código que vuelva anóni-mos los datos (para mantener privacidad los pacientes) los escriba una base datos estadística. componente estadístico procesa los datos estadísticos genera los reportes que requieren.figura . enredos código gestión sincronización buffersynchronized void put (sensorrecord rec ) { // comprueba que haya espacio buffer; espera ( numberofentries == bufsize) wait () ; // agrega registro final del bufferstore [back] = new sensorrecord (rec.sensorid, rec.sensorval) ; back = back + ;// está final del buffer, siguiente entrada está principioif (back == bufsize) back = ; numberofentries = numberofentries + ;// indica que buffer está disponible notify () ; } // put -.indd -.indd // :: // :: . ■ aspectos, puntos enlace puntos corte esto ilustra figura .. diagrama muestra ejemplos tres clases que pueden incluirse sistema registro pacientes junto con algunos los méto-dos centrales para gestionar información pacientes. área sombrada representa los métodos que requieren para implementar competencia estadística secundaria. como observa, esta competencia estadística dispersa largo las otras competencias centrales. los problemas con dispersión enredo ocurren cuando cambian los requeri-mientos iniciales del sistema. por ejemplo, suponga que deben recopilarse nuevos datos estadísticos sistema registro pacientes. los cambios sistema ubican todos lugar , por tanto, uno tiene que emplear tiempo buscando los componen-tes sistema que deban cambiarse. entonces preciso modificar cada uno estos componentes para incorporar los cambios requeridos. esto puede ser costoso debido tiempo que necesita para analizar los componentes , luego, para realizar probar los cambios. siempre existe posibilidad que pierda algo código que debe cam-biar , por consiguiente, las estadísticas serán incorrectas. más aún, cuanto más severos sean los cambios que deban realizarse, aumentará probabilidad que cometa una falla introduzcan errores software. . aspectos, puntos enlace puntos corte esta sección introducen los nuevos más importantes conceptos asociados con desarrollo software orientado aspectos ilustran mediante ejemplos del mhc-pms. terminología que utiliza fue introducida por los desarrolladores aspectj finales década . sin embargo, los conceptos son aplicación general específicos del lenguaje programación aspectj. figura . resume los términos clave que hay que entender. sistema registros médicos como mch-pms incluye componentes que mane-jan información relacionada lógicamente pacientes. componente patient (paciente) mantiene información personal acerca del paciente, componente medication (medica-ción) conserva información sobre los medicamentos que deben prescribirse, etcétera. diseñar sistema con enfoque basado componentes, pueden configurarse diferen-tes instancias del sistema. por ejemplo, podría configurarse una versión para cada tipo clínica que sólo permita los médicos prescribir medicamentos relevantes para figura . dispersión métodos que implementan competencias secundariaspaciente getname ()editname ()getaddress ()editaddress ()...anonymize ()...<decls atributoimagen getmodality ()archive ()getdate ()editdate ()...savediagnosis ()savetype ()...<decls atributoconsulta makeappoint ()cancelappoint ()assignnurse ()bookequip ()...anonymize ()saveconsult ()...<decls atributo -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos dicha clínica. esto simplifica labor del personal clínico reduce las posibilidades que médico prescriba por error medicamento equivocado. sin embargo, esta organización significa que información base datos debe actualizarse desde algunos lugares diferentes sistema. por ejemplo, información del paciente puede modificarse cuando sus datos personales cambian, prescribirle nuevo medicamento, asignarle nuevo especialista, etcétera. aras sencillez, suponga que todos los componentes del sistema usan una estrategia nomenclatura consistente que todas las actualizaciones base datos implementan mediante métodos que comienzan con “update”. por tanto, existen métodos sistema como: updatepersonalinformation (patientid, infoupdate) updatemedication (patientid, medicationupdate) paciente identifica mediante patientid los cambios realizar codifican segundo parámetro; los detalles esta codificación son importantes para este ejemplo. las actualizaciones realizan por personal del hospital, que ingresa sistema. imagine que ocurre una violación seguridad modifica maliciosamente infor-mación del paciente. tal vez alguien dejó por accidente computadora conectada sistema una persona autorizada entró mismo. alternativamente, una persona auto-rizada puede tener acceso modificar maliciosamente información del paciente. para reducir probabilidad que esto ocurra nuevamente, introduce una nueva política seguridad. antes realizar cualquier cambio base datos del paciente, per-sona que solicita cambio nuevo debe autenticarse sistema. los detalles quién hace cambio también registran archivo aparte. esto ayudará rastrear los problemas volvieran ocurrir. una forma implementar esta nueva política modificar método update - componente para llamar otros métodos realizar authentication (autenticación) figura . terminología usada ingeniería software orientada aspectostérmino definición consejo (advice) código que implementa una competencia. aspecto (aspect) una abstracción programa que define una competencia transversal. incluye definición punto corte ( pointcut) consejo (advice) asociado con dicha competencia. punto enlace ( join point) evento programa ejecución que puede ejecutarse consejo asociado con aspecto. modelo punto enlace ( join point model ) conjunto eventos que pueden referenciar punto corte. punto corte ( pointcut) enunciado, incluido aspecto, que define los puntos enlace que debe ejecutarse consejo del aspecto asociado. tejido (weaving) incorporación código del consejo (advice) los puntos enlace ( join point) especificados por tejedor (weaving) aspectos -.indd -.indd // :: // :: . ■ aspectos, puntos enlace puntos corte logging (conexión lógica). bien, sistema podría modificarse forma que cada vez que solicite método update, las llamadas del método agreguen antes del llamado para hacer authentication, después para registrar los cambios efectuados. sin embargo, ninguna éstas una excelente solución para este problema: . primer enfoque conduce una implementación enredada. lógicamente, actua- lizar una base datos, autenticar fuente una actualización registrar los -talles actualización son competencias ( concerns) relacionadas. tal vez usted quiera incluir authentication alguna otra parte del sistema sin ingresar sistema desee registrar las acciones separadas acción update (actualización). mismo código authentication logging debe incluirse dentro varios métodos diferentes. . enfoque alternativo conduce una implementación dispersa. explícitamente comprende llamadas método para hacer authentication logging antes después cada llamada los métodos update, entonces este código incluye sistema varios lugares diferentes. authentication logging cortan transversalmente las competencias centrales del sis-tema posiblemente deban incluirse varios lugares diferentes. sistema orien-tado aspectos, posible representar estas competencias transversales como aspectos separados. aspecto incluye una especificación dónde debe tejerse programa competencia transversal, código para implementar dicha competencia. esto ilustra figura ., que define aspecto authentication. notación que usa este ejemplo sigue estilo aspectj, pero usa una sintaxis simplificada que debe ser comprensible sin conocimiento java aspectj. los aspectos son completamente diferentes otras abstracciones del programa las que aspecto incluye una especificación torno dónde debe ejecutarse. aspect authentication { before: call (public void update* (..)) // éste punto corte{ // éste consejo –advice- que debe ejecutarse cuando teje –weaving- // sistema ejecuciónint tries = ; string userpassword = password.get ( tries ) ;while (tries < && userpassword != thisuser.password ( ) ){ // permite intentos para ingresar contraseña correctatries = tries + ;userpassword = password.get ( tries ) ; } (userpassword != thisuser.password ( )) then // contraseña equivocada, supone que usuario olvidó contraseñasystem.logout (thisuser.uid) ; } } // authentication figura . aspecto autenticación (aspect authentication) -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos con otras abstracciones, tales como los métodos, hay una separación clara entre defi- nición abstracción uso. examinar método, posible decir dónde llamará; las llamadas pueden ser desde cualquier parte que abarque método. contraste, los aspectos incluyen “punto corte” ( pointcut): enunciado que define dónde tejerá aspecto programa. este ejemplo, punto corte enunciado simple: before: call (public void update* (..)) significado esto que antes ejecución cualquier método cuyo nombre comience con cadena update, seguido por cualquier otra secuencia caracteres, debe ejecutarse código aspecto después definición punto corte. carácter asterisco (*) llama comodín (wildcard ) coincide con cualquier cadena caracteres que permite los identificadores. código ejecutar conoce como “advice” (consejo) implementación competencia transversal. este caso, consejo obtiene una contraseña persona que solicita cambio verifica que coincida con contraseña del usuario que ingresó recientemente sistema. concuerda, desconecta usuario procede actualización. habilidad para especificar, con puntos corte, dónde debe ejecutarse código característica distintiva los aspectos. sin embargo, para comprender qué significan los puntos corte, necesario entender otro concepto: idea punto enlace. punto enlace ( join point) evento que ocurre durante ejecución pro- grama; podría ser una llamada método, inicialización una variable, almacena-miento una actualización, etcétera. existen muchos tipos posibles eventos que pueden ocurrir durante ejecución del programa. modelo punto enlace define conjunto eventos que pueden referenciar programa orientado aspectos. los modelos punto enlace son estandarizados cada lenguaje programación orientado aspectos tiene pro-pio modelo punto enlace. por ejemplo, los eventos aspectj, que son parte del modelo punto enlace, incluyen: ■ eventos llamada: llamadas método constructor; ■ eventos ejecución: ejecución método constructor; ■ eventos inicialización: inicialización clase objeto; ■ eventos datos: acceso actualización archivo; ■ eventos excepciones: manejo una excepción. punto corte identifica evento eventos específicos (por ejemplo, una llamada procedimiento nombrado) con los que debe asociarse consejo. esto significa que posible tejer consejos programa muchos contextos diferentes, dependiendo del modelo punto enlace que soporte: . los consejos pueden incluirse antes ejecución método específico, una lista métodos nombrados una lista métodos cuyos nombres coincidan con una especificación patrón (como update*). -.indd -.indd // :: // :: . ■ aspectos, puntos enlace puntos corte . los consejos pueden incluirse después regreso normal excepcional método. ejemplo que muestra figura ., podría definir punto corte que ejecute código logging después todas las llamadas métodos update. . los consejos pueden incluirse cuando modifica archivo objeto; podrían incluir consejos para monitorizar cambiar ese archivo. inclusión consejos los puntos enlace especificados los puntos corte responsabilidad tejedor aspectos. los tejedores aspectos son extensiones compiladores que procesan definición los aspectos las clases objetos métodos que definen sistema. tejedor genera nuevo programa con los aspectos incluidos los puntos enlace especificados. los aspectos integran forma que las competencias transversales ejecuten los lugares correctos del sistema final. figura . ilustra este tejido aspectos para los aspectos authentication logging que deben incluirse mhc-pms. hay tres enfoques diferentes tejido aspectos: . preprocesamiento código fuente, que tejedor toma entrada código fuente genera nuevo código fuente lenguaje como java ++, que luego pueden compilarse usando compilador lenguaje estándar. este enfoque adoptó para lenguaje aspectx con asociado xweaver (birrer ., ). . tejido tiempo vinculación, que compilador modifica para incluir tejedor aspectos. lenguaje orientado aspectos, como aspectj, pro-cesa genera bytecode java estándar. entonces éste puede ejecutarse directamente mediante intérprete java procesarse aún más para generar código máquina nativo. . tejido dinámico tiempo ejecución. este caso, monitorizan los puntos enlace , cuando ocurre evento referenciado punto corte, integra consejo correspondiente con programa ejecución. enfoque usado más comúnmente para tejido aspectos tejido tiempo vinculación, pues esto permite implementación eficiente los aspectos sin una gran carga tiempo ejecución. tejido dinámico enfoque más flexible, pero puede incurrir significativas penalizaciones rendimiento durante ejecución del programa. actualmente preprocesamiento código fuente usa poco.aspecto authentication aspecto logging paciente ... updatedetails (...)...tejedor aspectospaciente ...código authenticationupdatedetails (...)código logging... figura . tejido aspectos -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos . ingeniería software con aspectos los aspectos introdujeron originalmente con lenguaje programación secuen- cias, pero, como estudió, noción competencias una que realmente proviene los requerimientos del sistema. por tanto, tiene sentido adoptar enfoque orientado aspectos todas las etapas del proceso desarrollo del sistema. las primeras etapas ingeniería software, adoptar enfoque orientado aspectos significa usar noción separación competencias como base para considerar los requerimientos diseño del sistema. identificar modelar las competencias debe ser parte ingeniería requerimientos diseño. los lenguajes programación orientados aspectos, pues, ofrecen soporte tecnológico para mantener separación las competencias implementación del sistema. cuando diseña sistema, jacobson () sugieren que debe considerarse que sistema soporte diferentes competencias las partes interesadas como sistema central más extensiones. esto ilustra figura ., donde usan paquetes uml para representar tanto núcleo como las extensiones. sistema central conjunto funciones del sistema que implementan propósito esencial del sistema. por consi-guiente, propósito sistema particular mantener información los pacientes hospital, sistema central tal caso ofrece medio para crear, editar, gestionar acceder una base datos registros pacientes. las extensiones del sistema central reflejan competencias adicionales las partes interesadas, que deben integrarse con sistema central. por ejemplo, importante que sistema información médica mantenga confidencialidad información los pacientes, manera que una extensión podría ocuparse del control del acceso, otra encriptación, etcétera. existen algunos tipos diferentes extensiones que derivan los distintos tipos competencias que estudiaron sección .. . extensiones funcionales secundarias agregan capacidades adicionales funcio- nalidad que ofrece sistema central. este caso, con ejemplo del mhc-pms, producción informes sobre los medicamentos prescritos mes anterior sería una extensión funcional secundaria para sistema información pacientes. . extensiones política agregan capacidades funcionales para soportar políticas organización. las extensiones que adicionan características seguridad son ejemplos extensiones política. . extensiones qos agregan capacidades funcionales para ayudar alcanzar los requerimientos calidad del servicio que especificaron para sistema. por ejemplo, una extensión podría implementar una caché para reducir número accesos base datos automatizar los respaldos para recuperación caso una falla del sistema. . extensiones infraestructura estas extensiones agregan capacidades funcionales para soportar implementación sistema alguna plataforma implemen-tación específica. por ejemplo, sistema información pacientes, pueden usarse extensiones infraestructura para implementar interfaz sistema ges-tión base datos subyacente. pueden hacerse cambios esta interfaz modifi-cando las extensiones infraestructura asociadas. -.indd -.indd // :: // :: . ■ ingeniería software con aspectos las extensiones siempre agregan algún tipo funcionalidad características adicio- nales sistema central. los aspectos son una forma implementar dichas extensiones pueden combinarse con funcionalidad del sistema central mediante las instalacio-nes tejido entorno programación orientado aspectos. .. ingeniería requerimientos orientados competencias como sugirió sección ., las competencias reflejan los requerimientos las partes interesadas. dichas competencias pueden reflejar funcionalidad requerida por participante, calidad servicio del sistema, políticas conflictos organiza-ción que relacionan con los atributos del sistema como todo. por tanto, tiene sen-tido adoptar enfoque ingeniería requerimientos que identifique especifique las diferentes competencias las partes interesadas. veces usa término “aspectos tempranos” para referirse uso aspectos etapas tempranas del ciclo vida del software donde enfatiza separación competencias. por muchos años reconocido importancia separar las competencias durante ingeniería requerimientos. los puntos vista que representan diferentes pers-pectivas sistémicas incorporan algunos métodos ingeniería requerimientos (easterbrook nuseibeh, ; finkelstein ., ; kotonya sommerville, ). estos métodos separan las competencias diferentes partes interesadas. los puntos vista reflejan distinta funcionalidad que requieren diferentes grupos participantes. sin embargo, también existen requerimientos que atraviesan todos los puntos vista, como muestra figura .. este diagrama indica que los puntos vista pueden ser diferentes tipos, pero las competencias transversales (como regulación, confiabilidad seguridad) generan requerimientos que pueden tener repercusiones todos los puntos vista del sistema. ésta fue principal consideración que hizo autor trabajo para desarrollar método preview (sommerville sawyer, ; sommerville ., ), que incluía pasos para identificar competencias transversales funcionales. para desarrollar sistema que esté organizado estilo que presenta figura ., hay que identificar los requerimientos para sistema central además los reque-rimientos para las extensiones del sistema. enfoque ingeniería requerimientos orientado puntos vista, que cada punto vista representa los requerimientos grupos participantes relacionados, una forma separar competencias centrales sistema centralextensión extensión extensión extensión extensión extensión figura . sistema central con extensiones -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos secundarias. los requerimientos organizan acuerdo con punto vista las partes interesadas, entonces usted podrá analizarlos para descubrir requerimientos rela-cionados que aparezcan todos mayoría los puntos vista. éstos representan funcionalidad central del sistema. otros requerimientos puntos vista pueden ser requerimientos que sean específicos dicho punto vista. éstos pueden implementarse como extensiones funcionalidad central. por ejemplo, imagine que usted desarrolla sistema software para rastrear equipo especializado que usan los servicios emergencia. equipo ubica diferentes lugares una región estado , caso una emergencia, como una inundación terremoto, los servicios emergencia emplean sistema para descubrir qué equipo está disponible cerca del sitio del problema. figura . muestra bosquejos reque-rimientos tres posibles puntos vista para tal sistema. este ejemplo observa que los participantes que representan los diferentes puntos vista deben encontrar ítems equipo específicos, navegar equipo disponible cada ubicación, ingresar/sacar equipo del almacén. por tanto, éstos son requerimien-tos para sistema central. los requerimientos secundarios soportan las necesidades más específicas cada punto vista. existen requerimientos secundarios para extensiones del sistema que soportan uso, gestión mantenimiento del equipo. los requerimientos funcionales secundarios que identifican partir cualquier punto vista atraviesan necesariamente los requerimientos otros puntos vista. por ejemplo, sólo punto vista mantenimiento está interesado por completar regis-tros mantenimiento. dichos requerimientos reflejan las necesidades ese punto vista tales competencias tal vez sean compartidas por otros puntos vista. sin embargo, además los requerimientos funcionales secundarios, existen competencias transversales que generan requerimientos importancia para algunos todos los puntos vista. con frecuencia, éstos reflejan requerimientos política calidad servicio que aplican sistema como todo. según estudió capítulo , trata requerimientos funcionales, como los requerimientos seguridad, rendimiento costo. sistema inventario equipo, ejemplo competencia transversal dis-ponibilidad del sistema. las emergencias pueden ocurrir con poca ninguna advertencia. salvar vidas puede requerir que equipo especial despliegue tan rápido como sea posible. por tanto, los requerimientos confiabilidad para sistema inventario puntos vista equipo usuarios gerentes organización sociedad regulacióncompetencias seguridad confiabilidadel sistema figura . puntos vista competencias -.indd -.indd // :: // :: . ■ ingeniería software con aspectos equipo incluyen requerimientos para alto nivel disponibilidad del sistema. figura . muestran algunos ejemplos estos requerimientos confiabilidad, con las razones asociadas. usar estos requerimientos posible identificar las extensiones funcionalidad central para logging transacción reporte estatus. esto facilita identificación problemas cambio sistema respaldo. resultado del proceso ingeniería requerimientos debe ser conjunto requerimientos que estructuran torno noción sistema central más exten-siones. por ejemplo, sistema inventario, los ejemplos requerimientos centrales pueden ser: . sistema debe permitir que los usuarios autorizados vean descripción algún ítem equipo inventario servicios emergencia.. usuarios del servicio emergencia . encontrar tipo específico equipo (por ejemplo, elevador cargas pesadas). . ver equipo disponible almacén específico.. retirar equipo.. ingresar equipo.. ordenar equipo para transportarlo una emergencia.. enviar reporte daño.. encontrar almacén cerca emergencia. . planificadores emergencias . encontrar tipo específico equipo. . ver equipo disponible una ubicación específica.. ingresar/retirar equipo almacén.. mover equipo almacén otro.. ordenar nuevo equipo. . personal mantenimiento . ingresar/retirar equipo para mantenimiento. . ver equipo disponible cada almacén.. encontrar tipo específico equipo.. ver calendario mantenimiento para ítem equipo.. completar registro mantenimiento para ítem equipo.. mostrar todos los ítems almacén que requieran mantenimiento. disp. debe existir sistema “ espera caliente” (hot standby) una ubicación que esté geográficamente bien separada del sistema principal. razón: emergencia puede afectar ubicación principal del sistema. disp.. todas las transacciones deben registrarse sitio del sistema principal sitio espera remoto. razón: esto permite que dichas transacciones reproduzcan que las bases datos del sistema sean consistentes. disp.. cada cinco minutos sistema debe enviar información estatus sistema sala control emergencias. razón: los operadores del sistema sala control pueden cambiar posición espera caliente cuando sistema principal esté disponible.figura . puntos vista sistema inventario equipo figura . requerimientos relacionados con disponibilidad para sistema inventario equipo -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos . sistema debe incluir una instalación búsqueda para permitir los usua- rios autorizados indagar inventarios individuales inventario completo ítem específico equipo tipo específico equipo. sistema también puede incluir una extensión que tenga propósito apoyar procuración sustitución equipo. los requerimientos para esta extensión pueden ser: . debe ser posible que usuarios autorizados realicen pedidos proveedores acre-ditados para sustituir los ítems equipo. .. cuando ordene ítem equipo, debe asignarse inventario específico marcarlo dicho inventario como “ pedido”. como regla general, hay que evitar tener demasiadas competencias extensiones sistema. esto simplemente confunde lector podría conducir diseño prematuro. además, limita libertad los diseñadores posible que por resultado diseño sistema que cumpla sus requerimientos calidad servicio. .. diseño programación orientada aspectos diseño orientado aspectos proceso diseñar sistema que utilice los aspec-tos para implementar las competencias transversales extensiones que identificaron durante proceso ingeniería requerimientos. esta etapa necesario traducir las competencias que relacionan con problema que hay que resolver los aspectos correspondientes programa que implementará solución. también indispensa-ble comprender cómo combinarán estos aspectos con otros componentes sistema garantizar que surjan ambigüedades composición. enunciado requerimientos alto nivel brinda una base para identificar algunas extensiones del sistema que puedan implementarse como aspectos. entonces necesa-rio desarrollarlos con mayor detalle para identificar más extensiones comprender funcionalidad solicitada. una forma hacerlo identificar conjunto casos uso (que explicaron los capítulos ) asociados con cada punto vista. los modelos caso uso enfocan interacción son más detallados que los requerimientos usuario. puede considerarlos como puente entre los requerimientos diseño. puntos vista noción puntos vista introdujo capítulo , donde explicó modo que pueden usarse los puntos vista como una forma estructurar los requerimientos diferentes partes interesadas. usar puntos vista, posible identificar los requerimientos del sistema central cada agrupamiento participantes. http:// -.indd -.indd // :: // :: . ■ ingeniería software con aspectos modelo caso uso describen los pasos cada interacción usuario así comienza identificar definir las clases sistema. jacobson () escribieron libro que explica cómo pueden usarse los casos uso ingeniería software orientada aspectos. sugieren que cada caso uso representa aspecto, proponen extensiones enfoque caso uso para apoyar los puntos enlace puntos corte. también introducen noción rebanadas caso uso módulos caso uso. ellos incluyen fragmentos clases que implementan aspecto. pueden combinarse para crear sistema completo. figura . muestra ejemplos tres casos uso que pueden ser parte del sis-tema gestión inventario. éstos reflejan las competencias agregar equipo inventario ordenar equipo. solicitud equipo adición equipo son compe-tencias relacionadas. una vez entregados los artículos solicitados, deben agregarse inventario entregarse uno los almacenes equipo. uml incluye noción casos uso extensión. caso uso exten-sión extiende funcionalidad hacia otro caso uso. figura . indica cómo colocación una petición equipo extiende caso uso central para agregar equipo almacén específico. equipo agregar existe, puede solicitarse agregarse almacén cuando entregue equipo. durante desarrollo los modelos caso uso habrá que buscar las características comunes , donde sea posible, estructurar los casos uso como casos centrales más extensiones. las características transversa-les, como registro lógico todas las transacciones, también pueden representarse como casos uso extensión. jacobson discuten cómo las extensiones este tipo pueden implementarse como aspectos.agregar equipo almacén operadorremover equipodel almacén hacer pedidode equipofigura . casos uso del sistema gestión inventario agregar equipo almacénrealizar pedidode equipo operador«extiende» figura . casos uso extensión -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos desarrollo proceso efectivo para diseño orientado aspectos resulta esen- cial diseño orientado aspectos debe aceptarse usarse. sugiere que proceso diseño orientado aspectos incluya las actividades que muestran figura .. dichas actividades son: . diseño del sistema central esta etapa diseña arquitectura del sistema para soportar funcionalidad central del sistema. arquitectura debe considerar tam-bién los requerimientos calidad servicio, como los requerimientos rendi-miento confiabilidad. . identificación diseño aspectos partir las extensiones identificadas los requerimientos del sistema, habrá que efectuar análisis para ver son aspectos mismos deben descomponerse varios aspectos. una vez identificados los aspectos, pueden diseñarse por separado tomando cuenta diseño las caracte-rísticas del sistema central. . diseño composición esta etapa analiza sistema central los diseños aspectos para descubrir dónde deben combinarse los aspectos con sistema central. esencia, identifican los puntos enlace programa donde tejerán los aspectos. . análisis resolución conflictos problema con los aspectos que pueden interferir entre cuando combinan con sistema central. los conflictos ocu-rren haber choque puntos corte con diferentes aspectos que especifican que deben combinarse mismo punto del programa. sin embargo, puede haber conflictos más sutiles. cuando los aspectos diseñan manera independiente, realizan suposiciones acerca funcionalidad del sistema central que debe modi-ficarse. obstante, cuando combinan varios aspectos, aspecto podría afectar funcionalidad del sistema una forma anticipada por otros aspectos. entonces comportamiento global del sistema quizá sea esperado. . diseño nombre ésta una importante actividad diseño que define están-dares para nombrar las entidades del programa. esto importante para evitar problema puntos corte accidentales. éstos ocurren cuando, algún punto enlace del programa, nombre coincide accidentalmente con patrón punto corte. consecuencia, consejo aplica manera intencional dicho punto. desde luego, esto indeseable puede conducir comportamiento inesperado del programa. por tanto, habrá que diseñar esquema nomencla-tura que minimice probabilidad que esto ocurra.requerimientos softwareestándares del programa nomenclaturamodelos diseñodiseño del sistema centralidentificación diseño aspectosdiseño composiciónanálisis resolución conflictosdiseño nombre figura . proceso diseño genérico orientado aspectos -.indd -.indd // :: // :: . ■ ingeniería software con aspectos este proceso, naturalmente, proceso iterativo que usted hace propuestas diseño iniciales luego las refina conforme analiza comprende los conflictos del diseño. por general, esperaría refinar las extensiones identificadas los requerimien-tos mayor número aspectos. resultado del proceso diseño orientado aspectos modelo diseño orien-tado aspectos. esto puede expresarse una versión extendida del uml que incluye nuevas sentencias específicas aspectos, tales como las propuestas por clarke baniassad () jacobson (). los elementos esenciales del “uml aspec-tos” son medio para modelar aspectos especificar los puntos enlace donde deben combinarse los consejos aspecto con sistema central. figura . ejemplo modelo diseño orientado aspectos. usó estereotipo uml para aspecto propuesto por jacobson . figura . muestra sistema central para inventario servicios emergencia más algunos aspectos que pueden combinarse con dicho núcleo. exponen algunas clases del sistema central algunos aspectos. ésta una imagen simplificada; modelo completo incluiría más clases aspectos. observe cómo usaron las notas uml para ofrecer información adi-cional acerca las clases que son atravesadas (cross-cut) por algunos aspectos. figura . modelo más detallado aspecto. desde luego, antes diseñar aspectos, hay que tener diseño del sistema central. como aquí hay espacio para mostrar esto, hicieron algunas suposiciones acerca las clases los métodos sistema central. primera sección del aspecto establece los puntos corte que especifican dónde combinarán con sistema central. por ejemplo, primer punto corte especifica que aspecto puede combinarse punto enlace call getiteminfo(..). siguiente sección define las extensiones que implementa aspecto. este ejemplo, enunciado extensión puede leerse como: método viewitem, después llamar método getiteminfo, debe incluirse llamado método displayhistory para mostrar registro mantenimiento. programación orientada aspectos (aop, por las siglas aspect-oriented pro- gramming) inició los laboratorios parc xerox, , con desarrollo del inventario«aspecto» monitor equipo almacén ubicaciónbitácora«aspecto» mantenimiento «aspecto» pedido«aspecto» disponibilidadplataforma «punto enlace» ubicación equipo«punto enlace» plataforma figura . modelo diseño orientado aspectos -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos lenguaje programación aspectj. éste sigue siendo lenguaje orientado aspectos usado más ampliamente, aunque han implementado también extensiones orienta-das aspectos otros lenguajes, tales como # ++. además, han desarrollado otros lenguajes experimentales para soportar separación explícita las competencias composición competencias, existe implementación experimental aop framework .net. programación orientada aspectos cubre manera extensa otros libros (colyer ., ; gradecki lezeiki, ; laddad, ). usted siguió enfoque orientado aspectos para diseñar sistema, identificó funcionalidad central las extensiones para que dicha funcionalidad implemente como aspectos transversales. enfoque del proceso programación debe ser entonces escribir código que implemente funcionalidad central extensión, , manera fun-damental, especificar los puntos corte los aspectos para que consejo del aspecto teja código base los lugares correctos. muy importante especificar manera correcta los puntos corte, pues éstos definen dónde combinarán los consejos aspecto con funcionalidad central. comete error especificación del punto corte, entonces consejo del aspecto tejerá programa lugar equivocado. esto podría conducir comporta-miento inesperado impredecible del programa. esencial respetar los estándares nomenclatura establecidos durante diseño del sistema. también necesario revisar todos los aspectos para garantizar que ocurra interferencia aspectos dos más aspectos tejen sistema central mismo punto enlace. general, mejor evitar esto por completo, pero, ocasiones, puede ser mejor forma para implementar una competencia. tales circunstancias, hay que asegurarse que los aspectos son completamente independientes. comportamiento del programa debe depender del orden que los aspectos tejan programa. .. verificación validación como estudió capítulo , verificación validación implican demostrar que programa cumple especificación (verificación) satisface las necesidades reales las partes interesadas (validación). las técnicas verificación estática enfocan aná-lisis manual automatizado del código fuente del programa. validación las pruebas dinámicas usan para descubrir defectos programa demostrar que programa «aspecto» mantenimiento pointcuts viewmain = call getiteminfo (..)mainco = call removeitem (..)mainci = call additem (..) extensiones clase viewmaintenance history <viewitem {after (<viewmain)displayhistory} más extensiones aquífigura . parte modelo aspecto -.indd -.indd // :: // :: . ■ ingeniería software con aspectos cumple con sus requerimientos. cuando detección defectos objetivo, proceso prueba puede guiarse mediante conocimiento del código fuente del programa. las métricas cobertura prueba muestran efectividad las pruebas para hacer que los enunciados del código fuente sean ejecutables. para los sistemas orientados aspectos, los procesos las pruebas validación son diferentes los cualquier otro sistema. programa final ejecutable trata como una caja negra diseñan pruebas para demostrar sistema cumple con los requerimientos. sin embargo, uso aspectos causa problemas reales con las ins-pecciones programa las pruebas caja blanca, mientras que código fuente del programa usa para identificar potenciales pruebas defecto. las inspecciones programa, que describen capítulo , implican equipo lectores que observan código fuente programa para descubrir defectos que haya introducido programador. una técnica muy efectiva descubrimiento defectos. sin embargo, los programas orientados aspectos pueden leerse secuencial-mente (esto , arriba abajo). por tanto, más difícil que gente los comprenda. lineamiento general para comprensibilidad del programa que lector pueda leer programa izquierda derecha sin tener que cambiar atención hacia otras partes del código. esto hace más sencillo para los lectores también hace menos probable que los programadores cometan errores mientras atención enfoca una sola sección código. mejorar legibilidad del programa fue una razón clave para introducción programación estructurada (dijkstra ., ) eliminación los enunciados ramificación incondicional (-) los lenguajes programación alto nivel. sistema orientado aspectos, imposible lectura código secuencial. lector debe examinar cada aspecto, comprender sus puntos corte (que pueden ser patrones) modelo punto enlace del lenguaje orientado aspectos. leer programa, tiene que identificar todo punto enlace potencial entonces cambiar atención código aspecto para ver puede tejerse dicho punto. luego, aten-ción regresa flujo principal control del código base. realidad, esto cognitiva-mente imposible única forma inspeccionar programa orientado aspectos mediante uso herramientas lectura código. pueden escribirse herramientas lectura código que “aplanen” programa orientado aspectos presenten programa lector con los aspectos “tejidos” programa los puntos enlace especificados. sin embargo, ésta una solución completa problema lectura código. modelo punto enlace lenguaje programación orientado aspectos puede ser dinámico vez estático, quizá sea imposible demostrar que programa aplanado comportará exactamente misma forma que programa que ejecutará. más aún, como posible que diferentes aspectos tengan misma especificación punto corte, herramienta lectura programa debe saber cómo tejedor aspectos maneja dichos aspectos “ competencia” cómo ordenará combinación. las pruebas caja blanca pruebas estructurales son enfoque sistemático las pruebas donde usa conocimiento del código fuente del programa para diseñar prue-bas defecto. meta diseñar pruebas que proporcionen algún nivel cobertura programa. esto , conjunto pruebas debe garantizar que ejecute toda ruta lógica través del programa, con consecuencia que cada enunciado programa efectúe menos una vez. pueden usarse analizadores ejecución programa para demostrar que logra este nivel cobertura pruebas. -.indd -.indd // :: // :: capítulo ■ ingeniería software orientada aspectos sistema orientado aspectos, existen dos problemas con este enfoque: . ¿cómo puede usarse conocimiento del programa para derivar sistemáticamente pruebas del programa? . ¿qué significa exactamente cobertura prueba? para diseñar pruebas programa estructurado (por ejemplo, pruebas del código método) sin ramificaciones incondicionales, usted puede derivar gráfico flujo programa, que revele toda ruta ejecución lógica través dicho programa. entonces examina código , para cada ruta través del gráfico flujo, eligen valores entrada que harán que ruta ejecute. sin embargo, programa orientado aspectos programa estructurado. flujo control interrumpe mediante enunciados “viene ” (constantinos ., ). algún punto enlace ejecución del código base, puede ejecutarse aspec-. autor está seguro que tal situación sea posible construir diagrama flujo estructurado. por tanto, difícil diseñar sistemáticamente pruebas programa que garanticen ejecución todas las combinaciones código base los aspectos. programa orientado aspectos, existe también problema decidir qué signi-fica “cobertura prueba”. ¿significa que código cada aspecto ejecuta menos una vez? ésta una condición muy débil, debido interacción entre los aspectos código base los puntos enlace donde tejen los aspectos. ¿ idea cobertura prueba debe extenderse manera que código del aspecto ejecute menos una vez cada punto enlace especificado punto corte del aspecto? tales situaciones, ¿qué sucede diferentes aspectos definen mismo punto corte? trata problemas tanto teóricos como prácticos. necesitan herramientas para soportar las pruebas los programas orientados aspectos, que ayudarán valorar medida obertura pruebas sistema. como estudiará capítulo , los grandes proyectos tienen por general equipo aseguramiento calidad separado, que establece los estándares las prue-bas requiere aseguramiento formal que las revisiones pruebas del sistema completan bajo dichos estándares. los problemas inspeccionar derivar pruebas para programas orientados aspectos son una significativa barrera para adopción del desa-rrollo software orientado aspectos los proyectos software grandes. además los problemas con las inspecciones las pruebas caja blanca, katz () identificó problemas adicionales las pruebas los programas orientados aspectos: . ¿cómo deben especificarse los aspectos manera que puedan derivarse pruebas para dichos aspectos? . ¿cómo pueden probarse los aspectos independientemente del sistema base con que deben tejerse? . ¿cómo puede someterse prueba interferencia aspectos? como estudió, interferencia aspectos ocurre cuando dos más aspectos usan misma especifi-cación punto corte. . ¿cómo pueden diseñarse pruebas manera que ejecuten todos los puntos enlace programa apliquen pruebas aspecto adecuadas? -.indd -.indd // :: // :: pmcapítulo ■ lecturas sugeridas esencia, estos problemas con las pruebas ocurren porque los aspectos están estre- chamente integrados con código base sistema. por tanto, son difíciles probar aislamiento. puesto que están tejidos programa muchos lugares dife-rentes, podemos estar seguros que aspecto que funciona con éxito punto enlace funcionará necesariamente todos los puntos enlace. todos éstos siguen siendo problemas investigación para desarrollo software orientado aspectos. puntos clave ■ principal beneficio enfoque orientado aspectos desarrollo software que soporta separación competencias. representar las competencias transversales como aspectos, las competencias individuales pueden entenderse, reutilizarse modificarse sin cambiar otras partes del programa. ■ enredo ocurre cuando módulo sistema incluye código que implementa diferentes requerimientos del sistema. fenómeno relacionado dispersión ocurre cuando implementación una sola competencia dispersa través varios componentes programa. ■ los aspectos incluyen punto corte ( enunciado que define dónde tejerá aspecto dentro del programa) consejos ( código para implementar competencia transversal). los puntos enlace son los eventos que pueden referenciar punto corte. ■ para garantizar separación las competencias, los sistemas pueden diseñarse como sistema central que implementa las principales competencias las partes interesadas, conjunto extensiones que implementan competencias secundarias. ■ para identificar las competencias puede usar enfoque ingeniería requerimientos orientado puntos vista, que permita recuperar los requerimientos las partes interesadas identificar calidad servicio transversal las competencias política. ■ transición requerimientos diseño puede hacerse identificando casos uso, cada uno los cuales representa una competencia las partes interesadas. diseño puede modelarse mediante una versión extendida del uml con estereotipos aspectos. ■ los problemas inspeccionar derivar pruebas para programas orientados aspectos son una barrera significativa para adopción del desarrollo software orientado aspectos los proyectos software grandes. lecturas sugeridas “aspect-oriented programming”. este número especial del cacm cuenta con algunos artículos dirigidos público general, que son buen punto partida para leer acerca programación orientada aspectos. (comm. acm, (), octubre .)http:/ /. doi. org/ . / . . -.indd -.indd // :: // :: pmaspect-oriented software development. libro escrito por diferentes autores conjunto, quienes presentan una gran variedad ensayos sobre desarrollo software orientado aspectos; entre sus autores encuentran muchos los investigadores líderes campo. (. . filman,. elrad, . clarke . aksit, addison-wesley, .) aspect-oriented software development with use cases. éste libro práctico para diseñadores software. los autores analizan cómo usar casos uso para gestionar separación competencias utilizarlos como base diseño orientado aspectos. (. jacobson . , addison-wesley, .) ejercicios .. ¿cuáles son los diferentes tipos competencias las partes interesadas que pueden surgir sistema grande? ¿cómo pueden los aspectos soportar implementación cada uno estos tipos competencias? .. resuma qué entiende por enredos dispersión. con ejemplos, explique por qué los enredos dispersión pueden causar problemas cuando cambian los requerimientos del sistema. .. ¿cuál diferencia entre punto enlace punto corte? explique cómo éstos facilitan tejido código programa para manejar las competencias transversales. .. ¿qué suposiciones subyacen idea que sistema debe estar organizado como sistema central que implemente los requerimientos esenciales, más extensiones que implementen funcionalidad adicional? ¿puede pensar sistemas donde este modelo sería adecuado? .. ¿cuáles puntos vista deben considerarse cuando desarrollan especificaciones requerimientos para mhc-pms? ¿cuáles son probablemente las competencias transversales más importantes? .. considerando funcionalidad para cada punto vista mostrado figura ., identifique seis casos uso para sistema inventario equipo, además aquellos que indican figura .. cuando sea adecuado, indique cómo algunos éstos podrían organizarse como extensión casos uso. .. con notación estereotipo aspectos que ilustró figura ., desarrolle con más detalle los aspectos pedido monitor, que muestran figura .. .. explique cómo puede surgir interferencia aspectos sugiera que debería hacerse durante proceso diseño del sistema para reducir los problemas interferencia aspectos. .. explique por qué expresar las especificaciones punto corte como patrones aumenta los problemas probar los programas orientados aspectos. para responder, piense cómo las pruebas los programas implican generalmente una comparación salida esperada con salida real producida por programa. .. sugiera cómo podría usar aspectos para simplificar depuración programas. capítulo ■ ingeniería software orientada aspectos -.indd -.indd // :: // :: pmcapítulo ■ referencias referencias birrer, ., pasetti, . rohlik, . (). “the xweaver project: aspect-oriented programming for -board applications”. http://control..ethz./index.cgi?page=publications;action=details;= clark, . baniassad, . (). aspect-oriented analysis and design: the theme approach . harlow, : addison-wesley.colyer, . clement, . (). “aspect-oriented programming with aspectj”. ibm systems ., (), –.colyer, ., clement, ., harley, . webster, . (). eclipse aspectj. upper saddle river, : addison-wesley. constantinos, ., skotiniotis, . stoerzer, . (). “aop considered harmful”. european interactive workshop aspects software (eiwas’), berlín, alemania.dijkstra, . ., dahl, . . hoare, . . . (). structured programming. londres: academic press. easterbrook, . nuseibeh, . (). “using viewpoints for inconsistency management”. bcs/iee software eng. ., (), –. finkelstein, ., kramer, ., nuseibeh, . goedicke, . (). “viewpoints: framework for integrating multiple perspectives system development”. int. . software engineering and knowledge engineering, (), –. gradecki, . . lezeiki, . (). mastering aspectj: aspect-oriented programming java . nueva york: john wiley & sons.jacobson, . , -. (). aspect-oriented software development with use cases . boston: addison-wesley.katz, . (). “ survey verification and static analysis for aspects”. http:// kiczales, ., hilsdale, ., hugunin, ., kersten, ., palm, . griswold, . . (). “getting started with aspectj”. comm. acm, (), –. kotonya, . sommerville, . (). “requirements engineering with viewpoints”. bcs/iee software eng. ., (), –. laddad, . (). aspectj action. greenwich, conn.: manning publications .laddad, . (). aspectj action: practical aspect-oriented programming. greenwich, conn.: manning publications. sommerville, . sawyer, . (). “viewpoints: principles, problems and practical approach requirements engineering”. annals software engineering, –. sommerville, ., sawyer, . viller, . (). “viewpoints for requirements elicitation: practical approach”. int. conf. requirements engineering. colorado: ieee computer society press, –. -.indd -.indd // :: // :: pmm-.indd -.indd // :: // :: pmalgunas veces dicho que diferencia principal entre ingeniería software otros tipos programación radica que primera proceso gestión. debido ello entiende que desarrollo software tiene lugar dentro una organización está sujeto una variedad res-tricciones tiempo, presupuesto organizacionales. por tanto, para ingeniería software, gestión muy importante. esta parte del libro presentan varios temas administración con enfoque conflictos gestión técnica cuestiones administrativas “más suaves”, como gestión personal gestión más estratégica los sistemas empre-sariales. capítulo introduce gestión proyectos software, primera sección principal refiere gestión del riesgo. junto con planea-ción proyectos, gestión del riesgo, que los gestores identifican aquello que puede salir mal planean que pueden hacer respecto, una responsabilidad clave gestión del proyecto. este capítulo incluye también secciones acerca gestión personal trabajo equipo. capítulo comprende planeación estimación proyectos. exponen las gráficas barras como herramientas fundamentales planeación explica por qué desarrollo dirigido por plan seguirá siendo importante enfoque desarrollo, pesar del éxito los parte software -.indd -.indd // :: // :: pmmétodos ágiles. también analizan los conflictos que influyen pre- cio que cobra por sistema las técnicas estimación costo software. usa familia modelos costo cocomo para describir modelado algorítmico costos explicar los beneficios las desven-tajas este enfoque. los últimos tres capítulos (del ) ocupan cuestiones referen- tes gestión calidad. ésta tiene que ver con los procesos las técnicas para garantizar mejorar calidad del software, tema que presenta capítulo . estudia importancia los estándares gestión calidad, uso revisiones inspecciones proceso aseguramiento calidad papel medición del software gestión calidad. capítulo explica administración configuración. éste tema relevante para todos los sistemas grandes que desarrollan los equi-pos. sin embargo, necesidad administración configuración siempre clara para los estudiantes, quienes sólo interesan por desarrollo software personal; por ello, describen aquí los diver-sos aspectos este tema, incluida planeación configuración, gestión versiones, construcción sistemas administración del cambio. finalmente, capítulo ocupa del mejoramiento del proceso software: ¿cómo pueden modificarse los procesos para que mejoren tanto los atributos del producto como del proceso? estudian las eta-pas proceso mejoramiento proceso genérico, esto , medición, análisis cambio proceso. posteriormente, analiza enfoque basado capacidades sei para mejoramiento proce-sos describen brevemente los modelos capacidad madurez. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo gestión proyectos software dos importantes actividades relacionadas, esto , gestión del riesgo personal. estudiar este capítulo: ■ conocerá las principales tareas los administradores proyectos software; ■ introducirá noción gestión del riesgo algunos los riesgos que pueden surgir los proyectos software; ■ comprenderá los factores que influyen motivación personal qué significan para los administradores proyectos software; ■ entenderá los conflictos clave que influyen trabajo equipo, tales como composición del equipo, organización comunicación. contenido . gestión del riesgo . gestión personal . trabajo equipo gestión proyectos -.indd -.indd // :: // :: capítulo ■ gestión proyectos gestión proyectos software una parte esencial ingeniería software. los proyectos necesitan administrarse porque ingeniería software profesional está sujeta siempre restricciones organizacionales presupuesto fecha. trabajo del administrador del proyecto asegurarse que proyecto software cumpla supere tales restriccio-nes, además que entregue software alta calidad. buena gestión puede garantizar éxito del proyecto. sin embargo, mala gestión, por general, como resultado una falla del proyecto: software puede entregarse tarde, costar más estimado original-mente cumplir las expectativas los clientes. desde luego, los criterios éxito para gestión del proyecto varían proyecto otro, pero, para mayoría los proyectos, las metas importantes son: . entregar software cliente tiempo acordado. . mantener costos dentro del presupuesto general. . entregar software que cumpla con las expectativas del cliente. . mantener equipo desarrollo óptimo con buen funcionamiento. tales metas son únicas para ingeniería software, pero son para todos los proyectos ingeniería. sin embargo, ingeniería software diferente algunas formas otros tipos ingeniería que hacen gestión del software particularmente desafiante. algunas estas diferencias son: . producto intangible administrador astillero proyecto inge- niería civil pueden ver producto conforme desarrolla. hay retraso calen-dario, visible efecto sobre producto: evidente que algunas partes estructura están terminadas. software intangible. puede ver tocar. los administradores proyectos software pueden constatar progreso con sólo observar artefacto que construye. más bien, ellos apoyan otros para crear prueba que pueden utilizar revisar progreso del trabajo. . los grandes proyectos software con frecuencia son proyectos excepcionaleslos grandes proyectos software consideran general diferentes ciertas for-mas los proyectos anteriores. por eso, incluso los administradores que cuentan con vasta experiencia pueden encontrar difícil anticiparse los problemas. aunado esto, los vertiginosos cambios tecnológicos computadoras comunicaciones pueden volver obsoleta experiencia administrador. las lecciones aprendidas pro-yectos anteriores pueden ser aplicables nuevos proyectos. . los procesos software son variables específicos organización proceso ingeniería para algunos tipos sistema, como puentes edificios, bastante comprendido. sin embargo, los procesos software varían considerablemente una organización otra. aunque producido notorio avance estandari-zación mejoramiento los procesos, posible predecir manera confiable cuándo proceso software particular conducirá problemas desarrollo. esto especialmente cierto proyecto software parte proyecto ingeniería sistemas más amplio. debido estos conflictos, sorpresivo que algunos proyectos software retrasen excedan presupuesto. menudo, los sistemas software son nuevos -.indd -.indd // :: // :: . ■ gestión del riesgo técnicamente innovadores. los proyectos ingeniería (como los nuevos sistemas transporte) que son reformadores, normalmente también tienen problemas calendario. dadas las dificultades, quizá sea asombroso que tantos proyectos software ¡ entre-guen tiempo dentro del presupuesto! imposible efectuar una descripción laboral estándar para administrador pro-yecto software. labor varía enormemente función organización producto software desarrollar. obstante, mayoría los administradores, alguna etapa, toman responsabilidad varias todas las siguientes actividades: . planeación del proyecto los administradores proyecto son responsables planeación, estimación calendarización del desarrollo del proyecto, así como asignación tareas las personas. supervisan trabajo para verificar que realice acuerdo con los estándares requeridos monitorizan avance para com-probar que desarrollo esté tiempo dentro del presupuesto. . informes los administradores proyectos por común son responsables informar del avance proyecto los clientes administradores compañía que desarrolla software. deben ser capaces comunicarse varios niveles, desde codificar información técnica detallada hasta elaborar resúmenes administra-tivos. deben redactar documentos concisos coherentes que sinteticen información crítica reportes detallados del proyecto. necesario que esta información presente durante las revisiones avance. . gestión del riesgo los administradores proyecto tienen que valorar los riesgos que pueden afectar proyecto, monitorizar dichos riesgos emprender acciones cuando surjan problemas. . gestión personal los administradores proyecto son responsables admi-nistrar equipo personas. deben elegir los integrantes sus equipos esta-blecer formas trabajar que conduzcan desempeño efectivo del equipo. . redactar propuestas primera etapa proyecto software puede implicar escribir una propuesta para obtener contrato trabajo. propuesta describe los objetivos del proyecto cómo realizará. por general, incluye estimaciones costo calendarización, además justificar por qué contrato del proyecto debe-ría concederse una organización equipo particular. escritura propues-tas una tarea esencial, pues supervivencia muchas compañías software depende contar con suficientes propuestas aceptadas concesiones contratos. posible que haya lineamientos establecidos para esta tarea; escritura propuestas una habilidad que adquiere través práctica experiencia. este capítulo nos centraremos gestión del riesgo gestión personal. planeación proyectos tema importante por derecho propio, que estudia capítulo . . gestión del riesgo gestión del riesgo una las tareas más sustanciales para administrador pro-yecto. gestión del riesgo implica anticipar riesgos que pudieran alterar calendario del -.indd -.indd // :: // :: capítulo ■ gestión proyectos proyecto calidad del software entregar, posteriormente tomar acciones para evitar dichos riesgos (hall, ; ould, ). podemos considerar riesgo como algo que preferible que ocurra. los riesgos pueden amenazar proyecto, software que desarrolla organización. por tanto, existen tres categorías relacionadas riesgo: . riesgos del proyecto los riesgos que alteran calendario los recursos del pro- yecto. ejemplo riesgo proyecto renuncia diseñador experimen-tado. encontrar diseñador reemplazo con habilidades experiencia adecuadas puede demorar mucho tiempo , consecuencia, diseño del software tardará más tiempo completarse. . riesgos del producto los riesgos que afectan calidad rendimiento del soft-ware desarrollar. ejemplo riesgo producto falla que presenta componente que adquirió desempeñarse como esperaba. esto puede afec-tar rendimiento global del sistema, modo que más lento previsto. . riesgos empresariales riesgos que afectan organización que desarrolla - quie software. por ejemplo, competidor que introduce nuevo producto riesgo empresarial. introducción producto competitivo puede significar que las suposiciones hechas sobre las ventas los productos software existentes sean excesivamente optimistas. desde luego, estos tipos riesgos traslapan. programador experimentado abandona proyecto, esto puede ser riesgo del proyecto porque, incluso susti-tuye manera inmediata, calendario alterará. siempre requiere tiempo para que nuevo miembro del proyecto comprenda trabajo realizado, manera que puede ser inmediatamente productivo. consecuencia, entrega del sistema podría demo-rarse. salida miembro del equipo también puede ser riesgo del producto, por-que sustituto tal vez sea tan experimentado , por tanto, podría cometer errores programación. finalmente, puede ser riesgo empresarial, porque experiencia dicho programador vital para obtener nuevos contratos. necesario registrar los resultados del análisis del riesgo plan del proyecto, junto con análisis consecuencias, que establece las consecuencias del riesgo para proyecto, producto empresa. gestión riesgos efectiva facilita hacer frente los problemas asegurar que éstos conduzcan presupuesto inaceptable retra-sos calendario. los riesgos específicos que podrían afectar proyecto dependen del proyecto entorno organización donde desarrolla software. sin embargo, también existen riesgos comunes que relacionan con tipo software desarrollar que pue-den ocurrir cualquier proyecto. figura . muestran algunos estos riesgos comunes. gestión del riesgo particularmente importante para los proyectos software, debido incertidumbre inherente que enfrentan mayoría proyectos. ésta deriva requerimientos vagamente definidos, cambios requerimientos que obedecen cambios las necesidades del cliente, dificultades estimar tiempo los recursos requeridos para desarrollo software, bien, deriva diferencias las habilidades individuales. necesario anticipar los riesgos; comprender efecto estos riesgos sobre proyecto, producto empresa; dar los pasos adecuados para evitar dichos riesgos. tal vez nece-site diseñar planes contingencia manera que, ocurren los riesgos, puedan tomar acciones inmediatas recuperación. -.indd -.indd // :: // :: . ■ gestión del riesgo figura . ilustra una idea general del proceso gestión del riesgo. comprende varias etapas: . identificación del riesgo hay que identificar posibles riesgos para proyecto, producto empresa. . análisis riesgos debe valorar probabilidad las consecuencias dichos riesgos. . planeación del riesgo indispensable elaborar planes para enfrentar riesgo, evitarlo minimizar sus efectos proyecto. . monitorización del riesgo hay que valorar regularmente riesgo los planes para atenuarlo, revisarlos cuando aprenda más sobre riesgo. preciso documentar los resultados del proceso gestión del riesgo plan gestión del riesgo. éste debe incluir estudio los riesgos que enfrenta proyecto, análisis dichos riesgos información cómo gestionará riesgo cuando probable que convierta problema. proceso gestión del riesgo proceso iterativo que continúa largo del proyecto. una vez desarrollado plan gestión del riesgo inicial, monitoriza situación para detectar riesgos emergentes. conforme está disponible más información referente los riesgos, habrá que volver analizar los riesgos decidir cambió prio-ridad del riesgo. entonces tal vez sea necesario cambiar los planes para evitar riesgo gestionar contingencia.riesgo repercute descripción rotación personal proyecto personal experimentado abandonará proyecto antes que éste termine. cambio administrativo proyecto habrá cambio gestión organización con diferentes prioridades. indisponibilidad hardware proyecto hardware, que esencial para proyecto, entregará tiempo. cambio requerimientos proyecto producto habrá mayor cantidad cambios los requerimientos que los anticipados. demoras especificación proyecto producto especificaciones interfaces esenciales están disponibles tiempo. subestimación del tamaño proyecto producto subestimó tamaño del sistema. bajo rendimiento las herramientas caseproducto las herramientas case, que apoyan proyecto, desempeñan como anticipaba. cambio tecnológico empresa tecnología subyacente sobre cual construye sistema sustituye con nueva tecnología. competencia productos empresa producto competitivo comercializa antes que sistema esté completo. figura . ejemplos riesgos comunes para proyecto, producto empresa -.indd -.indd // :: // :: capítulo ■ gestión proyectos .. identificación del riesgo identificación del riesgo primera etapa del proceso gestión del riesgo. ocupa identificar los riesgos que pudieran plantear una mayor amenaza proceso ingeniería software, software desarrollar, organización que desarrolla. identificación del riesgo puede ser proceso equipo que este último reúne para pensar posibles riesgos. bien, administrador del proyecto, con base experiencia, identifica los riesgos más probables críticos. como punto partida para identificación del riesgo, recomienda utilizar una lista verificación diferentes tipos riesgo. existen menos seis tipos riesgos que pueden incluirse una lista verificación: . riesgos tecnológicos derivan las tecnologías software hardware usadas para desarrollar sistema. . riesgos personales asocian con las personas equipo desarrollo. . riesgos organizacionales derivan del entorno organizacional donde desarrolla software. . riesgos herramientas resultan las herramientas software otro software soporte que usa para desarrollar sistema. . riesgos requerimientos proceden cambios los requerimientos del cliente del proceso gestionarlos. . riesgos estimación surgen las estimaciones administrativas los recursos requeridos para construir sistema. figura . brinda algunos ejemplos posibles riesgos cada una estas categorías. concluir proceso identificación riesgos, tendrá una larga lista eventualidades que podrían ocurrir afectar producto, proceso empresa. entonces necesita reducir esta lista tamaño razonable. existen demasiados ries-gos, será prácticamente imposible seguir huella todos ellos. .. análisis riesgo durante proceso análisis riesgos, hay que considerar cada riesgo identificado realizar juicio acerca probabilidad gravedad dicho riesgo. hay una forma sencilla hacer esto. usted debe apoyarse propio juicio experiencia identificación del riesgoanálisis del riesgoplaneación ante riesgomonitorización del riesgo lista riesgos potencialeslista riesgos prioritariosplanes para evitar riesgo contingenciavaloración del riesgofigura . proceso gestión del riesgo -.indd -.indd // :: // :: . ■ gestión del riesgo obtenida los proyectos anteriores los problemas que surgieron ellos. posible hacer valoraciones precisas numéricas probabilidad gravedad cada riesgo. vez ello, habrá que asignar riesgo una ciertas bandas: . probabilidad del riesgo puede valorarse como muy baja (< %), baja (del %), moderada (del %), alta (del %) muy alta ( %). . los efectos del riesgo pueden estimarse como catastróficos (amenazan supervi-vencia del proyecto), graves (causarían grandes demoras), tolerables (demoras den-tro contingencia permitida) insignificantes. luego hay que tabular los resultados este proceso análisis mediante una tabla clasificada acuerdo con gravedad del riesgo. figura . ilustra esto para los riesgos que identificaron figura .. desde luego, aquí valoración pro-babilidad seriedad son arbitrarias. para hacer esta valoración, necesita información detallada del proyecto, proceso, equipo desarrollo organización. desde luego, tanto probabilidad como valoración los efectos riesgo pue-den cambiar conforme disponga más información acerca del riesgo medida que implementen planes gestión del riesgo. por tanto, esta tabla debe actualizar durante cada iteración del proceso riesgo. una vez analizados clasificados los riesgos, valore cuáles son los más significativos. juicio debe depender una combinación probabilidad que riesgo surja junto con los efectos dicho riesgo. general, los riesgos catastróficos deben considerarse siempre, así como los riesgos graves con más una probabilidad moderada ocurrencia.tipo riesgo riesgos posibles tecnológico base datos que usa sistema puede procesar tantas transacciones por segundo como esperaba. () los componentes software reutilización contienen defectos que hacen que puedan reutilizarse como planeó. () personal imposible reclutar personal con las habilidades requeridas. () personal clave está enfermo indispuesto momentos críticos. () está disponible capacitación requerida para personal. () organización organización reestructura modo que diferentes administraciones son responsables del proyecto. ()problemas financieros organización fuerzan reducciones presupuesto del proyecto. () herramientas código elaborado por las herramientas generación código software ineficiente. ()las herramientas software pueden trabajar una forma integrada. () requerimientos proponen cambios los requerimientos que demandan mayor trabajo rediseño. () los clientes entienden las repercusiones los cambios los requerimientos. () estimación subestima tiempo requerido para desarrollar software. () subestima tasa reparación defectos. () subestima tamaño del software. () figura . ejemplos diferentes tipos riesgos -.indd -.indd // :: // :: capítulo ■ gestión proyectos boehm () recomienda identificar monitorizar los riesgos principales, pero considera que esta cifra más bien arbitraria. número correcto riesgos monitori-zar debe depender del proyecto. pueden ser cinco . sin embargo, número riesgos elegidos para monitorizar debe ser manejable. número riesgos muy grande requeri-ría recopilar demasiada información. partir los riesgos identificados figura ., adecuado considerar los ocho riesgos que tienen consecuencias catastróficas graves (figura .). .. planeación del riesgo proceso planeación del riesgo considera cada uno los riesgos clave identificados desarrolla estrategias para manejarlos. para cada uno los riesgos, usted debe considerar las acciones que puede tomar para minimizar perturbación del proyecto produce problema identificado riesgo. también debe pensar información que tal vez necesite recopilar mientras observa proyecto para que pueda anticipar los problemas. riesgo probabilidad efectos problemas financieros organización fuerzan reducciones presupuesto del proyecto. ()baja catastrófico imposible reclutar personal con las habilidades requeridas. () alta catastrófico personal clave está enfermo indispuesto momentos críticos. () moderada gravelos componentes software reutilización contienen defectos que hacen que puedan reutilizarse como planeó. ()moderada grave proponen cambios los requerimientos que demandan mayor trabajo rediseño. ()moderada grave organización reestructura modo que diferentes administraciones son responsables del proyecto. ()alta grave base datos que usa sistema puede procesar tantas transacciones por segundo como esperaba. ()moderada grave subestima tiempo requerido para desarrollar software. () alta grave las herramientas software pueden trabajar una forma integrada. () alta tolerable los clientes entienden las repercusiones los cambios los requerimientos. ()moderada tolerable está disponible capacitación requerida para personal. () moderada tolerable subestima tasa reparación defecto. () moderada tolerable subestima tamaño del software. () alta tolerable código elaborado por las herramientas generación código software ineficiente. ()moderada insignificante figura . tipos riesgos ejemplos -.indd -.indd // :: // :: . ■ gestión del riesgo nuevamente, hay proceso simple que pueda seguirse para planeación contin- gencias. apoya juicio experiencia del administrador del proyecto. figura . muestra posibles estrategias gestión del riesgo que identificaron como los principales riesgos ( decir, aquellos que son graves intolerables) que incluyen figura .. dichas estrategias establecen tres categorías: . estrategias evitación seguir estas estrategias significa que reducirá proba- bilidad que surja riesgo. ejemplo estrategia evitación del riesgo estrategia enfrentar los componentes defectuosos que muestran figura .. . estrategias minimización seguir estas estrategias significa que reducirá efecto del riesgo. ejemplo estrategia minimización riesgo estra-tegia para las enfermedades del personal que indica figura .. . planes contingencia seguir estas estrategias significa que está preparado para peor tiene una estrategia para hacer frente ello. ejemplo estrategia contingencia estrategia para los problemas financieros organización que indica figura .. aquí observa una clara analogía con las estrategias utilizadas los sistemas críticos para garantizar fiabilidad, seguridad protección, cuando hay que evitar, tolerar recupe-rarse las fallas. desde luego, mejor usar una estrategia que evitar riesgo. esto posible, debe usar una estrategia que reduzca las posibilidades que riesgo cause graves efectos. finalmente, debe contar con estrategias para enfrentar riesgo cuando éste surja. tales estrategias deben reducir efecto global riesgo proyecto producto.riesgo estrategia problemas financieros organizaciónprepare documento informativo para altos ejecutivos que muestre cómo proyecto realiza una aportación muy importante las metas empresa presente razones por las que los recortes presupuesto del proyecto serían efectivos costo. problemas reclutamientoalerte cliente dificultades potenciales posibilidad demoras; investigue compra componentes. enfermedad del personalreorganice los equipos manera que haya más traslape trabajo , así, las personas comprendan las labores los demás. componentes defectuosossustituya los componentes potencialmente defectuosos con compra componentes conocida fiabilidad. cambios requerimientosobtenga información seguimiento para valorar efecto cambiar los requerimientos; maximice información que oculta diseño. reestructuración organizaciónprepare documento informativo para altos ejecutivos que muestre cómo proyecto realiza una aportación muy importante las metas empresa. rendimiento base datosinvestigue posibilidad comprar una base datos mayor rendimiento. subestimación del tiempo desarrollo investigue los componentes comprados; indague uso generador programa. figura . estrategias para ayudar gestionar riesgo -.indd -.indd // :: // :: capítulo ■ gestión proyectos .. monitorización del riesgo monitorización del riesgo proceso para comprobar que han cambiado sus suposiciones sobre riesgos del producto, proceso empresa. hay que valorar regularmente cada uno los riesgos identificados para decidir este riesgo vuelve más menos probable. también tiene que considerar los efectos del riesgo han cambiado . para hacer esto, observe otros factores, como número peticiones cambio requerimientos, que pistas acerca probabilidad del riesgo sus efectos. dichos factores dependen claramente los tipos riesgos. figura . proporciona algunos ejemplos factores que pueden ser útiles para valorar estos tipos riesgos. los riesgos deben monitorizarse comúnmente todas las etapas del proyecto. cada revisión administrativa, necesario reflexionar estudiar cada uno los riesgos clave por separado. también hay que decidir más menos probable que surja riesgo, cambiaron gravedad las consecuencias del riesgo. . gestión personal las personas que trabajan una organización software son los activos más impor-tantes. cuesta mucho dinero reclutar retener buen personal, así que depende los administradores software garantizar que organización obtenga mejor aprovecha-miento posible por inversión. las compañías economías exitosas, esto logra cuando organización respeta las personas les asigna responsabilidades que reflejan sus habilidades experiencia. importante que los administradores proyecto software comprendan los conflictos técnicos que influyen trabajo del desarrollo software. sin embargo, por desgracia, los buenos ingenieros software necesariamente son buenos admi-nistradores personal. los ingenieros software con frecuencia tienen grandes tipo riesgo indicadores potenciales tecnológico entrega tardía hardware software soporte; muchos problemas tecnológicos reportados. personal baja moral personal; malas relaciones entre miembros del equipo; alta rotación personal. organización chismes organización; falta acción los altos ejecutivos. herramientas renuencia los miembros del equipo para usar herramientas; quejas acerca las herramientas case; demandas por estaciones trabajo mejor equipadas. requerimientos muchas peticiones cambio requerimientos; quejas los clientes. estimación falla para cumplir con calendario acordado; falla para corregir los defectos reportados.figura . indicadores riesgo -.indd -.indd // :: // :: . ■ gestión personal habilidades técnicas, pero pueden carecer habilidades más sutiles que les permitan motivar dirigir equipo desarrollo proyecto. como administrador pro-yecto, usted deberá estar tanto los problemas potenciales administrar personal debe tratar desarrollar habilidades gestión recursos humanos. desde perspectiva del autor, existen cuatro factores críticos gestión personal: . consistencia todas las personas equipo proyecto deben recibir trato similar. nadie espera que todas las distinciones sean idénticas, pero las personas podrían sentir que sus aportaciones organización menosprecian. . respeto las personas tienen distintas habilidades los administradores deben res-petar esas diferencias. todos los miembros del equipo deben recibir una oportuni-dad para aportar. desde luego, algunos casos, usted encontrará que las personas simplemente ajustan equipo pueden continuar, pero importante adelantar conclusiones sobre esto una etapa temprana del proyecto. . inclusión las personas contribuyen efectivamente cuando sienten que otros las escuchan que sus propuestas toman cuenta. importante desarrollar ambiente laboral donde consideren todas las visiones, incluso las del personal más joven. . honestidad como administrador, siempre debe ser honesto acerca que está bien que está mal equipo. también debe ser honesto respecto nivel conocimiento técnico voluntad para comunicar personal más conocimiento cuando sea necesario. trata encubrir ignorancia los problemas, con tiempo, éstos saldrán luz perderá respeto del grupo. gestión personal algo que debe basarse experiencia, lugar apren-derse libro. objetivo esta sección, siguiente sobre trabajo equipo, introducir manera sencilla algunos los problemas más importantes gestión personal del equipo que afectan gestión proyectos software. espera que este material sensibilice algunos los problemas que pueden encontrar los administra-dores cuando enfrentan con equipos individuos técnicamente talentosos. .. motivación del personal como administrador proyecto, usted necesitará motivar las personas con quienes trabaja, manera que éstas contribuyan con mejor sus habilidades. motivación significa organizar trabajo ambiente laboral para alentar los individuos des-empeñarse tan efectivamente como sea posible. las personas están motivadas, estarán interesadas actividad que realizan. así que trabajarán con lentitud, será más probable que cometan errores que contribuyan con las metas más amplias del equipo organización. para fomentar este ánimo, hay que saber poco acerca qué motiva gente. maslow () sugiere que las personas sienten motivadas para cubrir sus necesidades, las cuales ordenan una serie niveles, como muestra figura .. los niveles más bajos esta jerarquía representan necesidades fundamentales alimentación, sueño, etcétera, necesidad sentirse seguro ambiente. las necesidades sociales rela-cionan con hecho sentirse parte grupo social. las necesidades estima representan -.indd -.indd // :: // :: capítulo ■ gestión proyectos necesidad sentirse respetado por otros, las necesidades autorrealización tie- nen que ver con desarrollo personal. las personas requieren cubrir las necesidades nivel inferior, como hambre, antes las necesidades nivel superior, que son más abstractas. las personas que trabajan organizaciones desarrollo software, por general, están hambrientas sedientas físicamente amenazadas por ambiente. por tanto, asegurarse que cubren las necesidades sociales, estima autorrealización las personas más importante desde punto vista administrativo. . para satisfacer las necesidades sociales, preciso dar las personas tiempo para reunirse con sus compañeros trabajo proporcionarles lugares socialización. esto relativamente sencillo cuando todos los miembros equipo desarrollo trabajan mismo lugar. aunque cada vez más común que los miembros del equipo laboren mismo edificio siquiera misma ciudad estado. pueden trabajar para diferentes organizaciones mayor parte del tiempo desde casa. los sistemas redes sociales las teleconferencias facilitan las comunicaciones, pero los sistemas electrónicos son más efectivos una vez que las personas conocen entre . por tanto, necesario programar algunas reuniones cara cara etapas tempranas del proyecto, manera que gente pueda interactuar directamente con otros miembros del equipo. mediante esta interacción directa, las personas vuel-ven parte grupo social aceptan las metas prioridades dicho grupo. . para cubrir las necesidades estima, necesario demostrar las personas que son valoradas por organización. reconocimiento público los logros una forma simple, aunque efectiva, hacer esto. desde luego, las personas también deben sentir que les paga acuerdo con sus habilidades experiencia. . finalmente, para cubrir las necesidades autorrealización, necesario dar res-ponsabilidad las personas por trabajo, asignarles tareas demandantes (pero imposibles) ofrecer programa capacitación donde puedan desarrollar sus habilidades. capacitación una importante influencia motivadora, pues mayoría las personas desean adquirir nuevos conocimientos aprender nuevas habilidades. figura . ilustra problema motivación que habitualmente deben enfrentar los administradores. este ejemplo, miembro competente del grupo necesidades fisiológicasnecesidades seguridadnecesidades socialesnecesidades estimanecesidades autorrealización figura . jerarquía necesidades humanas -.indd -.indd // :: // :: . ■ gestión personal pierde interés trabajo grupo conjunto. calidad trabajo declina vuelve inaceptable. esta situación debe enfrentarse rápidamente. resuelve problema, los otros miembros del grupo sentirán insatisfechos pensarán que están haciendo una parte del trabajo que les corresponde. este ejemplo, alice trata descubrir las circunstancias personales dorothy son origen del problema. comúnmente, las dificultades personales afectan motiva-ción, porque las personas pueden concentrarse trabajo. tal vez haya que darles tiempo apoyo para resolver dichos conflictos, aunque también hay que dejar claro que siguen teniendo una responsabilidad con empleador. problema motivación dorothy bastante común cuando los proyectos desarrollan una dirección imprevista. las personas que esperan hacer tipo trabajo pueden terminar por hacer algo completamente diferente. esto vuelve problema cuando los miembros del equipo quieren desarrollar sus habilidades una forma que distinta rumbo que tomó proyecto. tales circunstancias, admi-nistrador podría decidir que integrante debe abandonar equipo encontrar opor-tunidades alguna otra parte. sin embargo, este ejemplo, alice decide tratar convencer dorothy que ampliar experiencia paso positivo carrera. concede dorothy más autonomía diseño organiza cursos capacitación inge-niería software que darán más oportunidades después terminado proyecto actual.estudio caso: motivación alice administradora proyecto software una compañía que desarrolla sistemas alarma. esta compañía quiere ingresar creciente mercado tecnología apoyo para ayudar que los ancianos las personas discapacitadas vivan manera independiente. solicitó alice dirigir equipo seis desarrolladores que pueden diseñar nuevos productos basados tecnología alarma empresa. proyecto tecnología apoyo alice comienza bien. dentro del equipo desarrollan tanto buenas relaciones trabajo como nuevas ideas creativas. equipo decide desarrollar sistema mensajería entre pares usando televisores digitales vinculados red alarma para comunicaciones. sin embargo, meses después proyecto, alice nota que dorothy, una experta diseño hardware, comienza llegar tarde trabajo, que calidad trabajo deteriora , cada vez más, parece comunicarse con otros miembros del equipo. alice platica problema informalmente con otros miembros del equipo para tratar descubrir cambiaron las circunstancias personales dorothy, esto pudiera afectar trabajo. como ninguno ellos sabe algo respecto, alice decide hablar con dorothy para tratar entender problema. después negar inicio que exista problema, dorothy admite que perdió interés trabajo. ella esperaba desarrollar usar sus habilidades creación interfaces hardware. sin embargo, debido gestión del producto que eligió, tiene poca oportunidad hacer esto. básicamente, trabaja como programadora con otros miembros del equipo. admite que aunque trabajo desafiante, ella está preocupada desarrollar sus habilidades interfaces. además, piensa que será difícil encontrar trabajo relacionado con interfaces hardware después este proyecto. puesto que quiere alterar equipo revelar que piensa siguiente proyecto, decide que mejor minimizar conversación con ellos. figura . motivación individual -.indd -.indd // :: // :: capítulo ■ gestión proyectos modelo motivación maslow útil sólo hasta cierto punto, que adopta punto vista exclusivamente personal motivación. considera manera adecuada hecho que las personas sienten parte una organización, grupo profesional una más culturas. ésta tan sólo una cuestión cubrir necesidades sociales: las personas pueden sentirse motivadas ayudar grupo lograr metas compartidas. ser miembro grupo cohesivo enormemente motivador para mayoría gente. con frecuencia, las personas con trabajos satisfactorios disfrutan trabajar, porque están motivadas por gente con que trabajan por actividad que realizan. por tanto, además pensar motivación individual, también hay que considerar cómo grupo conjunto puede motivarse para lograr las metas organización. siguiente sección estudian los conflictos administrar grupos. tipo personalidad también influye motivación. bass dunteman () clasifican los profesionales tres tipos: . personas orientadas las tareas, quienes están motivadas por trabajo que realizan. ingeniería software trata personas que están motivadas por reto intelectual desarrollar software. . personas orientadas hacia mismas, quienes están motivadas principalmente por éxito reconocimiento personales. están interesadas desarrollo del software como medio para lograr sus propias metas. esto significa que esos individuos sean egoístas sólo piensen sus propios intereses. vez ello, suelen tener metas plazos más largos, como avance profesional; esta manera, sienten motivados tener éxito trabajo para conseguir dichas metas. . personas orientadas interacción, quienes están motivadas por presencia las acciones los compañeros trabajo. conforme desarrollo software vuelve más centrado usuario, los individuos orientados interacción invo-lucran más ingeniería software. las personas orientadas interacción comúnmente disfrutan trabajar como parte grupo, mientras que quienes están orientadas las tareas hacia mismas pre-fieren actuar individualmente. las mujeres tienen más probabilidad que los hombres estar orientadas interacción. con frecuencia son comunicadores más efectivos. estudio caso figura . muestra mezcla estos diferentes tipos personalidad grupos.modelo madurez capacidad del personal modelo madurez capacidad del personal (-cmm) marco para valorar qué tan bien las organizaciones administran desarrollo personal. pone relieve las mejores prácticas gestión personal ofrece una base para que las organizaciones mejoren los procesos administración los recursos humanos. http:// -.indd -.indd // :: // :: . ■ trabajo equipo motivación cada individuo constituye con elementos cada clase, pero, por regular, tipo motivación domina algún momento dado. sin embargo, los indi-viduos pueden cambiar. por ejemplo, personal técnico que siente que recompensa manera adecuada puede volverse orientado hacia mismo anteponer interés per-sonal los asuntos técnicos. grupo trabaja particularmente bien, las personas orien-tadas hacia mismas pueden volverse más orientadas interacción. . trabajo equipo mayor parte del software profesional desarrolla mediante equipos proyecto, cuyo número miembros varía entre dos varios cientos personas. sin embargo, como imposible que todos los integrantes grupo grande trabajen conjunto solo problema, los equipos grandes habitualmente dividen grupos más pequeños. cada grupo responsable desarrollar parte del sistema global. como regla general, los gru-pos del proyecto ingeniería software deben tener más miembros. cuando usan grupos pequeños reducen los problemas comunicación. todos conocen todos los demás, grupo conjunto puede reunirse torno una mesa para estudiar proyecto software que desarrollan. conformar grupo que tiene equilibrio justo habilidades técnicas, experiencia personalidades una tarea administrativa fundamental. sin embargo, los grupos exi-tosos son mucho más que una colección individuos con equilibrio justo habili-dades. buen equipo cohesivo tiene espíritu grupo. las personas que participan están motivadas tanto por éxito del grupo como por sus metas personales. grupo cohesivo, los miembros piensan que equipo más importante que los individuos que integran. los miembros grupo cohesivo bien liderado son leales equipo. identifican con las metas del grupo con los demás miembros. tratan proteger grupo, como entidad, cualquier interferencia externa. esto hace que grupo sea sólido pueda enfrentar problemas situaciones inesperadas. los beneficios crear grupo cohesivo son: . grupo puede establecer sus propios estándares calidad puesto que dichos estándares establecen por consenso, éstos tienen más probabilidad respetarse que los estándares externos impuestos sobre grupo. . los individuos aprenden los demás apoyan mutuamente las personas grupo aprenden los demás. las inhibiciones causadas por ignorancia mini-mizan mientras promueve aprendizaje mutuo. . conocimiento comparte puede mantenerse continuidad sale miembro del grupo. otros grupo pueden tomar control las tareas críticas para ase-gurar que proyecto altere forma considerable. . alientan refactorización mejoramiento continuo los miembros del grupo trabajan manera colectiva para entregar resultados alta calidad corregir pro-blemas, sin importar quiénes crearon originalmente diseño programa. -.indd -.indd // :: // :: capítulo ■ gestión proyectos los buenos administradores proyecto siempre tratan alentar cohesión grupal. pueden organizar eventos sociales para los miembros del grupo sus familias, además establecer sentido identidad ponerle nombre grupo establecer una compatibili-dad territorio grupales, organizar actividades explícitas construcción grupal, como actividades deportivas juegos. una las formas más efectivas fomentar cohesión ser comprensivo. esto significa que hay que tratar los miembros los grupos como responsables con-fiables, poner información libre disposición. ocasiones, los administradores sienten que pueden revelar cierta información todos los miembros del grupo. esto invariablemente crea clima desconfianza. simple intercambio información una forma efectiva hacer que las personas sientan valoradas reconozcan como parte grupo. estudio caso figura . puede ver ejemplo esto. alice con-cierta reuniones informales regulares donde informa los otros miembros del grupo que sucede. asegura involucrar las personas desarrollo del producto pedir-les que proporcionen nuevas ideas derivadas propia experiencia familiar. los días fuera también son buenas formas promover cohesión: las personas relajan reunirse mientras ayudan mutuamente aprender nuevas tecnologías. grupo efectivo , cierta medida, depende naturaleza del proyecto organización que realiza trabajo. una organización encuentra estado turbulencia por reorganizaciones constantes inseguridad laboral, muy difícil que los miembros del equipo enfoquen desarrollo software. sin embargo, aparte los conflictos del proyecto organización, existen tres factores genéricos que afectan trabajo equipo: . las personas grupo necesita una combinación personas grupo proyecto, puesto que desarrollo software implica diversas actividades, como negociación con clientes, programación, pruebas documentación.estudio caso: espíritu equipo alice, una experimentada administradora proyecto, comprende importancia crear grupo cohesivo. conforme desarrolla nuevo producto, ella aprovecha oportunidad hacer participar todos los miembros del grupo especificación diseño del producto, hacer que analicen las posibles tecnologías con los miembros sus familias mayor experiencia. alice también los alienta llevar esos familiares para reunirse con otros integrantes del grupo desarrollo. también organiza almuerzos mensuales para todos los integrantes del grupo. dichos almuerzos son una oportunidad para que todos los miembros del equipo reúnan manera informal, platiquen acerca los temas que les preocupan conozcan mutuamente. almuerzo, alice comunica grupo que sabe acerca las noticias, políticas, estrategias, etcétera, organización. luego, cada miembro del equipo explica brevemente que hace, grupo examina tema general, como las ideas nuevo producto los parientes mayores. cada determinado tiempo, alice organiza día fuera para grupo, que equipo pasa dos días actualización tecnológica. cada miembro del equipo prepara una actualización sobre una tecnología relevante presenta grupo. ésta una reunión fuera sitio buen hotel programa bastante tiempo para las discusiones interacción social. figura . cohesión grupal -.indd -.indd // :: // :: . ■ trabajo equipo . organización grupal grupo debe organizarse forma que los individuos puedan contribuir con sus mejores habilidades completar las tareas como esperaba. . comunicaciones técnicas administrativas esencial óptima comunicación entre los miembros del grupo, entre equipo ingeniería software otras partes interesadas proyecto. como todos los conflictos administrativos, reunir equipo correcto garantiza éxito del proyecto. muchas otras cosas pueden salir mal, incluidos los cambios los negocios ambiente empresarial. sin embargo, presta atención debida composición, organización las comunicaciones del grupo, aumenta probabilidad que proyecto enfrente dificultades. .. selección los miembros del grupo labor administrador líder equipo crear grupo cohesivo organizar los miembros del grupo para que puedan trabajar conjunto manera efectiva. esto implica crear grupo con equilibrio correcto habilidades técnicas personalidades, así como organizarlo para que los miembros trabajen adecuadamente conjunto. ocasiones, contrata personas externas organización; obstante, con más fre-cuencia, los grupos ingeniería software componen empleados actuales que tienen experiencia adquirida otros proyectos. con todo, los administradores pocas veces tienen absoluta libertad selección del equipo. con frecuencia deben recurrir las personas que estén disponibles compañía, aun cuando sean ideales para puesto. como estudió sección .., muchos ingenieros software están motivados principalmente por trabajo. por tanto, los grupos desarrollo menudo están com-puestos por personas que cuentan con ideas propias sobre qué problemas técnicos deben resolverse. esto refleja los problemas que reportan regularmente relacionados con estándares interfaz ignorados, sistemas rediseñados conforme codifican, arre-glo innecesario del sistema, etcétera. grupo con personalidades complementarias puede trabajar mejor que grupo seleccionado exclusivamente por habilidad técnica. probable que las personas que están motivadas por trabajo sean las más fuertes técnicamente. las personas que son orientadas hacia mismas tal vez serán mejores para impulsar trabajo hacia delante para terminar tarea. las personas orientadas interacción ayudan facilitar las comunicaciones dentro del grupo. considera que grupo particularmente importante contar con personas orientadas interacción. éstas les gusta hablar con los demás son capaces detectar tensiones diferencias una etapa temprana, antes que tengan serias repercusiones sobre grupo. estudio caso figura ., narró cómo alice, administradora del proyecto, trató crear grupo con personalidades complementarias. este grupo particular tiene una buena combinación personas orientadas interacción las tareas, pero, figura ., describió cómo personalidad dorothy, quien está orientada hacia misma, causó problemas porque realizó trabajo esperado. también rol tiempo parcial fred, como experto dominio, podría ser pro-blema del grupo. está principalmente interesado los retos técnicos, así que posible- -.indd -.indd // :: // :: capítulo ■ gestión proyectos mente interactúe bien con otros miembros del grupo. hecho que siempre parte del equipo significa que puede relacionarse bien con las metas del equipo. ocasiones imposible elegir grupo con personalidades complementarias. éste caso, administrador del proyecto tiene que controlar grupo modo que las metas individuales antepongan los objetivos organización del grupo. este control más sencillo lograr todos los miembros del grupo participan cada etapa del proyecto. iniciativa individual más factible cuando los miembros del grupo reciben instrucciones sin estar tanto parte que desempeña tarea pro-yec global. por ejemplo, suponga que ingeniero software asigna diseño pro-grama para codificar, observa que parecen ser posibles mejoras que podrían hacerse diseño. implementa dichas mejoras sin comprender las razones del diseño original, cualquier cambio, aun cuando sea muy bien intencionado, puede tener implicaciones adversas para otras partes del sistema. todos los miembros del grupo participan diseño desde principio, comprenderán por qué tomaron las decisiones diseño. entonces, los miembros podrán identificarse con dichas decisiones lugar oponerse ellas. .. organización del grupo forma que organiza grupo influye las decisiones que toma dicho grupo, las maneras como intercambia información las interacciones entre grupo desa-rrollo los participantes externos del proyecto. las preguntas organizacionales impor-tantes para los administradores proyecto incluyen: . ¿ administrador del proyecto debe ser líder técnico del grupo? líder técnico arquitecto del sistema responsable las decisiones técnicas críticas tomadas durante desarrollo del software. ocasiones, administrador del proyecto tiene estudio caso: composición grupo crear grupo para desarrollo tecnología apoyo, alice está consciente importancia seleccionar miembros con personalidades complementarias. cuando entrevista miembros potenciales del grupo, trata valorar están orientados las tareas, hacia mismos orientados interacción. ella siente que personalidad está orientada hacia misma, porque considera que proyecto una forma hacerse notar ante los altos ejecutivos buscar una promoción. por ende, busca una quizá dos personalidades orientadas interacción, individuos orientados las tareas para completar equipo. valoración final que llegó fue: alice: orientada hacia misma brian: orientado tareas bob: orientado tareas carol: orientada interacción dorothy: orientada hacia misma : orientado interacción fred: orientado tareas figura . composición grupo -.indd -.indd // :: // :: . ■ trabajo equipo habilidad experiencia para desempeñar este papel. sin embargo, caso grandes proyectos, mejor asignar ingeniero con experiencia como arquitecto del proyecto, quien tomará responsabilidad del liderazgo técnico. . ¿quién encargará tomar las decisiones técnicas críticas, cómo tomarán? ¿las decisiones las tomará arquitecto del sistema, administrador del proyecto llegará consenso entre rango más amplio miembros del equipo? . ¿cómo manejarán las interacciones con los participantes externos los altos direc-tivos compañía? muchos casos, administrador del proyecto será res-ponsable dichas interacciones, asistido, acaso, por arquitecto del sistema. sin embargo, modelo organización alternativo incluye una función exclusiva para las relaciones externas, que supone asignar para dicha función una persona con habilidades interacción adecuadas. . ¿cómo posible que los grupos logren integrar personas que localizan mismo lugar? ahora común que los grupos incluyan miembros diferentes organizaciones personas que trabajan desde casa oficinas compartidas. esto debe tomarse cuenta los procesos toma decisiones grupales. . ¿cómo puede compartirse conocimiento través del grupo? organización del grupo afecta intercambio información, pues determinadas formas organiza-ción son mejores que otras para compartir. sin embargo, conviene evitar demasiado intercambio información, que las personas pueden sobresaturarse infor-mación excesiva podría distraerlos sus labores. los grupos programación pequeños, por general, están organizados una forma bastante informal. líder del grupo participa desarrollo software con los otros miembros del grupo. grupo informal, todo equipo analiza trabajo rea-lizar, las tareas asignan según habilidad experiencia. los miembros del grupo con mayor jerarquía pueden ser responsables del diseño arquitectónico. obstante, diseño implementación detallados son compromisos del miembro del equipo que asigna una tarea particular. los grupos programación extrema (beck, ) siempre son grupos informa-les. los apasionados afirman que estructura formal inhibe intercambio información. , muchas decisiones que normalmente consideran como decisio-nes administrativas (por ejemplo, las decisiones acerca del calendario) delegan los contratar las personas correctas con frecuencia los administradores del proyecto son responsables seleccionar personal organización que unirá equipo ingeniería software. conseguir las mejores personas posibles este proceso muy importante, pues las malas decisiones selección implican grave riesgo para proyecto. los factores clave que deben influir selección personal son: educación capacitación, dominio aplicación experiencia tecnológica, habilidad comunicación, adaptabilidad habilidad para resolver problemas. http:// -.indd -.indd // :: // :: capítulo ■ gestión proyectos miembros del grupo. los programadores trabajan pares para diseñar código asu- men responsabilidad conjunta los programas que desarrollaron. los grupos informales pueden ser muy exitosos, particular cuando mayoría los miembros del grupo son experimentados competentes. tal grupo toma decisiones por consenso, que mejora cohesión rendimiento. sin embargo, grupo está compuesto principalmente por miembros inexpertos incompetentes, informalidad puede ser obstáculo porque existe autoridad definida para dirigir trabajo, que causa una falta coordinación entre los miembros del grupo , posiblemente, una even-tual falla del proyecto. los grupos jerárquicos son grupos que comparten una estructura jerárquica con líder del grupo parte superior del escalafón. líder tiene autoridad más formal que los miembros del grupo así puede dirigir trabajo. existe una clara estructura organizacional, las decisiones toman hacia parte superior jerarquía aplican por las personas que están más abajo jerarquía. las comunicaciones, ante todo, son instrucciones del personal ejecutivo existe relativamente poca comunica-ción ascendente, decir, desde los niveles más bajos hacia los niveles superiores jerarquía. este enfoque funciona bien cuando problema bien entendido puede descompo-nerse fácilmente subproblemas los que las soluciones desarrollan diferentes partes jerarquía. dichas situaciones requiere muy poca comunicación través jerarquía. sin embargo, tales situaciones, proporción, son poco comunes ingeniería software por las siguientes razones: . los cambios software requieren con frecuencia cambios varias partes del sistema esto conduce una discusión negociación todos los niveles jerarquía. . las tecnologías software cambian tan rápido que muchas veces personal más joven conoce más tecnología que personal experimentado. las comu-nicaciones descendentes pueden significar que administrador del proyecto vislumbra las oportunidades usar nuevas tecnologías. personal más joven puede frustrarse debido que considera obsoletas las tecnologías usadas para desarrollo. las organizaciones grupales democráticas jerárquicas reconocen formalmente que puede haber diferencias muy grandes habilidad técnica entre los miembros del grupo. los mejores programadores pueden ser hasta veces más productivos que los peores programadores. tiene sentido aprovechar las capacidades los mejores elemen-tos forma más efectiva brindarles tanto apoyo como sea posible. uno los pri-meros modelos organizacionales que tenía intención ofrecer apoyo fue llamado equipo programador jefe. para aprovechar manera más efectiva los programadores con mayor habilidad, baker () otros (aron, ; brooks, ) sugieren que los equipos deben cons-truirse torno programador jefe individual con gran habilidad. principio subya-cente del equipo programador jefe que personal habilidoso experimentado debe ser responsable todo desarrollo del software. sus integrantes deben preocuparse por cuestiones rutinarias deben tener buen apoyo técnico administrativo para realizar trabajo. deben enfocarse software desarrollar perder mucho tiempo reuniones externas. -.indd -.indd // :: // :: . ■ trabajo equipo obstante, organización equipo programador jefe , desde perspectiva del autor, demasiado dependiente del programador jefe asistente. otros miembros del equipo quienes suficiente responsabilidad pueden desmotivarse porque sienten que sus habilidades son desaprovechadas. tienen información para hacer frente las cosas salen mal les oportunidad participar toma deci-siones. existen riesgos significativos para proyecto asociados con esta organización grupal esto podría superar cualquier beneficio que aporte este tipo organización. .. comunicaciones grupales absolutamente esencial que los miembros del grupo comuniquen efectiva eficien-temente entre con otras partes interesadas proyecto. los miembros del grupo deben intercambiar información acerca del estatus trabajo, las decisiones diseño que tomaron los cambios las decisiones diseño previas. tienen que resolver los problemas que surjan con otros interesados proyecto informar éstos sobre los cambios sistema, grupo planes entrega. buena comunicación ayuda también fortalecer cohesión del grupo. los miembros del grupo llegan entender las motiva-ciones, fortalezas debilidades otras personas grupo. efectividad eficiencia las comunicaciones están influidas por: . tamaño del grupo conforme grupo crece, hace más difícil que los miembros comuniquen manera efectiva. número vínculos comunicación canal * ( – ), donde tamaño del grupo, manera que, con grupo ocho miembros, existen posibles rutas comunicación. esto significa que muy posible que algunas personas rara vez comuniquen entre . las diferen-cias estatus entre los miembros del grupo significan que las comunicaciones con frecuencia son unidireccionales. los administradores ingenieros experimentados tienden dominar las comunicaciones con personal menos experimentado, quie-nes pueden tener reticencias para iniciar una conversación hacer puntualizaciones críticas. . estructura del grupo las personas los grupos estructurados manera infor-mal comunican más efectivamente que los individuos grupos con una estruc-tura jerárquica formal. los grupos jerárquicos, las comunicaciones tienden fluir hacia arriba abajo jerarquía. las personas mismo nivel tal vez ambiente laboral físico ambiente donde trabajan las personas afecta tanto las comunicaciones grupales como productividad individual. los espacios trabajo individuales son mejores para concentración trabajo técnico detallado, pues las personas tienen menos probabilidad distraerse por interrupciones. sin embargo, los espacios trabajo compartidos son mejores para las comunicaciones. ambiente laboral bien diseñado toma consideración ambas necesidades. http:// -.indd -.indd // :: // :: capítulo ■ gestión proyectos comuniquen entre . éste problema particular proyecto grande con varios grupos desarrollo. las personas que trabajan diferentes subsistemas comunican sólo través sus administradores, hay más probabilidad demo-ras malas interpretaciones. . composición del grupo las personas con los mismos tipos personalidad (estu-diados sección .) pueden chocar , como resultado, las comunicaciones inhiben. además, por regular, comunicación mejor los grupos integrados por personas uno otro género (marshall heslin, ) que los grupos forma-dos por miembros solo género. con frecuencia, las mujeres son más orientadas interacción que los hombres suelen actuar como controladoras facilitadoras interacción para grupo. . ambiente laboral físico organización del centro trabajo factor importante para facilitar inhibir las comunicaciones. véase página web del libro para más información. . los canales comunicación disponibles existen muchas formas diferentes comunicación: cara cara, correo electrónico, documentos formales, teléfono tecnologías web ., como las redes sociales los wikis. conforme los equipos proyecto distribuyen cada vez más, con miembros equipo que trabajan lugares remotos, necesario utilizar varias tecnologías para facilitar las comuni-caciones. los administradores proyecto trabajan por general bajo plazos estrechos , consecuencia, tratan usar canales comunicación que consuman mucho tiempo. por tanto, apoyan reuniones documentos formales para transmitir informa-ción personal del proyecto las partes interesadas. aunque éste tal vez sea enfoque eficiente para comunicación desde perspectiva administrador proyecto, comúnmente muy efectivo. menudo existen buenas razones por las que las per-sonas pueden asistir las reuniones , por tanto, escuchan presentación. los documentos extensos casi nunca leen, debido que los lectores saben los docu-mentos son relevantes. producirse varias versiones del mismo documento, los lectores encuentran difícil hacer seguimiento los cambios. comunicación efectiva logra cuando las comunicaciones son bidireccionales, las personas implicadas pueden discutir los conflictos información, establecer una comprensión común las proposiciones los problemas. esto lograr mediante reuniones, aunque éstas suelen estar dominadas por las personalidades poderosas. ocasiones práctico citar con escasa anticipación reuniones. cada vez más equipos proyecto incluyen miembros ubicados distancia, que dificulta las reuniones. para contrarrestar estos problemas apoyar intercambio información, puede recurrir tecnologías web, como wikis blogs. los wikis respaldan creación edi-ción documentos colaboración, mientras que los blogs apoyan las discusiones generadas por preguntas comentarios hechos por los miembros del grupo. los wikis blogs permiten los miembros del proyecto los participantes externos intercambiar información, sin importar ubicación. ayudan gestionar información seguir huella los hilos discusión, que con frecuencia vuelven confusos cuando rea-lizan por correo electrónico. para resolver conflictos que necesiten discusión, puede recurrir mensajería instantánea las teleconferencias, las cuales pueden organizar- fácilmente. -.indd -.indd // :: // :: pmcapítulo ■ lecturas sugeridas puntos clave ■ buena gestión proyectos software esencial los proyectos ingeniería software deben desarrollarse dentro del plazo presupuesto establecidos. ■ gestión del software distinta otras administraciones ingeniería. software intangible. los proyectos pueden ser novedosos innovadores, así que hay conjunto experiencias para orientar gestión. los procesos software son tan maduros como los procesos ingeniería tradicionales. ■ gestión del riesgo reconoce ahora como una las tareas más importantes gestión proyecto. ■ gestión del riesgo implica identificación valoración los grandes riesgos del proyecto para establecer probabilidad que ocurran; también supone identificar valorar las consecuencias para proyecto dicho riesgo surge. debe hacer planes para evitar, gestionar enfrentar los posibles riesgos. ■ las personas sienten motivadas por interacción con otros individuos, reconocimiento gestión sus pares, recibir oportunidades desarrollo personal. ■ los grupos desarrollo software deber ser bastante pequeños cohesivos. los factores clave que influyen efectividad grupo son sus integrantes, forma que está organizado comunicación entre los miembros. ■ las comunicaciones dentro grupo están influidas por factores como estatus los miembros del grupo, tamaño del grupo, composición por género del grupo, las personalidades los canales comunicación disponibles. lecturas sugeridas the mythical man month (anniversary edition). los problemas gestión del software siguen gran medida invariables desde década , este libro uno los mejores sobre tema. una interesante clara explicación gestión uno los primeros más grandes proyectos software: sistema operativo / ibm. edición aniversario (publicada años después edición original ) incluye otros ensayos clásicos brooks. (. . brooks, , addison-wesley.) software project survival guide. ésta una explicación bastante pragmática gestión del software que incluye buenos consejos prácticos para los administradores proyecto con antecedentes ingeniería software. fácil leer entender. (. mcconnell, , microsoft press.) peopleware: productive projects and teams, edition. ésta una nueva edición del libro clásico acerca importancia tratar las personas manera adecuada cuando administran proyectos software. uno los pocos libros que reconocen importancia del lugar donde trabajan las personas. enormemente recomendable. (. demarco . lister, , dorset house.) waltzing with bears: managing risk software projects. una introducción muy práctica fácil leer respecto los riesgos gestión del riesgo. (. demarco . lister, , dorset house.) -.indd -.indd // :: // :: capítulo ■ gestión proyectos ejercicios .. explique por qué intangibilidad los sistemas software plantea problemas especiales para gestión proyectos software. .. explique por qué los mejores programadores siempre son los mejores administradores software. tal vez resulte útil basar respuesta lista actividades administrativas sección .. .. con los casos problemas proyecto reportados literatura, mencione las dificultades los errores administrativos que ocurrieron dichos proyectos programación fallidos. ( sugiere que comience con the mythical man month, fred brooks). .. además los riesgos que muestran figura ., identifique menos otros seis riesgos posibles que pudieran surgir los proyectos software. .. los contratos precio fijo, donde contratista ofrece precio fijo para completar desarrollo sistema, permiten desplazar los riesgos del proyecto del cliente contratista. algo sale mal, contratista debe pagar. sugiera cómo uso tales contratos puede aumentar probabilidad que surjan riesgos del producto. .. explique por qué mantener informados todos los miembros grupo acerca del progreso las decisiones técnicas proyecto ayuda mejorar cohesión del grupo. .. ¿qué problemas considera que surgirían los equipos programación extrema, donde muchas decisiones administrativas delegan los miembros del equipo? .. escriba estudio caso, con estilo usado aquí, para ilustrar importancia las comunicaciones equipo proyecto. suponga que algunos miembros del equipo trabajan distancia posible reunir todo equipo corto plazo. .. administrador pide entregar software plazo que sólo podrá cumplir pide equipo proyecto trabajar tiempo extra sin remuneración. todos los miembros del equipo tienen hijos pequeños. discuta debe aceptar esta demanda administrador debe persuadir equipo ceder tiempo organización lugar dedicarlo sus familias. ¿qué factores pueden ser significativos decisión? .. como programador, ofrece una promoción puesto gestión proyectos, pero siente que puede hacer una aportación más efectiva papel técnico más que administrativo. discuta debe aceptar promoción. referencias aron, . . (). the program development process. reading, mass.: addison-wesley. baker, . . (). “chief programmer team management production programming”. ibm systems ., (), –. -.indd -.indd // :: // :: pmcapítulo ■ referencias bass, . . dunteman, . (). “behaviour groups function self, interaction and task orientation”. . abnorm. soc. psychology., (), –. beck, . (). extreme programming explained. reading, mass.: addison-wesley.boehm, . . (). “ spiral model software development and enhancement”. ieee computer, (), –. brooks, . . (). the mythical man month. reading, mass.: addison-wesley.hall, . (). managing risk: methods for software systems development . reading, mass.: addison-wesley.marshall, . . heslin, . (). “boys and girls together. sexual composition and the effect density group size and cohesiveness”. . personality and social psychology, (), –. maslow, . . (). motivation and personality. nueva york: harper and row.ould, . (). managing software quality and business risk. chichester: john wiley & sons. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo planeación, calendarización estimación costos proyectos. estudiar este capítulo: ■ comprenderá los fundamentos del costo del software las razones por las que precio del software puede relacionarse directamente con costo desarrollo; ■ conocerá qué secciones debe incluir plan proyecto creado dentro proceso desarrollo dirigido por plan; ■ entenderá que contempla calendarización del proyecto uso gráficas barras para presentar calendario proyecto; ■ introducirá “juego planeación”, utilizado para apoyar planeación proyectos programación extrema; ■ analizará cómo puede usarse modelo cocomo para estimación algorítmica costos. contenido . fijación precio software . desarrollo dirigido por plan . calendarización proyectos . planeación ágil . técnicas estimación planeación proyectos -.indd -.indd // :: // :: pmcapítulo ■ planeación proyectos planeación proyectos una las labores más importantes administrador proyectos software. como administrador, debe dividir trabajo partes asig-nar éstas los miembros del equipo del proyecto, anticipar los problemas que pudieran surgir preparar posibles soluciones tales inconvenientes. plan creado comienzo proyecto usa para comunicar equipo los clientes cómo realizará trabajo, así como para ayudar valorar avance del proyecto. planeación presenta durante tres etapas ciclo vida del proyecto: . etapa propuestas, cuando presenta una licitación con vistas obtener contrato para desarrollar proporcionar sistema software. esta etapa necesario plan para ayudarle decidir cuenta con los recursos para completar trabajo calcular precio que debe cotizar cliente. . durante fase inicio, cuando debe determinar quién trabajará proyecto, cómo dividirá proyecto incrementos, cómo asignarán los recursos través compañía, etcétera. aquí, cuenta con más información que etapa propuesta , por tanto, pueden afinar las estimaciones iniciales. . periódicamente largo del proyecto, cuando plan modifica luz experiencia obtenida información del monitoreo del avance del trabajo. aprende más acerca del sistema implementar las capacidades del equipo desarrollo. esta información permite hacer estimaciones más precisas sobre cuánto tardará trabajo. más aún, probable que los requerimientos del software cam-bien esto, por general, significa que debe modificarse división del trabajo extenderse plazo. para proyectos desarrollo tradicionales, quiere decir que plan creado durante fase inicio debe modificarse. obstante, cuando usa enfoque ágil, los planes son plazo más corto varían continuamente medida que evoluciona software. sección . estudia planeación ágil. planeación etapa propuesta, inevitablemente, especulativa, pues muchas veces cuenta con conjunto completo requerimientos para software desa-rrollar. vez ello, hay que responder una solicitud propuestas basada una descripción alto nivel sobre funcionalidad del software que requiere. con fre-cuencia, necesita plan como parte una propuesta, así que debe diseñar plan creíble para realizar trabajo. obtiene contrato, entonces por general habrá que replantear proyecto tomar cuenta los cambios desde que hizo pro-puesta. cuando presenta una licitación para obtener contrato, hay que calcular precio que propondrá cliente para desarrollo del software. como punto partida para calcular este precio, requiere presentar una estimación los costos para completar trabajo del proyecto. estimación incluye calcular cuánto esfuerzo requiere para ter-minar cada actividad , partir ello, calcular costo total las actividades. siempre habrá que calcular los costos del software manera objetiva, con finalidad pre-decir con precisión costo para desarrollo del software. una vez que tiene una estimación razonable los probables costos, entonces posible calcular precio que cotizará cliente. como estudia siguiente sección, muchos factores influyen fijación del precio proyecto software, trata simplemente sumar costo ganancia. -.indd -.indd // :: // :: capítulo ■ planeación proyectos existen tres principales parámetros que deben usar calcular los costos pro- yecto desarrollo software:  costos esfuerzo (los costos pagar los ingenieros administradores soft- ware);  costos hardware software, incluido mantenimiento;  costos viajes capacitación. para mayoría los proyectos, mayor costo primer rubro. debe estimarse esfuerzo total ( meses-hombre) que probable requiera para completar trabajo proyecto. desde luego, cuenta con datos limitados para realizar tal valoración, manera que habrá que hacer mejor evaluación posible continuación agregar contin-gencia significativa (tiempo esfuerzo adicionales) caso que estimación inicial sea optimista. para sistemas comerciales menudo usa hardware commodity, que relativa-mente barato. sin embargo, los costos software pueden ser considerables debe licenciar middleware software plataforma. posible que requieran viajes frecuentes cuando proyecto desarrolla diferentes lugares. aunque los costos viaje, por regular, representan una pequeña fracción los costos esfuerzo, tiempo invertido viajar desperdicia muchas veces agrega significativamente los costos esfuerzo del proyecto. los sistemas reunión electrónicos otro software que apoya colaboración remota pueden reducir cantidad viajes requeridos. tiempo que ahorra puede dedicarse trabajo del proyecto más productivo. una vez asignado contrato para desarrollar sistema, debe afinarse bosquejo plan proyecto para crear plan inicio proyecto. esta etapa debe saber más acerca los requerimientos para este sistema. sin embargo, posible que cuente con una especificación completa los requerimientos, especial cuando usa enfoque ágil para desarrollo. meta durante esta etapa debe ser elaborar plan proyecto que pueda usarse para apoyar toma decisiones acerca del personal presupuesto del proyecto. plan sirve como base para asignar recursos proyecto desde interior organización decidir requiere contratación nuevo personal. plan debe definir también los mecanismos monitorización del proyecto. necesario hacer seguimiento del avance del proyecto comparar los avances costos reales con progreso planeado. aunque mayoría las organizaciones tienen proce-dimientos formales para monitorizar, buen administrador debe ser capaz crear una costos generales estimar los costos del esfuerzo proyecto software, sólo multiplican los sueldos del personal involucrado por tiempo invertido proyecto, sino que también hay que tener cuenta todos los costos generales organización (espacio oficinas, administración, etcétera) que deben cubrirse con ingreso del proyecto. los costos estiman calcular dichos costos generales sumar una proporción los costos cada ingeniero que trabaja proyecto. http:// -.indd -.indd // :: // :: . ■ fijación precio software imagen clara que sucede mediante comunicaciones informales con personal del proyecto. monitorización informal ayuda pronosticar problemas potenciales pro-yecto revelar las dificultades conforme ocurren. por ejemplo, los intercambios diarios con personal del proyecto pueden revelar problema particular para encontrar una falla del software. vez esperar reporte reducción del plazo, administrador del proyecto podrá entonces asignar inmediato experto problema, decidir pro-gramar torno éste. plan del proyecto siempre evoluciona durante proceso desarrollo. planea-ción del desarrollo pretende garantizar que plan del proyecto siga siendo documento útil para que personal comprenda que debe lograrse cuándo debe entregarse. por tanto, calendario estimación costos riesgos deben revisarse medida que desarrolla software. usa método ágil, hay necesidad plan inicio del proyecto pues, sin importar enfoque empleado, compañía necesita planear cómo asignarán los recur-sos proyecto. sin embargo, éste plan detallado sólo debe incluir infor-mación limitada sobre división del trabajo calendario del proyecto. durante desarrollo, para cada entrega (release) del software, define plan proyecto infor-mal las estimaciones del esfuerzo; todo equipo participa proceso planeación. . fijación precio software principio, precio producto software cliente simplemente costo del desarrollo más las ganancias para diseñador. sin embargo, práctica, rela-ción entre costo del proyecto precio cotizado cliente tan simple. cuando calcula precio, hay que hacer consideraciones más amplias índole organizacional, económica, política empresarial, como las mostradas figura .. debe pensarse los intereses empresa, los riesgos asociados con proyecto tipo contrato que firmará. esto puede hacer que precio ajuste alza baja. dadas las preci-siones organizacionales implicadas, decidir sobre precio proyecto debe ser una actividad grupal que incluya personal marketing ventas, así como altos ejecutivos administradores proyecto. para ilustrar algunos los conflictos fijación precio del proyecto, tome cuenta siguiente escenario: una pequeña compañía software, pharmasoft, emplea ingenieros software. recientemente terminó gran proyecto, pero sólo tiene contratos que requieren cinco personas desarrollo. sin embargo, licita para contrato muy grande con una gran compañía farmacéutica que requiere años-hombre esfuerzo durante dos años. proyecto comenzará sino hasta dentro meses pero, realiza, transformará las finanzas compañía. pharmasoft tiene una oportunidad para licitar proyecto que requiere seis per- sonas debe completarse meses. los costos (incluidos los costos generales este proyecto) estiman $. millones. obstante, para mejorar posi-ción competitiva, pharmasoft decide ofrecer precio cliente $. millones. -.indd -.indd // :: // :: capítulo ■ planeación proyectos esto significa que, aunque pierda dinero este contrato, podrá retener personal especializado para proyectos futuros más rentables que, probablemente, llegarán raudales dentro año. como costo proyecto sólo está débilmente relacionado con precio cotizado cliente, “cotizar para ganar” una estrategia usada comúnmente. cotizar para ganar significa que una compañía tiene alguna idea del precio que cliente espera pagar hace una apuesta por contrato con base precio esperado por cliente. esto puede parecer ético poco práctico los negocios, pero tiene ventajas tanto para cliente como para proveedor del sistema. costo proyecto acuerda sobre base borrador propuesta. entonces las negociaciones tienen lugar entre cliente consumidor para establecer especifica-ción detallada del proyecto. esta especificación restringe costo acordado. com-prador vendedor deben convenir cuál funcionalidad aceptable del sistema. muchos proyectos factor fijo está constituido por los requerimientos del proyecto, sino por costo. los requerimientos pueden cambiar para que costo supere. por ejemplo, suponga que una compañía (oilsoft) licita por contrato con pro-pósito desarrollar sistema reparto combustible para una compañía petrolera que programa entregas gasolina sus estaciones servicio. para este sistema hay documento requerimientos detallado, manera que oilsoft estima que precio $ (dólares estadounidenses) probablemente sea competitivo esté dentro del pre-supuesto compañía petrolera. después que otorga contrato, oilsoft nego-cia los requerimientos detallados del sistema, manera que entrega funcionalidad básica. entonces estiman los costos adicionales para otros requerimientos. compañía petrolera necesariamente pierde aquí, pues otorga contrato una compañía factor descripción oportunidad mercado una organización desarrollo puede cotizar precio bajo porque quiere moverse hacia nuevo segmento del mercado software. aceptar una baja ganancia proyecto puede dar organización oportunidad obtener una mayor ganancia más adelante. experiencia alcanzada podría ayudarle también desarrollar nuevos productos. incertidumbre estimación costosi una organización está segura sus estimaciones costos, puede aumentar precio mediante una contingencia por arriba ganancia normal. términos contractuales cliente puede permitir desarrollador detener propiedad del código fuente reutilizarlo otros proyectos. entonces precio podrá ser inferior que cobra código fuente entrega cliente. volatilidad requerimientos probable que cambien los requerimientos, una organización puede reducir precio para ganar contrato. una vez otorgado contrato pueden cobrarse precios altos por cambios los requerimientos. salud financiera los desarrolladores dificultad financiera pueden reducir sus costos para obtener contrato. mejor obtener una ganancia menor que normal quedar punto equilibrio, que salir del negocio. flujo efectivo más importante que ganancia tiempos problemas económicos. figura . factores que afectan fijación precio del software -.indd -.indd // :: // :: . ■ desarrollo dirigido por plan que puede confiar. los requerimientos adicionales podrán financiarse partir pre- supuesto futuro, así que presupuesto compañía petrolera resulta alterado por alto costo inicial del software. . desarrollo dirigido por plan desarrollo dirigido por plan basado plan enfoque para ingeniería software donde proceso desarrollo planea detalle. elabora plan proyecto que registra trabajo que realizar, quién efectuará, calendario desarrollo los productos trabajo. los administradores utilizan plan para apoyar toma deci-siones del proyecto también como una forma medir progreso. desarrollo dirigido por plan sustenta técnicas administración proyectos ingeniería pueden considerarse como manera tradicional administrar grandes proyectos desarrollo software. anterior contrasta con desarrollo ágil, que muchas decisiones que afectan desarrollo retrasan hacen posteriormente, según requiera, durante proceso desarrollo. principal argumento contra desarrollo basado plan que muchas decisio-nes tempranas deben revisarse debido cambios entorno los que desarrollará usará software. retrasar las decisiones una práctica sensata porque evita tener que volver trabajar. los argumentos favor enfoque dirigido por plan son que planeación temprana permite que los asuntos organización (disponibilidad per-sonal, otros proyectos, etcétera) tomen estrictamente cuenta, que los problemas potenciales dependencias descubran antes que inicie proyecto, cuando esté marcha. desde esta perspectiva, mejor enfoque planeación del proyecto incluye una mezcla juiciosa desarrollo basado plan ágil. equilibrio depende del tipo proyecto las habilidades del personal que estén disponibles. por lado, los grandes sistemas críticos seguridad protección requieren amplio análisis previo quizá certificarse antes utilizarse. esto debe estar dirigido mediante plan. por otro lado, los sistemas información, pequeños medianos, que usan entorno competitivo vertiginosamente cambiante, deben ser ágiles. cuando muchas compañías están implicadas proyecto desarrollo, con frecuencia usa enfoque basado plan para coordinar trabajo través cada sitio desarrollo. .. planes proyecto proyecto desarrollo dirigido por plan, plan proyecto establecen los recursos disponibles para proyecto, división del trabajo calendario para realizar trabajo. plan debe identificar los riesgos para proyecto software desarrollo, así como enfoque que toma para gestión del riesgo. aunque los detalles específicos los planes proyecto varían dependiendo del tipo proyecto organización, los planes incluyen por regular las siguientes secciones: . introducción ésta describe brevemente los objetivos del proyecto establece las restricciones (por ejemplo, presupuesto, tiempo, etcétera) que afectan administra-ción del proyecto. -.indd -.indd // :: // :: capítulo ■ planeación proyectos . organización del proyecto ésta refiere forma que está organizado equipo desarrollo, las personas implicadas sus roles equipo. . análisis riesgo detalla los posibles riesgos del proyecto, probabilidad que surjan dichos riesgos las estrategias propuestas para reducir riesgo. gestión del riesgo trata capítulo . . requerimientos recursos hardware software detallan hardware software soporte requeridos para realizar desarrollo. hay que comprar hard-ware, pueden incluirse estimaciones los precios calendario entregas. . división del trabajo establece división del proyecto actividades identifica los plazos las entregas asociados con cada actividad. los plazos son las etapas clave del proyecto donde puede valorarse avance; las entregas son productos trabajo que proporcionan cliente. . calendario del proyecto indica las dependencias entre las actividades, tiempo estimado requerido para alcanzar cada plazo asignación personal las acti-vidades. las formas las que puede presentarse calendario estudian siguiente sección del capítulo. . mecanismos monitorización reporte esta sección define los informes admi-nistrativos que deben producirse, cuándo tienen que elaborarse los mecanismos monitorización del proyecto que usarán. además del plan proyecto principal, que debe enfocarse los riesgos para los proyectos calendario, conviene desarrollar algunos planes complementarios para apoyar otras actividades del proceso, como las pruebas administración configu-ración. figura . muestran ejemplos posibles planes complementarios. .. proceso planeación planeación del proyecto proceso iterativo que comienza cuando diseña plan proyecto inicial durante fase arranque del proyecto. figura . plan descripción plan calidad describe los procedimientos calidad estándares que usarán proyecto. plan validación describe enfoque, los recursos calendario utilizados para validación del sistema. configuración del plan gestión describe configuración los procedimientos las estructuras para gestión. plan mantenimiento predice los requerimientos, los costos esfuerzo mantenimiento. plan desarrollo personal describe cómo desarrollarán las habilidades experiencia los miembros del equipo proyecto. figura . complementos plan proyecto -.indd -.indd // :: // :: . ■ desarrollo dirigido por plan diagrama actividad uml que muestra flujo trabajo típico para proceso planeación proyecto. los cambios plan son inevitables. conforme más informa-ción sobre sistema equipo esté disponible durante proyecto, habrá que revisar regularmente plan para reflejar los requerimientos, calendario los cambios riesgo. modificar las metas empresa conduce también cambios los planes del proyecto. medida que cambien las metas empresa, esto podría afectar todos los proyectos, los cuales tal vez deban replantearse. comienzo proceso planeación, hay que valorar las restricciones que afec-tan proyecto. éstas son fecha entrega requerida, personal disponible, presupuesto global, herramientas disponibles, etcétera. conjunción con esto, también hay que iden-tificar los hitos entregables del proyecto. los hitos son puntos calendario contra los que puede valorar avance, por ejemplo, transferencia del sistema para pruebas. los entregables son productos trabajo que proporcionan cliente (por ejemplo, documento requerimientos para sistema). entonces proceso entra ciclo. prepara calendario estimado para pro-yecto inician las actividades definidas calendario concede permiso para continuarlas. después cierto tiempo (por general dos tres semanas), debe revisar avance anotar las diferencias del calendario planeado. puesto que las estima-ciones iniciales los parámetros del proyecto inevitablemente son aproximadas, nor-mal que presenten atrasos menores habrá que hacer modificaciones plan original. importante ser realista elaborar plan proyecto. los problemas alguna descripción surgen casi siempre durante proyecto pueden conducir demoras del mismo. consecuencia, las suposiciones calendarización iniciales deben ser más pesimistas que optimistas. tiene que haber suficiente contingencia acumulada plan, modo que las restricciones los hitos del plan necesiten renegociarse cada vez que revisa ciclo planeación. existen graves problemas con trabajo desarrollo que conduzcan demoras significativas, habrá que iniciar acciones mitigación del riesgo para reducir los riesgos falla del proyecto. junto con dichas acciones, debe también replantear proyecto. definir calendario del proyectoidentificar riesgosidentificar restricciones definir plazos entregas«sistema» planificador proyecto [sin problemas] [problemas menores atrasos][proyecto terminado] [sin terminar] [problemas serios] iniciar acciones mitigación riesgoreplantear proyectohacer trabajo monitorizar avance contra plan figura . proceso planeación del proyecto -.indd -.indd // :: // :: capítulo ■ planeación proyectos esto puede incluir renegociar las restricciones del proyecto entregables con cliente. también necesario establecer acordar con cliente nuevo calendario sobre tiempo que completará trabajo. esta renegociación tiene éxito son efectivas las acciones mitigación del riesgo, debe organizar entonces una revisión técnica formal del proyecto. los obje-tivos esta revisión son encontrar enfoque alternativo que permita continuación del proyecto, comprobar éste, así como las metas del cliente desarrollador software, todavía están alineados. resultado una revisión puede ser una decisión para cancelar proyecto. esto podría obedecer efecto los fracasos técnicos administrativos pero, menudo, consecuencia cambios externos que afectan proyecto. durante este tiempo, los objetivos las prioridades compañía cambian inevitablemente. tales cambios pue-den significar que software requiere más que los requerimientos del pro-yecto original resultan inadecuados. entonces administración puede decidir detener desarrollo del software realizar grandes cambios proyecto para que éstos reflejen los cambios los objetivos organización. . calendarización proyectos calendarización proyectos proceso decidir cómo organizará trabajo proyecto como tareas separadas, cuándo cómo ejecutarán dichas tareas. estima tiempo calendario para completar cada tarea, esfuerzo requerido quién trabajará las tareas identificadas. también hay que estimar los recursos necesarios para completar cada tarea (como espacio disco requerido servidor), tiempo que necesitará hardware especializado (como simulador) cuál será presu-puesto viajes. términos las etapas planeación estudiadas introducción este capítulo, calendario proyecto inicial elabora por general durante fase arranque del proyecto. luego, durante planeación del desarrollo, este calenda-rio afina modifica. tanto los procesos basados plan como los ágiles precisan calendario proyecto inicial, aunque nivel detalle puede ser menor plan proyecto ágil. este calendario inicial utiliza para planear cómo asignarán las personas proyecto comprobar avance éste frente los compromisos contractuales. los procesos tradicionales desarrollo, calendario completo elabora inicialmente enseguida modifica conforme avanza proyecto. los procesos ágiles debe existir calendario global que identifique tiempo que completarán las prin-cipales fases del proyecto. entonces, usa enfoque iterativo calendarización para planear cada fase. calendarización los proyectos dirigidos por plan (figura .) implica dividir trabajo total proyecto tareas separadas estimar tiempo requerido para completar cada tarea. por general, las tareas deben durar menos una semana, pero más dos meses. una subdivisión más fina significa que una cantidad desproporcio-nada tiempo debe emplearse para volver planear actualizar plan del proyecto. cantidad máxima tiempo para cualquier tarea debe durar alrededor ocho sema-nas. tarda más que esto, tarea debe subdividirse para planeación calendarización del proyecto. -.indd -.indd // :: // :: . ■ calendarización proyectos algunas estas tareas realizan paralelamente, con distintas personas que trabajan diferentes componentes del sistema. necesario coordinar las tareas paralelas orga-nizar las actividades para que fuerza trabajo desempeñe manera óptima introduzca entre las tareas dependencias innecesarias. importante evitar una situación que todo proyecto demore debido que una tarea crítica está terminada. proyecto está técnicamente avanzado, las estimaciones iniciales seguramente serán optimistas aun cuando trate considerar todas las eventualidades. este aspecto, calendarización del software diferente algún otro tipo gran proyecto avanzado. construcción las nuevas aeronaves, los puentes los nuevos modelos automóviles con frecuencia sufre retrasos, debido problemas previstos. por tanto, los calendarios deben actualizarse continuamente conforme disponga mejor información sobre avance. proyecto calendarizar similar proyecto anterior, pueden reutilizarse las estimaciones previas. sin embargo, los proyectos pueden usar diferentes métodos diseño lenguajes implementación, modo que expe-riencia proyectos anteriores tal vez sea aplicable planeación proyecto nuevo. como sugirió, evaluar calendarios hay que tomar cuenta posibilidad que las cosas salgan mal. las personas que trabajan proyecto podrían enfermar cambiar trabajo, hardware puede fallar entrega del software hardware apoyo esencial quizá demore. proyecto nuevo técnicamente avanzado, partes éste pueden resultar más difíciles tardar más que previsto originalmente. una buena regla empírica estimar que nada saldrá mal, luego ampliar estimación para enfrentar problemas anticipados. también puede añadirse estimación factor contingencia para hacer frente problemas anticipados. este factor contingencia adicional depende del tipo proyecto, los parámetros del proceso (plazo, estándares, etcétera) calidad experiencia los ingenieros software que trabajan pro-yecto. las estimaciones contingencia pueden agregar entre % esfuerzo tiempo requeridos para proyecto. .. representación del calendario los calendarios proyecto pueden representarse simplemente una tabla hoja cálculo que indique las tareas, esfuerzo, duración esperada las dependencias entre las tareas (figura .). sin embargo, este modo representación dificulta visualizar lasrelaciones dependencias entre las diferentes actividades. por esta razón han gráficas actividad una gráfica actividad una representación del calendario del proyecto que muestra cuáles tareas pueden realizarse forma paralela las que deben ejecutarse secuencia, debido dependencia respecto actividades anteriores. una tarea depende muchas otras, entonces todas éstas deben terminarse antes comenzar aquella. ruta crítica través gráfica actividad secuencia más larga tareas dependientes. esto define duración del proyecto. http:// -.indd -.indd // :: // :: capítulo ■ planeación proyectos desarrollado representaciones gráficas alternativas los calendarios proyecto, que con frecuencia son más fáciles leer entender. existen dos tipos representación que usan comúnmente: . gráficas barras, basadas calendario, las cuales señalan responsable cada actividad, tiempo transcurrido previsto fecha que programó ini-cio fin actividad. ocasiones, las gráficas barras llaman gráficas gantt, honor inventor, henry gantt. . redes actividad, son diagramas red que muestran las dependencias entre las diferentes actividades que constituyen proyecto. por general, una herramienta planeación usa para gestionar información del calendario del proyecto. dichas herramientas esperan menudo que introduzca información una tabla luego crearán una base datos información del proyecto. entonces, partir esta base datos, generan automáticamente gráficas barras actividad. las actividades proyecto son elemento planeación básico. cada actividad cuenta con: . una duración días meses calendario. . una estimación del esfuerzo, cual refleja número días-hombre meses- hombre para completar trabajo. . plazo dentro del cual debe completarse actividad. . punto final definido. éste representa resultado tangible completar activi-dad. también podría ser documento, realización una junta revisión, una ejecución exitosa todas las pruebas, etcétera. cuando planee proyecto, también deberá definir los hitos; esto , cada etapa del proyecto que puede realizarse una valoración del avance. cada hito debe documen-tarse mediante breve reporte que compendie avance realizado trabajo efectuado. los hitos pueden asociarse con una sola tarea con grupos actividades relacionadas. por ejemplo, figura ., hito asocia con tarea , mientras que hito asocia con par tareas, . tipo especial hito producción entregable del proyecto. entregable producto trabajo que entrega cliente. resultado una fase signifi-cativa del proyecto, como especificación diseño. por general, los entregables estimar recursos para actividadesidentificar dependencia entre actividadesidentificar actividadesasignar personal actividades información requerimientos diseño softwaregráfica barras que describa calendario del proyectocrear gráficas proyecto figura . proceso calendarización proyecto -.indd -.indd // :: // :: . ■ calendarización proyectos requeridos especifican contrato del proyecto, visión del cliente del avance del proyecto depende dichos entregables. para ilustrar cómo usan las gráficas barras creó conjunto hipotético tareas, que presenta figura .. esta tabla indica tareas, esfuerzo estimado, dura-ción interdependencias tareas. figura . observa que tarea depende tarea . por tanto, tarea debe completarse antes comenzar tarea . por ejemplo, puede ser preparación del diseño componente, implemen-tación ese diseño. antes comenzar implementación, debe completarse diseño. observe que duración estimada para algunas tareas mayor que esfuerzo requerido viceversa. esfuerzo menor que duración, significa que las personas asignadas dicha tarea trabajan ella tiempo completo. esfuerzo supera duración, quiere decir que muchos miembros del equipo trabajan mismo tiempo tarea. figura . toma información figura . presenta calendario del proyec- formato gráfico. una gráfica barras que muestra calendario proyecto las fechas inicio terminación las actividades. leerse izquierda derecha, gráfica barras señala claramente cuándo comienzan terminan las tareas. los hitos (, , etcétera) muestran también gráfica barras. observe que las tareas que son independientes realizan paralelamente (por ejemplo, las tareas , inician desde principio del proyecto). además planear calendario entregas para software, los administrado-res proyecto deben asignar recursos las tareas. desde luego, recurso clave son los ingenieros software que harán trabajo, ellos deben asignarse las activida-des del proyecto. también, asignación recursos puede ingresarse las herramien-tas administración del proyecto una gráfica barras generada, que muestra cuándo personal trabaja proyecto (figura .). las personas pueden trabajar más una figura . tareas, duraciones dependenciastarea esfuerzo (días-hombre) duración (días) dependencias () , () , () () () , () , () () , () -.indd -.indd // :: // :: capítulo ■ planeación proyectos tarea mismo tiempo , ocasiones, laborar proyecto. pueden estar vaca- ciones, ocupados otros proyectos, cursos capacitación inmersos alguna otra actividad. las asignaciones tiempo parcial indican con una línea diagonal que atraviesa barra. las grandes organizaciones, por general, emplean varios especialistas que tra-bajan proyecto cuando requiere. figura . observa que mary una especialista que trabaja sólo una tarea del proyecto. esto puede generar proble-mas calendarización. proyecto demora mientras especialista trabaja , esto podría tener efecto dominó sobre otros proyectos donde también requiera especialista. entonces este proyecto puede demorarse porque especialista está disponible. una tarea retrasa, sin duda, afectará desarrollo tareas posteriores que depen-den ella. posible iniciar éstas antes completar tarea retrasada. las demoras pueden causar graves problemas con asignación personal, especial cuando los individuos trabajan mismo tiempo varios proyectos. una tarea () demora, las personas seleccionadas pueden asignarse otro trabajo (). completar este último tal vez tarde más que demora; sin embargo, personal, una vez asignado, puede simplemente reasignarse tarea original (). entonces esto conducirá más aplaza-mientos mientras completa .semana (/) (/ & )(/& ) (/) (/ )(/ & ) (/ & ) fin(/ & ) figura . gráfica barras actividad -.indd -.indd // :: // :: . ■ planeación ágil . planeación ágil los métodos ágiles desarrollo software son enfoques iterativos donde software desarrolla entrega los clientes incrementos. diferencia los enfoques dirigi-dos por plan, funcionalidad dichos incrementos planea por anticipado, sino que decide durante desarrollo. decisión acerca qué incluir incremento depende del progreso las prioridades del cliente. argumento para este enfoque que las prioridades requerimientos del cliente cambian, manera que tiene sentido tener plan flexible que pueda acomodar dichos cambios. libro cohn (cohn, ) análisis exhaustivo los conflictos planeación los proyectos ágiles. los enfoques ágiles uso más común, como scrum (schwaber, ) progra-mación extrema (beck, ), tienen enfoque dos etapas para planeación, las cuales corresponden fase arranque desarrollo dirigido por plan pla-neación del desarrollo: . planeación entrega (release), que prevé con muchos meses antelación decide sobre las características que deben incluirse una entrega sistema. . planeación iteración, cual tiene panorama corto plazo enfoca planeación del siguiente incremento sistema. esto, para equipo, general-mente representa dos cuatro semanas trabajo. capítulo estudió enfoque scrum planeación, modo que aquí enfoque estará planeación programación extrema (). esto llama jane geetha hongt maryt fredt alit figura . gráfica asignación personal -.indd -.indd // :: // :: capítulo ■ planeación proyectos “juego planeación” por general implica todo equipo desarrollo, incluidos los representantes del cliente. figura . muestra las etapas del juego planeación. especificación del sistema basa historias del usuario, las cuales refle-jan las características que deben incluirse sistema. inicio del proyecto, equipo cliente tratan identificar conjunto historias que comprendan toda funcio-nalidad que incluirá sistema final. inevitablemente perderá cierta funcionali-dad, pero esta etapa esto importante. siguiente fase una etapa estimación. equipo del proyecto lee discute las historias las clasifica acuerdo con cantidad tiempo que consideran que tardará implementar historia. esto puede implicar división las historias grandes más pequeñas. estimación relativa con frecuencia más sencilla que estima-ción absoluta. por regular, las personas encuentran difícil evaluar cuánto esfuerzo tiempo requiere para hacer algo. sin embargo, cuando les presentan muchas activi-dades por hacer, pueden emitir juicios acerca cuáles historias requerirán más tiempo más esfuerzo. una vez completada clasificación, entonces equipo asigna puntos esfuerzo hipotéticos las historias. una historia compleja puede tener puntos una historia sencilla . esto hace para todas las historias lista clasificada. una vez estimadas las historias, esfuerzo relativo traduce primera estima-ción del esfuerzo total requerido usando noción velocidad. , velocidad número puntos esfuerzo implementados por equipo, por día. esto puede valuarse partir experiencia previa desarrollar una dos historias para ver tiempo que requiere. estimación velocidad aproximada, pero afina durante proceso desarrollo. una vez evaluada velocidad, posible calcular esfuerzo total días-hombre para implementar sistema. planeación entrega implica seleccionar afinar las historias que reflejarán las características aplicar una entrega sistema orden que deben implementarse las historias. cliente tiene que participar este proceso. entonces elige una fecha entrega las historias examinan para ver estimación del esfuerzo congruente con dicha fecha. , las historias agregan eliminan lista. planeación iteración primera etapa proceso desarrollo iteración. eligen las historias implementar para dicha iteración; número historias refleja tiempo para entregar una iteración (por general dos tres semanas) velocidad del equipo. cuando alcanza fecha entrega iteración, ésta completa, incluso han implementado todas las historias. equipo considera las historias que implementaron suma sus puntos esfuerzo. entonces puede calcularse nuevamente velocidad ésta considera planeación siguiente entrega del sistema. inicio cada iteración hay una etapa planeación más detallada que los desarrolladores dividen las historias tareas desarrollo. una tarea desarrollo debe tardar cuatro horas. mencionan todas las tareas que deben completarse para implementar todas las historias dicha iteración. entonces los desarrolladores indivi-planeación entregaestimación inicialidentificación historiaplaneación iteraciónplaneación tareas figura . planeación -.indd -.indd // :: // :: . ■ técnicas estimación duales comprometen cumplir las tareas específicas que implementarán. cada desa- rrollador conoce rapidez individual, manera que comprometerá para más tareas las que puede implementar tiempo. existen dos beneficios importantes partir este enfoque asignación tareas: . todo equipo consigue panorama las tareas completar una iteración. por tanto, todos tienen una comprensión que hacen otros miembros del equipo saben quién dirigirse identifican dependencias tarea. . los desarrolladores individuales eligen las tareas implementar; son simple-mente tareas asignadas por administrador proyecto. consecuencia, tienen sentido propiedad sobre dichas actividades probable que esto los motive completar tarea. mitad una iteración revisa avance. esta etapa deben estar completos mitad los puntos esfuerzo historia. este modo, una iteración implica puntos historia tareas, puntos historia tareas deben estar completos. éste caso, debe consultar cliente eliminar algunas historias iteración. este enfoque planeación tiene ventaja que software siempre entrega como planeó hay atraso calendario. trabajo puede completarse tiempo asignado, filosofía reducir alcance del trabajo lugar exten-der calendario. sin embargo, algunos casos, incremento puede ser suficiente para ser útil. reducir ámbito podría generar trabajo adicional para los clientes deben usar sistema incompleto cambiar sus prácticas laborales entre una entrega del sis-tema otra. una gran dificultad planeación ágil que depende del involucramiento disponibilidad del cliente. práctica, esto suele ser difícil organizar, pues los repre-sentantes del cliente ocasiones deben dar prioridad otros trabajos. los clientes tal vez estén más familiarizados con planes proyecto tradicionales encuentren difícil partici-par proyecto planeación ágil. planeación ágil funciona bien con equipos desarrollo pequeños estables, que pueden reunirse discutir las historias implementar. obstante, cuando los equipos son grandes / están geográficamente distribuidos, cuando cambia con frecuencia conformación del equipo, casi imposible que todos colaboren planeación, cual esencial para administración proyecto ágil. por consiguiente, los proyectos grandes planean generalmente usando enfoques tradicionales administración proyectos. . técnicas estimación difícil estimación del calendario del proyecto. probablemente haya que hacer esti-maciones iniciales sobre base una definición requerimientos usuario alto nivel. software puede ejecutarse computadoras familiares usar nueva tecnolo-gía desarrollo. quizá lleguen conocerse las personas involucradas proyecto -.indd -.indd // :: // :: capítulo ■ planeación proyectos sus habilidades. existe tanta incertidumbre que imposible estimar con precisión los costos desarrollo del sistema durante las primeras etapas proyecto. incluso existe una dificultad fundamental valoración precisión dife-rentes enfoques estimación del costo esfuerzo. con frecuencia, las estimaciones del proyecto autosatisfacen. estimación utiliza para definir presupuesto del proyecto, producto ajusta para que cumpla cifra del presupuesto. proyecto que está dentro presupuesto puede lograr esto expensas las características software desarrollar. conocen experimentos controlados con costo proyectos donde los costos estimados usen para sesgar experimento. experimento controlado revela-ría estimación costo administrador del proyecto. los costos reales compararían entonces con los costos proyecto estimados. obstante, las organizaciones necesitan hacer evaluaciones esfuerzo costo del software. existen dos tipos técnicas para ello: . técnicas basadas experiencia estimación los requerimientos esfuerzo futuro basan experiencia del administrador con proyectos anterio- res dominio aplicación. esencia, administrador emite juicio informado cuáles serán los requerimientos esfuerzo. . modelado algorítmico costo este caso usa enfoque formulista para calcular esfuerzo del proyecto con base estimaciones atributos del producto (por ejemplo, tamaño), así como las características del proceso (por ejemplo, experiencia del personal implicado). ambos casos necesario usar juicio para evaluar esfuerzo directamente, esti-mar proyecto las características del producto. fase arranque proyecto, dichas estimaciones tienen amplio margen error. con base datos recopilados gran número proyectos, boehm sus colaboradores () descubrieron que las estimaciones arranque varían significativamente. estimación inicial del esfuerzo requerido meses esfuerzo, rango puede ser . del esfuerzo real, medido cuando sistema entregó. durante planeación del desarrollo, las estimacio-nes vuelven cada vez más precisas conforme avanza proyecto (figura .). las técnicas basadas experiencia dependen experiencia del administrador proyectos anteriores esfuerzo real empleado dichos proyectos actividades que relacionan con desarrollo del software. por general, identifican los entre-gables que hay que producir proyecto los diferentes componentes software sistemas desarrollar. esto documenta una hoja cálculo, les estima manera individual calcula esfuerzo total requerido. por general, ayuda que grupo personas involucre estimación del esfuerzo pedir cada miembro del grupo que explique sus estimaciones. con frecuencia, esto revela factores que otros consideraron entonces itera hacia una estimación grupal consensuada. dificultad con las técnicas basadas experiencia que nuevo proyecto software puede tener mucho común con proyectos anteriores. desarrollo soft-ware cambia muy rápidamente con frecuencia proyecto usará técnicas familiares, tales como servicios web, desarrollo basado cots ajax. usted trabajado con estas técnicas, experiencia previa puede ser ayuda para estimar esfuerzo requerido, que dificultará producir estimaciones precisas costo calendario. -.indd -.indd // :: // :: . ■ técnicas estimación .. modelado algorítmico costos modelado algorítmico costos utiliza una fórmula matemática para predecir los costos del proyecto con base estimaciones del tamaño del proyecto, tipo software desarrollar, otros factores equipo, proceso producto. modelo algorítmico costo puede elaborarse analizar los costos atributos los proyectos completados, encontrar fórmula ajuste más cercana experiencia real. los modelos algorítmicos costo usan principalmente para hacer estimaciones los costos desarrollo software. sin embargo, boehm sus colaboradores () examinan una variedad otros usos para dichos modelos, como elaboración esti-maciones para inversionistas compañías software, estrategias alternativas para ayudar valorar los riesgos, decisiones informadas acerca reutilización, replaneación subcontratación. los modelos algorítmicos para estimar esfuerzo proyecto software basan principalmente una fórmula sencilla: esfuerzo tamañob factor constante que depende las prácticas locales organización tipo software que desarrolla. tamaño puede ser una valoración del tamaño del código del software una estimación funcionalidad expresada puntos función aplicación. valor del exponente encuentra por general entre .. multiplicador que integra combinar atributos procesos, producto desarrollo, tales como los requerimientos confiabilidad para software expe-riencia del equipo desarrollo. número líneas código fuente (sloc) sistema entregado métrica tamaño fundamental que utiliza muchos modelos algorítmicos costo. estima-ción del tamaño puede implicar estimación por analogía con otros proyectos, estimación convertir los puntos función aplicación tamaño del código, estimación clasi-ficar los tamaños los componentes del sistema uso componente referencia conocido para estimar tamaño del componente, simplemente puede ser una cuestión juicio ingeniería. . . requerimientos diseño códigoentrega figura . incertidumbre estimación -.indd -.indd // :: // :: capítulo ■ planeación proyectos mayoría los modelos estimación algorítmica tienen componente expo- nencial ( ecuación anterior) que relaciona con tamaño complejidad del sistema. esto refleja hecho que los costos aumentan con regularidad linealmente con tamaño del proyecto. conforme incrementa tamaño complejidad del software, incurre costos adicionales debido los costos generales comunicación los equipos más grandes, administración configuración más compleja, integra-ción sistemas más difícil, etcétera. cuanto más complejo sea sistema, más afectarán costo estos factores. por tanto, valor aumenta normalmente con tamaño complejidad del sistema. todos los modelos algorítmicos tienen problemas similares: . con frecuencia difícil estimar tamaño una etapa temprana del proyecto, cuando sólo está disponible especificación. las estimaciones punto función punto aplicación (véase más adelante) son más fáciles producir que las esti-maciones tamaño del código, pero por general aún son imprecisas. . las estimaciones los factores que contribuyen son subjetivas. las estima- ciones varían una persona otra, dependiendo sus antecedentes experiencia con tipo sistema que desarrolla. estimación precisa del tamaño del código difícil una etapa temprana pro-yecto, porque tamaño del programa final depende decisiones diseño que pueden haberse hecho cuando requirió estimación. por ejemplo, una aplicación que requiere ges tión datos alto rendimiento puede implementar propio sistema gestión datos usar sistema base datos comercial. estimación inicial del costo, pro-bable que conozca existe sistema base datos comercial que desempeñe bas-tante bien para cumplir los requerimientos rendimiento. por tanto, desconoce cuánto código gestión datos incluirá sistema. lenguaje programación usado para desarrollar sistema afecta también número líneas código desarrollar. lenguaje como java puede significar que necesiten más líneas código que usa (por ejemplo). sin embargo, este código adicional permite más comprobación tiempo compilación, manera que proba-ble que reduzcan los costos validación. ¿cómo debe tomarse esto cuenta? más aún, puede reutilizar una cantidad significativa código proyectos anteriores, así que tendrá que ajustarse estimación del tamaño para tomar esto cuenta. los modelos algorítmicos costo son una forma sistemática estimar esfuerzo requerido para desarrollar sistema, aunque dichos modelos son complejos difíciles usar. existen muchos atributos margen considerable para incertidumbre estimar sus valores. esta complejidad desalienta los usuarios potenciales , por tanto, aplicación práctica del modelado algorítmico costos limita número pequeño compañías. otra barrera que desalienta uso los modelos algorítmicos necesidad calibración. los usuarios del modelo deben calibrar sus modelos valores los atri-butos con sus datos históricos proyecto, pues ello refleja práctica experiencia locales. sin embargo, muy pocas organizaciones recaban suficientes datos proyectos anteriores una forma que soporte calibración del modelo. consecuencia, uso práctico modelos algorítmicos debe comenzar con los valores publicados para los parámetros del modelo. casi imposible que modelador sepa qué tan estrechamente relacionan éstos con organización. -.indd -.indd // :: // :: . ■ técnicas estimación usa modelo algorítmico estimación costos, hay que desarrollar rango estimaciones (peor, esperado mejor) lugar una sola estimación aplicar fórmulade costo todas ellas. más probable que las estimaciones sean precisas cuando com-prende tipo software que desarrolla, calibró modelo costeo usando datos locales, cuando predefinen lenguaje programación las opciones hardware. .. modelo cocomo han propuesto algunos modelos similares para coadyuvar estimar esfuerzo, calendario los costos proyecto software. modelo que estudia aquí cocomo . éste modelo empírico que derivó recopilar datos partir gran número proyectos software. dichos datos analizaron para descubrir qué fórmulas ajustaban mejor con las observaciones. dichas fórmulas vinculan tamaño del sistema los factores del producto, proyecto equipo, con esfuerzo para desarrollar sistema. cocomo modelo estimación bien documentado registrado. cocomo desarrolló partir los primeros modelos estimación costos cocomo, que basaron principalmente desarrollo código original (boehm, ; boehm royce, ). modelo cocomo toma cuenta enfoques más modernos para desarrollo software, tales como desarrollo rápido que usa lenguajes dinámicos, desarrollo mediante composición componentes uso programación base datos. cocomo soporta modelo espiral desarrollo, descrito capítulo , incrusta submodelos que producen estimaciones cada vez más detalladas. los submodelos (figura .) que consideran parte del modelo cocomo son: . modelo composición aplicación éste modela esfuerzo requerido para desarrollar sistemas que crean partir componentes reutilización, escritura número puntos aplicación número puntos funcióncon base usado por usado por usado por usado porcon base con base con base ennúmero líneas código reutilización generadas número líneas código fuentemodelo composición aplicación modelo diseño temprano modelo reutilización modelo posarquitecturasistemas desarrollados usando lenguajes dinámicos, programación , etcétera estimación esfuerzo inicial basado requerimientos del sistema opciones diseño esfuerzo para integrar componentes reutilización código generado automáticamente esfuerzo desarrollo basado especificación diseño del sistema figura . modelos estimación cocomo -.indd -.indd // :: // :: capítulo ■ planeación proyectos guiones programación base datos. las estimaciones del tamaño soft- ware basan puntos aplicación, para estimar esfuerzo requerido usa una simple fórmula tamaño/productividad. número puntos aplicación programa una estimación ponderada del número pantallas separadas que despliegan, número informes que producen, número módulos len-guajes programación imperativa (como java) número líneas lenguaje escritura guiones (scripting) código programación base datos. . modelo diseño temprano este modelo usa durante etapas tempranas del diseño del sistema después establecer los requerimientos. estimación basa fórmula estimación estándar que discutió introducción, con con-junto simplificado siete multiplicadores. las estimaciones basan puntos función, que luego convierten número líneas código fuente. los puntos función son una forma independiente lenguaje para cuantificar funcionali-dad del programa. número total puntos función programa calcula medir estimar número entradas salidas externas, las interacciones usuario, las interfaces externas las tablas archivos bases datos que usa sistema. . modelo reutilización este modelo emplea para calcular esfuerzo reque-rido integrar los componentes reutilización / código programa generado automáticamente. muchas veces utiliza conjunto con modelo posarquitec-tónico. . modelo posarquitectónico una vez diseñada arquitectura del sistema, puede hacerse una estimación más precisa del tamaño del software. nuevamente, este modelo usa fórmula estándar para estimación costo discutida líneas arriba. sin embargo, incluye conjunto más extenso multiplicadores que reflejan características capacidad personal, del producto del proyecto. desde luego, sistemas grandes pueden desarrollarse diferentes partes del sistema mediante distintas tecnologías posible que tenga que estimar todas las partes del sistema con mismo nivel precisión. tales casos puede usar submodelo productividad del software productividad del software una estimación cantidad promedio trabajo desarrollo que los ingenieros software completan una semana mes. por tanto, expresa como líneas código/mes, puntos función/mes, etcétera. sin embargo, tanto que productividad puede medirse fácilmente donde existe resultado tangible (por ejemplo, oficinista que procesa facturas por día), productividad del software más difícil definir. diferentes personas pueden implementar misma funcionalidad distintas formas, mediante número diferente líneas código. calidad del código también importante pero, cierta medida, considera subjetiva. por consiguiente, las comparaciones productividad entre ingenieros software son poco fiables , por consiguiente, son muy útiles para planeación del proyecto. http:// -.indd -.indd // :: // :: . ■ técnicas estimación adecuado cada parte del sistema combinar los resultados para crear una estimación compuesta. modelo composición aplicación modelo composición aplicación introdujo cocomo para apoyar estimación del esfuerzo requerido para proyectos creación prototipos proyectos que software desarrolla mediante composición los componentes existentes. basa una estimación puntos aplicación ponderados ( ocasiones llamados puntos objeto), divididos entre una estimación estándar productividad puntos apli-cación. entonces estimación ajusta acuerdo con dificultad desarrollar cada punto aplicación (boehm ., ). productividad depende experiencia habilidad del desarrollador, así como las capacidades las herramientas software (icase) usadas para apoyar desarrollo. figura . muestra los niveles produc-tividad punto aplicación sugeridos por los desarrolladores cocomo (boehm ., ). por general, composición aplicaciones incluye una significativa reutilización software. casi seguro que ciertos puntos aplicación sistema imple-menten través componentes reutilización. consecuencia, habrá que ajustar estimación para tomar cuenta porcentaje reutilización previsto. por tanto, fórmula final para calcular esfuerzo del prototipo sistema : (nap ( %reutilización /)) / prod estimación del esfuerzo meses-hombre. nap número puntos aplicación sistema entregado. “%reutilización” una estimación cantidad código reutilización desarrollo. prod productividad del punto aplicación, tal como muestra figura .. modelo produce una estimación aproximada, pues toma cuenta esfuerzo adicional incluido reutilización. modelo diseño temprano este modelo puede usarse durante las primeras etapas proyecto, antes que esté disponible diseño arquitectónico detallado para sistema. las estimaciones diseño temprano son más útiles para exploración opciones que necesario comparar dife-rentes formas implementar los requerimientos del usuario. modelo diseño temprano supone que acordaron los requerimientos del usuario que están marcha las etapas figura . productividad punto aplicaciónexperiencia habilidad del desarrolladormuy bajo bajo nominal alto muy alto madurez capacidad icasemuy bajo bajo nominal alto muy alto prod (nap/mes) -.indd -.indd // :: // :: capítulo ■ planeación proyectos iniciales del proceso diseño del sistema. meta esta etapa debe ser elaborar una estimación rápida aproximada los costos. por tanto, habrá que hacer suposiciones simplificadoras, por ejemplo, que esfuerzo implicado integración del código reutilización cero. las estimaciones generadas esta etapa basan fórmula estándar para mode-los algorítmicos, esto : esfuerzo tamañob con base propio gran conjunto datos, boehm propuso que coeficiente debe ser .. tamaño del sistema expresa ksloc, que número miles líneas código fuente. las ksloc calculan estimar número puntos función software. entonces usan tablas estándar que relacionan tamaño del software con puntos función para diferentes lenguajes programación, con finali-dad hacer una estimación inicial del tamaño del sistema ksloc. exponente refleja esfuerzo creciente requerido conforme aumenta tamaño del proyecto. esto puede variar . ., dependiendo novedad del proyecto, flexibilidad del desarrollo, procesos resolución riesgos utilizados, cohesión del equipo desarrollo nivel madurez del proceso (véase capítulo ) orga-nización. descripción del modelo posarquitectónico cocomo estudia cómo calcular valor este exponente usando dichos parámetros. esto por resultado siguiente cálculo esfuerzo: . tamaño(. .) donde pers rcpx ruse pdif prex fcil sced multiplicador basa siete atributos proyecto proceso que aumentan disminuyen estimación. los atributos que usan modelo diseño temprano son fiabilidad complejidad del producto ( rcpx ), reutilización requerida ( ruse ), dificultad plataforma ( pdif ), habilidad personal ( pers ), experiencia personal ( prex ), calendario (sced ) facilidades soporte ( fcil). estos atributos explican las páginas web del libro. los valores para dichos atributos estiman mediante una escala seis puntos, donde corresponde “muy bajo” corresponde “muy alto”. modelo reutilización como explicó capítulo , ahora común reutilización software. mayo-ría los grandes sistemas incluyen una cantidad significativa código que reutilizó proyectos desarrollo previos. modelo reutilización emplea para estimar esfuerzo requerido integrar código reutilización generado. cocomo considera dos tipos código reutilización. código “caja negra” código que puede reutilizarse sin comprender código hacerle cambios. considera que esfuerzo desarrollo para código caja negra cero. código “caja blanca” tiene que adaptarse para integrarlo código nuevo otros componentes -.indd -.indd // :: // :: . ■ técnicas estimación reutilización. para reutilización requiere esfuerzo desarrollo, pues código tiene que entenderse modificarse antes que pueda trabajar correctamente sistema. muchos sistemas incluyen código generado automáticamente modelos sistema, como estudió capítulo . analiza modelo (con frecuencia uml) genera código para implementar los objetos especificados modelo. modelo reutilización cocomo incluye una fórmula para estimar esfuerzo requerido integrar este código generado: pmauto (asloc /) / atprod // estimación para código generado asloc número total líneas código reutilización, incluido código que genera automáticamente. porcentaje código reutilización que genera automáticamente. atprod productividad los ingenieros para integrar tal código. boehm sus colaboradores () midieron atprod aproximadamente , enunciados fuente por mes. por tanto, existe total líneas código fuente reutilización sistema % éste genera automáticamente, enton-ces esfuerzo que requiere para integrar código generado : (, /) / . meses-hombre // código generado para estimar esfuerzo requerido integrar código reutilización otros sis-temas, realiza cálculo esfuerzo separado. modelo reutilización calcula directamente esfuerzo partir una estimación del número componentes reuti-lización. vez ello, con base número líneas código que reutilizan, modelo ofrece una base para calcular número equivalente líneas código nuevo ( esloc ). éste basa número líneas código reutilización que deben cam- biarse multiplicador que refleja cantidad trabajo que necesario hacer para reutilizar los componentes. fórmula que calcula esloc toma cuenta esfuerzo requerido para comprender software, hacer cambios código reutilización sistema para integrar dicho código. siguiente fórmula usa para calcular número líneas equivalentes código fuente: esloc asloc aam esloc número equivalente líneas nuevo código fuente. asloc número líneas código los componentes que deben cambiarse. aam multiplicador ajuste adaptación, como estudia continuación. reutilización nunca gratuita incurre algunos costos aun ninguna reutili- zación posible. sin embargo, los costos reutilización disminuyen conforme aumenta cantidad código reutilización. los costos fijos comprensión valoración dispersan través más líneas código. multiplicador ajuste adaptación -.indd -.indd // :: // :: capítulo ■ planeación proyectos (aam ) ajusta estimación para reflejar esfuerzo adicional requerido para reutilizar código. manera simplista, aam suma tres componentes: . componente adaptación (conocido como aaf) que representa los costos hacer cambios código reutilización. componente adaptación incluye sub- componentes que toman cuenta cambios diseño, código integración. . componente comprensión (conocido como ) que representa los costos para comprender código reutilizar familiaridad del ingeniero con código. varía para código complejo estructurado, para código orientado objetos bien escrito. . factor valoración (conocido como ) que representa los costos tomar decisión reutilizar. esto , siempre requiere algún análisis para decidir código puede reutilizarse , esto incluye costo como . factor varía , dependiendo cantidad esfuerzo análisis requerido. alguna adaptación del código puede hacerse automáticamente, esto reduce esfuerzo requerido. por tanto, estimación ajusta evaluar porcentaje códi- adaptado automáticamente ( ) usar esto para ajustar asloc . consecuencia, fórmula final : esloc asloc ( /) aam una vez calculado esloc , aplica fórmula estimación estándar para calcular esfuerzo total requerido, que parámetro tamaño esloc . entonces suma esto esfuerzo para integrar código generado automáticamente calculado, que permite calcular esfuerzo total requerido. nivel posarquitectónico modelo posarquitectónico más detallado los modelos cocomo . usa una vez que está disponible diseño arquitectónico inicial para sistema, mane- que conoce estructura del subsistema. entonces posible hacer estimaciones para cada parte del sistema.controladores costos cocomo los controladores costos (cost drivers) cocomo son atributos que reflejan algunos los factores del producto, equipo, proceso organización que afectan cantidad esfuerzo necesario para desarrollar sistema software. por ejemplo, requiere alto nivel fiabilidad, será preciso esfuerzo adicional; hay demanda entrega rápida, requerirá esfuerzo adicional; cambian los miembros del equipo, solicitará esfuerzo adicional. modelo cocomo hay estos atributos, los que los desarrolladores del modelo asignaron valores. http:// -.indd -.indd // :: // :: . ■ técnicas estimación punto partida para las estimaciones producidas nivel posarquitectónico misma fórmula básica usada las estimaciones diseño temprano: tamañob para esta etapa del proceso, hay que hacer una estimación más precisa del tamaño del proyecto conforme conoce cómo dividirá sistema objetos módulos. estas estimaciones del tamaño del código hacen mediante tres parámetros: . una estimación del número total líneas código nuevo desarrollar ( sloc ). . una estimación los costos reutilización, con base número equivalente líneas código fuente ( esloc ), calculadas mediante modelo reutilización. . una estimación del número líneas código que probable modifiquen debido cambios los requerimientos del sistema. los valores estos parámetros suman para calcular tamaño código total, ksloc, que emplea fórmula cálculo esfuerzo. componente final estimación, número líneas código modificado, refleja hecho que los reque-rimientos software siempre cambian. esto conduce reelaboración desarrollo código adicional, que debe tomarse cuenta. desde luego, con frecuencia habrá incluso más incertidumbre esta cifra que las estimaciones código nuevo desa-rrollar. término exponente ( ) fórmula cálculo esfuerzo relaciona con los niveles complejidad del proyecto. conforme los proyectos hacen más complejos, los efectos aumentar tamaño del sistema hacen más significativos. sin embar-, las prácticas los procedimientos organizacionales adecuados pueden controlar deseconomía escala que surge como consecuencia aumentar complejidad. por tanto, valor del exponente basa cinco factores, como muestra figura .. dichos factores clasifican una escala seis puntos, , donde signi-fica “extra alto” significa “muy bajo”. para calcular , suman las clasificaciones, dividen entre los resultados suman . para obtener exponente que debe usarse. por ejemplo, imagine que una organización acepta proyecto dominio que tiene poca experiencia. cliente del proyecto tiene definido proceso usar asignado tiempo calendario del proyecto para análisis del riesgo significativo. nuevo equipo desarrollo debe reunirse para implementar este sistema. organi-zación dispuso recientemente programa mejoramiento procesos clasificó como una organización nivel acuerdo con valoración capacidad sei, que estudiará capítulo . por consiguiente, los posibles valores para las clasificaciones empleadas cálculo del exponente son: . precedencia, calificada baja (). éste proyecto nuevo para organización. . flexibilidad desarrollo, clasificada muy alta (). hay involucramiento del cliente proceso desarrollo, manera que hay pocos cambios impuestos desde exterior. -.indd -.indd // :: // :: capítulo ■ planeación proyectos . resolución arquitectura/riesgo, clasificada muy baja (). realizado análisis riesgos. . cohesión del equipo, clasificada nominal (). éste equipo nuevo, así que hay información disponible acerca cohesión. . madurez del proceso, clasificada nominal (). existe cierto control del proceso. suma estos valores . entonces exponente calcula dividir esto entre sumar resultado .. por tanto, valor ajustado .. estimación del esfuerzo global perfecciona usando conjunto extenso atributos (controladores costos) del producto, proceso organización, lugar los siete atributos usados modelo diseño temprano. usted puede estimar los valores estos atributos porque tiene más información acerca del software , sus requerimientos funcionales, equipo desarrollo proceso desarrollo. figura . muestra cómo los atributos del controlador costos pueden influir las estimaciones del esfuerzo. este libro tomó valor . para expo-nente, como discutió ejemplo anterior, supone que rely , cplx , stor , tool sced son los controladores costos clave proyecto. todos los otros controladores costos tienen valor nominal , así que afectan cálculo del esfuerzo. figura . asignaron valores máximo mínimo los controladores costos clave para mostrar cómo influye estimación del esfuerzo. los valores tomados son los del manual referencia cocomo (boehm, ). como observa, valores altos para los controladores costos conducen una estimación del esfuerzo que más tres veces estimación inicial, mientras que los valores bajos reducen estimación aproximadamente tercio del original. esto destaca las diferencias significativas entre distintos tipos proyectos las dificultades transferir experiencia dominio aplicación otro.figura . factores escala empleados cálculo exponente modelo posarquitectónicofactor escala explicación precedencia refleja experiencia previa organización con este tipo proyectos. muy bajo significa ninguna experiencia; extra alto significa que organización está completamente familiarizada con este dominio aplicación. flexibilidad desarrollo refleja grado flexibilidad proceso desarrollo. muy bajo significa que usa proceso establecido; extra alto significa que cliente sólo establece las metas generales. resolución arquitectura/riesgorefleja extensión análisis riesgos realizado. muy bajo significa poco análisis; extra alto significa análisis riesgos completo profundidad. cohesión equipo refleja cuán bien equipo desarrollo conoce trabaja conjunto. muy bajo significa interacciones muy difíciles; extra alto significa equipo integrado efectivo sin problemas comunicación. madurez del proceso refleja madurez del proceso organización. cálculo este valor depende del cuestionario madurez cmm, pero puede lograrse una estimación restar nivel madurez del proceso cmm . -.indd -.indd // :: // :: . ■ técnicas estimación .. duración del proyecto asignación personal además estimar los costos globales proyecto esfuerzo que requiere para desarrollar sistema software, los administradores proyecto también deben estimar cuánto tardará software desarrollarse, cuándo personal necesitará trabajar proyecto. cada vez más, las organizaciones demandan calendarios desarrollo más cortos, forma que sus productos puedan llegar mercado antes que los sus competidores. modelo cocomo incluye una fórmula para estimar tiempo calendario reque-rido para completar proyecto: tdev () (. .*( .) tdev calendario nominal para proyecto, meses calendario, que ignora cual- quier multiplicador relacionado con calendario del proyecto. esfuerzo calculado por modelo cocomo. exponente relacionado con complejidad, como estudió sección ... . , entonces tdev (). mesesvalor del exponente . tamaño del sistema (incluidos factores para reutilización volatilidad requerimientos) dsi estimación cocomo inicial sin controladores costos meses-hombre fiabilidad muy alto, multiplicador = . complejidad muy alto, multiplicador = . restricción memoria alto, multiplicador = . uso herramientas bajo, multiplicador = . calendario acelerado, multiplicador = . estimación cocomo ajustada , meses-hombre fiabilidad muy bajo, multiplicador = . complejidad muy bajo, multiplicador = . restricción memoria ninguno, multiplicador = uso herramientas muy alto, multiplicador = . calendario normal, multiplicador = estimación cocomo ajustada meses-hombrefigura . efecto los controladores costos sobre las estimaciones del esfuerzo -.indd -.indd // :: // :: capítulo ■ planeación proyectos sin embargo, necesariamente son mismo calendario proyecto nominal pre- dicho por modelo cocomo calendario requerido por plan del proyecto. puede haber requerimiento para entregar software más pronto (muy rara vez) después fecha sugerida por calendario nominal. calendario comprime, aumenta esfuerzo requerido para proyecto. multiplicador sced toma cuenta esto cálculo estimación del esfuerzo. suponga que tdev estimado del proyecto meses, como sugirió ante- riormente, pero calendario real requerido fue meses. esto representa una com-presión del calendario aproximadamente por ciento. usar los valores para multiplicador sced derivados por equipo boehm, multiplicador del esfuerzo para tal compresión calendario .. por tanto, esfuerzo real que requerirá este calendario acelerado cumple casi % mayor que esfuerzo requerido para entregar software acuerdo con calendario nominal. existe una compleja relación entre número personas que trabajan pro-yecto, esfuerzo que dedicará éste calendario entrega del proyecto. cua-tro personas logran completar proyecto meses ( decir, meses-hombre esfuerzo), entonces puede considerar que, agregar una persona más, posible com-pletar trabajo meses ( meses-hombre esfuerzo). sin embargo, modelo cocomo sugiere que, hecho, necesitarán seis personas para terminar trabajo meses ( meses-hombre esfuerzo). razón para esto que agregar una persona reduce realidad productividad los miembros del equipo existente , por ende, incremento real esfuerzo agregado menor que que representa una persona. conforme aumenta tamaño del equipo del pro-yecto, los miembros del equipo pasan más tiempo comunicándose definiendo las inter-faces entre las partes del sistema desarrollado por otras personas. por tanto, duplicar número personal (por ejemplo) significa que duración del proyecto reducirá mitad. equipo desarrollo grande, ocasiones hecho agregar más personas proyecto extiende, vez reducir, calendario desarrollo. myers () discute los problemas aceleración del calendario. sugiere que probable que los proyectos operen hacia problemas significativos tratan desarrollar software sin permitir sufi-ciente tiempo calendario para completar trabajo. puede simplemente estimar número personas requerido para equipo proyecto dividir esfuerzo total entre tiempo contemplado calendario del proyecto requerido. por general, inicio del proyecto necesita pequeño número personas para realizar diseño inicial. entonces equipo crece hasta nivel pico durante desarrollo las pruebas del sistema, luego declina tamaño conforme sistema prepara para despliegue. demostrado que una acumulación muy rápida personal del proyecto correlaciona con atrasos calendario éste. por tanto, los administradores deben evitar agregar demasiado personal proyecto etapas tempranas ciclo vida. esta acumulación esfuerzo puede modelarse con curva rayleigh (londeix, ). modelo estimación putnam (), que incorpora modelo dotación personal proyecto, basa estas curvas rayleigh. este modelo también incluye tiempo desarrollo como factor clave. conforme reduce tiempo desarrollo, esfuerzo requerido para desarrollar sistema crece exponencialmente. -.indd -.indd // :: // :: pmcapítulo ■ lecturas sugeridas puntos clave ■ precio que cobra por sistema depende sólo sus costos desarrollo estimados ganancia requerida por compañía desarrollo. factores organizacionales pueden significar que precio aumente para compensar riesgo creciente disminuya para conseguir ventaja competitiva. ■ con frecuencia software asigna precio para obtener contrato entonces funcionalidad del sistema ajusta para satisfacer precio estimado. ■ desarrollo dirigido por plan organiza torno plan proyecto completo que define las actividades del proyecto, esfuerzo planeado, calendario actividades quién responsable cada actividad. ■ calendarización del proyecto implica elaboración varias representaciones gráficas parte del plan del proyecto. las gráficas barras, las cuales muestran duración actividad los cronogramas dotación personal, son las representaciones calendario que usan con mayor frecuencia. ■ hito proyecto resultado predecible una actividad conjunto actividades. cada hito debe presentarse administración reporte formal avance. entregable producto trabajo que entrega cliente del proyecto. ■ juego planeación implica todo equipo planeación del proyecto. plan desarrolla incrementalmente , surgen problemas, ajustan modo que funcionalidad del software reduzca lugar que demore entrega incremento. ■ las técnicas estimación para software pueden basarse experiencia ( que los administradores juzgan esfuerzo requerido) ser algorítmicas ( esfuerzo requerido calcula partir otros parámetros proyecto estimados). ■ modelo costos cocomo modelo costos algorítmico maduro que toma cuenta atributos proyecto, producto, hardware personal cuando formula una estimación del costo. lecturas sugeridas software cost estimation with cocomo . éste libro fundamental sobre modelo cocomo . ofrece una descripción completa del modelo, con muchos ejemplos, incluye software que implementa modelo. ampliamente detallado una lectura ligera. (. boehm ., prentice hall, .) “ten unmyths project estimation”. artículo pragmático que analiza las dificultades prácticas estimación del proyecto desafía algunas suposiciones fundamentales esta área. (. armour, comm. acm, (), noviembre .) agile estimating and planning. este libro una descripción comprensible planeación basada historias, como usa ; además, ofrece fundamentos para usar enfoque ágil planeación proyectos. además, incluye una buena introducción general los conflictos planeación proyectos. (. cohn, prentice hall, .) -.indd -.indd // :: // :: capítulo ■ planeación proyectos “achievements and challenges cocomo-based software resource estimation”. este artículo presenta una historia los modelos cocomo las influencias sobre dichos modelos, examina las variantes estos modelos que han desarrollado. también identifica posibles desarrollos ulteriores enfoque cocomo. (. . boehm . valeridi, ieee software, (), septiembre/ octubre .) http:/ /. doi. org/ . / . . . ejercicios .. ¿ qué circunstancias una compañía puede cobrar justificadamente por sistema software precio mucho mayor que estimación costo del software más margen ganancia razonable? .. explique por qué proceso planeación proyecto iterativo por qué plan debe revisarse manera continua durante proyecto software. .. explique brevemente propósito cada una las secciones plan proyecto software. .. las estimaciones costos son inherentemente riesgosas, sin importar técnica estimación empleada. sugiera cuatro formas las que pueda reducirse riesgo una estimación costos. .. figura . establece algunas tareas, duraciones dependencias. dibuje una gráfica barras que muestre calendario del proyecto. .. figura . muestra las duraciones las tareas para actividades proyecto software. suponga que ocurre grave inconveniente anticipado que tarea , vez tardar días, tarda días. dibuje nuevas gráficas barras que muestren cómo puede reorganizarse proyecto. .. juego planeación basa noción planeación para implementar las historias que representan los requerimientos del sistema. explique los problemas potenciales con este enfoque cuando software tiene alto rendimiento requerimientos confiabilidad. .. administrador software está encargado del desarrollo sistema software crítico protección, que está diseñado con finalidad controlar una máquina radioterapia para tratar pacientes que sufren cáncer. este sistema está embebido máquina debe operar procesador propósito especial con una cantidad fija memoria ( mbytes). máquina comunica con sistema base datos pacientes para obtener los detalles del paciente , después del tratamiento, registrar automáticamente base datos dosis radiación administrada otros detalles tratamiento. usa método cocomo para estimar esfuerzo requerido desarrollar este sistema calcula una estimación meses-hombre. todos los multiplicadores controlador costos establecieron cuando hizo esta estimación. explique por qué debe ajustarse esta estimación para tomar cuenta factores del proyecto, personal, producto organización. sugiera cuatro factores que puedan tener efectos significativos sobre estimación cocomo inicial proponga posibles valores para estos factores. justifique por qué debe incluir cada factor. -.indd -.indd // :: // :: pmcapítulo ■ referencias .. algunos proyectos software muy grandes implican escribir millones líneas código. explique por qué los modelos estimación esfuerzo, como cocomo, pueden funcionar bien cuando aplican sistemas muy grandes. .. ¿ ético que una compañía cotice precio bajo para contrato software, sabiendas que los requerimientos son ambiguos que pueden cobrar precio alto por cambios posteriores solicitados por cliente? referencias beck, . (). extreme programming explained. reading, mass.: addison-wesley. boehm, . . “cocomo model definition manual”. center for software engineering, university southern california. http://csse.usc.edu/csse/research/cocomoii/cocomo./cii_ modelman..pdf.tarea duración (días) dependencias , , , , , , . ejemplo calendarizaciónfigura . ejemplo calendarización -.indd -.indd // :: // :: capítulo ■ planeación proyectos boehm, ., clark, ., horowitz, ., westland, ., madachy, . selby, . (). “cost models for future life cycle processes: cocomo ”. annals software engineering, –. boehm, . royce, . (). “ada cocomo and the ada process model”. proc. cocomo users’ group meeting, pittsburgh: software engineering institute.boehm, . . (). software engineering economics. englewood cliffs, : prentice hall.boehm, . ., abts, ., brown, . ., chulani, ., clark, . ., horowitz, ., madachy, ., reifer, . steece, . (). software cost estimation with cocomo . upper saddle river, : prentice hall. londeix, . (). cost estimation for software development. wokingham: addison-wesley.myers, . (). “allow plenty time for large-scale software”. ieee software, (), –. putnam, . . (). “ general empirical solution the macro software sizing and estimating problem”. ieee trans. software engineering., - (), –. schwaber, . (). agile project management with scrum. seattle: microsoft press. -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo gestión calidad medición del software. estudiar este capítulo: ■ estará tanto del proceso gestión calidad sabrá por qué importante planeación calidad; ■ comprenderá que calidad del software afectada por proceso desarrollo del software utilizado; ■ conocerá importancia los estándares proceso gestión calidad aprenderá cómo usan los estándares aseguramiento calidad; ■ distinguirá forma que utilizan las revisionese inspecciones como mecanismo para garantizar calidad del software; ■ identificará cómo pueden ser útiles las mediciones valoración algunos atributos calidad del software las limitaciones actuales medición del software. contenido . calidad del software . estándares software . revisiones inspecciones . medición métricas del software gestión calidad -.indd -.indd // :: // :: capítulo ■ gestión calidad los problemas calidad del software descubrieron inicialmente década con desarrollo los primeros grandes sistemas software, han continuado inva-diendo ingeniería software partir esa década. software entregado era lento poco fiable, difícil mantener reutilizar. descontento con esta situación con-dujo adopción técnicas formales gestión calidad del software, desarrolladas partir métodos usados industria manufacturera. estas técnicas gestión calidad, conjunto con nuevas tecnologías mejores pruebas software, llevaron progresos significativos nivel general calidad del software. gestión calidad del software para los sistemas software tiene tres intereses fundamentales: . nivel organización, gestión calidad ocupa establecer marco proceso estándares organización que conducirán software mejor calidad. esto supone que equipo gestión calidad debe tener responsabilidad definir los procesos desarrollo del software usar, los estándares que deben apli-carse software documentación relacionada, incluyendo los requerimientos, diseño código del sistema. . nivel del proyecto, gestión calidad implica aplicación procesos espe-cíficos calidad verificación que continúen dichos procesos planeados; además, ocupa garantizar que los resultados del proyecto estén conformidad con los estándares aplicables dicho proyecto. . nivel del proyecto, gestión calidad ocupa también establecer plan calidad para proyecto. plan calidad debe establecer metas calidad para proyecto definir cuáles procesos estándares usarán. los términos aseguramiento calidad control calidad utilizan ampliamente industria manufacturera. aseguramiento calidad (, por las siglas quality assurance) definición procesos estándares que deben conducir obtención productos alta calidad , proceso fabricación, introducción procesos calidad. control calidad aplicación dichos procesos calidad para elimi-nar aquellos productos que cuentan con nivel requerido calidad. industria software, diversas compañías sectores industriales interpretan maneras diferentes aseguramiento calidad control calidad. ocasiones, aseguramiento calidad representa simplemente definición procedimientos, proce-sos estándares cuyo objetivo asegurar logro calidad del software. otros casos, aseguramiento calidad incluye también todas las actividades gestión configu-ración, verificación validación aplicadas después que equipo desarrollo entrega producto. este capítulo usa término aseguramiento calidad para incluir verificación validación, los procesos que comprobación procedimientos calidad aplicó manera adecuada. evita término “control calidad”, puesto que esta expresión usa mucho industria del software. mayoría las compañías, equipo responsable administrar pro-ceso pruebas liberación. como explicó capítulo , esto significa que aplican las pruebas del software antes que éste libere los clientes. equipo responsable comprobar que las pruebas del sistema cubran los requerimientos mantener los registros adecuados del proceso pruebas. como capítulo estudiaron las pruebas liberación, este apartado trata este aspecto del aseguramiento calidad. -.indd -.indd // :: // :: pmcapítulo ■ gestión calidad gestión calidad proporciona una comprobación independiente sobre pro- ceso desarrollo software. proceso gestión calidad verifica los entrega-bles del proyecto para garantizar que sean consistentes con los estándares las metas dela organización (figura .). equipo debe ser independiente del equipo desa-rrollo para que pueda tener una perspectiva objetiva del software. esto les permite reportar calidad del software sin estar influidos por los conflictos desarrollo del software. preferencia, equipo gestión calidad debe asociarse con algún grupo desarrollo particular; sin embargo, tiene responsabilidad ante toda organización por administración calidad. equipo debe ser independiente reportarse ante administración ubicada sobre nivel del administrador del proyecto. razón que los administradores proyecto tienen que mantener presupuesto calendario del proyecto. surgen problemas, pueden estar tentados comprometer calidad del pro-ducto para cumplir con calendario. equipo gestión calidad independiente garantiza que las metas calidad organización estén comprometidas corto plazo por consideraciones presupuesto calendario. sin embargo, compañías más pequeñas, esto prácticamente imposible. gestión calidad desarrollo soft-ware están inevitablemente vinculados con las personas que tienen responsabilidades tanto desarrollo como calidad. planeación calidad proceso desarrollar plan calidad para pro-yecto. plan calidad debe establecer las cualidades deseadas software describir cómo valorarán. por tanto, define que realmente significa software “alta cali-dad” para sistema particular. sin esta definición, los ingenieros pueden hacer diferen-tes suposiciones, algunas veces conflictivas, sobre cuáles atributos del producto reflejan las características calidad más importantes. planeación calidad formalizada parte integral los procesos desarrollo basados plan. obstante, los métodos ágiles adoptan enfoque menos formal para gestión calidad. humphrey (), clásico libro referente gestión del software, sugiere bosquejo estructura para plan calidad. éste incluye: . introducción del producto una descripción del producto, pretensión mer- cado las expectativas calidad para producto. . planes del producto indican las fechas entrega críticas las responsabilidades para producto, junto con planes para distribución servicio producto.proceso desarrollo software proceso gestión calidadd estándares procedimientosplan calidadreportes revisión calidad figura . gestión calidad desarrollo software -.indd -.indd // :: // :: capítulo ■ gestión calidad . descripciones procesos describen los procesos estándares desarrollo servicio que deben usarse para diseño gestión del producto. . metas calidad las metas los planes calidad para producto, incluyendo una identificación justificación los atributos esenciales calidad del producto. . riesgos gestión del riesgo los riesgos clave que pueden afectar calidad del producto las acciones tomar para enfrentar dichos riesgos. los planes calidad, que desarrollan como parte del proceso planeación gene-ral del proyecto, difieren detalle dependiendo del tamaño tipo sistema que desarrolló. sin embargo, cuando escriba planes calidad, debe tratar mantenerlos tan breves como sea posible. documento demasiado amplio, las personas leerán , consecuencia, anulará propósito generar plan calidad. algunas personas consideran que calidad del software puede lograrse mediante pro-cesos establecidos basados estándares organización procedimientos calidad asociados que verifican seguimiento dichos estándares mediante equipo desa-rrollo software. argumento que los estándares dirigen buena práctica ingeniería software que seguir esta buena práctica conducirá productos alta cali- dad. obstante, práctica, considera que gestión calidad hay mucho más que estándares burocracia asociados para asegurar que éstos sigan. aunque los estándares procesos son importantes, los administradores calidad deben enfocarse también desarrollar una “cultura calidad” que todo respon-sable del desarrollo del software comprometa lograr alto nivel calidad del producto. deben exhortar los equipos asumir responsabilidad calidad trabajo desarrollar nuevos enfoques para mejoramiento calidad. pesar que los estándares procedimientos son base gestión calidad, los buenos adminis-tradores calidad reconocen que existen aspectos intangibles calidad del software (elegancia, legibilidad, etcétera) que pueden expresarse estándares. deben apoyar gente interesada aspectos intangibles calidad impulsar comportamiento profesional todos los miembros del equipo. gestión calidad formalizada particularmente importante para los equipos que diseñan grandes sistemas larga duración, los cuales tardan varios años desa-rrollarse. documentación calidad registro que cada subgrupo realizó proyecto. ayuda las personas comprobar que olvidaron tareas importantes que grupo hizo suposiciones incorrectas acerca que hicieron otros grupos. documentación calidad también medio comunicación durante vida del sistema. permite los grupos responsables evolución del sistema encontrar las pruebas comprobaciones que equipo desarrollo debe implementar. para sistemas más pequeños, gestión calidad aún importante, aunque puede adoptarse enfoque más informal. necesita tanto papeleo, puesto que equipo desarrollo pequeño puede comunicarse manera informal. aspecto calidad clave para desarrollo sistemas pequeños establecer una cultura calidad ase-gurarse que todos los miembros del equipo tienen enfoque positivo sobre calidad del software. -.indd -.indd // :: // :: . ■ calidad del software . calidad del software industria manufacturera estableció los fundamentos gestión calidad para mejorar ésta los productos que fabricaban. como parte ello desarrolló una definición calidad, que basa conformidad con una especificación produc- detallada (crosby, ) noción tolerancia. suposición subyacente era que los productos podían especificarse por completo establecerse procedimientos que com-probaran producto manufacturado cumplía con especificación. desde luego, los productos nunca cumplirán exactamente una especificación, pues permite cierta tolerancia. producto era “casi bueno”, clasificaba como aceptable. calidad del software directamente comparable con calidad fabrica-ción. idea tolerancia aplicable los sistemas digitales prácticamente imposible llegar una conclusión objetiva sobre sistema software cumple especificación, por las siguientes razones: . como explicó capítulo , referente ingeniería requerimientos, difícil escribir especificaciones software completas sin ambigüedades. los desarrolladores clientes software pueden interpretar los requerimientos dife-rentes formas tal vez sea imposible llegar acuerdos acerca software desarrolló conforme especificación. . por general, las especificaciones integran requerimientos varias clases par-ticipantes. dichos requerimientos son compromiso ineludible tal vez inclu-yan los requerimientos todos los grupos participantes. por tanto, las partes interesadas excluidas quizá perciban sistema como uno mala calidad, pesar que implementa los requerimientos acordados. . imposible medir manera directa ciertas características calidad (por ejemplo, mantenibilidad) , por ende, pueden especificarse plenamente sin ambigüedades. sección . estudian las dificultades medición. debido estos problemas, valoración calidad del software proceso sub-jetivo que equipo gestión calidad tiene que usar juicio para decidir logró nivel aceptable calidad. equipo gestión calidad debe considerar software ajusta propósito pretendido. esto implica responder preguntas sobre las características del sistema. por ejemplo: . ¿ proceso desarrollo siguieron los estándares programación docu- mentación? . ¿ software verificó manera adecuada? . ¿ software suficientemente confiable para utilizarse?. ¿ rendimiento del software aceptable para uso normal? -.indd -.indd // :: // :: capítulo ■ gestión calidad . ¿ software utilizable? . ¿ software está bien estructurado comprensible? existe suposición general gestión calidad del software que sistema pondrá prueba contra sus requerimientos. decisión acerca entregar funcionalidad requerida debe basarse los resultados dichas pruebas. por tanto, equipo debe revisar las pruebas que desarrollaron examinar los registros pruebas para verificar que éstas hayan realizado manera apropiada. algunas organizaciones equipo gestión calidad responsable las pruebas del sistema, pero, ocasiones, grupo pruebas sistema separado responsable esto. calidad subjetiva sistema software basa principalmente sus caracte-rísticas funcionales. esto refleja experiencia práctica del usuario: funcionalidad del software que esperaba, entonces los usuarios con frecuencia sólo darán vuelta este asunto encontrarán otras formas hacer que quieren. sin embargo, software fiable resulta muy lento, entonces prácticamente imposible que los usuarios logren sus metas. por consiguiente, calidad del software sólo trata funcionalidad éste implementó correctamente, sino también depende los atributos funcionales del sistema. boehm sus colaboradores () indican que existen importantes atributos calidad software, los cuales listan figura .. dichos atributos relacio-nan con confiabilidad, usabilidad, eficiencia mantenibilidad del software. como estudió capítulo , por general considera que los atributos confiabilidad son los atributos calidad más importantes sistema. sin embargo, también significativo rendimiento del software. los usuarios rechazarán software que sea demasiado lento. posible que algún sistema optimice para todos esos atributos; por ejemplo, mejorar robustez puede conducir pérdida rendimiento. consecuencia, plan calidad debe definir los atributos calidad más importantes para software que desarrollará. tal vez eficiencia sea crítica tengan que sacrificarse otros factores para que logre esto. anterior estableció plan calidad, los ingenieros que trabajan desarrollo pueden cooperar para lograrlo. plan debe incluir también una definición del proceso valoración calidad. ésta debe ser una forma acordada valorar cierto grado calidad, como mantenibilidad robustez, está presente producto. una suposición que subyace gestión calidad del software que cali-dad del software relaciona directamente con calidad del proceso desarrollo del protección comprensibilidad portabilidad seguridad comprobabilidad usabilidad fiabilidad adaptabilidad reusabilidad flexibilidad modularidad eficiencia robustez complejidad facilidad para que usuario aprenda utilizarlofigura . atributos calidad del software -.indd -.indd // :: // :: . ■ estándares software software. esto proviene nuevo los sistemas fabriles, donde calidad del producto está estrechamente relacionada con proceso producción. proceso fabricación incluye configurar, establecer operar las máquinas implicadas proceso. una vez que las máquinas operan correctamente, sigue manera natural calidad del pro-ducto. entonces mide calidad del producto proceso modifica hasta que logra nivel calidad necesario. figura . ilustra este enfoque basado pro-ceso para obtener calidad del producto. manufactura existe claro vínculo entre proceso calidad del producto, que proceso relativamente sencillo estandarizar monitorizar. una vez cali-brados los sistemas fabricación, pueden operar una otra vez para generar productos alta calidad; sin embargo, software manufactura, diseña. por tanto, desarrollo del software más compleja relación entre calidad proceso calidad del producto. diseño del software proceso creativo más que mecánico, pues significativa influencia las habilidades experiencia individuales. factores exter-nos, como novedad una aplicación premura por lanzamiento comercial producto, también afectan calidad éste sin importar proceso usado. hay duda que proceso desarrollo utilizado tiene una influencia importante sobre calidad del software, que los buenos procesos tienen más probabilidad con-ducir software buena calidad. gestión calidad mejoramiento del proceso pueden conducir menores defectos software desarrollar. sin embargo, difícil valorar los atributos calidad del software, como mantenibilidad, sin usar software durante largo periodo. consecuencia, difícil decir cómo las características del pro-ceso influyen dichos atributos. más aún, debido papel del diseño creatividad proceso software, estandarización del proceso ocasiones puede exterminar creatividad, cual, lejos elevar calidad, conducirá software calidad inferior. . estándares software los estándares software tienen una función muy importante gestión calidad del software. como indicó, aspecto importante del aseguramiento calidad defi-nición selección estándares que deben aplicarse proceso desarrollo software producto software. como parte este proceso , también pueden elegirse herra-mientas métodos para apoyar uso dichos estándares. una vez seleccionados éstos definir procesodesarrollar productovalorar calidad del producto estandarizar procesomejorar procesocalidad okno figura . calidad basada proceso -.indd -.indd // :: // :: capítulo ■ gestión calidad para uso, deben definirse procesos específicos proyecto para monitorizar uso los estándares comprobar que éstos siguieron. los estándares software son importantes por tres razones: . los estándares reflejan sabiduría que valor para organización. basan conocimiento sobre mejor más adecuada práctica para compañía. con frecuencia, este conocimiento adquiere sólo después gran cantidad ensayo error. configurarla dentro estándar, ayuda compañía reutilizar esta experiencia evitar errores del pasado. . los estándares proporcionan marco para definir, escenario particular, que significa término “calidad”. como dijo, calidad del software subje-tiva, usar estándares establece una base para decidir logró nivel calidad requerido. desde luego, esto depende del establecimiento estándares que reflejen las expectativas del usuario para confiabilidad, usabilidad rendi-miento del software. . los estándares auxilian continuidad cuando una persona retoma trabajo ini-ciado por alguien más. los estándares aseguran que todos los ingenieros dentro una organización adopten las mismas prácticas. consecuencia, reduce esfuerzo aprendizaje requerido iniciarse nuevo trabajo. existen dos tipos estándares ingeniería software relacionados que pueden definirse usarse gestión calidad del software: . estándares del producto aplican producto software desarrollar. incluyen estándares documentos (como estructura los documentos requerimien-tos), estándares documentación (como encabezado comentario estándar para una definición clase objeto) estándares codificación, los cuales defi-nen cómo debe usarse lenguaje programación. . estándares proceso establecen los procesos que deben seguirse durante desarrollo del software. deben especificar cómo una buena práctica desarrollo. los estándares proceso pueden incluir definiciones especificación, procesos diseño validación, herramientas soporte proceso una descripción los documentos que deben escribirse durante dichos procesos.estándares documentación los documentos del proyecto son una forma tangible describir las diferentes representaciones sistema software (requerimientos, uml, código, etcétera) proceso producción. los estándares documentación definen organización diferentes tipos documentos, así como formato del documento. son importantes porque facilitan comprobación que haya omitido material importante los documentos garantiza que los documentos del proyecto tengan una apariencia común. los estándares pueden desarrollarse para proceso escribir documentos, los documentos intercambio documentos. http:// -.indd -.indd // :: // :: . ■ estándares software los estándares deben entregar valor, forma calidad aumentada del producto. hay razón para definir estándares que sean costosos términos tiempo esfuerzo, pues aplicarlos sólo conduce mejoras secundarias calidad. los estándares pro-ducto deben diseñarse forma que puedan aplicarse comprobarse manera efectiva cuanto costos, los estándares proceso deben incluir definición procesos que comprueben que siguieron dichos estándares. desarrollo estándares internacionales ingeniería software, por general, proceso prolongado que reúnen los interesados estándar, elaboran borradores para comentar , finalmente, acuerdan estándar. organismos nacionales internacionales, como .. dod, ansi, bsi, otan ieee, apoyan determinación estándares. trata estándares generales que pueden aplicarse través varios proyectos. entidades tales como otan otras organizaciones defensa pueden requerir que sus propios estándares usen desarrollo contratos que suscriben con compañías software. han desarrollado estándares nacionales internacionales que incluyen terminolo-gía ingeniería software, lenguajes programación como java ++, anotaciones como los símbolos diagramación, procedimientos para derivar escribir requerimien-tos software, procedimientos aseguramiento calidad, procesos verificación validación software (ieee, ). estándares más especializados, como iec (iec, ), desarrollaron para sistemas críticos protección seguridad. los equipos gestión calidad que elaboran estándares para alguna compañía, por general deben basar los estándares dicha compañía estándares nacionales internacionales. usar estándares internacionales como punto partida, equipo aseguramiento calidad debe redactar manual estándares, cual debe definir los estándares que necesita organización. figura . muestran ejemplos estándares que podrían incluirse dicho manual. ocasiones, los ingenieros software consideran los estándares como demasiado prescriptivos realmente poco relevantes para actividad técnica del desarrollo soft-ware. esto probable sobre todo cuando los estándares proyecto requieren docu-mentación registro del trabajo tediosos. aunque general están acuerdo con necesidad los estándares, los ingenieros encuentran menudo razones para señalar que los estándares necesariamente son adecuados para proyecto particular. para estándares producto estándares proceso formato revisión diseño realizar revisión diseño estructura documento requerimientosenviar nuevo código para construcción sistema formato encabezado por métodoproceso liberación versión estilo programación java proceso aprobación del plan del proyecto formato plan proyecto proceso control cambioformato solicitud cambio proceso registro pruebafigura . estándares producto proceso -.indd -.indd // :: // :: capítulo ■ gestión calidad minimizar descontento alentar participación los estándares, los administradores calidad que establezcan los estándares deben dar los siguientes pasos: . involucrar los ingenieros software selección estándares producto los desarrolladores comprenden por qué seleccionaron los estándares, tienen más probabilidad comprometerse con éstos. preferencia, los documentos estándares deben establecer sólo estándar seguir, sino también deben incluir comentarios que expliquen por qué tomaron las decisiones estandarización. . revisar modificar regularmente los estándares para reflejar las tecnologías cam-biantes los estándares son costosos desarrollar tienden guardarse como reliquias manual estándares una compañía. debido los costos dis-cusión requeridos, muchas veces hay reticencia para cambiarlos. aunque manual estándares esencial, debe evolucionar para reflejar las circunstancias tec-nología cambiantes. . ofrecer herramientas software para dar soporte los estándares los desarro-lladores encuentran con frecuencia que los estándares son una pesadilla cuando adhesión ellos incluye tedioso trabajo manual que podría hacerse mediante una herramienta software. está disponible soporte para herramientas, requiere muy poco esfuerzo para seguir los estándares desarrollo software. por ejem-plo, los estándares documento pueden implementarse mediante estilos proce-sador texto. diferentes tipos software necesitan distintos procesos desarrollo, puesto que los estándares deben ser adaptables. hay razón para prescribir una forma particular tra-bajar inadecuada para proyecto equipo proyecto. cada administrador pro-yecto debe tener autoridad modificar los estándares proceso acuerdo con las circunstancias individuales. sin embargo, cuando hacen cambios, importante garanti-zar que dichos cambios conduzcan una pérdida calidad del producto. esto afectará relación una empresa con sus clientes conducirá probablemente aumento los costos del proyecto. administrador del proyecto administrador calidad pueden evitar problemas los estándares planear cuidadosamente calidad oportuna proyecto. deben decidir cuál los estándares organización debe usarse sin cambio, cuáles deben modificarse cuáles ignorarse. posible que deban crearse nuevos estándares res-puesta requerimientos del cliente del proyecto. por ejemplo, tal vez requieran estándares para especificaciones formales han usado proyectos anteriores. .. marco estándares iso existe conjunto internacional estándares que pueden utilizarse desarrollo los sistemas administración calidad todas las industrias, llamado iso . los estándares iso pueden aplicarse varias organizaciones, desde las industrias manufactureras hasta las servicios. iso , más general dichos estándares, aplica organizaciones que diseñan, desarrollan mantienen productos, incluido software. estándar iso desarrolló originalmente , revisión más reciente fue . -.indd -.indd // :: // :: . ■ estándares software estándar iso mismo estándar para desarrollo software, sino marco para elaborar estándares software. establece principios calidad total, describe general proceso calidad, explica los estándares procedimientos organizacionales que deben determinarse. éstos tienen que documentarse manual calidad organización. revisión principal del estándar iso reorientó estándar hacia nueve procesos centrales (figura .). una organización quiere estar conforme con están-dar iso , debe documentar cómo relacionan sus procesos con dichos procesos centrales. también deberá definir mantener registros que demuestren que siguieron los procesos organizacionales establecidos. manual calidad compañía tiene que describir los procesos relevantes los datos proceso que deben recopilarse conservarse. estándar iso define prescribe los procesos calidad específicos que deben usarse una compañía. para estar conformidad con iso , una compañía debe espe-cificar los tipos proceso que muestran figura . tener procedimientos que demuestren que siguen sus procesos calidad. esto permite flexibilidad través sec-tores industriales diversos tamaños compañías. pueden definirse estándares calidad que sean adecuados para tipo software desarrollar. las compañías pequeñas pueden tener procesos burocráticos estar conformidad con iso . sin embargo, esta flexibilidad significa que posible hacer suposiciones sobre las similitudes diferencias entre los procesos distintas compañías que acatan iso . algunas compañías tienen procesos calidad muy rígidos con registros detallados, mientras que otras son mucho menos formales, con poca documentación adicional. figura . muestran las relaciones entre iso , manuales calidad organizacional planes calidad proyecto individuales. este diagrama derivó modelo presentado por ince (), quien explica cómo puede usarse estándar general iso como base para procesos gestión calidad software. bamford dielbler () explican cómo puede aplicarse más reciente estándar iso : las compañías software.adquisición empresarial diseño desarrollo prueba producción entrega servicio soporteadministración empresarial administración del proveedor administración del inventario administración configuraciónprocesos entrega producto procesos soporte figura . procesos centrales iso -.indd -.indd // :: // :: capítulo ■ gestión calidad algunos clientes software demandan que sus proveedores tengan certificación iso . así, los clientes podrán estar seguros que compañía que desarrolla software tiene sistema gestión calidad aprobado. autoridades acreditación independiente examinan los procesos gestión calidad documentación pro-ceso, deciden dichos procesos abarcan todas las áreas especificadas iso . así, certifican que los procesos calidad una compañía, definidos manual cali-dad, concuerdan con estándar iso . algunas personas consideran que certificación iso significa que calidad del software producido por compañías certificadas será mejor que derivado com-pañías certificadas. esto precisamente cierto. estándar iso enfoca garantizar que organización tenga procedimientos gestión calidad que siga dichos procedimientos. hay seguridad que las compañías con certificación iso empleen las mejores prácticas desarrollo software que sus procesos conduz-can software alta calidad. por ejemplo, una compañía podría definir estándares cobertura pruebas que especifiquen que todos los métodos los objetos deben llamarse menos una vez. lamentablemente, este estándar puede cumplirse mediante pruebas software incom-pletas, que incluyen pruebas con diferentes parámetros métodos. tanto sigan los procedimientos prueba definidos conserven registros las pruebas realiza-das, compañía podría tener certificación iso . esta certificación define cali-dad como conformidad con estándares, toma cuenta calidad como advierten los usuarios del software. los métodos ágiles, que evitan documentación enfocan código desarro-llar, tienen poco común con los procesos calidad formal que examinan iso . hecho cierto trabajo para reconciliar estos enfoques (stalhane hanssen, ), pero comunidad desarrollo ágil general opone que considera una carga burocrática conformidad con los estándares. por esta razón, las compañías usa para desarrollar ejemplificado comoejemplificado como documentos soportesplan calidad del proyecto calidad del proyecto calidad del proyecto calidad del proyectomanual calidad organizaciónmodelos calidad iso proceso calidad organización figura . iso gestión calidad -.indd -.indd // :: // :: . ■ revisiones inspecciones que usan métodos desarrollo ágil preocupan pocas veces por certificación iso . . revisiones inspecciones las revisiones inspecciones son actividades que comprueban calidad los entre-gables del proyecto. esto incluye examinar software, documentación los registros del proceso para descubrir errores omisiones, así como observar que siguieron los estándares calidad. como estudió los capítulos , revisiones inspecciones usan junto con las pruebas del programa como parte del proceso general verificación validación del software. durante una revisión, grupo personas examinan software documentación asociada busca problemas potenciales falta conformidad con los estándares. equipo revisión realiza juicios informados sobre nivel calidad entre-gable sistema proyecto. entonces los administradores proyecto pueden usar dichas valoraciones para tomar decisiones planeación asignar recursos proceso desarrollo. las revisiones calidad basan documentos que elaboraron durante pro-ceso desarrollo del software. igual que las especificaciones, diseño código del software, también pueden revisarse los modelos proceso, planes prueba, proce-dimientos gestión configuración, estándares proceso manuales usuario. revisión debe comprobar coherencia integridad los documentos código objeto prueba, asegurarse que han seguido las normas calidad. sin embargo, revisión sólo acerca comprobación conformidad con las normas, sino también utiliza para ayudar descubrir problemas omisiones documentación del software proyecto. las conclusiones revisión deben regis-trarse formalmente como parte del proceso gestión calidad. descubren proble-mas, los comentarios los revisores deben pasar autor del software quien resulte responsable corregir los errores omisiones. propósito las revisiones inspecciones mejorar calidad del software, valorar rendimiento los miembros del equipo desarrollo. revisión pro-ceso público detección errores, comparado con proceso más privado prueba componentes. necesario que los errores cometidos por los individuos revelen todo equipo programación. para garantizar que todos los desarrolladores participen constructivamente con proceso revisión, los administradores proyecto tienen que ser sensibles las preocupaciones individuales. deben desarrollar una cultura trabajo que brinde apoyo culpar cuando descubran errores. aunque una revisión calidad ofrece administración datos sobre software desarrollar, las revisiones calidad son mismo que las revisiones avan- administrativo. como expuso capítulo , las revisiones avance comparan avance real proyecto software frente avance planeado. principal preocu-pación proyecto entregará software útil tiempo dentro del presupuesto. las revisiones progreso toman cuenta factores externos, circunstancias cambian-tes pueden significar que software fase desarrollo requiera que tenga -.indd -.indd // :: // :: capítulo ■ gestión calidad que cambiarse radicalmente. tal vez cancelen los proyectos que desarrollaron soft- ware alta calidad debido cambios empresa entorno operacional. .. proceso revisión aunque existen numerosas variaciones los detalles las revisiones, proceso revisión (figura .) estructura por general tres fases: . actividades previas revisión trata actividades preparatorias esenciales para que sea efectiva revisión. por general, las actividades previas revi-sión ocupan planeación preparación revisión. planeación revisión incluye establecer equipo revisión, organizar tiempo, destinar lugar para revisión distribuir los documentos revisar. durante preparación revisión, equipo puede reunirse para obtener panorama del software revisar. miembros del equipo revisión leen entienden software los docu-mentos estándares relevantes. trabajan manera independiente para encontrar errores, omisiones distanciamiento los estándares. los revisores pueden asistir reunión revisión, pueden hacer sus comentarios por escrito acerca del software. . reunión revisión durante reunión revisión autor del documento programa revisar debe repasar documento con equipo revisión. revisión debe ser relativamente corta, dos horas sumo. miembro del equipo debe dirigir revisión otro registrar formalmente todas las decisiones acciones revi-sión tomar. durante revisión, quien dirige responsable garantizar que consideren todos los comentarios escritos. dirección revisión debe firmar registro comentarios acciones acordados durante revisión. . actividades posteriores revisión después terminada una reunión revi-sión, deben tratarse los conflictos problemas surgidos durante revisión. esto puede implicar corregir bugs software, refactorizar software modo que esté conforme con los estándares calidad, reescribir los documentos. algunas veces, los problemas descubiertos una revisión calidad son tales que necesaria tam-bién una revisión administrativa con finalidad decidir deben disponerse más recursos para corregirlos. después efectuar los cambios, dirección revisión deberá comprobar que hayan considerado todos los comentarios revisión. ocasiones requerirá una revisión ulterior para comprobar que los cambios realiza-dos comprenden todos los comentarios revisión anteriores.actividades posteriores revisión actividades posteriores revisiónreunión revisiónpreparación individual preparación grupoplaneación comprobaciones seguimiento mejoramientocorrección errores figura . proceso revisión software -.indd -.indd // :: // :: . ■ revisiones inspecciones con frecuencia, los equipos revisión tienen eje tres cuatro personas selec- cionadas como revisores principales. miembro debe ser diseñador ejecutivo, quien tendrá responsabilidad tomar decisiones técnicas significativas. los revisores prin-cipales pueden invitar otros miembros del proyecto, como los diseñadores subsis-temas relacionados, para contribuir revisión. tal vez participen revisión todo documento, pero deben concentrarse aquellas secciones que afecten tra-bajo. como alternativa, equipo revisión puede hacer circular documento pedir comentarios por escrito amplio número miembros del proyecto. administra-dor del proyecto necesita participar revisión, menos que anticipen problemas que requieran cambios plan del proyecto. proceso revisión anterior apoya todos los miembros equipo desa-rrollo asignado disponible para una reunión equipo. sin embargo, ahora común que los equipos proyecto estén distribuidos, veces largo del país distintos continentes, así que muchas veces práctico que los miembros del equipo reúnan mismo lugar. ante tales situaciones, pueden usarse herramientas edición documentos para apoyar proceso revisión. los miembros del equipo usan éstos para anotar comentarios documento código fuente software. tales comentarios son visibles para otros miembros del equipo, quienes entonces podrán aprobarlos rechazar-los. sólo requeriría una conversación telefónica cuando deban resolverse desacuerdos entre los revisores. por general, proceso revisión desarrollo software ágil informal. scrum, por ejemplo, hay una junta revisión después completar cada iteración del software (una revisión rápida), que pueden exponerse los conflictos problemas calidad. programación extrema, como estudiará siguiente sección, programación grupos dos personas garantiza que código examine revise constantemente por otro miembro del equipo. los conflictos calidad general también consideran las reuniones diarias del equipo, pero apoya individuos que toman iniciativa para mejorar refactorizar código. por general, los enfoques ágiles son dirigidos por estándares, manera que consideran los asuntos cumplimiento estándares. falta procedimientos calidad formal los métodos ágiles supone que puede haber problemas uso enfoques ágiles compañías que desarrollaron procedi-mientos gestión calidad detallados. las revisiones calidad ocasiones aplazan ritmo del desarrollo del software, así que éstas emplean mejor dentro proceso desarrollo dirigido por plan. este tipo proceso, las revisiones pueden efec-tuarse mientras otros trabajos realizan paralelamente. esto práctico enfoques ágiles que centran manera exclusiva desarrollo del código.roles proceso inspección cuando estableció por primera vez una inspección del programa ibm (fagan, ; fagan, ), definieron algunos roles formales para los miembros del equipo inspección. éstos incluían: moderador, lector código secretario. otros usuarios inspección modificaron dichos roles, pero generalmente acepta que una inspección debe incluir autor del código, inspector, secretario moderador que dirija. http:// -.indd -.indd // :: // :: capítulo ■ gestión calidad .. inspecciones del programa las inspecciones del programa son “revisiones pares” las que los miembros del equipo colaboran para encontrar bugs programa desarrollo. como explicó capí-tulo , las inspecciones pueden ser parte los procesos verificación validación del software. complementan las pruebas, puesto que requieren ejecución del programa. esto quiere decir que posible verificar versiones incompletas del sistema comprobar representaciones como los modelos uml. gilb graham () sugieren que una las formas más efectivas usar las inspecciones revisar los casos prueba para sistema. las inspecciones permiten identificar problemas con las pruebas , así, mejorar efectividad dichas pruebas detección bugs programa. las inspecciones del programa incluyen miembros del equipo con diferentes antece-dentes que realizan una cuidadosa revisión, línea por línea, del código fuente del programa. buscan defectos problemas, los informan una reunión inspección. los defectos pueden ser errores lógicos, anomalías código que indican una condición errónea ciertas características que hayan omitido del código. equipo revisión examina detalle los modelos diseño código del programa destaca las anomalías proble-mas reparar. durante una inspección, con frecuencia usa una lista verificación errores comunes programación para enfocar búsqueda bugs. esta lista verificación basa ejemplos libros, bien, conocimiento defectos normales dominio aplicación común. para diferentes lenguajes programación usan dis-tintas listas verificación, puesto que cada lenguaje tiene sus errores característicos. humphrey (), amplio debate sobre inspecciones, ofrece algunos ejemplos listas verificación inspección. figura . muestran las posibles comprobaciones que pueden hacerse durante proceso inspección. gilb graham () enfatizan que cada organización debe desarrollar lista verificación inspección con base estándares prácti-cas locales. dichas listas verificación deben actualizarse regularmente, conforme encuentren nuevos tipos defectos. los ítems lista verificación varían según lenguaje programación, debido diferentes niveles comprobación posibles tiempo compilación. por ejemplo, compilador java comprueba que las funciones tengan número correcto parámetros; compilador hace. mayoría compañías que introdujeron las inspecciones descubrieron que éstas son muy efectivas para encontrar bugs. fagan () reportó que posible detectar más del % los errores programa mediante inspecciones informales pro-grama. mills sus colaboradores () sugieren que enfoque más formal ins-pección, con base argumentos exactitud, permite detectar más del % los errores programa. mcconnell () compara las pruebas unidad, las que tasa detección defectos alrededor del %, con las inspecciones, las que tasa detección defectos fue del %. también describe diversos estudios caso, incluido ejemplo que introducción revisiones pares condujo aumento productividad del % una reducción los defectos programa del por ciento. pesar reconocida efectividad términos costos, muchas compañías desarrollo software resisten usar inspecciones revisiones pares. los inge-nieros software con experiencia pruebas programa ocasiones son reacios aceptar que las inspecciones son más efectivas que las pruebas para detección defec-tos. los administradores tal vez muestren recelosos porque las inspecciones requieren -.indd -.indd // :: // :: . ■ revisiones inspecciones costos adicionales durante diseño desarrollo. quizá quieran aceptar riesgo que haya ahorros correspondientes los costos prueba del programa. los procesos ágiles pocas veces usan procesos inspección formal revisión pares. vez ello, apoyan los miembros del equipo que cooperan para compro-bar mutuamente código lineamientos informales, tales como “comprobar antes ingresar”, que sugiere que los programadores deben comprobar propio código. los profesionales programación extrema argumentan que programación parejas sustituto efectivo inspección, que, efecto, trata proceso inspección continuo. dos personas observan cada línea código comprueban antes aceptarla. programación grupos dos conduce conocimiento profundo pro-grama, pues ambos programadores deben entender funcionamiento detalle para con-tinuar desarrollo. ocasiones difícil lograr esta profundidad conocimiento otros procesos inspección , por tanto, programación grupos dos permite clase falla comprobación inspección fallas datos  ¿todas las variables del programa inician antes usar sus valores?  ¿todas las constantes tienen nombre? ¿ cota superior los arreglos igual tamaño del arreglo valor – ?  usan cadenas caracteres, ¿ asigna explícitamente delimitador? ¿existe alguna posibilidad desbordamiento buffer? fallas control  para cada enunciado condicional, ¿ condición correcta? ¿hay certeza que termine cada ciclo?  ¿los enunciados compuestos están correctamente colocados entre paréntesis?  caso enunciados, ¿ justifican todos los casos posibles? después cada caso los enunciados requiere paréntesis, ¿éste incluyó? fallas entrada/salida  ¿ usan todas las variables entrada?  ¿ todas las variables salida les asigna valor antes que produzcan?  ¿entradas inesperadas pueden causar corrupción? fallas interfaz  ¿todas las llamadas función método tienen número correcto parámetros?  ¿los tipos parámetro formal real coinciden? ¿los parámetros están orden correcto? los componentes acceden memoria compartida, ¿tienen mismo modelo estructura memoria compartida? fallas gestión almacenamiento modifica una estructura vinculada, ¿todos los vínculos reasignan correctamente?  usa almacenamiento dinámico, ¿ espacio asignó correctamente? ¿ espacio cancela explícitamente después que requiere? fallas gestión excepción  ¿ tomaron cuenta todas las posibles condiciones error? figura . lista verificación una inspección -.indd -.indd // :: // :: capítulo ■ gestión calidad encontrar bugs que veces descubrirían inspecciones formales. sin embargo, programación grupos dos también puede conducir malas interpretaciones los requerimientos, las que ambos miembros del par cometen mismo error. más aún, las parejas pueden tener reticencias para buscar errores, pues uno los dos quiere frenar avance del proyecto. ocasiones, las personas que participan son tan objeti-vas como equipo inspección externo, probable que habilidad para descubrir defectos esté comprometida por cercana relación laboral. . medición métricas del software medición del software ocupa derivar valor numérico perfil para atributo componente, sistema proceso software. comparar dichos valores unos con otros, con los estándares que aplican través una organización, posible extraer conclusiones sobre calidad del software, valorar efectividad los procesos, las herramientas los métodos software. por ejemplo, suponga que una organización pretende introducir una nueva herramien- prueba software. antes introducir herramienta, hay que registrar número defectos descubiertos software tiempo determinado. ésta una línea referencia para valorar efectividad herramienta. después usar herramienta durante algún tiempo, repite este proceso. descubren más defectos mismo lapso, después introducida herramienta, usted tal vez determine que ofrece apoyo útil para proceso validación del software. meta largo plazo medición del software usar medición lugar revisiones para realizar juicios calidad del software. usar medición software, sistema podría valorarse preferentemente mediante rango métricas , partir dichas mediciones, podría inferir valor calidad del sistema. soft-ware alcanzó umbral calidad requerido, entonces podría aprobarse sin revisión. cuando adecuado, las herramientas medición pueden destacar también áreas del software susceptibles mejora. sin embargo, aún está lejos esta situación ideal hay señales que valoración automatizada calidad será futuro una reali-dad previsible. una métrica software una característica sistema software, documen-tación sistema proceso desarrollo que puede medirse manera objetiva. los ejemplos métricas incluyen tamaño producto líneas código; índice fog (gunning, ), que una medida legibilidad pasaje texto escrito; número fallas reportadas producto software entregado, número días-hombre requerido para desarrollar componente sistema. las métricas software pueden ser métricas control predicción. como nombre dice, las métricas control apoyan gestión del proceso, las métricas predicción ayudan predecir las características del software. las métricas control asocian por general con procesos software. ejemplos las métricas control proceso son esfuerzo promedio tiempo requerido para reparar los defectos reportados. las métricas predicción asocian con software veces conocen como métricas producto. ejemplos métricas predicción son comple-jidad ciclomática módulo (estudiado capítulo ), longitud promedio los -.indd -.indd // :: // :: . ■ medición métricas del software identificadores programa, número atributos operaciones asociados con las clases objetos diseño. tanto las métricas control como las predicción pueden influir toma decisiones administrativas, como muestra figura .. los administradores usan mediciones proceso para decidir deben hacerse cambios proceso, las métricas predicción ayudan estimar esfuerzo requerido para hacer cambios software. este capítulo estudian principalmente las métricas predicción, cuyos valores evalúan analizar código sistema software. capítulo estudian las métricas control cómo usan mejoramiento procesos. existen dos formas que pueden usarse las mediciones sistema software: . para asignar valor los atributos calidad del sistema medir las caracte- rísticas los componentes del sistema, como complejidad ciclomática, luego agregar dichas mediciones, posible valorar los atributos calidad del sistema, tales como mantenibilidad. . para identificar los componentes del sistema cuya calidad está por debajo estándar las mediciones pueden identificar componentes individuales con carac-terísticas que desvían norma. por ejemplo, posible medir componentes para descubrir aquéllos con complejidad más alta. éstos tienen más probabilidad tener bugs porque complejidad los hace más difíciles entender. lamentablemente, difícil hacer mediciones directas muchos los atributos calidad del software que muestran figura .. los atributos calidad, como mantenibilidad, comprensibilidad usabilidad, son atributos externos que refieren cómo los desarrolladores usuarios experimentan software. ven afectados por fac-tores subjetivos, como experiencia educación del usuario, , por tanto, pueden medirse manera objetiva. para hacer juicio sobre estos atributos, hay que medir algunos atributos internos del software (como tamaño, complejidad, etcétera) suponer que éstos relacionan con las características calidad por las que uno interesa. figura . muestra algunos atributos externos calidad del software atri-butos internos que podrían, intuitivamente, relacionarse con ellos. aunque diagrama sugiere que pueden existir relaciones entre atributos externos internos, dice cómo decisiones administrativasmediciones métrica controlproceso software mediciones métrica predicciónproducto software figura . mediciones predicción control -.indd -.indd // :: // :: capítulo ■ gestión calidad relacionan dichos atributos. medida del atributo interno debe ser factor pre- dicción útil característica externa del software, deben sostenerse tres condiciones (kitchenham, ): . atributo interno debe medirse con exactitud. esto siempre proceso directo tal vez requiera herramientas propósito especial para hacer las mediciones. . debe existir una relación entre atributo que pueda medirse atributo calidad externo que interés. esto , valor del atributo calidad debe relacionarse, alguna forma, con valor del atributo que puede medirse. . esta relación entre los atributos interno externo debe comprenderse, validarse expre-sarse términos una fórmula modelo. formulación modelo implica identificar manera funcional del modelo (lineal, exponencial, etcétera) mediante análisis datos recopilados, identificar los parámetros que incluirán modelo, calibrar dichos parámetros usando los datos existentes. los atributos software internos, como complejidad ciclomática compo-nente, miden usando herramientas software que analizan código fuente del soft-ware. hay herramientas disponibles fuente abierta que pueden utilizarse para hacer dichas mediciones. aunque intuición sugiere que podría existir una relación entre complejidad componente software número fallas observadas uso, difícil demostrar objetivamente que éste caso. para probar esta hipótesis, requie-ren datos falla para gran número componentes acceso código fuente del componente para análisis. muy pocas compañías han establecido compromiso largo plazo para recopilación datos sobre software, manera que pocas veces están disponibles datos fallas para análisis. década , numerosas grandes compañías, como hewlett-packard (grady, ), & (barnard price, ) nokia (kilpi, ) introdujeron programas métricas. hicieron mediciones sus productos procesos las usaron durante sus fiabilidadprofundidad árbol herencia complejidad ciclomática tamaño del programa líneas código número mensajes error longitud manual usuariomantenibilidad usabilidadreusabilidadatributos calidad externos atributos internos figura . relaciones entre software interno externo -.indd -.indd // :: // :: . ■ medición métricas del software procesos gestión calidad. mayor parte atención centró recolección métricas sobre los defectos programa los procesos verificación validación. offen jeffrey () hall fenton () tratan con más detalle introducción industria programas métricas. existe escasa información disponible público concerniente uso actual industria medición sistemática del software. muchas compañías reúnen informa-ción referente software, como número peticiones cambio requerimientos número defectos descubiertos las pruebas. sin embargo, claro usan entonces dichas mediciones manera sistemática para comparar productos procesos software para valorar efecto los cambios sobre los procesos las herramientas software. existen algunas razones por las que esto dificulta: . imposible cuantificar rentabilidad inversión introducir programa métricas organizacional. años pasados existieron significativas mejoras calidad del software sin uso métricas, así que difícil justificar los costos iniciales introducir medición valoración sistemáticas del software. . hay estándares para las métricas software para los procesos estandariza-dos para medición análisis. muchas compañías son renuentes introducir progra-mas medición hasta que hallan disponibles tales estándares herramientas apoyo. . gran parte las compañías, los procesos software están estandarizados encuentran mal definidos controlados. por tanto, hay demasiada variabilidad procesos dentro misma compañía para que las mediciones usen una forma significativa. . buena parte investigación medición métricas del software enfoca métricas basadas códigos procesos desarrollo basados plan. sin embargo, ahora cada vez más desarrolla software mediante configuración sistemas erp cots, uso métodos ágiles. por consiguiente, sabe investigación previa aplicable dichas técnicas desarrollo software. . introducción medición representa una carga adicional los procesos. esto contradice las metas los métodos ágiles, los cuales recomiendan eliminación actividades proceso que están directamente relacionadas con desarrollo pro- gramas. consecuencia, improbable que las compañías que adoptaron los méto- dos ágiles aprueben programa métricas. medición las métricas software son base ingeniería software empí-rica (endres rombach, ). ésta área investigación que han usado experimentos respecto los sistemas software, recolección datos referente proyectos reales para formar validar hipótesis sobre métodos técnicas ingeniería software. los investigadores que trabajan esta área argumentan que sólo posi-ble confiar valor los métodos las técnicas ingeniería software encuentra evidencia concreta que realidad ofrecen los beneficios que sugieren sus inventores. resulta lamentable que aun cuando posible hacer mediciones objetivas extraer conclusiones partir ellas, esto necesariamente convence quienes toman las deci-siones. vez ello, toma decisiones está influida con frecuencia por factores -.indd -.indd // :: // :: capítulo ■ gestión calidad subjetivos, como novedad, medida que las técnicas son interés para los profe- sionales. por tanto, considera que transcurrirán muchos años antes que los resul-tados ingeniería software empírica presenten efecto significativo sobre práctica ingeniería software. .. métricas del producto las métricas del producto son métricas predicción usadas para medir los atributos internos sistema software. los ejemplos las métricas productos incluyen tamaño del sistema, medida líneas código número métodos asociados con cada clase objeto. por desgracia, como explicó anteriormente esta sección, las características del software que pueden medirse fácilmente, como tamaño com-plejidad ciclomática, tienen una relación clara consistente con los atributos cali-dad como comprensibilidad mantenibilidad. las relaciones varían dependiendo los procesos desarrollo, tecnología empleada tipo sistema diseñar. las métricas del producto dividen dos clases: . métricas dinámicas, que recopilan mediante mediciones hechas programa ejecución. dichas métricas pueden recopilarse durante las pruebas del sistema después que sistema está uso. ejemplo número reportes bugs tiempo necesario para completar cálculo. . métricas estáticas, las cuales recopilan mediante mediciones hechas represen-taciones del sistema, como diseño, programa documentación. ejemplos mediciones estáticas son tamaño del código longitud promedio los identi-ficadores que usaron. estos tipos métrica relacionan con diferentes atributos calidad. las métricas dinámicas ayudan valorar eficiencia fiabilidad programa. las métricas está-ticas ayudan valorar complejidad, comprensibilidad mantenibilidad sistema software los componentes del sistema. por general, existe una relación clara entre métricas dinámicas características calidad del software. muy sencillo medir tiempo ejecución requerido para fun-ciones particulares valorar tiempo requerido con finalidad iniciar sistema. éstos relacionan directamente con eficiencia del sistema. igual modo, número fallas del sistema tipo fallas pueden registrarse relacionarse directamente con fiabilidad del software, que estudió capítulo . como comentó, las métricas estáticas, como las que muestran figura ., tienen una relación indirecta con los atributos calidad. propuesto una gran can-tidad diferentes métricas han intentado muchos experimentos para derivar vali-dar las relaciones entre dichas métricas atributos como complejidad mantenibilidad. ninguno tales experimentos sido concluyente, pero tamaño del programa complejidad del control parecen ser los factores predicción más fiables compren-sibilidad, complejidad del sistema mantenibilidad. las métricas figura . son aplicables cualquier programa, pero también han propuesto métricas más específicas orientadas objetos (). figura . resu- suite chidamber kemerer ( ocasiones llamada suite ) seis métricas -.indd -.indd // :: // :: . ■ medición métricas del software orientadas objetos (). aunque propusieron originalmente principio década , aún son las métricas más amplio uso. algunas herramientas diseño uml recopilan automáticamente valores para dichas métricas conforme crean los diagramas uml. -amam () hace una excelente revisión las métricas orientadas objetos, analiza las métricas otras métricas , concluye que todavía tiene sufi-ciente evidencia para comprender cómo estas otras métricas orientadas objetos relacionan con cualidades externas software. esta situación cambiado realmente desde análisis . todavía sabe cómo usar las mediciones los programas orientados objetos para extraer conclusiones fiables acerca calidad. .. análisis componentes software figura . ilustra proceso medición que puede ser parte proceso valoración calidad del software. cada componente del sistema puede analizarse por separado mediante rango métricas. los valores dichas métricas pueden compa-rarse entonces para diferentes componentes , tal vez, con datos medición históricos métrica software descripción fan-/fan-out fan- (abanico entrada) una medida del número funciones métodos que llaman otra función método (por ejemplo, ). fan-out (abanico salida) número funciones las que llama función . valor alto para fan- significa que está estrechamente acoplado con resto del diseño que los cambios tendrán extensos efectos dominó. valor alto fan-out sugiere que complejidad global puede ser alta debido complejidad lógica control necesaria para coordinar los componentes llamados. longitud código ésta una medida del tamaño programa. por general, cuanto más grande sea tamaño del código componente, más probable será que componente sea complejo proclive errores. demostrado que longitud del código una las métricas más fiables para predecir proclividad error los componentes. complejidad ciclomática ésta una medida complejidad del control programa. tal complejidad del control puede relacionarse con comprensibilidad del programa. capítulo estudia complejidad ciclomática. longitud identificadores ésta una medida longitud promedio los identificadores (nombres para variables, clases, métodos, etcétera) programa. cuanto más largos sean los identificadores, más probable que sean significativos , por ende, más comprensible será programa. profundidad anidado condicionalésta una medida profundidad anidado los enunciados programa. los enunciados profundamente anidados son difíciles entender proclives potencialmente errores. índice fog ésta una medida longitud promedio las palabras oraciones los documentos. cuanto más alto sea valor del índice fog documento, más difícil será entender documento. figura . métricas estáticas productos software -.indd -.indd // :: // :: capítulo ■ gestión calidad recopilados proyectos anteriores. las mediciones anómalas, que desvían significa- tivamente norma, pueden implicar que existen problemas con calidad dichos componentes. las etapas clave este proceso medición componentes son: . elegir las mediciones realizar deben formularse las preguntas que medición busca responder, definir las mediciones requeridas para responder tales pre-guntas. deben recopilarse las mediciones que son directamente relevantes para dichas preguntas. paradigma gqm (por las siglas goal-question-metric, decir, meta-pregunta-métrica) basili (basili rombach, ), que estudia métrica orientada objetos descripción métodos ponderados por clase (weighted methods per class, wmc)éste número métodos cada clase, ponderado por complejidad cada método. por tanto, método simple puede tener una complejidad , método grande complejo tendrá valor mucho mayor. cuanto más grande sea valor para esta métrica, más compleja será clase objeto. más probable que los objetos complejos sean más difíciles entender. tal vez sean lógicamente cohesivos, por que pueden reutilizarse manera efectiva como superclases árbol herencia. profundidad árbol herencia (depth inheritance tree, dit)esto representa número niveles discretos árbol herencia que las subclases heredan atributos operaciones (métodos) las superclases. cuanto más profundo sea árbol herencia, más complejo será diseño. posible que tengan que comprenderse muchas clases objetos para entender las clases objetos las hojas del árbol. número hijos (number children, noc)ésta una medida del número subclases inmediatas una clase. mide amplitud una jerarquía clase, mientras que dit mide profundidad. valor alto noc puede indicar mayor reutilización. podría significar que debe realizarse más esfuerzo para validar las clases base, debido número subclases que dependen ellas. acoplamiento entre clases objetos (coupling between object classes, cbo )las clases están acopladas cuando los métodos una clase usan los métodos variables instancia definidos una clase diferente. cbo una medida cuánto acoplamiento existe. valor alto para cbo significa que las clases son estrechamente dependientes , por tanto, más probable que hecho cambiar una clase afecte otras clases programa. respuesta por clase (response for class, rfc)rfc una medida del número métodos que potencialmente podrían ejecutarse respuesta mensaje recibido por objeto dicha clase. nuevamente, rfc relaciona con complejidad. cuanto más alto sea valor para rfc, más compleja será una clase , por ende, más probable que incluya errores. falta cohesión métodos (lack cohesion methods, lcom) lcom calcula considerar pares métodos una clase. lcom diferencia entre número pares método sin compartir atributos número pares método con atributos compartidos. valor esta métrica debate ampliamente existe muchas variaciones. claro realmente agrega alguna información útil además proporcionada por otras métricas. figura . suite métricas orientadas objetos -.indd -.indd // :: // :: . ■ medición métricas del software capítulo , enfoque adecuado cuando decide cuáles datos hay que recopilar. . seleccionar componentes valorar probablemente usted necesite estimar valo-res métricos para todos los componentes sistema software, que oca-siones podrá seleccionar una muestra representativa componentes para medición, que permitirá realizar una valoración global calidad del sistema. otras circunstancias, tal vez desee enfocarse los componentes centrales del sistema que están casi uso constante. calidad dichos componentes más importante que aquellos componentes que sólo usan muy pocas veces. . medir las características los componentes miden los componentes selec- cionados calculan los valores métrica asociados. por general, esto implica procesar representación los componentes (diseño, código, etcétera) median- una herramienta recolección automatizada datos. esta herramienta puede escribirse especialmente ser una característica las herramientas diseño que están uso. . identificar mediciones anómalas después hacer las mediciones compo- nentes, comparan entonces unas con otras con mediciones anteriores que hayan registrado una base datos mediciones. hay que observar los valores inusualmente altos bajos para cada métrica, pues éstos sugieren que podría haber problemas con componente que muestra dichos valores. . analizar componentes anómalos cuando identifique los componentes con valores anómalos para sus métricas seleccionadas, debe examinarlos para decidir dichos valores métrica anómalos significan que calidad del componente encuentra comprometida. valor métrica anómalo para complejidad ( parecer) necesariamente significa componente mala calidad. podría haber alguna otra razón para valor alto, por que necesariamente significa que haya proble-mas con calidad del componente. siempre conveniente mantener datos recopilados como recurso organizacional, así como registros históricos todos los proyectos aun cuando hayan usado durante proyecto particular. una vez establecida una base suficientemente grande datos medición, será posible hacer comparaciones calidad software través proyectos, además validar las relaciones entre atributos componentes internos características calidad.medir características componentesidentificar mediciones anómalasseleccionar componentes valoraranalizar componentes anómaloselegir mediciones realizar figura . proceso medición producto -.indd -.indd // :: // :: capítulo ■ gestión calidad .. ambigüedad mediciones cuando reúna datos cuantitativos relativos software los procesos software, deberá analizar dichos datos para entender significado. fácil malinterpretar los datos hacer inferencias incorrectas. basta con observar los datos por mismos, sino que también hay que considerar contexto donde recaban los datos. para ilustrar cómo pueden interpretarse los datos recopilados diferentes formas, considere siguiente escenario, que ocupa del número peticiones cambio hechas por los usuarios sistema: una administradora decide monitorizar número peticiones cambio envia-das por los clientes, con base una suposición que existe una relación entre dichas peticiones cambio usabilidad conveniencia del producto. ella supone que cuanto más alto sea número peticiones cambio, menos cumple software las necesidades del cliente. costoso manejar las peticiones cambio modificar software. por tanto, organización decide cambiar proceso con intención mejorar satis-facción del cliente , mismo tiempo, reducir los costos hacer cambios. intención que cambio proceso dará como resultado mejores productos menos peticiones cambio. los cambios proceso inician para aumentar inclusión del cliente proceso diseño del software. introducen pruebas beta todos los produc-tos; además, incorporan producto entregado las modificaciones solici-tadas por cliente. entregan las nuevas versiones los productos, que desarrollan mediante este proceso modificado. algunos casos reduce número peticiones cambio, aunque otros aumenta. administradora está confundida descubre que imposible valorar los efectos los cambios proceso sobre calidad del producto. para comprender por qué puede ocurrir este tipo ambigüedad, hay que conocer las razones por las que los usuarios pueden hacer peticiones cambio: . software bastante bueno hace que quieren los clientes. por tanto, solicitan cambios para obtener funcionalidad que ellos requieren. . como alternativa, software puede ser muy bueno , por consiguiente, usa amplia intensamente. las peticiones cambio pueden generarse porque exis-ten muchos usuarios software que piensan creativamente nuevas ideas que podrían hacer con software. por ende, aumentar participación del cliente proceso puede reducir número peticiones cambio para los productos con los que los clientes están descontentos. los cambios proceso han sido efectivos han hecho software más útil adecuado. sin embargo, alternativamente, los cambios proceso pueden haber funcionado, los clientes tal vez decidieron buscar sistema opcional. número peticiones cambio disminuye porque producto perdió participación mercado frente producto rival , consecuencia, hay menos usuarios del producto. -.indd -.indd // :: // :: pmcapítulo ■ puntos clave por otra parte, los cambios proceso pueden conducir muchos nuevos clientes satisfechos que deseen participar proceso desarrollo del producto. por tanto, generan más peticiones cambio. los cambios proceso manejar las peticiones cambio contribuyen este aumento. compañía tiene mayor capacidad respuesta con los clientes, ellos generarán más peticiones cambio porque saben que éstas tomarán con seriedad. creen que sus sugerencias incorporarán quizás versiones posteriores del software. bien, número peticiones cambio puede aumentar porque los sitios prueba beta eran los típicos del mayor uso del programa. para analizar los datos petición cambio, basta con conocer número peticiones cambio, sino que necesita conocer quién hizo petición, cómo usa software por qué hizo petición. también requiere información sobre los factores externos, como modificaciones procedimiento petición cambio cambios mercado que puedan tener efecto. con esta información, posible averiguar los cambios proceso fueron efectivos para aumentar calidad del producto. esto ilustra las dificultades entender los efectos los cambios, enfoque “cien-tífico” este problema reducir número factores que tiendan afectar las medi-ciones hechas. sin embargo, los procesos productos que miden están aislados entorno. ambiente empresarial cambia constantemente imposible evitar los cambios práctica laboral sólo porque pueden hacerse comparaciones datos inválidos. como tales, los datos cuantitativos sobre las actividades humanas siempre deben tomarse serio. las razones por las que cambia valor medido con frecuencia son ambiguas. dichas razones deben investigarse profundidad antes extraer conclu-siones cualquier medición que haya realizado. puntos clave ■ gestión calidad del software ocupa garantizar que software tenga número menor defectos que alcance los estándares requeridos mantenibilidad, fiabilidad, portabilidad, etcétera. incluye definir estándares para procesos productos, establecer procesos para comprobar que siguieron dichos estándares. ■ los estándares software son importantes para aseguramiento calidad, pues representan una identificación las “mejores prácticas”. desarrollar software, los estándares proporcionan cimiento sólido para diseñar software buena calidad. ■ necesario documentar conjunto procedimientos aseguramiento calidad manual calidad organizacional. esto puede basarse modelo genérico para manual calidad sugerido estándar iso . ■ las revisiones los entregables del proceso software incluyen equipo personas que verifican que siguieron los estándares calidad. las revisiones son técnica usada más ampliamente para valorar calidad. ■ una inspección programa revisión pares, reducido equipo comprueba sistemáticamente código. ellos leen código detalle buscan posibles errores omisiones. entonces los problemas detectados discuten una reunión revisión del código. -.indd -.indd // :: // :: ■ medición del software puede usarse para recopilar datos cuantitativos tanto del software como del proceso software. usan los valores las métricas software recopilados para hacer inferencias referentes calidad del producto proceso. ■ las métricas calidad del producto son particularmente útiles para resaltar los componentes anómalos que pudieran tener problemas calidad. dichos componentes deben entonces analizarse con más detalle. lecturas sugeridas metrics and models for software quality engineering, edition . éste análisis muy completo las métricas del software que incluyen métricas proceso, producto orientadas objetos. también contiene cierto conocimiento matemático requerido para desarrollar comprender modelos basados medición software. (. . kan, addison-wesley, .) software quality assurance: from theory implementation. excelente vistazo actualizado los principios práctica del aseguramiento calidad del software. incluye análisis los estándares, como iso . (. galin, addison-wesley, .) “ practical approach for quality-driven inspections”. actualidad muchos artículos concernientes las inspecciones son más bien anticuados, que consideran práctica moderna del desarrollo software. este texto relativamente reciente describe método inspección que ocupa algunos los problemas utilizar inspección sugiere cómo pueden usarse las inspecciones entorno moderno desarrollo. (. denger, . shull, ieee software, (), marzo-abril .) http:/ /. doi. org/ . / . . “misleading metrics and unsound analyses”. excelente artículo los principales investigadores métricas, quienes analizan las dificultades comprensión que significan realmente las métricas. (. kitchenham, . jeffrey . connaughton, ieee software, (), marzo- abril .) http:/ /. doi. org/ . / . . . “the case for quantitative project management”. ésta una introducción una sección especial revista que incluye otros dos artículos sobre administración cuantitativa proyectos. plantea razones para una mayor investigación métricas medición con finalidad mejorar administración proyectos software. (. curtis ., ieee software, (), mayo-junio .) http:/ /. doi. org/ . / . . . ejercicios .. explique por qué proceso software alta calidad debería conducir productos alta calidad software. discuta los posibles problemas con este sistema gestión calidad. .. exponga cómo pueden usarse los estándares para obtener conocimiento organización sobre los métodos efectivos desarrollo software. sugiera cuatro tipos conocimiento que puedan reflejarse los estándares organización. capítulo ■ gestión calidad -.indd -.indd // :: // :: pmcapítulo ■ referencias .. discuta valoración calidad del software según los atributos calidad mostrados figura .. debe considerar vez cada atributo explicar cómo puede valorarse. .. diseñe formato electrónico que pueda usar para registrar comentarios revisión para enviar comentarios por correo electrónico los revisores. .. describa brevemente posibles estándares que podría utilizar para: • uso sentencias control , # java; • enviar reportes para proyecto final una universidad;• proceso hacer aprobar cambios programa (véase capítulo );• proceso comprar instalar una nueva computadora. .. suponga que trabaja una organización que desarrolla productos bases datos para individuos empresas pequeñas. esta organización está interesada cuantificar desarrollo software. escriba reporte que sugiera métricas adecuadas mencione cómo pueden recopilarse. .. exprese por qué las inspecciones programa son una técnica efectiva para descubrir errores programa. ¿qué tipos errores tienen escasa probabilidad descubrirse mediante inspecciones? .. diga por qué las métricas diseño son, por mismas, método inadecuado para predecir calidad del diseño. .. exponga por qué difícil validar las relaciones entre atributos producto internos (como complejidad ciclomática) los atributos externos (como mantenibilidad). .. colega que muy buen programador elabora software con bajo número defectos, pero siempre pasa por alto los estándares calidad organización. ¿cómo deberían reaccionar sus administradores ante este comportamiento? referencias bamford, . deibler, . . (eds.) (). “iso : for software and systems providers: engineering approach”. boca raton, fla.: crc press. barnard, . price, . (). “managing code inspection information”. ieee software, (), –.basili, . . rombach, . . (). “the tame project: towards improvement-oriented software environments”. ieee trans. software eng., (), –. boehm, . ., brown, . ., kaspar, ., lipow, ., macleod, . merrit, . (). characteristics software quality. amsterdam: north-holland. chidamber, . kemerer, . (). “ metrics suite for object-oriented design”. ieee trans. software eng., (), –. -.indd -.indd // :: // :: pmcrosby, . (). quality free. nueva york: mcgraw-hill. -amam, . . “object-oriented metrics: review theory and practice”. national research council canada. http://seg.iit.nrc./english/abstracts/nrc.html . endres, . rombach, . (). empirical software engineering: handbook observations, laws and theories. harlow, : addison-wesley. fagan, . . (). “design and code inspections reduce errors program development”. ibm systems ., (), –.fagan, . . (). “advances software inspections”. ieee trans. software eng., - (), –.gilb, . graham, . (). software inspection. wokingham: addison-wesley.grady, . . (). “practical results from measuring software quality”. comm. acm, (), –. gunning, . (). techniques clear writing. nueva york: mcgraw-hill.hall, . fenton, . (). “implementing effective software metrics programs”. ieee software, (), –.humphrey, . (). managing the software process. reading, mass.: addison-wesley.iec. . “standard iec : functional safety electrical/electronic/programmable electronic safety-related systems”. international electrotechnical commission: ginebra. ieee. (). ieee software engineering standards collection -rom . los alamitos, .: ieee computer society press.ince, . (). iso and software quality assurance. londres: mcgraw-hill.kilpi, . (). “implementing software metrics program nokia”. ieee software, (), –. kitchenham, . (). “measuring software development”. software reliability handbook. rook, . (.). amsterdam: elsevier, –.mcconnell, . (). code complete: practical handbook software construction, edition . seattle: microsoft press.mills, . ., dyer, . linger, . (). “cleanroom software engineering”. ieee software, (), –.offen, . . jeffrey, . (). “establishing software measurement programs”. ieee software, (), –.stalhane, . hanssen, . . (). “the application iso agile software development”. international conference product focused software process improvement, profes , monte porzio catone, italy: springer. capítulo ■ gestión calidad -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo los procesos las herramientas administración configuración. estudiar este capítulo: ■ comprenderá los procesos procedimientos implicados gestión cambio software; ■ conocerá funcionalidad esencial que debe proporcionar una versión del sistema gestión las relaciones entre gestión versiones construcción sistema; ■ entenderá las diferencias entre una versión del sistema una entrega (release) sistema, identificará las etapas proceso gestión entregas del software. contenido . administración del cambio . gestión versiones . construcción del sistema . gestión entregas software (release) administración configuración -.indd -.indd // :: // :: capítulo ■ administración conﬁ guración los sistemas software siempre cambian durante desarrollo uso. descubren bugs éstos deben corregirse. los requerimientos del sistema cambian, necesario imple-mentar dichos cambios una nueva versión del sistema. dispone nuevas versiones hardware plataformas sistema, por que hay que adaptar los sistemas para que funcionen con ellos. los competidores introducen nuevas características sus sistemas que deben igualar. conforme hacen cambios software, crea una nueva versión del sistema. consecuencia, mayoría los sistemas pueden considerarse como conjunto versiones, cada una las cuales debe mantenerse gestionarse. administración configuración (, por las siglas configuration manage-ment) ocupa las políticas, los procesos las herramientas para administrar los sis-temas cambiantes software. necesario gestionar los sistemas evolución porque fácil perder pista cuáles cambios versiones del componente incorporaron cada versión del sistema. las versiones implementan propuestas para cambios, correc-ciones fallas adaptaciones para diferentes tipos hardware sistemas operativos. pueden existir mismo tiempo numerosas versiones uso bajo desarrollo. cuenta con procedimientos efectivos administración configuración, puede malgastar esfuerzo modificar versión equivocada sistema, entregar los clien-tes versión incorrecta sistema olvidar dónde almacena código fuente del software para una versión particular del sistema componente. administración configuración útil para proyectos individuales, que fácil para una persona olvidar qué cambios realizaron. esencial para los proyectos equipo los que muchos desarrolladores trabajan mismo tiempo sistema software. ocasiones dichos desarrolladores laboran todos mismo lugar, pero cada vez más frecuente que los miembros los equipos desarrollo estén distribuidos diferentes sitios del planeta. uso sistema administración configura-ción garantiza que los equipos tengan acceso información sobre sistema que está bajo desarrollo sin que interfiera con trabajo los demás. administración configuración producto sistema software com-prende cuatro actividades estrechamente relacionadas (figura .): . administración del cambio esto implica hacer seguimiento las peticiones cambios software por parte clientes desarrolladores, estimar los costos efecto realizar dichos cambios, decidir deben implementarse los cambios cuándo. . gestión versiones esto incluye hacer seguimiento las numerosas versio-nes los componentes del sistema garantizar que los cambios hechos por diferen-tes desarrolladores los componentes interfieran entre . . construcción del sistema éste proceso ensamblar los componentes del programa, datos librerías, luego compilarlos vincularlos para crear sistema ejecutable. . gestión entregas ( release) esto implica preparar software para entrega externa hacer seguimiento las versiones del sistema que entregaron para uso del cliente. administración configuración implica enfrentar gran volumen infor-mación, por que han desarrollado numerosas herramientas administración -.indd -.indd // :: // :: pmconfiguración para dar soporte los procesos . éstos abarcan desde las simples herramientas que apoyan una sola tarea administración configuración, como rastreo bugs, hasta complejos costosos conjuntos herramientas integradas que apoyan todas las actividades administración configuración. las políticas los procesos administración configuración definen cómo regis-trar procesar los cambios propuestos sistema, cómo decidir qué componentes del sis-tema modificar, cómo gestionar las diferentes versiones del sistema sus componentes, cómo distribuir estos cambios los clientes. las herramientas administración configuración usan para rastrear las propuestas cambio, almacenar versiones componentes del sistema, construir sistemas partir dichos componentes, rastrear liberaciones las versiones del sistema para los clientes. ocasiones administración configuración considera parte gestión calidad del software (que trató capítulo ), donde mismo administrador tiene responsabilidades tanto gestión calidad como administración confi-guración. cuando implementa una nueva versión del software, transfiere del equipo desarrollo equipo aseguramiento calidad (, por las siglas quality assurance). equipo comprueba que calidad del sistema sea aceptable. , entonces convierte sistema controlado, que significa que todos los cambios sistema tienen que ajustarse registrarse antes que éste implemente. definición uso los estándares administración configuración son esen-ciales para certificación calidad tanto los estándares iso como cmm cmmi (ahern ., ; bamford deibler, ; paulk ., ; peach, ). dichos estándares pueden basarse estándares genéricos desarrollados por orga-nismos como ieee. por ejemplo, estándar ieee - estándar para planes administración configuración. estos estándares enfocan los procesos documentos elaborados durante dichos procesos. usar los estándares externos como punto partida, las compañías desarrollan estándares más detallados, definidos compañía, que ajustan sus necesidades particulares. uno los problemas con administración configuración que diversas com-pañías hablan los mismos conceptos utilizando diferentes términos. existen razones históricas para esto. probablemente los sistemas software militares sean los primeros gestión entregaspropuestas cambio administración del cambio entregas del sistemaversiones del componenteversiones del sistema gestión versionesconstrucción del sistema figura . actividades administración configuracióncapítulo ■ administración conﬁ guración -.indd -.indd // :: // :: capítulo ■ administración conﬁ guración sistemas los que usó administración configuración, terminología para dichos sistemas reflejaba los procesos procedimientos establecidos para adminis-tración configuración del hardware. los desarrolladores sistemas comerciales estaban familiarizados con los procedimientos con terminología militar, por que inventaban con frecuencia sus propios términos. los métodos ágiles crearon también nueva terminología, introducida ocasiones manera deliberada para distinguir enfoque ágil los métodos tradicionales. figura . define terminología administración configuración usada este capítulo.figura . terminología cmtérmino explicación ítem configuración ítem configuración software (sci, por las siglas software configuration item)cualquier aspecto asociado con proyecto software (diseño, código, datos prueba, documento, etcétera) coloca bajo control configuración. por general, existen diferentes versiones ítem configuración. los ítems configuración tienen nombre único. control configuración proceso asegurar que las versiones sistemas componentes registren mantengan modo tal que los cambios gestionen, identifiquen almacenen todas las versiones componentes durante vida del sistema. versión una instancia ítem configuración que difiere, alguna forma, otras instancias del mismo ítem. las versiones siempre tienen identificador único, que compone generalmente del nombre del ítem configuración más número versión. línea base (baseline) una línea base una colección versiones componente que construyen sistema. las líneas base están controladas, que significa que las versiones los componentes que conforman sistema pueden ser cambiadas. por tanto, siempre debería ser posible recrear una línea base partir los componentes que constituyen. línea código (codeline)una línea código conjunto versiones componente software otros ítems configuración los cuales depende dicho componente. línea principal (mainline) una secuencia líneas base que representa diferentes versiones sistema. entrega, liberación (release)una entrega sistema que libera para uso los clientes ( otros usuarios una organización). espacio trabajo (workspace)área trabajo privada donde puede modificarse software sin afectar otros desarrolladores que estén usando modificando dicho software. ramificación (branching) creación una nueva línea código partir una versión una línea código existente. nueva línea código existente pueden desarrollarse manera independiente. combinación (merging) creación una nueva versión componente software combinar versiones separadas diferentes líneas código. dichas líneas código pueden crearse mediante una rama anterior una las líneas código implicadas. construcción sistema creación una versión ejecutable del sistema compilar vincular las versiones adecuadas los componentes las librerías que constituyen sistema. -.indd -.indd // :: // :: . ■ administración del cambio . administración del cambio cambio hecho vida los grandes sistemas software. las necesidades los requerimientos organizacionales cambian durante vida sistema, los bugs deben repararse los sistemas adaptarse cambios entorno. para garantizar que los cambios apliquen sistema forma controlada, necesita conjunto procesos gestión cambio soportado por herramientas. administración del cambio tiene intención asegurar que evolución del sistema sea proceso gestionado que prioridad los cambios más urgentes rentables. proceso administración del cambio ocupa analizar los costos beneficios los cambios propuestos, aprobar aquellos que ameritan indagar cuál cuáles los componentes del sistema modificaron. figura . modelo proceso administración que muestra las principales actividades administración del cambio. existen muchas variantes este proceso uso pero, para ser efectivos, los procesos administración del cambio deben tener siempre medio que compruebe, costee apruebe los cambios. este proceso debe entrar efecto cuando software transfiere para liberación los clientes utilización dentro una organización. proceso administración del cambio inicia cuando “cliente” completa envía una petición cambio que describe cambio requerido sistema. éste podría ser figura . proceso administración del cambiosoporte cliente desarrolloenviar solicitudes cambios cliente desarrollo del producto/ccbsolicitudes cambios (change request, ) seleccionar cerrar crvalorar crválido inválido registrar cerrar crcomprobar pasa falla cerrar cranálisis implementación análisis costo-beneficio modificar software probar software -.indd -.indd // :: // :: capítulo ■ administración conﬁ guración reporte bug, que describan sus síntomas, una petición para agregar alguna funcionalidad sistema. algunas compañías tratan por separado los reportes bug los nuevos requerimientos, pero, principio, ambos son simplemente peticiones cambio. estas últimas pueden enviarse mediante formato petición cambio (crf, por las siglas change request form). aquí usa término cliente para incluir cualquier participante que sea parte del equipo desarrollo, modo que los cambios puede sugerirlos, por ejemplo, departamento marketing una compañía. los formatos electrónicos petición cambios registran información que com-parte entre todos los grupos implicados administración del cambio. conforme procesa petición del cambio, agrega información crf para registrar las decisio-nes tomadas cada etapa del proceso. por tanto, cualquier momento representa una fotografía instantánea del estado petición del cambio. además registrar cam-bio requerido, crf registra las recomendaciones concernientes cambio, los costos estimados del cambio, las fechas cuando solicitó, aprobó, implementó validó cambio. crf también puede incluir una sección donde desarrollador enfatice cómo puede implementarse cambio. figura . muestra ejemplo formato petición cambio par-cialmente completado. éste ejemplo tipo crf que puede usarse proyecto grande complejo ingeniería sistemas. para proyectos más pequeños, recomienda que las peticiones cambio registren manera formal crf enfoque descripción del cambio requerido, con menos énfasis los conflictos implementación. como desarrollador del sistema, usted decide cómo implementar dicho cambio estima tiempo requerido para ello.formato petición cambio proyecto: sicsa/appprocessing número: / solicitante del cambio: . sommerville fecha: // cambio solicitado: estatus los solicitantes (rechazado, aceptado, etcétera) debe ser visible lista despliegue solicitantes. analizador del cambio: . looek fecha análisis: // componentes afectados: applicantlistdisplay, statusupdatercomponentes asociados: studentdatabasevaloración del cambio: relativamente simple implementar cambiar color despliegue acuerdo con estatus. debe agregarse una tabla para relacionar estatus con los colores. requieren cambios los componentes asociados. prioridad del cambio: media implementación del cambio:esfuerzo estimado: horasfecha para equipo sga app.: // fecha decisión ccb: // decisión: aceptar cambio. implementarse cambio versión . del cambio: fecha cambio: fecha envío : decisión : fecha envío :comentarios: figura . formato petición cambio parcialmente completado -.indd -.indd // :: // :: . ■ administración del cambio después enviar una petición cambio, ésta verifica para asegurarse que sea válida. esta verificación puede venir tanto del cliente como del equipo soporte aplicación, para peticiones internas miembro del equipo desarrollo. comprobación necesaria porque todas las peticiones cambio requieren acción. petición cambio reporte bug, tal vez éste haya sido reportado. oca-siones, que gente considera como problemas realidad son malas interpretaciones que espera que haga sistema. algunas veces, las personas solicitan caracterís-ticas que implementaron, pero que desconocen. algo esto sucede, petición cambio cierra formato actualiza indicando razón para cierre. una petición cambio válida, entonces registra como una petición sobresaliente para análisis posterior. para peticiones válidas cambio, siguiente etapa del proceso consiste evaluar costear cambio. por general, esto responsabilidad del equipo desarrollo del mantenimiento, pues ellos están condiciones determinar que requiere para implementación del cambio. debe comprobarse efecto del cambio sobre resto del sistema. para hacer esto, hay que identificar todos los componentes afectados por cam-bio. realizar cambio significa que necesitarán más modificaciones alguna otra parte del sistema, esto aumentará costo implementar cambio. continuación, valoran los cambios requeridos los módulos del sistema. finalmente, estima costo efectuar cambio toman cuenta los costos modificar los componentes asociados. continuando con este análisis, grupo separado debe determinar realizar cam-bio software rentable desde una perspectiva empresarial. para sistemas militares gubernamentales este grupo conoce usualmente como consejo control del cambio (ccb, por las siglas change control board). industria puede llamarse “grupo desarrollo del producto”, cual responsable tomar las decisiones sobre cómo debe evolucionar sistema software. este grupo debe revisar aprobar todas las peticiones cambio, menos que los cambios impliquen simplemente corregir errores menores pantallas despliegue, páginas web documentos. estas peticiones meno-res deben transmitirse equipo desarrollo sin análisis detallado, pues esto podría ser más costoso que implementar cambio. ccb grupo desarrollo del producto consideran efecto del cambio desde punto vista estratégico organizacional más que técnico. decide cambio cuestión está justificado económicamente prioriza los cambios aceptados para implementación. los cambios aceptados transmiten regreso grupo desarrollo; las peticiones cambio rechazadas cierran emprenden más acciones. los factores significativos que deben tomarse cuenta para decidir cambio debe apro-barse son los siguientes: . las consecuencias realizar cambio cuando valora una petición cambio debe considerar que ocurrirá éste implementa. cambio relaciona con una falla reportada del sistema, gravedad dicha falla tiene que tomarse cuenta. falla del sistema causa caída este último, resulta muy grave, hacer cambio puede perturbar uso operacional del sistema. por otra parte, falla tiene efecto menor (por ejemplo, presentan los colores equivo-cados pantalla), entonces importante corregir rápidamente problema, modo que cambio tendrá una prioridad menor. -.indd -.indd // :: // :: capítulo ■ administración conﬁ guración . los beneficios del cambio ¿ cambio algo que beneficiará muchos usuarios del sistema simplemente una propuesta que beneficiará sobre todo quien pro-pone cambio? . número usuarios afectados por cambio sólo algunos usuarios resultan afectados, entonces cambio puede asignar una baja prioridad. hecho, hacer cambio resulta aconsejable pudiera tener efectos adversos sobre mayoría los usuarios del sistema. . los costos hacer cambio hacer cambio afecta muchos componentes del sistema ( que, por tanto, aumenta las posibilidades introducir nuevos bugs) / tarda mucho tiempo implementarse, entonces puede rechazar cam-bio, debido los elevados costos implicados. . ciclo liberación del producto una nueva versión del software libera los clientes, tal vez tenga sentido demorar implementación del cambio hasta siguiente liberación planeada (véase sección .). administración del cambio para productos software (por ejemplo, produc- sistema cad), vez sistemas que desarrollan específicamente para cierto cliente, tiene que manejarse una forma relativamente diferente. los productos software, cliente participa manera directa las decisiones concernientes evolución del sistema, manera que relevancia del cambio representa problema para compañía del cliente. las peticiones cambio para dichos productos provienen del equipo soporte del cliente, equipo marketing compañía los mismos -rro lla res. dichas peticiones pueden reflejar sugerencias retroalimentación los clien tes análisis que ofrecen los productos competitivos. equipo soporte del cliente puede enviar peticiones cambio asociadas con los bugs que los clientes descubrieron reportaron después que entregó sistema. los clientes pueden usar una página web correo electrónico para reportar los bugs. entonces, equipo gestión bugs comprueba que estos reportes sean válidos los traduce peticiones formales cambio del sistema. personal marketing reúne con los clientes investiga productos competitivos. pueden sugerir cambios que deban incluirse para facilitar venta una nueva versión sistema clientes nuevos existentes. los propios desarrolladores del sistema pueden tener buenas ideas referentes nuevas características que podrían agregarse sistema. proceso petición cambio mostrado figura . usa después que sistema entregó los clientes. durante desarrollo, cuando crean nuevas versiones clientes cambios los métodos ágiles enfatizan importancia que los clientes participen proceso priorización del cambio. representante del cliente ayuda equipo decidir sobre los cambios que deben implementarse siguiente iteración desarrollo. aunque esto efectivo para sistemas que están desarrollo para solo cliente, puede constituir problema desarrollo productos donde hay cliente real trabajando con equipo. esos casos, equipo tiene que tomar sus propias decisiones respecto priorización del cambio. http:// -.indd -.indd // :: // :: . ■ administración del cambio del sistema mediante construcciones diarias ( más frecuentes), por general usa proceso administración del cambio más sencillo. los problemas cambios aún deben registrarse, pero los cambios que sólo afectan componentes módulos individuales necesitan valorarse manera independiente; transmiten directamente desarrollador del sistema. éste los acepta ofrece razones por las que son necesarios tales cambios. sin embargo, una autoridad independiente, como arquitecto del sistema, debe valorar priorizar los cambios que afectan aquellos módulos del sistema que produjeron dife-rentes equipos desarrollo. algunos métodos ágiles, como programación extrema, los clientes participan directamente decisión implementar cambio. cuando proponen cambio los requerimientos del sistema, trabajan con equipo para valorar efecto dicho cambio deciden entonces éste tendría prioridad sobre las características planeadas para siguiente incremento del sistema. obstante, los cambios que implican mejo-ramiento del software dejan discreción los programadores que trabajan sistema. refactorización, que software mejora manera continua, como una carga, sino como parte necesaria del proceso desarrollo. conforme equipo desarrollo modifica los componentes software, debe man-tener registro los cambios hechos cada componente. algunas veces esto conoce como historial derivación componente. una buena forma conservar historial derivación comentario estandarizado principio del código fuente del componente (figura .). este comentario debe hacer referencia petición cambio que provocó cambio software. entonces uno puede escribir rutinas sen-cillas que busquen todos los componentes procesen los historiales derivación para generar reportes cambio componentes. caso documentos, los registros los cambios incorporados cada versión anotan por general frente del docu-mento una página aparte. esto discute capítulo web sobre documentación. administración del cambio, por general, recibe soporte herramientas espe-cializadas software. éstas pueden ser herramientas relativamente sencillas basadas web, como bugzilla, que usa para reportar problemas con muchos sistemas código abierto. bien, pueden usarse herramientas más complejas para automatizar todo proceso manejar las peticiones cambio desde propuesta inicial del cliente hasta aprobación del cambio.// sicsa project (xep ) //// app-system/auth/rbac/user_role//// objeto: currentrole// autor: . looek// fecha creación: ////// © andrews university //// historial modificación// versión modificador fecha cambio razón// . . jones // agregar encabezado enviado // . . looek // nuevo campo pet. cambio / figura . historia derivación -.indd -.indd // :: // :: capítulo ■ administración conﬁ guración . gestión versiones gestión versiones (, por las siglas version management) proceso hacer seguimiento las diferentes versiones los componentes software ítems configuración, los sistemas donde usan dichos componentes. también incluye asegurar que los cambios hechos dichas versiones por los diferentes desarrolladores ter fie ran unos con otros. por tanto, puede considerar gestión versiones como proceso administrar líneas código líneas base. figura . ilustra las diferencias entre línea código línea base. esencia, una línea código una secuencia versiones código fuente con las versiones más recientes secuencia derivadas las versiones anteriores. las líneas código aplican regularmente componentes sistemas, manera que existen diferentes ver-siones cada componente. una línea base una definición sistema específico. por consiguiente, línea base especifica las versiones del componente que incluyen sistema más una especificación las librerías usadas, archivos configuración, etcétera. figura . observa que diferentes líneas base usan distintas versiones los componentes cada línea código. diagrama sombrearon los recuadros que representan componentes definición línea base para indicar que realidad son referencias componentes una línea código. línea principal una secuencia versiones del sistema desarrolladas partir una línea base original. las líneas base pueden especificarse mediante lenguaje configuración, que permite definir cuáles componentes incluyen una versión sistema particular. posible especificar manera explícita una versión componente específica (.., por ejemplo) simplemente especificar identificador del componente (). usa identificador, esto significa que línea base debe usarse versión más reciente del componente. las líneas base son importantes porque muchas veces necesario volver crear una versión específica sistema completo. por ejemplo, una línea producto puede ejemplificarse modo que existan versiones sistema individuales para diferentes clientes. posiblemente tenga que volver crear versión entregada cliente espe-cífico , por ejemplo, dicho cliente reporta bugs sistema que deban repararse. para soportar gestión versiones, siempre deben usar herramientas gestión versiones (llamadas ocasiones sistemas control versiones sistemas control baseline - . . baseline - . . . mainlinel () codeline ()codeline () librerías componentes externos . . . . . . . . . figura . líneas código (codelines) líneas base (baselines) -.indd -.indd // :: // :: pmde código fuente). estas herramientas identifican, almacenan controlan acceso las diferentes versiones los componentes. hallan disponibles muchos sistemas dife-rentes gestión versiones, incluidos los sistemas código abierto ampliamente usados como cvs subversion (pilato ., ; vesperman, ). los sistemas gestión versiones ofrecen menudo varias características: . identificación versión entrega (release) las versiones gestionadas les asig- nan identificadores cuando envían sistema. dichos identificadores basan, por general, nombre del ítem configuración (por ejemplo, buttonmanager), seguido por uno más números. esta manera, buttonmanager . significa tercera versión codeline del componente buttonmanager. algunos sistemas también permiten asociación atributos con versiones (por ejemplo, móvil, pantalla pequeña), que también pueden usarse para identificación versión. importante que sistema identificación sea consistente, que esto simplifica problema definir configuraciones. hace más sencillo uso referencias abre-viadas (por ejemplo, *., que significa versión todos los componentes). . gestión almacenamiento para reducir espacio almacenamiento requerido por múltiples versiones los componentes que difieren sólo ligeramente, los siste-mas gestión versiones ofrecen, por general, facilidades gestión alma-cenamiento. vez conservar una copia completa cada versión, sistema almacena una lista diferencias (deltas) entre una versión otra. aplicar esto una versión fuente (por regular, versión más reciente), puede recrearse una versión objetivo. esto ilustra figura .. . registro del historial cambios todos los cambios realizados código sistema componente registran enumeran. algunos sistemas, dichos cam-bios pueden usarse para seleccionar versión sistema particular. esto implica etiquetar componentes con palabras clave que describan los cambios reali-zados. entonces pueden usar dichas etiquetas (tags) para seleccionar los compo-nentes incluir una línea base. . desarrollo independiente posible que diferentes desarrolladores trabajen mismo componente mismo tiempo. sistema gestión versiones hace seguimiento los componentes que marcaron para edición asegura que interfieran los cambios hechos componente por diferentes desarrolladores. . soporte proyecto sistema gestión versiones puede soportar desarro-llo varios proyectos que comparten componentes. los sistemas soporte fecha creación secuencia versión más reciente estructura almacenamientoversión . . . versión . fuente . . gestión almacenamiento con deltas. ■ gestión versiones -.indd -.indd // :: // :: capítulo ■ administración conﬁ guración proyecto, como cvs (vesperman, ), posible ingresar (chek ) sacar (check out) todos los archivos asociados con proyecto lugar tener que trabajar vez con archivo directorio. cuando desarrollaron por primera vez los sistemas gestión versiones, gestión del almacenamiento fue una sus funciones más importantes. las características ges-tión almacenamiento sistema control versiones reduce espacio disco requerido para mantener todas las versiones del sistema. cuando crea una nueva ver-sión, sistema simplemente almacena una delta (una lista diferencias) entre nueva versión anterior que usó para crear esa nueva versión ( que ilustra parte inferior figura .). esta misma figura, los recuadros sombreados representan versiones anteriores componente que recrean automáticamente partir ver-sión componente más reciente. por general, las deltas almacenan como listas líneas que cambiaron , aplicarlas automáticamente, puede crearse una versión componente partir otro. como más probable que use versión más reciente componente, mayoría los sistemas almacenan completa dicha versión. entonces, las deltas definen cómo recrear versiones anteriores del sistema. mayor parte del desarrollo software una actividad grupal, modo que con frecuencia surgen situaciones las que diferentes miembros del equipo trabajan paralela-mente mismo componente. por ejemplo, suponga que alicia hace algunos cambios sistema, que implica cambiar los componentes , . mismo tiempo, roberto trabaja cambios que requieren modificar los componentes , . entonces, tanto alicia como roberto cambian . importante evitar que estos cambios interfieran entre , decir, que los cambios roberto sobrescriban los alicia viceversa. para apoyar desarrollo independiente sin interferencia, los sistemas gestión versiones usan concepto repositorio público espacio trabajo privado. los desarrolladores sacan componentes del repositorio público hacia espacio trabajo privado pueden cambiarlos como deseen mismo espacio. cuando sus cambios están completos, ingresan los componentes repositorio. esto ilustra figura .. dos más personas trabajan componente mismo tiempo, cada uno debe sacar componente del repositorio. extrae componente, sistema gestión versiones por general advierte otros usuarios que quieren sacar dicho componente que alguien más está usando. sistema también garantizará que, ingresar los sistema gestión versionesalice bobespacio trabajo () ingreso (check_in)ingreso (check_in)salida (check_out)salida (check_out) . . . trabajo () figura . ingreso salida repositorio versión -.indd -.indd // :: // :: pmcomponentes modificados las distintas versiones, les asignen diferentes identificado- res versión almacenen por separado. una consecuencia del desarrollo independiente del mismo componente que las líneas código pueden ramificarse (branch). vez una secuencia lineal versio-nes que refleje los cambios componente con paso del tiempo, puede haber varias secuencias independientes, como muestra figura .. esto normal desa-rrollo sistemas, que los diferentes desarrolladores trabajan manera indepen-diente distintas versiones del código fuente cambian diversas formas. alguna etapa, tal vez sea necesario combinar ramificaciones líneas código para crear una nueva versión componente que incluya todos los cambios realizados. esto también muestra figura ., donde las versiones .. . del compo-nente combinan para crear versión .. los cambios realizados involucran partes completamente diferentes del código, las versiones del componente pueden combinarse automáticamente mediante sistema gestión versiones, combinar las deltas que aplican código. con más frecuencia, existen traslapes entre los cambios realizados que además interfieren entre . desarrollador debe verificar los conflictos modificar los cambios manera que sean compatibles. . construcción del sistema construcción del sistema proceso crear sistema ejecutable completo compilar vincular los componentes del sistema, librerías externas, archivos con-figuración, etcétera. las herramientas construcción del sistema las gestión versiones deben comunicarse, pues proceso construcción implica extraer versiones del componente del repositorio administrado por sistema gestión versiones. descripción configuración que usa para identificar una línea base utiliza también herramienta construcción del sistema. construir proceso complejo, que potencialmente proclive error, pues tres diferentes plataformas sistema pueden estar implicadas (figura .): . sistema desarrollo, que incluye herramientas desarrollo, como los compi- ladores, editores código fuente, etcétera. los desarrolladores sacan código del sistema gestión versiones hacia espacio trabajo privado antes hacer codeline codeline <ramificación <ramificación<combinacióncodeline . . . .. ... .. . . . figura . ramificación (branching) combinación (merging). ■ construcción del sistema -.indd -.indd // :: // :: capítulo ■ administración conﬁ guración cambios sistema. ellos tal vez quieran construir una versión del sistema para pro- barla entorno desarrollo antes aplicar los cambios que hicieron sistema gestión versiones. esto supone usar herramientas construcción locales que usan versiones componentes sacadas espacio trabajo privado. . servidor construcción, que usa para construir versiones ejecutables definiti- vas del sistema. éste interactúa estrechamente con sistema gestión versiones. los desarrolladores ingresan código este sistema antes que construya. elaboración del sistema puede depender librerías externas que incluyen sistema gestión versiones. . entorno objetivo plataforma donde ejecuta sistema. éste puede ser mismo tipo computadora que usó para los sistemas desarrollo construc-ción. sin embargo, para sistemas embebidos tiempo real, entorno objetivo con frecuencia más pequeño sencillo que entorno desarrollo (por ejemplo, teléfono celular). para sistemas grandes, entorno objetivo puede incluir bases datos otros sistemas cots que pueden instalarse máquinas desarrollo. ambos casos, posible construir probar sistema computadora desarrollo servidor construcción. sistema desarrollo servidor construcción pueden interactuar con sis-tema gestión versiones. sistema puede alojarse servidor construc-ción servidor dedicado. para sistemas embebidos puede instalarse entorno simulación entorno desarrollo para pruebas, vez usar plataforma sistema embebido real. dichos simuladores pueden ofrecer mejor soporte depuración que disponible sistema embebido. sin embargo, muy difícil simular com-portamiento sistema embebido todos los aspectos. por tanto, las pruebas del sistema deben realizar plataforma real donde ejecutará sistema, así como simulador del sistema. construcción del sistema implica ensamblar una gran cantidad información acerca del software entorno operacional. por tanto, para cualquier sistema aparte los pequeños, siempre tiene sentido usar una herramienta construcción automati-zada para crear una construcción del sistema (figura .). observe que sólo nece-sita los archivos del código fuente implicados construcción, sino tal vez deban sistema desarrollo cogestión versiones servidor construcciónsistema objetivo sacar (check-out, )ingresar (check-)herramientas desarrollo espacio trabajo privado sistema gestión versionesservidor construcciónsistema ejecutable plataforma objetivo figura . plataforma desarrollo, plataforma construcción plataforma objetivo -.indd -.indd // :: // :: pmvincular dichos archivos con librerías, archivos datos (como archivo mensajes error) archivos configuración proporcionados externamente que definan insta-lación objetivo. probable que deban especificar las versiones del compilador otras herramientas software usadas construcción. manera ideal, usted debería ser capaz construir sistema completo con solo comando clic del ratón. existe una gran cantidad herramientas construcción disponibles, sistema construcción puede ofrecer algunas las siguientes características todas ellas: . generación rutinas (scripts) construcción necesario, sistema cons- truc ción debe analizar programa construcción, identificar los componentes dependientes generar automáticamente una rutina construcción (llamado algunas veces archivo configuración). sistema debe soportar también creación manual edición rutinas construcción. . integración del sistema gestión versiones sistema construcción debe sacar las versiones componentes requeridas del sistema gestión versiones. . recompilación mínima sistema construcción debe establecer qué código fuente necesita volver compilarse establecer las compilaciones así requiere. . creación sistema ejecutable sistema construcción debe vincular los archivos código objeto compilado entre con otros archivos requeridos, como las libre-rías los archivos configuración, para crear sistema ejecutable. . automatización pruebas algunos sistemas construcción pueden efectuar pruebas automatizadas utilizando herramientas automatización pruebas como junit. éstas comprueban que construcción haya “roto” por los cambios. . informes sistema construcción debe ofrecer informes sobre éxito fracaso construcción las pruebas que efectuaron. . generación documentación sistema construcción puede generar notas referentes las páginas ayuda construcción del sistema. rutina construcción una definición del sistema construir. incluye informa-ción respecto los componentes sus dependencias, así como sobre las versiones las herramientas utilizadas para compilar vincular sistema. rutina construcción incluye especificación configuración, manera que lenguaje escritura rutinas utilizado generalmente mismo que lenguaje descripción configu-archivos código fuente archivos datos libreríaspruebas ejecutables sistema objetivo ejecutable resultados pruebasarchivos configuración sistema construcción automatizado compiladores herramientasfigura . construcción del sistema. ■ construcción del sistema -.indd -.indd // :: // :: capítulo ■ administración conﬁ guración ración. lenguaje configuración incluye sentencias para describir los componentes del sistema incluir construcción sus dependencias. puesto que compilación proceso cómputo intensivo, las herramientas para soportar construcción sistemas diseñan por general para minimizar canti-dad compilación que requiere. esto hace comprobando está disponible una versión compilada componente. ser así, hay necesidad volver compilar dicho componente. por tanto, debe haber una forma vincular sin ambigüedades código fuente componente con código objeto equivalente. forma que hace esto asociar una firma única con cada archivo donde almacene componente del código fuente. código objeto correspondiente, que compiló partir del código fuente, tiene una firma relacionada que identifica cada ver-sión del código fuente cambia cuando éste edita. comparar las firmas los archi-vos código fuente objeto, posible decidir componente del código fuente usó para generar componente código objeto. hay dos tipos firmas que pueden usarse: . modificación marca tiempo (timestamp) firma archivo del código fuente fecha hora cuándo éste modificó. archivo del código fuente componente modifica después del archivo del código objeto relacionado, entonces sistema supone que requiere “recompilación” para crear nuevo archivo del código objeto. por ejemplo, suponga que los componentes comp.java comp.class tienen fir- mas modificación ::::: :::::, respectiva-mente. esto significa que código java modificó las horas con minutos segundos del febrero , versión compilada modificó las horas con minutos segundos del febrero . este caso, sistema recompilaría automáticamente comp.java porque versión compilada incluye los cambios hechos código fuente desde febrero. . sumas verificación (checksums) código fuente firma archivo del código fuente una suma verificación calculada partir datos archivo. una función checksum calcula número único usando texto fuente como entrada. modifica código fuente (incluso por carácter), esto generará una suma diferente. por tanto, usted puede estar seguro que los archivos código fuente con diferentes sumas verificación realidad son diferentes. suma verificación asigna código fuente justo antes compilación identifica manera exclusiva archivo fuente. entonces sistema construcción etiqueta archivo código objeto generado con firma checksum. hay archivo código objeto con misma firma que archivo código fuente incluir sistema, entonces necesario recompilar código fuente. como menudo los archivos del código objeto están versiones, primer enfoque significa que sólo archivo del código objeto compilado más recientemente mantiene sistema. esto, por general, relaciona con archivo del código fuente por nom-bre ( decir, tiene mismo nombre que archivo código fuente, pero con sufijo diferente). por tanto, archivo fuente comp.java puede generar archivo objeto comp.class. puesto que los archivos fuente objeto están vinculados por nombre por una firma archivo fuente explícita, por general posible construir diferentes versiones componente código fuente mismo directorio mismo tiempo, pues ello generaría archivos objeto con mismo nombre. -.indd -.indd // :: // :: enfoque checksum tiene ventaja permitir muchas versiones diferentes del código objeto componente para mantenerse mismo tiempo. firma, más que nombre archivo, vínculo entre código fuente objeto. los archivos código fuente código objeto tienen misma firma. por tanto, cuando recom-pila componente, sobrescribe código objeto, como sería normalmente caso cuando usa timestamp. vez ello, genera nuevo archivo código objeto etiqueta con firma del código fuente. posible compilación paralela compilar diferentes versiones componente mismo tiempo. los métodos ágiles recomiendan que los componentes sistema muy frecuentes deben realizarse con pruebas automatizadas (llamadas ocasiones pruebas humo) para descubrir problemas del software. los componentes frecuentes pueden ser parte proceso integración continua, como muestra figura .. para ser congruentes con noción los métodos ágiles elaborar muchos cambios peque-ños, integración continua implica reconstruir frecuentemente línea principal (main-line), después realizar pequeños cambios código fuente. los pasos integración continua son: . saque línea principal del sistema gestión versiones hacia espacio tra- bajo privado del desarrollador. . construya sistema efectúe pruebas automatizadas para garantizar que sistema construido pasa todas las pruebas. hace, construcción descompone hay que informar quienquiera que ingrese último sistema línea base (baseline). ellos son responsables reparar problema. . realice los cambios los componentes del sistema. . construya sistema espacio trabajo privado vuelva efectuar las pruebas del sistema. las pruebas fallan, continúe edición. . una vez que sistema pasa sus pruebas, ingréselo sistema construcción, pero confirme como una línea base nueva del sistema.fallan pruebas pruebas okfallan pruebassacar línea principal (mainline)sistema construcción pruebasistema construcción pruebahacer cambios ingresar servidor construcciónsistema construcción pruebarealizar cambios sistema gestión versionesservidor construcciónespacio trabajo privadosistema gestión versiones figura . integración continua. ■ construcción del sistema -.indd -.indd // :: // :: capítulo ■ administración conﬁ guración . construya sistema servidor construcción efectúe las pruebas. necesita hacer esto caso que otros hayan modificado componentes luego que usted los sacó del sistema. éste caso, saque componente que falló edítelo modo que las pruebas pasen espacio trabajo privado. . sistema pasa sus pruebas sistema construcción, confirme entonces los cambios que hizo como una nueva línea base línea principal del sistema. argumento para integración continua que permite que los problemas causados por las interacciones entre diferentes desarrolladores descubran reparen tan pronto como sea posible. sistema más reciente línea principal sistema funcional definitivo. sin embargo, aunque integración continua una buena idea, siempre posible implementar este enfoque construcción del sistema. las razones para esto son: . sistema muy grande, puede tardar mucho tiempo construir probar. por tanto, práctico construir muchas veces día dicho sistema. . plataforma desarrollo diferente plataforma objetivo, tal vez sea posible efectuar pruebas del sistema espacio trabajo privado. puede haber diferencias hardware, sistema operativo software instalado. por consi-guiente, requiere más tiempo para probar sistema. para sistemas grandes sistemas donde plataforma ejecución misma que plataforma desarrollo, integración continua quizá sea práctica. ante tales cir-cunstancias puede usar sistema que construya diariamente. las características esto son las siguientes: . organización desarrollo establece tiempo entrega (por ejemplo, ..) para los componentes del sistema. los desarrolladores tienen nuevas versiones los componentes que escriben, deben entregarlas ese plazo. los compo-nentes pueden estar incompletos, pero deben ofrecer alguna funcionalidad básica que pueda ponerse prueba. . partir dichos componentes crea una nueva versión del sistema compilarlos vincularlos para formar sistema completo. . entonces este sistema entrega equipo pruebas, que realiza conjunto pruebas sistema predefinidas. mismo tiempo, los desarrolladores todavía tra-bajan sus componentes, añaden funcionalidad reparan las fallas descubiertas pruebas anteriores. . las fallas que descubren durante las pruebas del sistema documentan regre- san los desarrolladores del sistema, quienes reparan dichas fallas una versión posterior del componente. las ventajas usar componentes frecuentes software son que aumentan las posibi-lidades descubrir manera oportuna durante proceso los problemas que surgen partir las interacciones los componentes. construcción frecuente alienta las pruebas unidad profundas los componentes. psicológicamente, los desarrolladores ponen bajo presión para “ romper construcción”; esto , tratan evitar ingreso versiones -.indd -.indd // :: // :: pmcomponentes que causen que todo sistema falle. por tanto, tienen reticencia entregar nuevas versiones componentes que hayan probado manera adecuada. conse-cuencia, emplean menos tiempo durante las pruebas del sistema descubriendo lidiando con las fallas software que pudiera encontrar desarrollador. . gestión entregas software ( releaserelease) una entrega (release) sistema una versión sistema software que dis-tribuye los clientes. para software mercado masivo posible identificar por general dos tipos entregas: release mayor, que proporciona funcionalidad significa-tivamente nueva, release menor, que repara bugs corrige problemas reportados por cliente. por ejemplo, este libro escribió una computadora apple mac donde sistema operativo ... esto significa release menor release mayor . las entregas mayores son muy importantes económicamente para pro-veedor software, pues los clientes tienen que pagar por ellas. las entregas menores generalmente distribuyen manera gratuita. para software medida líneas producto software, gestión las entregas del sistema proceso complejo. posible que deban producirse entregas especia-les del sistema para cada cliente, clientes individuales pueden ejecutar muchas entre-gas diferentes del sistema mismo tiempo. anterior significa que una compañía software que vende producto software especializado tal vez deba gestionar dece-nas incluso cientos diferentes entregas dicho producto. sus sistemas procesos administración configuración deben diseñarse para dar información sobre qué clientes tienen cuáles releases del sistema sobre relación entre entregas versiones del sistema. caso problemas, quizá sea necesario reproducir con exactitud soft-ware que entregó cliente particular. por tanto, cuando produce una entrega sistema, esto debe documentarse para garantizar que pueda recrearse con exactitud futuro. esto particularmente impor-tante para sistemas embebidos personalizados larga duración, como los que contro-lan máquinas complejas. los clientes pueden usar una sola entrega dichos sistemas durante muchos años requerir cambios específicos sistema software particular mucho tiempo después fecha liberación original. para documentar una entrega, necesario registrar las versiones específicas los componentes código fuente que usaron creación del código ejecutable. hay que conservar copias los archivos código fuente, los ejecutables correspondientes todos los datos archivos configuración. también hay que registrar las versio-nes del sistema operativo, librerías, compiladores otras herramientas utilizadas para construir software. esto puede requerir construir exactamente mismo sistema alguna fecha posterior. también puede significar que debe almacenar copias del software plataforma las herramientas usadas para crear sistema sistema gestión versiones junto con código fuente del sistema objetivo. preparar distribuir una entrega sistema proceso costoso, particular para los productos software mercado masivo. además del trabajo técnico que implica creación una distribución entrega (release), hay que elaborar publicidad material difusión, así como establecer estrategias marketing para convencer los clientes . ■ gestión entregas software (release) -.indd -.indd // :: // :: capítulo ■ administración conﬁ guración comprar nueva entrega del sistema. debe considerarse con cuidado tiempo las - tregas. las entregas son muy frecuentes requieren actualizaciones hardware, losclientes quizá cambien hacia nueva entrega, especial tienen que pagar por ella. las entregas del sistema son muy poco frecuentes, tal vez pierda participa-ción mercado, pues los clientes cambiarán hacia sistemas alternativos. figura . muestran los diversos factores técnicos organizacionales que hay que tomar cuenta decidir sobre cuándo liberar una nueva versión sistema. una entrega sistema sólo código ejecutable del sistema; ésta también puede incluir:  archivos configuración que definan cómo debe configurarse entrega (release) para instalaciones particulares;  archivos datos, como los archivos mensajes error, necesarios para opera- ción exitosa del sistema;  programa instalación para ayudar instalar sistema hardware objetivo;  documentación electrónica escrita que describa sistema; empaquetado publicidad asociada diseñados para dicha entrega. creación entrega proceso instaurar colección archivos docu- mentación que incluyen todos los componentes entrega del sistema. código figura . factores que influyen planeación release sistemafactor descripción calidad técnica del sistemasi reportan graves fallas del sistema que afectan forma que muchos clientes usan, puede ser necesario emitir una entrega reparación falla. las fallas menores sistema pueden remediarse con uso parches (distribuidos por general internet) que aplican entrega actual del sistema. cambios plataformatal vez deba crear una nueva entrega una aplicación software cuando libera una nueva versión plataforma sistema operativo. quinta ley lehman (véase capítulo )esta “ley” sugiere que agrega mucha funcionalidad nueva sistema, también introducirán bugs que limitarán cantidad funcionalidad que puede incluir siguiente entrega. por tanto, posible que una entrega sistema con funcionalidad significativamente nueva vaya seguida por una entrega que enfoque reparar problemas mejorar rendimiento. competencia para software mercado masivo, quizá sea necesaria una entrega sistema, debido que productos competitivos introdujeron nuevas características podría perderse participación mercado éstas ofrecen los clientes existentes. requerimientos marketingel departamento marketing una organización tal vez hizo compromisos para que las entregas estén disponibles una fecha particular. propuestas cambio del cliente para sistemas medida, los clientes posiblemente hicieron pagaron por conjunto específico propuestas cambios del sistema, esperan una entrega del sistema tan pronto como hayan implementado. -.indd -.indd // :: // :: pmejecutable del programa todos los archivos datos asociados deben identificarse sistema gestión versiones etiquetarse con identificador entrega (release). quizás haya que escribir descripciones configuración para hardware sistemas opera-tivos diferentes, instrucciones preparadas para los clientes que necesiten configurar sus sistemas. distribuyen máquina manuales legibles, deben almacenarse copias electrónicas con software. probablemente haya que escribir rutinas para programa instalación. finalmente, cuando toda información está disponible, debe prepararse una imagen maestra ejecutable del software transferirse para distribución los clientes almacenes ventas. cuando planea instalación nuevas entregas del sistema, puede suponer que los clientes siempre instalarán nuevas entregas del sistema. algunos usuarios del sistema pueden estar satisfechos con sistema existente considerarán que vale pena costo cambiar una nueva entrega. por tanto, las nuevas entregas del sistema pueden depender instalación entregas anteriores. para ilustrar este problema, considere siguiente escenario: . entrega sistema distribuye pone uso. . entrega requiere instalación nuevos archivos datos, pero algunos clien- tes necesitan las facilidades entrega , así que continúan con entrega . . entrega requiere los archivos datos instalados entrega tiene nuevos archivos datos propios. distribuidor del software puede suponer que los archivos requeridos por entrega instalaron todos los sitios. algunos sitios pueden directamente entrega entrega , saltar entrega . otros sitios posiblemente modificaron los archivos datos asociados con entrega para reflejar circunstancias locales. consecuencia, los archivos datos deben distribuirse instalarse con entrega del sistema. los costos marketing empaquetado asociados con las nuevas entregas produc-tos software son altos, modo que los proveedores productos, por general, sólocrean nuevas entregas para nuevas plataformas para agregar funcionalidad significa-tivamente novedosa. entonces cobran sus usuarios por este nuevo software. cuando descubren problemas entrega existente, los proveedores software elaboran parches para reparar este software, disponibles sitio web para que los clientes los descarguen. problema con usar parches descargables que muchos clientes nunca pue-den descubrir existencia dichas reparaciones problemas entender por qué deben instalarlos. vez ello, siguen usando sistema defectuoso existente, con los conse-cuentes riesgos para empresa. algunas situaciones, donde parche está diseñado para reparar vacíos seguridad, los riesgos fallar instalación del parche pueden significar que empresa vulnerable ataques externos. para evitar estos problemas, los vendedores software para mercado masivo, como adobe, apple microsoft, por general implementan actualizaciones automáticas, las que los sistemas actualizan siempre que está disponible una nueva versión mínima. sin embargo, esto generalmente funciona para sistemas medida, puesto que dichos sistemas existen una versión estándar para todos los clientes.. ■ gestión entregas software (release) -.indd -.indd // :: // :: pmpuntos clave ■ administración configuración gestión sistema software evolución. cuando mantiene sistema establece equipo para garantizar que los cambios incorporen sistema una forma controlada que mantienen registros con los detalles los cambios que implementaron. ■ los principales procesos administración configuración ocupan administración del cambio, gestión versiones, construcción del sistema gestión entregas software (release). para apoyar todos estos procesos dispone herramientas software. ■ administración del cambio implica valorar las propuestas cambios por los clientes del sistema otros interesados, así como decidir conveniente términos costos implementarlos una nueva versión sistema. ■ gestión versiones incluye hacer seguimiento las diferentes versiones los componentes software que crean conforme hacen cambios ellos. ■ construcción del sistema proceso ensamblar componentes sistema programa ejecutable para que operen sistema cómputo objetivo. ■ software debe reconstruirse frecuentemente probarse inmediato después construir una nueva versión. esto facilita detección bugs problemas que introdujeron desde última construcción. ■ las entregas sistema contienen código ejecutable, archivos datos, archivos configuración documentación. gestión entregas incluye tomar decisiones referentes las fechas entrega del sistema, preparar toda información para distribución documentar cada entrega del sistema. lecturas sugeridas configuration management principles and practice. este libro, muy completo, estudia los enfoques estándar tradicionales , así como los enfoques que son más adecuados para los procesos modernos, como desarrollo software ágil. (anne mette jonassen hass, addison-wesley, .) software configuration management patterns: effective teamwork, practical integration . libro fácil lectura relativamente breve, que ofrece buenos consejos prácticos respecto práctica administración configuración, especial para métodos ágiles desarrollo. (. . berczuk con . appleton, addison-wesley, .) “high-level best practices software configuration management”. este artículo web, escrito por personal proveedor herramientas , una excelente introducción buena práctica administración configuración del software. (. wingerd . seiwald, .) http:/ /www. perforce. com/ perforce/ papers/ bestpractices. html. capítulo ■ administración conﬁ guración -.indd -.indd // :: // :: “agile configuration management for large organizations”. este artículo web describe las prácticas administración configuración que pueden usarse procesos desarrollo ágil, con particular énfasis cómo puede escalarse proyectos compañías grandes. (. schuh, .) http:/ /www. ibm. com/ developerworks/ rational/ library/ mar/ schuh/ index. html. ejercicios .. sugiera cinco posibles problemas que pudieran surgir una compañía desarrolla políticas procesos efectivos administración configuración. .. ¿cuáles son los beneficios usar formato petición cambio como documento central proceso administración del cambio? .. describa seis características esenciales que deben incluirse una herramienta para soportar procesos administración del cambio. .. explique por qué esencial que toda versión componente deba identificarse manera exclusiva. comente acerca los problemas usar esquema identificación versión que base simplemente números versión. .. imagine una situación donde dos desarrolladores modifican simultáneamente tres componentes software diferentes. ¿qué dificultades pueden surgir cuando tratan fusionar los cambios que realizaron? .. software desarrolla cada vez más seno equipos, cuyos miembros trabajan diferentes lugares. sugiera algunas características sistema gestión versiones que puedan requerirse para apoyar este desarrollo software distribuido. .. describa las dificultades que podrían surgir cuando construye sistema partir sus componentes. ¿qué problemas particulares pueden ocurrir cuando sistema construye una computadora anfitriona para alguna máquina objetivo? .. con referencia construcción sistemas, explique por qué ocasiones tienen que conservar computadoras obsoletas las que desarrollaron grandes sistemas software. .. problema común con construcción sistemas ocurre cuando los nombres archivo físico incorporan código sistema estructura archivo implicada dichos nombres corresponde con máquina objetivo. escriba conjunto lineamientos que ayuden programador evitar esto cualquier otro problema construcción del sistema que pueda considerar. .. detalle cinco factores que deben tomar cuenta los ingenieros durante proceso construcción una entrega (release) amplio sistema software.capítulo ■ ejercicios -.indd -.indd // :: // :: pmreferencias ahern, . ., clouse, . turner, . (). cmmi distilled. reading, mass.: addison-wesley. bamford, . deibler, . . (). “iso : for software and systems providers: engineering approach”. boca raton, : crc press. paulk, . ., weber, . ., curtis, . chrissis, . . (). the capability maturity model: guidelines for improving the software process. reading, mass.: addison-wesley. peach, . . (). the iso handbook, edition. nueva york: irwin professional pub.pilato, . ., collins-sussman, . fitzpatrick, . . (). version control with subversion. sebastopol, calif.: ‘reilly media inc.vesperman, . (). essential cvs. sebastopol, calif.: ‘reilly and associates. capítulo ■ administración conﬁ guración -.indd -.indd // :: // :: pmobjetivos objetivo este capítulo introducirlo mejora del proceso software como una forma aumentar calidad del software reducir los costos desarrollo. estudiar este capítulo: ■ comprenderá las razones para mejora del proceso software como medio que pretende mejorar tanto calidad del producto como eficiencia efectividad los procesos software; ■ entenderá los principios mejora del proceso software proceso mejora del proceso cíclico; ■ conocerá cómo puede usarse enfoque meta-pregunta-métrica para guiar medición del proceso; ■ estará tanto las ideas capacidad madurez proceso, así como forma general del modelo cmmi del sei para mejora procesos. contenido . proceso mejora procesos . medición del proceso . análisis del proceso . cambios los procesos . marco trabajo para mejora procesos cmmi mejora procesos -.indd -.indd // :: // :: capítulo ■ mejora procesos actualidad existe una constante demanda industria por mejor más barato software, que debe entregarse plazos cada vez más cortos. por consiguiente, numero-sas compañías software han dirigido atención hacia mejora procesos soft-ware como una forma aumentar calidad software, reducir sus costos acelerar los procesos desarrollo. mejora procesos significa comprender los procesos existentes cambiarlos para incrementar calidad del producto reducir los costos tiempo desarrollo. usan dos enfoques muy diferentes para mejora cambio procesos: . enfoque madurez procesos, que orientado mejorar proceso gestión del proyecto introducir una organización buenas prácticas ingeniería software. nivel madurez del proceso refleja medida que adoptan buenas prácticas técnicas administrativas los procesos desarrollo software organizacional. las metas principales este enfoque consisten mejorar cali-dad del producto previsibilidad del proceso. . enfoque ágil, orientado desarrollo iterativo reducción las sobrecargas proceso software. las características primarias los métodos ágiles son entrega rápida funcionalidad capacidad respuesta ante los cambiantes requerimientos del cliente. los partidarios cada uno estos enfoques generalmente son escépticos reco-nocer los beneficios del otro. enfoque madurez del proceso basa desarrollo orientado por plan , por regla general, requiere aumento “sobrecarga”, sen-tido que introducen actividades que son directamente relevantes para progra-mación. los enfoques ágiles centran código desarrollar minimizan manera deliberada formalidad documentación. capítulo otras partes del libro estudiaron los métodos ágiles, así que este capítulo enfoca administración mejora del proceso basado madurez. esto significa que prefiera este enfoque los métodos ágiles. hecho, autor considera que, para proyectos pequeños medianos, adoptar las prácticas ágiles pro-bablemente estrategia mejora proceso más efectiva costo. sin embargo, para sistemas grandes, sistemas críticos sistemas que involucran desarrolladores dife-rentes compañías, los conflictos administración menudo son las razones por las que los proyectos pueden tener problemas. para compañías cuyo negocio ingeniería sistemas grandes complejos, debe considerarse enfoque mejora procesos centrado madurez. como explicó capítulo , proceso desarrollo usado para crear sis-tema software influye calidad dicho sistema. por eso, muchas personas creen que mejorar proceso desarrollo software conducirá software mejor cali-dad. esta noción mejora procesos una idea original del ingeniero estadounidense . . deming, quien trabajó con industria japonesa después segunda guerra mundial para ayudar mejorar calidad. durante muchos años, industria japonesa comprometido con mejora continua los procesos, que conducido recono-cimiento alta calidad los bienes manufacturados japón. deming, entre otros, introdujo idea del control estadístico calidad. ésta basa medir número defectos productos relacionarlos con proceso. meta dis-minuir número defectos del producto analizar modificar proceso para que reduzcan las posibilidades introducir defectos mejore detección los mismos. -.indd -.indd // :: // :: pmcapítulo ■ mejora procesos una vez lograda reducción conteo defectos, proceso estandariza comienza ciclo más mejora. humphrey (), libro gran influencia sobre gestión procesos, argu-menta que pueden aplicarse las mismas técnicas ingeniería software. afirma: . . deming, trabajo con industria japonesa después segunda guerra mundial, aplicó industria los conceptos control estadístico pro-cesos. bien existen importantes diferencias, dichos conceptos son tan aplicables software como los automóviles, las cámaras, los relojes pulsera acero. aunque hay claras similitudes, autor está acuerdo con humphrey que los resultados ingeniería fabril puedan transferirse fácilmente ingeniería soft-ware. ahí donde manufactura incluye, evidente relación proceso/producto. por general, manufactura implica ajuste herramientas automatizadas procesos verificación productos. alguien comete error calibrar una máquina, esto afec-tará todos los productos elaborados por dicha máquina. evitar los errores configurar las máquinas introducir procesos verificación más efectivos claramente mejora calidad del producto. esta relación calidad proceso/calidad producto menos evidente cuando producto intangible depende, alguna medida, procesos intelectuales que pueden automatizarse. calidad del software está influida por sus procesos fabri-cación, sino por proceso diseño, que las habilidades experiencia gente son significativas. ciertos casos, proceso utilizado puede ser determinante más significativo calidad del producto. sin embargo, para aplicaciones innovadoras particular, personal que interviene proceso tiene mayor influencia sobre calidad que proceso utilizado. para productos software, cualquier producto intelectual, como libros películas, donde calidad depende del diseño, hay cuatro factores elementales que afectan cali-dad del producto, los cuales muestran figura .. influencia cada uno estos factores depende del tamaño tipo del proyec-. para sistemas muy grandes que incluyen subsistemas separados, desarrollados por equipos que pueden trabajar diferentes lugares, factor principal que afecta cali-dad del producto proceso software. los mayores problemas con los proyectos grandes son integración, gestión del proyecto las comunicaciones. por general, existe una mezcla habilidades experiencia entre los miembros del equipo , como calidad productotecnología desarrollo costo, tiempo calendarizacióncalidad del procesocalidad personal figura . factores que afectan producto software -.indd -.indd // :: // :: capítulo ■ mejora procesos proceso desarrollo menudo tiene lugar largo varios años, equipo desarrollo volátil. puede cambiar por completo durante vida del proyecto. sin embargo, para proyectos pequeños, los que sólo existen equipo algunos miembros, calidad del equipo desarrollo más importante que proceso desa-rrollo utilizado. por consiguiente, manifiesto ágil proclama importancia gente por encima los procesos. equipo tiene alto nivel habilidad experiencia, probable que calidad del producto sea alta, independientemente del proceso utilizado. equipo carece experiencia habilidad, buen proceso puede limitar daño, pero, mismo, llevará software alta calidad. donde los equipos son reducidos, buena tecnología desarrollo particularmente importante. equipo pequeño puede dedicar mucho tiempo tediosos procedimientos administrativos. los integrantes del equipo pasan mayor parte tiempo diseñando programando sistema; por tanto, las buenas herramientas afectan significativamente productividad. para proyectos grandes esencial nivel básico tecnología desarrollo para gestión información. obstante, paradójicamente, las herramien-tas sofisticadas software son menos importantes los proyectos grandes. los miem-bros del equipo dedican una menor proporción tiempo las actividades desarrollo más tiempo para comunicarse entender otras partes del sistema. las herramientas desarrollo hacen diferencia esto. sin embargo, las herramientas web . que soportan las comunicaciones, tales como los wikis blogs, pueden mejorar manera sustancial comunicación entre los miembros los equipos distribuidos. sin considerar los factores personal, procesos herramientas, proyecto tiene presupuesto inadecuado planea con calendario entregas poco realista, -dad del producto verá afectada. buen proceso requiere recursos para una ple-mentación efectiva. dichos recursos son insuficientes, proceso puede ser real mente efectivo. los recursos son inadecuados, sólo personal excelencia puede salvar pro-yecto. aun así, déficit demasiado grande, calidad del producto degradará. haber suficiente tiempo para desarrollo, probable que software entregado tenga funcionalidad reducida niveles más bajos fiabilidad rendimiento. con demasiada frecuencia, causa real los problemas calidad del software una gestión deficiente, procesos inadecuados capacitación escasa calidad. más bien, hecho que las organizaciones deben competir para sobrevivir. para ganar contrato, una compañía puede subestimar esfuerzo requerido prometer entrega rápida sistema. con intención cumplir estos compromisos, tal vez acuerde calendario desarrollo poco realista. consecuencia, calidad del software afectada manera negativa. . proceso mejora procesos capítulo introdujo idea general proceso software como una secuen-cia actividades que, cuando ejecuta, conduce producción sistema software. describieron procesos genéricos, como modelo cascada desarrollo basado reutilización; además, estudiaron las actividades más importantes del pro-ceso. dichos procesos genéricos ejemplifican dentro una organización para crear proceso particular que utiliza desarrollo del software. los procesos software pueden ser observados todas las organizaciones, des- compañías integradas por una sola persona hasta grandes multinacionales. dichos -.indd -.indd // :: // :: . ■ proceso mejora procesos procesos son diferentes tipos dependiendo del grado formalidad del proceso, los tipos productos desarrollados, tamaño organización, etcétera. existe algo como proceso software “ideal” “estándar” que sea aplicable todas las orga-nizaciones para todos los productos software tipo particular. cada compañía debe desarrollar propio proceso función tamaño, sus antecedentes las habilidades personal, tipo software que desarrollado, los requerimientos del cliente del mercado, cultura empresarial. por tanto, mejora procesos significa simplemente adoptar métodos herra-mientas particulares usar proceso genérico publicado. aunque las organizaciones que desarrollan mismo tipo software sin duda tienen mucho común, siempre existen factores organizacionales locales, procedimientos estándares que influyen proceso. ocasionalmente tendrá éxito introducir mejoras proceso sólo intenta cambiar proceso por uno usado otra parte. siempre hay que considerar entorno cultura locales cómo esto puede verse afectado por las propuestas cambio del proceso. también hay que considerar qué aspectos del proceso desea mejorar. meta podría ser mejorar calidad del software , tal caso, habría que introducir nuevas actividades proceso que cambien forma que desarrolla prueba software. quizás usted esté interesado mejorar algunos atributos del proceso deba determinar cuáles atributos proceso son los más importantes para compañía. figura . mues-tran algunos ejemplos atributos proceso que pueden ser objeto mejora.figura . atributos procesocaracterística del proceso cuestiones clave comprensión ¿ qué medida proceso está definido explícitamente qué tan fácil entender definición del proceso? estandarización ¿hasta qué punto proceso basa proceso genérico estándar? esto puede ser importante para algunos clientes que requieran conformidad con conjunto estándares definidos proceso. ¿hasta dónde usa mismo proceso todas las partes una compañía? visibilidad ¿las actividades del proceso culminan resultados claros, modo que avance del proceso observa externamente? mensurabilidad ¿ proceso incluye recolección datos otras actividades que permitan medir las características del proceso del producto? soportabilidad ¿ qué medida pueden usarse herramientas software para apoyar las actividades del proceso? aceptabilidad ¿ proceso definido aceptable útil para los ingenieros responsables elaborar producto software? fiabilidad ¿ proceso está diseñado tal forma que evitan detectan errores proceso antes que deriven errores producto? robustez ¿ proceso puede continuar pesar problemas inesperados? mantenibilidad ¿ proceso puede evolucionar para reflejar los requerimientos cambiantes organización mejoras identificadas proceso? rapidez ¿qué tan rápido puede completarse proceso entrega sistema partir una especificación dada? -.indd -.indd // :: // :: capítulo ■ mejora procesos está claro que, ocasiones, dichos atributos relacionan forma positiva otras veces forma negativa. por tanto, proceso que califica alto atributo visi-bilidad también será probablemente comprensible. observador del proceso puede inferir existencia actividades partir las salidas producidas. por otra parte, visibilidad del proceso puede estar inversamente relacionada con rapidez. hacer visi-ble proceso requiere que las personas implicadas tengan que generar información sobre proceso . esto puede reducir producción del software, debido tiempo que toma elaborar esos documentos. imposible hacer mejoras proceso que optimicen simultáneamente todos los atributos proceso. por ejemplo, meta tener proceso desarrollo rápido, entonces tal vez haya que reducir visibilidad del proceso. quiere hacer proceso más mantenible, hay que adoptar procedimientos herramientas que reflejen amplia práctica organización que usen diferentes partes compañía. esto podría reducir aceptabilidad local del proceso. probablemente los ingenieros tengan que introducir procedimientos locales herramientas estandarizadas para apoyar forma trabajar. tanto que éstos sean efectivos, querrán renunciar ellos favor proceso estandarizado. proceso mejora procesos cíclico, como observa figura .. incluye tres subprocesos: . medición del proceso miden atributos del proyecto actual producto. meta mejorar las medidas acuerdo con los objetivos organización impli-cada mejora del proceso. esto constituye una línea referencia que ayuda determinar son efectivas las mejoras del proceso. . análisis del proceso valora proceso actual identifican las debilidades los cuellos botella del proceso. durante esta etapa pueden desarrollarse modelos proceso (llamados también mapas proceso) que describen proceso. aná-lisis puede enfocarse considerar las características del proceso como rapidez robustez. . cambio del proceso los cambios proceso son propuestas para atacar algunas las debilidades identificadas del proceso. estos cambios introducen ciclo vuelve recopilar datos sobre efectividad los cambios.medición análisis cambio figura . ciclo mejora procesos -.indd -.indd // :: // :: . ■ medición del proceso sin datos concretos respecto proceso software desarrollado usando dicho pro- ceso, imposible estimar valor mejora del proceso. sin embargo, improba-ble que las compañías que inician proceso mejora procesos cuenten con datos proceso disponibles como una línea referencia para mejora. por eso, como parte del primer ciclo cambios, quizás haya que introducir actividades proceso para recopilar datos sobre proceso software medir las características del producto software. mejora del proceso una actividad largo plazo, así que cada una las etapas proceso mejora puede durar varios meses. también una actividad continua pues, independientemente los procesos introducidos, ambiente negocios cambiará los nuevos procesos tendrán que evolucionar para tomar cuenta dichos cambios. . medición del proceso las mediciones del proceso son datos cuantitativos acerca del proceso software, como tiempo que tarda realizarse cierta actividad del proceso. por ejemplo, posible -dir tiempo requerido para desarrollar casos prueba del programa. humphrey (), libro referente mejora procesos, argumenta que medición del proceso los atributos del producto son esenciales para mejora los procesos. además, refiere que medición desempeña importante papel mejora procesos personales pequeña escala (humphrey, ), donde los individuos tratan ser más productivos. las mediciones procesos pueden usarse para valorar eficiencia proceso mejoró . por ejemplo, puede monitorizar esfuerzo tiempo dedicados las pruebas. las mejoras efectivas proceso pruebas deben reducir esfuerzo tiempo pruebas. obstante, las mediciones del proceso, por mismas, pueden usarse para determinar mejoró calidad del producto. también deben recopilarse datos calidad del producto (véase capítulo ) relacionarse con las actividades del proceso. pueden recopilarse tres tipos métricas proceso: . tiempo que tarda completarse proceso particular éste puede ser tiempo total dedicado proceso, tiempo calendario, tiempo empleado proceso por ciertos ingenieros particular, etcétera. . los recursos requeridos para proceso particular los recursos pueden incluir esfuerzo total días-hombre, costos viaje recursos cómputo. . número ocurrencias evento particular los ejemplos eventos que pueden monitorizarse incluyen número defectos descubiertos durante ins-pección del código, número cambios solicitados los requerimientos número promedio líneas código modificadas respuesta cambio requerimientos. los primeros dos tipos medición pueden usarse para descubrir los cambios proceso mejoraron eficiencia proceso. suponga que proceso desarrollo -.indd -.indd // :: // :: capítulo ■ mejora procesos software hay puntos fijos, como aceptación requerimientos, conclusión del diseño arquitectónico finalización generación datos prueba. posi-ble medir tiempo esfuerzo requeridos para moverse uno estos puntos fijos otro. después introducir los cambios, las mediciones los atributos del sistema pueden indicar los cambios proceso tuvieron éxito para reducir tiempo esfuerzo requerido. las mediciones cantidad eventos que producen tienen una relación más directa con calidad del software. por ejemplo, aumentar número defectos des-cubiertos cambiar proceso inspección del programa reflejará probablemente una mejora calidad del producto. sin embargo, esto debe confirmarse mediante posteriores mediciones del producto. una dificultad fundamental medición del proceso conocer qué información respecto proceso debe recopilarse para apoyar mejora los procesos. basili rombach () proponen que llaman paradigma gqm (meta-pregunta-métrica, por las siglas goal-question-metric ), que usa ampliamente medición del software los procesos. basili green () describen cómo usa este enfoque programa mejora procesos largo plazo basado mediciones, agencia espacial estadounidense nasa. paradigma gqm (figura .) usa mejora procesos para ayudar res-ponder tres preguntas fundamentales: . ¿por qué introduce mejora procesos? . ¿qué información necesita para ayudar identificar valorar las mejoras?. ¿qué mediciones proceso producto requieren para obtener esta informa- ción? estas preguntas relacionan directamente con las abstracciones (metas, preguntas, métricas) paradigma gqm: . metas una meta algún objetivo que organización pretende lograr. debe ocuparse directamente los atributos del proceso, sino más bien cómo metas por lograr preguntas por responder cosas por medirmeta meta figura . paradigma gqm -.indd -.indd // :: // :: . ■ medición del proceso proceso afecta los productos organización . ejemplos metas pueden ser mejor nivel madurez procesos (véase sección .), tiempo desa-rrollo producto más corto aumento fiabilidad del producto. . preguntas trata mejoras las metas, las que identifican áreas especí-ficas incertidumbre relacionadas con las metas. por general, una meta tendrá algunas preguntas asociadas que necesiten responderse. ejemplos preguntas rela-cionadas con meta acotar los tiempos desarrollo productos pueden ser: ¿dónde están los cuellos botella proceso actual?, ¿cómo puede reducirse tiempo requerido para finalizar los requerimientos producto con los clientes?, ¿cuántas pruebas son efectivas para descubrir defectos producto? . métricas trata mediciones que deben recopilarse para ayudar responder las preguntas confirmar las mejoras del proceso lograron las metas deseadas. para ayudar responder las preguntas anteriores, pueden recopilar datos acerca del tiempo que tarda completarse cada actividad del proceso (normalizado por tamaño sistema), número comunicaciones formales entre clientes usua-rios para cada cambio requerimientos, cantidad defectos descubiertos mediante ejecución pruebas. ventaja usar enfoque gqm mejora procesos que separa las pre-ocupaciones organización (las metas) preocupaciones específicas del proceso (las preguntas). proporciona una base para determinar cuáles datos deben recopilarse sugiere que los datos recopilados deben analizarse diferentes formas, dependiendo pregunta que pretende responder. enfoque gqm desarrolló combinó con modelo madurez capacidad del sei (paulk ., ) método ami (por las siglas analyze, measure, improve, decir, analizar, medir, mejorar) mejora procesos del software. los desarro-lladores del método ami proponen enfoque por etapas para mejora procesos, que las mediciones comienzan después que una organización introduce cierta estandarización sus procesos, lugar comenzar las mediciones inmediato. manual ami (pulford ., ) ofrece lineamientos consejos prácticos sobre cómo implementar mejora los procesos con base mediciones. como estudió capítulo , ocasiones problemático interpretar que realidad significan las mediciones. por ejemplo, suponga que mide tiempo pro-medio tomado para reparar los bugs que reportaron software entregado para pruebas externas. éste tiempo entre recepción reporte error por parte del equipo momento que este reporte marca formalmente como “aclarado”. introduce una nueva herramienta basada web para reportar errores , después usar algún tiempo herramienta, observa que reduce tiempo para reparar los bugs reportados. entonces posible afirmar que introducción las herramientas para reportar errores redujo realmente tiempo para reparar los bugs. cuando observan cambios una métrica, siempre tentador atribuir dichos cambios los cambios proceso introducidos. sin embargo, peligroso hacer suposiciones simplistas tocante las mejoras. los cambios una métrica pueden ser causa algo completamente diferente, como cambio del personal equipo proyecto, cambios calendarización del -.indd -.indd // :: // :: capítulo ■ mejora procesos proyecto cambios administrativos. también posible que modifique práctica del equipo, tan sólo porque hace una medición. caso las herramientas para repor-tar errores, algunas las razones por las que observa cambio incluyen: . nuevo sistema puede tener carga reducida , así, más tiempo disponible para reparar bugs. esto conduce una reducción los tiempos promedios para “reparar bugs”. mejora del proceso pudo hacer una diferencia real. . nuevo sistema tal vez haga diferencia con tiempo que verdad tarda corregir los bugs, pero puede facilitar registro información. por tanto, los tiempos reparación bugs miden más exactamente con nuevo sistema. hay cambio real tiempo promedio para corregir bugs. . las mediciones antes que nuevo sistema introdujera hicieron, tal vez, través las pruebas sistema. los bugs que eran más fáciles rápidos corregir habían corregido sólo permanecieron los “bugs duros” que tardaban más repararse. sin embargo, después introducir sistema reporte bugs, las mediciones hicieron comienzo las pruebas del nuevo sistema los bugs corregidos fueron los “bugs sencillos”, que podían repararse rápidamente. . nuevo gerente del equipo pruebas pudo instruir los miembros del equi- para reportar las inconsistencias interfaz usuario como bugs, mientras que antes ignoraban. esto significó reporte muchos más “bugs sencillos” que podían corregirse rápidamente. medición una forma generar evidencia respecto proceso los cambios proceso. obstante, esta evidencia tiene que interpretarse junto con otra informa-ción sobre proceso antes poder estar seguros que son efectivos los cambios proceso. siempre debe usar medición conjunto con valoración cualitativa los cambios. esto implica hablar con las personas implicadas proceso acerca los cambios que introdujeron, obtener impresión efectividad los mismos. esto sólo revela otros factores que pudieron influir proceso, sino también medida que equipo adoptó los cambios propuestos cómo éstos afectaron práctica desarrollo actual.análisis práctica proceso enfoque análisis procesos usar cuestionarios para descubrir medida que utilizan las buenas prácticas ingeniería software. por tanto, para algunas etapas proceso, como ingeniería requerimientos, posible identificar cuáles prácticas son más adecuadas para tipo sistema desarrollar una compañía formular preguntas sobre qué tan ampliamente utilizan. éste enfoque que sugiere presente libro relación con mejora procesos ingeniería requerimientos (sommerville sawyer, ). http:// -.indd -.indd // :: // :: . ■ análisis del proceso . análisis del proceso análisis del proceso estudio los procesos para ayudar entender sus caracterís- ticas clave cómo las personas implicadas realizan práctica dichos procesos. figura . sugiere que análisis del proceso sigue medición del proceso. ésta una simplificación porque, realidad, tales actividades están entrelazadas. necesario realizar cierto análisis para saber qué medir , hacer las mediciones, desarrolla ine-vitablemente una comprensión más fondo del proceso medir. análisis del proceso tiene número objetivos relacionados estrechamente: . comprender las actividades implicadas proceso las relaciones entre dichas actividades. . entender las relaciones entre las actividades del proceso las mediciones realizadas. . relacionar proceso procesos específicos analizados con procesos comparables otras partes organización, idealizar procesos del mismo tipo. durante análisis del proceso trata comprender que sucede proceso. busca información acerca los problemas ineficiencias del proceso. también debe estar interesado medida que proceso utiliza, las herramientas soft-ware empleadas para apoyar proceso, cómo proceso está influido por restriccio-nes organización. figura . muestra algunos los aspectos del proceso que pueden investigar durante análisis del proceso. las técnicas usadas más comúnmente para análisis del proceso son: . cuestionarios entrevistas los ingenieros administradores que trabajan proyecto preguntan sobre que sucede realmente. las respuestas para cues-tionario formal mejoran durante las entrevistas personales con los implicados proceso. como estudia más adelante, discusión puede estructurarse torno modelos procesos software. . estudios etnográficos los estudios etnográficos (véase capítulo ) observa los participantes proceso mientras trabajan, los estudios pueden usarse para entender naturaleza del desarrollo del software como una actividad humana. tales análisis revelan sutilezas complejidades que pueden revelarse cuestionarios entrevistas. cada uno estos enfoques tiene ventajas desventajas. análisis basado cues-tionarios puede realizarse muy rápidamente una vez identificadas las preguntas correctas. sin embargo, las preguntas están mal planteadas son inadecuadas, esto podría desen-cadenar una comprensión incompleta imprecisa del proceso. además, análisis basado cuestionarios quizá les parezca una forma valoración evaluación. por tanto, los ingenieros encuestados pueden dar respuestas que consideren que serán del agrado los encuestadores, verdad sobre proceso utilizado. las entrevistas con personal implicado proceso son más abiertas que los cues-tionarios. inicie con guión preguntas preparado, pero adáptelas acuerdo con las -.indd -.indd // :: // :: capítulo ■ mejora procesos respuestas que obtenga diferentes personas. los participantes oportunidad discutir los temas más ampliamente, descubrirá que los participantes hablan acer- los problemas los procesos, las formas que los procesos cambian prác-tica, etcétera. casi todos los procesos, los individuos implicados hacen cambios locales para adap-tar proceso las circunstancias locales. los análisis etnográficos tienen más probabilidad que las entrevistas descubrir verdadero uso del proceso. sin embargo, este tipo aná-lisis suele ser una actividad prolongada que tal vez dure varios meses, que depende observación externa del proceso conforme éste realiza. para hacer análisis completo, uno tiene que involucrarse desde las etapas iniciales proyecto hasta entrega mantenimiento del producto. para proyectos grandes, esto podría durar varios años, así que aspecto del proceso preguntas adopción estandarización ¿ proceso está documentado estandarizado toda organización? está, ¿significa que algunas mediciones son sólo específicas para una instancia del proceso? los procesos están estandarizados, entonces los cambios proceso pueden ser transferibles procesos comparables otras partes compañía. práctica ingeniería software ¿existen buenas conocidas prácticas ingeniería software que incluyan proceso? ¿por qué incluyen? ¿ falta estas prácticas afecta las características del producto, tales como número defectos sistema software entregado? restricciones organizacionales ¿cuáles son las restricciones organización que afectan diseño del proceso las formas que realizan los procesos? por ejemplo, proceso implica lidiar con material clasificado, puede haber actividades proceso para comprobar que información clasificada incluya algún material que entregará organizaciones externas. las restricciones organización pueden significar que posible hacer cambios los procesos. comunicaciones ¿cómo gestionan las comunicaciones proceso? ¿cómo relacionan los conflictos las comunicaciones con las mediciones realizadas del proceso? los problemas comunicación son conflicto grave muchos procesos, los cuellos botella las comunicaciones con frecuencia son las razones para las demoras del proyecto. introspección ¿ proceso reflexivo ( decir, los actores que participan proceso piensan explícitamente discuten proceso cómo puede mejorarse)? ¿hay mecanismos mediante los cuales los actores del proceso puedan sugerir mejoras los procesos? aprendizaje ¿cómo aprenden los individuos que unen equipo desarrollo sobre los procesos software utilizados? ¿ compañía tiene manuales proceso programas capacitación procesos? soporte herramientas ¿qué aspectos del proceso están soportados por las herramientas software cuáles están? para áreas sin soporte, ¿existen herramientas que puedan desplegarse forma rentable para ofrecer soporte? para áreas con soporte, ¿las herramientas son efectivas eficientes? ¿hay mejores herramientas disponibles? figura . aspectos análisis del proceso -.indd -.indd // :: // :: . ■ análisis del proceso muy práctico hacer análisis etnográfico completo los procesos proyecto grande. los análisis etnográficos realidad son más útiles cuando requiere una com-prensión profunda fragmentos del proceso. una vez identificadas las áreas que necesitan más investigación partir del material entrevistas, entonces posible enfocarse estudio etnográfico enfocado descubrir detalles del proceso. cuando analice proceso, con frecuencia será útil comenzar con modelo que defina las actividades del proceso las entradas salidas dichas actividades. modelo puede incluir también información sobre los actores del proceso: los individuos los roles responsables realizar las actividades los entregables críticos que deben producirse. conveniente usar una notación informal para describir los modelos pro-ceso notaciones tabulares más formales, diagramas actividad uml, una notación modelado procesos empresariales, como bpmn (que estudió capítulo ). este libro existen muchos ejemplos modelos proceso usados para presentar describir los procesos software. los modelos proceso son una buena forma enfocar atención las activi-dades proceso transferencia información entre tales actividades. dichos modelos proceso tienen que ser formales completos, que objetivo provo-car discusión más que documentar detalle proceso. discusión con los individuos implicados proceso las observaciones dicho proceso estructuran menudo torno conjunto preguntas respecto modelo proceso formal. ejemplos estas preguntas son: . ¿qué actividades tienen lugar práctica, pero muestran modelo? inevitablemente, los modelos están incompletos, pero diferentes personas identifi-can distintas actividades faltantes, esto indica que proceso realiza manera consistente través organización. . ¿hay actividades del proceso, mostradas modelo, que ( actor del proceso) considera ineficientes? ¿ qué formas son ineficientes cómo pueden mejorarse? ¿cómo dichas actividades ineficientes afectan las mediciones del proceso que pudie-ran realizarse? . ¿qué ocurre cuando las cosas salen mal? ¿ equipo sigue proceso definido modelo, abandonan proceso toman acciones emergencia? pro-ceso abandona, esto indica que los ingenieros software creen que proceso sea suficientemente bueno que éste tenga suficiente flexibilidad para manipular excepciones. . ¿quiénes son los actores que participan las diferentes etapas del proceso cómo comunican? ¿qué cuellos botella presentan comúnmente intercambio información? . ¿qué soporte herramientas usa para las actividades que muestran modelo? ¿éste efectivo uso universal? ¿cómo podría mejorarse soporte herramientas? cuando completa análisis del proceso software, tiene una comprensión más profunda dicho proceso del potencial para mejorar los procesos futuro. también deben comprender las restricciones sobre mejora los procesos cómo puede esto limitar alcance las mejoras que pueden introducirse. -.indd -.indd // :: // :: capítulo ■ mejora procesos .. excepciones proceso los procesos software son entidades complejas. una organización puede haber modelo proceso definido, pero esto tal vez sólo represente situación que equipo desarrollo enfrenta con algunos problemas imprevistos. realidad, los problemas imprevistos son hecho cotidiano para los líderes proyecto. modelo proceso “ideal” debe modificarse manera dinámica conforme encuentren solu-ciones dichos problemas. los ejemplos los tipos excepción que debe enfrentar líder proyecto incluyen:  muchas personas clave enferman mismo tiempo, justo antes una revisión crítica del proyecto;  una violación grave seguridad computadora, que significa que todas las comunicaciones externas están fuera acción durante varios días;  una reorganización compañía, que significa que los administradores tienen que pasar buena parte tiempo trabajando asuntos organización gestión del proyecto;  una petición prevista escribir una propuesta para nuevo proyecto, cual significa que esfuerzo debe transferirse del proyecto actual elaboración una propuesta. básicamente, una excepción afectará, por general alterará alguna forma, los -cursos, presupuestos calendarización proyecto. difícil predecir todas las excep-ciones por adelantado incorporarlas modelo proceso formal. por tanto, con frecuencia habrá que arreglárselas para manejar las excepciones luego cambiar dinámica-mente proceso “estándar” para hacer frente dichas circunstancias inesperadas. . cambios los procesos cambio proceso implica hacer modificaciones proceso existente. como sugi-rió, esto incluye introducir nuevas prácticas, métodos herramientas; cambiar orden las actividades del proceso; introducir eliminar entregables del proceso; mejorar modelado procesos software modelado procesos software comenzó principios década (osterweil, ) con objetivo largo plazo usar modelos proceso como una forma organizar coordinar soporte herramientas para los procesos. modelo proceso debe incluir información concerniente las actividades del proceso, entradas salidas, así como acerca los actores que participan proceso. desarrollaron notaciones modelado procesos software propósito especial, pero han sustituido principalmente por notaciones para modelado procesos empresariales, como bpmn (white, ) modelos actividad uml. http:// -.indd -.indd // :: // :: . ■ cambios los procesos las comunicaciones, introducir nuevos roles responsabilidades. los cambios proceso deben estar dirigidos por metas mejora, tales como “reducir % número defectos descubiertos durante las pruebas integración”. después implementar los cambios, usan las mediciones del proceso para valorar efectividad éstos. existen cinco etapas clave proceso cambios proceso (figura .): . identificación mejoras esta etapa ocupa usar los resultados del análisis del proceso para identificar las formas enfrentar los problemas calidad, los cuellos botella programación las ineficiencias costo que identifi-caron durante análisis del proceso. pueden sugerir nuevos procesos, estructuras proceso, métodos herramientas para enfrentar los problemas los procesos. por ejemplo, tal vez una compañía considere que muchas sus dificultades software surgen problemas con los requerimientos. usar una guía mejores prácticas para ingeniería requerimientos (sommerville sawyer, ), posible identificar varias prácticas ingeniería requerimientos que pudieran introducirse cambiarse. . priorización las mejoras esta etapa ocupa valorar los posibles cambios los procesos priorizarlos para implementación. cuando identifican muchos posibles cambios, por general imposible introducirlos todos vez, determi-nar cuáles son los más importantes. estas decisiones pueden tomar con base necesidad mejorar áreas proceso específicas, los costos introducir cam-bio, los efectos cambio organización otros factores. por ejemplo, una compañía quizá considere introducción procesos gestión requerimientos para administrar los requerimientos evolución como cambio proceso prioridad más alta. . introducción cambios los procesos introducción cambios proceso significa establecer nuevos procedimientos, métodos herramientas, integrarlos con otras actividades proceso. hay que permitir suficiente tiempo para introducir cambios garantizar que éstos sean compatibles con otras actividades proceso, así como con estándares procedimientos organizacionales. esto tal vez implique adquirir herramientas para gestión requerimientos diseñar procesos para usar dichas herramientas.modelar procesoplan cambio procesoplan capacitaciónretroalimentación sobre mejorasmodelo proceso revisadoidentificar mejoraspriorizar mejorasafinar cambios procesointroducir cambios proceso capacitar ingenieros figura . proceso cambios proceso -.indd -.indd // :: // :: capítulo ■ mejora procesos . capacitación proceso sin capacitación imposible obtener todos los benefi- cios los cambios proceso. los ingenieros implicados necesitan comprender los cambios que propusieron cómo realizar los procesos nuevos modificados. con demasiada frecuencia, los cambios los procesos imponen sin adecuada capaci-tación efecto dichos cambios degradar, antes que mejorar, calidad del producto. caso gestión requerimientos, capacitación puede comprender una discusión del valor gestión los requerimientos, una explicación las actividades del proceso una introducción las herramientas seleccionadas. . afinación del cambio los cambios proceso propuestos nunca serán completa-mente efectivos momento introducirlos. requiere una fase afinación que puedan descubrirse problemas menores, para entonces proponer introducir modificaciones proceso. esta fase afinación debe durar varios meses hasta que los ingenieros desarrollo estén satisfechos con nuevo proceso. por general, recomendable introducir muchos cambios mismo tiempo. además las dificultades capacitación que esto provoca, introducción -merosos cambios hace imposible valorar proceso efecto cada cambio. una vez introducido cambio, proceso mejora puede iterarse con subsecuente análisis usado para identificar problemas del proceso, proponer mejoras alguna otra actividad. además los problemas valorar efectividad los procesos cambio estudia-dos, existen dos dificultades importantes que pueden enfrentar quienes participan los procesos cambio: . resistencia cambio los miembros del equipo líderes proyecto pueden opo- nerse introducción cambios proceso exponer razones por las que los cambios funcionarán, retrasar introducción cambios. algunos casos, podrían obstruir manera deliberada los cambios los procesos, interpretar los datos para demostrar ineficiencia los cambios propuestos los procesos. . persistencia del cambio aunque posible introducir inicialmente cambios los procesos, común que desechen las innovaciones los procesos después poco tiempo que los procesos vuelvan estado anterior. resistencia cambio puede provenir tanto los líderes del proyecto como losingenieros que intervienen proceso cambiar. con frecuencia, los líderes pro-yecto resisten cambio los procesos porque cualquier innovación tiene riesgos desconocidos asociados con éste. los cambios proceso tal vez pretendan acelerar producción del software reducir los defectos del software. sin embargo, siempre existe peligro que dichos cambios proceso sean ineficaces que tiempo requerido para introducir los cambios sea mayor tiempo ahorrado. juzga los líderes pro-yecto función proyecto produce software tiempo dentro del pre-supuesto. por tanto, quizá prefieran proceso ineficiente, pero predecible, que proceso mejorado que tenga beneficios para organización que, mismo tiempo, conlleve riesgos asociados corto plazo. los ingenieros pueden resistirse por razones similares introducción nuevos procesos, porque consideran que dichos procesos son una amenaza para profesiona-lismo. esto , tal vez sientan que nuevo proceso predefinido les menos discrecio- -.indd -.indd // :: // :: . ■ marco trabajo para mejora procesos cmmi nalidad que reconoce valor sus habilidades experiencia. quizá piensen que nuevo proceso signifique que requerirá menos personal que ellos podrían perder sus empleos. probablemente quieran aprender nuevas habilidades, herramientas formas trabajar. como líder, usted tiene que ser sensible los sentimientos las personas afectadas cuando introducen cambios los procesos. debe incluir todo tiempo equipo del proceso cambio, comprender sus dudas invitarlos participar planeación del nuevo proceso. hacerlos partícipes cambio del proceso, mucho más pro-bable que deseen hacer trabajo. reingeniería procesos empresariales (hammer, ; ould, ), una moda década que implicó hacer cambios radicales los procesos, tuvo éxito debido principalmente que fracasó para tomar cuenta las preocupaciones legítimas los individuos implicados. para hacer frente las preocupaciones los líderes proyecto que proceso cambio afectará manera negativa planeación los costos del proyecto, hay que aumentar presupuesto del proyecto para permitir costos demoras adicionales que resul-ten del cambio. también hay que ser realistas respecto los beneficios corto plazo del cambio. improbable que los cambios conduzcan mejoras inmediatas gran escala. los beneficios del cambio los procesos son largo plazo antes que corto plazo, manera que debe dar apoyo los cambios proceso través varios proyectos. común problema los cambios introducidos que posteriormente modifi-can. los cambios quizá sean propuestos por “evangelista”, quien cree firmemente que los cambios conducirán mejoras. tal vez trabaje arduamente para garantizar que los cambios sean efectivos acepte nuevo proceso. sin embargo, “evange-lista” marcha, entonces puede sustituirlo alguien que esté menos comprometido con nuevo proceso. por tanto, probable que los individuos implicados simplemente regresen las formas anteriores hacer las cosas. esto más probable los cambios introducidos adoptaron universalmente aún materializan todos los benefi-cios los cambios proceso. debido problemas persistencia del cambio, modelo cmmi, estudiado sección ., argumenta firmemente favor institucionalización los cambios los procesos. esto significa que los cambios los procesos dependen los indivi-duos, sino que los cambios vuelven parte práctica estándar compañía, con apoyo capacitación largo toda ella. . marco trabajo para mejora procesos cmmi software engineering institute (sei) estableció para mejorar las capacidades industria software estadounidense. mediados década , sei inició estudio formas para valorar las capacidades los contratistas software. resultado esta valoración capacidad fue modelo madurez capacidades software (cmm, por las siglas software capability maturity model) del sei (paulk ., ; paulk ., ). dicho modelo influido enormemente para convencer comunidad ingeniería software tomar con seriedad mejora procesos. cmm software siguió una variedad modelos madurez capacidades, -.indd -.indd // :: // :: capítulo ■ mejora procesos incluido modelo madurez capacidades del personal (-cmm) (curtis ., ) modelo capacidades ingeniería sistemas (bate, ). otras organizaciones han desarrollado también modelos comparables madurez proceso. enfoque spice valoración capacidades mejora procesos (paulk konrad, ) más flexible que modelo sei. incluye niveles madu-rez comparables con los niveles cmm, pero también identifica procesos, como los pro-cesos cliente-proveedor, que atraviesan dichos niveles. conforme aumenta nivel madurez, también debe mejorar rendimiento dichos procesos transversales. proyecto bootstrap década tenía meta extender adaptar modelo madurez sei para hacerlo aplicable través amplio rango compa-ñías. este modelo (haase ., ; kuvaja ., ) usa los niveles madurez sei (que explican sección ..). igual forma, propone modelo pro-ceso base (fundado modelo que usa agencia espacial europea) que puede emplearse como punto partida para definición local procesos. incluye lineamien-tos cuya finalidad desarrollar sistema calidad toda una compañía para apoyar mejora procesos. con intención integrar cúmulo modelos capacidad con base noción madurez proceso (incluidos sus propios modelos), sei embarcó nuevo programa para desarrollar modelo capacidad integrado (cmmi). marco cmmi sustituye los cmm ingeniería software sistemas, integra otros modelos madurez capacidades. tiene dos ejemplificaciones, etapas continuo, enfrenta algunas las debilidades reportadas cmm software. modelo cmmi (ahern ., ; chrissis ., ) tiene intención ser marco para mejora procesos con amplia aplicabilidad través varias com-pañías. versión etapas compatible con cmm software permite que los procesos desarrollo gestión del sistema una organización valoren asignándoles nivel madurez . versión continua permite una clasificación más fina madurez del proceso. este modelo ofrece una forma clasificar áreas proceso (figura .) una escala . modelo cmmi muy complejo, con más , páginas descripción. aquí simplificó principalmente para análisis. los principales componentes del modelo son: . conjunto áreas proceso que relacionan con las actividades proceso del software. cmmi identifica áreas proceso que son relevantes para capacidad mejora del proceso software. están organizadas cuatro grupos modelo cmmi continuo. dichos grupos las áreas proceso relacionadas listan figura .. . algunas metas, las cuales son descripciones abstractas estado deseable que debe lograr una organización. cmmi tiene metas específicas que asocian con cada área proceso definen estado deseable dicha área. también define metas genéricas asociadas con institucionalización buena práctica. figura . muestra ejemplos metas específicas genéricas cmmi. . conjunto buenas prácticas, las cuales son descripciones formas para lograr una meta. muchas prácticas específicas genéricas pueden asociarse con cada meta dentro área proceso. figura . muestran algunos ejemplos -.indd -.indd // :: // :: . ■ marco trabajo para mejora procesos cmmi prácticas recomendadas. sin embargo, cmmi reconoce que importante meta, más que forma que alcanza dicha meta. las organizaciones pueden usar cualquier práctica adecuada para lograr cualquiera las metas cmmi: tie-nen que adoptar las prácticas recomendadas por cmmi. las metas prácticas genéricas son técnicas, sino que están asociadas con insti-tucionalización buenas prácticas, que significa que esto depende madurez organización. una etapa temprana del desarrollo madurez, institucionalización quizá pretenda garantizar que establezcan los planes compañía definan los procesos para todo desarrollo software. obstante, para una organización con pro-cesos avanzados más maduros, institucionalización puede suponer introducir control procesos mediante técnicas estadísticas otras técnicas cuantitativas través organización.categoría área proceso gestión procesos definición proceso organizacional (opd) enfoque proceso organizacional (opf)capacitación organizacional ()rendimiento proceso organizacional (opp)innovación despliegue organizacional (oid) gestión proyectos planeación proyecto ()monitorización control proyecto (pmc) gestión acuerdo con proveedor (sam) gestión proyectos integrados (ipm)gestión riesgos (rskm)gestión cuantitativa proyectos (qpm) ingeniería gestión requerimientos (reqm)desarrollo requerimientos ()solución técnica ()integración producto ()verificación (ver)validación (val) soporte administración configuración ()gestión calidad proceso producto (ppqa)medición análisis ()análisis resolución decisiones (dar)análisis resolución causal (car) figura . áreas proceso cmmi -.indd -.indd // :: // :: capítulo ■ mejora procesos una valoración cmmi implica examinar los procesos una organización clasi- ficar dichos procesos áreas proceso una escala seis puntos que relacionan con nivel madurez cada área proceso. idea que, cuanto más maduro sea proceso, mejor será. siguiente escala seis puntos que asigna nivel madurez área proceso: . incompleto menos satisface una las metas específicas asociadas con área proceso. hay metas genéricas este nivel, pues tiene sentido institucionalización proceso incompleto. . realizado las metas asociadas con área proceso están satisfechas, para todos los procesos alcance del trabajo realizar estableció manera explícita comunicó los miembros del equipo. . gestionado este nivel satisfacen las metas asociadas con área pro-ceso establecen políticas organizacionales que determinan cuándo debe usarse cada proceso. tiene que haber planes proyecto documentados que establezcan las metas del proyecto. institución debe haber procedimientos para gestión recursos monitorización procesos. . definido este nivel enfoca estandarización organizacional despliegue procesos. cada proyecto tiene proceso gestionado que adapta los reque-rimientos del proyecto desde conjunto definido procesos organizacionales. deben recopilarse activos mediciones proceso, además usarse para futuras mejoras proceso. . gestionado cuantitativamente este nivel hay una responsabilidad organizacio-nal cuya finalidad usar métodos estadísticos cuantitativos para controlar los subprocesos; esto , deben utilizarse mediciones recopiladas proceso producto gestión del proceso. . optimizado este nivel superior, organización debe usar las mediciones proceso producto para impulsar mejora los procesos. hay que analizar las tendencias adaptar los procesos las necesidades cambiantes empresa.meta área proceso manejan acciones correctivas para cerrar cuando rendimiento los resultados del proyecto desvían significativamente del plan.monitorización control del proyecto (meta específica) rendimiento avance reales del proyecto monitorizan tomando como base plan del proyecto.monitorización control del proyecto (meta específica) los requerimientos analizan validan; además, desarrolla una definición funcionalidad requerida.desarrollo requerimientos (meta específica) determinan sistemáticamente las causas raíz los defectos otros problemas.análisis causal resolución (meta específica) proceso institucionaliza como proceso definido. meta genérica figura . áreas proceso cmmi -.indd -.indd // :: // :: . ■ marco trabajo para mejora procesos cmmi ésta una descripción muy simplificada los niveles capacidad , para ponerla práctica, necesita trabajar con descripciones más detalladas. los niveles son pro-gresivos, con las descripciones explícitas del proceso los niveles inferiores, pasando través estandarización procesos hacia cambio mejora los procesos dirigidos por las mediciones del proceso software, que ubican nivel más alto. para mejorar sus procesos, una compañía debe tener como objetivo aumentar nivel madurez los grupos procesos que son relevantes para negocio. .. modelo cmmi etapas modelo cmmi etapas comparable con modelo madurez capacidades software sentido que ofrece medio para valorar capacidad proceso una organización uno cinco niveles, prescribe las metas que deben lograrse cada uno dichos niveles. mejora proceso logra implementar prácticas cada nivel, desplazarse modelo los niveles inferiores los superiores. figura . muestran los cinco niveles modelo cmmi por etapas. corresponden los niveles capacidad modelo continuo. principal dife-rencia entre los modelos cmmi por etapas continuo que primero usa para valorar capacidad organización como todo, mientras que segundo mide madurez áreas proceso específicas dentro organización. cada nivel madurez tiene conjunto áreas proceso metas genéricas aso-ciadas. éstas reflejan buena práctica ingeniería gestión software, además institucionalización mejora los procesos. los niveles madurez más bajos meta prácticas asociadas los requerimientos analizan validan; además, desarrolla una definición funcionalidad requerida.analizar sistemáticamente los requerimientos derivados para asegurar que éstos son necesarios suficientes. validar los requerimientos para garantizar que producto resultante desempeñará como pretende entorno del usuario, empleando caso múltiples técnicas según sea apropiado. determinan sistemáticamente las causas raíz los defectos otros problemas.seleccionar para análisis los defectos críticos otros problemas. realizar análisis causales los defectos seleccionados otros problemas, proponer acciones para enfrentarlos. proceso institucionaliza como proceso definido.establecer mantener una política organizacional para planear realizar proceso desarrollo requerimientos. asignar responsabilidad autoridad para realizar proceso, desarrollar los productos trabajo ofrecer los servicios del proceso desarrollo requerimientos. figura . metas prácticas asociadas cmmi -.indd -.indd // :: // :: capítulo ■ mejora procesos pueden alcanzarse introducir buenas prácticas; sin embargo, los niveles más altos requieren compromiso con medición mejora los procesos. por ejemplo, las áreas proceso definidas modelo asociado con segundo nivel ( nivel gestionado) son: . gestión requerimientos gestionar los requerimientos los productos com- ponentes producto del proyecto, así como identificar inconsistencias entre dichos requerimientos los planes productos trabajo del proyecto. . planeación proyecto establecer mantener planes que definan las actividades del proyecto. . monitorización control del proyecto facilitar comprensión del avance del pro-yecto, forma que puedan tomarse las acciones correctivas adecuadas cuando rendimiento del proyecto desvíe significativamente del plan. . gestión acuerdos con proveedor gestionar adquisición productos servi-cios proveedores externos proyecto con los que existan acuerdos formales. . medición análisis desarrollar sostener una capacidad medición que sirva para apoyar necesidades información gerencial. . aseguramiento calidad proceso producto ofrecer personal geren-cia una perspectiva objetiva los procesos productos trabajo asociados. . administración configuración establecer mantener integridad los pro-ductos trabajo mediante identificación configuración, control confi-guración, registro del estatus configuración auditorías configuración. además estas prácticas específicas, las organizaciones que operan segundo nivel modelo cmmi deben lograr meta genérica institucionalizar cada uno nivel definido nivel gestionado nivel inicialnivel gestionado cuantitativamentenivel optimizado figura . modelo madurez cmmi por etapas -.indd -.indd // :: // :: . ■ marco trabajo para mejora procesos cmmi los procesos como proceso gestionado. los siguientes son algunos ejemplos prácti- cas institucionales asociadas con planeación proyectos que conducen proceso planeación proyecto convertirse proceso gestionado:  establecer mantener una política organizacional para planear realizar proceso planeación del proyecto.  brindar recursos adecuados para realizar proceso gestión proyecto, desarro- llar los productos trabajo ofrecer los servicios del proceso.  monitorizar controlar proceso planeación del proyecto con base plan tomar acciones correctivas adecuadas.  revisar las actividades, estatus los resultados del proceso planeación pro- yecto con gestión alto nivel, resolver cualquier conflicto. ventaja del cmmi por etapas consiste que compatible con modelo madurez capacidades software que propuso mediados década . numerosas compañías comprendieron están comprometidas con uso este modelo para mejora procesos. por tanto, sencillo para ellas hacer una transición este modelo cmmi etapas. más aún, modelo etapas define una clara ruta mejora para las organizaciones. éstas pueden planear paso del segundo tercer nivel, así sucesivamente. sin embargo, principal desventaja del modelo etapas ( del cmm software) naturaleza prescriptiva. cada nivel madurez tiene sus propias metas prácticas. modelo etapas supone que todas las metas prácticas nivel implementaron antes transición siguiente nivel. sin embargo, las circunstancias organizacionales pueden ser tales que sea más adecuado implementar las metas prácticas niveles supe-riores antes que las prácticas nivel más bajo. cuando una organización hace esto, una valoración madurez dará una imagen engañosa capacidad. .. modelo cmmi continuo los modelos madurez continuos clasifican una organización acuerdo con niveles discretos. vez ello, son modelos grano más fino que consideran prácti-cas individuales grupos valoran uso buena práctica dentro cada grupo procesos. por tanto, valoración madurez solo valor, sino con-junto valores que muestran madurez organización cada proceso grupo procesos. cmmi continuo considera las áreas proceso que muestran figura . asigna nivel valoración capacidad (como describió anteriormente) cada área del proceso. por general, las organizaciones operan diferentes niveles madurez para distintas áreas proceso. consecuencia, resultado una valoración cmmi continua perfil capacidad que muestra cada área proceso valora-ción capacidad asociada. figura . presenta fragmento perfil capacidad que muestra los procesos diferentes niveles capacidad. esto indica que nivel madurez administración configuración, por ejemplo, alto, pero que madurez gestión del riesgo baja. una compañía puede desarrollar perfiles capacidad reales objetivo, donde perfil objetivo refleja nivel capacidad que gustaría alcanzar para dicha área proceso. -.indd -.indd // :: // :: capítulo ■ mejora procesos principal ventaja del modelo continuo que las compañías pueden elegir procesos para mejorar acuerdo con sus necesidades requerimientos particulares. diferentes tipos organizaciones tienen distintos requerimientos para mejora los procesos. por ejemplo, una compañía que desarrolle software para industria aeroespacial puede enfocarse mejorar especificación del sistema, administración configuración validación, mientras que una compañía desarrollo web tal vez esté más interesada los procesos que enfrenta cliente. modelo etapas requiere que las compañías enfoquen vez diferentes etapas. contraste, cmmi continuo permite dis-creción flexibilidad, tiempo que acepta que las compañías trabajen dentro del marco mejora cmmi. puntos clave ■ las metas mejora procesos son una mayor calidad los productos, reducción costos proceso entrega más rápida del software. ■ los principales enfoques para mejora procesos son los enfoques ágiles, orientados reducir los costos los procesos, los enfoques fundados madurez sobre base una mejor gestión procesos uso buenas prácticas ingeniería software.monitorización control del proyecto gestión acuerdos con proveedor gestión del riesgo administración configuración gestión requerimientos verificación validación . perfil capacidad proceso -.indd -.indd // :: // :: pmcapítulo ■ lecturas sugeridas ■ ciclo mejora procesos incluye medición, análisis, modelado cambio los procesos. ■ los modelos proceso, que muestran las actividades proceso sus relaciones con los productos software, usan para descripciones procesos. sin embargo, práctica, los ingenieros que participan desarrollo software siempre adaptan modelos las circunstancias locales. ■ medición debe usarse para responder preguntas específicas sobre proceso software utilizado. dichas preguntas deben basarse metas mejora organizacional. ■ los tres tipos métricas proceso que usan proceso medición son: métricas tiempo, métricas utilización recursos métricas eventos. ■ modelo madurez proceso cmmi modelo mejora proceso integrado que soporta tanto proceso mejora continua como etapas. ■ mejora los procesos modelo cmmi basa alcanzar conjunto metas relacionadas con las buenas prácticas ingeniería software descripción, estandarización control las prácticas utilizadas para lograr dichas metas. modelo cmmi incluye prácticas recomendadas que pueden usarse, pero éstas son obligatorias. lecturas sugeridas “can you trust software capability evaluations?” este artículo echa vistazo escéptico tema evaluación capacidad, que valora madurez los procesos una compañía, analiza por qué dichas evaluaciones pueden ofrecer una imagen verdadera madurez una organización. (. ’connell . saiedian, ieee computer, (), febrero ) http:/ /. doi. org/. / . . software process improvement: results and experience from the field. este libro una colección ensayos enfocados estudios caso mejora procesos varias compañías noruegas, pequeñas medianas. también incluye una excelente introducción los asuntos generales mejora procesos. (conradi, ., dybå, ., sjøberg, ., ulsund, . (eds.), springer, .) cmmi: guidelines for process integration and product improvement, edition . una completa descripción del cmmi. cmmi amplio complejo, además que resulta prácticamente imposible hacerlo fácil leer entender. este libro realiza una labor razonable incluir cierto material anecdótico histórico, pero veces tanto denso. (. . chrissis, . konrad, . shrum, addison-wesley, .) -.indd -.indd // :: // :: pmejercicios .. ¿cuáles son las diferencias importantes entre enfoque ágil enfoque madurez del proceso para mejora los procesos software? .. ¿ante qué circunstancias probable que calidad producto esté determinada por calidad del equipo desarrollo? ejemplos los tipos productos software que son particularmente dependientes del talento habilidad individuales. .. mencione tres herramientas software especializadas que puedan desarrollarse para soportar programa mejora procesos una organización. .. suponga que meta mejora procesos una organización aumentar número componentes reutilización que producen durante desarrollo. sugiera tres preguntas paradigma gqm las que esto pueda conducir. .. describa tres tipos métrica proceso software que puedan recopilarse como parte proceso mejora procesos. ejemplo cada tipo métrica. .. diseñe proceso para valorar priorizar propuestas cambios procesos. documente esto como modelo que muestre los roles implicados este proceso. debe usar diagramas actividad uml bpmn para describir proceso. .. escriba dos ventajas dos desventajas del enfoque valoración mejora procesos que exprese los marcos mejora procesos como cmmi. .. ¿ qué circunstancias recomendaría uso representación etapas del cmmi? .. ¿cuáles son las ventajas desventajas usar modelo madurez proceso que enfoque las metas lograr, introducción buenas prácticas? .. ¿considera que los programas mejora procesos, que implican medir trabajo del personal proceso introducir cambios dicho proceso, pueden ser inherentemente insensibles? ¿qué resistencia podría surgir ante programa mejora procesos por qué? referencias ahern, . ., clouse, . turner, . (). cmmi distilled. reading, mass.: addison-wesley. basili, . green, . (). “software process improvement the sel”. ieee software, (), –.basili, . . rombach, . . (). “the tame project: towards improvement-oriented software environments”. ieee trans. software eng., (), –. capítulo ■ mejora procesos -.indd -.indd // :: // :: pmcapítulo ■ referencias bate, . . “ systems engineering capability maturity model version .”. software engineering institute. chrissis, . ., konrad, . shrum, . (). cmmi: guidelines for process integration and product improvement, edition. boston: addison-wesley. curtis, ., hefley, . . miller, . . (). the people capability model: guidelines for improving the workforce. boston: addison-wesley. haase, ., messnarz, ., koch, ., kugler, . . decrinis, . (). “bootstrap: fine tuning process assessment”. ieee software, (), –. hammer, . (). “reengineering work: don’ automate, obliterate”. harvard business review, julio agosto , –.humphrey, . (). managing the software process. reading, mass.: addison-wesley.humphrey, . . (). “characterizing the software process”. ieee software, (), –. humphrey, . . (). discipline for software engineering. reading, mass.: addison-wesley.kuvaja, ., similä, ., krzanik, ., bicego, ., saukkonen, . koch, . (). software process assessment and improvement: the bootstrap approach. oxford: blackwell publishers.osterweil, . (). “software processes are software too”. int. conf. software engineering, ieee press, –.ould, . . (). business processes: modeling and analysis for -engineering and improvement. chichester: john wiley & sons. paulk, . ., curtis, ., chrissis, . . weber, . . (). “capability maturity model, version .”. ieee software, (), –. paulk, . . konrad, . (). “ overview iso’ spice project”. ieee computer, (), –.paulk, . ., weber, . ., curtis, . chrissis, . . (). the capability maturity model: guidelines for improving the software process. reading, mass.: addison-wesley. pulford, ., kuntzmann-combelles, . shirlaw, . (). quantitative approach software management. wokingham: addison-wesley.sommerville, . sawyer, . (). requirements engineering: good practice guide. chichester: john wiley & sons. white, . . . “ introduction bpmn”. http:/ /www. bpmn. org/ documents/ introduction%%. -.indd -.indd // :: // :: pmm-.indd -.indd // :: // :: pmada lenguaje programación que desarrolló departamento defensa estadounidense década como lenguaje estándar para desarrollar software militar. basa investigación acerca lenguajes programación década incluye sentencias como tipos datos abstractos soporte para concurrencia. todavía utiliza grandes sistemas militares aeroespaciales complejos. administración configuración proceso administrar los cambios producto software evolución. administración configuración implica planeación configuración, gestión versiones, construcción sistema administración del cambio. administración del cambio proceso para registrar, comprobar, analizar, estimar implementar los cambios propuestos sistema software. análisis estático análisis basado herramientas del código fuente programa para descubrir errores anomalías. las anomalías, como las asignaciones sucesivas una variable sin uso intermedio, pueden ser indicadores errores programación. arquitectura cliente-servidor modelo arquitectónico para sistemas distribuidos donde funcionalidad del sistema ofrece como conjunto servicios proporcionados por servidor. ellos acceden computadoras cliente que usan los servicios. variantes este enfoque, como las arquitecturas cliente-servidor tres capas, usan múltiples servidores. arquitectura referencia arquitectura genérica idealizada que incluye todas las características que pueden incorporar los sistemas. una manera informar los diseñadores acerca estructura general dicha clase sistema lugar una base para crear una arquitectura sistema específica. glosario - glo.indd - glo.indd // :: // :: glosario arquitectura software modelo estructura organización fundamentales sistema software.arquitectura dirigida por modelo (model-driven architecture, mda) enfoque desarrollo software con base construcción conjunto modelos sistema, que pueden procesarse forma automática semiautomática para generar sistema ejecutable. aseguramiento calidad (quality assurance, ) proceso global para definir cómo puede lograrse calidad del software cómo organización que desarrolla software sabe que éste satisface nivel calidad requerido. ataque negación servicio ataque sistema software basado web que trata sobrecargar sistema forma que pueda proporcionar servicio normal los usuarios. bea proveedor estadounidense sistemas erp.bomba insulina dispositivo médico controlado mediante software que puede suministrar dosis controladas insulina personas que sufren diabetes. usó como estudio caso varios capítulos este libro. bpmn business process modeling notation (notación para modelado procesos negocio). una notación para definir flujos trabajo. lenguaje programación que originalmente desarrolló para implementar sistema unix. lenguaje implementación sistema nivel relativamente bajo, que permite acceso hardware del sistema que puede compilarse código eficiente. usa ampliamente para programación sistemas bajo nivel desarrollo sistemas embebidos. # lenguaje programación orientado objetos, desarrollado por microsoft, que tiene mucho común con ++, pero que incluye características que permiten más comprobación escritura tiempo compilación. ++ lenguaje programación orientado objetos que superconjunto .case (computer-aided software engineering), ingeniería software auxiliada por computadora proceso desarrollar software usando soporte automatizado.caso confiabilidad documento estructurado que usa para respaldar las afirmaciones realizadas por desarrollador sistema acerca confiabilidad este último. caso seguridad argumento estructurado que sistema seguro / está protegido. muchos sistemas críticos deben tener casos seguridad asociados que valoran aprueban mediante reguladores externos antes que sistema certifique para uso. - glo.indd - glo.indd // :: // :: pmglosario caso uso especificación tipo interacción con sistema.ciclo vida del software con frecuencia usa como otro nombre para proceso software; originalmente acuñó para referirse modelo cascada del proceso software. clase objeto una clase define los atributos las operaciones los objetos. los objetos crean tiempo ejecución ejemplificar definición clase. nombre clase puede usar como tipo nombre algunos lenguajes orientados objetos. cmm (capability maturity model) modelo madurez capacidad del software engineering institute, que usa para valorar nivel madurez desarrollo del software una organización. aunque desplazó cmmi, todavía usa ampliamente. cmmi enfoque integrado modelado madurez capacidad proceso con base adopción buenas prácticas ingeniería software gestión calidad integrada. apoya modelado madurez discreto continuo, integra modelos madurez sistemas procesos ingeniería software. cobertura prueba efectividad las pruebas del sistema para probar código todo sistema. algunas compañías tienen estándares para cobertura prueba (por ejemplo, las pruebas del sistema deben garantizar que todos los enunciados del programa ejecuten menos una vez). código ética práctica profesional conjunto lineamientos que establecen comportamiento ético profesional esperado por parte los ingenieros software. definieron las principales sociedades profesionales estadounidenses ( acm ieee) define comportamiento ético bajo ocho encabezados: público, cliente empleador, producto, juicio, administración, colegas, profesión uno mismo. com+ modelo componente middleware soporte diseñado para usar plataformas microsoft; actualmente reemplaza .net. componente unidad software independiente portable que está completamente definido que accede través conjunto interfaces. computación nube provisión computación / servicios aplicación través internet con uso una “nube” servidores proveedor externo. “nube” implementa usando gran número computadoras tecnología virtualización para usar manera efectiva dichos sistemas. confiabilidad confiabilidad sistema una propiedad agregada que toma cuenta protección, fiabilidad, disponibilidad, seguridad otros atributos del sistema. confiabilidad sistema refleja grado que los usuarios pueden confiar . - glo.indd - glo.indd // :: // :: glosario construcción sistema proceso compilar los componentes las unidades que constituyen sistema los vinculan con otros componentes para crear programa ejecutable. construcción del sistema por general automatizada, por que minimiza recompilación. esta automatización puede instalarse sistema procesamiento lenguaje (como java) puede implicar herramientas software para soportar construcción del sistema. corba (arquitectura común intermediarios petición objetos, common request broker architecture) conjunto estándares propuestos por object management group (omg) que define modelos objetos distribuidos comunicaciones objetos; influyente desarrollo sistemas distribuidos, pero actualmente utiliza rara vez. cvs herramienta software fuente abierta ampliamente usada para gestión versiones. desarrollo software orientado aspectos enfoque del desarrollo software que combina desarrollo generativo basado componentes. identifican las competencias, intereses, asuntos propiedades (concerns) transversales programa implementación esas competencias definen como aspectos. los aspectos incluyen una definición dónde incorporan programa. luego, tejedor (weaver) aspectos teje los aspectos los lugares adecuados del programa. desarrollo dirigido por modelo (model-driven development, mdd) enfoque ingeniería software centrado modelos sistema que expresan uml, vez utilizar código lenguaje programación. esto extiende mda considerar actividades distintas desarrollo, como ingeniería requerimientos las pruebas. desarrollo dirigido por pruebas enfoque desarrollo del software, donde escriben pruebas ejecutables antes del código del programa. conjunto pruebas corre automáticamente después cada cambio programa. desarrollo incremental enfoque desarrollo software donde éste entrega despliega incrementos.desarrollo iterativo enfoque desarrollo software donde los procesos especificación, diseño, programación pruebas están entremezclados. desarrollo orientado objetos () enfoque desarrollo software donde las abstracciones fundamentales sistema son objetos independientes. mismo tipo abstracción usa durante especificación, diseño desarrollo. desarrollo rápido aplicación (rapid application development, rad)enfoque desarrollo software dirigido entrega rápida del software. con frecuencia implica uso programación bases datos herramientas soporte desarrollo, como generadores pantalla reportes. - glo.indd - glo.indd // :: // :: pmglosario detección fallas uso procesos comprobación tiempo operación para detectar eliminar fallas desarrollo programa antes que den por resultado una falla operación del sistema. diagrama clase tipos diagrama uml que muestran las clases objetos sistema sus relaciones.diagrama estado tipo diagrama uml que muestra los estados sistema los eventos que disparan una transición estado otro. diagrama secuencia diagrama que muestra secuencia las interacciones requeridas para completar cierta operación. uml, los diagramas secuencia pueden asociarse con casos uso. dinámica evolución programa estudio las formas las que cambia sistema software evolución. afirma que las leyes lehman gobiernan dinámica evolución del programa. diseño interfaz usuario proceso diseñar forma que los usuarios del sistema pueden ingresar funcionalidad éste, forma que despliega información producida por sistema. disponibilidad facilidad con que sistema proporciona servicios cuando solicitan. por general, disponibilidad expresa como número decimal, manera que una disponibilidad . significa que sistema puede entregar servicios para , unidades tiempo. dominio área problemática empresarial específica donde usan los sistemas software. los ejemplos dominio incluyen control tiempo real, procesamiento datos empresariales conmutación telecomunicaciones. dsdm método desarrollo sistema dinámico (dynamic system development method); mencionado como uno los primeros métodos desarrollo ágiles. ejb (enterprise java beans) modelo componentes basado java.entrega (release) versión sistema software que pone disposición los clientes del sistema.escenario descripción una forma típica que usa sistema que usuario realiza cierta actividad. etnografía técnica observación que puede usarse adquisición análisis requerimientos. etnógrafo sumerge entorno del usuario observa sus hábitos laborales cotidianos. partir las observaciones posible inferir requerimientos para soporte software. - glo.indd - glo.indd // :: // :: glosario familia aplicación conjunto programas aplicación software que tienen una arquitectura común una funcionalidad genérica. éstas pueden ajustar las necesidades clientes específicos modificar componentes parámetros del programa. fiabilidad capacidad sistema para entregar servicios acuerdo con las especificaciones. fiabilidad puede especificarse manera cuantitativa como una probabilidad falla pedido como tasa ocurrencia fallas. flujo trabajo definición detallada proceso empresarial que tiene intención lograr cierta tarea. por general, flujo trabajo expresa gráficamente muestra las actividades proceso individual información que produce consume cada actividad. framework aplicación conjunto clases concretas abstractas reutilizables que implementan características comunes muchas aplicaciones dominio (por ejemplo, interfaces usuario). las clases framework aplicación especializan instancian para crear una aplicación. fuente abierta enfoque desarrollo software donde código fuente sistema hace público alienta usuarios externos participar desarrollo del sistema. generador programa programa que genera otro programa partir una especificación abstracta alto nivel. generador incrusta conocimiento que reutiliza cada actividad generación. gestión requerimientos proceso administrar los cambios los requerimientos para asegurarse que los cambios realizados analizan adecuadamente rastrean largo del sistema. gestión versiones proceso gestionar los cambios sistema software sus componentes, modo que sea posible conocer cuáles cambios implementaron cada versión del componente/sistema, también para recuperar recrear versiones anteriores del componente/sistema. gestión del riesgo proceso identificación riesgos, valoración severidad, planeación medidas para implementar caso que surjan riesgos, monitorización del software proceso software para detectar riesgos. gráfica actividades (pert) gráfica que usan los líderes proyecto para mostrar las dependencias entre tareas que deben completarse. gráfica muestra las tareas, tiempo esperado para completarlas sus dependencias mutuas. ruta crítica ruta más larga ( términos del tiempo requerido para completar las tareas) través gráfica actividad. ruta crítica define tiempo mínimo requerido para completar proyecto. - glo.indd - glo.indd // :: // :: pmglosario gráfica barras gráfica que utilizan los líderes proyecto para mostrar las tareas del proyecto, calendario asociado con dichas tareas las personas que trabajarán ellas. indica las fechas inicio fin las tareas, las asignaciones personal, contra cronograma. gráfica gantt nombre alternativo para una gráfica barras.herramienta case una herramienta software, como editor diseño depurador programa, usada para apoyar una actividad proceso desarrollo software. ingeniería sistemasproceso que ocupa especificar sistema, integrar sus componentes probar que sistema satisface sus requerimientos. ingeniería sistemas ocupa todo sistema sociotécnico (software, hardware procesos operacionales), sólo del software del sistema. ingeniería software basada componentes (cbse, component-based software engineering) desarrollo software mediante composición componentes software independientes portables que son congruentes con modelo componentes. ingeniería software cuarto limpio (cleanroom) enfoque desarrollo software donde meta evitar introducir fallas desarrollo software (por analogía con cuarto limpio usado fabricación semiconductores). proceso implica especificación software formal, transformación estructurada una especificación programa, desarrollo argumentos correctos pruebas estadísticas del programa. inspección programa revisión donde grupo inspectores examina programa, línea por línea, con intención detectar errores. con frecuencia las inspecciones realizan con base una lista verificación errores programación comunes. interfaz especificación los atributos las operaciones asociados con componente software. interfaz usa como medio para acceder funcionalidad del componente. interfaz programa aplicación (api)una interfaz, por general especificada como conjunto operaciones que permiten acceso funcionalidad programa aplicación. esto significa que posible que esta funcionalidad sea llamada directamente por otros programas sólo accederse ella través interfaz usuario. iso / conjunto estándares normas para procesos gestión calidad definidos por international standards organization (iso). iso estándar iso que resulta más aplicable desarrollo software. puede usarse para certificar los procesos gestión calidad una organización. - glo.indd - glo.indd // :: // :: glosario ítem configuración unidad legible por máquina, como documento archivo código fuente, que está sujeto cambio donde este último tiene que controlarse mediante sistema administración configuración. java platform enterprise edition. complejo sistema middleware que apoya desarrollo java aplicaciones web basadas componentes. incluye modelo componentes para componentes java, apis, servicios, etcétera. java lenguaje programación orientado objetos usado ampliamente, diseñado por sun con intención obtener independencia plataforma. lenguaje consulta estructurado (structured query language, sql) lenguaje estándar que utiliza para programación bases datos relacionales.lenguaje modelado unificado (unified modeling language, uml) lenguaje gráfico que utiliza desarrollo orientado objetos incluye varios tipos modelos sistema que ofrecen diferentes visiones sistema. uml convirtió estándar facto para modelado orientado objetos. lenguaje restricción objetos (object constraint language, ocl)lenguaje que parte del uml, que usa para definir predicados que aplican clases objetos interacciones modelo uml. uso del ocl para especificar componentes parte fundamental del desarrollo dirigido por modelo. leyes lehmanconjunto hipótesis acerca los factores que influyen evolución sistemas software complejos. línea productos software véase familia aplicación.make una las primeras herramientas construcción sistemas; todavía usa ampliamente sistemas unix/linux. manifiesto ágil conjunto principios que incluyen las ideas subyacentes los métodos ágiles desarrollo software. mantenimiento proceso hacer cambios sistema después ponerlo operación.mejora proceso cambio proceso desarrollo software con intención hacer que dicho proceso sea más eficiente mejore calidad sus resultados. por ejemplo, intención reducir número defectos software entregado, posible mejorar proceso agregar nuevas actividades validación. método estructurado método diseño software que define los modelos sistema que deben desarrollarse, las reglas los lineamientos que deben aplicarse dichos modelos, proceso seguir desarrollo del diseño. - glo.indd - glo.indd // :: // :: pmglosario métodos ágiles métodos desarrollo software que combinan para una entrega rápida del software. software desarrolla entrega incrementos, minimizan documentación del proceso burocracia. foco del desarrollo está código , los documentos apoyo. métodos formales métodos desarrollo software donde software modela usando sentencias matemáticas formales como predicados conjuntos. transformación formal convierte este modelo código. usa principalmente especificación desarrollo sistemas críticos. métrica control métrica software que permite los administradores tomar decisiones planeación con base información acerca del proceso software producto software que desarrollará. mayoría las métricas control son métricas proceso. métrica predicción métrica software que usa como base para realizar predicciones acerca las características sistema software, como fiabilidad mantenibilidad. métrica del software atributo sistema proceso software que puede expresarse numéricamente medirse. las métricas proceso son atributos del proceso, como tiempo que tarda completarse una tarea; las métricas producto son atributos del software , como tamaño complejidad. mhc-pms sistema gestión pacientes atención salud mental; usó como estudio caso varios capítulos. middleware software infraestructura sistema distribuido. ayuda gestionar las interacciones entre las entidades distribuidas sistema las bases datos del sistema. ejemplos middleware son intermediario solicitud objetos sistema gestión transacciones. modelado algorítmico costo enfoque estimación costos del software donde usa una fórmula para estimar costo del proyecto. los parámetros fórmula son atributos del proyecto software . modelado crecimiento fiabilidad desarrollo modelo cómo cambia (mejora) fiabilidad sistema conforme prueba eliminan defectos del programa. modelo constructivo costos (constructive cost modeling, cocomo)familia modelos algorítmicos estimación costos. cocomo propuso por primera vez principios década , desde entonces, modificó actualizó para reflejar nueva tecnología las cambiantes prácticas ingeniería software. - glo.indd - glo.indd // :: // :: glosario modelo componentes conjunto estándares para implementación, documentación despliegue componentes. cubre las interfaces específicas que pueden proporcionar componente, nomenclatura, interoperación composición componentes. los modelos componentes brindan base para que middleware soporte componentes ejecución. modelo componentes corba modelo componentes diseñado para usar plataforma corba.modelo dominio definición abstracciones dominio, como políticas, procedimientos, objetos, relaciones eventos. sirve como base conocimiento acerca alguna área problema. modelo madurez proceso modelo medida que proceso incluye buenas prácticas capacidades medición que integran para mejorar proceso. modelo madurez capacidad del personal (people capability maturity model, -cmm) modelo madurez proceso que refleja cuán efectiva una organización para administrar las habilidades, capacitación experiencia personal. modelo objeto modelo sistema software que estructura organiza como conjunto clases objetos las relaciones entre dichas clases. pueden existir varias perspectivas diferentes del modelo, como una perspectiva estado una secuencia. modelo proceso representación abstracta proceso. los modelos proceso pueden desarrollarse desde varias perspectivas muestran las actividades implicadas proceso, los artefactos usados éste, las restricciones que aplican proceso los roles las personas que ejecutan. modelo cascada modelo proceso software que comprende etapas desarrollo discretas: especificación, diseño, implementación, pruebas mantenimiento. principio, una etapa debe completarse antes que sea posible avance siguiente etapa. práctica, existe significativa iteración entre etapas. modelo espiralmodelo proceso desarrollo donde proceso representa como una espiral; cada vuelta espiral incorpora las diferentes etapas del proceso. conforme uno mueve una vuelta espiral otra, repiten todas las etapas del proceso. .net marco trabajo muy extenso que usa para desarrollar aplicaciones para sistemas microsoft windows; incluye modelo componentes que define estándares para componentes sistemas windows middleware asociado para apoyar ejecución componentes. - glo.indd - glo.indd // :: // :: pmglosario object management group (omg) grupo compañías constituido con finalidad desarrollar estándares para desarrollo orientado objetos. los ejemplos estándares promovidos por omg son corba, uml mda. ocultamiento información uso sentencias lenguaje programación para ocultar representación las estructuras datos controlar acceso externo dichas estructuras. patrón arquitectónico (estilo)descripción abstracta una arquitectura software que ensayó puso prueba algunos sistemas software distintos. descripción del patrón incluye información acerca dónde adecuado usar patrón organización los componentes arquitectura. patrón diseño solución bien probada problema común que conjunta experiencia buena práctica una forma que pueda reutilizarse. una representación abstracta que puede ejemplificarse varias formas. plan calidad plan que define los procesos procedimientos calidad que deben usarse. esto implica seleccionar instanciar los estándares para productos procesos, definir los atributos calidad del sistema que son más importantes. prevención fallas desarrollo software tal forma que introduzcan fallas desarrollo dicho software. probabilidad falla pedido (probability failure demand, pofod)métrica fiabilidad que basa probabilidad que sistema software caiga cuando hace una petición sus servicios. proceso software conjunto actividades procesos relacionados implicados desarrollo evolución sistema software. proceso racional unificado (rational unified process, rup) modelo proceso software genérico que presenta desarrollo del software como una actividad iterativa cuatro fases: concepción, elaboración, construcción transición. concepción establece caso empresarial para sistema, elaboración define arquitectura, construcción implementa sistema, transición implementa sistema entorno del cliente. programación pares situación desarrollo donde los programadores trabajan pares, individualmente, para desarrollar código; parte fundamental programación extrema. programación extrema () método ágil desarrollo software usado ampliamente, que incluye prácticas como requerimientos basados escenarios, desarrollo primera prueba programación pares. - glo.indd - glo.indd // :: // :: glosario propiedad emergente propiedad que sólo vuelve evidente una vez que integran todos los componentes para crear sistema. protección capacidad sistema para operar sin falla catastrófica.pruebas caja blanca enfoque las pruebas programa, donde las pruebas basan conocimiento estructura del programa sus componentes. acceso código fuente esencial para las pruebas caja blanca. pruebas caja negra enfoque las pruebas donde los examinadores tienen acceso código fuente sistema sus componentes. las pruebas derivan especificación del sistema. python lenguaje programación con tipos dinámicos, que particularmente adecuado para desarrollo sistemas basados web; google usa manera extensa. reingeniería modificación sistema software para facilitar comprensión cambio. con frecuencia, reingeniería implica reestructuración organización software datos, simplificación del programa redocumentación. reingeniería, procesos empresariales cambio proceso empresarial para satisfacer nuevo objetivo organizacional, como costo reducido ejecución más rápida. requerimiento funcional enunciado cierta función característica que debe implementarse sistema.requerimiento funcional enunciado una restricción comportamiento esperado que aplica sistema. esta restricción puede referirse las propiedades emergentes del software que desarrolla proceso desarrollo. requerimientos confiabilidad requerimiento sistema que incluye para ayudar lograr confiabilidad requerida para sistema. los requerimientos funcionales confiabilidad especifican valores atributo confiabilidad; los requerimientos confiabilidad funcional son requerimientos funcionales que especifican cómo evitar, detectar, tolerar recuperarse fallas desarrollo operación del sistema. rest rest deriva representational state transfer (transferencia estado representacional), que estilo desarrollo basado simplemente interacción cliente/servidor, que usa protocolo http. rest basa idea recurso identificable, que tiene una uri. toda interacción con los recursos basa http post, get, put delete. ahora usa ampliamente para implementar servicios web carga baja. riesgo resultado indeseable que plantea una amenaza logro cierto objetivo. riesgo proceso amenaza calendarización costo proceso; riesgo producto - glo.indd - glo.indd // :: // :: pmglosario riesgo que puede significar que algunos los requerimientos del sistema logren. ruby lenguaje programación con tipos dinámicos que particularmente adecuado para programación aplicaciones web. sap compañía alemana que desarrolló sistema erp bien conocido ampliamente usado. también refiere nombre del sistema erp . scrum método desarrollo ágil, que basa sprints: ciclos desarrollo cortos. scrum puede usarse como base para gestión proyectos ágiles, junto con otros métodos ágiles como . seguridad capacidad sistema para protegerse mismo contra intrusión accidental deliberada. seguridad incluye confidencialidad, integridad disponibilidad. sei software engineering institute. centro investigación transferencia tecnológica ingeniería software, fundado con intención mejorar estándar ingeniería software las compañías estadounidenses. servicio véase servicio web.servicio web componente software independiente que puede accederse través internet usando protocolos estándar. está completamente autocontenido sin dependencias externas. han desarrollado estándares basados xml, como soap (standard object access protocol, protocolo estándar acceso objetos), para intercambio información servicio web, wsdl (web service definition language, lenguaje definición servicio web), para definición interfaces servicio web. sin embargo, enfoque rest también puede usarse para implementar servicios web. servidor programa que proporciona servicio otros programas (clientes).sistema crítico sistema cómputo cuya falla puede dar por resultado significativas pérdidas económicas, humanas ambientales. sistema planeación recursos empresariales (enterprise resource planning, erp) sistema software gran escala que incluye rango capacidades para soportar operación las empresas que ofrece medio para compartir información través dichas capacidades. por ejemplo, sistema erp puede incluir soporte para proporcionar administración, fabricación distribución cadena. los sistemas erp configuran con base los requerimientos cada compañía que usa sistema. - glo.indd - glo.indd // :: // :: glosario sistema procesamiento datos sistema que dirige procesar grandes cantidades datos estructurados. dichos sistemas, por general, procesan los datos lotes siguen modelo entrada-proceso-salida. ejemplos sistemas procesamiento datos son los sistemas boletaje facturación, los sistemas pago. sistema procesamiento lenguaje sistema que traduce lenguaje otro. por ejemplo, compilador sistema procesamiento lenguaje que traduce código fuente del programa código objeto. sistema procesamiento transacciones sistema que garantiza que las transacciones procesen tal forma que puedan interferir entre , por tanto, que falla transacción individual afecte otras transacciones los datos del sistema. sistema tiempo real sistema que debe reconocer procesar eventos externos “tiempo real”. exactitud del sistema sólo depende que hace, sino también qué tan rápido hace. los sistemas tiempo real por general organizan como conjunto procesos secuenciales cooperativos. sistema distribuido sistema software donde los subsistemas componentes software ejecutan diferentes procesadores. sistema heredado sistema sociotécnico que útil esencial para una organización, pero que desarrolló usando tecnología métodos obsoletos. puesto que los sistemas heredados con frecuencia realizan funciones empresariales críticas, deben mantenerse. sistema meteorológico campo abierto sistema para recopilar datos acerca las condiciones meteorológicas áreas remotas. usó como estudio caso varios capítulos este libro. sistema par par sistema distribuido donde hay distinción entre clientes servidores. las computadoras sistema pueden actuar como clientes como servidores. las aplicaciones par par incluyen compartición archivos, mensajería instantánea sistemas apoyo cooperación. sistema sociotécnico sistema (incluyendo hardware componentes software) con procesos operacionales definidos, que siguen operadores humanos que funciona dentro una organización. por tanto, recibe influencia políticas, procedimientos estructuras organizacionales. sistemas basados eventos sistemas donde control operación está determinado por eventos que generan entorno del sistema. mayoría los sistemas tiempo real son sistemas basados eventos. - glo.indd - glo.indd // :: // :: pmglosario sistemas embebidos sistema software que embebe dispositivo hardware (por ejemplo, sistema software teléfono celular). por general, los sistemas embebidos son sistemas tiempo real , por tanto, deben responder forma oportuna los eventos que ocurren entorno. subversión herramienta construcción sistemas fuente abierta, ampliamente utilizada, que está disponible para una variedad plataformas. tasa ocurrencia fallas (rate ocurrence failure, rocof)métrica fiabilidad que basa número fallas observadas sistema periodo tiempo dado. tejedor aspectos (weaver) programa que por general parte sistema compilación que procesa programa orientado aspectos modifica código para incluir los aspectos definidos los puntos especificados del programa. tiempo medio para falla (mttf) tiempo promedio entre fallas sistema observadas; usa especificación fiabilidad. tipo datos abstractos tipo que define por sus operaciones por representación. representación privada sólo puede accederse ella mediante las operaciones definidas. tolerancia fallas capacidad sistema para continuar ejecución incluso después que ocurran fallas. transacción unidad interacción con sistema cómputo. las transacciones son independientes atómicas ( descomponen unidades más pequeñas) son una unidad fundamental recuperación, consistencia concurrencia. validación proceso comprobar que sistema satisface las necesidades expectativas del cliente. verificación proceso comprobación que sistema satisface sus especificaciones.verificación modelo método verificación estático donde modelo estado sistema analiza exhaustivamente con intención descubrir estados inalcanzables. workbench case conjunto integrado herramientas case que trabajan conjunto para apoyar una actividad proceso principal como diseño software administración configuración. - glo.indd - glo.indd // :: // :: glosario wsdl notación basada xml para definir interfaz servicios web.xml extended markup language, decir, lenguaje marcas extensible. xml lenguaje marca texto que soporta intercambio datos estructurados. cada campo datos está delimitado por etiquetas que ofrecen información acerca dicho campo. ahora xml usa ampliamente convertido base protocolos para servicios web. abreviatura utilizada comúnmente para programación extrema. lenguaje especificación formal, basado modelos, desarrollado universidad oxford, inglaterra. - glo.indd - glo.indd // :: // :: pmde proyectos, - actividades , ágil, - trabajo, del cambio, , , , , -, forma solicitud (crf), ágiles , historia, para administración del cambio, - terminología, adquisición análisis ( requerimientos), , -, datos flujo neutrones, advice (consejo) (aose), , , falla sistemas, datos, , , , sistema control vuelo, , -, , , , , , , del cambio (procesos cambio proceso), , laborales, , mediciones , -, , , (análisis, medición, mejora), método, basado escenarios, árbol fallas, -, componentes software, - basado reutilización, índice analítico abrazar cambio (manifiesto ágil), , , usuario, bitácora , -, , , , /ieee- joint task force software engineering ethics and professional practices (fuerza trabajo conjunta sobre ética prácticas profesionales ingeniería software), - actividades automatizadas, ingeniería software, , , , activos, , , , , , , , , , ambiental, -, -, (lenguajes descripción arquitectura), configuración, , -, , -. véase también administración del cambio actividades , - sistema , , , -, flujo trabajo para, entregas (release) , , -, gestión versiones , , , -, arquitectónicos , personal, , - - indice.indd - indice.indd // :: // :: índice analítico análisis (continúa) red petri, sistemas supervivientes, , - temporización (sistemas tiempo real), - estático, -, automático, - estructurado demarco, trabajo diseño , , mejora (ami), método, riesgos, , analizadores estáticos, , , , , -, sistema frenado, . véase ingeniería software orientada aspectos. aplicaciones independientes, -, basadas transacciones, aprendizaje (análisis proceso), , -() protección estructurados, -, seguridad informal (bomba insulina), -, -, ariane , explosión, , , , , aplicación, -, empresarial, arquitectura() cliente-servidor dos niveles, -, - automonitorización, - compilador tubería filtro, , componentes distribuidos, - protección capas, referencia, sistema, - confiable, - aplicación, -, sistema recolección datos (estación meteorológica), , compilador tubería filtro, - , , , sistemas , , software aplicación, -, grande, pequeño, sistema, - sistema administración recursos, dirigida por modelo (mda), -, , -esclavo, - servicios (soa), , - definición , software , versus, descentralizada, semicentralizada, par (), -, arreglos enlazados, límites, aseguramiento confiabilidad/seguridad, -. véase también procesos software (aseguramiento ) asignación memoria dinámica, , lenguaje programación, , , , , , aspectos, -(), , , , , , envenenamiento sql, , modificación, negación servicio, neutralización, (requerimientos seguridad), , atención salud mental-sistema gestión pacientes. véase mhc-pms atm (cajeros automáticos), , , , , , atributos software, , , pruebas, , , , , , “banda cuatro”, , , (notación para modelado procesos negocios), , , , , , , , , bomba gas (modelo máquina estado), petróleo (modelo máquina estado), buffer circular, , , - indice.indd - indice.indd // :: // :: pmíndice analítico caída del sistema, caja blanca, , , cajeros automáticos. véase atmcalendarización (planeación proyecto), - del servicio (qos), , , -. véase también procesos software (cambio ) métodos ágiles , , , , , empresa , , capa gestión comunicación datos, -, - capacidades reinicio, (ingeniería software auxiliada por computadora), herramientas, , , , , caso protección/confiabilidad, -, prueba verificación dosis, , , , uso, -, , adquisición, , , , -, , , , catálogo arquitectura software, booch, , , cbse. véase ingeniería software basada componentes ciclo vida análisis riesgo, , seguridad, , - del software, -. véase también modelo cascada cim (modelos computación independientes), , clases objetos, -, , , sitio (), , modelo madurez. véase modelo madurez capacidad del personal; modelo madurez cmm softwarecmmi, armazón mejora del proceso, -, cocomo , modelo, , , - red, gusano, () conducta, -, ética práctica profesional (ingeniería software), - duplicado, , , , , compartimentalización, (), separación , - compiladores, ciclomática, , , , , , , componente() controlador (mvc), software, -, -, composición, -, , , , , , , , , -, , -, -, , - , -, , versus, - visualizador, (mvc), (mvc), comprobación() basada herramientas, - aserción, error definido por usuario, modelo, , , , , -, racionalidad, rango, realismo, representación, tamaño, totalidad, , , validez, , -, computación nube, , , , regreso (callbacks), análisis, condiciones latentes, del software, - aseguramiento, - , -, hardware, - indice.indd - indice.indd // :: // :: índice analítico confiabilidad del software (continúa) definición , , especificación , - , - , - , , , , confianza, , , -, tiempo implementación, -, , , , , mención , sistemas, , , -, proclives error, -, () armazones aplicación , eventos, , configuración, arquitectónicos para, , , corba (arquitectura común intermediarios peticiones objetos), , , , , , corrección bugs, . véase también técnicas basadas experiencia (técnicas estimación) cocomo , , - fallas desarrollo, formal, del sistema, , software, /desarrollo, , software , cots reutilización basada , , -, , , - solución, -, - creación prototipos sistema, , -, , , , sistema ejecutable, “crisis del software”, éxito (sistemas sociotécnicos), , - crystal, , , , , , , , daños, , fallas software , , , , propiedad intelectual, heterogeneidad, anfitrión destino, , -, mantenimiento, , código abierto, -, instancia producto, primera prueba, , , -, , sistemas, -, -, software adaptativo, , , , , -, dirigido por modelo (mdd), por plan métodos ágiles versus, -, , proyectos , - , , , , , -, dirigido por pruebas (tdd), -/entrega iterativos, , , versus, , -, , , -, , , , , versus, espiral , , -, prueba, -, - software, - , con (proceso cbse), , - (proceso cbse), , - servicios , - sociotécnicos, -, -, , , descripción universal, descubrimiento integración (uddi), , despliegue del sistema, , , dfd (diagramas flujo datos), actividades (uml), , , , , , bloques, , clase, , - estado(uml), , , , , , , , - indice.indd - indice.indd // :: // :: pmíndice analítico flujo datos (dfd), secuencia, , , -, dinámica evolución programa, - arquitectónico, , - catálogo arquitectónico booch , , , decisiones, -, orientado objetos , - visión +, , , , , , - base datos, interfaz, , , catálogo, servicio, - usuario, , , , seguridad sistema, - sistemas, embebidos, -, -, software, , , -, , - fase ciclo vida, trabajo, , - , -, , -, -, interfaz usuario, , , , aspectos, - implementación, , - recuperabilidad, - , -/requerimientos, modelo espiral , - , embebidos, - programación orientados aspectos, - dispersión, -, sistema, , , - diversidad del software, , , , -, , -, , , , , , -, documentación, , , arquitecturas , - línea, proceso , sistema. véase documentaciónestándares, ágiles , , -, build , , dominio, , , , , del proyecto asignación personal (cocomo ), - eficiencia, , , (enterprise java beans), , , , , oilsoft, -, - empresas cambio social , software rápido , - flujo trabajo, procesos, , software, , , , , , código abierto, , enfoque “big bang”, persona (errores humanos), sistemas (errores humanos), por riesgo para derivación requerimientos, spice, enlaces arreglo, verificación, (tangling), -, aplicación, heredado, , , , enterprise java beans (ejb), , , , , (). véase también ide desarrollo interactivo. véase ideeclipse, , , , , , , trabajo , case , , , , , arquitectónicos , , entrada() procesamiento , por omisión, - validez , -, entrega() versión pequeñas (), , , , -, (release), entrevistas, -, - indice.indd - indice.indd // :: // :: índice analítico enunciados -, , , envoltura (capa) aplicación (wrapper), activos, , , ingeniería sistemas , () aritmético, operadores, , , , , , temporización, - sistema, , -, , escalamiento métodos ágiles, -, , - pruebas , - escritura propuestas, trabajo, ambiental (líneas productos software), plataforma (líneas producto software), funcional (líneas producto software), especificación() algebraicas, fiabilidad, - confiabilidad funcional, interfaz, - requerimientos software (srs), -, sistema (-spec), software, , , , , , -, - lenguaje natural, , -, -, , -, , . véase también métodos formales. espíritu equipo (estudio caso), objetivos (modelo espiral), meteorológicas campo abierto, - ambiente , - alto nivel , sistema recolección datos , , diagrama estado, , secuencia “datos meteorológicos recopilados” para, identificación objetos , -, objeto , caso uso para, , contexto para, objetos, datos (diagrama secuencia) , proceso, , , , , producto, , servicio web, , , , , , software, -, estándares iso , - estímulo() periódicos, -, -/respuesta (sistemas embebidos), - estrategia minimización (gestión del riesgo), reconocimiento (supervivencia), , recuperación (supervivencia), -, resistencia (supervivencia), , estudios factibilidad, , adquisición/procuración (sistemas sociotécnicos), -, -, operación (sistemas sociotécnicos), -, -, procuración/adquisición (sistemas sociotécnicos), -, -, etnografía, -, , cambio, riesgos, -, (gestión del riesgo), desarrollo, , falla único, -, evolución del software, , , , , , - definición , versus, , -, , evolución programa, - sistema versus, - , , , espiral , -, servicios , - , - , , , , - excepciones proceso, para, - exposición, , calidad del servicio, centrales con, - - indice.indd - indice.indd // :: // :: pmíndice analítico fallas hardware, sistema computadora, /seguridad , , , , , , - del sistema , humanos , , -, software , desarrollo del sistema , , , - determinismo , rendimiento , , caso , críticos para protección , críticos , aeronaves , software, , , , -, , , , , , , , , , , , , , desarrollo, detección eliminación , , , , , - , , errores humanos , -, , , , , , , , fase concepción (rup), - elaboración (rup), transición (rup), fiabilidad del operador, sistema, , , , , -, -, , -, -, crecimiento, , , - , -, fijación precio software (planeación proyectos), - filmoteca, () trabajo, -, - paquete vacaciones, petición cambio (crf), , - aplicación web (waf), del sistema, , , , , fusión, , generación rutinas (scripts) construcción, programa, especulativa, , -, -, , calidad del software , - almacenamiento, entregas (release), , -, calidad, - versiones (), , , -, software, , , -. véase también administración configuración; administración personal; administración proyectos; gestión calidad; mejora procesos; planeación proyectos estándares software , -/métricas software , - gnutella, (meta-pregunta-métrica), , -, () actividades (planeación), , asignación personal, estado, , grupo(), - composición (estudio caso), , - gestión objetos (omg), , , - gusano, , , , , , internet, , , , herencia, , , , , , , , , , , , , - indice.indd - indice.indd // :: // :: índice analítico herramientas desarrollo software. véase case, herramientas ingeniería software auxiliada por computadora. véase case, herramientas traducción, , , , automatizadas, historia derivación, usuario, , , , , , honestidad (administración personal), microondas, , -, , icase, (entornos desarrollo interactivos) arquitectura repositorio para, , , , anfitrión destino , , -, , eclipse , , , , , , , general, identificación amenaza (requerimientos seguridad), control (requerimientos seguridad), servicio candidato, - evaluación activos (requerimientos seguridad), priorización mejora (proceso cambio proceso), identificadores universales recurso (uri), (international electrotechnical commission), estándar para gestión seguridad, iec , ciclo vida seguridad, conflictos , - cambio, , servicio, - sistema, , , , , -, , -, , servicio, - implementación uml, , , , -, , -, -, para, , - ciclo vida, trabajo, , -, incompatibilidad operación, parámetro, del copyright, , , , requerimientos, , , , , , -, , - definición , ágiles , competencias, - sistemas, , , , - críticos, , , , , , software actividades , , , , procesos , , - componentes (cbse), , - , , computación versus, , aspectos, - , , , -, - , - , , - sistemas versus, , , , , -pms , - fundamentales , , , aspectos (aose), , - reutilización, , -, , -, responsabilidad ética , -, para , , , competencias , -, , , - subsistemas, , por modelo (mde), -, , , , , , , inspecciones, -, , , -. véase también revisiones instancia versión, continua, , , , , , , sistema, , , prueba , , interacción usuario (waf), , componentes , -, , - memoria compartida, - indice.indd - indice.indd // :: // :: pmíndice analítico parámetro, servicio, transmisión mensajes, , , international electrotechnical commision (iec), estándar para gestión seguridad, interpretación mediciones, -, , , , (análisis proceso), control, armazones, del cliente (métodos ágiles), , , , , iso , marcos estándares, - configuración, software (sci), , , , desarrollo sistemas tiempo real , , prueba programa, jerarquía afirmación protección (sistema control bomba insulina), necesidades humanas, juego planeación, -, , , , , , , , , , lenguaje consulta estructurado. véase sqlde definición servicio web. véase esdlde descripción arquitectura (adl), diseño, modelado unificado. véase umlde restricción objeto (ocl), , , - estructurado, /ada, leyes lehman, -, programa, , - bsd (berkeley standard distribution), público general (gpl) gnu, general reducida (lesser general public license), licenciamiento código abierto, - software , limitación daño, , recuperación exposición, lineamientos contratación, programación confiable, - sistema, - línea() base (baseline), , código (codeline), , producto software, -, (mainline), linux, , , , , , , , , () verificación inspección , (análisis riesgo), , lógica formal (análisis riesgos), (bitácoras), -, - procedimiento remoto (rpc), , ideas, , mad. véase arquitectura dirigida por modelomal uso computadoras, interfaz, mala interpretación interfaz, “malos olores”, , , , excepciones, - ágil, , , , , , , , , , , , , , , , , , , - indice.indd - indice.indd // :: // :: índice analítico mantenimiento software, , , , - costos , desarrollo, , desarrollo versus, arquitectónico , - esfuerzo, ciclo vida, ágiles , -, - , , preventivo. véase refactorización mapeo entrada/salida, tiempo (timestamp) modificación, .net, , , , , , , , , , marcos aplicación web (waf), , infraestructura del sistema, mdd. véase desarrollo dirigido por modelomde. véase ingeniería dirigida por modelo. véase también métricas ambigüedad , -, /predicción, , -, proceso, -, medición/métricas software, -. véase procesos software (mejora ) estructura programa, mensajes entrada/salida (uml), -pregunta-métrica (gqm), , -, () ágiles, , - administración del proyecto, -, , , , , , , incremental , , arquitectónico , , , -, dirigido por plan versus, -, , scrum , , , , -, , , , -, formal , , del cliente , , , , , , , , , , , , del proceso , , , -“personas, procesos” , , , del proyecto, - , , diseño , críticos , , análisis estructurado, , diseño estructurado, , ingeniería requerimientos volere, , (desarrollo software), , , , , , , mde , , , , , sistema, , - objectory, métrica() avail, -, control/ predicción, disponibilidad (avail), -, eventos, -, productos, - tiempo, -, utilización recursos, -, gqm, , -, producto software, software , - fiabilidad, -, requerimientos funcionales, , -, recursos, -, mhc-pms (mental health care-patient management system: atención salud mental-sistema gestión pacientes), - análisis activos (reporte valoración riesgos) para, - amenazas control para, aose , - agregación , principales del, prueba comprobación dosis, , uso para, seguridad , - éxito , - clase , , secuencia , - , generalización , , , -, caso uso , , , contexto , proceso detención involuntaria , - indice.indd - indice.indd // :: // :: pmíndice analítico organización (diagrama) , participantes para, arquitectónico capas , , - , - escenario , basadas requerimientos , funcionales , , , , funcionales , seguridad , - historia , , tarea , , middleware, , , , - datos, ágil, , , , costo, , -, , , crecimiento, confiabilidad, - sistema. véase modelosdirigido por datos, - eventos, - modelo(), , , - actividad, , , , , , uso, , , -, , , liviano, pesado, continuo, - etapas, - contextuales, -, , - fiabilidad, , semánticos, , , boehm. véase modelos espiralde capacidad ingeniería sistemas, , componentes, - comportamiento, -, composición aplicación, computación independientes (cim), , diseño temprano, - interacción, -, -, - madurez cmm software, , , , , madurez capacidad del personal (-cmm), , máquinas estado, , , , , , proceso, -, , , negocios, prueba, queso suizo, -, reutilización (cocomo ), - subsistema, , transmisión, visión +, , , , , , , , , por datos, - eventos, - cascada, , -, espiral, -, -, -, , - plataforma (psm), , , , , , -, , , -, . véase modelosindependientes plataforma (pim), , , -, -, - estado, , , , , ágil, , , , costos, - -cmm, , -arquitectónico, - datos, , , tiempo real, -, subsistema, , , modelo-vista-controlador. véase mvcmotivación (administración personal), - (modelo-vista-controlador), , , , , - mysql, , necesidades autorrealización, estima, protección (jerarquía necesidades humanas), , , nivel abstracción (reutilización), sistema (reutilización), determinismo, , -, - indice.indd - indice.indd // :: // :: índice analítico funcional propiedades emergentes, - requerimientos, , -, , fiabilidad, - notación para modelado procesos negocios (bpmn), -, -, -, - números punto flotante, ocl (lenguaje restricción objetos), , , - omg (grupo gestión objetos), , servicio catálogo, sistema, -, -, mantenimiento (fase ciclo vida), oracle, objetos análisis requerimientos, , , -, owl-, , páginas web dinámicas, software vertical, , , programador/examinador, - equivalencia, - partes interesadas, () arquitectónico repositorio, -, (estilos), -, , - software embebido , - arquitectura capas, -, -, control ambiental, , - diseño, -, organizativo, decorador, (fachada), , , , , . reaccionar, , --consumidor, , filtro, , -, -cmm (modelo madurez capacidades del personal), , perfiles operativos, , -, , , del cambio, () autoorientadas, tareas, personal orientado interacción, cots , , componentes , software , , embebidos , perspectiva dinámica (rup), (rup), (rup), , - picos, (modelo independiente plataforma), , gestión requerimientos, - proyectos, , - calendarización , -, dirigido por plan , - precio software , - ágiles , - , - estimación, - prueba, , , (), espiral , , , - , , , , -, , , planes contingencia (gestión del riesgo), proyecto, - plug-ins, , (probabilidad falla pedido), -, , , , () seguridad organizacional, seguridad, - pre/post-condiciones (procesos software), , mantenimiento, - mhc-pms , - , probabilidad falla pedido (pofod), -, “malvados” (que pueden definir por completo), , , - indice.indd - indice.indd // :: // :: pmíndice analítico procesamiento entrada por omisión, - proceso() auditables, -/check-out, /productor (buffer circular), cuarto limpio (cleanroom), , , , , , , , desarrollo genérico, , , desarrollo software unificado, , ingeniería servicio, -, software confiables, - confiables, unificado. véase rup procesos software, , - actividades, , , , , , , - , , (con base proceso), , , - características, , , -, , , , - ágil , , ciclo mejora, -, madurez, , (líneas producto software), estándares , , , , capacitación, estandarización , , , , , , - aseguramiento seguridad, - excepciones, , , -, proceso, , - enfoques , , mejoramiento procesos cmmi, -, metas , , ágiles , , modelos, -, , , segmentación proceso (process pipeline), , - proceso mejora, -, , procuración del sistema (adquisición del sistema), -, -, productividad del software, () medida, software genéricos, -, , , - , - procesos software, , - programación. véase también programación extrema -versión, , - pares, , - (), -, ciclo liberación , primera prueba , , , -, , requerimientos , , continua , , , , , , , ágiles , proyecto , -/prácticas, aceptación , del usuario , . lineamientos , - aspectos, - ego, personalismo, /actividades, , - real, propagación falla, () colectiva, , , sistema emergente, , -, emergentes, - proposiciones cambio, , -, - nivel aplicación, plataforma, , definición , arquitectónico , , - , - riesgos seguridad , -pms , - aseguramiento, - , , , prototipo mago , bootstrap, , () alfa, , , , , , , -, , , - indice.indd - indice.indd // :: // :: índice analítico prueba() (continúa) basadas experiencia, lineamientos, beta, , aceptación, , , - caja blanca, , caja negra, defecto, , , , , , , , entregas (release), - esfuerzo, , , interfaz, partición, - regresión, ruta, software, - aceptación, , , -, , , , , , , -, , , , , sistema, , -, , , , , , , , (debugging) versus, , -, -, , , -, - versus, - , ágiles , , , -, , usuario, - sistema, , -, , , , , , - psm (modelos específicos plataforma), , () corte (pointcuts), -, enlace, -, vista, , , , , falla, evitar, - python, , , , , , qos. véase calidad del servicior ramificación (branching), , ( requerimientos), , , , , rastreo problemas, gps, , , diseño para, -, , , , , , , , , , , , , redundancia diversidad , -, , triple (tmr), refactorización, , , , -, diseño, regulación contabilidad sarbanes-oxley, , software, reingeniería datos, , software, -, relaciones software interna/externa, diseño arquitectónico , , reparabilidad, , , , versión, del calendario, -, , , , - autenticación, autorización, detección intrusión, identificación, inmunidad, integridad, organización, - repudio, recuperación (requerimiento fiabilidad funcional), redundancia (requerimiento fiabilidad funcional), seguridad para mantenimiento sistema, software, , administración del cambio, -/análisis, , -, definición (fase ciclo vida), organización, , , - indice.indd - indice.indd // :: // :: pmíndice analítico desarrollo, descubrimiento, , - (especificación requerimientos software), -, duraderos, , -, , , , -, diseño, -, , -, , , , -, ágiles , (desarrollo basado reutilización), funcionales, , -, , negociación, (con base requerimientos), -, , , , , , , , , , , , , , -, , usuario, , , , sistema, , , , -, -, , , respeto (administración personal), ética/profesional, -, organizacionales (análisis procesos), reutilización nivel objetos, , generador, concepto, , - función, sistemas aplicación, software, , , , -, , , -, , - revisiones, , inspecciones , - comprobación (análisis peligros), proceso revisión, - riesgo(), . véase también riesgos específicos alarp (tan bajos como sea razonablemente práctico), análisis , -, , , -, , , - bitácora , - estimación, , herramientas, , proyecto, - personal, , eliminación , , , - requerimientos dirigida por, - etapa descomposición, , , , -, , , , , - , , , , , , , , , , , , , , - , requerimientos seguridad dirigidos por, - reducción , , , -, , , , , , - , - ritmo sostenible (), (característica proceso), , (tasa ocurrencia fallas), -, (procesos software), (llamadas procedimiento remoto), , . véase sistemas operativos tiempo realruby, , , (proceso racional unificado), -, saas. véase software como serviciosap, , , (ítem configuración software), , , , , -, , , , - amenazas , , -, propiedad emergente, , , , , , , , - indice.indd - indice.indd // :: // :: índice analítico seguridad (continúa) diseño arquitectónico , , - para, - especificación , -, del riesgo, , -, , - , - usabilidad, lista verificación, , - , -, , -, auditoría, terminología , , separación competencias, -(), , , , coordinación, , utilidad, , , -, , entidades, tareas, restful, , , , , , , , clasificación , , componentes reutilizables, - versus, - (mediante composición) , - , , , , , software , -, , restful , , , , , , , , , , , proceso empresarial , , - , , , simplicidad (métodos ágiles), , , , , , , () bancario, internet, web, - gnu, -servidor, -, , -, , - aseguramiento proceso , , , -, sistema , spark/ada , ágiles , , , , , , , protección, - desarrollo , riesgo para, - administración inventario, adquisición datos, , , , alta rapidez, , , , alarma contra robo, , , , , , , alta disponibilidad, , , , , aplicación comerciales. véase cots, sistemasde asignación recursos, arquitectura , banca por internet, comercio equitativo, control bomba insulina, - análisis árbol fallas para, - seguridad informal , - estructurados , - riesgo para, dosis insulina (con verificaciones seguridad) , clasificación riesgo para, - hardware (diagrama), procesamiento pedido , requerimiento estructurado , , especificación formal para, tabular , , afirmación seguridad para, actividad , , confiabilidad para, seguridad para, , control robot empacado, , control tráfico aéreo, , despacho vehículos, entretenimiento, equipajes, aeropuerto denver, frenado antibloqueo, gestión recursos, -, , , , , , , tráfico, - indice.indd - indice.indd // :: // :: pmíndice analítico información, , - automotriz, - pacientes. véase mhc-pmsdentro del auto, -, inventario equipo, planeación recursos empresariales. véase sistema() erp procesamiento lenguaje, , - transacciones, -, , , , lotes, , protección, - recolección datos, con base sensores, registros pacientes (prs), , , . véase mhc-pms software. véase también sistemas distribuidos complejo, - extensiones, - , -, - , , , -, -, , - software embebidos, , -, -. véase también sistemas tiempo real desarrollo anfitrión destino , arquitectónicos , - , , , tiempo real, -, análisis temporización , -, - , - , verificación controlador, , , , - conflictos, - arquitectónicos para, - cliente-servidor, -, , -, , , empresariales críticos, , , , , (planeación recursos empresariales), , , , , , , , , , heredados gestión , , -, servicio , -, (envoltura), , , , , tiempo real (rtos), -, - , skype, . véase arquitecturas orientadas serviciossoap, , , , , , , atributos , , , defectos, , servicio (saas), , - con, , , , , , , , , crítico para seguridad, , interna/externa, producto, -, -, soporte herramientas, , análisis proceso, sprint (scrum), , , (lenguaje consulta estructurado), , , , , , , srs (especificación requerimientos software), -, subsistemas, , , , , métricas chidamber kemerer (), - sumas verificación (checksums) código fuente, supervivencia, , - tablero control cambio ( ccb), , , tarjetas historia, , , , tarea, , tasa ocurrencia fallas (rocof), -, . véase desarrollo dirigido por pruebastécnicas basadas experiencia (técnicas estimación), estimación (planeación del proyecto), - algorítmico costos, , - cocomo , , , - basadas experiencia, - indice.indd - indice.indd // :: // :: índice analítico tejido (weaving) (aose), tipos personalidad, (redundancia modular triple), cambio, error, trabajo equipo, - código fuente, uml (lenguaje modelado unificado) definición , despliegue, , , arquitectónico , objetos con, - mensajes entrada/salida , estado , , , diagrama, , , uml ejecutable (xuml), (identificadores universales recurso), como propiedad emergente, , seguridad, , , utilidad make unix, & (verificación validación), , aose , - validación software, , , , , - aose , - , , espiral , requerimientos, , , -, versus, - valoración exposición (requerimientos seguridad), factibilidad (requerimientos seguridad), entorno, , enlaces arreglo, error característico, - requerimientos (requerimiento confiabilidad funcional), software aose , -, , , , , , , formales , - versus, - estática, , , , , , verificadores contraseña, modelo spin, virus, , , , , , arquitectónica, -,, , , , vista() arquitectónicas, -, , , . véase gestión versionesv-spec, evitar vulnerabilidad, -bpel, , , , , (lenguaje definición servicio web), , , , , , , , , , , , , , xml, mensaje (ejemplo), basados xml, procesamiento lenguaje , , , . véase programación extremaxuml (uml ejecutable), - indice.indd - indice.indd // :: // :: pmb badeau, ., , baier, ., , , . ., , , ., , , . ., , , , . ., , , ., , , , , , ., , , , , ., , , . ., , , ., , , . ., , , . ., , , , , . ., , , ., , , , , , ., , , ., , , ., , , ., , , , , , , , , , , , , , , , beedle, ., , , , , ., , , , ., , , . ., , , . ., , , , . ., , , , ., , , , , . ., , , , , ., , , ., , índice autores abbot, ., , , . ., , , ., , , , , , , ., , , . ., , , ., , , . ., , , , , ., , ., , , ., , , ., , , . ., , , , , ., , , . ., , ., , , , , , . ., , , ., , , ., , ., , , ., , , , ., , , ., , , ., , . ., , , . ., , , . . ., , ., , , . ., , . ., , , , ., - aut.indd - aut.indd // :: // :: índice autores birrer, ., , bishop, ., , , , , ., , , . ., , , . ., , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , booch, ., , , , , , , , ., , , , , ., , . ., , ., , , ., , , . ., , -hansen, ., , , . ., , , , , ., , , ., , , , , ., , , , , , ., , , , , cabrera, . ., , , ., , , , , ., , , ., , , ., , , ., , , . . ., , ., , , . ., , , , , . ., , , ., , ., , , ., , , ., , , , ., , , , , ., , , ., , , ., , , , . ., , , ., , , , , ., , ., , -sussman, ., , , ., , , , , ., , ., , ., , , ., , , , . ., , , ., , , . ., , , , , , ., , , ., , , ., , ., , , ., , , ., , ., , , , ., , , , , ., , , , dahl, . ., , , . ., , , . ., , , , , ., , , , , , ., , . ., , , . ., , , . ., , , , , , , , , ., , , . ., , , , ., , , . ., , ., , , ., , ., , , easterbrook, ., , , ., , ., -amam, ., , , ., , , , , , , ., , ., , , , , ., , - aut.indd - aut.indd // :: // :: pmíndice autores erl, ., , , , , erlikh, ., , , ., , fagan, . ., , , , , , . ., , , . ., , , ., , , . ., , ., , , . ., , , , . ., , , ., , ., , galin, ., , ., , , , , , , , , , ., , , ., , , , , , , , , ., , , ., , , . ., , ., , ., , , , . ., , , . ., , , ., , , . ., , , ., , , . ., , , , , ., , , ., , haase, ., , , ., , , , ., , , ., , , , , ., , , , ., , , , , . ., , , ., , ., , , , , , , ., , , . ., , , . ., , , . . ., , ., , , . ., , , , , , ., , , , , , , , , , ., , , ., , , . ., , , . ., , ., , . . ., , , , , ., , , , ., , . ., , , , , , , . ., , , ., , , , , . ., , ., , , . ., , , , , ., , , ., , , , , , , ., , , ., , , , , , ince, ., , jaatun, . ., , ., , , , , , , , , , , , , , , , jahanian, ., , , ., , , , , . ., , , ., , , - aut.indd - aut.indd // :: // :: índice autores jeffries, ., , , , , , , jenkins, ., , , , , . ., , ., , , , , , , , , johnson, . ., , , ., , , , , ., kafura, ., , , . ., , ., , , . -., , , ., , , ., , , ., , , ., , , ., , , , ., , , ., , , ., , , ., , , ., , , ., , , , , ., , , , ., , ., , , , , . ., , , , , ., , , , ., , , , , , , ., , , ., , , ., , , , , , , ., , , ., , lange, . . ., , , . -., , , ., , , , , , ., , , . ., , , . -., , , , , ., , , . ., , , ., , , , , . ., , , , , , , , . ., , , , , , , , , lewis, ., , . ., , . ., , , ., , , . ., , , ., , , , , . ., , , , , , , , ., , ., , , ., , , ., , , ., , , , ., , , . ., , , , , . ., , maciaszek, ., , . ., , , . ., , , ., , , , , ., , , . ., , , . ., , , ., , , , , , , , , ., , , . ., , , ., , , , ., , , ., , , , , . ., , , ., , , . ., , , , . ., , , . ., , . ., , , , , , , , , - aut.indd - aut.indd // :: // :: pmíndice autores melnik, ., , , meyer, ., , , ., , , ., , , , ., , , , ., , , . ., , . ., , , . ., , , . ., , , , , , , . ., , , ., , , ., , , ., , , , , ., , , ., , , . ., , , , ., , nakajo, ., , , ., , , . ., , , ., , , ., , , . -., , , , , , , ., , , . ., , , . ., , , ., , , , ’connell, ., , . ., , ’leary, . ., , , . ., , , . ., , , ., , , , ., , , , ., , ., , , , , , ., , , ., , , palmer, . ., , , ., , , . ., , , ., , , . ., , , , , , ., , , . ., , , ., , , . ., , , ., , , . ., , , , , , , , . ., , , , , , , , ., , , , , ., , ., , , , , ., , , , ., , , , , ., , , . ., , , , , ., , , ., , , . ., , , rajlich, ., , , , ., , , . ., , , ., , , , , , . ., , , ., , , , . ., , , ., , , ., , , ., , , ., , , ., , , , ., , , - aut.indd - aut.indd // :: // :: índice autores rogerson, ., , rombach, . ., , , , , , , ., , , ., , ., , . ., , , , , ., , , ., , ., , , , , , saiedian, ., , ., , , , ., , , , , , , ., , . ., , , , , , , , , , , , , , schneider, ., , , , , ., , , , , , ., , , ., , ., , , , , , , . ., , , ., , , . ., , ., , . ., , , ., , , , , , ., , , ., , , ., , ., , , ., , , ., , , ., , ., , , ., , , , , , , , , , , , , , sousa, . ., , , ., , , , , ., , . laurent, ., , , ., , , ., , , ., , , , ., , , ., , , , ., , , ., , , ., , , , , ., , , , , ., , , ., , , . ., , , . ., , , ., , , , tanenbaum, . ., , , , , , . ., , , , ., , , . ., , ., , , , -pomales, ., , , ., , , ., , , , ., , , , ulrich, . ., , , ., valeridi, ., steen, ., , , , ., , ., , , , , ., , , , ., , , ., , , , , , , , , , ., , , ., , - aut.indd - aut.indd // :: // :: pmíndice autores wang, ., , , , ward, ., , , ., , , , . ., , , . ., , , . ., , ., , , ., , , , . ., , ., , , ., , , , , . ., , , . ., , , ., , , . ., , , , , . ., , , , , , ., , , , , ., -brock, ., , , ., , , , , , ., , yacoub, ., , , ., , ., , zheng, ., , - aut.indd - aut.indd // :: // :: pmz- aut.indd - aut.indd // :: // ::