Uno de los aspectos más interesantes de las excepciones es que  definen un ámbito  en el programa. Al ejecutar código en la parte  try  de una instrucción try-catch-finally , indicamos que la ejecución se puede cancelar en cualquier momento y después retomar en  catch . Los bloques  try  son como las transacciones,  catch  debe salir del programa en un estado coherente, independientemente de lo que suceda en try . Por este motivo, es aconsejable iniciar con una instrucción  try-catch- finally  el código que genere excepciones. De este modo define lo que debe esperar el usuario del código, independientemente de que se produzca un error en el código ejecutado en la cláusula  try . Veamos un ejemplo. Imagine que tiene que crear un código que acceda a un archivo y lea objetos serializados. Comenzamos con una prueba de unidad que muestra que obtendremos una excepción cuando el archivo no exista: @Test(expected = StorageException.class) public void retrieveSectionShouldThrowOnInvalidFileName() { sectionStore.retrieveSection(“invalid - file”); } La prueba nos lleva a crear lo siguiente: public List<RecordedGrip> retrieveSection(String sectionName) { // se devuelve un resultado ficticio hasta tener una implementación real return new ArrayList<RecordedGrip>(); } Nuestra prueba falla ya que no genera una excepción. Tras ello, cambiamos la implementación para que intente acceder a un archivo no válido. Esta operación genera una excepción: public List<RecordedGrip> retrieveSection (String sectionName) { try { FileInputstream stream = new FileInputStream(sectionName) } catch (Exception e) { throw new StorageException(“retrieval error”, e); } return new ArrayList<RecordedGrip>(); } Ahora la prueba es correcta ya que capturamos la excepción y ya podemos refactorizar. Podemos reducir el tipo de la excepción capturada para que coincida con el tipo generado desde el constructor  FileInputStream: 149