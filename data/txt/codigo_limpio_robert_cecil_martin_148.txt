uno de los aspectos más interesantes de las excepciones es que definen un ámbito en el programa. al ejecutar código en la parte try de una instrucción try-catch-finally , indicamos que la ejecución se puede cancelar en cualquier momento y después retomar en catch . los bloques try son como las transacciones, catch debe salir del programa en un estado coherente, independientemente de lo que suceda en try . por este motivo, es aconsejable iniciar con una instrucción try-catch- finally el código que genere excepciones. de este modo define lo que debe esperar el usuario del código, independientemente de que se produzca un error en el código ejecutado en la cláusula try . veamos un ejemplo. imagine que tiene que crear un código que acceda a un archivo y lea objetos serializados. comenzamos con una prueba de unidad que muestra que obtendremos una excepción cuando el archivo no exista: @test(expected = storageexception.class) public void retrievesectionshouldthrowoninvalidfilename() { sectionstore.retrievesection(“invalid - file”); } la prueba nos lleva a crear lo siguiente: public list<recordedgrip> retrievesection(string sectionname) { // se devuelve un resultado ficticio hasta tener una implementación real return new arraylist<recordedgrip>(); } nuestra prueba falla ya que no genera una excepción. tras ello, cambiamos la implementación para que intente acceder a un archivo no válido. esta operación genera una excepción: public list<recordedgrip> retrievesection (string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname) } catch (exception e) { throw new storageexception(“retrieval error”, e); } return new arraylist<recordedgrip>(); } ahora la prueba es correcta ya que capturamos la excepción y ya podemos refactorizar. podemos reducir el tipo de la excepción capturada para que coincida con el tipo generado desde el constructor fileinputstream: 149