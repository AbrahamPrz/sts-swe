capítulo 10 diseño en el nivel de componentes 245 finidos que se utilizan en toda la aplicación), el acoplamiento común lleva a la propagación incontrolada del error y a efectos colaterales imprevistos cuando se hacen los cambios. acoplamiento del control. tiene lugar si la operación a( ) invoca a la operación b( ) y pasa una bandera de control a b. la bandera “dirige” entonces el flujo de la lógica dentro de b. el problema con esta forma de acoplamiento es que un cambio no relacionado en b puede dar como resultado la necesidad de cambiar el significado de la bandera de control que pasa a. si esto se pasa por alto ocurrirá un error. acoplamiento de molde. se presenta cuando se declara a claseb como un tipo para un argumento de una operación de clasea. como claseb ahora forma parte de la definición de clasea, la modificación del sistema se vuelve más compleja. acoplamiento de datos. ocurre si las operaciones pasan cadenas largas de argumentos de datos. el “ancho de banda” de la comunicación entre clases y componentes crece y la complejidad de la interfaz se incrementa. se hace más difícil hacer pruebas y dar manteni-miento. acoplamiento de rutina de llamada. tiene lugar cuando una operación invoca a otra. este nivel de acoplamiento es común y con frecuencia muy necesario. sin embargo, au-menta la conectividad del sistema. acoplamiento de tipo de uso. ocurre si el componente a usa un tipo de datos definidos en el componente b (esto ocurre siempre que “una clase declara una variable de instancia o una variable local como si tuviera otra clase para su tipo” [let01]). si cambia la definición de tipo, también debe cambiar todo componente que la utilice. acoplamiento de inclusión o importación. pasa cuando el componente a importa o in- cluye un paquete o el contenido del componente b. acoplamiento externo. sucede si un componente se comunica o colabora con compo-nentes de infraestructura (por ejemplo, funciones del sistema operativo, capacidad de la base de datos, funciones de telecomunicación, etc.). aunque este tipo de acoplamiento es necesario, debe limitarse a un número pequeño de componentes o clases dentro de un sis-tema. el software debe tener comunicación interna y externa. por tanto, el acoplamiento es un hecho de la vida. sin embargo, el diseñador debe trabajar para reducirlo siempre que sea posible, y entender las ramificaciones que tiene el acoplamiento abundante cuando no puede evitarse. la escena: cubículo de shakira. participantes: vinod y shakira, miembros del equipo de software de casasegura, que trabajan en la función de seguridad. la conversación:shakira: tuve lo que considero una gran idea… entonces lo pensé un poco y me pareció que no era tan buena. al final la deseché, pero pensé en hacerla para ustedes. vinod: seguro. ¿cuál es la idea?shakira: bueno, cada uno de los sensores reconoce una condición de alarma de algún tipo, ¿verdad?vinod (sonríe): por eso se llaman sensores, shakira. shakira (exasperada): sarcasmo, vinod, tienes que mejorar tus habilidades interpersonales. vinod: ¿decías?shakira: bien, de cualquier modo, me pregunté… por qué no crear una operación dentro de cada objeto de sensor llamada hacerllamada( ) que colaboraría directamente con el componente salellamada, bueno, con una interfaz hacia el componente salellamada. vinod (pensativo): quieres decir, ¿eso en vez de hacer que esa colaboración ocurra fuera de un componente como paneldecon-trol o algún otro?casasegura el acoplamiento en acción 10pressman(234-264).indd  24510pressman(234-264).indd  245 26/1/10  17:33:2026/1/10  17:33:20