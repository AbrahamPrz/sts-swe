CAPÍTULO 10  DISEÑO EN EL NIVEL DE COMPONENTES 245 finidos que se utilizan en toda la aplicación), el acoplamiento común lleva a la propagación  incontrolada del error y a efectos colaterales imprevistos cuando se hacen los cambios. Acoplamiento del control. Tiene lugar si la operación A( ) invoca a la operación B( ) y  pasa una bandera de control a B. La bandera “dirige” entonces el flujo de la lógica dentro  de B. El problema con esta forma de acoplamiento es que un cambio no relacionado en B  puede dar como resultado la necesidad de cambiar el significado de la bandera de control que pasa A. Si esto se pasa por alto ocurrirá un error. Acoplamiento de molde. Se presenta cuando se declara a ClaseB como un tipo para un  argumento de una operación de ClaseA. Como ClaseB ahora forma parte de la definición  de ClaseA, la modificación del sistema se vuelve más compleja. Acoplamiento de datos. Ocurre si las operaciones pasan cadenas largas de argumentos  de datos. El “ancho de banda” de la comunicación entre clases y componentes crece y la complejidad de la interfaz se incrementa. Se hace más difícil hacer pruebas y dar manteni-miento. Acoplamiento de rutina de llamada. Tiene lugar cuando una operación invoca a otra.  Este nivel de acoplamiento es común y con frecuencia muy necesario. Sin embargo, au-menta la conectividad del sistema. Acoplamiento de tipo de uso. Ocurre si el componente A usa un tipo de datos definidos  en el componente B (esto ocurre siempre que “una clase declara una variable de instancia o una variable local como si tuviera otra clase para su tipo” [Let01]). Si cambia la definición de tipo, también debe cambiar todo componente que la utilice. Acoplamiento de inclusión o importación. Pasa cuando el componente A importa o in- cluye un paquete o el contenido del componente B. Acoplamiento externo. Sucede si un componente se comunica o colabora con compo-nentes de infraestructura (por ejemplo, funciones del sistema operativo, capacidad de la base de datos, funciones de telecomunicación, etc.). Aunque este tipo de acoplamiento es necesario, debe limitarse a un número pequeño de componentes o clases dentro de un sis-tema. El software debe tener comunicación interna y externa. Por tanto, el acoplamiento es un hecho de la vida. Sin embargo, el diseñador debe trabajar para reducirlo siempre que sea posible, y entender las ramificaciones que tiene el acoplamiento abundante cuando no puede evitarse. La escena: Cubículo de Shakira. Participantes: Vinod y Shakira, miembros del  equipo de software de CasaSegura, que trabajan en la función de  seguridad. La conversación:Shakira: Tuve lo que considero una gran idea… entonces lo pensé  un poco y me pareció que no era tan buena. Al final la deseché, pero pensé en hacerla para ustedes. Vinod: Seguro. ¿Cuál es la idea?Shakira: Bueno, cada uno de los sensores reconoce una condición  de alarma de algún tipo, ¿verdad?Vinod (sonríe): Por eso se llaman sensores, Shakira. Shakira (exasperada): Sarcasmo, Vinod, tienes que mejorar tus  habilidades interpersonales. Vinod: ¿Decías?Shakira: Bien, de cualquier modo, me pregunté… por qué no  crear una operación dentro de cada objeto de sensor llamada HacerLlamada( ) que colaboraría directamente con el componente SaleLlamada, bueno, con una interfaz hacia el componente SaleLlamada. Vinod (pensativo): Quieres decir, ¿eso en vez de hacer que esa  colaboración ocurra fuera de un componente como PaneldeCon-trol o algún otro?CASASEGURA El acoplamiento en acción 10Pressman(234-264).indd   24510Pressman(234-264).indd   245 26/1/10   17:33:2026/1/10   17:33:20