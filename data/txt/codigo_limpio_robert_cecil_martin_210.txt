rutina  main  o un contenedor de propósito especial. Las búsquedas JNDI son una implementación parcial de la inyección de dependencias, en las que un objeto solicita a un servidor de directorios un servicio que coincida con un nombre concreto. MyService myService = (MyService)(jndiContext.lookup(“NameOfMyService”)); El objeto invocador no controla el tipo de objeto devuelto (siempre que implemente la interfaz correcta, evidentemente), pero es el que resuelve la dependencia de forma activa. La verdadera inyección de dependencias va un paso más allá. La clase no hace nada directamente para resolver sus dependencias, es totalmente pasiva. Por el contrario, ofrece métodos de establecimiento o argumentos de constructor (o ambos) que se usan para inyectar las dependencias. En el proceso de construcción, el contenedor de inyección de dependencias crea instancias de los objetos necesarios (normalmente bajo demanda) y usa los argumentos de constructor o métodos de establecimiento proporcionados para conectar las dependencias. Los objetos dependientes empleados suelen especificarse a través de un archivo de configuración o mediante programación en un módulo de construcción de propósito especial. La estructura Spring proporciona el contenedor de inyección de dependencias más conocido para Java [53] . Los objetos que se van a conectar se definen en un archivo de configuración XML y después se solicitan objetos concretos por nombre en código de Java. Veremos un ejemplo en breve. ¿Y qué sucede con las virtudes de la inicialización tardía? En ocasiones es útil con la inyección de dependencias. Por un lado, muchos contenedores de inyección de dependencias no crean un objeto hasta que es necesario. Por otra parte, muchos de estos contenedores cuentan con mecanismos para invocar factorías o crear  proxies  que se pueden usar para evaluación tardía y optimizaciones similares [54] . Evolucionar Las ciudades nacen de pueblos, que nacen de asentamientos. Inicialmente, los 211