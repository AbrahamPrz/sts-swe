CAPÍTULO 4  PRINCIPIOS QUE GUÍAN LA PRÁCTICA 85 cesidades de todos los participantes. Para lograrlo, debe adoptarse un conjunto de principios  fundamentales que guíen el trabajo técnico. Estos principios tienen mérito sin que importen los métodos de análisis y diseño que se apliquen, ni las técnicas de construcción (por ejemplo, el lenguaje de programación o las herramientas automatizadas) que se usen o el enfoque de veri-ficación y validación que se elija. Los siguientes principios fundamentales son vitales para la práctica de la ingeniería de software: Principio 1. Divide y vencerás.  Dicho en forma más técnica, el análisis y el diseño siem- pre deben enfatizar la separación de entidades (SdE). Un problema grande es más fácil de resolver si se divide en un conjunto de elementos (o entidades). Lo ideal es que cada enti- dad entregue funcionalidad distinta que pueda desarrollarse, y en ciertos casos validarse, independientemente de otras entidades. Principio 2. Entender el uso de la abstracción.  En su parte medular, una abstracción  es una simplificación de algún elemento complejo de un sistema usado para comunicar sig- nificado en una sola frase. Cuando se usa la abstracción hoja de cálculo, se supone que se  comprende lo que es una hoja de cálculo, la estructura general de contenido que presenta y las funciones comunes que se aplican a ella. En la práctica de la ingeniería de software, se usan muchos niveles diferentes de abstracción, cada uno de los cuales imparte o implica significado que debe comunicarse. En el trabajo de análisis y diseño, un equipo de software normalmente comienza con modelos que representan niveles elevados de abstracción (por ejemplo, una hoja de cálculo) y poco a poco los refina en niveles más bajos de abstracción (como una columna o la función SUM). Joel Spolsky [Spo02] sugiere que “todas las abstracciones no triviales hasta cierto punto  son esquivas”. El objetivo de una abstracción es eliminar la necesidad de comunicar deta-lles. Pero, en ocasiones, los efectos problemáticos precipitados por estos detalles se “fil-tran” por todas partes. Sin la comprensión de los detalles, no puede diagnosticarse con fa-cilidad la causa de un problema. Principio 3. Buscar la coherencia.  Ya sea que se esté creando un modelo de los reque- rimientos, se desarrolle un diseño de software, se genere código fuente o se elaboren casos de prueba, el principio de coherencia sugiere que un contexto familiar hace que el software sea más fácil de usar. Como ejemplo, considere el diseño de una interfaz de usuario para una webapp. La colocación consistente de opciones de menú, el uso de un esquema cohe-rencia de color y el uso coherencia de íconos reconocibles ayudan a hacer que la interfaz sea muy buena en el aspecto ergonómico. Principio 4. Centrarse en la transferencia de información.  El software tiene que ver  con la transferencia de información: de una base de datos a un usuario final, de un sistema  heredado a una webapp, de un usuario final a una interfaz gráfica de usuario (GUI, por sus siglas en inglés), de un sistema operativo a una aplicación, de un componente de software a otro… la lista es casi interminable. En todos los casos, la información fluye a través de una interfaz, y como consecuencia hay posibilidades de cometer errores, omisiones o am-bigüedades. Este principio implica que debe ponerse atención especial al análisis, diseño, construcción y prueba de las interfaces. Principio 5. Construir software que tenga modularidad eficaz.  La separación de enti- dades (principio 1) establece una filosofía para el software. La modularidad proporciona un  mecanismo para llevar a cabo dicha filosofía. Cualquier sistema complejo puede dividirse  en módulos (componentes), pero la buena práctica de la ingeniería de software demanda más. La modularidad debe ser eficaz. Es decir, cada módulo debe centrarse exclusivamente en un aspecto bien delimitado del sistema: debe ser cohesivo en su función o restringido en el contenido que representa. Además, los módulos deben estar interconectados en forma PUNTO CLAVE Los problemas son más fáciles de  resolver cuando se subdividen en entidades separadas, distintas entre sí, solucionables individualmente y verificables. 04Pressman(081-100).indd   8504Pressman(081-100).indd   85 26/1/10   17:31:5726/1/10   17:31:57