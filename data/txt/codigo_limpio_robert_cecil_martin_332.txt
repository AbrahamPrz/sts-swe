result = result + computeCommonSuffix(); return result; } … private String computeCommonSuffix() { int end = Math.min(expected.length() -  suffixLength  + contextLength, expected.length() ); return expected.substring(expected.length() -  suffixLength , end) + (expected.length() -  suffixLength  < expected.length() - contextLength ? ELLIPSIS : “”); } Cambiamos  +1  en computeCommonSuffix por un  -1  en charFromEnd, donde tiene sentido, y dos operadores  <=  en  suffixOverlapsPrefix , totalmente correctos. De este modo podemos cambiar el nombre de suffixIndex  por  suffixLength , lo que mejora considerablemente la legibilidad del código. Pero hay un problema. Al comenzar a eliminar los  +1 , me fijé en la siguiente línea de  compactstring : if (suffixLength > 0) Búsquela en el Listado 15-4. Como ahora  suffixLength  es una unidad menos que antes, debemos cambiar el operador  >  por  >= . Pero eso no tiene sentido. Ahora sí. Significa que no tenía sentido antes y que seguramente fuera un error. Bueno, no del todo. Tras un análisis detallado, vemos que ahora la instrucción  if  impide que se añada un sufijo de longitud cero. Antes de realizar el cambio, la instrucción  if  no funcionaba ya que  suffixIndex nunca podía ser menos de uno. Esto cuestiona ambas instrucciones  if  en  compactString . Parece como si se pudieran eliminar. Por ello, las comentamos y ejecutamos las pruebas. Satisfactorias. Reestructuremos  compactString  para eliminar las instrucciones  if  sobrantes y simplificar la función [G9]. private String compactString(String source) { return computeCommonPrefix() + DELTA_START + source.substring(prefixLength, source.length() - suffixLength) + 333