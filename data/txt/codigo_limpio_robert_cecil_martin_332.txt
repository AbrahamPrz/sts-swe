result = result + computecommonsuffix(); return result; } … private string computecommonsuffix() { int end = math.min(expected.length() - suffixlength + contextlength, expected.length() ); return expected.substring(expected.length() - suffixlength , end) + (expected.length() - suffixlength < expected.length() - contextlength ? ellipsis : “”); } cambiamos +1 en computecommonsuffix por un -1 en charfromend, donde tiene sentido, y dos operadores <= en suffixoverlapsprefix , totalmente correctos. de este modo podemos cambiar el nombre de suffixindex por suffixlength , lo que mejora considerablemente la legibilidad del código. pero hay un problema. al comenzar a eliminar los +1 , me fijé en la siguiente línea de compactstring : if (suffixlength > 0) búsquela en el listado 15-4. como ahora suffixlength es una unidad menos que antes, debemos cambiar el operador > por >= . pero eso no tiene sentido. ahora sí. significa que no tenía sentido antes y que seguramente fuera un error. bueno, no del todo. tras un análisis detallado, vemos que ahora la instrucción if impide que se añada un sufijo de longitud cero. antes de realizar el cambio, la instrucción if no funcionaba ya que suffixindex nunca podía ser menos de uno. esto cuestiona ambas instrucciones if en compactstring . parece como si se pudieran eliminar. por ello, las comentamos y ejecutamos las pruebas. satisfactorias. reestructuremos compactstring para eliminar las instrucciones if sobrantes y simplificar la función [g9]. private string compactstring(string source) { return computecommonprefix() + delta_start + source.substring(prefixlength, source.length() - suffixlength) + 333