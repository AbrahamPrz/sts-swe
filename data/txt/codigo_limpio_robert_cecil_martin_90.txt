en este caso el comentario sería redundante si cambiamos el nombre de la función por responderBeingTested. Veamos un ejemplo mejor: // el formato coincide con kk:mm:ss EEE, MMM dd, yyyy Pattern timeMatcher = Pattern.compile( “\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*”); En este caso, el comentario nos indica que la expresión regular debe coincidir con una fecha y una hora con el formato aplicado por la función SimpleDateFormat.format  con la cadena de formato especificada. Hubiera resultado mejor y más claro si el código se hubiera cambiado a una clase especial que convirtiera los formatos de fechas y horas. De ese modo el comentario habría sido superfluo. Explicar la intención En ocasiones, un comentario es algo más que información útil sobre la implementación y proporciona la intención de una decisión. En el siguiente caso, vemos una interesante decisión documentada por un comentario. Al comparar dos objetos, el autor decidió ordenar los objetos de su clase por encima de los objetos de otra. public int compareTo(Object o) { if (o instanceof WikiPagePath) { WikiPagePath p = (WikiPagePath) o; String compressedName = StringUtil.join(names, “”); String compressedArgumentName = StringUtil.join(p.names, “”); return compressedName.compareTo(compressedArgumentName); } return 1;  // somos mayores porque somos el tipo correcto. } Veamos otro ejemplo mejor. Puede que no esté de acuerdo con la solución del programador, pero al menos sabe lo que intentaba hacer. public void testConcurrentAddWidgets() throws Exception { WidgetBuilder widgetBuilder = new WidgetBuilder(new Class[](BoldWidget.class)); String text = “‘‘‘bold text’’’”; ParentWidget parent = new BoldWidget(new MockWidgetRoot(), “‘‘‘bold text’’’”); AtomicBoolean failFlag = new AtomicBoolean(); failFlag.set(false); 91