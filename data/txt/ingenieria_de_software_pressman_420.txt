CAPÍTULO 17  ESTRATEGIAS DE PRUEBA DE SOFTWARE 389 Construyen software “robusto” que esté diseñado para probarse a sí mismo.  El software debe  diseñarse en forma que use técnicas antierrores (sección 17.3.1), es decir, el software debe   poder diagnosticar ciertas clases de errores. Además, el diseño debe incluir pruebas automati-zadas y pruebas de regresión. Usan revisiones técnicas efectivas como filtro previo a las pruebas. Las revisiones técnicas (ca- pítulo 15) pueden ser tan efectivas como probar para descubrir errores. Por esta razón, las re-visiones pueden reducir la cantidad del esfuerzo de pruebas que se requieren para producir software de alta calidad. Realizan revisiones técnicas para valorar la estrategia de prueba y los casos de prueba. Las re- visiones de prueba pueden descubrir inconsistencias, omisiones y errores evidentes en el abordaje de las pruebas. Esto ahorra tiempo y también mejora la calidad del producto. Desarrollan un enfoque de mejora continuo para el proceso de prueba.  La estrategia de prue- bas debe medirse. Las métricas recopiladas durante las pruebas deben usarse como parte de un enfoque de control de proceso estadístico para la prueba del software.  17.3 E STRATEGIAS  DE PRUEBA  PARA  SOFTWARE  CONVENCIONAL2 Existen muchas estrategias que pueden usarse para probar el software. En un extremo, puede esperarse hasta que el sistema esté completamente construido y luego realizar las pruebas sobre el sistema total, con la esperanza de encontrar errores. Este enfoque, aunque atractivo, simple-mente no funciona. Dará como resultado software defectuoso que desilusionará a todos los par-ticipantes. En el otro extremo, podrían realizarse pruebas diariamente, siempre que se construya alguna parte del sistema. Este enfoque, aunque menos atractivo para muchos, puede ser muy efectivo. Por desgracia, algunos desarrolladores de software son reacios a usarlo. ¿Qué hacer? Una estrategia de prueba que eligen la mayoría de los equipos de software se coloca entre  los dos extremos. Toma una visión incremental de las pruebas, comenzando con la de unidades de programa individuales, avanza hacia pruebas diseñadas para facilitar la integración de las unidades y culmina con pruebas que ejercitan el sistema construido. Cada una de estas clases de pruebas se describe en las secciones que siguen. 17.3.1  Prueba de unidad La prueba de unidad enfoca los esfuerzos de verificación en la unidad más pequeña del diseño  de software: el componente o módulo de software. Al usar la descripción del diseño de compo-nente como guía, las rutas de control importantes se prueban para descubrir errores dentro de la frontera del módulo. La relativa complejidad de las pruebas y los errores que descubren están limitados por el ámbito restringido que se establece para la prueba de unidad. Las pruebas de unidad se enfocan en la lógica de procesamiento interno y de las estructuras de datos dentro de las fronteras de un componente. Este tipo de pruebas puede realizarse en paralelo para múl-tiples componentes. Consideraciones de las pruebas de unidad.  Las pruebas de unidad se ilustran de manera  esquemática en la figura 17.3. La interfaz del módulo se prueba para garantizar que la informa- ción fluya de manera adecuada hacia y desde la unidad de software que se está probando. Las estructuras de datos locales se examinan para asegurar que los datos almacenados temporal-Cita: “Probar sólo los requerimien- tos del usuario final es como inspeccionar un edificio con base en el trabajo realizado por el decorador de interiores a costa de cimientos, vigas y plomería.” Boris Beizer 2 A lo largo de este libro, se usan los términos software convencional o software tradicional para referirse a arqui- tecturas de software jerárquica común, o de “llamar y regresar”, que con frecuencia se encuentran en una varie- dad de dominios de aplicación. Las arquitecturas de software tradicional no son orientadas a objetos y no abarcan  webapps.No es mala idea diseñar casos de  prueba de unidad antes de desarrollar el código para un componente. Eso ayuda a garantizar que se desarrollará un código que pasará las pruebas.CONSEJO 17Pressman(383-410).indd   38917Pressman(383-410).indd   389 21/1/10   10:59:2021/1/10   10:59:20