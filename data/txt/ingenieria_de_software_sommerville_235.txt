218  Capítulo 8 ■ Pruebas de software porque el productor de la información no actualizó la información de la interfaz  compartida.  Las pruebas por defectos de interfaz son difíciles porque algunas fallas de interfaz sólo pueden manifestarse ante condiciones inusuales. Por ejemplo, se dice que un objeto implementa una cola como una estructura de datos de longitud fija. Un objeto que llama puede suponer que la cola se implementó como una estructura de datos infinita y no verificaría el desbordamiento de la cola, cuando se ingresa un ítem. Esta condición sólo se logra detectar durante las pruebas, al diseñar casos de prueba que fuercen el desbor-damiento de la cola, y causen que el desbordamiento corrompa el comportamiento del objeto en cierta forma detectable. Un problema posterior podría surgir derivado de interacciones entre fallas en dife-rentes módulos u objetos. Las fallas en un objeto sólo se detectan cuando algún otro objeto se comporta de una forma inesperada. Por ejemplo, un objeto llama a otro objeto para recibir algún servicio y supone que es correcta la respuesta; si el servicio de lla-mada es deficiente en algún modo, el valor devuelto puede ser válido pero equivocado. Esto no se detecta de inmediato, sino sólo se vuelve evidente cuando algún cálculo posterior sale mal. Algunos lineamientos generales para las pruebas de interfaz son: 1. Examinar el código que se va a probar y listar explícitamente cada llamado a un  componente externo. Diseñe un conjunto de pruebas donde los valores de los pará-metros hacia los componentes externos estén en los extremos finales de sus ran-gos. Dichos valores extremos tienen más probabilidad de revelar inconsistencias de interfaz. 2. Donde los punteros pasen a través de una interfaz, pruebe siempre la interfaz con parámetros de puntero nulo. 3. Donde un componente se llame a través de una interfaz de procedimiento, diseñe pruebas que deliberadamente hagan que falle el componente. Diferir las suposi-ciones de falla es una de las interpretaciones de especificación equivocadas más comunes. 4. Use pruebas de esfuerzo en los sistemas que pasan mensajes. Esto significa que debe diseñar pruebas que generen muchos más mensajes de los que probablemente ocurran en la práctica. Ésta es una forma efectiva de revelar problemas de tempori-zación. 5. Donde algunos componentes interactúen a través de memoria compartida, diseñe pruebas que varíen el orden en que se activan estos componentes. Tales pruebas pueden revelar suposiciones implícitas hechas por el programador, sobre el orden en que se producen y consumen los datos compartidos.  En ocasiones, las inspecciones y revisiones suelen ser más efectivas en costo que las pruebas para descubrir errores de interfaz. Las inspecciones pueden concentrarse en interfaces de componente e interrogantes sobre el comportamiento supuesto de la inter-faz planteada durante el proceso de inspección. Un lenguaje robusto como Java permite que muchos errores de interfaz sean descubiertos por el compilador. Los analizadores estáticos (capítulo 15) son capaces de detectar un amplio rango de errores de interfaz. M08_SOMMERVILLE_INGENIERIA_1ED_SE_205-233.indd   218M08_SOMMERVILLE_INGENIERIA_1ED_SE_205-233.indd   218 3/18/11   5:39:59 PM3/18/11   5:39:59 PM