66 67 /** 68 * Clase abstracta que define nuestros requisitos para manipular fechas, 68 * sin limitación a una determinada implementación. 70 * <P> 71 * Requisito 1: coincidir al menos con el procesamiento de fechas en Excel; 72 * Requisito 2: la clase es inmutable; 73 * <P> 74 * ¿Por qué no usar java.util.Date? Lo haremos, cuando tenga sentido. En ocasiones, 75 * java.util.Date puede ser demasiado precisa; representa un instante en el tiempo, 76 * con una precisión de 1/1000 de segundo (y la fecha depende de la 77 * zona horaria). En ocasiones sólo querremos representar un día concreto (como el 21 78 * de enero de 2015) sin preocuparnos de la hora del día, la 79 * zona horaria u otros aspectos. Para eso hemos definido DayDate. 80 * <P> 81 * Puede invocar getInstance() para obtener una subclase concreta de SerialDate, 82 * sin preocuparse de su implementación exacta 83 * 84 * @author David Gilbert 85 */ 86 public abstract class SerialDate implements Comparable, 87 Serializable, 88 MonthConstants { 89 90 /** Para serialización. */ 91 private static final long serialVersionUID = -293716040467423637L; 92 93 /** Símbolos de formato de fecha. */ 94 public static final DateFormatSymbols 95 DATE_FORMAT_SYMBOLS = new SimpleDateFormat().getDateFormatSymbols(); 96 97 /** Número de serie para el 1 de enero de 1900. */ 98 public static final int SERIAL_LOWER_BOUND = 2; 99 100 /** Número de serie para el 31 de diciembre de 9999. */ 101 public static final int SERIAL_UPPER_BOUND = 2958465; 102 103 /** Valor de año más bajo admitido por este formato de fecha. */ 104 public static final int MINIMUM_YEAR_SUPPORTED = 1900; 105 106 /** Valor de año más alto admitido por este formato de fecha. */ 440