66 67 /** 68 * clase abstracta que define nuestros requisitos para manipular fechas, 68 * sin limitación a una determinada implementación. 70 * <p> 71 * requisito 1: coincidir al menos con el procesamiento de fechas en excel; 72 * requisito 2: la clase es inmutable; 73 * <p> 74 * ¿por qué no usar java.util.date? lo haremos, cuando tenga sentido. en ocasiones, 75 * java.util.date puede ser demasiado precisa; representa un instante en el tiempo, 76 * con una precisión de 1/1000 de segundo (y la fecha depende de la 77 * zona horaria). en ocasiones sólo querremos representar un día concreto (como el 21 78 * de enero de 2015) sin preocuparnos de la hora del día, la 79 * zona horaria u otros aspectos. para eso hemos definido daydate. 80 * <p> 81 * puede invocar getinstance() para obtener una subclase concreta de serialdate, 82 * sin preocuparse de su implementación exacta 83 * 84 * @author david gilbert 85 */ 86 public abstract class serialdate implements comparable, 87 serializable, 88 monthconstants { 89 90 /** para serialización. */ 91 private static final long serialversionuid = -293716040467423637l; 92 93 /** símbolos de formato de fecha. */ 94 public static final dateformatsymbols 95 date_format_symbols = new simpledateformat().getdateformatsymbols(); 96 97 /** número de serie para el 1 de enero de 1900. */ 98 public static final int serial_lower_bound = 2; 99 100 /** número de serie para el 31 de diciembre de 9999. */ 101 public static final int serial_upper_bound = 2958465; 102 103 /** valor de año más bajo admitido por este formato de fecha. */ 104 public static final int minimum_year_supported = 1900; 105 106 /** valor de año más alto admitido por este formato de fecha. */ 440