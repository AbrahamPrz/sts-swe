capítulo 21 modelado y verificación formal 491 un conjunto llamado blocks (bloques) consistirá de todo número de bloques. allblocks (to- dos los bloques) es un conjunto de bloques que se encuentra entre 1 y maxblocks (máximo de bloques). el estado se modelará mediante dos conjuntos y una secuencia. los dos conjuntos son used (utilizado) y free (libre). ambos contienen bloques: el conjunto used contiene los que ac- tualmente se usan en los archivos y el conjunto free los que están disponibles para nuevos archivos. la secuencia contendrá conjuntos de bloques que están listos para ser liberados de los archivos que se borraron. el estado puede describirse como used, free: /h11936 blocksblockqueue: seq /h11936 blocks esto es muy parecido a la declaración de las variables de programa. se afirma que used y free serán conjuntos de bloques y que blockqueu (fila de bloques) será una secuencia, cada elemento de la cual será un conjunto de bloques. la invariante de datos puede escribirse como used /h20669 free /h11005 ∅ /h11625used /h20668 free /h11005 allblocks /h11625/h7001 i: dom blockqueue • blockqueue i /h20661 used /h11625/h7001 i, j: dom blockqueue • i /hs11005 j /h11005 blockqueue i /h20669 blockqueue j /h11005 ∅ los componentes matemáticos de la invariante de datos coinciden con cuatro de las caracterís-ticas de los componentes de lenguaje natural descritos anteriormente. la primera línea de la in variante de datos afirma que no habrá bloques comunes en la colección utilizada y en las colecciones libres de bloques. la segunda afirma que la colección de bloques utilizados y de bloques libres siempre será igual a la colección completa de bloques en el sistema. la tercera línea indica que el i-ésimo elemento en la fila de bloques siempre será un subconjunto de los bloques utilizados. la línea final afirma que, para cualesquiera dos elementos de la fila de blo-ques que no son el mismo, no habrá bloques comunes en dichos elementos. los dos compo-nentes de lenguaje natural finales de la invariante de datos se implementan en virtud del hecho de que used y free son conjuntos y, por tanto, no contendrán duplicados. la primera operación por definir es aquella que remueve un elemento de la cabeza de la fila de bloques. la precondición es que debe haber al menos un ítem en la fila: #blockqueue /h11022 0, la poscondición es que la cabeza de la fila debe removerse y colocarse en la colección de blo-ques libres y la fila debe ajustarse para mostrar la remoción: used′ /h11005 used \ head blockqueue /h11625free′ /h11005 free /h20668 head blockqueue /h11625blockqueue′ /h11005 tail blockqueue una convención que se usa en muchos métodos formales es que el valor de una variable des-pués de una operación es prima. en consecuencia, el primer componente de la expresión pre-cedente afirma que los nuevos bloques usados ( used’) serán iguales a los antiguos bloques usados menos los bloques que se removieron. el segundo componente señala que los nuevos bloques libres (free’) serán los antiguos bloques libres, con el agregado de la cabeza de la fila de bloques. el tercer componente afirma que la nueva fila de bloques será igual a la fila del valor antiguo de la fila de bloques, es decir, todos los elementos en la fila menos el primero. una segunda operación agrega una colección de bloques, ablocks, a la fila de bloques. la precondi-ción es que ablocks es en la actualidad un conjunto de bloques utilizados: ablocks /h20661 used la poscondición es que el conjunto de bloques se agrega al final de la fila de bloques y el con-junto de bloques usados y libres permanece invariable:¿cómo pueden representarse estados e invariantes de datos usando un conjunto y operadores lógicos?? ¿cómo se representan las precondiciones y las poscondiciones??webref amplia información de los métodos formales se puede encontrar en www.afm.sbu .ac.uk. 21pressman(478-500).indd  49121pressman(478-500).indd  491 19/1/10  12:43:2719/1/10  12:43:27