190  Capítulo 7 ■ Diseño e implementación considerarla como un descripción de sabiduría y experiencia acumuladas, una solución  bien probada a un problema común. Una cita del sitio Web de Hillside Group (http://hillside.net), que se dedica a mante-ner información acerca de patrones, resume su papel en la reutilización: Los patrones y los lenguajes de patrón son formas de describir mejores prácticas, buenos diseños, y captan la experiencia de tal manera que es posible que otros reutilicen esta experiencia.  Los patrones causaron un enorme impacto en el diseño de software orientado a obje-tos. Como son soluciones probadas a problemas comunes, se convirtieron en un vocabula-rio para hablar sobre un diseño. Por lo tanto, usted puede explicar su diseño al describir los patrones que utilizó. Esto es en particular verdadero para los patrones de diseño más cono-cidos que originalmente describió la “Banda de los cuatro” en su libro de patrones (Gamma et al., 1995). Otras descripciones de patrón en especial importantes son las publicadas en una serie de libros por autores de Siemens, una gran compañía tecnológica europea (Buschmann et al., 1996; Buschmann et al., 2007a; Buschmann et al., 2007b; Kircher y  Jain, 2004; Schmidt et al., 2000). Los patrones de diseño se asocian usualmente con el diseño orientado a objetos. Los patrones publicados se suelen apoyar en características de objetos como herencia y polimorfismo para dar generalidad. Sin embargo, el principio universal de encapsular Nombre del patrón: Observer Descripción: Separa el despliegue del estado de un objeto del objeto en sí y permite el ofrecimiento  de despliegues alternativos. Cuando cambia el estado del objeto, todos los despliegues se notifican automáticamente y se actualizan para reflejar el cambio. Descripción del problema: En muchas situaciones hay que proporcionar múltiples despliegues de información  del estado, tales como un despliegue gráfico y un despliegue tabular. Tal vez no se conozcan todos éstos cuando se especifica la información. Todas las presentaciones alternativas deben soportar la interacción y, cuando cambia el estado, los despliegues en su totalidad deben actualizarse. Este patrón puede usarse en todas las situaciones en que se requiera más de un formato de despliegue para  información del estado y donde no es necesario que el objeto mantenga la información del estado para conocer sobre los formatos específicos de despliegue utilizados. Descripción de la solución: Esto implica dos objetos abstractos, Subject y Observer, y dos objetos concretos,  ConcreteSubject (sujeto concreto) y ConcreteObject (objeto concreto), que heredan los atributos de los objetos abstractos relacionados. Los objetos abstractos contienen operaciones generales que son aplicables en todas las situaciones. El estado a desplegar se mantiene en ConcreteSubject, que hereda operaciones de Subject y le permite agregar y remover Observers (cada observador corresponde a un despliegue) y emite una notificación cuando cambia el estado. ConcreteObserver (observador concreto) mantiene una copia del estado de ConcreteSubject e implementa  la interfaz Update() de Observer que permite que dichas copias se conserven al paso. ConcreteObserver automáticamente despliega el estado y refleja los cambios siempre que se actualice el estado.El modelo UML del patrón se ilustra en la figura 7.12. Consecuencias: El sujeto sólo conoce al Observer abstracto y no los detalles de la clase concreta. Por lo tanto,  existe un acoplamiento mínimo entre dichos objetos. Debido a esta falta de conocimiento, son imprácticas las optimizaciones que mejoran el rendimiento del despliegue. Los cambios al sujeto podrían generar un conjunto de actualizaciones vinculadas a observadores, de las cuales algunas quizá no sean necesarias. Figura 7.10 El patrón Observer (observador) M07_SOMMERVILLE_INGENIERIA_1ED_SE_176-204.indd   190M07_SOMMERVILLE_INGENIERIA_1ED_SE_176-204.indd   190 3/18/11   4:50:13 PM3/18/11   4:50:13 PM