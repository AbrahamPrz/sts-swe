caminos son estrechos y prácticamente inexistentes, después se asfaltan y aumentan de tamaño. los pequeños edificios y solares vacíos se llenan de otros mayores que acaban convirtiéndose en rascacielos. al principio no hay servicios, electricidad, agua, alcantarillado o internet (¡vaya!). estos servicios se añaden cuando aumenta la densidad de población. este crecimiento no es fácil. cuántas veces mientras conduce por una carretera llena de baches y ve una señal de obras no se ha preguntado por qué no la hicieron más ancha desde un principio. no se podía haber hecho de otra forma. ¿quién puede justificar el gasto en una autopista de seis carriles que atraviese un pequeño pueblo como anticipación a un supuesto crecimiento? ¿quién querría una autopista así en su ciudad? conseguir sistemas perfectos a la primera es un mito. por el contrario, debemos implementar hoy, y refactorizar y ampliar mañana. es la esencia de la agilidad iterativa e incremental. el desarrollo controlado por pruebas, la refactorización y el código limpio que generan hace que funcione a nivel del código. ¿pero qué sucede en el nivel del sistema? ¿la arquitectura del sistema no requiere una planificación previa? sin duda no puede aumentar incrementalmente algo sencillo a algo complejo, ¿o sí? los sistemas de software son únicos si los comparamos con los sistemas físicos. sus arquitecturas pueden crecer incrementalmente, si mantenemos la correcta separación de los aspectos. la naturaleza efímera de los sistemas de software hace que sea posible, como veremos. primero nos centraremos en una arquitectura que no separa correctamente los aspectos. las arquitecturas ejb1 y ejb2 originales no separaban correctamente los aspectos y por tanto imponían barreras innecesarias al crecimiento orgánico. imagine un bean de entidad para una clase bank persistente. un bean de entidad es una representación en memoria de datos relacionales, es decir, una fila de una tabla. primero, debe definir una interfaz local (en proceso) o remota (mvj 212