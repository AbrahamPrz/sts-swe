métodos polimórficos, sólo una lista de matrices (o eso parece). el problema no es la simplicidad del código sino su carácter implícito : el grado en el que el contexto no es explícito en el propio código. implícitamente, el código requiere que sepamos las respuestas a las siguientes preguntas: ¿qué contiene thelist ? ¿qué significado tiene el subíndice cero de un elemento de thelist ? ¿qué importancia tiene el valor 4 ? ¿cómo se usa la lista devuelta? las respuestas a estas preguntas no se encuentran en el código, pero se podrían haber incluido. imagine que trabaja en un juego de buscar minas. el tablero es una lista de celdas llamada thelist . cambiemos el nombre por gameboard . cada celda del teclado se representa por medio de una matriz. el subíndice cero es la ubicación de un valor de estado que, cuando es 4 , significa que se ha detectado. al asignar nombres a estos conceptos mejoramos considerablemente el código: public list<int[]> getflaggedcells() { list<int[]> flaggedcells = new arraylist<int[]>(); for (int[] cell : gameboard) if (cell[status_value] == flagged) flaggedcells.add(cell); return flaggedcells; } la simplicidad del código no ha cambiado. sigue teniendo los mismos operadores y constantes y el mismo número de niveles anidados, pero ahora es mucho más explícito. podemos crear una sencilla clase para celdas en lugar de usar una matriz de elementos int . puede incluir una función que revele el objetivo (con el nombre isflagged ) para ocultar los números. el resultado es una nueva versión de la función: public list<cell> getflaggedcells() { list<cell> flaggedcells = new arraylist<cell>(); for (cell cell : gameboard) if (cell.isflagged()) flaggedcells.add(cell); 43