métodos polimórficos, sólo una lista de matrices (o eso parece). El problema no es la simplicidad del código sino su carácter  implícito : el grado en el que el contexto no es explícito en el propio código. Implícitamente, el código requiere que sepamos las respuestas a las siguientes preguntas: ¿Qué contiene  theList ? ¿Qué significado tiene el subíndice cero de un elemento de  theList ? ¿Qué importancia tiene el valor  4 ? ¿Cómo se usa la lista devuelta? Las respuestas a estas preguntas no se encuentran en el código, pero se podrían haber incluido. Imagine que trabaja en un juego de buscar minas. El tablero es una lista de celdas llamada  theList . Cambiemos el nombre por gameBoard . Cada celda del teclado se representa por medio de una matriz. El subíndice cero es la ubicación de un valor de estado que, cuando es  4 , significa que se ha detectado. Al asignar nombres a estos conceptos mejoramos considerablemente el código: public List<int[]> getFlaggedCells() { List<int[]> flaggedCells = new ArrayList<int[]>(); for (int[] cell : gameBoard) if (cell[STATUS_VALUE] == FLAGGED) flaggedCells.add(cell); return flaggedCells; } La simplicidad del código no ha cambiado. Sigue teniendo los mismos operadores y constantes y el mismo número de niveles anidados, pero ahora es mucho más explícito. Podemos crear una sencilla clase para celdas en lugar de usar una matriz de elementos  int . Puede incluir una función que revele el objetivo (con el nombre  isFlagged ) para ocultar los números. El resultado es una nueva versión de la función: public List<Cell> getFlaggedCells() { List<Cell> flaggedCells = new ArrayList<Cell>(); for (Cell cell : gameBoard) if (cell.isFlagged()) flaggedCells.add(cell); 43