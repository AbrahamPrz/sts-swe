embargo, el entorno de pruebas es improbable que lo esté. Es la naturaleza del estándar dual. Hay cosas que nunca haría en un entorno de producción totalmente válidas para un entorno de prueba. Suelen ser problemas de memoria o eficacia de la CPU, pero nunca problemas de limpieza. Una afirmación por prueba Existe una escuela de pensamiento [40]  que afirma que todas las funciones de prueba de una prueba JUnit sólo deben tener una instrucción de afirmación. Puede parecer una regla draconiana pero la ventaja se aprecia en el Listado 9- 5. Las pruebas llegan a una misma conclusión, que se entiende de forma rápida y sencilla. ¿Pero qué sucede con el Listado 9-2? No parece razonable afirmar que el resultado es XML y que contiene determinadas subcadenas. Sin embargo, podemos dividir la prueba en dos, cada una con una afirmación concreta, como se muestra en el Listado 9-7. Listado 9-7 SerializedPageResponderTest.java (una sola afirmación). public void testGetPageHierarchyAsXml() throws Exception { givenPages(“PageOne”, “PageOne.ChildOne”, “PageTwo”); whenRequestIsIssued(“root”, “type:pages”); thenResponseShouldBeXML(); } public void testGetPageHierarchyHasRightTags() throws Exception { givenPages(“PageOne”, “PageOne.ChildOne”, “PageTwo”); whenRequestIsIssued(“root”, “type:pages”); thenResponseShouldContain( “<name>PageOne</name>”, “<name>PageTwo</name>”, “<name>ChildOne</name>” ); } He cambiado los nombres de las funciones para usar la convención  dado- cuando-entonces [41] . De este modo las pruebas son más fáciles de leer. Desafortunadamente, al dividir las pruebas se genera código duplicado. 180