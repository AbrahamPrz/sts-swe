una cadena que no se puede analizar a un argumento  ##. public void testInvalidDouble() throws Exception { Args args = new Args(“x##”, new String[] {“-x”, “Forty two”}); assertFalse(args.isValid()); assertEquals(0, args.cardinality()); assertFalse(args.has(‘x’)); assertEquals(0, args.getInt(‘x’)); assertEquals(“Argument -x expects a double but was ‘Forty two’.”, args.errorMessage()); } --- public String errorMessage() throws Exception { switch (errorCode) { case OK: throw new Exception(“TILT: Should not get here.”); case UNEXPECTED_ARGUMENT: return unexpectedArgumentMessage(); case MISSING_STRING: return String.format(“Could not find string parameter for -%c.”, errorArgumentId); case INVALID_INTEGER: return String.format(“Argument -%c expects an integer but was ‘%s’.”, errorArgumentId, errorParameter); case MISSING_INTEGER: return String.format(“Could not find integer parameter for -%c.”, errorArgumentId); case INVALID_DOUBLE: return String.format(“Argument -%c expects a double but was ‘%s’.”, errorArgumentId, errorParameter); case MISSING_DOUBLE: return String.format(“Could not find double parameter for -%c”, errorArgumentId); } return “”; } Y las pruebas son satisfactorias. La siguiente prueba garantiza que se detecte correctamente la ausencia de un argumento  double . public void testMissingDouble() throws Exception { Args args = new Args(“x##”, new String[]{"-x"}); assertFalse (args.isValid()); assertEquals(0, args.cardinality()); assertFalse(args.has(‘x’)); assertEquals(0.0, args.getDouble(‘x’), 0.01); assertEquals(“Could not find double parameter for -x.”, args.errorMessage()); } Es correcto. La incluimos para que el ejemplo resulte más completo. El código de excepciones no es atractivo y no pertenece realmente a la 306