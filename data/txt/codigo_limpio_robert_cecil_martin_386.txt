Los argumentos de línea de comandos se analizan en la primera línea ejecutable de FitNesse. Los valores predeterminados de dichos argumentos se especifican al inicio de la clase  Argument . No tiene que buscar instrucciones como la siguiente en los niveles inferiores del sistema: if (arguments.port == 0) // usar 80 de forma predeterminada Las constantes de configuración se encuentran en un nivel superior y son fáciles de cambiar. Se pasan al resto de la aplicación. Los niveles inferiores de la aplicación no poseen los valores de estas constantes. G36: Evitar desplazamientos transitivos Por lo general, no es recomendable que un módulo sepa demasiado sobre sus colaboradores. En concreto, si A colabora con  B y B  con C, no queremos que los módulos que usan A sepan nada sobre C (por ejemplo, o queremos a.getB().getC().doSomething(); ). Es lo que en ocasiones se denomina Ley de Demeter. Los programadores pragmáticos lo denominan  Crear código silencioso [115] . En cualquier caso, se trata de garantizar que los módulos sólo tienen conocimiento de sus colaboradores inmediatos y no del mapa de navegación completo del sistema. Si varios módulos usan alguna variante de la instrucción  a.getB().getC() , sería complicado cambiar el diseño y la arquitectura para intercalar Q entre  B y C.  Tendría que localizar todas las instancias de  a.getB().getC()  y convertirlas a  a.getB().getQ().getC() . Es la forma en que las arquitecturas se vuelven rígidas. Demasiados módulos saben demasiado sobre la arquitectura. Por el contrario, queremos que nuestros colaboradores intermedios ofrezcan todos los servicios que necesitamos. No debemos deambular por el gráfico de objetos del sistema en busca del método que necesitamos invocar. Bastaría con poder usar: myCollaborator.doSomething(). Java 387