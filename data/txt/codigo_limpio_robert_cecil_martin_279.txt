stringValue = s; } public String getString() { return stringValue == null ? “” : stringValue; } } De nuevo, estos cambios se realizaron individualmente para conservar las pruebas, aunque fallaran. Si una prueba fallaba, me aseguraba de que fuera correcta antes de continuar con el siguiente cambio. Ya debería reconocer mi intención. Tras incluir el comportamiento de señalización en la clase base  ArgumentMarshaler , comencé a transferirlo a las variantes, para de esta forma mantener el funcionamiento mientras cambiaba gradualmente la forma del programa. El siguiente paso consistía en transferir la funcionalidad del argumento int  a  ArgumentMarshaler . De nuevo, no hubo sorpresas. private Map<Character,  ArgumentMarshaler > intArgs = new HashMap<Character,  ArgumentMarshaler >(); … private void parseIntegerSchemaElement(char elementId) { intArgs.put(elementId,  new IntegerArgumentMarshaler() ); } … private void setIntArg(char argChar) throws ArgsException { currentArgument++; String parameter = null; try { parameter = args[currentArgument]; intArgs. get (argChar). setInteger (Integer.parseInt(parameter)); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (NumberFormatException e) { valid = false; errorArgumentId = argChar; errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw new ArgsException(); } } … public int getInt(char arg) { Args.ArgumentMarshaler am =  intArgs.get(arg); return  am == null ? 0  : am.getInteger(); } 280