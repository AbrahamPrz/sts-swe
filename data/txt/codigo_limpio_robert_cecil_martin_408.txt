Estas tres instrucciones son atómicas ya que a pesar de que el subproceso que las ejecuta podría verse interrumpido por cualquiera de ellas, la información para la instrucción  PUTFIELD  (el valor constante  0  de la parte superior de la pila y la referencia a éste una posición inferior, junto con el valor del campo) no se ve alterada por ningún otro subproceso. Por tanto, al producirse la asignación, sabemos que el valor 0 se almacena en el valor del campo. La operación es atómica. Todos los operandos procesan información local del método, de modo que no hay interferencias entre subprocesos. Si estas instrucciones se ejecutan en diez subprocesos, hay 4.38679733629e+24 ordenaciones posibles. Sin embargo, sólo hay un resultado posible, de modo que las distintas ordenaciones son irrelevantes. Y además, se garantiza el mismo resultado para valores  long  en este caso. ¿Por qué? Los diez subprocesos asignan un valor constante. Aunque se entremezclen, el resultado final será el mismo. Habrá problemas con la operación  ++  en el método  getNextId . Imagine que  lastId  contiene  42  al inicio de este método. Veamos el código de  bytes  de este nuevo método: Nemónico Descripción Pila de operandos posterior ALOAD 0 Cargar  this  en la pila de operandos. this DUP Copiar la parte superior de la pila. Ahora tenemos dos copias de  this  en la pila de operandos. this, this GETFIELD lastId Recuperar el valor del campo  lastId  del objeto al que se apunta en la parte superior de la pila ( this ) y volver a almacenar el valor en la pila. this, 42 ICONST_1 Desplazar la constante entera 1 en la pila. this, 42, 1 IADD Suma entera de los dos valores superiores de la pila de operandos y volver a almacenar el resultado en la pila. this, 43 DUP_X1 Duplicar el valor 43 y añadirlo delante de  this . 43, this, 43 PUTFIELD Almacenar el valor superior de la pila de operandos, 43 409