} } Y también cambia el código cliente: while (true) { Integer nextValue = iterator.getNextOrNull(); if (next == null) break; // hacer algo con nextValue } En este caso, en realidad cambiamos la API de la clase para que sea compatible con el subproceso [120] . El cliente debe realizar una comprobación de  null  en lugar de comprobar  hasNext() . Por lo general, el bloqueo basado en el servidor es preferible por estos motivos: Reduce el código repetido: El bloqueo basado en el servidor hace que el cliente bloquee correctamente el servidor. Al incluir el código de bloqueo en el servidor, se libera a los clientes para usar el objeto y no tener que preocuparse de crear código de bloqueo adicional. Permite un mejor rendimiento: Puede intercambiar un servidor compatible con subprocesos por otro incompatible en caso de desarrollo de un solo subproceso, lo que evita la sobrecarga. Reduce las posibilidades de error: Sólo se necesita un programador que se olvide del bloqueo. Aplica una única política: La política se aplica solamente al servidor, no a todos los clientes. Reduce el ámbito de las variables compartidas: El cliente las desconoce y tampoco sabe cómo se bloquean. Todo se oculta en el servidor. Cuando se produce un fallo, su origen se busca en menos puntos. ¿Y si no es el propietario del código de servidor? Usar un adaptador para cambiar la API y añadir bloqueo public class ThreadSafeIntegerIterator { private IntegerIterator iterator = new IntegerIterator(); public synchronized Integer getNextOrNull() { 419