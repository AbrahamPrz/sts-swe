lo que intenta hacer y es probable que pudiera crear las funciones que faltan en función de ese significado que intuye. Los números mágicos ya no lo son y la estructura del algoritmo es descriptiva y atractiva: public int score() { int score = 0; int frame = 0; for (int frameNumber = 0; frameNumber < 10; frameNumber++) { if (isStrike(frame)) { score += 10 + nextTwoBallsForStrike(frame); frame += 1; } else if (isSpare(frame)) { score += 10 + nextBallForSpare(frame); frame += 2; } else { score += twoBallsInFrame(frame); frame += 2; } } return score; } Los nombres bien elegidos inundan la estructura del código con descripciones. Dicha inundación define las expectativas del lector sobre el cometido de otras funciones del módulo. Puede inferir la implementación de  isStrike()  si se fija en el código anterior. Cuando lea el método  isStrike , será prácticamente lo que esperaba [116] . private boolean isStrike(int frame) { return rolls[frame] = 10; } N2: Elegir nombres en el nivel correcto de abstracción No elija nombres que comuniquen implementación; seleccione nombres que reflejen el nivel de abstracción de la clase o la función con la que trabaje. Es complicado. De nuevo, nos cuesta mezclar niveles de abstracción. Siempre que realice una pasada por su código, es probable que encuentre una variable con nombre en un nivel demasiado bajo. Cambie esos nombres cuando los vea. Para que el código sea legible se necesita una mejora continua. Fíjese en la siguiente interfaz  Modem : public interface Modem { 392