Las necesidades cambiarán y también lo hará el código. En la programación orientada a objetos aprendemos que hay clases concretas que contienen detalles de implementación (el código) y clases abstractas que sólo representan conceptos. Una clase cliente que dependa de detalles concretos está en peligro si dichos detalles cambian. Podemos recurrir a interfaces y clases abstractas para aislar el impacto de dichos detalles. Las dependencias de detalles de concretos crean retos para nuestro sistema. Si tenemos que crear la clase  Portfolio  y ésta depende de una API TokyoStockExchange  externa para obtener su valor, nuestros casos de prueba se verán afectados por la volatilidad de esta búsqueda. Resulta complicado crear una prueba cuando se obtiene una respuesta diferente cada cinco minutos. En lugar de diseñar  Portfolio  para que dependa directamente de TokyoStockExchange , creamos una interfaz,  StockExchange , que declara un único método: public Interface StockExchange { Money currentPrice(String symbol); } Diseñamos  TokyoStockExchange  para implementar esta interfaz. También nos aseguramos de que el constructor de  Portfolio  adopte como argumento una referencia a StockExchange: public Portfolio { private StockExchange exchange; public Portfolio(StockExchange exchange) { this.exchange = exchange; } //… } Ahora la prueba puede crear una implementación de la interfaz StockExchange  que emule  TokyoStockExchange . Esta implementación de prueba fijará el valor actual del símbolo que usemos en la prueba. Si nuestra prueba demuestra la adquisición de cinco acciones de Microsoft para nuestra cartera de valores, diseñe el código de la implementación de prueba para que siempre devuelva 100 dólares por acción de Microsoft. Nuestra implementación de prueba de la interfaz StockExchange  se reduce a una sencilla búsqueda de tabla. De este modo 202