makeDate , lo que mejora ligeramente los nombres [N1]. De forma predeterminada es  SpreadsheetDateFactory  pero se puede cambiar por otra factoría. Los métodos estáticos delegados en métodos abstractos usan una combinación de los  patrones de instancia única [99] ,  decorador [100]  y  factoría abstracta  que considero muy útil.  SpreadsheetDateFactory  tiene este aspecto: public class SpreadsheetDateFactory extends DayDateFactory { public DayDate _makeDate(int ordinal) { return new SpreadsheetDate(ordinal); } public DayDate _makeDate(int day, DayDate.Month month, int year) { return new SpreadsheetDate(day, month, year); } public DayDate _makeDate(int day, int month, int year) { return new SpreadsheetDate(day, month, year); } public DayDate _makeDate(Date date) { final GregorianCalendar calendar = new GregorianCalendar(); calendar.setTime(date); return new SpreadsheetDate( calendar.get(Calendar.DATE), DayDate.Month.make(calendar.get(Calendar.MONTH) + 1), calendar.get(Calendar.YEAR)); } protected int _getMinimumYear() { return SpreadsheetDate.MINIMUM_YEAR_SUPPORTED; } protected int _getMaximumYear() { return SpreadsheetDate.MAXIMUM_YEAR_SUPPORTED; } } Como puede apreciar, hemos enviado las variables MINIMUM_YEAR_SUPPORTED  y  MAXIMUM_YEAR_SUPPORTED  a  SpreadsheetDate , donde pertenecen [G6]. El siguiente problema de  DayDate  son las constantes de días, comenzando en la línea 109. Deberían ser otra enumeración [J3]. Ya hemos visto este patrón, de modo que no lo repetiremos. Se incluye en los listados definitivos. Seguidamente, vemos una serie de tablas que comienzan en LAST_DAY_OF_MONTH  (línea 140). El primer problema con estas tablas es que 346