makedate , lo que mejora ligeramente los nombres [n1]. de forma predeterminada es spreadsheetdatefactory pero se puede cambiar por otra factoría. los métodos estáticos delegados en métodos abstractos usan una combinación de los patrones de instancia única [99] , decorador [100] y factoría abstracta que considero muy útil. spreadsheetdatefactory tiene este aspecto: public class spreadsheetdatefactory extends daydatefactory { public daydate _makedate(int ordinal) { return new spreadsheetdate(ordinal); } public daydate _makedate(int day, daydate.month month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(int day, int month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(date date) { final gregoriancalendar calendar = new gregoriancalendar(); calendar.settime(date); return new spreadsheetdate( calendar.get(calendar.date), daydate.month.make(calendar.get(calendar.month) + 1), calendar.get(calendar.year)); } protected int _getminimumyear() { return spreadsheetdate.minimum_year_supported; } protected int _getmaximumyear() { return spreadsheetdate.maximum_year_supported; } } como puede apreciar, hemos enviado las variables minimum_year_supported y maximum_year_supported a spreadsheetdate , donde pertenecen [g6]. el siguiente problema de daydate son las constantes de días, comenzando en la línea 109. deberían ser otra enumeración [j3]. ya hemos visto este patrón, de modo que no lo repetiremos. se incluye en los listados definitivos. seguidamente, vemos una serie de tablas que comienzan en last_day_of_month (línea 140). el primer problema con estas tablas es que 346