ExecutorClientScheduler.java. import java.util.concurrent.Executor; import java.util.concurrent.Executors; public class ExecutorClientScheduler implements ClientScheduler { Executor executor; public ExecutorClientScheduler(int availableThreads) { executor = Executors.newFixedThreadPool(availableThreads); } public void schedule(final ClientRequestProcessor requestProcessor) { Runnable runnable = new Runnable() { public void run() { requestProcessor.process(); } }; executor.execute(runnable); } } Conclusión En este ejemplo concreto, la presencia de la concurrencia ilustra una forma de mejorar la producción de un sistema y otra de validar dicha producción a través de una estructura de pruebas. Al centrar el código de concurrencia en un número reducido de clases, aplicamos el Principio de responsabilidad única. En el caso de la programación concurrente, resulta especialmente importante debido a su complejidad. Posibles rutas de ejecución Repase el método  incrementValue , un método de Java de una línea sin bucles ni ramificaciones: public class IdGenerator { int lastIdUsed; public int incrementValue() { return ++lastIdUsed; } } Ignore el desbordamiento de enteros e imagine que solamente un 404