Entonces me detuve Todavía tenía que añadir otros dos tipos de argumentos y sabía que empeorarían las cosas. Si los forzaba, seguramente funcionarían pero provocaría un desastre demasiado complicado de arreglar. Si la estructura del código tenía que poder mantenerse, era el momento de corregirla. Por ello dejé de añadir elementos y comencé la refactorización. Tras añadir los argumentos  String  e  integer , sabía que cada uno necesitaría nuevo código en tres puntos principales. En primer lugar, cada tipo de argumento necesita una forma de analizar su elemento de esquema para poder seleccionar el  HashMap  de ese tipo. Tras ello, sería necesario analizar cada tipo de argumento en las cadenas de línea de comandos y convertirlos en su tipo correcto. Por último, cada tipo de argumento necesitaría un método getXXX  para poder devolverlo al invocador como su tipo correcto. Muchos tipos diferentes y todos con métodos similares, lo que en realidad era una clase. Y de este modo nació el concepto de  ArgumentMarshaler . Sobre el incrementalismo Una de las mejores formas de acabar con un programa es realizar cambios masivos con la intención de mejorarlo. Algunos programas nunca se recuperan de estas mejoras. El problema es lo complicado que resulta conseguir que el programa funcione de la misma forma que antes de la mejora. Para evitarlo, recurro a la disciplina TDD ( Test-Driven Development  o Desarrollo guiado por pruebas). Una de las doctrinas centrales de este enfoque es mantener la ejecución del sistema en todo momento. Es decir, con TDD no puedo realizar cambios que afecten al funcionamiento del sistema. Todos los cambios deben mantenerlo como antes de los cambios. Para lograrlo, necesito una serie de pruebas automatizadas que ejecutar rápidamente y que verifiquen que el comportamiento del sistema no ha variado. Para la clase  Args , creé una serie de pruebas de unidad y aceptación. Las pruebas de unidad se crearon en Java y se administraron con JUnit. Las 276