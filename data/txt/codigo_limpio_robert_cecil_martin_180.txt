podemos eliminar los duplicados por medio del patrón método de plantilla [42] e incluir las partes dado/cuando en la clase base, y las partes entonces en derivaciones diferentes. o podríamos crear una clase de prueba independiente e incluir las partes dado y cuando en la función @before y las partes entonces en cada función @test . pero parece un mecanismo excesivo para un problema tan menor. al final, opto por las afirmaciones múltiples del listado 9-2. considero que la regla de una sola afirmación es una directriz adecuada [43] . siempre intento crear un lenguaje de pruebas específico del dominio que la complemente, como en el listado 9-5, pero no rechazo incluir más de una afirmación en una prueba. creo que lo mejor que podemos decir es que el número de afirmaciones de una prueba debe ser mínimo. un solo concepto por prueba puede que una regla más indicada sea probar un único concepto en cada función de prueba. no queremos extensas funciones que prueben una cosa diferente tras otra, como sucede en el listado 9-8. esta prueba debería dividirse en tres diferentes que probaran tres cosas distintas. al combinarlas en la misma función se obliga al lector a determinar por qué cada sección se ubica en ese punto y qué prueba dicha sección. listado 9-8 /** * varias pruebas para el método addmonths(). */ public void testaddmonths() { serialdate d1 = serialdate.createinstance(31, 5, 2004); serialdate d2 = serialdate.addmonths(1, d1); assertequals(30, d2.getdayofmonth()); assertequals(6, d2.getmonth()); assertequals(2004, d2.getyyyy()); serialdate d3 = serialdate.addmonths(2, d1); assertequals(31, d3.getdayofmonth()); assertequals(7, d3.getmonth()); assertequals(2004, d3.getyyyy()); 181