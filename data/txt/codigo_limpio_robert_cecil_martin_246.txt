Crear un sistema activo y que se ejecute indefinidamente es distinto a crear algo que funcione de forma temporal y después se cierre correctamente. Entre los problemas más habituales destacan los bloqueos [88] , con procesos que esperan una señal para continuar que nunca se produce. Imagine, por ejemplo, un sistema con un proceso principal que genera varios procesos secundarios y que espera a que todos terminen antes de liberar sus recursos y cerrarse. ¿Qué sucede si uno de los procesos secundarios está bloqueado? El principal esperará indefinidamente y el sistema nunca se cerrará. Imagine ahora un sistema similar al que se le indica que se cierre. El proceso principal indica a todos los secundarios que abandonen sus tareas y terminen. Pero imagine que dos procesos secundarios funcionan como par productor/consumidor y que el productor recibe una señal del principal y se cierra rápidamente. El consumidor espera un mensaje del productor y puede quedar bloqueado en un estado en el que no recibe la señal del principal, lo que también impide que éste finalice. Son situaciones habituales. Por tanto, si tiene que crear código concurrente con cierres correctos, tendrá que dedicar tiempo a que el cierre se produzca de forma correcta. Recomendación :  Planifique con antelación el proceso de cierre y pruébelo hasta que funcione. Le llevará más tiempo del que espera. Repase los algoritmos existentes porque será complicado . Probar código con procesos Demostrar que el código es correcto no resulta práctico. Las pruebas no garantizan su corrección. Sin embargo, las pruebas adecuadas pueden minimizar los riesgos, en especial en aplicaciones de un solo proceso. Cuando hay dos o más procesos que usan el mismo código y trabajan con datos compartidos, la situación se vuelve más compleja. Recomendación :  Cree pruebas que puedan detectar problemas y ejecútelas periódicamente, con distintas configuraciones de programación y del sistema, y cargas. Si las pruebas fallan, identifique el fallo. No lo ignore 247