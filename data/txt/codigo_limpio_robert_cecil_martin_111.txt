{ result = new int[numberOfUncrossedIntegers()]; for (int j = 0, i = 2; i < crossedOut.length; i++) if (notCrossed(i)) result[j++] = i; } private static int numberOfUncrossedIntegers() { int count = 0; for (int i = 2; i < crossedOut.length; i++) if (notCrossed(i)) count++; return count; } } Se podría decir que el primer comentario es redundante ya que es muy similar a la función  generatePrimes , pero creo que muestra mejor el algoritmo al lector, motivo por el que lo he mantenido. El segundo argumento es sin duda necesario. Explica la lógica del uso de la raíz cuadrada como límite del bucle. No encontré otro nombre de variable más sencillo ni otra estructura de código que lo aclarara más. Por otra parte, el uso de la raíz cuadrada podría resultar presuntuoso. ¿Realmente se ahorra tanto tiempo limitando la iteración a la raíz cuadrada? ¿El cálculo de la raíz cuadrada llevaría más tiempo del que se ahorra? Conviene analizarlo. El uso de la raíz cuadrada como límite de iteración satisface al viejo  hacker  de C y de lenguajes de ensamblado de mi interior, pero no estoy convencido de que merezca el tiempo y el esfuerzo que los demás puedan dedicar a entenderlo. Bibliografía [KP78] : Kernighan and Plaugher,  The Elements of Programming Style , 2d. ed., McGraw-Hill, 1978. 112