return true; } --- private void setbooleanarg (argumentmarshaler m, iterator<string> currentargument) throws argsexception { try { m.set(“true”); catch (argsexception e) { } } ¿no acabamos de incluir el procesamiento de excepciones? añadir elementos para después excluirlos es habitual en los procesos de refactorización. los pasos reducidos y la necesidad de que las pruebas sigan siendo correctas implican que los elementos cambien de posición. la refactorización es como resolver el cubo de rubik. se necesitan muchos pasos pequeños para lograr un objetivo mayor. cada paso habilita el siguiente. se preguntará por qué pasamos iterator si setbooleanarg no lo necesita. pues porque setintarg y setstringarg sí. y como el objetivo es implementar las tres funciones a través de un método abstracto en argumentmarshaller , es necesario pasarlo a setbooleanarg . ahora setbooleanarg no sirve de nada. si hubiera una función set en argumentmarshaler , podríamos invocarla directamente. es el momento de crear dicha función. el primer paso consiste en añadir el nuevo método abstracto a argumentmarshaler . private abstract class argumentmarshaler { public abstract void set(iterator<string> currentargument) throws argsexception; public abstract void set (string s) throws argsexception; public abstract object get(); } evidentemente, esto afecta a todas las variantes, de modo que implementamos el nuevo método en cada una. private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(iterator<string> currentargument) throws argsexception { booleanvalue = true; } public void set(string s) { 300