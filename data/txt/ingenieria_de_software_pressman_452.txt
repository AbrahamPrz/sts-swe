CAPÍTULO 18  PRUEBA DE APLICACIONES CONVENCIONALES 421 18.5.1  Prueba de condición La prueba de condición  [Tai89] es un método de diseño de casos de prueba que revisa las condi- ciones lógicas contenidas en un módulo de programa. Una condición simple es una variable  booleana o una expresión relacional, posiblemente precedida de un operador NOT (¬). Una expresión relacional toma la forma E 1 <operador relacional> E2 donde E1 y E2 son expresiones aritméticas y <operador relacional> es uno de los siguientes:  /H11021, /H11349, /H11005, /HS33527 (no igualdad), /H11022 o /H11350. Una condición compuesta se integra con dos o más condiciones  simples, operadores booleanos y paréntesis. Se supone que los operadores booleanos permiti-dos en una condición compuesta incluyen OR (/H20841 ), AND (&) y NOT (¬). Una condición sin expre- siones relacionales se conoce como expresión booleana. Si una condición es incorrecta, entonces al menos un componente de la condición es in- correcto. Por tanto, los tipos de errores en una condición incluyen errores de operador booleano (operadores booleanos incorrectos/perdidos/adicionales), de variable booleana, de paréntesis booleanos, de operador relacional y de expresión aritmética. El método de prueba de condición se enfoca en la prueba de cada condición del programa para asegurar que no contiene errores. 18.5.2  Prueba de flujo de datos El método de prueba de flujo de datos [Fra93] selecciona rutas de prueba de un programa de acuerdo con las ubicaciones de las definiciones y con el uso de variables en el programa. Para ilustrar el enfoque de prueba de flujo de datos, suponga que a cada enunciado en un programa se le asigna un número de enunciado único y que cada función no modifica sus parámetros o variables globales. Para un enunciado con S como su número de enunciado, DEF(S) /H11005 {X | enunciado S contiene una definición de X} USE(S) /H11005 {X | enunciado S contiene un uso de X} Si el enunciado S es un enunciado if o loop, su conjunto DEF es vacío y su conjunto USE se basa en la condición del enunciado S. Se dice que la definición de la variable X en el enunciado S está  viva en el enunciado S/H11032 si existe una ruta desde el enunciado S hasta el enunciado S/H11032 que no  contiene otra definición de X. Una cadena de definición de uso (DU)  de la variable X es de la forma [X, S, S/H11032], donde S y S/H11032 son  números de enunciado, X está en DEF(S) y en USE(S/H11032), y la definición de X en el enunciado S está  viva en el enunciado S/H11032. Una estrategia de prueba de flujo de datos simple es requerir que toda cadena DU se cubra al  menos una vez. A esta estrategia se le conoce como estrategia de prueba DU. Se ha demostrado que la prueba DU no garantiza la cobertura de todas las ramas de un programa. Sin embargo, la prueba DU no garantiza la cobertura de una rama sólo en raras situaciones, como en los constructos if-then-else en los cuales la parte then no tiene definición de alguna variable y la parte else  no existe. En esta situación, la rama else del enunciado if no necesariamente se cubre  con la prueba DU. 18.5.3  Prueba de bucle Los bucles son la piedra de toque de la gran mayoría de todos los algoritmos implementados en el software. Y aún así, con frecuencia se les pone poca atención mientras se realizan las pruebas de software. La prueba de bucle es una técnica de prueba de caja blanca que se enfoca exclusivamente en  la validez de los constructos bucle. Pueden definirse cuatro clases diferentes de bucles [Bei90]: simples, concatenados, anidados y no estructurados (figura 18.7).Cita: “Poner más atención a la aplica- ción de las pruebas que a su diseño es un error clásico.” Brian Marick PUNTO CLAVE Los errores son mucho más comunes  en la cercanía de las condiciones lógicas que en el lugar de los enunciados de procesamiento secuencial. Cita: “Los buenos examinadores son maestros para notar ‘algo diver-tido’ y actuar sobre ello.” Brian Marick Es irreal suponer que la prueba de  flujo de datos se usará de manera extensa cuando se prueba un sistema grande. Sin embargo, puede usarse en forma dirigida para áreas de software que sean sospechosas.CONSEJO 18Pressman(411-436).indd   42118Pressman(411-436).indd   421 21/1/10   10:58:5621/1/10   10:58:56