clase  Args . También generamos  ParseException , que no nos pertenece. Por ello, combinamos todas las excepciones en una única clase  ArgsException  y la incluimos en su propio módulo. public class ArgsException extends Exception { private char errorArgumentId = ‘\0’; private String errorParameter = “TILT”; private ErrorCode errorCode = ErrorCode.OK; public ArgsException() {} public ArgsException(String message) { super(message); } public enum ErrorCode { OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT, MISSING_DOUBLE, INVALID_DOUBLE } } … public class Args { … private char errorArgumentId = ‘\0’; private String errorParameter = “TILT”; private  ArgsException .ErrorCode errorCode =  ArgsException .ErrorCode.OK; private List<String> argsList; public Args(String schema, String[] args) throws  ArgsException  { this.schema = schema; argsList = Arrays.asList(args); valid = parse(); } private boolean parse() throws ArgsException { if (schema.length() == 0 && argsList.size() == 0) return true; parseSchema(); try { parseArguments(); } catch ( ArgsException  e) { } return valid; } private boolean parseSchema() throws  ArgsException  { … } private void parseSchemaElement(String element) throws  ArgsException  { … else throw new  ArgsException ( String.format(“Argument: %c has invalid format: %s.”, elementId, elementTail)); } 307