if (s.equalsIgnoreCase(shortWeekdayNames[day.index]) || s.equalsIgnoreCase(weekDayNames[day.index])) { return day; } } throw new IllegalArgumentException( String.format(“%s is not a valid weekday string”, s)); } public String toString() { return dateSymbols.getWeekdays()[index]; } } Hay dos funciones  getMonths  (líneas  288-316).  La primera invoca la segunda. La segunda solamente se invoca desde la primera. Por ello, las he combinado en una y las he simplificado considerablemente [G9], [G12], [F4]. Por último, he cambiado el nombre por otro más descriptivo [N1]. public static String[] getMonthNames() { return dateFormatSymbols.getMonths(); } La función  isValidMonthCode  (líneas  326-346)  es ahora irrelevante gracias a la enumeración  Month , de modo que la elimino [G9]. La función  monthCodeToQuarter  (líneas  356-375)  parece sufrir  envidia de las características [102]  [G14] y seguramente pertenezca a la enumeración Month  como método  quarter , motivo por el que la sustituyo. public int quarter() { return 1 + (index-1)/3; } De este modo, la enumeración  Month  tiene tamaño suficiente como para estar en una clase propia. La extraigo de DayDate para mantener la coherencia con la enumeración  Day  [G11], [G13]. Los dos siguientes métodos tienen el nombre  monthCodeToString  (líneas  377-426).  Vemos de nuevo que uno invoca al otro con un indicador. No es recomendable pasar un indicador como argumento de una función, en especial si dicho indicador sólo selecciona el formato del resultado [G15]. Por tanto, cambio de nombre, simplifico y reestructuro estas funciones y las incluyo en la enumeración  Month  [N1], [N3], [C3], [G14]. public String toString() { return dateFormatSymbols.getMonths()[index - 1]; 350