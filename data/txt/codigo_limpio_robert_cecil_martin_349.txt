if (s.equalsignorecase(shortweekdaynames[day.index]) || s.equalsignorecase(weekdaynames[day.index])) { return day; } } throw new illegalargumentexception( string.format(“%s is not a valid weekday string”, s)); } public string tostring() { return datesymbols.getweekdays()[index]; } } hay dos funciones getmonths (líneas 288-316). la primera invoca la segunda. la segunda solamente se invoca desde la primera. por ello, las he combinado en una y las he simplificado considerablemente [g9], [g12], [f4]. por último, he cambiado el nombre por otro más descriptivo [n1]. public static string[] getmonthnames() { return dateformatsymbols.getmonths(); } la función isvalidmonthcode (líneas 326-346) es ahora irrelevante gracias a la enumeración month , de modo que la elimino [g9]. la función monthcodetoquarter (líneas 356-375) parece sufrir envidia de las características [102] [g14] y seguramente pertenezca a la enumeración month como método quarter , motivo por el que la sustituyo. public int quarter() { return 1 + (index-1)/3; } de este modo, la enumeración month tiene tamaño suficiente como para estar en una clase propia. la extraigo de daydate para mantener la coherencia con la enumeración day [g11], [g13]. los dos siguientes métodos tienen el nombre monthcodetostring (líneas 377-426). vemos de nuevo que uno invoca al otro con un indicador. no es recomendable pasar un indicador como argumento de una función, en especial si dicho indicador sólo selecciona el formato del resultado [g15]. por tanto, cambio de nombre, simplifico y reestructuro estas funciones y las incluyo en la enumeración month [n1], [n3], [c3], [g14]. public string tostring() { return dateformatsymbols.getmonths()[index - 1]; 350