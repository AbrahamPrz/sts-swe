} } Es lo que se denomina  Patrón de Caso Especial  [Fowler]. Se crea una clase o se configura un objeto que procese un caso especial. Al hacerlo, el código cliente no tiene que procesar comportamientos excepcionales. Dichos comportamientos se encapsulan en un objeto de caso especial. No devolver Null Creo que toda descripción del control de errores debe mencionar los elementos proclives a errores. El primero es devolver null. He perdido la cuenta de la cantidad de aplicaciones en que las que línea sí y línea también se comprueba null: public void registerItem(Item item) { if (item != null) { ItemRegistry registry = peristentStore.getItemRegistry(); if (registry != null) { Item existing = registry.getItem(item.getID()); if (existing.getBillingPeriod().hasRetailOwner()) { existing.register(item); } } } } Si trabaja en una base de código como ésta, puede que no le parezca tan mala, pero lo es. Al devolver  null , básicamente nos creamos trabajo y generamos problemas para los invocadores. Basta con que falte una comprobación de  null  para que la aplicación pierda el control. ¿Se ha fijado en que no hay una comprobación de  null  en la segunda línea de la instrucción  if  anidada? ¿Qué sucedería en tiempo de ejecución si persistentStore  fuera  null ? Se generaría  NullPointerException  en tiempo de ejecución y se capturaría  NullPointerException  en el nivel superior o no. En ambos casos es incorrecto. ¿Qué debería hace como respuesta a la generación de  NullPointerException  desde el interior de su aplicación? Se puede afirmar que el problema de este código es la ausencia de una comprobación de  null  pero en realidad el problema es su exceso. Si 155