} } es lo que se denomina patrón de caso especial [fowler]. se crea una clase o se configura un objeto que procese un caso especial. al hacerlo, el código cliente no tiene que procesar comportamientos excepcionales. dichos comportamientos se encapsulan en un objeto de caso especial. no devolver null creo que toda descripción del control de errores debe mencionar los elementos proclives a errores. el primero es devolver null. he perdido la cuenta de la cantidad de aplicaciones en que las que línea sí y línea también se comprueba null: public void registeritem(item item) { if (item != null) { itemregistry registry = peristentstore.getitemregistry(); if (registry != null) { item existing = registry.getitem(item.getid()); if (existing.getbillingperiod().hasretailowner()) { existing.register(item); } } } } si trabaja en una base de código como ésta, puede que no le parezca tan mala, pero lo es. al devolver null , básicamente nos creamos trabajo y generamos problemas para los invocadores. basta con que falte una comprobación de null para que la aplicación pierda el control. ¿se ha fijado en que no hay una comprobación de null en la segunda línea de la instrucción if anidada? ¿qué sucedería en tiempo de ejecución si persistentstore fuera null ? se generaría nullpointerexception en tiempo de ejecución y se capturaría nullpointerexception en el nivel superior o no. en ambos casos es incorrecto. ¿qué debería hace como respuesta a la generación de nullpointerexception desde el interior de su aplicación? se puede afirmar que el problema de este código es la ausencia de una comprobación de null pero en realidad el problema es su exceso. si 155