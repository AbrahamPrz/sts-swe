int deltaStart = prefixLength; int deltaEnd = s.length() - suffixLength; return s.substring(deltaStart, deltaEnd); } private String endingContext() { int contextStart = expected.length() - suffixLength; int contextEnd = Math.min(contextStart + contextLength, expected.length()); return expected.substring(contextStart, contextEnd); } private String endingEllipsis() { return (suffixLength > contextLength ? ELLIPSIS : “”); } } Bastante atractivo. El módulo se separa en un grupo de funciones de análisis y otro grupo de funciones de síntesis. Se ordenan topológicamente para que la definición de cada función aparezca donde realmente se usa. Primero se muestran las funciones de análisis y después las de síntesis. Si se fija atentamente, verá que he invertido algunas de las decisiones adoptadas inicialmente. Por ejemplo, he añadido algunos métodos extraídos a formatCompactedComparison  y he modificado el sentido de la expresión shouldNotBeCompacted . Es algo habitual. A menudo, un cambio de refactorización lleva a otro que a su vez lleva a deshacer el primero. La refactorización es un proceso iterativo de ensayo y error, e inevitablemente converge en algo que consideramos digno de un profesional. Conclusión Hemos cumplido la Regla del Boy Scout. Hemos dejado este módulo más limpio de como lo encontramos. No es que no estuviera limpio originalmente, ya que el trabajo de sus autores es excelente, pero cualquier módulo se puede mejorar y es nuestra responsabilidad dejar el código más limpio de lo que lo encontramos. 336