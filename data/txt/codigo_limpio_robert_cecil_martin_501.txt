48 * java.util.Date puede ser demasiado precisa; representa un instante en el tiempo, 49 * con una precisión de 1/1000 de segundo (y la fecha depende de la 50 * zona horaria). En ocasiones solo querremos representar un día concreto (como el 21 51 * de enero de 2015) sin preocuparnos de la hora del día, la 52 * zona horaria u otros aspectos. Para eso hemos definido SerialDate. 53 * 54 * Usar DayDateFactory.makeDate para crear una instancia. 55 * 56 * @author David Gilbert 57 * @author Robert C. Martin realizó gran parte de la refactorización. 58 */ 59 60 public abstract class DayDate implements Comparable, Serializable { 61 public abstract int getOrdinalDay(); 62 public abstract int getYear(); 63 public abstract Month getMonth(); 64 public abstract int getDayOfMonth(); 65 66 protected abstract Day getDayOfWeekForOrdinalZero(); 67 68 public DayDate plusDays(int days) { 69 return DayDateFactory.makeDate(getOrdinalDay() + days); 70 } 71 72 public DayDate plusMonths(int months) { 73 int thisMonthAsOrdinal = getMonth().toInt() - Month.JANUARY.toInt(); 74 int thisMonthAndYearAsOrdinal = 12 * getYear() + thisMonthAsOrdinal; 75 int resultMonthAndYearAsOrdinal = thisMonthAndYearAsOrdinal + months; 76 int resultYear = resultMonthAndYearAsOrdinal / 12; 77 int resultMonthAsOrdinal = resultMonthAndYearAsOrdinal % 12 + Month.JANUARY.toInt(); 78 Month resultMonth = Month.fromInt(resultMonthAsOrdinal); 79 int resultDay = correctLastDayOfMonth(getDayOfMonth(), resultMonth, resultYear); 80 return DayDateFactory.makeDate(resultDay, resultMonth, resultYear); 81 } 82 83 public DayDate plusYears(int years) { 84 int resultYear = getYear() + years; 85 int resultDay = correctLastDayOfMonth(getDayOfMonth(), getMonth(), resultYear); 86 return DayDateFactory.makeDate(resultDay, getMonth(), resultYear); 87 } 502