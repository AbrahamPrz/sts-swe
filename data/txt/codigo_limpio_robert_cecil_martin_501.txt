48 * java.util.date puede ser demasiado precisa; representa un instante en el tiempo, 49 * con una precisión de 1/1000 de segundo (y la fecha depende de la 50 * zona horaria). en ocasiones solo querremos representar un día concreto (como el 21 51 * de enero de 2015) sin preocuparnos de la hora del día, la 52 * zona horaria u otros aspectos. para eso hemos definido serialdate. 53 * 54 * usar daydatefactory.makedate para crear una instancia. 55 * 56 * @author david gilbert 57 * @author robert c. martin realizó gran parte de la refactorización. 58 */ 59 60 public abstract class daydate implements comparable, serializable { 61 public abstract int getordinalday(); 62 public abstract int getyear(); 63 public abstract month getmonth(); 64 public abstract int getdayofmonth(); 65 66 protected abstract day getdayofweekforordinalzero(); 67 68 public daydate plusdays(int days) { 69 return daydatefactory.makedate(getordinalday() + days); 70 } 71 72 public daydate plusmonths(int months) { 73 int thismonthasordinal = getmonth().toint() - month.january.toint(); 74 int thismonthandyearasordinal = 12 * getyear() + thismonthasordinal; 75 int resultmonthandyearasordinal = thismonthandyearasordinal + months; 76 int resultyear = resultmonthandyearasordinal / 12; 77 int resultmonthasordinal = resultmonthandyearasordinal % 12 + month.january.toint(); 78 month resultmonth = month.fromint(resultmonthasordinal); 79 int resultday = correctlastdayofmonth(getdayofmonth(), resultmonth, resultyear); 80 return daydatefactory.makedate(resultday, resultmonth, resultyear); 81 } 82 83 public daydate plusyears(int years) { 84 int resultyear = getyear() + years; 85 int resultday = correctlastdayofmonth(getdayofmonth(), getmonth(), resultyear); 86 return daydatefactory.makedate(resultday, getmonth(), resultyear); 87 } 502