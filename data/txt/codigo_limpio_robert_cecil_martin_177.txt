controller.tic(); assertTrue(hw.heaterState()); assertTrue(hw.blowerState()); assertFalse(hw.coolerState()); assertFalse(hw.hiTempAlarm()); assertTrue(hw.loTempAlarm()); } Aquí hay muchos detalles. Por ejemplo, ¿para qué sirve la función  tic ? De hecho, la ignoraría mientras leemos esta prueba. Intente centrarse en saber si está de acuerdo en que el estado final del sistema tiene que ver con que la temperatura sea demasiado baja. Al leer la prueba, la vista tiene que cambiar entre el nombre del estado comprobado y el sentido del estado comprobado. Vemos  heaterState  y después la vista salta a  assertTrue . Vemos  coolerState  y nos fijamos en assertFalse . Resulta tedioso y dificulta la lectura de la prueba. He conseguido mejorar la legibilidad de la prueba transformándola en el Listado 9-4. Listado 9-4 EnvironmentControllerTest.java (refactorizado) @Test public void turnOnLoTempAlarmAtThreshold() throws Exception { wayTooCold(); assertEquals(“HBchL”, hw.getState()); } Evidentemente, he ocultado el detalle de la función  tic  creando una función  wayTooCold . Pero lo importante es la extraña cadena de assertEquals . Las mayúsculas significan activado y las minúsculas desactivado, y las letras siempre aparece en este orden:  {heater, blower, cooler, hi-temp-alarm, lo-temp-alarm} . Aunque prácticamente sea un incumplimiento de las reglas de asignación mental [39] , en este caso parece apropiado. Una vez que conocemos el significado, la vista pasa por la cadena y podemos interpretar los resultados. La lectura de la prueba es casi un placer. Fíjese en el Listado 9-5 y compruebe con qué facilidad entiende las pruebas. 178