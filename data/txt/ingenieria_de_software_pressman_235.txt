204 PARTE DOS  MODELADO 8.2. Si el diseño del software no es un programa (y no lo es), entonces, ¿qué es? 8.3. ¿Cómo se evalúa la calidad del diseño del software? 8.4. Estudie el conjunto de tareas presentado para el diseño. ¿Dónde se evalúa la calidad en dicho conjunto?  ¿Cómo se logra? ¿Cómo se consiguen los atributos de calidad estudiados en la sección 8.2.1? 8.5. Dé ejemplos de tres abstracciones de datos y de las abstracciones de procedimiento que se usan para  manipularlas.8.6. Describa con sus propias palabras la arquitectura de software. 8.7. Sugiera un patrón de diseño que encuentre en una categoría de objetos cotidianos (por ejemplo, elec- trónica de consumo, automóviles, aparatos, etc.). Describa el patrón en forma breve.8.8. Describa con sus propias palabras la separación de problemas. ¿Hay algún caso en el que no sea apro- piada la estrategia de divide y vencerás? ¿Cómo afecta esto al argumento a favor de la modularidad?8.9. ¿Cuándo debe implementarse un diseño modular como software monolítico? ¿Cómo se logra esto? ¿El  rendimiento es la única justificación para la implementación de software monolítico?8.10. Analice la relación entre el concepto de ocultamiento de información como atributo de la modularidad  efectiva y el de independencia de los módulos.8.11. ¿Cómo se relacionan los conceptos de acoplamiento y portabilidad del software? Dé ejemplos que  apoyen su punto de vista.8.12. Aplique un “enfoque de refinamiento stepwise” para desarrollar tres niveles distintos de abstracciones  del procedimiento para uno o más de los programas siguientes: a) un revisor de la escritura que, dada una  cantidad numérica de dinero, imprima ésta en las palabras que se requieren normalmente en un cheque. b)  una resolución en forma iterativa de las raíces de una ecuación trascendente. c) un algoritmo de programa- ción de tareas simples para un sistema operativo.8.13. Considere el software requerido para implementar la capacidad de navegación (con un GPS) en un  dispositivo móvil de comunicación portátil. Describa dos o tres preocupaciones de interferencia que se pre- sentarían. Analice la manera en la que se representaría como aspecto una de estas preocupaciones. 8.14. ¿”Rediseñar” significa que se modifica todo el diseño en forma iterativa? Si no es así, ¿qué significa? 8.15. Describa en breves palabras cada uno de los cuatro elementos del modelo del diseño.   LECTURAS  ADICIONALES  Y FUENTES  DE INFORMACIÓN Donald Norman ha escrito dos libros (The Design of Everyday Things, Doubleday, 1990, y The Psychology of  Everyday Things, Harpercollins, 1988) que se han convertido en clásicos de la bibliografía sobre el diseño y una “obligación” de lectura para quien diseñe cualquier cosa que utilicen los humanos. Adams ( Conceptual  Blockbusting, 3a. ed., Addison-Wesley, 1986) escribió un libro cuya lectura es esencial para los diseñadores que deseen ampliar su forma de pensar. Por último, el texto clásico de Polya ( How to Solve It, 2a. ed., Prince- ton University Press, 1988) proporciona un proceso general de solución de problemas que ayuda a los dise-ñadores de software cuando se enfrentan a problemas complejos. En la misma tradición, Winograd et al. (Bringing Design to Software, Addison-Wesley, 1996) analizan los  diseños de software que funcionan, los que no y su por qué. Un libro fascinante editado por Wixon y Ramsey (Field Methods Casebook for Software Design , Wiley, 1996) sugiere métodos de investigación de campo (muy  parecidos a los de los antropólogos) para entender cómo hacen el trabajo los usuarios finales y luego diseñar el software que satisfaga sus necesidades. Beyer y Holtzblatt ( Contextual Design: A Customer-Centered Appro- ach to Systems Designs, Academic Press, 1997) ofrecen otro punto de vista del diseño de software que integra al consumidor o usuario en cada aspecto del proceso de diseño. Bain (Emergent Design , Addison-Wesley,  2008) acopla los patrones, el rediseño y el desarrollo orientado a pruebas en un enfoque de diseño eficaz. Un tratamiento exhaustivo del diseño en el contexto de la ingeniería de software es presentado por Fox  (Introduction to Software Engineering Design , Addison-Wesley, 2006) y Zhu (Software Design Methodology,  Butterworth-Heinemann, 2005). McConnell (Code Complete, 2a. ed., Microsoft Press, 2004) plantea un estudio  excelente de los aspectos prácticos del diseño de software de alta calidad. Robertson (Simple Program Design, 3a. ed., Boyd y Fraser Publishing, 1999) presenta un análisis introductorio del diseño de software, útil para quienes se inician en el estudio del tema. Budgen ( Software Design, 2a. ed., Addison-Wesley, 2004) presenta  08Pressman(183-205).indd   20408Pressman(183-205).indd   204 14/1/10   14:31:1214/1/10   14:31:12