capítulo 21 modelado y verificación formal 485 que pasa a través de la condición cont. dado que la condición cont es idéntica a la con- dición loop, ésta es verdadera sin importar la trayectoria de flujo que conduce a ella. 3. la condición cont se encuentra solamente después de que el valor de y aumenta en 1. además, la ruta de flujo de control que conduce a cont puede in vocarse sólo si la condi- ción yes también es verdadera. por tanto, si ( y /h11001 1)2 /h11349 x se sigue que y2 /h11349 x. se satisface la condición cont. 4. la condición yes se prueba en la lógica condicional que se muestra. por ende , la condi- ción yes debe ser verdadera cuando el flujo de control se mueve a lo largo de la trayec- toria mostrada. 5. la condición exit demanda primero que x permanezca in variable. un examen del diseño indica que x no aparece a la izquierda de un operador de asignación. no hay llamadas de función que usen x. en consecuencia, es invariable. puesto que la prueba condicional (y /h11001 1)2 /h11349 x debe fallar para alcanzar la condición exit, se sigue que ( y /h11001 1)2 /h11349 x. ade- más, la condición loop debe incluso ser verdadera (es decir, y2 /h11349 x). por tanto, ( y /h11001 1)2 /h11022 x y y2 /h11349 x pueden combinarse para satisfacer la condición exit. adicionalmente, debe asegurarse de que el ciclo termina. un examen de la condición loop indica que, dado que y se incrementa y x ≥ 0, el ciclo finalmente debe terminar. los cinco pasos recién señalados son una prueba de la exactitud del diseño del algoritmo anotado en la figura 21.6. entonces se está seguro de que el diseño, de hecho, calculará la parte entera de una raíz cuadrada. es posible un enfoque matemático más riguroso para verificar el diseño. sin embargo, un estudio de este tema está más allá del ámbito de este libro. si tiene interés en ello, consulte [lin79]. 21.4 p ruebas de cuarto limpio la estrategia y tácticas de las pruebas de cuarto limpio son fundamentalmente diferentes a las de los enfoques de prueba convencionales (capítulos del 17 al 20). los métodos convencionales derivan un conjunto de casos de prueba para descubrir errores de diseño y codificación. la meta punto clave para probar que un diseño es correcto, primero deben identificarse todas las condiciones y luego probar que cada una toma el valor booleano adecuado. a éstas se les llama subpruebas.y := y + 1 (y + 1)2 ≤ xy := 0sqrt exit: x no cambia y y2 ≤ x ≤ (y + 1)2yes: (y + 1)2 ≤ xloop: [y2 ≤ x] cont: [y2 ≤ x]init: [x ≥ 0, y y = 0]entry: [x ≥ 0]figura 21.6 cálculo de la parte entera de una raíz cuadradafuente: [lin79]. 21pressman(478-500).indd  48521pressman(478-500).indd  485 19/1/10  12:43:2519/1/10  12:43:25