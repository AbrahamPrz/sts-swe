public string formatcompactedcomparison(string message) { el cuerpo de la instrucción if es donde se realiza la verdadera compactación de las cadenas. debemos extraerlo como método con el nombre compactexpectedandactual . sin embargo, queremos que la función formatcompactedcomparison realice todo el formato. la función compact … sólo debe realizar la compactación [g30], de modo que la dividimos de esta forma: … private string compactexpected; private string compactactual; … public string formatcompactedcomparison(string message) { if (canbecompacted()) { compactexpectedandactual(); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private void compactexpectedandactual () { findcommonprefix(); findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } para ello, hemos tenido que ascender compactexpected y compactactual a variables miembro. no me gusta la forma en que las dos últimas líneas de la nueva función devuelven variables pero las dos primeras no lo hacen. no utilizan convenciones coherentes [g11]. debemos cambiar findcommonprefix y findcommonsuffix para que devuelvan los valores de prefijo y sufijo. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonprefix() { int prefix index = 0; int end = math.min(expected.length(), actual.length()); for (; prefix index < end; prefix index ++) { 329