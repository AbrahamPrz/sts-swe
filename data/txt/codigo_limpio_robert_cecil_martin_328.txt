public String formatCompactedComparison(String message) { El cuerpo de la instrucción  if  es donde se realiza la verdadera compactación de las cadenas. Debemos extraerlo como método con el nombre  compactExpectedAndActual . Sin embargo, queremos que la función formatCompactedComparison  realice todo el formato. La función  compact … sólo debe realizar la compactación [G30], de modo que la dividimos de esta forma: … private String compactExpected; private String compactActual; … public String formatCompactedComparison(String message) { if (canBeCompacted()) { compactExpectedAndActual(); return Assert.format(message, compactExpected, compactActual); } else { return Assert.format(message, expected, actual); } } private void  compactExpectedAndActual () { findCommonPrefix(); findCommonSuffix(); compactExpected = compactString(expected); compactActual = compactString(actual); } Para ello, hemos tenido que ascender  compactExpected  y  compactActual a variables miembro. No me gusta la forma en que las dos últimas líneas de la nueva función devuelven variables pero las dos primeras no lo hacen. No utilizan convenciones coherentes [G11]. Debemos cambiar findCommonPrefix  y  findCommonSuffix  para que devuelvan los valores de prefijo y sufijo. private void compactExpectedAndActual() { prefixIndex  = findCommonPrefix(); suffixIndex  = findCommonSuffix(); compactExpected = compactString(expected); compactActual = compactString(actual); } private  int  findCommonPrefix() { int  prefix Index  = 0; int end = Math.min(expected.length(), actual.length()); for (; prefix Index  < end; prefix Index ++) { 329