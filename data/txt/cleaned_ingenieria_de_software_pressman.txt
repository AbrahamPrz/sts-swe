(-xxx)prelim.indd (-xxx)prelim.indd // ::// :: del software enfoque práctico (-xxx)prelim.indd (-xxx)prelim.indd // ::// ::(-xxx)prelim.indd (-xxx)prelim.indd // ::// :: del software enfoque práctico séptima edición roger . pressman, .. university connecticut méxico • bogotá • buenos aires • caracas • guatemala • madrid nueva york • san juan • santiago • são paulo • auckland • londres • milán montreal • nueva delhi • san francisco • singapur • . louis • sidney • toronto (-xxx)prelim.indd iii(-xxx)prelim.indd iii // ::// :: higher education: miguel ángel toledo castellanos editor sponsor: pablo roig vázquezcoordinadora editorial: marcela . rocha martínezeditora desarrollo: maría teresa zapata terrazassupervisor producción: zeferino garcía garcía traductores: víctor campos olguín javier enríquez brito revisión técnica: carlos villegas quezada bárbaro jorge ferro castro ingeniería del software. enfoque práctico séptima edición prohibida reproducción total parcial esta obra, por cualquier medio, sin autorización escrita del editor. educación derechos reservados © , , respecto tercera edición español pormcgraw-hill interamericana editores, .. .. subsidiary the mcgraw-hill companies, inc. prolongación paseo reforma , torre piso , colonia desarrollo santa , delegación álvaro obregón .. , méxico, . . miembro cámara nacional industria editorial mexicana, reg. núm. isbn: ---- (isbn edición anterior: ---) traducido séptima edición software engineering. practitioner’ approach. published mcgraw-hill, business unit the mcgraw-hill companies, inc., avenue the americas, new york, . copyright © the mcgraw-hill companies, inc. all rights reserved.---- méxico printed mexico (-xxx)prelim.indd (-xxx)prelim.indd // ::// :: recuerdo querido padre, quien vivió años enseñó, sobre todo, que honestidad integridad eran las mejores guías para viaje por vida. (-xxx)prelim.indd (-xxx)prelim.indd // ::// ::(-xxx)prelim.indd (-xxx)prelim.indd // ::// :: del autor roger . pressman una autoridad internacionalmente reconocida mejoramiento del proceso del software las tecnologías ingeniería del mismo. durante casi cuatro décadas trabajado como ingeniero software, gestor, profesor, escritor consultor, especializado temas ingeniería del software. como profesional gestor industrial, doctor pressman trabajó desarrollo sistemas cad/cam para aplicaciones ingeniería fabricación avanzadas. también tenido posicio-nes responsabilidad programación científica sistemas. después recibir doctorado ingeniería por parte universidad connecticut, pressman dedicó academia, donde convirtió profesor asociado cátedra bullard ingeniería cómputo universidad bridgeport, director del centro diseño fabricación asistidos por computadora dicha universidad. actualidad, doctor pressman presidente . . pressman & associates, inc., una empresa consultoría especializada métodos capacitación ingeniería del software. trabaja como consultor principal diseñó desarrolló ingeniería del software esencial, video curricular completo acerca ingeniería del software, consultor procesos, sistema auto- dirigido para mejoramiento del proceso software. ambos productos los utilizan miles compañías todo mundo. más recientemente, trabajó colaboración con edistalearning, india, para desarrollar capacitación abarcadora basada internet acerca ingeniería del software. doctor pressman escrito muchos artículos técnicos, colaborador regular revistas periódicas industriales autor siete libros técnicos. además ingeniería del software: enfoque práctico, coautor web engineering (mcgraw-hill), uno los primeros libros aplicar conjunto personalizado principios prácticas ingeniería del software -sarrollo sistemas aplicaciones basados web. también escribió premiado manager’ guide software engineering (mcgraw-hill); making software engineering happen (prentice hall), primer libro abordar los problemas administrativos cruciales asociados con mejo-ramiento del proceso software; software shock (dorset house), tratamiento que - foca software impacto los negocios sociedad. pressman formado parte los consejos editoriales varias publicaciones industriales durante muchos años fue editor columna “manager” ieee software. además, orador bien conocido, sido orador principal muchas conferencias industriales importantes. miembro ieee, tau beta , phi kappa phi, eta kappa tau sigma. lado personal, pressman vive sur florida con esposa, bárbara. atleta toda vida, sigue siendo serio jugador tenis (. programa estadounidense calificación tenis, ntrp) golfista con handicap solo dígito. tiempo libre escribió dos novelas, aymara bridge the puppeteer, tiene planes para escribir una más. vii (-xxx)prelim.indd vii(-xxx)prelim.indd vii // ::// ::(-xxx)prelim.indd viii(-xxx)prelim.indd viii // ::// :: breve capítulo software ingeniería software parte uno proceso del software capítulo modelos del proceso capítulo desarrollo ágil parte dos modelado capítulo principios que guían práctica comprensión los requerimientos modelado los requerimientos: escenarios, información clases análisis capítulo modelado los requerimientos: flujo, comportamiento, patrones webapps conceptos diseño diseño arquitectura diseño nivel componentes diseño interfaz usuario diseño basado patrones diseño webapps parte tres administración calidad capítulo conceptos calidad técnicas revisión aseguramiento calidad del software estrategias prueba software prueba aplicaciones convencionales prueba aplicaciones orientadas objetos prueba aplicaciones web modelado verificación formal administración configuración del software métricas producto parte cuatro administración proyectos software capítulo conceptos administración proyecto métricas proceso proyecto estimación para proyectos software calendarización del proyecto administración del riesgo mantenimiento reingeniería (-xxx)prelim.indd (-xxx)prelim.indd // ::// :: cinco temas avanzados capítulo mejoramiento del proceso software capítulo tendencias emergentes ingeniería del software comentarios finales apéndice introducción uml apéndice conceptos orientados objeto analítico contenido breve (-xxx)prelim.indd (-xxx)prelim.indd // ::// :: prefacio xxv capítulo software ingeniería software . naturaleza del software .. definición software .. dominios aplicación del software .. software heredado . naturaleza única las webapps . ingeniería software . proceso del software . práctica ingeniería software .. esencia práctica .. principios generales . mitos del software . cómo comienza todo . resumen problemas puntos por evaluar lecturas adicionales fuentes información parte uno proceso del software capítulo modelos del proceso . modelo general proceso .. definición actividad estructural .. identificación conjunto tareas .. patrones del proceso . evaluación mejora del proceso . modelos proceso prescriptivo .. modelo cascada .. modelos proceso incremental .. modelos proceso evolutivo .. modelos concurrentes .. una última palabra acerca los procesos evolutivos . modelos proceso especializado .. desarrollo basado componentes .. modelo métodos formales .. desarrollo software orientado aspectos . proceso unificado .. breve historia .. fases del proceso unificado . modelos del proceso personal del equipo .. proceso personal del software (pps) .. proceso del equipo software (pes) . tecnología del proceso . producto proceso . resumen problemas puntos por evaluar lecturas adicionales fuentes información (-xxx)prelim.indd (-xxx)prelim.indd // ::// :: contenido capítulo desarrollo ágil . ¿qué agilidad? . agilidad costo del cambio . ¿qué proceso ágil? .. principios agilidad .. política del desarrollo ágil .. factores humanos . programación extrema () .. valores .. proceso .. industrial .. debate . otros modelos ágiles proceso .. desarrollo adaptativo software (das) .. scrum .. método desarrollo sistemas dinámicos (mdsd) .. cristal .. desarrollo impulsado por las características (dic) .. desarrollo esbelto software (des) .. modelado ágil () .. proceso unificado ágil (pua) . conjunto herramientas para proceso ágil . resumen problemas puntos por evaluar lecturas adicionales fuentes información parte dos modelado capítulo principios que guían práctica . conocimiento ingeniería software . principios fundamentales .. principios que guían proceso .. principios que guían práctica . principios que guían toda actividad estructural .. principios comunicación .. principios planeación .. principios modelado .. principios construcción .. principios despliegue . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo comprensión los requerimientos . ingeniería requerimientos . establecer las bases .. identificación los participantes .. reconocer los múltiples puntos vista .. trabajar hacia colaboración .. hacer las primeras preguntas . indagación los requerimientos .. recabación los requerimientos forma colaborativa .. despliegue función calidad .. escenarios uso .. indagación los productos del trabajo (-xxx)prelim.indd xii(-xxx)prelim.indd xii // ::// :: xiii . desarrollo casos uso . elaboración del modelo los requerimientos .. elementos del modelo requerimientos .. patrones análisis . requerimientos las negociaciones . validación los requerimientos . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo modelado los requerimientos: escenarios, información clases análisis . análisis los requerimientos .. objetivos filosofía general .. reglas prácticas del análisis .. análisis del dominio .. enfoques del modelado requerimientos . modelado basado escenarios .. creación caso preliminar uso .. mejora caso uso preliminar .. escritura caso uso formal . modelos uml que proporcionan caso uso .. desarrollo diagrama actividades .. diagramas canal (swimlane) . conceptos modelado datos .. objetos datos .. atributos los datos .. relaciones . modelado basado clases .. identificación las clases análisis .. especificación atributos .. definición las operaciones .. modelado clase-responsabilidad-colaborador (crc) .. asociaciones dependencias .. paquetes análisis . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo modelado los requerimientos: flujo, comportamiento, patrones webapps . requerimientos que modelan las estrategias . modelado orientado flujo .. creación modelo flujo datos .. creación modelo flujo control .. especificación control .. especificación del proceso . creación modelo comportamiento .. identificar los eventos con caso uso .. representaciones estado . patrones para modelado requerimientos .. descubrimiento patrones análisis .. ejemplo patrón requerimientos: actuador-sensor . modelado requerimientos para webapps .. ¿cuánto análisis suficiente? .. entrada del modelado los requerimientos (-xxx)prelim.indd xiii(-xxx)prelim.indd xiii // ::// :: contenido .. salida del modelado los requerimientos .. modelo del contenido las webapps .. modelo interacción para webapps .. modelo funcional para las webapps .. modelos configuración para las webapps .. modelado navegación . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo conceptos diseño . diseño contexto ingeniería software . proceso diseño .. lineamientos atributos calidad del software .. evolución del diseño del software . conceptos diseño .. abstracción .. arquitectura .. patrones .. división problemas .. modularidad .. ocultamiento información .. independencia funcional .. refinamiento .. aspectos .. rediseño .. conceptos diseño orientados objeto .. clases diseño . modelo del diseño .. elementos del diseño datos .. elementos del diseño arquitectónico .. elementos diseño interfaz .. elementos del diseño nivel los componentes .. elementos del diseño del despliegue . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo diseño arquitectura . arquitectura del software .. ¿qué arquitectura? .. ¿por qué importante arquitectura? .. descripciones arquitectónicas .. decisiones arquitectónicas . géneros arquitectónicos . estilos arquitectónicos .. breve taxonomía estilos arquitectura .. patrones arquitectónicos .. organización refinamiento . diseño arquitectónico .. representación del sistema contexto .. definición arquetipos .. refinamiento arquitectura hacia los componentes .. descripción las instancias del sistema (-xxx)prelim.indd xiv(-xxx)prelim.indd xiv // ::// :: . evaluación los diseños alternativos para arquitectura .. método negociación para analizar arquitectura .. complejidad arquitectónica .. lenguajes descripción arquitectónica . mapeo arquitectura con uso del flujo datos .. mapeo transformación .. refinamiento del diseño arquitectónico . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo diseño nivel componentes . ¿qué componente? .. una visión orientada objetos .. visión tradicional .. visión relacionada con proceso . diseño componentes basados clase .. principios básicos del diseño .. lineamientos diseño nivel componentes .. cohesión .. acoplamiento . realización del diseño nivel componentes . diseño nivel componentes para webapps .. diseño del contenido nivel componente .. diseño las funciones nivel componentes . diseño componentes tradicionales .. notación gráfica diseño .. notación del diseño tabular .. lenguaje diseño del programa . desarrollo basado componentes .. ingeniería del dominio .. calificación, adaptación combinación los componentes .. análisis diseño para reutilización .. clasificación recuperación componentes . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo diseño interfaz usuario . las reglas doradas .. dejar control usuario .. reducir necesidad que usuario memorice .. hacer consistente interfaz . análisis diseño interfaz usuario .. análisis modelos del diseño interfaz .. proceso . análisis interfaz .. análisis del usuario .. análisis modelado tarea .. análisis del contenido pantalla .. análisis del ambiente trabajo . etapas del diseño interfaz .. aplicación las etapas diseño interfaz .. patrones diseño interfaz usuario .. aspectos del diseño (-xxx)prelim.indd (-xxx)prelim.indd // ::// :: contenido . diseño una interfaz para webapps .. principios lineamientos del diseño interfaz .. flujo trabajos para diseño interfaz webapp . evaluación del diseño . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo diseño basado patrones . patrones diseño .. clases patrones .. estructuras .. descripción patrón .. lenguajes repositorios patrones . diseño software basado patrones .. diseño basado patrones, contexto .. pensar patrones .. tareas diseño .. construcción una tabla para organizar patrón .. errores comunes diseño . patrones arquitectónicos . patrones diseño nivel componentes . patrones diseño interfaz usuario . patrones diseño webapp .. centrarse diseño .. granularidad del diseño . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo diseño webapps . calidad del diseño webapps . metas del diseño . pirámide del diseño webapps . diseño interfaz webapp . diseño estética .. aspectos distribución .. aspectos del diseño gráfico . diseño del contenido .. objetos contenido .. aspectos diseño del contenido . diseño arquitectónico .. arquitectura del contenido .. arquitectura las webapps . diseño navegación .. semántica navegación .. sintaxis navegación . diseño nivel componentes . método diseño hipermedios orientado objetos (mdhoo) .. diseño conceptual del mdhoo .. diseño navegación para mdhoo .. diseño abstracto interfaz implementación . resumen problemas puntos por evaluar lecturas adicionales fuentes información (-xxx)prelim.indd xvi(-xxx)prelim.indd xvi // ::// :: xvii parte tres administración calidad capítulo conceptos calidad . ¿qué calidad? . calidad del software .. dimensiones calidad garvin .. factores calidad mccall .. factores calidad iso .. factores calidad que persiguen .. transición punto vista cuantitativo . dilema calidad del software .. software “suficientemente bueno” .. costo calidad .. riesgos .. negligencia responsabilidad .. calidad seguridad .. efecto las acciones administración . lograr calidad del software .. métodos ingeniería software .. técnicas administración proyectos .. control calidad .. aseguramiento calidad . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo técnicas revisión . efecto los defectos del software costo . amplificación eliminación del defecto . métricas revisión empleo .. análisis las métricas .. eficacia del costo las revisiones . revisiones: espectro formalidad . revisiones informales . revisiones técnicas formales .. reunión revisión .. reporte registro revisión .. lineamientos para revisión .. revisiones orientadas muestreo . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo aseguramiento calidad del software . antecedentes . elementos aseguramiento calidad del software . tareas, metas métricas del acs .. tareas del acs .. metas, atributos métricas . enfoques formales acs . aseguramiento estadístico calidad del software .. ejemplo general .. seis sigma para ingeniería software . confiabilidad del software .. mediciones confiabilidad disponibilidad .. seguridad del software (-xxx)prelim.indd xvii(-xxx)prelim.indd xvii // ::// :: contenido . las normas calidad iso . plan acs . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo estrategias prueba software . enfoque estratégico para prueba software .. verificación validación .. organización las pruebas del software .. estrategia prueba del software. visión general .. criterios para completar las pruebas . aspectos estratégicos . estrategias prueba para software convencional .. prueba unidad .. pruebas integración . estrategias prueba para software orientado objeto .. prueba unidad contexto .. prueba integración contexto . estrategias prueba para webapps . pruebas validación .. criterios pruebas validación .. revisión configuración .. pruebas alfa beta . pruebas del sistema .. pruebas recuperación .. pruebas seguridad .. pruebas esfuerzo .. pruebas rendimiento .. pruebas despliegue . arte depuración .. proceso depuración .. consideraciones psicológicas .. estrategias depuración .. corrección del error . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo prueba aplicaciones convencionales . fundamentos las pruebas del software . visiones interna externa las pruebas . prueba caja blanca . prueba ruta básica .. notación gráfico grafo flujo .. rutas programa independientes .. derivación casos prueba .. matrices grafo . prueba estructura control .. prueba condición .. prueba flujo datos .. prueba bucle . pruebas caja negra .. métodos prueba basados gráficos .. partición equivalencia (-xxx)prelim.indd xviii(-xxx)prelim.indd xviii // ::// :: xix .. análisis valor frontera .. prueba arreglo ortogonal . prueba basada modelo . prueba para entornos, arquitecturas aplicaciones especializados .. pruebas interfaces gráficas usuario .. prueba arquitecturas cliente-servidor .. documentación prueba centros ayuda .. prueba para sistemas tiempo real . patrones para pruebas software . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo prueba aplicaciones orientadas objetos . ampliación definición las pruebas . modelos prueba aoo doo .. exactitud los modelos aoo doo .. consistencia los modelos orientados objetos . estrategias pruebas orientadas objetos .. prueba unidad contexto .. prueba integración contexto .. prueba validación contexto . métodos prueba orientada objetos .. implicaciones del diseño casos prueba los conceptos .. aplicabilidad los métodos convencionales diseño casos prueba .. prueba basada fallo .. casos prueba jerarquía clase .. diseño pruebas basadas escenario .. pruebas las estructuras superficial profunda . métodos prueba aplicables nivel clase .. prueba aleatoria para clases .. prueba partición nivel clase . diseño casos prueba interclase .. prueba clase múltiple .. pruebas derivadas partir modelos comportamiento . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo prueba aplicaciones web . conceptos pruebas para aplicaciones web .. dimensiones calidad .. errores dentro entorno webapp .. estrategia las pruebas .. planificación pruebas . panorama del proceso prueba . prueba contenido .. objetivos prueba contenido .. prueba base datos . prueba interfaz usuario .. estrategia prueba interfaz .. prueba mecanismos interfaz .. prueba semántica interfaz .. pruebas usabilidad .. pruebas compatibilidad . prueba nivel componente (-xxx)prelim.indd xix(-xxx)prelim.indd xix // ::// :: contenido . prueba navegación .. prueba sintaxis navegación .. prueba semántica navegación . prueba configuración .. conflictos lado servidor .. conflictos lado cliente . prueba seguridad . prueba rendimiento .. objetivos prueba rendimiento .. prueba carga .. prueba esfuerzo . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo modelado verificación formal . estrategia cuarto limpio . especificación funcional .. especificación caja negra .. especificación caja estado .. especificación caja clara . diseño cuarto limpio .. refinamiento diseño .. verificación diseño . pruebas cuarto limpio .. pruebas uso estadístico .. certificación . conceptos métodos formales . aplicación notación matemática para especificación formal . lenguajes especificación formal .. lenguaje restricción objeto (ocl) .. lenguaje especificación . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo administración configuración del software . administración configuración del software .. escenario acs .. elementos sistema administración configuración .. líneas referencia .. ítems configuración del software . repositorio acs .. papel del repositorio .. características contenido generales .. características acs . proceso acs .. identificación objetos configuración del software .. control versión .. control cambio .. auditoría configuración .. reporte estado . administración configuración para webapps .. conflictos dominantes .. objetos configuración webapps .. administración contenido (-xxx)prelim.indd (-xxx)prelim.indd // ::// :: xxi .. administración del cambio .. control versión .. auditoría reporte . resumen problemas puntos por evaluar lecturas adicionales fuentes información capítulo métricas producto . marco conceptual para las métricas producto .. medidas, métricas indicadores .. reto métrica producto .. principios medición .. medición software orientado meta .. atributos las métricas software efectivas . métricas para modelo requerimientos .. métrica basada funciones .. métricas para calidad especificación . métricas para modelo diseño .. métricas del diseño arquitectónico .. métricas para diseño orientado objetos .. métricas orientadas clase: suite métricas .. métricas orientadas clase: suite métricas mood .. métricas propuestas por lorenz kidd .. métricas diseño nivel componente .. métricas orientadas operación .. métricas diseño interfaz usuario . métricas diseño para webapps . métricas para código fuente . métricas para pruebas .. métricas halstead aplicadas para probar .. métricas para pruebas orientadas objetos . métricas para mantenimiento . resumen problemas puntos por evaluar lecturas fuentes información adicionales parte cuatro administración proyectos software capítulo conceptos administración proyecto . espectro administrativo .. personal .. producto .. proceso .. proyecto . personal .. los participantes .. líderes equipo .. equipo software .. equipos ágiles .. conflictos coordinación comunicación . producto .. ámbito del software .. descomposición del problema . proceso .. fusión producto proceso .. descomposición del proceso (-xxx)prelim.indd xxi(-xxx)prelim.indd xxi // ::// :: contenido . proyecto . principio . prácticas cruciales . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo métricas proceso proyecto . métricas los dominios proceso proyecto .. las métricas del proceso mejora del proceso software .. métricas proyecto . medición del software .. métricas orientadas tamaño .. métricas orientadas función .. reconciliación métricas loc .. métricas orientadas objeto .. métricas orientadas caso uso .. métricas proyecto webapp . métricas para calidad software .. medición calidad .. eficiencia remoción del defecto . integración métricas dentro del proceso software .. argumentos para métricas software .. establecimiento una línea referencia .. recolección, cálculo evaluación métricas . métricas para organizaciones pequeñas . establecimiento programa métricas del software . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo estimación para proyectos software . observaciones acerca las estimaciones . proceso planificación del proyecto . ámbito factibilidad del software . recursos .. recursos humanos .. recursos software reutilizables .. recursos ambientales . estimación proyectos software . técnicas descomposición .. dimensionamiento del software .. estimación basada problema .. ejemplo estimación basada loc .. ejemplo estimación basada .. estimación basada proceso .. ejemplo estimación basada proceso .. estimación con casos uso .. ejemplo estimación basada caso uso .. reconciliación estimaciones . modelos estimación empíricos .. estructura los modelos estimación .. modelo cocomo .. ecuación del software (-xxx)prelim.indd xxii(-xxx)prelim.indd xxii // ::// :: xxiii . estimación para proyectos orientados objetos . técnicas estimación especializadas .. estimación para desarrollo ágil .. estimación para webapp . decisión hacer/comprar .. creación árbol decisión .. outsourcing . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo calendarización del proyecto . conceptos básicos . calendarización del proyecto .. principios básicos .. relación entre personal esfuerzo .. distribución esfuerzo . definición conjunto tareas para proyecto software .. ejemplo conjunto tareas .. refinamiento acciones ingeniería del software . definición una red tareas . calendarización .. cronogramas .. seguimiento del calendario .. seguimiento del progreso para proyecto .. calendarización para proyectos webapp . análisis valor ganado . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo administración del riesgo . estrategias reactivas riesgo frente estrategias proactivas riesgo . riesgos software . identificación riesgos .. valoración del riesgo proyecto global .. componentes promotores riesgo . proyección del riesgo .. elaboración una lista riesgos .. valoración impacto riesgo . refinamiento del riesgo . mitigación, monitoreo manejo riesgo . plan mmmr . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo mantenimiento reingeniería . mantenimiento software . soportabilidad del software . reingenería . reingeniería procesos empresa .. procesos empresariales .. modelo rpe (-xxx)prelim.indd xxiii(-xxx)prelim.indd xxiii // ::// :: contenido . reingeniería software .. modelo proceso reingeniería software .. actividades reingeniería software . ingeniería inversa .. ingeniería inversa para comprender datos .. ingeniería inversa para entender procesamiento .. ingeniería inversa interfaces usuario . reestructuración .. reestructuración código .. reestructuración datos . ingeniería hacia adelante .. ingeniería hacia adelante para arquitecturas cliente-servidor .. ingeniería hacia adelante para arquitecturas orientadas objetos . economía reingeniería . resumen problemas puntos por evaluar lecturas fuentes información adicionales parte cinco temas avanzados capítulo mejoramiento del proceso software . ¿qué mps? .. enfoques del mps .. modelos madurez .. ¿ mps para todos? . proceso mps .. valoración análisis desviación .. educación capacitación .. selección justificación .. instalación/migración .. evaluación .. gestión del riesgo para mps .. factores éxito cruciales . cmmi . cmm personal . otros marcos conceptuales mps . rendimiento sobre inversión mps . tendencias mps . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo tendencias emergentes ingeniería del software . evolución tecnológica . observación las tendencias ingeniería del software . identificación “tendencias blandas” .. administración complejidad .. software mundo abierto .. requerimientos emergentes .. mezcla talento .. bloques constructores software .. cambio percepciones “valor” .. fuente abierta . direcciones tecnología .. tendencias proceso .. gran desafío (-xxx)prelim.indd xxiv(-xxx)prelim.indd xxiv // ::// :: xxv .. desarrollo colaborativo .. ingeniería requerimientos .. desarrollo software impulsado por modelo .. diseño posmoderno .. desarrollo impulsado por pruebas . tendencias relacionadas con herramientas .. herramientas que responden tendencias blandas .. herramientas que abordan tendencias tecnológicas . resumen problemas puntos por evaluar lecturas fuentes información adicionales capítulo comentarios finales . importancia del software-revisión . las personas forma que construyen sistemas . nuevos modos para representar información . vista larga . responsabilidad del ingeniero software . comentario final apéndice introducción uml apéndice conceptos orientados objeto analítico (-xxx)prelim.indd xxv(-xxx)prelim.indd xxv // ::// ::(-xxx)prelim.indd xxvi(-xxx)prelim.indd xxvi // ::// :: software computadora triunfa ( satisfacer las necesidades las personas que usan, trabajar sin fallos durante largos periodos, será fácil modificar incluso más fácil usar) puede debe cambiar las cosas fin mejorar. pero cuando soft- ware fracasa (cuando sus usuarios están satisfechos, proclive error, difícil cambiar incluso más difícil usar) pueden ocurrir, ocurren, cosas malas. todo mundo quiere cons-truir software que haga mejor las cosas que evite las malas que acechan sombra los esfuerzos fallidos. para triunfar, necesita disciplina momento diseñar construir software. necesario enfoque ingeniería. han pasado casi tres décadas desde que escribió primera edición este libro. durante ese tiempo, ingeniería del software evolucionó desde una oscura idea practicada por -mero relativamente pequeño fanáticos hasta una legítima disciplina ingeniería. actualidad, reconoce como una materia merecedora investigación seria, estudio con-cienzudo debate turbulento. largo toda industria, ingeniero software sustituyó programador como título laboral preferencia. los modelos proceso software, los métodos ingeniería software las herramientas del software adoptaron exitosamente través amplio espectro segmentos industriales. aunque los gestores profesionales reconocen por igual necesidad enfoque del software más disciplinado, continúan debatiendo forma que disciplina debe aplicarse. muchos individuos compañías todavía desarrollan software manera fortuita, incluso cuando construyen sistemas para atender las tecnologías más avanzadas actualidad. -chos profesionales estudiantes están conscientes los métodos modernos. como resul-tado, calidad del software que producen deficiente ocurren cosas malas. además, conti-núa debate controversia torno verdadera naturaleza del enfoque ingeniería del software. estatus ingeniería del software estudio contrastes. las actitudes han cambiado, progresado, pero todavía falta mucho por hacer antes que disciplina alcance madurez plena. séptima edición ingeniería del software: enfoque práctico tiene intención funcio- nar como guía hacia una disciplina ingeniería que madura. como las seis ediciones que precedieron, séptima dirige estudiantes profesionales, conserva atractivo como guía para profesional industrial como introducción abarcadora para estudiante los niveles superiores pregrado primer año graduado. séptima edición considerablemente más que una simple actualización. libro revisó reestructuró para mejorar flujo pedagógico enfatizar nuevos importantes procesos prácticas ingeniería del software. además, este texto cuenta con paquete comple-mentos, los cuales están disponibles para los profesores que adopten. consulte con repre-sentante mcgraw-hill local. séptima edición. los capítulos séptima edición reorganizaron cinco partes. esta organización, que difiere considerablemente sexta edición, realizó para dividir mejor los temas ayudar los profesores que tal vez tengan tiempo para completar todo libro semestre. parte , proceso, presenta varias visiones diferentes del proceso software, considera todos los modelos proceso importantes aborda debate entre las filosofías proceso prefacio xxvii (-xxx)prelim.indd xxvii(-xxx)prelim.indd xxvii // ::// :: ágil. parte , modelado, presenta los métodos análisis diseño con énfasis las técnicas orientadas objeto modelado uml. también considera diseño basa- patrón diseño para aplicaciones web. parte , gestión calidad, presenta los conceptos, procedimientos, técnicas métodos que permiten equipo software valorar calidad del software, revisar los productos trabajo ingeniería del software, realizar procedimientos sqa aplicar una estrategia tácticas prueba efectivas. además, también considera modelado formal los métodos verificación. parte , gestión proyectos software, presenta temas que son relevantes quienes planean, gestionan controlan pro-yecto desarrollo software. parte , temas avanzados, considera mejoramiento del proceso software las tendencias ingeniería del software. continuar con tradición las ediciones pasadas, largo del libro usa una serie recuadros para presentar las experiencias tribulaciones equipo software (ficticio) para proporcionar materiales complementarios acerca los métodos herramientas que son relevantes para los temas del capítulo. dos nuevos apéndices proporcionan breves tutoriales acerca del uml del pensa-miento orientado objeto para quienes estén familiarizados con estos importantes temas. organización cinco partes séptima edición permite profesor “englobar” los - mas con base tiempo disponible las necesidades del estudiante. curso todo semestre podría construirse torno uno más las cinco partes. uno evaluación ingeniería del software seleccionaría capítulos las cinco. uno ingeniería del software que enfatice análisis diseño elegiría temas las partes . curso ingeniería del soft-ware orientado pruebas seleccionaría temas las partes , con una breve incursión parte . “curso administrativo” subrayaría las partes . reconocimientos. trabajo las siete ediciones ingeniería del software: enfoque prác- tico sido proyecto técnico continuo más largo vida. aun cuando escritura cesó, información extraída literatura técnica continúa asimilándose organizándose, las críti-cas sugerencias los lectores todo mundo evalúan catalogan. por esta razón, agradezco los muchos autores libros, ponencias artículos (tanto copia dura como medios electrónicos) que han proporcionado comprensión, ideas comentarios adicionales durante casi años. agradezco especialmente tim lethbridge, universidad ottawa, quien auxilió desarrollo los ejemplos uml ocl, quien desarrolló estudio caso que acompaña este libro, dale skrien, colby college, quien desarrolló tutorial uml apéndice . asistencia sus comentarios fueron invaluables. agradecimiento especial también para bruce maxim, universidad michigan-dearborn, quien auxilió desarrollo gran parte del contenido pedagógico sitio web que acompaña este libro. finalmente, quiero agradecer los revisores séptima edición: sus comentarios profundidad críticas bien pensadas han sido invaluables. osman balci, virginia tech university max fomitchev, penn state university jerry (zeyu) gao, san jose state university guillermo garcia, universidad alfonso madrid pablo gervas, universidad complutense madridsk jain, national institute technology hamirpur saeed monemi, cal poly pomona ahmed salem, california state university vasudeva varma, iiit hyderabad contenido séptima edición ingeniería del software: enfoque práctico fue confor- mado por profesionales industria, profesores universitarios estudiantes, quienes usaron ediciones anteriores del libro tomaron tiempo para comunicar sus sugerencias, críticas ideas. xxviii prefacio (-xxx)prelim.indd xxviii(-xxx)prelim.indd xxviii // ::// :: agradecimiento cada uno ustedes. además, reconocimiento personal nuestros muchos clientes industriales todo mundo, quienes, ciertamente, enseñaron tanto más que podría haberles enseñado algún momento. conforme las ediciones este libro evolucionaban, mis hijos, mathew michael, crecieron niños hombres. madurez, carácter éxito mundo real han sido una inspiración para . nada llenado más orgullo. finalmente, bárbara, amor agradecimiento por tolerar las muchísimas horas oficina por alentar todavía otra edición “ libro”. roger . pressmanprefacio xxix (-xxx)prelim.indd xxix(-xxx)prelim.indd xxix // ::// ::(-xxx)prelim.indd xxx(-xxx)prelim.indd xxx // ::// :: software ingeniería software conceptos clave actividades estructurales . . . . actividades sombrilla. . . . . . . del software . . . aplicación . . . . . . . software . . . . . del software . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . del software. . . . . . . heredado . . . . . . . . . . . . . . . . . . . . . . . . . ¿qué ? software computadora producto que construyen los programadores profesionales que después dan manteni-miento durante largo tiempo. incluye pro- gramas que ejecutan una computadora cual-quier tamaño arquitectura, contenido que presenta medida que ejecutan los programas cómputo información descriptiva tanto una copia dura como formatos virtuales que engloban virtualmente cualesquie- medios electrónicos. ingeniería software está for-mada por proceso, conjunto métodos (prácticas) arreglo herramientas que permite los profesiona-les elaborar software cómputo alta calidad. ¿quién hace? los ingenieros software elaboran dan mantenimiento software, virtualmente cada perso- emplea mundo industrializado, sea forma directa indirecta. ¿por qué importante? software importante por- que afecta casi todos los aspectos nuestras vidas invadido nuestro comercio, cultura actividades cotidia-nas. ingeniería software importante porque nos permite construir sistemas complejos tiempo razona-ble con alta calidad. ¿cuáles son los pasos? software computadora construye del mismo modo que cualquier producto exitoso, con aplicación proceso ágil adaptable para obtener resultado mucha calidad, que satisfaga las necesidades las personas que usarán producto. estos pasos aplica enfoque ingeniería soft-ware. ¿cuál producto final? desde punto vista ingeniero software, producto final conjunto programas, contenido (datos) otros productos termi-nados que constituyen software computadora. pero desde perspectiva del usuario, producto final información resultante que algún modo hace mejor mundo que vive. ¿cómo aseguro que hice bien? lea resto este libro, seleccione aquellas ideas que sean aplicables software que usted hace aplíquelas trabajo. una mirada rápidatenía apariencia clásica alto ejecutivo una compañía importante software — mitad los , con las sienes comenzando encanecer, esbelto atlético, con ojos que penetraban observador mientras hablaba—. pero que dijo dejó anona- dado. “ software muerto”. pestañeé con sorpresa sonreí. “bromeas, ¿verdad? mundo dirigido con software empresa beneficiado mucho ello. ¡ muerto! está vivo desarrollo.” movió cabeza manera enfática. “, está muerto… menos como conocimos.” apoyé escritorio. “continúa.”habló tiempo que golpeaba mesa con énfasis. “ concepto antiguo del software — compras, posees trabajo consiste administrarlo— está llegando fin. hoy día, con web . computación ubicua cada vez más fuerte, vamos ver una generación software por completo diferente. distribuirá por internet verá exactamente como estuviera ins-talado equipo cómputo cada usuario… pero encontrará servidor remoto.” tuve que estar acuerdo. “entonces, vida será mucho más sencilla. tus muchachos tendrán que preocuparse por las cinco diferentes versiones misma app que utilizan dece-nas miles usuarios.” sonrió. “absolutamente. sólo versión más reciente estará nuestros servidores. cuando hagamos cambio corrección, actualizaremos funcionalidad contenido cada usuario. todos tendrán forma instantánea…” hice una mueca. “pero cometes error, todos tendrán también instantáneamente”. rió entre dientes. “ verdad, por eso estamos redoblando nuestros esfuerzos para hacer una ingeniería software aún mejor. problema que tenemos que hacerlo ‘rápido’ porque mercado acelerado cada área aplicación.” (-).indd (-).indd // ::// :: capítulo software ingeniería software ¿está muerto realmente software? estuviera, usted estaría leyendo este libro… software computadora sigue siendo tecnología más importante escena mundial. también ejemplo magnífico ley las consecuencias inesperadas. hace años, nadie hubiera podido predecir que software convertiría una tecnología indispensable para los negocios, ciencias ingeniería, que permitiría creación tecnologías nuevas (por ejemplo, ingeniería genética nanotecnología), ampliación tecnologías existentes (-lecomunicaciones) cambio radical tecnologías antiguas ( industria impresión); tampoco que software sería fuerza que impulsaría revolución las computadoras per-sonales, que productos software empacados comprarían los supermercados, que software evolucionaría poco poco producto servicio cuando compañías software “sobre pedido” proporcionaran funcionalidad justo tiempo través navegador web, que una compañía software sería más grande tendría más influencia que casi todas las empre-sas era industrial, que una vasta red llamada internet sería operada con software evolu-cionaría cambiaría todo, desde investigación bibliotecas compra productos para consumidor hasta discurso político los hábitos encuentro los adultos jóvenes ( tan jóvenes). nadie pudo prever que habría software incrustado sistemas toda clase: transporte, médicos, telecomunicaciones, militares, industriales, entretenimiento, máquinas oficina… lista casi infinita. usted cree ley las consecuencias inesperadas, hay muchos efectos que aún podemos predecir. nadie podía anticipar que millones programas computadora tendrían que ser corregi- dos, adaptados mejorados medida que transcurriera tiempo. que carga ejecutar estas actividades “mantenimiento” absorbería más personas recursos que todo trabajo aplicado creación software nuevo. conforme aumentado importancia del software, comunidad programadores tratado continuamente desarrollar tecnologías que hagan más fácil, rápida barata elabo-ración programas cómputo alta calidad. algunas estas tecnologías dirigen dominio específico aplicaciones (por ejemplo, diseño implantación sitio web), otras centran dominio tecnológico (sistemas orientados objetos programación orientada aspectos), otros más tienen una base amplia (sistemas operativos, como linux). sin embargo, todavía falta por desarrollarse una tecnología software que haga todo esto, hay pocas pro-babilidades que surja una futuro. pesar ello, las personas basan sus trabajos, confort, seguridad, diversiones, decisiones sus propias vidas software computadora. más vale que esté bien hecho. este libro presenta una estructura que puede ser utilizada por aquellos que hacen software cómputo —personas que deben hacerlo bien—. estructura incluye proceso, conjunto métodos unas herramientas que llamamos ingeniería software. . naturaleza del software actualidad, software tiene papel dual. producto mismo tiempo -hículo para entregar producto. forma producto, brinda potencial cómputo -corporado hardware cómputo , con más amplitud, una red computadoras las recargué espalda coloqué mis manos nuca. “ sabes que dice… pue- des tenerlo rápido bien hecho barato. escoge dos estas características…” “elijo rápido bien hecho”, dijo mientras comenzaba levantarse.también incorporé. “entonces realmente necesitas ingeniería software.”“ ”, dijo mientras salía. “ problema que tenemos que llegar convencer otra generación más técnicos que así …” cita: “las ideas los descubrimientos tecnológicos son los motores que impulsan crecimiento econó-mico.” wall street journal (-).indd (-).indd // ::// :: software ingeniería software que accede por medio hardware local. sea que resida teléfono móvil opere interior una computadora central, software transformador información—produce, administra, adquiere, modifica, despliega transmite información que puede ser tan simple como solo bit tan compleja como una presentación con multimedios generada partir datos obtenidos decenas fuentes independientes—. como vehículo utilizado para distribuir producto, software actúa como base para control computadora (siste-mas operativos), para comunicación información (redes) para creación control otros programas (herramientas ambientes software). software distribuye producto más importante nuestro tiempo: información. trans- forma los datos personales (por ejemplo, las transacciones financieras individuo) modo que puedan ser más útiles contexto local, administra información negocios para mejorar competitividad, provee una vía para las redes mundiales información ( internet) brinda los medios para obtener información todas sus formas. último medio siglo, papel del software cómputo sufrido cambio significativo. las notables mejoras funcionamiento del hardware, los profundos cambios las arqui-tecturas computadora, gran incremento memoria capacidad almacenamiento, una amplia variedad opciones entradas salidas exóticas han propiciado existencia sistemas basados computadora más sofisticados complejos. cuando sistema tiene éxito, sofisticación complejidad producen resultados deslumbrantes, pero también plantean pro-blemas enormes para aquellos que deben construir sistemas complejos. actualidad, enorme industria del software convertido factor dominante las economías del mundo industrializado. equipos especialistas software, cada uno centrado una parte tecnología que requiere para llegar una aplicación compleja, han reemplazado programador solitario los primeros tiempos. pesar ello, las pregun-tas que hacía aquel programador son las mismas que surgen cuando construyen sistemas modernos basados computadora: • ¿por qué requiere tanto tiempo para terminar software? • ¿por qué son tan altos los costos desarrollo? • ¿por qué podemos detectar todos los errores antes entregar software nuestros clientes? • ¿por qué dedicamos tanto tiempo esfuerzo mantener los programas existentes? • ¿por qué seguimos con dificultades para medir avance mientras desarrolla mantiene software? éstas muchas otras preguntas, denotan preocupación sobre software manera que desarrolla, preocupación que llevado adopción práctica ingeniería del software. .. definición software actualidad, mayoría profesionales muchos usuarios tienen fuerte sensación que entienden software. pero, ¿ así? descripción que daría libro texto sobre software sería más menos así: software : ) instrucciones (programas cómputo) que cuando ejecutan proporcionan las características, función desempeño buscados; ) estructuras datos que permiten que los progra-punto clave software tanto producto como vehículo para entregar producto. cita: “ software lugar donde siembran sueños cose-chan pesadillas, una ciénega abstracta mística que terribles demonios luchan contra panaceas mágicas, mundo hombres lobo balas plata.” brad . cox excelente libro ensayos sobre negocio del software, tom demarco [dem] defiende punto vista contrario. dice: “ lugar preguntar por qué software cuesta tanto, necesitamos comenzar preguntar: ¿qué hemos hecho para hacer posible que software actual cueste tan poco? respuesta esa pregunta nos ayudará continuar extraordinario nivel logro que siempre distinguido industria del software.”¿cómo define software?? (-).indd (-).indd // ::// :: capítulo software ingeniería software mas manipulen forma adecuada información, ) información descriptiva tanto papel como formas virtuales que describen operación uso los programas. hay duda que podrían darse definiciones más completas. pero probable que una definición más formal mejore manera apreciable nuestra comprensión. para asimilar anterior, importante examinar las características del software que hacen diferente otros objetos que construyen los seres humanos. software ele-mento sistema lógico uno físico. por tanto, tiene características que difieren con-siderablemente las del hardware: . software desarrolla modifica con intelecto; manufactura sentido clásico. unque hay algunas similitudes entre desarrollo software fabricación hard- ware, las dos actividades son diferentes fundamental. ambas, alta calidad logra través buen diseño, pero fase manufactura del hardware introduce problemas calidad que existen ( que corrigen con facilidad) software. ambas actividades dependen personas, pero relación entre los individuos dedica-dos trabajo logrado diferente por completo (véase capítulo ). las dos activi-dades requieren construcción “producto”, pero los enfoques son distintos. los costos del software concentran ingeniería. esto significa que los proyectos software pueden administrarse como fueran proyectos manufactura. . software “desgasta”. figura . ilustra tasa falla del hardware como función del tiempo. relación, que frecuente llamar “curva tina”, indica que hardware presenta una tasa -llas relativamente elevada una etapa temprana vida (fallas que con frecuencia son atribuibles defectos diseño manufactura); los defectos corrigen tasa fallas abate nivel estable (muy bajo, por fortuna) durante cierto tiempo. obstante , conforme pasa tiempo, tasa fallas aumenta nuevo medida que los componentes del hardware resienten los efectos acumulativos suciedad, vibración, abuso, temperaturas extremas muchos otros inconvenientes ambientales. pocas palabras, hardware comienza desgastarse. software susceptible los problemas ambientales que hacen que hard- ware desgaste. por tanto, teoría, curva tasa fallas adopta forma “curva idealizada” que aprecia figura .. los defectos ocultos ocasionarán -punto clave software modifica con intelecto, manufactura. “desgaste” “mortalidad infantil” tiempotasa fallafigura . curva fallas del hardwarepunto clave software desgasta, pero deteriora. (-).indd (-).indd // ::// :: software ingeniería software sas elevadas fallas comienzo vida programa. sin embargo, éstas - rrigen curva aplana, como indica. curva idealizada una gran simplifica-ción los modelos reales las fallas del software. aun así, implicación está clara: software desgasta, ¡pero deteriora! esta contradicción aparente entiende mejor considera curva real - gura .. durante vida, software sufrirá cambios. probable que cuando éstos realicen, introduzcan errores que ocasionen que curva tasa fallas tenga -mentos súbitos, como ilustra “curva real” (véase figura .). antes que curva vuelva tasa fallas original estado estable, surge solicitud otro cambio que hace que curva dispare otra vez. poco poco, nivel mínimo tasa fallas comienza aumentar: software está deteriorando como consecuen-cia del cambio. otro aspecto del desgaste ilustra diferencia entre hardware software. cuando componente del hardware desgasta sustituido por una refacción. cambio, hay refacciones para software. cada falla éste indica error -seño proceso que tradujo diseño código ejecutable por máquina. enton-ces, las tareas mantenimiento del software, que incluyen satisfacción peticio-nes cambios, involucran una complejidad considerablemente mayor que mantenimiento del hardware. . aunque industria mueve hacia construcción basada componentes, mayor parte del software construye para uso individualizado. medida que evoluciona una disciplina ingeniería, crea conjunto compo- nentes estandarizados para diseño. los tornillos estándar los circuitos integrados preconstruidos son sólo dos los miles componentes estándar que utilizan los -genieros mecánicos eléctricos conforme diseñan nuevos sistemas. los componentes reutilizables han sido creados para que ingeniero pueda concentrarse los elemen-tos verdaderamente innovadores diseño; decir, las partes éste que repre-sentan algo nuevo. mundo del hardware, volver usar componentes una parte quiere reducir deterioro del software, tendrá que mejorar diseño (capítulos ).consejotasa fallas incrementada debido efectos colaterales tiempotasa fallascambio curva real curva idealizadafigura . curvas falla del software realidad, los distintos participantes solicitan cambios desde momento que comienza desarrollo mucho antes que disponga primera versión.punto clave los métodos ingeniería software llevan reducir magnitud los picos pendiente curva real figura .. cita: “las ideas son los ladrillos con los que construyen las ideas.” jason zebehazy (-).indd (-).indd // ::// :: capítulo software ingeniería software natural del proceso ingeniería. del software, algo que apenas empezado hacerse gran escala. componente software debe diseñarse implementarse modo que pueda volverse usar muchos programas diferentes. los modernos componentes reutiliza-bles incorporan tanto los datos como procesamiento que les aplica, que permite que ingeniero software cree nuevas aplicaciones partir partes susceptibles volverse usar. por ejemplo, las actuales interfaces interactivas usuario constru- yen con componentes reutilizables que permiten creación ventanas gráficas, -nús desplegables una amplia variedad mecanismos interacción. las estructuras datos detalle procesamiento que requieren para construir interfaz están contenidos una librería componentes reusables para tal fin. .. dominios aplicación del software actualmente, hay siete grandes categorías software computadora que plantean retos continuos los ingenieros software: software sistemas: conjunto programas escritos para dar servicio otros progra-mas. determinado software sistemas (por ejemplo, compiladores, editores herramien-tas para administrar archivos) procesa estructuras información complejas pero determi-nistas. otras aplicaciones sistemas (por ejemplo, componentes sistemas operativos, manejadores, software redes, procesadores telecomunicaciones) procesan sobre todo datos indeterminados. cualquier caso, área software sistemas caracteriza por: gran interacción con hardware computadora, uso intensivo por parte usua-rios múltiples, operación concurrente que requiere secuenciación, recursos compartidos administración proceso sofisticado, estructuras complejas datos interfaces -ternas múltiples. software aplicación: programas aislados que resuelven una necesidad específica negocios. las aplicaciones esta área procesan datos comerciales técnicos una forma que facilita las operaciones negocios toma decisiones administrativas técnicas. además las aplicaciones convencionales procesamiento datos, soft-ware aplicación usa para controlar funciones negocios tiempo real (por ejem-plo, procesamiento transacciones punto venta, control procesos manufac-tura tiempo real). software ingeniería ciencias: caracterizado por algoritmos “devoradores números”. las aplicaciones van astronomía vulcanología, del análisis tensio-nes automóviles dinámica orbital del transbordador espacial, biología -lecular manufactura automatizada. sin embargo, las aplicaciones modernas dentro del área ingeniería las ciencias están abandonando los algoritmos numéricos conven-cionales. diseño asistido por computadora, simulación sistemas otras aplicacio-nes interactivas, han comenzado hacerse tiempo real incluso han tomado caracterís-ticas del software sistemas. software incrustado: reside dentro producto sistema usa para implementar controlar características funciones para usuario final para sistema . software incrustado ejecuta funciones limitadas particulares (por ejemplo, control del tablero horno microondas) provee una capacidad significativa funcionamiento control desarrollo basado componentes estudia capítulo . software determinista posible predecir orden momento las entradas, procesamiento las salidas. software determinista pueden predecirse orden momento que ocurren éstos.webref dirección shareware.cnet. com encuentra una las librerías más completas software compartido libre. (-).indd (-).indd // ::// :: software ingeniería software (funciones digitales automóvil, como control del combustible, del tablero con- trol los sistemas frenado). software línea productos: diseñado para proporcionar una capacidad especí- fica para uso muchos consumidores diferentes. software línea productos centra algún mercado limitado particular (por ejemplo, control del inventario pro-ductos) dirige mercados masivos consumidores (procesamiento textos, hojas cálculo, gráficas por computadora, multimedios, entretenimiento, administración base datos aplicaciones para finanzas personales negocios). aplicaciones web: llamadas “webapps”, esta categoría software centrado redes agrupa una amplia gama aplicaciones. forma más sencilla, las webapps son poco más que conjunto archivos hipertexto vinculados que presentan información con uso texto gráficas limitadas. sin embargo, desde que surgió web ., las webapps - tán evolucionando hacia ambientes cómputo sofisticados que sólo proveen caracte-rísticas aisladas, funciones cómputo contenido para usuario final, sino que también están integradas con bases datos corporativas aplicaciones negocios. software inteligencia artificial: hace uso algoritmos numéricos para resolver problemas complejos que son fáciles tratar computacionalmente con análisis -recto. las aplicaciones esta área incluyen robótica, sistemas expertos, reconocimiento patrones (imagen voz), redes neurales artificiales, demostración teoremas juegos. son millones ingenieros software todo mundo los que trabajan duro proyectos software una más estas categorías. ciertos casos elaboran sistemas nuevos, pero muchos otros corrigen, adaptan mejoran aplicaciones existentes. raro que una joven ingeniera software trabaje programa mayor edad que ella… las genera-ciones pasadas los trabajadores del software dejaron legado cada una las categorías mencionadas. por fortuna, herencia que dejará actual generación aligerará carga los futuros ingenieros software. aun así, nuevos desafíos (capítulo ) han aparecido hori-zonte. computación mundo abierto: rápido crecimiento las redes inalámbricas quizá lleve pronto computación verdaderamente ubicua distribuida. reto para los ingenieros software será desarrollar software sistemas aplicación que permita dispositivos móviles, computadoras personales sistemas empresariales comunicarse través redes enormes. construcción redes: red mundial (world wide web) está convirtiendo con rapi- dez tanto motor computación como proveedor contenido. desafío para los ingenieros software hacer arquitecturas sencillas (por ejemplo, planeación -nanciera personal aplicaciones sofisticadas que proporcionen beneficio mercados objetivo usuarios finales todo mundo). fuente abierta: tendencia creciente que como resultado distribución código fuente para aplicaciones sistemas (por ejemplo, sistemas operativos, bases datos ambientes desarrollo) modo que mucha gente pueda contribuir desarrollo. -safío para los ingenieros software elaborar código fuente que sea autodescriptivo, también, que más importante, desarrollar técnicas que permitirán tanto los consu-midores como los desarrolladores saber cuáles son los cambios hechos cómo mani-fiestan dentro del software. indudable que cada uno estos nuevos retos obedecerá ley las consecuencias -previstas tendrá efectos (para hombres negocios, ingenieros software usuarios finales) que hoy pueden predecirse. sin embargo, los ingenieros software pueden prepararse -cita: “ hay computadora que tenga sentido común.” marvin minsky cita: “ siempre puedes predecir, pero siempre puedes prepararte.” anónimo (-).indd (-).indd // ::// :: capítulo software ingeniería software sarrollando proceso que sea ágil suficientemente adaptable para que acepte los cambios profundos tecnología las reglas los negocios que seguramente surgirán década siguiente. .. software heredado cientos miles programas cómputo caen uno los siete dominios amplios apli-cación que estudiaron subsección anterior. algunos ellos son software muy nuevo, disponible para ciertos individuos, industria gobierno. pero otros programas son más viejos, ciertos casos muy viejos. estos programas antiguos —que frecuente denominar software heredado — han sido centro atención preocupación continuas desde década . dayani-fard sus colegas [day] describen software heredado manera siguiente: los sistemas software heredado […] fueron desarrollados hace varias décadas han sido modifi- cados manera continua para que satisfagan los cambios los requerimientos los negocios plataformas computación. proliferación tales sistemas causa dolores cabeza para las organizaciones grandes, las que resulta costoso mantenerlos riesgoso hacerlos evolucionar. liu sus colegas [liu] amplían esta descripción hacer notar que “muchos sistemas hereda- dos continúan siendo apoyo para las funciones básicas del negocio son ‘indispensables’ para éste”. además, software heredado caracteriza por longevidad importancia críti- para negocio. desafortunadamente, ocasiones hay otra característica presente software heredado: mala calidad . hay veces las que los sistemas heredados tienen diseños que son suscepti- bles extenderse, código confuso, documentación mala inexistente, casos resultados pruebas que nunca archivaron, una historia los cambios mal administrada… lista muy larga. pesar esto, dichos sistemas dan apoyo las “funciones básicas del negocio son indispensables para éste”. ¿qué hacer? única respuesta razonable : hacer nada, menos hasta que sistema heredado tenga cambio significativo. software heredado satisface las necesidades sus usuarios corre manera confiable, entonces falla necesita repararse. sin embargo, conforme pase tiempo será frecuente que los sistemas software evolucionen por una varias las -guientes razones: • software debe adaptarse para que cumpla las necesidades los nuevos ambientes del cómputo tecnología. • software debe ser mejorado para implementar nuevos requerimientos del negocio. • software debe ampliarse para que sea operable con otros sistemas bases datos modernos. • arquitectura del software debe rediseñarse para hacerla viable dentro ambiente redes. cuando ocurren estos modos evolución, debe hacerse reingeniería del sistema heredado (capítulo ) para que sea viable futuro. meta ingeniería software moderna “desarrollar metodologías que basen concepto evolución; decir, concepto que los sistemas software cambian continuamente, que los nuevos sistemas software este caso, calidad juzga con base pensamiento moderno ingeniería software, criterio algo injusto, que algunos conceptos principios ingeniería software moderna tal vez hayan sido bien entendidos época que desarrolló software heredado.¿qué hago encuentro sistema heredado mala calidad?? ¿qué tipos cambios hacen los sistemas heredados?? todo ingeniero software debe reconocer que cambio natural. trate evitarlo.consejo (-).indd (-).indd // ::// :: software ingeniería software desarrollan partir los antiguos […] que todo debe operar entre cooperar con cada uno los demás” [day]. . naturaleza única las webapps los primeros días red mundial (entre ), los sitios web consistían poco más que conjunto archivos hipertexto vinculados que presentaban información con empleo texto gráficas limitadas. pasar tiempo, aumento html por medio herramientas desarrollo (xml, java) permitió los ingenieros web brindar capacidad cómputo junto con contenido información. habían nacido los sistemas aplicaciones - sados web (denominó éstas forma colectiva como webapps). actualidad, las webapps han convertido herramientas sofisticadas cómputo que sólo proporcionan funciones aisladas usuario final, sino que también han integrado con bases datos cor-porativas aplicaciones negocios. como dijo sección .., las webapps son una varias categorías distintas soft- ware. obstante, podría argumentarse que las webapps son diferentes. powell [pow] sugiere que los sistemas aplicaciones basados web “involucran una mezcla entre las publicaciones impresas desarrollo software, entre mercadotecnia computación, entre las comu-nicaciones internas las relaciones exteriores, entre arte tecnología”. gran mayoría webapps presenta los siguientes atributos: uso intensivo redes. una webapp reside una red debe atender las necesidades una comunidad diversa clientes. red permite acceso comunicación mundiales (por ejemplo, internet) tiene acceso comunicación limitados (por ejemplo, una intranet corporativa). concurrencia. webapp puede acceder gran número usuarios vez. - chos casos, los patrones uso entre los usuarios finales varían mucho.carga impredecible. número usuarios webapp cambia varios órdenes magnitud día otro. lunes tal vez utilicen cien personas, jueves quizá usen sistema. rendimiento. usuario webapp debe esperar demasiado (para entrar, para procesamiento por parte del servidor, para formado despliegue del lado del cliente), ella quizá decidan irse otra parte. disponibilidad. aunque razonable esperar una disponibilidad %, fre- cuente que los usuarios webapps populares demanden acceso las horas los días del año. los usuarios australia asia quizá demanden acceso horas las que las aplicaciones internas software tradicionales norteamérica estén línea por razones mantenimiento. orientadas los datos. función principal muchas webapp uso hiperme- dios para presentar usuario final contenido forma texto, gráficas, audio video. además, las webapps utilizan forma común para acceder información que existe bases datos que son parte integral del ambiente basado web (por ejemplo, comer-cio electrónico aplicaciones financieras).cita: “cuando veamos cualquier tipo estabilización, web habrá convertido algo com-pletamente diferente.” louis monier contexto este libro, término aplicación web (webapp) agrupa todo, desde una simple página web que ayude consumidor calcular pago del arrendamiento automóvil hasta sitio web integral que pro- porcione servicios completos viaje para gente negocios vacacionistas. esta categoría incluyen sitios web completos, funcionalidad especializada dentro sitios web aplicaciones procesamiento informa-ción que residen internet una intranet extranet.¿qué característica diferencia las webapps otro software?? (-).indd (-).indd // ::// :: capítulo software ingeniería software contenido sensible. calidad naturaleza estética del contenido constituye rasgo importante calidad una webapp. evolución continua. diferencia del software aplicación convencional que evolu- ciona largo una serie etapas planeadas separadas cronológicamente, las aplica- ciones web evolucionan forma continua. raro que ciertas webapp (específica- mente contenido) actualicen minuto minuto que contenido calcule cada solicitud. inmediatez. aunque inmediatez —necesidad apremiante que software llegue con rapidez mercado— una característica muchos dominios aplicación, frecuente que las webapps tengan plazos algunos días semanas para llegar mercado. seguridad. debido que las webapps encuentran disponibles con acceso una red, difícil imposible limitar población usuarios finales que pueden acceder apli-cación. con fin proteger contenido sensible brindar modos seguros transmi-sión los datos, deben implementarse medidas estrictas seguridad través infra-estructura apoyo una webapp dentro aplicación misma. estética. parte innegable del atractivo una webapp apariencia percepción. cuando diseñado una aplicación para comercializar vender productos ideas, estética tiene tanto que ver con éxito como diseño técnico. podría argumentarse que otras categorías aplicaciones estudiadas sección .. muestran algunos los atributos mencionados. sin embargo, las webapps casi siempre poseen todos ellos. . ingeniería software con objeto elaborar software listo para enfrentar los retos del siglo xxi, lector debe aceptar algunas realidades sencillas: • software incrustado profundamente casi todos los aspectos nuestras vidas , como consecuencia, número personas que tienen interés las características funciones que brinda una aplicación específica crecido forma notable. cuando construirse una aplicación nueva sistema incrustado, deben escucharse muchas opiniones. ocasiones parece que cada una ellas tiene una idea poco distinta cuáles características funciones debiera tener software. concluye que debe hacerse esfuerzo concertado para entender problema antes desarrollar una aplica-ción software. • los requerimientos tecnología información que demandan los individuos, negocios gobiernos hacen más complejos con cada año que pasa. actualidad, grandes equipos personas crean programas cómputo que antes eran elaborados por solo individuo. software sofisticado, que alguna vez implementó ambiente cómputo predecible autocontenido, hoy día halla incrustado interior todo, desde electrónica consumo hasta dispositivos médicos sistemas armamento. complejidad estos nuevos sistemas productos basados computadora demanda atención cuidadosa las interacciones todos los elementos del sistema. concluye que diseño vuelto una actividad crucial. con las herramientas modernas posible producir páginas web sofisticadas unas cuantas horas. una parte posterior este libro, llamaré estas personas “participantes”.punto clave entender problema antes dar una solución. punto clave diseño una actividad crucial ingeniería software. (-).indd (-).indd // ::// :: software ingeniería software • los individuos, negocios gobiernos dependen cada vez más del software para tomar decisiones estratégicas tácticas, así como para sus operaciones control cotidianos. software falla, las personas empresas grandes pueden experimentar desde incon-veniente menor hasta fallas catastróficas. concluye que software debe tener alta calidad. • medida que aumenta valor percibido una aplicación específica incrementa probabilidad que base usuarios longevidad también crezcan. conforme extienda base usuarios tiempo uso, las demandas para adaptarla mejorarla también crecerán. concluye que software debe tener facilidad para recibir mantenimiento. estas realidades simples llevan una conclusión: debe hacerse ingeniería con software todas sus formas través todos sus dominios aplicación. esto conduce tema este libro: ingeniería software. aunque cientos autores han desarrollado definiciones personales ingeniería soft- ware, propuesta por fritz bauer [nau] conferencia fundamental sobre tema todavía sirve como base para análisis: [ ingeniería software ] establecimiento uso principios fundamentales ingeniería con objeto desarrollar forma económica software que sea confiable que trabaje con eficiencia máquinas reales. lector sentirá tentado ampliar esta definición. dice poco sobre los aspectos técnicos calidad del software; habla directamente necesidad satisfacer los consumi- dores entregar producto tiempo; omite mencionar importancia medición metrología; establece importancia proceso eficaz. obstante, definición bauer proporciona una base. ¿cuáles son los “principios fundamentales ingeniería” que pueden aplicarse desarrollo del software computadora? ¿cómo desarrolla software “ forma económica” que sea “confiable”? ¿qué requiere para crear programas cómputo que trabajen con “eficiencia”, una sino muchas “máquinas reales” diferentes? éstas son las preguntas que siguen siendo reto para los ingenieros software. ieee [ieee] desarrollado una definición más completa, como sigue: ingeniería software : ) aplicación enfoque sistemático, disciplinado cuantificable desarrollo, operación mantenimiento software; decir, aplicación ingeniería soft-ware. ) estudio enfoques según punto . aun así, enfoque “sistemático, disciplinado cuantificable” aplicado por equipo software podría ser algo burdo para otro. necesita disciplina, pero también adaptabilidad agilidad. ingeniería software una tecnología con varias capas. como aprecia figura ., cualquier enfoque ingeniería (incluso software) debe basarse compromiso organizacional con calidad. administración total calidad, six sigma otras filosofías similares alimentan cultura mejora continua, esta cultura que lleva última ins- tancia desarrollo enfoques cada vez más eficaces ingeniería software. funda-mento que apoya ingeniería software compromiso con calidad. fundamento para ingeniería software capa proceso. proceso ingeniería software aglutinante que une las capas tecnología permite desarrollo racional punto clave tanto calidad como facilidad recibir mantenimiento son resultado buen diseño. cita: “más que una disciplina cuer- conocimientos, ingeniería verbo, una palabra acción, una forma abordar problema.” scott whitmir punto clave ingeniería software incluye proceso, métodos herramientas para administrar hacer ingeniería con software.¿cómo define ingeniería software? ? consulte muchas otras definiciones capítulo toda parte del libro estudia administración calidad los enfoques relacionados con ésta. (-).indd (-).indd // ::// :: capítulo software ingeniería software oportuno del software cómputo. proceso define una estructura que debe establecerse para obtención eficaz tecnología ingeniería software. proceso software forma base para control administración proyectos software, establece contexto que aplican métodos técnicos, generan productos del trabajo (modelos, documentos, datos, reportes, formatos, etc.), establecen puntos referencia, asegura calidad adminis-tra cambio manera apropiada. los métodos ingeniería software proporcionan experiencia técnica para elaborar software. incluyen conjunto amplio tareas, como comunicación, análisis los requeri-mientos, modelación del diseño, construcción del programa, pruebas apoyo. los métodos ingeniería software basan conjunto principios fundamentales que gobiernan cada área tecnología incluyen actividades modelación otras técnicas descriptivas. las herramientas ingeniería software proporcionan apoyo automatizado - miautomatizado para proceso los métodos. cuando integran las herramientas modo que información creada por una pueda ser utilizada por otra, queda establecido sistema llamado ingeniería software asistido por computadora que apoya desarrollo software. . proceso del software proceso conjunto actividades, acciones tareas que ejecutan cuando crearse algún producto del trabajo. una actividad busca lograr objetivo amplio (por ejemplo, comu-nicación con los participantes) desarrolla sin importar dominio aplicación, tamaño del proyecto, complejidad del esfuerzo grado rigor con que usará ingeniería software. una acción (diseño arquitectura) conjunto tareas que producen pro- ducto importante del trabajo (por ejemplo, modelo del diseño arquitectura). una tarea centra objetivo pequeño pero bien definido (por ejemplo, realizar una prueba unitaria) que produce resultado tangible. contexto ingeniería software, proceso una prescripción rígida cómo elaborar software cómputo. por contrario, enfoque adaptable que permite que las personas que hacen trabajo ( equipo software) busquen elijan conjunto apropiado acciones tareas para trabajo. busca siempre entregar software forma oportuna con calidad suficiente para satisfacer quienes patrocinaron creación aquellos que usarán. estructura del proceso establece fundamento para proceso completo ingeniería software por medio identificación número pequeño actividades estructurales que sean aplicables todos los proyectos software, sin importar tamaño complejidad. además, estructura del proceso incluye conjunto actividades sombrilla que son aplica- bles través todo proceso del software. una estructura proceso general para inge-niería software consta cinco actividades:herramientas compromiso con calidadmétodos ocesofigura . capas ingeniería software webref crosstalk periódico que información práctica sobre procesos, métodos herramientas. encuentra cita: “ proceso define quién hace qué, cuándo cómo, para alcanzar cierto objetivo.” ivar jacobson, grady booch james rumbaugh¿cuáles son los elementos proceso software?? (-).indd (-).indd // ::// :: software ingeniería software comunicación. antes que comience cualquier trabajo técnico, tiene importancia crí- tica comunicarse colaborar con cliente ( con otros participantes). busca entender los objetivos los participantes respecto del proyecto, reunir los requerimientos que ayuden definir las características funciones del software. planeación. cualquier viaje complicado simplifica existe mapa. proyecto software viaje difícil, actividad planeación crea “mapa” que guía equipo mientras viaja. mapa —llamado plan del proyecto software— define trabajo inge- niería software describir las tareas técnicas por realizar, los riesgos probables, los -cursos que requieren, los productos del trabajo que obtendrán una programación las actividades. modelado. sea usted diseñador paisaje, constructor puentes, ingeniero aeronáu- tico, carpintero arquitecto, diario trabaja con modelos. crea “bosquejo” del objeto por hacer fin entender panorama general —cómo verá arquitectónicamente, cómo ajustan entre las partes constituyentes muchas características más—. requiere, -fina bosquejo con más más detalles esfuerzo por comprender mejor problema cómo resolverlo. ingeniero software hace mismo crear modelos fin entender mejor los requerimientos del software diseño que los satisfará. construcción. esta actividad combina generación código ( sea manual auto- matizada) las pruebas que requieren para descubrir errores éste.despliegue. software (como entidad completa como incremento parcialmente terminado) entrega consumidor que evalúa que retroalimentación, misma que basa dicha evaluación. estas cinco actividades estructurales genéricas usan durante desarrollo programas -queños sencillos, creación aplicaciones web grandes ingeniería sistemas enormes complejos basados computadoras. los detalles del proceso software serán distintos cada caso, pero las actividades estructurales son las mismas. para muchos proyectos software, las actividades estructurales aplican forma itera- tiva medida que avanza proyecto. decir, comunicación, planeación, mode- lado, construcción despliegue ejecutan través cierto número repeticiones del proyecto. cada iteración produce incremento del software que los participantes subconjunto características funcionalidad generales del software. conforme produce cada incremento, software hace más más completo. las actividades estructurales del proceso ingeniería software son complementadas por cierto número actividades sombrilla. general, las actividades sombrilla aplican largo proyecto software ayudan equipo que lleva cabo administrar controlar avance, calidad, cambio riesgo. común que las actividades sombrilla sean las -guientes: seguimiento control del proyecto software: permite que equipo software evalúe progreso comparándolo con plan del proyecto tome cualquier acción necesa-ria para apegarse programación actividades. administración del riesgo: evalúa los riesgos que puedan afectar resultado del pro- yecto calidad del producto.¿cuáles son las cinco actividades estructurales del proceso?? participante cualquier persona que tenga algo que ver resultado exitoso del proyecto —gerentes del negocio, usuarios finales, ingenieros software, personal apoyo, etc.—. rob thomset dice broma que “ participante una persona que blande una estaca grande aguda […] vez más lejos que los participantes, sabes dónde terminará estaca”. (. del .: esta nota juego palabras: stake significa estaca también parte, stakeholder que blande una estaca, pero también participante.)cita: “einstein afirmaba que debía haber una explicación sencilla naturaleza porque dios caprichoso arbitrario. ingeniero software con-forta una parecida. gran parte complejidad que debe doblegar origen arbitrario.” fred brooks punto clave las actividades sombrilla ocurren largo del proceso software centran sobre todo administración, seguimiento control del proyecto. (-).indd (-).indd // ::// :: capítulo software ingeniería software aseguramiento calidad del software: define ejecuta las actividades requeridas para garantizar calidad del software. revisiones técnicas: evalúa los productos del trabajo ingeniería software fin descubrir eliminar errores antes que propaguen siguiente actividad. medición: define reúne mediciones del proceso, proyecto producto para ayudar equipo entregar software que satisfaga las necesidades los participantes; puede usarse junto con todas las demás actividades estructurales sombrilla. administración configuración del software: administra los efectos del cambio largo del proceso del software.administración reutilización: define criterios para volver usar producto del trabajo (incluso los componentes del software) establece mecanismos para obtener com-ponentes reutilizables. preparación producción del producto del trabajo: agrupa las actividades requeridas para crear productos del trabajo, tales como modelos, documentos, registros, formatos listas. cada una estas actividades sombrilla analiza detalle más adelante. dijo esta sección que proceso ingeniería software una prescripción rígida que deba seguir forma dogmática equipo que crea. contrario, debe ser ágil adaptable ( problema, proyecto, equipo cultura organizacional). por tanto, pro-ceso adoptado para proyecto puede ser significativamente distinto otro adoptado para otro proyecto. entre las diferencias encuentran las siguientes: • flujo general las actividades, acciones tareas, así como las interdependencias entre ellas • grado que las acciones tareas están definidas dentro cada actividad estruc- tural • grado que identifican requieren los productos del trabajo • forma que aplican las actividades aseguramiento calidad • manera que realizan las actividades seguimiento control del proyecto • grado general detalle rigor con que describe proceso • grado con que cliente otros participantes involucran con proyecto • nivel autonomía que equipo software • grado con que son prescritos organización los roles del equipo parte este libro, examinará proceso software con mucho detalle. los modelos proceso prescriptivo (capítulo ) enfatizan definición, identificación aplicación deta- lladas las actividades tareas del proceso. objetivo mejorar calidad del sistema, desarrollar proyectos más manejables, hacer más predecibles las fechas entrega los costos, guiar los equipos ingenieros software cuando realizan trabajo que requiere para construir sistema. desafortunadamente, habido casos los que estos objetivos han logrado. los modelos prescriptivos aplican forma dogmática sin adaptación, pueden incrementar nivel burocracia asociada con desarrollo sistemas basados compu-tadora crear inadvertidamente dificultades para todos los participantes. los modelos proceso ágil (capítulo ) ponen énfasis “agilidad” del proyecto siguen conjunto principios que conducen enfoque más informal (pero menos efectivo, dicen sus defensores) del proceso software. por general, dice que estos modelos del proceso son “ágiles” porque acentúan maniobrabilidad adaptabilidad. son apropiados para muchos tipos proyectos son útiles particular cuando hace ingeniería sobre apli-caciones web.punto clave adaptación del proceso software esencial para éxito del proyecto. ¿qué diferencias existen entre los modelos del proceso?? cita: “siento que una receta sólo tema que una cocinera inteli-gente ejecuta con una variación cada ocasión.” madame benoit ¿qué caracteriza proceso “ágil”?? (-).indd (-).indd // ::// :: software ingeniería software . práctica ingeniería software sección . introdujo modelo general proceso software compuesto con- junto actividades que establecen una estructura para práctica ingeniería software. las actividades estructurales generales —comunicación, planeación, modelado, construc-ción despliegue— las actividades sombrilla establecen esqueleto arquitectura para trabajo ingeniería software. pero, ¿cómo entra aquí práctica ingeniería soft-ware? las secciones que siguen, lector obtendrá comprensión básica los conceptos principios generales que aplican las actividades estructurales. .. esencia práctica libro clásico, how solve , escrito antes que existieran las computadoras modernas, george polya [pol] describió esencia solución problemas , consecuencia, esencia práctica ingeniería software: . entender problema (comunicación análisis). . planear solución (modelado diseño del software). . ejecutar plan (generación del código). . examinar exactitud del resultado (probar asegurar calidad). contexto ingeniería software , estas etapas sentido común conducen una serie preguntas esenciales [adaptado pol]: entender problema. ocasiones difícil admitir , pero mayor parte nosotros adoptamos una actitud orgullo desmedido cuando nos presenta problema. escuchamos por unos segundos después pensamos: claro, , entiendo, resolvamos esto. desafortunada- mente, entender siempre fácil. conveniente dedicar poco tiempo responder algunas preguntas sencillas: • ¿quiénes tienen que ver con solución del problema? decir, ¿quiénes son los partici-pantes? • ¿cuáles son las incógnitas? ¿cuáles datos, funciones características requieren para resolver problema forma apropiada? • ¿puede fraccionarse problema? ¿ posible representarlo con problemas más pequeños que sean más fáciles entender? • ¿ posible representar gráficamente problema? ¿puede crearse modelo análisis? planear solución. ahora entiende problema ( que piensa) puede esperar para escribir código. antes hacerlo, cálmese poco haga pequeño diseño: • ¿ visto antes problemas similares? ¿hay patrones reconocibles una solución potencial? ¿hay algún software existente que implemente los datos, funciones caracte-rísticas que requieren? • ¿ resuelto problema similar? así, ¿son reutilizables los elementos solución? • ¿pueden definirse problemas más pequeños? así fuera, ¿hay soluciones evidentes para éstos?podría decirse que enfoque polya simple sentido común. verdad. pero sorprendente frecuencia con que sentido común poco común mundo del software.consejowebref dirección encuentran varias citas provocativas sobre práctica ingeniería software. lector debería volver consultar las secciones este capítulo medida que libro describan espe- cífico los métodos las actividades sombrilla ingeniería software.cita: “ solución cualquier pro-blema hay grano descubrimiento.” george polya (-).indd (-).indd // ::// :: capítulo software ingeniería software • ¿ capaz representar una solución una forma que lleve implementación eficaz? ¿ posible crear modelo del diseño? ejecutar plan. diseño que creó sirve como mapa carreteras para sistema que quiere construir . puede haber desviaciones inesperadas posible que descubra camino mejor medida que avanza, pero “plan” permitirá proceder sin que pierda. • ¿ ajusta solución plan? ¿ código fuente puede apegarse modelo del diseño? • ¿ probable que cada parte componente solución sea correcta? ¿ diseño código han revisado , mejor aún, han hecho pruebas respecto corrección del algoritmo? examinar resultado. puede estar seguro que solución sea perfecta, pero que diseñado número suficiente pruebas para descubrir tantos errores como sea posible. • ¿puede probarse cada parte componente solución? ¿ implementado una estra- tegia razonable para hacer pruebas? • ¿ solución produce resultados que apegan los datos, funciones características que requieren? ¿ software validado contra todos los requerimientos los partici-pantes? debiera sorprender que gran parte este enfoque tenga que ver con sentido común. realidad, razonable afirmar que enfoque sentido común para ingeniería software hará que nunca extravíe. .. principios generales diccionario define palabra principio como “una ley importante suposición que subyace requiere sistema pensamiento”. este libro analizarán principios muchos niveles distintos abstracción. algunos centran ingeniería software como todo, otros consideran una actividad estructural general específica (por ejemplo, comunicación), otros más centran acciones ingeniería software (por ejemplo, diseño -quitectura) tareas técnicas (escribir escenario para uso). sin importar nivel enfoque, los principios ayudarán establecer conjunto herramientas mentales para una práctica sólida ingeniería software. ésa razón que sean importantes. david hooker [hoo] propuso siete principios que centran práctica ingeniería software como todo. reproducen los párrafos siguientes: primer principio: razón que exista todo sistema software existe por una razón: dar valor sus usuarios. odas las decisiones deben tomarse teniendo esto mente. antes especificar requerimiento del sistema, antes notar funcionalidad una parte , antes determinar las plataformas del hardware desarrollar procesos, plantéese preguntas tales como: “¿esto agrega valor real sistema?” respuesta “”, entonces haga. todos los demás principios apoyan éste. segundo principio: mse (mantenlo sencillo, estúpido…) diseño software proceso caprichoso. hay muchos factores por considerar cualquier actividad diseño. odo diseño debe ser tan simple como sea posible, pero más . reproducido con permiso del autor [hoo]. hooker define algunos patrones para estos principios http:// .com/cgi/wiki?sevenprinciplesofsoftwaredevelopment.antes comenzar proyecto software, asegúrese que software tenga propósito para negocio que los usuarios perciben valor .consejo (-).indd (-).indd // ::// :: software ingeniería software esto facilita conseguir sistema que sea comprendido más fácilmente que sea susceptible recibir mantenimiento, que quiere decir que nombre simplicidad deban des-cartarse características hasta rasgos internos. realidad, los diseños más elegantes por general son los más simples. simple tampoco significa “rápido sucio”. verdad que con frecuencia requiere mucha reflexión trabajo con iteraciones múltiples para poder simplifi-car. recompensa software más fácil mantener menos propenso error. tercer principio: mantener visión una visión clar esencial para éxito proyecto software. sin ella, casi infalible- mente proyecto terminará siendo ser “con dos [ más mentes]”. sin integridad concep- tual, sistema está amenazado convertirse una urdimbre diseños incompatibles unidos por tornillos del tipo equivocado […] comprometer visión arquitectura sistema software debilita , finalmente hará que colapsen incluso los sistemas bien diseña-dos. tener arquitecto que pueda para mantener visión que obligue cumplimiento garantiza proyecto software muy exitoso. cuarto principio: otr consumirán que usted produce rara vez construye vacío sistema software con fortaleza industrial. modo otro, alguien más usará, mantendrá, documentará , alguna forma, dependerá capacidad para entender sistema. así que siempre establezca especificaciones, diseñe implemente con seguridad que alguien más tendr que entender que usted haga . - diencia para cualquier producto desarrollo software potencialmente grande. elabore especificaciones con mirada puesta los usuarios. diseñe con los implementadores mente. codifique pensando aquellos que deben dar mantenimiento ampliar sistema. alguien debe depurar código que usted escriba, eso hace usuario código. hacer trabajo más fácil agrega valor sistema. quinto principio: ábr ase futuro sistema con larga vida útil tiene más valor. los ambientes cómputo actuales, donde las especificaciones cambian momento otro las plataformas hardware quedan obsoletas con sólo unos meses edad, común que vida útil del software mida meses años. sin embargo, los sistemas software con verdadera “fortaleza industrial” deben durar mucho más tiempo. para tener éxito esto, los sistemas deben ser fáciles adaptar ésos otros cambios. los sistemas que logran son los que diseñaron para ello desde principio. nunca diseñe sobre algo iniciado. siempre pregunte: “¿qué pasa …?” prepárese para todas las respuestas posibles mediante creación sistemas que -suelvan problema general, sólo uno específico. muy posible que esto lleve volver usar sistema completo. sexto principio: planee por anticipado eutilización reutilización ahorra tiempo esfuerzo. desarrollar sistema software, lograr alto nivel reutilización quizá meta más difícil lograr. reutilización del código los diseños reconocido como uno los mayores beneficios usar tecnologías orientadas objetos. sin embargo, recuperación esta inversión automática. para reforzar las posibilidades reutilización que programación orientada objetos [ cita: “hay cierta majestad sen- cillez, que con mucho todo que adorna ingenio.” papa alejandro (-) punto clave software tiene valor, cambiará durante vida útil. por esa razón, debe construirse forma que sea fácil darle mantenimiento. peligroso llevar este consejo los extremos. diseñar para resolver “ problema general” ocasiones requiere compromisos rendimiento puede volver ineficientes las soluciones específicas. aunque esto verdad para aquellos que reutilizan software proyectos futuros, volver usar puede ser caro para quienes deben diseñar elaborar componentes reutilizables. los estudios indican que diseñar construir componentes reutilizables llega costar entre % más que software buscado. ciertos casos justifica diferencia costos. (-).indd (-).indd // ::// :: capítulo software ingeniería software convencional], requiere reflexión planeación. hay muchas técnicas para incluir reutili- zación cada nivel del proceso desarrollo del sistema… planeación anticipada busca reutilización disminuye costo incrementa valor tanto los componentes reutilizables como los sistemas los que incorpora. séptimo principio: ¡piense! este último principio tal vez que más pasa por alto. pensar todo con claridad - tes emprender acción casi siempre produce mejores resultados. cuando piensa algo más probable que haga bien. asimismo, también gana conocimiento pensar cómo volver hacerlo bien. usted piensa algo aun así hace mal, eso con vierte una experiencia valiosa. efecto colateral pensar aprender reconocer cuando sabe algo, punto que puede investigar respuesta. cuando sistema han puesto pensamientos claros, valor manifiesta. aplicación los primeros seis principios -quiere pensar con intensidad, por que las recompensas potenciales son enormes. todo ingeniero equipo software tan sólo siguiera los siete principios hooker, elimi- narían muchas las dificultades que experimentan construir sistemas complejos basados computadora. . mitos del software los mitos del software —creencias erróneas sobre éste sobre proceso que utiliza para obtenerlo— remontan los primeros días computación. los mitos tienen cierto número atributos que los hacen insidiosos. por ejemplo, parecen enunciados razonables hechos ( veces contienen elementos verdad), tienen una sensación intuitiva frecuente que los manifiesten profesionales experimentados que “conocen historia”. actualidad, mayoría profesionales ingeniería software reconocen los - tos como que son: actitudes equivocadas que han ocasionado serios problemas los admi-nistradores los trabajadores por igual. sin embargo, las actitudes hábitos antiguos son difíciles modificar, persisten algunos remanentes los mitos del software. mitos administración. los gerentes que tienen responsabilidades software , como los otras disciplinas, con frecuencia hallan bajo presión para cumplir presupuesto, man- tener programación actividades sin desvíos mejorar calidad. así como persona que ahoga agarra clavo ardiente, raro que gerente software sostenga creencia mito del software eso disminuye presión que está sujeto (incluso -nera temporal). mito: tenemos libro lleno estándares procedimientos para elaborar software. ¿ dará personal todo que necesita saber? realidad: tal vez exista libro estándares, pero ¿ utiliza? ¿saben existencia los trabajadores del software? ¿refleja práctica moderna ingeniería software? ¿ completo? ¿ adaptable? ¿está dirigido mejorar -trega tiempo también centra calidad? muchos casos, res-puesta todas estas preguntas “”. mito: nos atrasamos, podemos agregar más programadores ponernos corriente ( ocasiones, esto llama “concepto horda mongoles”). realidad: desarrollo del software proceso mecánico similar manufac-tura. palabras brooks [bro]: “agregar personal proyecto soft-ware atrasado atrasará más”. principio, esta afirmación parece contra intuición. sin embargo, medida que agregan personas, las que cita: “ ausencia estándares sig- nificativos, una industria nueva como del software depende sólo del folklore.” tom demarco webref software project managers network (red gerentes proyectos software), ayuda eliminar éstos otros mitos. (-).indd (-).indd // ::// :: software ingeniería software encontraban trabajando deben dedicar tiempo para enseñar los recién lle- gados, que disminuye cantidad tiempo dedicada esfuerzo desa-rrollo productivo. pueden agregarse individuos, pero sólo forma planeada bien coordinada. mito: decido subcontratar proyecto software tercero, puedo descansar dejar que esa compañía elabore. realidad: una organización comprende cómo administrar controlar proyectos software internamente, manera invariable tendrá dificultades cuando sub-contrate proyectos software. mitos del cliente. cliente que requiere software computadora puede ser persona escritorio lado, grupo técnico piso inferior , departamento mercadotecnia ventas, una compañía externa que solicita software mediante contrato. muchos casos, cliente sostiene mitos sobre software porque los gerentes profesionales éste hacen poco para corregir mala información. los mitos generan falsas expectativas (por parte del cliente) , última instancia, insatisfacción con desarrollador. mito: para comenzar escribir programas, suficiente enunciado general los objetivos —podremos entrar detalles más adelante. realidad: aunque siempre posible tener enunciado exhaustivo estable los requerimientos, “planteamiento objetivos” ambiguo una receta para desastre. los requerimientos que son ambiguos (que por general obtienen forma iterativa) desarrollan sólo por medio una comunica-ción eficaz continua entre cliente desarrollador. mito: los requerimientos del software cambian continuamente, pero cambio asi-mila con facilidad debido que software flexible. realidad: verdad que los requerimientos del software cambian, pero efecto que los cambios tienen varía según época que introducen. cuando solicitan principio cambios los requerimientos (antes que haya -menzado diseño elaboración código), efecto sobre costo -lativamente pequeño. sin embargo, conforme pasa tiempo, costo - menta con rapidez: los recursos han comprometido, establecido estructura del diseño cambio ocasiona perturbaciones que exigen -cursos adicionales modificaciones importantes del diseño. mitos del profesional. los mitos que aún sostienen los trabajadores del software han sido alimentados por más años cultura programación. durante los primeros días, pro-gramación veía como una forma del arte. difícil que mueran los hábitos actitudes arrai-gados. mito: una vez que escribimos programa hacemos que funcione, nuestro trabajo terminado. realidad: alguien dijo alguna vez que “entre más pronto comience ‘escribir - digo’, más tiempo tomará hacer que funcione”. los datos industria indi-can que entre % todo esfuerzo dedicado software ocurrirá después entregarlo cliente por primera vez. mito: hasta que haga “correr” programa, hay manera evaluar cali-dad. muchos ingenieros software han adoptado enfoque “ágil” que asimila los cambios forma gradual creciente, con que controlan efecto costo. los métodos ágiles estudian capítulo .trabaje muy duro para entender qué que tiene que hacer antes empezar. quizás pueda desarrollarlo detalle, pero entre más sepa, menor será riesgo que tome.consejo siempre que piense que hay tiempo para ingeniería software, pregúntese: “¿tendremos tiempo hacerlo otra vez?”.consejo (-).indd (-).indd // ::// :: capítulo software ingeniería software realidad: uno los mecanismos más eficaces asegurar calidad del software puede aplicarse desde concepción del proyecto: revisión técnica. las - visiones del software (descritas capítulo ) son “filtro calidad” que revelado más eficaz que las pruebas para encontrar ciertas clases defectos software. mito: único producto del trabajo que entrega proyecto exitoso pro-grama que funciona. realidad: programa que funciona sólo una parte una configuración soft- ware que incluye muchos elementos. son varios los productos terminados (modelos, documentos, planes) que proporcionan base ingeniería exitosa , más importante, que guían apoyo para software. mito: ingeniería software hará que generemos documentación voluminosa -necesaria, invariablemente nos retrasará. realidad: ingeniería software consiste producir documentos. trata crear producto calidad. mejor calidad conduce menos repeticio-nes, que como resultado tiempos entrega más cortos. muchos profesionales del software reconocen falacia los mitos mencionados. lamen- table que las actitudes métodos habituales nutran administración las prácticas técnicas deficientes, aun cuando realidad dicta enfoque mejor. primer paso hacia formulación soluciones prácticas para ingeniería software reconocimiento las realidades este campo. . cómo comienza todo todo proyecto software desencadena por alguna necesidad negocios: corregir defecto una aplicación existente, adaptar “sistema heredado” ambiente -gocios cambiante, ampliar las funciones características una aplicación existente necesidad crear producto, servicio sistema nuevo. comenzar proyecto software, frecuente que las necesidades del negocio - presen manera informal como parte una simple conversación. plática que presenta recuadro que sigue muy común. cómo inicia proyecto escena: sala juntas cpi corporation, empresa (ficticia) que manufactura productos consumo para uso doméstico comercial. participantes: mal golden, alto directivo desarrollo produc- tos; lisa pérez, gerente comercial; lee warren, gerente ingenie-ría; joe camalleri, ejecutivo, desarrollo negocios. conversación:joe: oye, lee, ¿qué eso que acerca que gente desa- rrollar qué? ¿una caja inalámbrica universal general?lee: sensacional… más menos del tamaño una caja ceri-llos pequeña… podemos conectarla sensores todo tipo, una cámara digital… cualquier cosa. usa protocolo . ina-lámbrico. permite acceso salida dispositivos sin cables. pensamos que llevará toda una nueva generación productos. joe: ¿estás acuerdo, mal?mal: . realidad, con las ventas tan planas que hemos tenido este año necesitamos algo nuevo. lisa hemos hecho algo investigación del mercado pensamos que tenemos una línea productos que podría ser algo grande.casasegura proyecto casasegura usará todo libro para ilustrar los entretelones equipo proyecto que ela- bora producto software. compañía, proyecto las personas son ficticias, pero las situaciones pro- blemas son reales. (-).indd (-).indd // ::// :: software ingeniería software con excepción una referencia casual, software mencionó conversación. , sin embargo, que hará triunfar fracasar línea productos casasegura. esfuerzo ingeniería tendrá éxito sólo también tiene software casasegura. mercado aceptará producto sólo software incrustado éste satisface las necesidades del cliente (aún establecidas). muchos los capítulos siguientes continuaremos avance ingeniería del software casasegura. . resumen software elemento clave evolución sistemas productos basados compu-tadoras, una las tecnologías más importantes todo mundo. los últimos años, software pasado ser solución problema especializado herramienta análisis información una industria misma. obstante, aún hay problemas para desarrollar software alta calidad tiempo dentro del presupuesto asignado. software —programas, datos información descriptiva— dirige una gama amplia tecnología campos aplicación. software heredado sigue planteando retos especiales quienes deben darle mantenimiento. los sistemas aplicaciones basados web han evolucionado simples conjuntos con- tenido información sistemas sofisticados que presentan una funcionalidad compleja contenido multimedios. aunque dichas webapps tienen características requerimientos úni-cos, son software. ingeniería software incluye procesos, métodos herramientas que permiten elaborar tiempo con calidad sistemas complejos basados computadoras. proceso software incorpora cinco actividades estructurales: comunicación, planeación, modelado, construcción despliegue que son aplicables todos los proyectos software. práctica ingeniería software una actividad para resolver problemas, que sigue conjunto principios fun-damentales. muchos mitos del software todavía hacen que administradores trabajadores equivoquen, aun cuando aumentado nuestro conocimiento colectivo del software las tecnologías reque-ridas para elaborarlo. conforme lector aprenda más sobre ingeniería software, comenzará entender por qué deben rebatirse estos mitos cada vez que surjan. problemas puntos por evaluar .. menos cinco ejemplos forma que aplica ley las consecuencias imprevistas software cómputo.joe: ¿cuán grande… tanto como renglón utilidades? mal (que evita compromiso directo): cuéntale nuestra idea, lisa.lisa: toda una nueva generación que hemos llamado “productos para administración del hogar”. dimos nombre casase-gura. usan nueva interfaz inalámbrica, proporcionan los due-ños viviendas pequeños negocios sistema controlado por —seguridad del hogar, vigilancia, control aparatos equi-pos—, sabes, apaga aire acondicionado cuando sales casa, esa clase cosas. lee (dando brinco): oficina ingeniería hizo estudio factibilidad técnica esta idea, joe. algo realizable con costo bajo manufactura. mayor parte del hardware línea. queda pendiente software, pero algo que poda-mos hacer. joe: interesante. pero pregunté sobre las utilidades.mal: las han penetrado por ciento los hogares esta- dos unidos. vendemos precio correcto, podría ser una aplicación sensacional. nadie tiene nuestra caja inalámbrica… somos dueños. nos adelantaremos dos años competencia. ¿las ganancias? quizá tanto como millones dólares segundo año. joe (sonriente): llevemos esto siguiente nivel. estoy interesado. (-).indd (-).indd // ::// :: capítulo software ingeniería software .. diga algunos ejemplos (tanto positivos como negativos) que indiquen efecto del software nuestra sociedad. .. desarrolle sus propias respuestas las cinco preguntas planteadas principio sección .. ana- lícelas con sus compañeros estudiantes... muchas aplicaciones modernas cambian con frecuencia, antes que presenten usuario final después que primera versión entrado uso. sugiera algunos modos elaborar software para detener deterioro que produce cambio. .. considere las siete categorías software presentadas sección ... ¿piensa que puede aplicarse cada una mismo enfoque ingeniería software? explique respuesta... figura . muestra las tres capas ingeniería software arriba otra llamada “compromiso con calidad”. esto implica programa calidad organizacional como enfoque administración total calidad. haga poco investigación desarrolle los lineamientos los elementos clave programa para administración calidad. .. ¿ aplicable ingeniería software cuando elaboran webapps? así, ¿cómo puede modificarse para que asimile las características únicas éstas?.. medida que software gana ubicuidad, los riesgos para público (debidos programas defectuosos) convierten motivo preocupación significativa. desarrolle escenario catastrófico pero realista que falla programa cómputo pudiera ocasionar gran daño (económico humano). .. describa con sus propias palabras una estructura proceso. cuando dice que las actividades - tructurales son aplicables todos los proyectos, ¿significa que realizan las mismas tareas todos los proyectos sin que importe tamaño complejidad? explique respuesta. .. las actividades sombrilla ocurren través todo proceso del software. ¿piensa usted que son apli- cables por igual través del proceso, que algunas concentran una más actividades estructurales?.. agregue dos mitos adicionales lista presentada sección .. también diga realidad que acompaña mito. lecturas adicionales fuentes información hay literalmente miles libros escritos sobre software cómputo. gran mayoría analiza lenguajes programación aplicaciones software, pero algunos estudian software mismo. pressman herron (software shock , dorset house, ) presentaron estudio temprano (dirigido las personas comunes) sobre software forma que elaboran los profesionales. libro negroponte que convirtió éxito ventas ( being digital , alfred . knopf, inc., ) describe panorama computación efecto general siglo xxi. demarco (why does software cost much? , dorset house, ) produ- cido varios ensayos amenos profundos sobre software proceso con que elabora. minasi (the software conspiracy: why software companies put out faulty products, how they can hurt you, and what you can , mcgraw-hill, ) afirma que “flagelo moderno” los errores software puede eliminarse sugiere formas lograrlo. compaine ( digital divide: facing crisis creating myth, mit press, ) asegura que “división” entre aquellos que tienen acceso recursos información (por ejemplo, web) los que tienen está estrechando conforme avanzamos primera década este siglo. los libros escritos por greenfield ( everyware: the dawning age ubiquitous computing , new riders publish- ing, ) loke (context-aware pervasive systems: architectures for new breed applications, auerbach, ) introducen concepto software “mundo abierto” predicen ambiente inalámbrico que software deba adaptarse los requerimientos que surjan tiempo real. sección “lecturas adicionales fuentes información” que presenta final cada capítulo expone panorama breve fuentes impresas que ayudan aumentar comprensión los principales temas pre- sentados. autor creado sitio web para apoyar libro ingeniería software: enfoque del profesional entre los muchos temas que abordan dicho sitio, encuentran desde los recursos ingeniería software capítulo por capítulo hasta información basada web que com-plementa material presentado. como parte esos recursos halla vínculo hacia amazon.com para cada libro citado esta sección. (-).indd (-).indd // ::// :: software ingeniería software estado actual ingeniería del proceso software determina mejor partir publicaciones tales como ieee software, ieee computer, crosstalk ieee transactions software engineering . publicacio- nes periódicas como application development trends cutter journal con frecuencia contienen artículos sobre temas ingeniería software. disciplina “resume” cada año proceeding the international conference software engineering, patrocinada por ieee acm, analiza profundidad revistas tales como acm transactions software engineering and methodology, acm software engineering notes annals software engineering. hay decenas miles sitios web dedicados ingeniería proceso soft-ware. años recientes han publicado muchos libros que abordan proceso ingeniería software. algunos presentan panorama todo proceso, mientras otros profundizan algunos temas impor-tantes omiten otros. entre los más populares (¡además del que tiene usted sus manos!) encuentran los siguientes: abran, ., and . moore, swebok: guide the software engineering body knowledge, ieee, . andersson, ., ., software engineering for internet applications, the mit press, . christensen, ., and . thayer, project manager’ guide software engineering best practices, ieee- press (wiley), . glass, ., fact and fallacies software engineering, addison-wesley, . jacobson, ., object-oriented software engineering: use case driven approach, ., addison-wesley, . jalote, ., integrated approach software engineering, springer, . pfleeger, ., software engineering: theory and practice, ., prentice-hall, .schach, ., object-oriented and classical software engineering, ., mcgraw-hill, . sommerville, ., software engineering, ., addison-wesley, .tsui, ., and . karam, essentials software engineering, jones & bartlett publishers, . las últimas décadas, son muchos los estándares para ingeniería software que han sido publicados por ieee, iso sus organizaciones. moore ( the road map software engineering: standards-based guide, wiley-ieee computer society press, ) proporciona una revisión útil los estándares relevantes forma que aplican proyectos reales. internet encuentra disponible una amplia variedad fuentes acerca ingeniería proceso software. una lista actualizada referencias red mundial que son útiles para proceso soft-ware encuentra sitio web del libro, dirección professional/olc/ser.htm. (-).indd (-).indd // ::// ::(-).indd (-).indd // ::// :: proceso del softwareparte uno esta parte obra, aprenderá sobre proceso que genera una estructura para práctica ingeniería software. los capí-tulos que siguen abordan preguntas como las siguientes: • ¿qué proceso del software? • ¿cuáles son las actividades estructurales generales que están presen-tes todo proceso del software? • ¿cómo modelan los procesos cuáles son los patrones del pro-ceso? • ¿cuáles son los modelos prescriptivos del proceso cuáles son sus fortalezas debilidades? • ¿por qué agilidad imperativo ingeniería software moderna? • ¿qué desarrollo ágil del software qué diferencia los modelos más tradicionales del proceso? una vez respondidas estas preguntas, lector estará mejor preparado para entender contexto que aplica práctica ingeniería software.. . . . . . (-).indd (-).indd // ::// :: del proceso conceptos clave conjunto tareas. . . . . . . . . desarrollo basado componentes . . . . . . . . . . modelo métodos formales. . . . . . . . . . . . . . . . modelo general proceso. . . concurrentes . . . . . . proceso evolutivo . . . . . . . . . . . . . . . modelos proceso incremental. . . . . . . . . . . . . . modelos proceso prescriptivo . . . . . . . . . . . . . patrones del proceso . . . . . . . del equipo software . . . . . . . . . . . . . proceso personal del software. . . . . . . . . . . . . proceso unificado . . . . . . . . . ¿qué ? cuando trabaja construc- ción producto sistema, importante ejecutar una serie pasos predecibles — mapa carreteras que ayuda obtener tiempo resultado alta calidad—. mapa que sigue llama “proceso del software”. ¿quién hace? los ingenieros software sus geren- tes adaptan proceso sus necesidades luego siguen. además, las personas que solicitaron software tienen papel proceso definición, elaboración prueba. ¿por qué importante? porque estabilidad, control organización una actividad que puede volverse caótica descontrola. sin embargo, enfoque moderno ingeniería software debe ser “ágil”. debe incluir sólo aquellas actividades, controles productos del trabajo que sean apropiados para equipo del proyecto para producto que busca obtener.¿cuáles son los pasos? nivel detallado, proceso que adopte depende del software que esté elaboran-. proceso puede ser apropiado para crear software destinado sistema control electrónico aero-plano, mientras que para creación sitio web será necesario proceso completamente distinto. ¿cuál producto final? desde punto vista ingeniero software, los productos del trabajo son los programas, documentos datos que producen como consecuencia las actividades tareas definidas por proceso. ¿cómo aseguro que hice bien? hay cierto número mecanismos evaluación del proceso del software que permiten que las organizaciones determinen “madurez” proceso. sin embargo, calidad, oportunidad viabilidad largo plazo del producto que elabora son los mejores indicadores eficacia del proceso que utiliza. una mirada rápidaen libro fascinante que expone punto vista economista sobre software ingeniería, howard baetjer, . [bae] comenta acerca del proceso del software. debido que software, como todo capital, conocimiento incorporado que conocimiento originalmente halla disperso, tácito, latente incompleto gran medida, desarrollo software proceso aprendizaje social. proceso diálogo que conocimiento que debe convertirse software reúne incorpora éste. proceso genera interacción entre usuarios diseñadores, entre usuarios herramientas cambiantes, entre diseñadores herramientas evolu-ción [tecnología]. proceso que repite que herramienta que evoluciona sirve por misma como medio para comunicación: con cada nueva ronda del diálogo genera más cono-cimiento útil partir las personas involucradas. realidad, elaboración software computadora proceso reiterativo apren- dizaje social, resultado, algo que baetjer llamaría “capital software”, reunión conocimiento recabado, depurado organizado medida que realiza proceso. pero desde punto vista técnico, ¿qué exactamente proceso del software? contexto este libro, define proceso del software como una estructura para las actividades, acciones tareas que requieren fin construir software alta calidad. ¿“proceso” -nónimo “ingeniería software”? respuesta “ ”. proceso del software define enfoque adoptado mientras hace ingeniería sobre software. pero ingeniería soft-ware también incluye tecnologías que pueblan proceso: métodos técnicos herramientas automatizadas. más importante aún, ingeniería software llevada cabo por personas creativas preparadas que deben adaptar proceso maduro software fin que resulte apropiado para los productos que construyen para las demandas mercado. (-).indd (-).indd // ::// :: modelos del proceso . modelo general proceso capítulo definió proceso como colección actividades trabajo, acciones tareas que realizan cuando crearse algún producto terminado. cada una las activida-des, acciones tareas encuentra dentro una estructura modelo que define relación tanto con proceso como entre . figura . representa proceso del software manera esquemática. dicha - gura, cada actividad estructural está formada por conjunto acciones ingeniería software cada una éstas encuentra definida por conjunto tareas que identifica las tareas del trabajo que deben realizarse, los productos del trabajo que producirán, los puntos aseguramiento calidad que requieren los puntos referencia que utilizarán para evaluar avance. como dijo capítulo , una estructura general para ingeniería software define cinco actividades estructurales: comunicación, planeación, modelado, construcción despliegue. además, largo todo proceso aplica conjunto actividades som-punto clave jerarquía del trabajo técnico dentro del proceso del software : actividades, acciones que contiene tareas constituyentes. estructura del proceso actividades sombrilla actividad estructural # conjuntos tareastareas del trabajoproductos del trabajopuntos aseguramiento calidadpuntos referencia del proyectoacción ingeniería software # . conjuntosde tareastareas del trabajoproductos del trabajopuntos aseguramiento calidadpuntos referencia del proyectoacción ingeniería software # . actividad estructural # conjuntosde tareastareas del trabajoproductos del trabajopuntos aseguramiento calidadpuntos referencia del proyectoacción ingeniería software # . conjuntosde tareastareas del trabajoproductos del trabajopuntos aseguramiento calidadpuntos referencia del proyectoacción ingeniería software # .mproceso del softwarefigura . estructura proceso del software (-).indd (-).indd // ::// :: parte uno proceso del software brilla: seguimiento control del proyecto, administración riesgos, aseguramiento cali- dad, administración configuración, revisiones técnicas, entre otras. lector debe observar que aún menciona aspecto importante del proceso del soft- ware. figura . ilustra dicho aspecto —llamado flujo del proceso— describe manera que están organizadas las actividades estructurales las acciones tareas que ocu-rren dentro cada una con respecto secuencia tiempo. flujo proceso lineal ejecuta cada una las cinco actividades estructurales secuencia, comenzando por comunicación terminando con despliegue (véase figura .). flujo proceso iterativo repite una más las actividades antes pasar siguiente (véase figura . ). flujo proceso evolutivo realiza las actividades forma “circular”. través las cinco actividades, cada circuito lleva una versión más completa del software (véase -gura .). flujo proceso paralelo (véase figura .) ejecuta una más actividades cita: “pensamos que los desarrolla- dores software pierden vista una verdad fundamental: mayor parte organizacio-nes saben que hacen. piensan que saben, pero así.” tom demarco ) flujo proceso paraleloc) flujo proceso evolutivocomunicación planeación modelado ) flujo proceso linealconstrucción despliegue comunicación planeación modelado construcción despliegue construcción desplieguecomunicación planeación modelado tiempob) flujo proceso iterativo planeación modelado construcción despliegueincremento obtenidocomunicaciónfigura . flujo del proceso (-).indd (-).indd // ::// :: modelos del proceso paralelo con otras (por ejemplo, modelado aspecto del software tal vez ejecute paralelo con construcción otro aspecto del software). .. definición actividad estructural aunque capítulo describieron cinco actividades estructurales dio una definición básica cada una, equipo software necesitará mucha más información antes poder ejecutar manera apropiada cualquiera ellas como parte del proceso del software. por tanto, surge una pregunta clave: ¿qué acciones son apropiadas para una actividad estructural, dados naturaleza del problema por resolver, las características las personas que hacen tra-bajo los participantes que patrocinan proyecto? para proyecto software pequeño solicitado por una persona ( una ubicación remota) con requerimientos sencillos directos, actividad comunicación tal vez incluya algo más que una llamada telefónica con participante apropiado. entonces, única acción nece-saria una conversación telefónica, las tareas del trabajo ( conjunto tareas) que engloba son las siguientes: . hacer contacto con participante por vía telefónica. . analizar los requerimientos tomar notas. . organizar las notas por escrito una formulación breve los requerimientos. . enviar correo electrónico participante para que revise apruebe. proyecto fuera considerablemente más complejo, con muchos participantes cada uno con distinto conjunto requerimientos ( veces conflicto), actividad comunicación puede tener seis acciones distintas (descritas capítulo ): concepción, indagación, elabor - ción, negociación, especificación validación. cada una estas acciones ingeniería del software tendrá muchas tareas trabajo número grande diferentes productos finales. .. identificación conjunto tareas relación con figura ., cada acción ingeniería software (por ejemplo, obtención, asociada actividad comunicación) representa por cierto número distintos conjuntos tareas, cada uno los cuales una colección tareas trabajo ingeniería soft-ware, relacionadas con productos del trabajo, puntos aseguramiento calidad puntos referencia del proyecto. debe escogerse conjunto tareas que adapte mejor las -cesidades del proyecto las características del equipo. esto implica que una acción -geniería software puede adaptarse las necesidades específicas del proyecto software las características del equipo del proyecto. .. patrones del proceso cada equipo software enfrenta problemas conforme avanza proceso del software. demostrara que existen soluciones fáciles para dichos problemas, sería útil para equipo abordarlos resolverlos rápidamente. patrón del proceso describe problema relacionado con proceso que encuentra durante trabajo ingeniería software, identifica -biente que surge problema sugiere una más soluciones para mismo. dicho manera general, patrón proceso formato [amb]: método consistente para describir soluciones del problema contexto del proceso del software. combinar patro-nes, equipo software resuelve problemas construye proceso que mejor satisfaga las necesidades proyecto.¿cómo transforma una actividad estructural cuando cambia naturaleza del proyecto?? punto clave diferentes proyectos demandan diferentes conjuntos tareas. equipo software elige conjunto tareas con base las características del problema proyecto. ¿qué patrón del proceso? ? capítulo hace análisis detallado los patrones. (-).indd (-).indd // ::// :: parte uno proceso del software los patrones definen cualquier nivel abstracción. ciertos casos, patrón puede usarse para describir problema ( solución) asociado con modelo completo del proceso (por ejemplo, hacer prototipos). otras situaciones, los patrones utilizan para describir problema ( solución) asociado con una actividad estructural (por ejemplo, planeación) una acción dentro una actividad estructural (estimación proyectos). ambler [amb] propuesto formato para describir patrón del proceso: nombre del patrón. patrón recibe nombre significativo que describe con- texto del proceso del software (por ejemplo, revisionestécnicas). fuerzas. ambiente que encuentra patrón los aspectos que hacen visible problema afectan solución. tipo. especifica tipo patrón. ambler [amb] sugiere tres tipos: . patrón etapa: define problema asociado con una actividad estructural para proceso. como una actividad estructural incluye múltiples acciones tareas del tra-bajo, patrón etapa incorpora múltiples patrones tarea (véase conti-nuación) que son relevantes para etapa (actividad estructural). ejemplo -trón etapa sería establecercomunicación. este patrón incorporaría patrón tarea recabarrequerimientos otros más. . patrón tarea: define problema asociado con una acción tarea trabajo ingeniería software que relevante para éxito práctica ingeniería software (por ejemplo, recabarrequerimientos patrón tarea).conjunto tareas conjunto tareas define trabajo real por efectuar fin cumplir los objetivos una acción ingeniería software. por ejemplo, indagación (mejor conocida como “recabar los requerimientos”) una acción importante ingeniería soft-ware que ocurre durante actividad comunicación. meta recabar los requerimientos entender que los distintos participan-tes desean del software que elaborar. para proyecto pequeño relativamente sencillo, conjunto tareas para indagación requerimientos tendrá aspecto pare-cido siguiente: . elaborar lista participantes del proyecto. . invitar todos los participantes una reunión informal. . pedir cada participante que haga una relación las caracte- rísticas funciones que requiere. . analizar los requerimientos construir lista definitiva. . ordenar los requerimientos según prioridad. . identificar las áreas incertidumbre. para proyecto software más grande complejo requerirá conjunto tareas diferente que quizá esté constituido por las siguientes tareas trabajo: . hacer lista participantes del proyecto. . entrevistar cada participante por separado fin determi- nar los deseos necesidades generales. . formar lista preliminar las funciones características con base las aportaciones del participante. . programar una serie reuniones para facilitar elaboración las especificaciones aplicación. . celebrar las reuniones. . producir cada reunión escenarios informales usuario. . afinar los escenarios del usuario con base retroalimenta- ción los participantes. . formar una lista revisada los requerimientos los partici- pantes. . usar técnicas despliegue función calidad para asig- nar prioridades los requerimientos. . agrupar los requerimientos modo que puedan entregarse forma paulatina creciente. . resaltar las limitantes restricciones que introducirán sis- tema. . analizar métodos para validar sistema. los dos conjuntos tareas mencionados sirven para “recabar los requerimientos”, pero son muy distintos profundidad formalidad. equipo software elige conjunto tareas que permita alcanzar meta cada acción con calidad agilidad.información cita: “ repetición patrones algo muy diferente repeti-ción las partes. realidad, las distintas partes serán únicas porque los patrones son los mis-mos.” christopher alexander los patrones son aplicables muchas actividades ingeniería software. análisis, diseño prueba patrones estudian los capítulos , , , . los patrones “antipatrones” para las actividades administración proyectos analizan parte del libro.punto clave formato patrón proporciona medio consistente para describir patrón. (-).indd (-).indd // ::// :: modelos del proceso . patrón fase: define secuencia las actividades estructurales que ocurren dentro del proceso, aun cuando flujo general las actividades sea naturaleza iterativa. ejemplo patrón fase modeloespir prototipos. contexto inicial. describe las condiciones las que aplica patrón. antes iniciar patrón: ) ¿qué actividades organizacionales relacionadas con equipo han ocurrido? ) ¿cuál estado entrada para proceso? ) ¿qué información ingeniería soft-ware del proyecto existe? por ejemplo, patrón planeación (patrón etapa) requiere que: ) los clientes los ingenieros software hayan establecido una comunicación colaboradora; ) haya termi-nado con éxito cierto número patrones tarea [especificado] para patrón comuni- cación; ) conozcan alcance del proyecto, los requerimientos básicos del negocio las restricciones del proyecto. problema. problema específico que debe resolver patrón.solución. describe cómo implementar con éxito patrón. esta sección describe forma que modifica estado inicial del proceso (que existe antes implementar -trón) como consecuencia iniciación del patrón. también describe cómo transforma información sobre ingeniería software sobre proyecto, disponible antes que inicie patrón, como consecuencia ejecución exitosa del patrón. contexto resultante. describe las condiciones que resultarán una vez que haya - plementado con éxito patrón: ) ¿qué actividades organizacionales relacionadas con equipo deben haber ocurrido? ) ¿cuál estado salida del proceso? ) ¿qué informa-ción sobre ingeniería software sobre proyecto desarrollado? patrones relacionados. proporciona una lista todos los patrones proceso directa- mente relacionados con éste. puede representarse como una jerarquía alguna forma diagrama. por ejemplo, patrón etapa comunicación incluye los patrones tarea: equipodelproyecto, lineamientosdecolaboración, definicióndealcances, reca-barrequerimientos, descripciónderestricciones creacióndeescenarios. usos ejemplos conocidos. indica las instancias específicas las que aplicable patrón. por ejemplo, comunicación obligatoria principio todo proyecto soft-ware, recomendable largo del proyecto nuevo obligatoria una vez alcanzada actividad despliegue. los patrones proceso dan mecanismo efectivo para enfrentar problemas asociados con cualquier proceso del software. los patrones permiten desarrollar una descripción jerárquica del proceso, que comienza nivel alto abstracción ( patrón fase). después -jora descripción como conjunto patrones etapa que describe las actividades estruc-turales mejora aún más forma jerárquica patrones tarea más detallados para cada patrón etapa. una vez desarrollados los patrones proceso, pueden reutilizarse para definición variantes del proceso, decir, equipo software puede definir modelo proceso específico con empleo los patrones como bloques constituyentes del modelo del proceso. . evaluación mejora del proceso existencia proceso del software garantía que software entregue tiempo, que satisfaga las necesidades los consumidores que tenga las características técnicas que estos patrones fase estudian sección ...webref dirección com/processpatternspage.html encuentran recursos amplios sobre los patrones proceso. (-).indd (-).indd // ::// :: parte uno proceso del software conducirán características calidad largo plazo (véanse los capítulos ). los patro- nes proceso deben acoplarse con una práctica sólida ingeniería software (véase parte del libro). además, proceso puede evaluarse para garantizar que cumple con ciertos criterios proceso básicos que haya demostrado que son esenciales para éxito -geniería software. las últimas décadas han propuesto numerosos enfoques para evaluación mejora proceso del software: método evaluación del estándar cmmi para proceso mejora (scampi, por sus siglas inglés): proporciona modelo cinco fases para evaluar proceso: inicio, diagnóstico, establecimiento, actuación aprendizaje. método scampi emplea sei cmmi como base evaluación [sei]. evaluación basada cmm para mejora del proceso interno (cba ipi, por sus - glas inglés): proporciona una técnica diagnóstico para evaluar madurez relativa una organización software; usa sei cmm como base evaluación [dun]. spice (iso/iec ): estándar que define conjunto requerimientos para eva- luación del proceso del software. objetivo del estándar ayudar las organizaciones desarrollar una evaluación objetiva cualquier proceso del software definido [iso]. iso: para software : estándar genérico que aplica cualquier organización que desee mejorar calidad general los productos, sistemas servicios que propor- ciona. por tanto, estándar directamente aplicable las organizaciones compañías software [ant]. capítulo presenta análisis detallado los métodos evaluación del software del proceso mejora.ejemplo patrón proceso siguiente patrón proceso abreviado describe enfoque aplicable caso que los participantes tienen una idea general que debe hacerse, pero están segu-ros los requerimientos específicos software. nombre del patrón. requerimientospococlarosintención. este patrón describe enfoque para construir mode- ( prototipo) que los participantes pueden evaluar forma itera-tiva, esfuerzo por identificar solidificar los requerimientos software. tipo. patrón fase.contexto inicial. antes iniciar este patrón deben cumplirse las siguientes condiciones: ) identificado los participantes; ) establecido modo comunicación entre los participantes equipo software; ) los participantes han identificado problema general software que resolver; ) obtenido enten-dimiento inicial del alcance del proyecto, los requerimientos básicos del negocio las restricciones del proyecto. problema. los requerimientos son confusos inexistentes, pero hay reconocimiento claro que existe problema por resolver que debe hacerse con una solución software. los participantes están seguros que quieren, decir, pueden describir con detalle los requerimientos del software. solución. aquí presentaría una descripción del proceso prototi- , que describirá más adelante, sección ...contexto resultante. los participantes aprueban prototipo software que identifica los requerimientos básicos (por ejemplo, modos interacción, características computacionales, funciones procesamiento). después esto, ) prototipo quizá evolucione través una serie incrementos para convertirse software producción, ) tal vez descarte prototipo software pro-ducción elabore con empleo otro proceso patrón. patrones relacionados. los patrones siguientes están relaciona- dos con este patrón: comunicaciónconclientes, diseñoitera-tivo, desarrolloiterativo, evaluacióndelcliente, obten-ciónderequerimientos. usos ejemplos conocidos. cuando los requerimientos sean inciertos, recomendable hacer prototipos.información punto clave evaluación busca entender estado actual del proceso del software con objeto mejorarlo. publicación cmmi [cmm] del sei, describen con muchos detalles las características proceso del software los criterios para proceso exitoso.¿ qué técnicas formales dispone para evaluar proceso del software?? cita: “las organizaciones software tienen deficiencias significativas capacidad capitalizar las experiencias obtenidas los proyectos terminados.” nasa (-).indd (-).indd // ::// :: modelos del proceso . modelos proceso prescriptivo los modelos proceso prescriptivo fueron propuestos originalmente para poner orden caos del desarrollo software. historia indica que estos modelos tradicionales han dado cierta estructura útil trabajo ingeniería software que constituyen mapa razonable-mente eficaz para los equipos software. sin embargo, trabajo ingeniería software producto que genera siguen “ borde del caos”. artículo intrigante sobre extraña relación entre orden caos mundo del software, nogueira sus colegas [nog] afirman siguiente: borde del caos define como “ estado natural entre orden caos, compromiso grande entre estructura sorpresa” [kau]. borde del caos visualiza como estado inestable parcialmente estructurado […] inestable debido que atraído constantemente hacia caos hacia orden absoluto. tenemos tendencia pensar que orden estado ideal naturaleza. esto podría ser error […] las investigaciones apoyan teoría que operación que aleja del equilibrio genera creatividad, procesos autoorganizados rendimientos crecientes [roo]. orden absoluto significa ausencia variabilidad, que podría ser una ventaja los ambientes impredecibles. cambio ocurre cuando hay cierta estructura que permita que cambio pueda organizarse, pero que sea tan rígi- como para que pueda suceder. por otro lado, demasiado caos hace imposible coordinación coherencia. falta estructura siempre significa desorden. las implicaciones filosóficas este argumento son significativas para ingeniería software. los modelos proceso prescriptivo buscan generar estructura orden, ¿son inapropiados para mundo del software, que basa cambio? pero rechazamos los modelos pro-ceso tradicional ( orden que implican) los reemplazamos con algo menos estructurado, ¿hacemos imposible coordinación coherencia trabajo software? hay respuestas fáciles para estas preguntas, pero existen alternativas disponibles para los ingenieros software. las secciones que siguen estudia enfoque proceso prescrip-tivo que los temas dominantes son orden consistencia del proyecto. autor los llama “prescriptivos” porque prescriben conjunto elementos del proceso: actividades -tructurales, acciones ingeniería software, tareas, productos del trabajo, aseguramiento calidad mecanismos control del cambio para cada proyecto. cada modelo del proceso también prescribe flujo del proceso (también llamado flujo trabajo), decir, manera que los elementos del proceso relacionan entre . todos los modelos del proceso del software pueden incluir las actividades estructurales - nerales descritas capítulo , pero cada una pone distinto énfasis ellas define forma diferente flujo proceso que invoca cada actividad estructural (así como acciones tareas ingeniería software). .. modelo cascada hay veces las que los requerimientos para cierto problema comprenden bien: cuando trabajo desde comunicación hasta despliegue fluye forma razonablemente lineal. esta situación encuentra ocasiones cuando deben hacerse adaptaciones mejoras bien defi-nidas sistema existente (por ejemplo, una adaptación para software contabilidad que obligatorio hacer debido cambios las regulaciones gubernamentales). también ocurre cierto número limitado nuevos esfuerzos desarrollo, pero sólo cuando los requerimien-tos están bien definidos tienen una estabilidad razonable.cita: “ proceso está bien, los resultados cuidarán mis-mos.” takashi osada los modelos proceso prescriptivo ocasiones son denominados modelos proceso “tradicional”.punto clave los modelos proceso prescriptivo definen conjunto prescrito elementos del proceso flujo predecible para trabajo del proceso. (-).indd (-).indd // ::// :: parte uno proceso del software modelo cascada, veces llamado ciclo vida clásico, sugiere enfoque sistemático secuencial para desarrollo del software, que comienza con especificación los reque- rimientos por parte del cliente avanza través planeación, modelado, construcción des- pliegue, para concluir con apoyo del software terminado (véase figura .). una variante representación del modelo cascada denomina modelo . figura . ilustra modelo [buc], donde aprecia relación entre las acciones para aseguramiento calidad aquellas asociadas con comunicación, modelado construc-ción temprana. medida que equipo software avanza hacia abajo desde lado izquierdo , los requerimientos básicos del problema mejoran hacia representaciones técnicas cada vez más detalladas del problema solución. una vez que generado código, equipo sube por lado derecho , esencia ejecuta una serie pruebas (acciones para asegurar calidad) que validan cada uno los modelos creados cuando equipo fue hacia abajo por lado izquierdo. realidad, hay diferencias fundamentales entre ciclo vida clásico modelo . este último proporciona una forma visualizar modo aplicación las acciones verificación validación trabajo ingeniería inicial. modelo cascada paradigma más antiguo ingeniería software. sin - bargo, las últimas tres décadas, las críticas hechas modelo han ocasionado que incluso sus defensores más obstinados cuestionen eficacia [han]. entre los problemas que ocasio-nes surgen aplicar modelo cascada encuentran los siguientes: . raro que los proyectos reales sigan flujo secuencial propuesto por modelo. aun-que modelo lineal acepta repeticiones, hace forma indirecta. como resultado, los cambios generan confusión conforme equipo del proyecto avanza. . menudo, difícil para cliente enunciar forma explícita todos los requerimien-tos. modelo cascada necesita que haga tiene dificultades para aceptar -certidumbre natural que existe principio muchos proyectos. . cliente debe tener paciencia. dispondrá una versión funcional del( los) programa() hasta que proyecto esté muy avanzado. error grande sería desastroso detectara hasta revisar programa funcionamiento. análisis interesante proyectos reales, bradac [bra] encontró que naturaleza lineal del ciclo vida clásico llega “estados bloqueo” los que ciertos miembros del equipo proyecto deben esperar otros fin terminar tareas interdependientes. reali-dad, ¡ tiempo espera llega superar dedicado trabajo productivo! los estados bloqueo tienden ocurrir más principio final proceso secuencial lineal. hoy día, trabajo software acelerado está sujeto una corriente sin fin cambios ( las características, funciones contenido información). modelo cascada suele ser comunicación inicio del proyecto recabar los requerimientosplaneación estimación programación seguimientomodelado análisis diseño despliegue entrega asistencia retroalimentaciónconstrucción código pruebasfigura . modelo cascada aunque modelo cascada propuesto originalmente por winston royce [roy] prevé los “bucles retroa- limentación”, gran mayoría organizaciones que aplican este modelo proceso tratan como fuera estrictamente lineal. parte del libro estudian con detalle las acciones aseguramiento calidad.punto clave modelo ilustra forma que asocian las acciones verificación validación con las primeras acciones ingeniería. ¿por qué veces falla modelo cascada? ? cita: “con demasiada frecuencia, trabajo software sigue pri-mera ley del ciclismo: importa hacia dónde dirijas, vas hacia arriba contra viento.” anónimo (-).indd (-).indd // ::// :: modelos del proceso inapropiado para ese tipo labor. obstante, sirve como modelo proceso útil situa- ciones las que los requerimientos son fijos trabajo avanza forma lineal hacia final. .. modelos proceso incremental hay muchas situaciones las que los requerimientos iniciales del software están razonable-mente bien definidos, pero alcance general del esfuerzo desarrollo imposibilita proceso lineal. además, tal vez haya una necesidad imperiosa dar rápidamente cierta funcionalidad limitada software los usuarios aumentarla las entregas posteriores software. tales casos, elige modelo proceso diseñado para producir software incrementos. modelo incremental combina elementos los flujos proceso lineal paralelo estudia- dos sección .. relación con figura ., modelo incremental aplica secuencias -neales forma escalonada medida que avanza calendario actividades. cada secuencia lineal produce “incrementos” software susceptibles entregarse [mcd] manera pare-cida los incrementos producidos flujo proceso evolutivo (sección ..). por ejemplo, software para procesar textos que elabore con paradigma incremental quizá entregue primer incremento las funciones básicas administración archivos, edición producción del documento; segundo dará herramientas más sofisticadas edi-ción producción documentos; tercero habrá separación palabras revisión ortografía; cuarto proporcionará capacidad para dar formato avanzado las pági-nas. debe observarse que flujo proceso para cualquier incremento puede incorporar paradigma del prototipo. cuando utiliza modelo incremental, frecuente que primer incremento sea pro- ducto fundamental. decir, abordan los requerimientos básicos, pero proporcionan muchas características suplementarias (algunas conocidas otras ). cliente usa producto fundamental ( somete una evaluación detallada). como resultado del uso / evaluación, generación códigodiseño arquitectura diseño los componentesmodelado los requerimientospruebas aceptación pruebas del sistema pruebas integración pruebas unitarias software ejecutablefigura . modelo punto clave modelo incremental ejecuta una serie avances, llamados incrementos, que forma progresiva dan más funcionalidad cliente conforme entrega cada incremento. cliente solicita entrega para una fecha que imposible cumplir. sugiera entregar uno más incrementos fecha que pide, resto del software (incrementos adicionales) momento posterior. consejo (-).indd (-).indd // ::// :: parte uno proceso del software desarrolla plan para incremento que sigue. plan incluye modificación del producto fundamental para cumplir mejor las necesidades del cliente, así como entrega caracterís-ticas adicionales más funcionalidad. este proceso repite después entregar cada incre-mento, hasta terminar producto final. modelo proceso incremental centra que cada incremento entrega pro- ducto que opera. los primeros incrementos son versiones desnudas del producto final, pero proporcionan capacidad que sirve usuario también dan una plataforma evaluación. desarrollo incremental útil particular cuando dispone personal para - plementación completa del proyecto plazo establecido por negocio. los primeros incre-mentos desarrollan con pocos trabajadores. producto básico bien recibido, entonces agrega más personal ( requiere) para que labore siguiente incremento. además, los incrementos planean para administrar riesgos técnicos. por ejemplo, sistema grande tal vez requiera que disponga hardware nuevo que encuentre desarrollo cuya fecha entrega sea incierta. este caso, tal vez sea posible planear los primeros incrementos forma que eviten uso dicho hardware, así proporcionar una funcionalidad parcial los usuarios finales sin retraso importante. .. modelos proceso evolutivo software, como todos los sistemas complejos, evoluciona tiempo. frecuente que los requerimientos del negocio del producto cambien conforme avanza desarrollo, que hace que sea realista trazar una trayectoria rectilínea hacia producto final; los plazos apretados del mercado hacen que sea imposible terminación software perfecto, pero debe lan-zarse una versión limitada fin aliviar presión competencia del negocio; com-prende bien conjunto requerimientos producto básico, pero los detalles del producto extensiones del sistema aún están por definirse. estas situaciones otras parecidas necesita modelo proceso diseñado explícitamente para adaptarse producto que evo-luciona con tiempo. los modelos evolutivos son iterativos. caracterizan por manera que permiten desarrollar versiones cada vez más completas del software. los párrafos que siguen pre-sentan dos modelos comunes proceso evolutivo.incremento # # entrega del primer incrementoentrega del segundoincrementoentrega del -ésimoincrementoincremento # calendario del proyectofuncionalidad características del softwarecomunicación planeación modelado (análisis, diseño) construcción (código, prueba) despliegue (entrega, retroalimentación)figura . modelo incremental importante observar que para todos los modelos proceso “ágiles” que estudian capítulo también usa filosofía incremental.punto clave modelo del proceso evolutivo genera cada iteración una versión final cada vez más completa del software. (-).indd (-).indd // ::// :: modelos del proceso hacer prototipos. frecuente que cliente defina conjunto objetivos generales para software , pero que identifique los requerimientos detallados para las funciones caracte- rísticas. otros casos, desarrollador tal vez esté seguro eficiencia algoritmo, adaptabilidad sistema operativo forma que debe adoptar interacción entre humano máquina. estas situaciones, muchas otras, paradigma hacer prototipos tal vez ofrezca mejor enfoque. aunque posible hacer prototipos como modelo proceso aislado, más común usarlo como una técnica que puede implementarse contexto cualquiera los modelos proceso descritos este capítulo. sin importar manera que aplique, paradigma hacer prototipos ayudará usted otros participantes mejorar comprensión que hay que elaborar cuando los requerimientos están claros. paradigma hacer prototipos (véase figura .) comienza con comunicación. usted reúne con otros participantes para definir los objetivos generales del software, identifica cuales-quiera requerimientos que conozca detecta las áreas las que imprescindible una mayor definición. planea rápidamente una iteración para hacer prototipo, lleva cabo modelado ( forma “diseño rápido”). éste centra representación aquellos aspectos del software que serán visibles para los usuarios finales (por ejemplo, disposición interfaz humana formatos pantalla salida). diseño rápido lleva construcción prototipo. éste entrega evaluado por los participantes, que dan retroalimenta-ción para mejorar los requerimientos. iteración ocurre medida que prototipo afi-nado para satisfacer las necesidades distintos participantes, mismo tiempo permite usted entender mejor que necesita hacer. ideal que prototipo sirva como mecanismo para identificar los requerimientos del software. construirse prototipo, pueden utilizarse fragmentos programas existen-tes aplicar herramientas (por ejemplo, generadores reportes administradores venta-nas) que permitan generar rápidamente programas que funcionen. pero, ¿qué hacer con prototipo cuando sirvió para propósito descrito? brooks [bro] una respuesta: mayoría proyectos raro que primer sistema elaborado sea utilizable. tal vez sea muy lento, muy grande, difícil usar todo vez. hay más alternativa que comenzar nuevo, con más inteligencia, construir una versión rediseñada que resuelvan los problemas.cita: “planee para lanzar uno. todos modos hará eso. única elección tratará vender sus clientes que lanzó.” frederick . brooks cuando cliente tiene una necesidad legítima, pero ignora los detalles, como primer paso desarrolle prototipo.consejo comunicaciónplan rápido construcción delprototipomodelado diseño rápido despliegue entrega retroalimentaciónfigura . paradigma hacer prototipos (-).indd (-).indd // ::// :: parte uno proceso del software prototipo sirve como “ primer sistema”. que brooks recomienda desecharlo. pero esto quizá sea punto vista idealizado. aunque algunos prototipos construyen para ser “desechables”, otros son evolutivos; decir, poco poco transforman sistema real. tanto los participantes como los ingenieros software les gusta paradigma hacer prototipos. los usuarios adquieren sensación del sistema real, los desarrolladores logran construir algo inmediato. obstante, hacer prototipos llega ser problemático por las -guientes razones: . los participantes ven que parece ser una versión funcional del software, sin darse cuenta que prototipo obtuvo manera caprichosa; perciben que prisa por hacer que funcionara, usted consideró calidad general del software facili-dad darle mantenimiento largo plazo. cuando les informa que producto debe rehacerse fin obtener altos niveles calidad, los participantes gritan que usted tonto piden “unos cuantos arreglos” para hacer del prototipo producto funcio-nal. con demasiada frecuencia, gerente desarrollo del software cede. . como ingeniero software, frecuente que llegue compromisos respecto -plementación fin hacer que prototipo funcione rápido. quizá utilice sistema operativo inapropiado, lenguaje programación tan sólo porque cuenta con conoce; tal vez implementó algoritmo ineficiente sólo para demostrar capacidad. después tiempo, quizá sienta cómodo con esas elecciones olvide todas las razones por las que eran inadecuadas. elección algo menos que ideal ahora pasado formar parte del sistema. unque puede haber problemas, hacer prototipos paradigma eficaz para ingeniería software. clave definir desde principio las reglas del juego; decir, todos los parti-cipantes deben estar acuerdo que prototipo sirva como mecanismo para definir los requerimientos. después descartará ( menos parte) hará ingeniería del software real con mirada puesta calidad.resista presión para convertir prototipo burdo producto terminado. como resultado ello, casi siempre disminuye calidad.consejo selección modelo proceso, parte escena: sala juntas del grupo ingeniería software cpi corporation, compañía (ficticia) que manufactura artículos consumo para hogar para uso comercial. participantes: lee warren, gerente ingeniería; doug miller, gerente ingeniería software; jamie lazar, miembro del equipo software; vinod raman, miembro del equipo software; robbins, miembro del equipo software. conversación:lee: recapitulemos. dedicado algún tiempo análisis línea productos casasegura, según vemos hasta momento. hay duda que hemos efectuado mucho trabajo tan sólo para definir concepto, pero gustaría que ustedes comenzaran pen-sar cómo van enfocar parte del software este proyecto. doug: pareciera que pasado hemos estado muy desorganiza- dos nuestro enfoque del software. : , doug, siempre sacamos producto.doug: cierto, pero sin muchos sobresaltos, este proyecto parece más grande complejo que cualquier cosa que hayamos hecho antes. jamie: parece tan mal, pero estoy acuerdo… nuestro enfo- que hoc los proyectos anteriores funcionará éste, particular tenemos una fecha entrega muy apretada. doug (sonríe): quiero ser poco más profesional nuestro enfoque. semana pasada asistí curso breve aprendí mucho sobre ingeniería software… algo bueno. aquí necesitamos proceso. jamie (con ceño fruncido): trabajo producir progra- mas computadora, papel. doug: den una oportunidad antes ser tan negativos conmigo. que quiero decir esto: [doug pasa describir estructura del proceso vista este capítulo los modelos proceso prescriptivo presentados hasta momento.] doug: cualquier forma, parece que modelo lineal para nosotros… pues supone que conocemos todos los requerimientos , conociendo esta empresa, eso parece probable.casasegura (-).indd (-).indd // ::// :: modelos del proceso modelo espiral. propuesto primer lugar por barry boehm [boe], modelo espir modelo evolutivo del proceso del software acopla con naturaleza iterativa hacer prototipos con los aspectos controlados sistémicos del modelo cascada. tiene potencial para hacer desarrollo rápido versiones cada vez más completas. boehm [boe] describe modelo del modo siguiente: modelo desarrollo espiral generador modelo proceso impulsado por riesgo, que usa para guiar ingeniería concurrente con participantes múltiples sistemas intensivos soft- ware. tiene dos características distintivas principales. primera enfoque cíclico para creci- miento incremental del grado definición sistema implementación, mientras que dismi-nuye grado riesgo. otra conjunto puntos referencia anclaje puntual para asegurar compromiso del participante con soluciones factibles mutuamente satisfactorias. con empleo del modelo espiral, software desarrolla una serie entregas evolutivas. durante las primeras iteraciones, que entrega puede ser modelo prototipo. las iteraciones posteriores producen versiones cada vez más completas del sistema cuya inge-niería está haciendo. modelo espiral dividido por equipo software conjunto actividades estructurales. para fines ilustrativos, utilizan las actividades estructurales generales ana-lizadas. cada una ellas representa segmento trayectoria espiral ilustrada figura .. comenzar proceso evolutivo, equipo software realiza actividades implícitas vinod: , parece demasiado orientado las tecnologías información… tal vez sea bueno para hacer sistema control inventarios algo así, pero parece bueno para casasegura. doug: estoy acuerdo.: ese enfoque hacer prototipos parece bueno. todo caso, asemeja mucho que hacemos aquí.vinod: eso problema. preocupa que nos suficiente estructura. doug: preocupes. tenemos muchas opciones más, quisiera que ustedes, muchachos, elijan que sea mejor para equipo para proyecto. comunicaciónplaneación modelado construccióndespliegue entrega retroalimentacióninicioanálisis diseño códigopruebaestimaciónprogramación análisis riesgofigura . modelo espiral común modelo espiral estudiado esta sección una variante del propuesto por boehm. para más información acerca del modelo espiral original, consulte [boe]. [boe] encuentra análisis más reciente del modelo espiral del mismo autor.punto clave modelo espiral adapta para emplearse largo todo ciclo vida una aplicación, desde desarrollo del concepto hasta mantenimiento. (-).indd (-).indd // ::// :: parte uno proceso del software circuito alrededor espiral sentido horario, partiendo del centro. riesgo considera conforme desarrolla cada revolución (capítulo ). cada paso evolutivo marcan puntos referencia puntuales: combinación productos del trabajo condiciones que encuentran largo trayectoria espiral. primer circuito alrededor espiral como resultado desarrollo una especifica- ción del producto; las vueltas sucesivas usan para desarrollar prototipo , luego, versiones cada vez más sofisticadas del software. cada paso por región planeación como resul-tado ajustes plan del proyecto. costo programación actividades ajustan con base retroalimentación obtenida del cliente después entrega. además, gerente del proyecto ajusta número planeado iteraciones que requieren para terminar software. diferencia otros modelos del proceso que finalizan cuando entrega software, modelo espiral puede adaptarse para aplicarse largo toda vida del software cómputo. entonces, primer circuito alrededor espiral quizá represente “proyecto desarrollo del concepto” que comienza centro espiral continúa por iteraciones múltiples hasta que queda terminado desarrollo del concepto. concepto desarro- llarse producto real, proceso sigue hacia fuera espiral comienza “proyecto desarrollo producto nuevo”. nuevo producto evolucionará través cierto número iteraciones alrededor espiral. más adelante puede usarse circuito alrededor espiral para que represente “proyecto mejora del producto”. esencia, espiral, cuando caracteriza este modo, sigue operativa hasta que software retira. hay ocasiones las que proceso está inmóvil, pero siempre que inicia cambio comienza punto entrada apropiado (por ejemplo, mejora del producto). modelo espiral enfoque realista para desarrollo sistemas software gran escala. como software evoluciona medida que proceso avanza, desarrollador cliente comprenden reaccionan mejor ante los riesgos cada nivel evolución. modelo espiral usa los prototipos como mecanismo reducción riesgos, pero, más importante, permite aplicar enfoque hacer prototipos cualquier etapa evolución del producto. mantiene enfoque escalón sistemático sugerido por ciclo vida clásico, pero incorpora una estructura iterativa que refleja mundo real una forma más realista. modelo espiral -manda una consideración directa los riesgos técnicos todas las etapas del proyecto , aplica manera apropiada, debe reducir los riesgos antes que vuelvan problema. pero, como otros paradigmas, modelo espiral una panacea. difícil convencer los clientes ( particular situaciones bajo contrato) que enfoque evolutivo controlable. demanda mucha experiencia evaluación del riesgo basa ella para llegar éxito. hay duda que habrá problemas algún riesgo importante descubre administra. .. modelos concurrentes modelo desarrollo concurrente, ocasiones llamado ingeniería concurrente, permite que equipo software represente elementos iterativos concurrentes cualquiera los -delos proceso descritos este capítulo. por ejemplo, actividad modelado definida para modelo espiral logra por medio invocar una más las siguientes acciones soft-ware: hacer prototipos, análisis diseño. figura . muestra representación esquemática una actividad ingeniería soft- ware dentro actividad modelado con uso del enfoque modelado concurrente. administración pide desarrollo apegado presupuesto (mala idea, por general), espiral convierte problema. costo revisa modifica cada vez que termina circuito.consejowebref dirección edu/publications/documents/.reports/.html encuentra información útil sobre modelo espiral. cita: “sólo voy aquí sólo mañana guía.” dave matthews band las flechas que apuntan hacia dentro largo del eje que separa región del despliegue comunica- ción indican potencial para iteración local largo misma trayectoria espiral. debe observarse que análisis diseño son tareas complejas que requieren mucho análisis. parte este libro considera detalle dichos temas.con frecuencia, modelo concurrente más apropiado para proyectos ingeniería productos los que involucran varios equipos trabajo.consejo (-).indd (-).indd // ::// :: modelos del proceso selección modelo proceso, parte escena: sala juntas del grupo ingeniería software cpi corporation, compañía que manufactura productos consumo para uso doméstico comercial. participantes: lee warren, gerente ingeniería; doug miller, gerente ingeniería software; vinod jamie, miembros del equipo ingeniería software. conversación: [doug describe las opciones proceso evoluti- .] jamie: ahora doy cuenta algo. enfoque incremental tiene sentido, verdad gusta flujo del modelo espiral. bas-tante realista. vinod: acuerdo. entregamos incremento, aprendemos retroalimentación del cliente, volvemos planear luego entregamos otro incremento. también ajusta naturaleza del producto. podemos lanzar con rapidez algo mercado luego agregar fun-cionalidad con cada versión, digo… con cada incremento. lee: momento. doug, ¿dijiste que volveríamos hacer plan cada vuelta espiral? eso nada bueno; necesitamos plan, programa actividades apegarnos ellos. doug: ésa vieja escuela, lee. como dijeron los chicos, tene- mos que hacerlo apegado realidad. afirmo que mejor afinar plan medida que aprendamos más conforme soliciten cambios. eso más realista. ¿qué sentido tiene plan refleja realidad? lee (con ceño fruncido): supongo, pero… alta dirección gustar… quieren plan fijo. doug (sonriente): entonces tendrás que reeducarlos, amigo.casasegura revisión alcance mínimoen evaluacióncambios esperaen desarrolloinactivo actividad modelado representa estado una actividad otarea ingenieríade software terminadofigura . elemento del modelo proceso concurrenteactividad —modelado— puede estar cualquiera los estados mencionados - mento dado. forma similar, posible representar manera análoga otras actividades, acciones tareas (por ejemplo, comunicación construcción). todas las actividades - geniería software existen manera concurrente, pero hallan diferentes estados. estado algún modo comportamiento observable externamente. (-).indd (-).indd // ::// :: parte uno proceso del software por ejemplo, actividad comunicación ( muestra figura) termina primera iteración principio proyecto existe estado cambios espera. actividad modelado (que existía estado inactivo mientras concluía comunicación inicial, ahora hace una transición estado desarrollo. sin embargo, cliente indica que deben hacerse cambios los requerimientos, actividad modelado pasa del estado desarrollo cambios espera. modelado concurrente define una serie eventos que desencadenan transiciones estado otro para cada una las actividades, acciones tareas ingeniería software. por ejemplo, durante las primeras etapas del diseño (acción importante ingeniería soft-ware que ocurre durante actividad modelado), detecta una inconsistencia modelo requerimientos. esto genera evento corrección del modelo análisis, que disparará acción análisis requerimientos del estado terminado cambios espera. modelado concurrente aplicable todos los tipos desarrollo software propor- ciona panorama apropiado del estado actual del proyecto. lugar confinar las activida-des, acciones tareas ingeniería software una secuencia eventos, define una red del proceso. cada actividad, acción tarea red existe simultáneamente con otras activida-des, acciones tareas. los eventos generados cierto punto red del proceso desencade-nan transiciones entre los estados. .. una última palabra acerca los procesos evolutivos dijo que software cómputo moderno caracteriza por cambio continuo, por tiem-pos entrega muy apretados por una necesidad apremiante satisfacción del cliente usuario. muchos casos, tiempo para llegar mercado requerimiento administrativo más importante. pierde nicho mercado, todo proyecto software podría carecer sentido. los modelos proceso evolutivo fueron concebidos para cumplir esos requisitos, pero, aun así, como clase general modelos proceso tienen demasiadas debilidades, que fueron -sumidas por nogueira sus colegas [nog]: pesar los beneficios incuestionables los procesos evolutivos software, existen algunas pre- ocupaciones. primera que hacer prototipos ( otros procesos evolutivos más sofisticados) plantea problema para planeación del proyecto debido incertidumbre número ciclos que requieren para elaborar producto. mayor parte técnicas administración estimación pro-yectos basa planteamiento lineal las actividades, por que ajustan por completo. segundo lugar, los procesos evolutivos software establecen velocidad máxima evolución. las evoluciones ocurren demasiado rápido, sin periodo relajamiento, seguro que proceso volverá caos. por otro lado, velocidad muy lenta, verá perjudicada pro-ductividad… tercer lugar, los procesos software deben centrarse flexibilidad capacidad exten- sión lugar alta calidad. esto suena preocupante. sin embargo, debe darse prioridad velocidad del desarrollo con enfoque cero defectos. extender desarrollo fin lograr alta calidad podría dar como resultado entrega tardía del producto, cuando haya desaparecido nicho oportunidad. este cambio paradigma impuesto por competencia borde del caos. realidad, parece preocupante proceso del software que centre flexibilidad, expansión velocidad del desarrollo por encima calidad. obstante, esta idea sido propuesta por varios expertos ingeniería software muy respetados ([you], [bac]).cita: “todo proceso organiza- ción tiene cliente, proceso sin cliente tiene pro-pósito.” . daniel hunt sin embargo, importante notar que ser primero llegar mercado garantía éxito. realidad, muchos productos software muy exitosos han llegado segundo hasta tercer lugar mercado (apren- den los errores sus antecesores). (-).indd (-).indd // ::// :: modelos del proceso objetivo los modelos evolutivos desarrollar software alta calidad forma itera- tiva incremental. sin embargo, posible usar proceso evolutivo para hacer énfasis flexibilidad, expansibilidad velocidad del desarrollo. reto para los equipos software sus administradores establecer balance apropiado entre estos parámetros críticos del pro-yecto producto, satisfacción del cliente (árbitro definitivo calidad del software). . modelos proceso especializado los modelos proceso especializado tienen muchas las características uno más los modelos tradicionales que presentaron las secciones anteriores. sin embargo, dichos -delos tienden aplicarse cuando elige enfoque ingeniería software especializado definido muy específicamente. .. desarrollo basado componentes los componentes comerciales software general (cots, por sus siglas inglés), desarrolla-dos por vendedores que los ofrecen como productos, brindan una funcionalidad que persigue con interfaces bien definidas que permiten que componente integre software que construir. modelo desarrollo basado componentes incorpora muchas las caracte- rísticas del modelo espiral. naturaleza evolutiva [nie] demanda enfoque iterativo para creación software. sin embargo, modelo desarrollo basado componentes construye aplicaciones partir fragmentos software prefabricados. las actividades modelado construcción comienzan con identificación candidatos componentes. éstos pueden diseñarse como módulos software convencional clases orientadas objetos paquetes clases. sin importar tecnología usada para crear los componentes, modelo desarrollo basado componentes incorpora las etapas siguientes ( implementan con uso enfoque evolutivo): . investigan evalúan, para tipo aplicación que trate, productos disponi- bles basados componentes. . consideran los aspectos integración los componentes. . diseña una arquitectura del software para que reciba los componentes. . integran los componentes arquitectura. . efectúan pruebas exhaustivas para asegurar funcionalidad apropiada. modelo del desarrollo basado componentes lleva reutilización del software , eso los ingenieros software varios beneficios cuanto mensurabilidad. reutiliza-ción componentes vuelve parte cultura, equipo ingeniería software tiene posibilidad tanto reducir ciclo tiempo del desarrollo como costo del proyecto. capítulo analiza con más detalle desarrollo basado componentes. este contexto, calidad del software define con mucha amplitud para que agrupe sólo satisfacción del cliente sino también varios criterios técnicos que estudian los capítulos . ciertos casos, los modelos proceso especializado pueden caracterizarse mejor como conjunto téc- nicas “metodología” para alcanzar una meta específica desarrollo software. obstante, implican proceso. apéndice estudian los conceptos orientados objetos, utilizan toda parte del libro. este contexto, una clase agrupa conjunto datos los procedimientos para procesarlos. paquete clases conjunto clases relacionadas que funcionan juntas para alcanzar cierto resultado final.webref dirección hay información útil sobre desarrollo basado componentes. (-).indd (-).indd // ::// :: parte uno proceso del software .. modelo métodos formales modelo métodos formales agrupa actividades que llevan especificación matemática formal del software cómputo. los métodos formales permiten especificar, desarrollar veri- ficar sistema basado computadora por medio del empleo una notación matemática rigurosa. ciertas organizaciones desarrollo software aplican una variante este enfoque, que denomina ingeniería software quirófano [mil, dye]. cuando durante desarrollo usan métodos formales (capítulo ), obtiene meca- nismo para eliminar muchos los problemas difíciles vencer con otros paradigmas ingeniería software. ambiguo, incompleto inconsistente descubre corrige con más facilidad, través una revisión hoc sino con aplicación análisis matemático. durante diseño emplean métodos formales, éstos sirven como base para verificación del programa, así permiten descubrir corregir errores que otro modo serían detectados. aunque modelo los métodos formales más seguido, promete software libre defectos. sin embargo, han expresado preocupaciones acerca aplicabilidad ambiente negocios: • desarrollo modelos formales consume mucho tiempo caro. • debido que pocos desarrolladores software tienen formación necesaria para aplicar métodos formales, requiere mucha capacitación. • difícil utilizar los modelos como mecanismo comunicación para clientes sin complejidad técnica. pesar estas preocupaciones, enfoque los métodos formales ganado partidarios entre los desarrolladores que deben construir software primera calidad seguridad (por ejemplo, control electrónico aeronaves equipos médicos), entre los desarrolladores que sufrirían graves pérdidas económicas ocurrieran errores software. .. desarrollo software orientado aspectos sin importar proceso del software que elija, los constructores software complejo imple-mentan manera invariable conjunto características, funciones contenido informa-ción localizados. estas características localizadas del software modelan como componentes (clases orientadas objetos) luego construyen dentro del contexto una arquitectura sistemas. medida que los sistemas modernos basados computadora hacen más sofisti-cados ( complejos), ciertas preocupaciones —propiedades que requiere cliente áreas interés técnico— extienden toda arquitectura. algunas ellas son las propiedades alto nivel sistema (por ejemplo, seguridad tolerancia fallas). otras afectan funcio-nes (aplicación las reglas negocios), mientras que otras más son sistémicas (sincroniza-ción tarea administración memoria). cuando las preocupaciones afectan múltiples funciones, características información del sistema, frecuente que les llame preocupaciones globales. los requerimientos del aspecto definen aquellas preocupaciones globales que tienen algún efecto través arquitectura del software. desarrollo software orientado aspectos (dsoa), conocido también como progra- mación orientada aspectos (poa), paradigma ingeniería software relativamente nuevo que proporciona proceso enfoque metodológico para definir, especificar, diseñar construir aspectos: “mecanismos más allá subrutinas herencia para localizar expresión una preocupación global” [elr]. grundy [gru] analiza con más profundidad los aspectos contexto que denomina ingeniería componentes orientada aspectos (icoa): icoa usa concepto rebanadas horizontales través componentes software descom- puestos verticalmente, llamados “aspectos”, para caracterizar las propiedades globales funcionales punto clave dsoa define “aspectos” que expresan preocupaciones del cliente que afectan múltiples funciones, características información del sistema. con los métodos formales puede demostrarse correcto software, ¿por qué son ampliamente utilizados? ? webref existen muchos recursos información sobre soa dirección: aosd.net (-).indd (-).indd // ::// :: modelos del proceso funcionales los componentes. los aspectos comunes sistémicos incluyen interfaces usua- rio, trabajo colaboración, distribución, persistencia, administración memoria, procesamiento las transacciones, seguridad, integridad, etc. los componentes pueden proveer requerir uno más “detalles aspectos” relación con aspecto particular, como mecanismo visión, -cance extensible clase interfaz (aspectos interfaz usuario); generación eventos, trans-porte recepción (aspectos distribución); almacenamiento, recuperación indización datos (aspectos persistencia); autenticación, encriptación derechos acceso (aspectos seguridad); descomposición las transacciones, control concurrencia estrategia registro (aspectos las transacciones), entre otros. cada detalle del aspecto tiene cierto número propiedades relacionadas con las características funcionales del detalle del aspecto. aún madura proceso distinto orientado aspectos. sin embargo, probable que proceso así adopte características tanto los modelos proceso evolutivo como concurrente. modelo evolutivo apropiado tanto los aspectos identifican después construyen. naturaleza paralela del desarrollo concurrente esencial porque ingeniería aspectos hace forma independiente los componentes software localizados; aun así, los -pectos tienen efecto directo sobre éstos. esta forma, esencial disponer comunica-ción asincrónica entre las actividades proceso del software aplicadas ingeniería, construcción los aspectos componentes. análisis detallado del desarrollo software orientado aspecto deja libros especia- lizados tema. lector tiene interés profundizar, invita consultar [saf], [cla], [jac] [gra]. administración del proceso objetivo: ayudar definición, ejecución administra- ción modelos proceso prescriptivo. mecánica: las herramientas administración del proceso permiten que una organización equipo software defina modelo com-pleto del proceso (actividades estructurales, acciones, tareas, asegura-miento calidad, puntos revisión, referencias productos del trabajo). además, las herramientas proporcionan mapa conforme los ingenieros software realizan trabajo técnico, una plantilla para los gerentes que deben dar seguimiento controlar proceso del software. herramientas representativas: gdpa, grupo herramientas investigación definición del pro- ceso, desarrollada por universidad bremen, alemania ( home.htm), proporciona una amplia variedad funciones para modelar administrar procesos. speedev, desarrollada por speedev corporation ( com), incluye conjunto herramientas para definición del proceso, administración los requerimientos, resolución pro-blemas, planeación seguimiento del proyecto. provision bpmx, desarrollado por proforma ( corp.com), representativo muchas herramientas que ayu-dan definir proceso que automatizan flujo del trabajo. dirección htm, encuentra una lista extensa muchas herramientas dife-rentes asociadas con proceso del software.herramientas software las herramientas mencionadas aquí representan una obligación; sólo son una muestra las esta catego- ría. mayoría casos, los nombres las herramientas son marcas registradas por sus desarrolladores respectivos. . proceso unificado libro fundamental, unified process, ivar jacobson, grady booch james rumbaugh [jac] analizan necesidad proceso del software “impulsado por caso uso, centrado arquitectura, iterativo incremental”, con afirmación siguiente: (-).indd (-).indd // ::// :: parte uno proceso del software actualidad, tendencia software hacia sistemas más grandes complejos. eso debe parte hecho que año tras año las computadoras son más poderosas, que hace que los usuarios esperen más ellas. esta tendencia también visto influida por uso creciente -ternet para intercambiar toda clase información […] nuestro apetito por software cada vez más sofisticado aumenta conforme aprendemos, entre lanzamiento otro producto, cómo mejo-rar éste. queremos software que adapte mejor nuestras necesidades, pero eso vez hace más complejo. pocas palabras, queremos más. cierto modo, proceso unificado intento por obtener los mejores rasgos caracterís- ticas los modelos tradicionales del proceso del software, pero forma que implemente muchos los mejores principios del desarrollo ágil software (véase capítulo ). proceso unificado reconoce importancia comunicación con cliente los métodos directos para describir punto vista respecto sistema ( caso uso). hace énfasis impor- tancia arquitectura del software “ayuda que arquitecto centre las metas correc-tas, tales como que sea comprensible, permita cambios futuros reutilización” [jac]: -giere flujo del proceso iterativo incremental, que sensación evolutiva que resulta esencial desarrollo moderno del software. .. breve historia principio década , james rumbaugh [rum], grady booch [boo] ivar jacob-son [jac] comenzaron trabajar “método unificado” que combinaría mejor cada uno sus métodos individuales análisis diseño orientado objetos. resultado fue uml, lenguaje modelado unificado, que contiene una notación robusta para modelado desarrollo los sistemas orientados objetos. uml utiliza toda parte del libro para representar tanto los modelos requeri- mientos como diseño. apéndice presenta método introductorio enseñanza para quienes están familiarizados con las reglas básicas notación modelado con uml. estudio exhaustivo del uml deja libros dedicados tema. apéndice enlistan los textos recomendables. uml brinda tecnología necesaria para apoyar práctica ingeniería software orientada objetos, pero estructura del proceso que guíe los equipos del proyecto cuando aplican tecnología. los siguientes años, jacobson, rumbaugh booch desarrolla-ron proceso unificado, estructura para ingeniería software orientado objetos que utiliza uml. actualmente, proceso unificado () uml usan mucho proyectos toda clase orientados objetos. modelo iterativo incremental propuesto por puede debe adap-tarse para que satisfaga necesidades específicas del proyecto. .. fases del proceso unificado principio este capítulo estudiaron cinco actividades estructurales generales dijo que podían usarse para describir cualquier modelo proceso del software. proceso unificado excepción. figura . ilustra las “fases” del las relaciona con las actividades gene-rales estudiadas capítulo inicio éste. fase concepción del agrupa actividades tanto comunicación con cliente como planeación. colaborar con los participantes, identifican los requerimientos del negocio, caso uso (véase capítulo ) narración plantilla que describe una función rasgo sistema desde punto vista del usuario. éste escribe caso uso que sirve como base para creación modelo requerimientos más completos. proceso unificado ocasiones recibe nombre proceso racional unificado (pru), acuñado por rational corporation (adquirida posteriormente por ibm), que contribuyó desde principio desarrollo mejora del elaboración ambientes completos (herramientas tecnología) que apoyan proceso.punto clave las fases del tienen objetivo similar las actividades estructurales generales definidas este libro. (-).indd (-).indd // ::// :: modelos del proceso propone una arquitectura aproximada para sistema desarrolla plan para natura- leza iterativa incremental del proyecto cuestión. los requerimientos fundamentales del negocio describen por medio conjunto casos uso preliminares (véase capítulo ) que detallan las características funciones que desea cada clase principal usuarios. este punto, arquitectura más que lineamiento tentativo subsistemas principales función rasgos que tienen. arquitectura mejorará después expandirá conjunto modelos que representarán distintos puntos vista del sistema. planeación identifica los recursos, evalúa los riesgos principales, define programa actividades establece una base para las fases que van aplicar medida que avanza incremento del software. fase elaboración incluye las actividades comunicación modelado del modelo gene- ral del proceso (véase figura .). elaboración mejora amplía los casos uso prelimina-res desarrollados como parte fase concepción aumenta representación arqui-tectura para incluir cinco puntos vista distintos del software: los modelos del caso uso, requerimientos, del diseño, implementación del despliegue. ciertos casos, elabora-ción crea una “línea base arquitectura ejecutable” [arl] que representa sistema ejecutable “primer corte”. línea base arquitectura demuestra viabilidad ésta, pero proporciona todas las características funciones que requieren para usar sistema. además, terminar fase elaboración revisa con cuidado plan fin asegurar que alcance, riesgos fechas entrega siguen siendo razonables. frecuente que este -mento hagan modificaciones plan. fase construcción del idéntica actividad construcción definida para pro- ceso general del software. con uso del modelo arquitectura como entrada, fase construcción desarrolla adquiere los componentes del software que harán que cada caso uso sea operativo para los usuarios finales. para lograrlo, completan los modelos -querimientos diseño que comenzaron durante fase elaboración, fin que reflejen versión final del incremento software. después implementan código fuente todas las características funciones necesarias para incremento software (por ejemplo, lanza-miento). medida que implementan los componentes, diseñan efectúan pruebas unitarias para cada uno. además, realizan actividades integración (ensamble compo-transición producciónincremento del softwarelanzamientomodelado construcciónplaneación comunicación despliegueconstrucciónconcepciónelaboraciónfigura . proceso unificado importante darse cuenta que línea base arquitectura prototipo que desecha. por contrario, revestida durante fase siguiente del . los capítulos presenta análisis exhaustivo las pruebas del software (incluso las pruebas unita- rias).webref dirección .html, encuentra análisis interesante del contexto del desarrollo ágil. (-).indd (-).indd // ::// :: parte uno proceso del software nentes pruebas integración). emplean casos uso para obtener grupo pruebas aceptación que ejecutan antes comenzar siguiente fase del . fase transición del incluye las últimas etapas actividad general construcción primera parte actividad despliegue general (entrega retroalimentación). software los usuarios finales para las pruebas beta, quienes reportan tanto los defectos como los cambios necesarios. además, equipo software genera información apoyo nece-saria (por ejemplo, manuales usuario, guías solución problemas, procedimientos instalación, etc.) que requiere para lanzamiento. finalizar fase transición, soft-ware incrementado convierte producto utilizable que lanza. fase producción del coincide con actividad despliegue del proceso general. durante esta fase, vigila uso que software, brinda apoyo para ambiente operación (infraestructura) reportan defectos solicitudes cambio para evaluación. probable que mismo tiempo que llevan cabo las fases construcción, transición producción, comience trabajo sobre siguiente incremento del software. esto significa que las cinco fases del ocurren secuencia sino que concurren forma escalonada. flujo trabajo ingeniería software está distribuido través todas las fases del . contexto éste, flujo trabajo análogo conjunto tareas (que descri- bió este capítulo). decir, flujo trabajo identifica las tareas necesarias para completar una acción importante ingeniería software los productos trabajo que generan como consecuencia terminación exitosa aquéllas. debe notarse que toda tarea iden-tificada para flujo trabajo del realizada todos los proyectos software. equipo adapta proceso (acciones, tareas, subtareas productos del trabajo) fin que cumpla sus necesidades. . modelos del proceso personal del equipo mejor proceso del software que está cerca las personas que harán trabajo. modelo del proceso del software desarrollado nivel corporativo organizacional, será eficaz sólo acepta una adaptación significativa para que cubra las necesidades del equipo proyecto que realidad hace trabajo ingeniería software. situación ideal crearía proceso que ajustara del mejor modo los requerimientos, mismo tiempo cubriera las más amplias necesidades del equipo organización. forma alternativa, equipo crearía proceso propio que satisficiera las necesidades más estrechas los indivi-duos las más generales organización. watts humphrey ([hum] [hum]) afirma que posible crear “proceso personal software” / “proceso del equipo software”. ambos requieren trabajo duro, capacitación coordinación, pero los dos son asequibles. .. proceso personal del software (pps) todo desarrollador utiliza algún proceso para elaborar software cómputo. proceso puede ser caprichoso hoc; quizá cambie diario; tal vez sea eficiente, eficaz incluso sirva; pero existe “proceso”. watts humphrey [hum] sugiere que fin cambiar proceso personal ineficaz, individuo debe pasar por las cuatro fases, cada una las cuales requiere capacitación instrumentación cuidadosa. proceso personal del software (pps) pone énfasis medición personal tanto del producto del trabajo que genera como calidad. ade-más, pps responsabiliza profesional acerca planeación del proyecto (por ejemplo, útil notar que quienes proponen desarrollo ágil del software (véase capítulo ) también plantean que proceso debe ser cercano equipo. para lograr esto sugieren método alternativo.cita: “ persona que exitosa tan sólo hecho hábito hacer las cosas que hacen las personas que tienen éxito.” dexter yager webref dirección psp, hallan muchos recursos para pps. (-).indd (-).indd // ::// :: modelos del proceso estimación programación actividades) delega practicante poder controlar calidad todos los productos del trabajo software que desarrollen. modelo del pps define cinco actividades estructurales: planeación. esta actividad aísla los requerimientos desarrolla las estimaciones tanto del tamaño como los recursos. además, realiza estimación los defectos ( número defectos proyectados para trabajo). todas las mediciones registran hojas tra-bajo plantillas. por último, identifican las tareas desarrollo crea programa para proyecto. diseño alto nivel. desarrollan las especificaciones externas para cada compo- nente que construir crea diseño componentes. hay incertidumbre, elaboran prototipos. registran todos los aspectos relevantes les seguimiento. revisión del diseño alto nivel. aplican métodos verificación formal (véase capítulo ) para descubrir errores diseño. mantienen las mediciones para todas las tareas resultados del trabajo importantes. desarrollo. mejora revisa diseño del componente. código genera, revisa, compila prueba. las mediciones mantienen para todas las tareas resultados tra-bajo importancia. post mórtem. determina eficacia del proceso por medio medidas mediciones obtenidas (ésta una cantidad sustancial datos que deben analizarse con métodos - tadísticos). las medidas mediciones deben dar guía para modificar proceso fin mejorar eficacia. pps enfatiza necesidad detectar pronto los errores; igual importancia entender los tipos ellos que probable cometer. esto logra través una actividad evaluación rigurosa ejecutada para todos los productos del trabajo que generen. pps representa enfoque disciplinado basado medición para ingeniería soft- ware que quizá sea choque cultural para muchos sus practicantes. sin embargo, cuando introduce pps forma apropiada los ingenieros software [hum], significativa mejora resultante productividad ingeniería respectiva calidad del software [fer]. obstante, pps sido adoptado con amplitud por industria. triste recono-cer que las razones esto tienen que ver más con naturaleza humana inercia organiza-cional que con las fortalezas debilidades del enfoque del pps. dicho enfoque plantea desafíos intelectuales demanda nivel compromiso (por parte los practicantes sus adminis-tradores) que siempre posible obtener. capacitación relativamente larga sus costos elevados. nivel requerido las mediciones culturalmente difícil para muchas personas comunidad del software. ¿ posible usar pps como proceso eficaz software nivel personal? respuesta rotundo “”. pero aun adoptara por completo pps, muchos los conceptos del proceso mejora personal que introduce constituyen aprendizaje provechoso. .. proceso del equipo software (pes) debido que muchos proyectos software industrial son elaborados por equipo profe-sionales, watts humphrey extendió las lecciones aprendidas introducción del pps pro-puso proceso del equipo software (pes). objetivo éste construir equipo “autodi- rigido” para proyecto, que organice para producir software alta calidad. humphrey [hum] define los objetivos siguientes para pes: • formar equipos autodirigidos que planeen den seguimiento trabajo, que esta- blezcan metas que sean dueños sus procesos planes. éstos pueden ser equipos software puros productos integrados (epi) constituidos por ingenieros.¿qué actividades estructurales usan durante pps?? punto clave pps pone énfasis necesidad registrar analizar los tipos errores que cometen, modo que desarrollen estrategias para eliminarlos. webref dirección edu/tsp/, hay información sobre formación equipos alto rendimiento que usan pes pps. (-).indd (-).indd // ::// :: parte uno proceso del software • mostrar los gerentes cómo dirigir motivar sus equipos cómo ayudarlos mantener rendimiento máximo. • acelerar mejora del proceso del software, haciendo del modelo madurez capacidad, cmm, nivel , comportamiento normal esperado. • brindar las organizaciones muy maduras una guía para mejora. • facilitar enseñanza universitaria aptitudes equipo con grado industrial. equipo autodirigido tiene comprensión consistente sus metas objetivos generales; define papel responsabilidad cada miembro del equipo; seguimiento cuantitativo los datos del proyecto (sobre productividad calidad); identifica proceso equipo que sea apropiado para proyecto una estrategia para implementarlo; define estándares locales apli-cables trabajo ingeniería software del equipo; evalúa forma continua riesgo -acciona consecuencia; seguimiento, administra reporta estado del proyecto. pes define las siguientes actividades estructurales: inicio del proyecto, diseño alto nivel, implementación, integración pruebas, post mórtem. como sus contrapartes del pps (observe que terminología algo diferente), estas actividades permiten que equipo planee, diseñe construya software forma disciplinada, mismo tiempo que mide cuantita-tivamente proceso producto. etapa post mórtem escenario las mejoras del proceso. pes utiliza una variedad amplia scripts, formatos estándares que guían los miembros del equipo trabajo. los scripts definen actividades específicas del proceso (por ejemplo, inicio del proyecto, diseño, implementación, integración pruebas del sistema, post mórtem), así como otras funciones más detalladas del trabajo (planeación del desarrollo, desarrollo requerimientos, administración configuración del software prueba unitaria) que forman parte del proceso equipo. pes reconoce que los mejores equipos software son los autodirigidos. los miembros del equipo establecen los objetivos del proyecto, adaptan proceso para que cubra las necesi-dades, controlan programación actividades del proyecto , con medida análisis las mediciones efectuadas, trabajan manera continua mejora del enfoque ingeniería software que tiene equipo. igual que pps, pes enfoque riguroso para ingeniería software proporciona beneficios distintivos cuantificables productividad calidad. equipo debe tener com-promiso total con proceso recibir capacitación completa para asegurar que enfoque aplique forma apropiada. . tecnología del proceso equipo del software debe adaptar uno más los modelos del proceso estudiados las secciones precedentes. para ello, han desarrollado herramientas tecnología del proceso que ayudan las organizaciones software analizar proceso actual, organizar las tareas trabajo, controlar vigilar avance, administrar calidad técnica. las herramientas tecnología del proceso permiten que una organización software construya modelo automatizado estructura del proceso, conjuntos tareas activida-des sombrilla, estudiados sección .. modelo, que normalmente representa como modelo madurez capacidad (cmm), que una medida eficacia proceso del software, estudia capítulo . capítulo analiza importancia los equipos “autoorganizados” como elemento clave del desarrollo ágil del software.punto clave los scripts del pes definen elementos del proceso del equipo las actividades que ocurren dentro del proceso.para formar equipo autodirigido, usted debe colaborar bien interno comunicarse bien externo.consejo (-).indd (-).indd // ::// :: modelos del proceso una red, analiza para determinar flujo trabajo normal examinan estructuras alter- nativas del proceso que podrían llevar disminuir tiempo costo del desarrollo. una vez creado proceso aceptable, emplean otras herramientas tecnología para asignar, vigilar incluso controlar todas las actividades, acciones tareas ingeniería software definidas como parte del modelo del proceso. cada miembro equipo software utiliza dichas herramientas para desarrollar una lista verificación las tareas trabajo que deben realizarse. herramienta tecnología del proceso también usa para coordinar empleo otras herramientas ingeniería software que sean apropiadas para una tarea particular del trabajo. las herramientas mencionadas aquí son obligatorias, sino una muestra las que hay esta categoría. mayoría casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores.herramientas modelado del proceso objetivo: una organización trabaja para mejorar proceso ( software) negocios, primero debe entender- . las herramientas modelado del proceso (también llamadas herramientas tecnología del proceso administración del pro-ceso) usan para representar los elementos clave proceso, modo que entienda mejor. dichas herramientas también relacio-nan con descripciones del proceso que ayudan los involucrados entender las acciones tareas del trabajo que requieren para lle-varlo cabo. las herramientas modelado del proceso tienen víncu-los con otras que dan apoyo las actividades del proceso definido. mecánica: las herramientas esta categoría permiten que equipo defina los elementos modelo proceso único (accio-nes, tareas, productos del trabajo, puntos aseguramiento calidad, etc.), dan una guía detallada acerca del contenido descrip-ción cada elemento del proceso, después administran proceso conforme realiza. ciertos casos, las herramientas tecnología del proceso incorporan tareas estándar administración proyec-tos, tales como estimación, programación, seguimiento control. herramientas representativas: igrafx process tools: herramientas que permiten que equipo mapee, mida modele proceso del software ( grafx.com) adeptia bpm server: diseñado para administrar, automatizar opti- mizar procesos negocios ( speeddev suite: conjunto seis herramientas con mucho énfasis las actividades administración comunicación modelado ( software . producto proceso proceso deficiente, cabe duda que producto final sufrirá. pero también peli- grosa dependencia excesiva del proceso. ensayo corto escrito hace muchos años, margaret davis [dav] hace comentarios atemporales sobre dualidad del producto del proceso: cada diez años, más menos, comunidad del software redefine “ problema” por medio cambiar atención aspectos del producto aspectos del proceso. así, hemos adoptado lenguajes pro-gramación estructurada (producto) seguidos métodos análisis estructurados (proceso) que van seguidos por encapsulamiento datos (producto) los que siguieron énfasis actual modelo madurez capacidad, del instituto ingeniería software para desarrollo software (proceso) (seguido por métodos orientados objetos, los que sigue desarrollo ágil software). tanto que tendencia natural péndulo alcanzar estado reposo punto medio entre dos extremos, atención comunidad del software cambia constantemente porque aplica una nueva fuerza fallar última oscilación. estos vaivenes son dañinos mismos porque confunden profesional promedio del software cambiar forma radical que significa hacer trabajo bien. los cambios periódicos resuelven “ problema” porque están predestinados fallar toda vez que producto proceso son tratados como fueran una dicotomía lugar una dualidad. (-).indd (-).indd // ::// :: parte uno proceso del software comunidad científica existe precedente adoptar nociones dualidad cuando las con- tradicciones las observaciones pueden ser explicadas por alguna teoría alternativa. natura- leza dual luz, que parece ser mismo tiempo onda partícula, sido aceptada desde década , cuando propuso louis broglie. pienso que las observaciones que podemos hacer sobre conjunto del software desarrollo demuestran una dualidad fundamental entre producto proceso. nunca posible derivar obtener todo conjunto, contexto, uso, significado beneficios sólo como proceso sólo como producto… toda actividad humana proceso, pero cada uno nosotros obtiene sentido benefi- cio propio gracias aquellas actividades que dan como resultado una representación instancia que puede usar apreciar más una persona, utilizarla una otra vez, emplearla algún otro con-texto considerado. decir, obtenemos sentimientos satisfacción por reutilización nues-tros productos, sea que hagamos nosotros otras personas. entonces, bien rápida asimilación las metas reutilización desarrollo del software incrementa potencialmente satisfacción que obtienen los profesionales del software trabajo, también aumenta urgencia aceptación dualidad producto proceso. pensar artefacto reutilizable como fuera sólo producto sólo proceso oscurece contexto las formas emplearlo, bien oculta hecho que cada uso como resultado producto que vez será utilizado como entrada para alguna otra actividad desarrollo software. privilegiar punto vista sobre otro reduce mucho las oportunidades para reutilización , por tanto, pierde oportunidad aumentar satisfacción por trabajo. gente obtiene tanta ( más) satisfacción del proceso creativo como del producto final. artista disfruta las pinceladas tanto como resultado que enmarca. escritor goza bús- queda metáfora apropiada tanto como del libro terminado. como profesional creativo del software, usted también debe obtener tanta satisfacción del proceso como del producto final. dualidad producto proceso elemento importante para hacer que personas creativas involucren conforme ingeniería software evoluciona. . resumen modelo general del proceso para ingeniería software incluye conjunto actividades estructurales sombrilla, acciones tareas trabajo. cada uno los modelos proceso puede describirse por flujo distinto del proceso: descripción cómo organizan secuencial cronológicamente las actividades estructurales, acciones tareas. los patrones del proceso pueden utilizarse para resolver los problemas comunes que surgen como parte del proceso del software. los modelos proceso prescriptivo han aplicado durante muchos años esfuerzo por introducir orden estructura desarrollo software. cada uno dichos modelos sugiere flujo proceso algo distinto, pero todos llevan cabo mismo conjunto actividades estructurales generales: comunicación, planeación, modelado, construcción desarrollo. los modelos proceso secuencial, como cascada , son los paradigmas más antiguos del software. sugieren flujo lineal del proceso que con frecuencia congruente con las realidades modernas (cambio continuo, sistemas evolución, plazos ajustados, etc.) del mundo del software. sin embargo, tienen aplicación situaciones las que los requeri-mientos están bien definidos son estables. los modelos proceso incremental son naturaleza iterativa producen con mucha - pidez versiones funcionales del software. los modelos proceso evolutivo reconocen natu-raleza iterativa incremental mayoría proyectos ingeniería software están -señados para aceptar los cambios. los modelos evolutivos, tales como hacer prototipos espiral, generan rápido productos trabajo incremental ( versiones funcionales del soft-ware). estos modelos adoptan para aplicarse largo todas las actividades inge- (-).indd (-).indd // ::// :: modelos del proceso niería software, desde desarrollo del concepto hasta mantenimiento del sistema largo plazo. modelo proceso concurrente permite que equipo software represente los elemen- tos iterativos concurrentes cualquier modelo proceso. los modelos especializados -cluyen basado componentes, que pone énfasis reutilización ensamble los componentes; modelo métodos formales consiste enfoque basado matemáticas para desarrollar verificar software; modelo orientado aspectos implica preocupaciones globales que afectan toda arquitectura del sistema. proceso unificado proceso del software diseñado como estructura para los métodos herramientas del uml, está “impulsado por caso uso, centrado arquitectura, iterativo incremental”. han propuesto modelos personal del equipo para proceso del software. ambos enfa- tizan medición, planeación autodirección como los ingredientes clave para proceso exitoso del software. problemas puntos por evaluar .. introducción este capítulo, baetjer afirma que: “ proceso genera interacción entre usuarios diseñadores, entre usuarios herramientas cambiantes [tecnología].” enliste cinco preguntas que ) los - señadores deben responder los usuarios, ) los usuarios deben plantear los diseñadores, ) los usuarios deben hacerse mismos sobre producto software que elaborarse, ) los diseñadores deben plantearse acerca del producto software que construirse del proceso que usará para ello. .. trate desarrollar conjunto acciones para actividad comunicación. seleccione una acción defina conjunto tareas para ella... problema común durante comunicación ocurre cuando encuentra dos participantes que tienen ideas conflicto sobre que debe ser software, decir, que tienen requerimientos mutuamente conflictivos. desarrolle patrón del proceso (esto sería patrón etapa) con empleo plantilla presentada sección .. que aborda este problema sugiera enfoque eficaz para . .. investigue poco sobre pps haga una breve presentación que describa los tipos mediciones que pide hacer ingeniero individual software forma que pueden usarse para mejorar eficacia personal. .. uso scripts (mecanismo requerido pes) apreciado manera universal comuni- dad del software. haga una lista pros contras relación con los scripts sugiera menos dos situa- ciones las que serían útiles, otras dos las que generarían menos beneficios. .. lea [nog] escriba ensayo dos tres páginas donde analice efecto que tiene “caos” ingeniería software... tres ejemplos proyectos software que podrían efectuarse con modelo cascada. sea espe- cífico... proporcione tres ejemplos proyectos software que podrían abordarse con modelo hacer prototipos. sea específico... ¿qué adaptaciones del proceso requerirían proyecto evolucionara sistema producto que entregase?.. diga tres ejemplos proyectos software que podrían realizarse con modelo incremental. sea específico... conforme avanza hacia fuera por flujo proceso espiral, ¿qué puede decirse sobre software que está desarrollando que está mantenimiento?.. ¿ posible combinar modelos proceso? así, diga ejemplo. .. modelo proceso concurrente define conjunto “estados”. describa con sus propias palabras qué que representan, después indique cómo entran juego dentro del modelo proceso concu- rrente. (-).indd (-).indd // ::// :: parte uno proceso del software .. ¿cuáles son las ventajas desventajas desarrollar software que calidad “suficiente- mente buena”? decir, ¿qué pasa cuando pone énfasis velocidad desarrollo sobre calidad del producto? .. tres ejemplos proyectos software que serían abordables con modelo basado compo- nentes. sea específico. .. ¿ posible demostrar que componente software, incluso programa completo, correcto? entonces, ¿por qué todos hacen? .. ¿son mismo proceso unificado uml? explique respuesta. lecturas adicionales fuentes información mayor parte los libros ingeniería software consideran detalle los modelos proceso tradi- cionales. libros como sommerville ( software engineering, . ., addison-wesley, ), pfleeger atlee ( software engineering , . ., prentice-hall, ), schach (object-oriented and classical software engineering, . ., mcgraw-hill, ) consideran los paradigmas tradicionales estudian sus fortalezas debilidades. glass (facts and fallacies software engineering, prentice-hall, ) punto vista prag-mático crudo del proceso ingeniería software. aunque dedica específicamente proceso, brooks (the mythical man-month, . ., addison-wesley, ) presenta sabiduría antigua sobre los proyectos plantea que todo tiene que ver con proceso. firesmith henderson-sellers ( the open process framework: introduction , addison-wesley, ) presenta una plantilla general para crear “procesos software flexibles pero con disciplina” analiza los atributos objetivos del proceso. madachy (software process dynamics, wiley-ieee, ) estudia técnicas modelado que permiten analizar los elementos técnicos sociales interrelacionados del proceso del soft-ware. sharpe mcdermott ( workflow modeling: tools for process improvement and application development, artech house, ) presentan herramientas para modelar procesos tanto software como negocios. lim (managing software reuse, prentice-hall, ) estudia reutilización desde perspectiva del - rente. ezran, morisio tully ( practical software reuse, springer, ) jacobson, griss jonsson ( software reuse, addison-wesley, ) presentan mucha información útil sobre desarrollo basado componentes. heineman council ( component-based software engineering, addison-wesley, ) describen proceso requerido para implementar sistemas basados componentes. kenett baker ( software process quality: management and control, marcel dekker, ) analizan manera que conectan íntimamente administración calidad diseño del proceso. nygard ( release !: design and deploy production-ready software, pragmatic bookshelf, ) richard- son gwaltney ( ship ! practical guide successful software projects, pragmatic bookshelf, ) presentan una amplia colección lineamientos útiles aplicables actividad despliegue. además del libro fundamental jacobson, rumbaugh booch acerca del proceso unificado [jac], los libros arlow neustadt (uml and the unified process, addison-wesley, ), kroll kruchten ( the rational unified process made easy, addison-wesley, ) farve ( uml and the unified process, irm press, ) proveen información complementaria excelente. gibbs (project management with the ibm rational unified process, ibm press, ) analiza administración proyectos dentro del contexto del . internet existe una amplia variedad fuentes información sobre ingeniería software proceso del software. sitio web del libro, nal/olc/ser.htm, hay una lista actualizada referencias red mundial que son relevantes para proceso del software. (-).indd (-).indd // ::// :: ágil conceptos clave agilidad . . . . . . . . . . . . . . . . cristal . . . . . . . . . . . . . . . . . adaptativo software . . . . . . . . . . . . . desarrollo esbelto software . . . . . . . . . . . . . dic. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ágil . . . . . . . . . . . . . unificado ágil . . . . . . . . . . . . . . . . . . . . extrema. . . . . . por parejas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . del proyecto. . . . . . industrial. . . . . . . . . . . . . ¿qué ? ingeniería software ágil com- bina una filosofía con conjunto linea-mientos desarrollo. filosofía pone énfasis : satisfacción del cliente entrega rápida software incremental, los equipos pequeños muy motivados para efectuar proyecto, los métodos informales, los productos del trabajo con mínima ingeniería software sencillez general desarro-llo. los lineamientos desarrollo enfatizan entrega sobre análisis diseño (aunque estas actividades desalientan) comunicación activa continua entre desarrolladores clientes. ¿quién hace? los ingenieros software otros parti- cipantes proyecto (gerentes, clientes, usuarios finales, etc.) trabajan juntos proyecto ágil, formando equipo con organización propia que controla propio destino. equipo ágil facilita comunicación colabo-ración entre aquellos quienes sirve. ¿por qué importante? ambiente moderno nego- cios que genera sistemas basados computadora pro-ductos software evoluciona rápida constantemente. ingeniería software ágil representa una alternativa razonable ingeniería software convencional para ciertas clases software algunos tipos proyectos. asimismo, demostrado que concluye con rapidez sistemas exitosos. ¿cuáles son los pasos? nombre más apropiado para desarrollo ágil sería “ingeniería software ligero”. permanecen las actividades estructurales fundamentales: comunicación, planeación, modelado, construcción des-pliegue. pero transforman conjunto mínimo tareas que lleva equipo del proyecto hacia construc-ción entrega (algunas personas dirían que esto hace costa del análisis del problema del diseño solu-ción). ¿cuál producto final? tanto cliente como ingeniero software tienen misma perspectiva: único producto del trabajo realmente importante “incre-mento software” operativo que entrega cliente exactamente fecha acordada. ¿cómo aseguro que hice bien? trabajo estará bien hecho equipo ágil concuerda que proceso funciona que produce incrementos soft-ware utilizables que satisfagan cliente. una mirada rápida ocasiones conoce los métodos ágiles como métodos ligeros métodos esbeltos. , kent beck otros notables desarrolladores software, escritores consulto- res [bec] (grupo conocido como “alianza ágil”) firmaron “manifiesto por desa-rrollo ágil software”. establecía siguiente: estamos descubriendo formas mejores desarrollar software, por medio hacerlo dar ayuda otros para que hagan. ese trabajo nos hecho valorar: los individuos sus interacciones, sobre los procesos las herramientas software que funciona, más que documentación exhaustivala colaboración con cliente, tanto negociación del contratoresponder cambio, mejor que apegarse planes decir, bien son valiosos los conceptos que aparecen segundo lugar, valoramos más los que aparecen primer sitio. manifiesto normalmente asocia con movimiento político emergente: ataca vieja guardia sugiere cambio revolucionario ( espera que para mejorar). cierta forma, eso que trata desarrollo ágil. aunque las ideas subyacentes que guían han estado durante muchos años entre nosotros, sido menos dos décadas que cristalizaron “movimiento”. los métodos ágiles desarrollaron como esfuerzo por superar las debilidades reales percibidas ingeniería software convencional. desarrollo ágil proporciona beneficios importantes, pero (-).indd (-).indd // ::// :: parte uno proceso del software aplicable todos los proyectos, productos, personas situaciones. antítesis prác- tica ingeniería software sólida puede aplicarse como filosofía general para todo trabajo software. frecuente que economía moderna sea difícil imposible predecir forma que evolucionará sistema basado computadora (por ejemplo, una aplicación con base web). las condiciones del mercado cambian con rapidez, las necesidades los usuarios finales transforman emergen nuevas amenazas competitivas sin previo aviso. muchas situacio-nes será posible definir los requerimientos por completo antes que proyecto comience. debe ser suficientemente ágil para responder fluido que presenta ambiente -gocios. fluidez implica cambio, cambio caro, particular descontrolado - ministra mal. una las características más atractivas del enfoque ágil capacidad -ducir los costos del cambio durante proceso del software. ¿significa esto que reconocimiento los retos planteados por las realidades modernas hace que sean descartables los valiosos principios, conceptos, métodos herramientas ingeniería del software? , absoluto… igual que todas las disciplinas ingeniería, del software evoluciona forma continua. puede adaptarse con facilidad para que satisfaga los desafíos que surgen demanda agilidad. libro que suscita reflexión sobre desarrollo software ágil, alistair cockburn [coco] argumenta que los modelos proceso prescriptivo, introducidos capítulo , tie-nen una falla grande: olvidan las flaquezas las personas cuando construyen software . los inge- nieros software son robots. sus estilos trabajo varían mucho; tienen diferencias signi-ficativas habilidad, creatividad, orden, consistencia espontaneidad. algunos comunican bien por escrito, pero otros . cockburn afirma que los modelos proceso pueden “manejar las carencias disciplina tolerancia las personas comunes” que los modelos proceso más prescriptivo eligen disciplina. dice: “como consistencia las acciones una debili-dad humana, las metodología que requieren mucha disciplina son frágiles.” para funcionar, los modelos proceso deben proveer mecanismo realista que estimule disciplina necesaria, deben caracterizarse por “tolerancia” con las personas que hacen trabajo ingeniería software. invariablemente, las prácticas tolerantes son más fáciles adoptar sostener por parte comunidad del software, pero son menos productivas (como admite cockburn). debe considerarse negociación entre ellas, como todas las cosas vida. . ¿ agilidad ? pero, ¿qué agilidad contexto del trabajo ingeniería software? ivar jacobson [jac] hace análisis útil: agilidad convertido palabra mágica hoy para describir proceso del software - derno. todos son ágiles. equipo ágil diestro capaz responder manera apropiada los cambios. cambio que trata software gran medida. hay cambios software que construye, los miembros del equipo, debidos las nuevas tecnologías, todas clases que tienen efecto producto que elabora proyecto que crea. deben introducirse apoyos para cambio todo que haga software; ocasiones hace porque alma corazón éste. equipo ágil reconoce que software desarrollado por individuos que trabajan equipo, que capacidad, habilidad para colaborar, fundamento para éxito del proyecto. desde punto vista jacobson, ubicuidad del cambio motor principal agilidad. los ingenieros software deben rápido han adaptarse los cambios veloces que des-cribe jacobson.cita: “agilidad: , todo demás: .” tom demarco (-).indd (-).indd // ::// :: desarrollo ágil pero agilidad algo más que una respuesta efectiva cambio. también incluye filoso- fía expuesta manifiesto citado principio este capítulo. ésta recomienda las estructuras equipo las actitudes que hacen más fácil comunicación (entre los miembros del equipo, tecnólogos gente negocios, entre los ingenieros software sus gerentes, etc.); pone énfasis entrega rápida software funcional resta importancia los productos interme-dios del trabajo ( que siempre bueno); adopta cliente como parte del equipo desa-rrollo trabaja para eliminar actitud “nosotros ellos” que todavía invade muchos proyec-tos software; reconoce que planeación mundo incierto tiene sus límites que plan proyecto debe ser flexible. agilidad puede aplicarse cualquier proceso del software. sin embargo, para lograrlo esencial que éste diseñe forma que permita equipo del proyecto adaptar las tareas hacerlas directas, ejecutar planeación manera que entienda fluidez enfoque ágil del desarrollo, eliminar todos los productos del trabajo excepto los más esenciales mantener-los esbeltos, poner énfasis una estrategia entrega incremental que haga trabajar software tan rápido como sea posible para cliente, según tipo producto ambiente operación. . agilidad costo del cambio sabiduría convencional del desarrollo software (apoyada por décadas experiencia) señala que costo incrementa forma lineal medida que proyecto avanza (véase figura ., curva continua negra). relativamente fácil efectuar cambio cuando equipo software reúne los requerimientos ( principio proyecto). escenario uso tal vez tenga que modificarse, lista funciones puede aumentar, editarse una especificación -crita. los costos hacer que esto funcione son mínimos, tiempo requerido perjudicará resultado del proyecto. pero, ¿qué pasa una vez transcurridos algunos meses? equipo está mitad las pruebas validación (algo que ocurre cuando proyecto está relativamente avanzado) participante importancia solicita que haga cambio funcional grande. cambio requiere modificar diseño arquitectura del software, diseño construcción tres componentes nuevos, hacer cambios otros cinco componentes, diseñar nuevas pruebas, etc. los costos aumentan con rapidez, son pocos tiempo dinero requeridos para asegurar que haga cambio sin efectos colaterales intencionados. los defensores agilidad (por ejemplo [bec] [amb]) afirman que proceso ágil bien diseñado “aplana” costo curva cambio (véase figura ., curva continua cometa error suponer que agilidad permiso para improvisar soluciones. requiere proceso, disciplina esencial.consejo costo del cambio con empleo procesosconvencionales software costo del cambio conel uso procesos ágiles costo idealizado del cambiocon uso proceso ágil avance programación del desarrollocosto del desarrollofigura . cambio los costos como función del tiempo trans-currido desarrollocita: “ agilidad dinámica, espe- cífica contenido, acepta con entusiasmo cambio orienta crecimiento.” steven goldman . (-).indd (-).indd // ::// :: parte uno proceso del software sombreada), que permite que equipo software haga cambios una fase tardía proyecto software sin que haya efecto notable costo tiempo. lector sabe que proceso ágil incluye entrega incremental. cuando ésta acopla con otras prácticas ágiles, como las pruebas unitarias continuas programación por parejas (que estudia más adelante, este capítulo), costo hacer cambio disminuye. aunque hay debate sobre grado que aplana curva costo, existen evidencias [coc] que sugieren que posible lograr una reducción significativa del costo. . ¿ proceso ágil? cualquier proceso del software ágil caracteriza por forma que aborda cierto número suposiciones clave [fow] acerca mayoría proyectos software: . difícil predecir qué requerimientos software persistirán cuáles cambiarán. tam- bién difícil pronosticar cómo cambiarán las prioridades del cliente medida que avanza proyecto. . para muchos tipos software, diseño construcción están imbricados. decir, ambas actividades deben ejecutarse forma simultánea, modo que los modelos diseño prueben medida que crean. difícil predecir cuánto diseño necesita antes que use construcción para probar diseño. . análisis, diseño, construcción las pruebas son tan predecibles como nos gustaría (desde punto vista planeación). dadas estas tres suposiciones, surge una pregunta importante: ¿cómo crear proceso que pueda manejar impredecible? respuesta, como dijo, está adaptabilidad del pro-ceso ( cambio rápido del proyecto las condiciones técnicas). por tanto, proceso ágil debe ser adaptable. pero adaptación continua logra muy poco hay avance. entonces, proceso soft- ware ágil debe adaptarse incrementalmente. para lograr adaptación incremental, equipo ágil requiere retroalimentación con cliente ( modo que sea posible hacer las adaptaciones apropiadas). catalizador eficaz para retroalimentación con cliente prototipo ope-rativo una porción sistema operativo. así, debe instituirse una estr ategia desarrollo incremental. deben entregarse incrementos software (prototipos ejecutables porciones sistema operativo) periodos cortos tiempo, modo que adaptación vaya ritmo con cambio (impredecible). este enfoque iterativo permite que cliente evalúe forma regu-lar incremento software, retroalimentación necesaria equipo software influya las adaptaciones del proceso que realicen para aprovechar retroalimentación. .. principios agilidad alianza ágil (véase [agi]), [fow]) define principios agilidad para aquellos que quieran alcanzar: . prioridad más alta satisfacer cliente través entrega pronta continua software valioso. . son bienvenidos los requerimientos cambiantes, aun una etapa avanzada del desa- rrollo. los procesos ágiles dominan cambio para pro vecho ventaja competitiva del cliente. . entregar con frecuencia software que funcione, dos semanas par meses, preferencia más pronto que pueda.punto clave proceso ágil reduce costo del cambio porque software entrega incrementos esta forma cambio controla mejor. webref dirección articles/index hay una colección completa artículos sobre proceso ágil. punto clave aunque los procesos ágiles aceptan cambio, importante examinar las razones éste. (-).indd (-).indd // ::// :: desarrollo ágil . las personas negocios los desarrolladores deben trabajar juntos, diario durante todo proyecto. . hay que desarrollar los proyectos con individuos motivados. debe darse éstos - biente apoyo que necesiten, confiar que harán trabajo. . método más eficiente eficaz para transmitir información los integrantes equipo desarrollo, entre éstos, con versación cara cara. . medida principal avance software que funciona. . los procesos ágiles promueven desarrollo sostenible. los patrocinadores, desarrolla- dores usuarios deben poder mantener ritmo constante forma indefinida. . atención continua excelencia técnica buen diseño mejora agilidad. . esencial simplicidad: arte maximizar cantidad trabajo realizado. . las mejores arquitecturas, requerimientos diseños surgen los equipos con organi- zación propia. . equipo reflexiona intervalos regulares sobre cómo ser más eficaz, para después afi- nar ajustar comportamiento consecuencia. todo modelo proceso ágil aplica estos principios con igual intensidad algunos eligen ignorar ( menos soslayar) importancia uno más ellos. sin embargo, los principios definen espíritu ágil que mantiene cada uno los modelos proceso que presen-tan este capítulo. .. política del desarrollo ágil hay mucho debate ( veces estridente) sobre los beneficios aplicabilidad del desarrollo software ágil como oposición los procesos más convencionales. jim highsmith [hig] señala ( tono burla) los extremos cuando caracteriza posición del campo favor agilidad (“agilistas”). “los metodólogos tradicionales están atrapados pantano producirán una documentación sin defectos vez sistema funcional que satisfaga las necesidades del negocio.” como contrapunto, plantea ( nuevo como burla) posición del campo inge-niería software tradicional: “los metodólogos ligeros, perdón, ‘ágiles’, son grupo -mendones famosos que van llevar una sorpresa cuando intenten convertir sus juguetes software medida empresa.” como todos los argumentos sobre tecnología software, este debate sobre metodolo- gía corre riesgo degenerar una guerra religiosa. estalla, desaparece pensamiento racional que guía toma decisiones son las creencias los hechos. nadie está contra agilidad. pregunta real : ¿cuál mejor forma lograrla? igual importancia: ¿cómo construir software que satisfaga momento las necesidades los clientes que tenga características calidad que permitan ampliarlo escalarlo para que tam-bién las satisfaga largo plazo? hay respuestas absolutas ninguna estas preguntas. aun dentro escuela ágil hay muchos modelos proceso propuestos (véase sección .), cada uno con enfoque algo diferente para problema agilidad. dentro cada modelo hay conjunto “ideas” (los agilistas las llaman “tareas del trabajo”) que representan alejamiento significativo inge-niería software tradicional. obstante, muchos conceptos ágiles sólo son adaptaciones algunos que provienen buena ingeniería software. resumen: hay mucho por ganar considera mejor ambas escuelas, virtualmente gana nada denigra cual-quiera los enfoques. lector está interesado, consulte [hig], [hig] [dem] para ver resumen ameno otros aspectos técnicos políticos importantes. software que funciona importante, pero olvide que también debe poseer varios atributos calidad, como ser confiable, utilizable susceptible recibir mantenimiento.consejo tiene que elegirse entre agilidad ingeniería software. vez ello, hay que definir enfoque ingeniería software que sea ágil.consejo (-).indd (-).indd // ::// :: parte uno proceso del software .. factores humanos los defensores del desarrollo software ágil toman muchas molestias para enfatizar importancia los “factores personales”. como dicen cockburn highsmith [coc]: “ desa-rrollo ágil centra los talentos habilidades los individuos, adapta proceso perso-nas equipos específicos.” punto clave esta afirmación que proceso adapta las necesidades las personas del equipo, revés. los miembros del equipo software son los que van generar las características del pro- ceso que van aplicarse elaboración software, entre ellos debe existir cierto número características clave, mismas que debe compartir equipo ágil como tal: competencia. contexto desarrollo ágil (así como ingeniería software), “competencia” incluye talento innato, las habilidades específicas relacionadas con software conocimiento general del proceso que equipo haya elegido aplicar. habi-lidad conocimiento del proceso pueden deben considerarse para todas las personas que sean miembros ágiles del equipo. enfoque común. aunque los miembros del equipo ágil realicen diferentes tareas apor- ten habilidades distintas proyecto, todos deben centrarse una meta: entregar cliente fecha prometida incremento software que funcione. para lograrlo, equipo también centrará adaptaciones continuas (pequeñas grandes) que hagan que proceso ajuste las necesidades del equipo. colaboración. ingeniería software (sin importar proceso) trata evaluar, anali- zar usar información que comunica equipo software; crear información que ayudará todos los participantes entender trabajo del equipo; generar información (software cómputo bases datos relevantes) que aporten cliente valor del negocio. para efectuar estas tareas, los miembros del equipo deben colaborar, entre con todos los participantes. habilidad para tomar decisiones. cualquier equipo bueno software (incluso los equipos ágiles) debe tener libertad para controlar destino. esto implica que auto- nomía equipo: autoridad para tomar decisiones sobre asuntos tanto técnicos como del proyecto. capacidad para resolver problemas difusos. los gerentes software deben recono- cer que equipo ágil tendrá que tratar forma continua con ambigüedad que será sacudido manera permanente por cambio. ciertos casos, equipo debe aceptar hecho que problema que resuelven ahora tal vez sea que necesite resolver mañana. sin embargo, las lecciones aprendidas cualquier actividad relacionada con solución problemas (incluso aquellas que resuelven problema equivocado) serán -néficas para equipo una etapa posterior del proyecto. confianza respeto mutuos. equipo ágil debe convertirse que demarco lis- ter [dem] llaman “pegado” (véase capítulo ). equipo pegado tiene confianza respeto que son necesarios para hacer “ tejido tan fuerte que todo más que suma sus partes” [dem]. organización propia. contexto del desarrollo ágil, organización propia implica tres cosas: ) equipo ágil organiza mismo para hacer trabajo, ) equipo orga- niza proceso que adapte mejor ambiente local, ) equipo organiza progra-mación del trabajo fin que logre del mejor modo posible entrega del incremento las organizaciones exitosas ingeniería software reconocen esta realidad sin importar modelo proceso que elijan.cita: “los métodos ágiles obtienen gran parte agilidad por basarse conocimiento táci- incorporado equipo, más que escribir conoci-miento planes.” barry boehm ¿qué características clave deben existir entre los integrantes equipo eficaz software?? cita: “ que para equipo ape-nas suficiente, para otro más que suficiente para otro más resulta insuficiente.” alistair cockburn punto clave equipo con organización propia tiene control del trabajo que realiza. establece sus propios compromisos define los planes para lograrlo. (-).indd (-).indd // ::// :: desarrollo ágil software. organización propia tiene cierto número beneficios técnicos, pero, que más importante, sirve para mejorar colaboración elevar moral del equipo. esencia, equipo sirve como propio gerente. ken schwaber [sch] aborda estos -pectos cuando escribe: “ equipo selecciona cuánto trabajo cree que puede realizar cada iteración, compromete con labor. nada desmotiva tanto equipo como que alguien establezca compromisos por . nada motiva más equipo como aceptar res-ponsabilidad cumplir los compromisos que haya hecho mismo.” . programación extrema () fin ilustrar proceso ágil con más detalle, daremos panorama programación - trema (), enfoque más utilizado del desarrollo software ágil. aunque las primeras activi-dades con las ideas los métodos asociados ocurrieron final década , trabajo fundamental sobre materia había sido escrito por kent beck [bec]. una variante llamada industrial [ixp] propuso una época más reciente [ker]. ixp mejora tiene como objetivo proceso ágil para ser usado específicamente organizaciones grandes. .. valores beck [bec] define conjunto cinco valores que establecen fundamento para todo tra- bajo realizado como parte : comunicación, simplicidad, retroalimentación, valentía respeto. cada uno estos valores usa como motor para actividades, acciones tareas específicas . fin lograr comunicación eficaz entre los ingenieros software otros participantes (por ejemplo, para establecer las características funciones requeridas para software), pone énfasis colaboración estrecha pero informal (verbal) entre los clientes los desarrollado-res, establecimiento metáforas para comunicar conceptos importantes, retroali- mentación continua evitar documentación voluminosa como medio comunicación. para alcanzar simplicidad, restringe los desarrolladores para que diseñen sólo para las necesidades inmediatas, lugar considerar las del futuro. objetivo crear diseño sencillo que implemente con facilidad forma código. hay que mejorar diseño, rediseñará momento posterior. retroalimentación obtiene tres fuentes: software implementado, cliente otros miembros del equipo software. diseñar implementar una estrategia pruebas eficaz (capítulos ), software (por medio los resultados las pruebas) retroalimentación equipo ágil. usa prueba unitaria como táctica principal pruebas. medida que desarrolla cada clase, equipo implementa una prueba unitaria para ejecutar cada operación acuerdo con funcionalidad especificada. cuando entrega incremento cliente, las historias del usuario casos uso (véase capítulo ) que implementan con incre- mento utilizan como base para las pruebas aceptación. grado que software implementa salida, función comportamiento del caso uso una forma retroalimen-tación. por último, conforme obtienen nuevos requerimientos como parte planeación iterativa, equipo cliente una retroalimentación rápida con miras costo efecto programación actividades. contexto , una metáfora “una historia que cada quien —clientes, programadores gerentes— narra, acerca cómo funciona sistema” [bec]. rediseño permite que ingeniero mejore estructura interna diseño ( código fuente) sin cambiar funcionalidad comportamiento externos. esencia, rediseño puede utilizarse para mejorar eficiencia, disponibilidad rendimiento diseño del código que implementa.mantenlo sencillo siempre que pueda, pero reconoce que “rediseño” continuo consume mucho tiempo recursos.consejo (-).indd (-).indd // ::// :: parte uno proceso del software beck [bec] afirma que adhesión estricta ciertas prácticas requiere valentía. término más apropiado sería disciplina. por ejemplo, frecuente que haya mucha presión para diseñar requerimientos futuros. mayor parte equipos software sucumben ella justifican porque “diseñar para mañana” ahorrará tiempo esfuerzo largo plazo. equipo ágil debe tener disciplina (valentía) para diseñar para hoy reconocer que los -querimientos futuros tal vez cambien mucho, por que demandarán repeticiones sustanciales del diseño del código implementado. apegarse cada uno estos valores, equipo ágil inculca respeto entre sus miembros, entre otros participantes los integrantes del equipo, indirectamente para software mismo. conforme logra entrega exitosa incrementos software, equipo desarrolla más respeto para proceso . .. proceso programación extrema usa enfoque orientado objetos (véase apéndice ) como para-digma preferido desarrollo, engloba conjunto reglas prácticas que ocurren contexto cuatro actividades estructurales: planeación, diseño, codificación pruebas. -gura . ilustra proceso resalta algunas las ideas tareas clave que asocian con cada actividad estructural. los párrafos que siguen resumen las actividades clave. planeación. actividad planeación (también llamada juego planeación) comienza - cuc hando —actividad para recabar requerimientos que permite que los miembros técnicos del equipo entiendan contexto del negocio para software adquieran sensibilidad salida características principales funcionalidad que requieren—. escuchar lleva crea-ción algunas “historias” (también llamadas historias del usuario) que describen salida - cesaria, características funcionalidad del software que elaborar. cada historia (similar los casos uso descritos capítulo ) escrita por cliente colocada una tarjeta indizada. cliente asigna valor ( decir, una prioridad) historia con base valor general característica función para negocio. después, los miembros del equipo cita: “ respuesta pregun- : ‘¿cuán pequeño podemos hacer gran software?’.” anónimo ¿qué una “historia” ??webref dirección www. extremeprogramming.org/rules.html, encuentra panorama excelente las “reglas” . historias del usuario valores criterios pruebas aceptaciónplan iteracióndiseño simple tarjetas crc prueba unitaria integración continuaincremento software velocidad calculada del proyectosoluciones punta prototipos rediseño programación por parejas pruebas aceptaciónlanzamientodiseño codiﬁcaciónplaneación pruebafigura . proceso programación extrema valor una historia también puede depender presencia otra historia. (-).indd (-).indd // ::// :: desarrollo ágil evalúan cada historia asignan costo, medido semanas desarrollo. estima que historia requiere más tres semanas desarrollo, pide cliente que descomponga historias más chicas nuevo asigna valor costo. importante observar que cualquier momento posible escribir nuevas historias. los clientes desarrolladores trabajan juntos para decidir cómo agrupar las historias siguiente entrega ( siguiente incremento software) que desarrollará equipo . una vez que llega compromiso sobre entrega (acuerdo sobre las historias por incluir, fecha entrega otros aspectos del proyecto), equipo ordena las historias que serán desarro-lladas una tres formas: ) todas las historias implementarán inmediato ( pocas semanas), ) las historias con más valor entrarán programación actividades imple-mentarán primer lugar ) las historias más riesgosas formarán parte programación actividades implementarán primero. después primera entrega del proyecto (también llamada incremento software), equipo calcula velocidad éste. pocas palabras, velocidad del proyecto número historias los clientes implementadas durante primera entrega. velocidad del proyecto usa para: ) ayudar estimar las fechas entrega programar las actividades para las -tregas posteriores, ) determinar hecho gran compromiso para todas las historias durante todo desarrollo del proyecto. esto ocurre, modifica contenido las entregas cambian las fechas entrega final. medida que avanza trabajo, cliente puede agregar historias, cambiar valor una existente, descomponerlas eliminarlas. entonces, equipo reconsidera todas las entre-gas faltantes modifica sus planes consecuencia. diseño. diseño sigue rigurosamente principio (mantenlo sencillo). diseño sencillo siempre prefiere sobre una representación más compleja. además, diseño guía implementación una historia conforme escribe: nada más nada menos. desalienta diseño funcionalidad adicional porque desarrollador supone que requerirá después. estimula uso las tarjetas crc (véase capítulo ) como mecanismo eficaz para pensar software contexto orientado objetos. las tarjetas crc (clase-responsabili-dad-colaborador) identifican organizan las clases orientadas objetos que son relevantes para incremento actual software. equipo dirige ejercicio diseño con uso proceso similar que describe capítulo . las tarjetas crc son único producto del trabajo diseño que genera como parte del proceso . diseño una historia encuentra problema diseño difícil, recomienda creación inmediata prototipo operativo esa porción del diseño. entonces, imple-menta evalúa prototipo del diseño, llamado solución punta. objetivo disminuir riesgo cuando comience implementación verdadera validar las estimaciones originales para historia que contiene problema diseño. sección anterior dijo que estimula rediseño, técnica construcción que tam- bién método para optimización del diseño. fowler [fow] describe rediseño del modo siguiente: rediseño proceso mediante cual cambia sistema software forma tal que altere comportamiento externo del código, pero mejore estructura interna. una manera discipli-nada limpiar código [ modificar simplificar diseño interno] que minimiza probabilidad introducir errores. esencia, cuando rediseña, mejora diseño del código después haber sido escrito.punto clave velocidad del proyecto una medición sutil productividad del equipo. desalienta importancia del diseño, opinión con que todos están acuerdo. realidad, hay veces las que debe hacerse énfasis diseño.consejowebref dirección .com/cgi/ wiki?planninggame, halla “juego planeación” provechoso. estos lineamientos diseño deben seguirse todo método ingeniería software, aunque hay ocasiones los que notación terminología sofisticadas del diseño son camino hacia simplicidad. las clases orientadas objetos estudian apéndice , capítulo toda parte este libro.webref dirección encuentran técnicas herramientas rediseño. (-).indd (-).indd // ::// :: parte uno proceso del software como diseño virtualmente utiliza notación genera pocos, alguno, productos del trabajo que sean tarjetas crc soluciones punta, diseño visto como artefacto transición que puede debe modificarse continuamente medida que avanza construcción. objetivo del rediseño controlar dichas modificaciones, sugiriendo pequeños cambios diseño que “son capaces mejorarlo forma radical” [fow]. sin embargo, debe notarse que esfuerzo que requiere rediseño aumenta forma notable con tamaño aplicación. concepto central que diseño ocurre tanto antes como después que comienza codificación. rediseñar significa que diseño hace manera continua conforme cons-truye sistema. realidad, actividad construcción misma dará equipo una guía para mejorar diseño. codificación. después que las historias han sido desarrolladas que hecho trabajo diseño preliminar , equipo inicia codificación, sino que desarrolla una serie pruebas unitarias cada una las historias que van incluir entrega curso (incre- mento software). una vez creada prueba unitaria, desarrollador está mejor capacitado para centrarse que debe implementarse para pasar prueba. agrega nada extraño (). una vez que código está terminado, aplica inmediato una prueba unitaria, con que obtiene retroalimentación instantánea para los desarrolladores. concepto clave durante actividad codificación ( uno los aspectos del que más habla ) programación por parejas . recomienda que dos personas trabajen juntas una estación trabajo con objeto crear código para una historia. esto meca-nismo para solución problemas tiempo real ( frecuente que dos cabezas piensen más que una) para aseguramiento calidad también tiempo real ( código revisa con-forme crea). también mantiene los desarrolladores centrados problema que trate. práctica, cada persona adopta papel poco diferente. por ejemplo, una ellas tal vez piense los detalles del código una porción particular del diseño, mientras otra asegura que siguen los estándares codificación (parte necesaria ) que código para historia satisfará prueba unitaria desarrollada fin validar código con-frontándolo con historia. medida que las parejas programadores terminan trabajo, código que desarrollan integra con trabajo los demás. ciertos casos, esto lleva cabo diario equipo integración. otros, las parejas programadores tienen responsabilidad integra-ción. esta estrategia “integración continua” ayuda evitar los problemas compatibilidad interfaces brinda ambiente “prueba humo” (véase capítulo ) que ayuda des-cubrir tiempo los errores. pruebas. dijo que creación pruebas unitarias antes que comience codificación elemento clave del enfoque . las pruebas unitarias que crean deben implemen-tarse con uso una estructura que permita automatizarlas ( modo que puedan ejecutarse repetidas veces con facilidad). esto estimula una estrategia pruebas regresión (véase capítulo ) siempre que modifique código ( que ocurre con frecuencia, dada filoso-fía del rediseño ). medida que organizan las pruebas unitarias individuales “grupo prueba univer- sal” [wel], las pruebas integración validación del sistema pueden efectuarse diario. esto equipo una indicación continua del avance también lanza señales alerta las este enfoque equivalente saber las preguntas del examen antes comenzar estudiar. vuelve mucho más fácil estudio porque centra atención sólo las preguntas que van responder. prueba unitaria, que estudia detalle capítulo , centra componente software individual sobre interfaz, estructuras datos funcionalidad del componente, esfuerzo por descubrir errores locales del componente.punto clave rediseño mejora estructura interna diseño ( código fuente) sin cambiar funcionalidad comportamiento externo. muchos equipos software están llenos individualistas. programación por parejas funcionar con eficacia, tendrá que trabajar para cambiar esa cultura.consejo¿qué programación por parejas??webref hay información útil acerca dirección ¿cómo usan las pruebas unitarias ?? (-).indd (-).indd // ::// :: desarrollo ágil cosas marchan mal. wells [wel] dice: “corregir pequeños problemas cada cierto número horas toma menos tiempo que resolver problemas enormes justo antes del plazo final.” las pruebas aceptación , también llamadas pruebas del cliente, son especificadas por cliente centran las características funcionalidad generales del sistema que son visibles revisables por parte del cliente. las pruebas aceptación derivan las historias los usuarios que han implementado como parte liberación del software. .. industrial joshua kerievsky [ker] describe programación extrema industrial [ixp, por sus siglas - glés] forma siguiente: “ixp evolución orgánica . está imbuida del espíritu mini-malista, centrado cliente orientado las pruebas que tiene . ixp difiere sobre todo original mayor inclusión gerencia, papel más amplio los clientes sus prácticas técnicas actualizadas”. ixp incorpora seis prácticas nuevas diseñadas para ayudar garantizar que proyecto funciona con éxito para proyectos significativos dentro una organización grande. evaluación factibilidad. antes iniciar proyecto ixp, organización debe efectuar una evaluación factibilidad. ésta deja claro : ) existe ambiente apro-piado desarrollo que acepte ixp, ) equipo estará constituido por los participantes adecuados, ) organización tiene programa calidad distintivo apoya mejora continua, ) cultura organizacional apoyará los nuevos valores equipo ágil, ) comunidad extendida del proyecto estará constituida modo apropiado. comunidad del proyecto. clásica sugiere que utilice personal apropiado para formar equipo ágil fin asegurar éxito. implicación que las personas equipo deben estar bien capacitadas, ser adaptables hábiles, tener temperamento apropiado para contribuir equipo con organización propia. cuando aplica pro-yecto significativo una organización grande, concepto “equipo” debe adoptar forma comunidad. una comunidad puede tener tecnólogo clientes que son funda-mentales para éxito del proyecto, así como muchos otros participantes (equipo jurídico; auditores calidad, tipos manufactura ventas, etc.) que “con frecuencia -cuentran periferia proyecto ixp, pero que desempeñan éste papeles impor-tantes” [ker]. ixp, los miembros comunidad sus papeles deben definirse modo explícito, así como establecer los mecanismos para comunicación coordinación entre los integrantes comunidad. calificación del proyecto. equipo ixp evalúa proyecto para determinar existe una justificación apropiada negocios proyecto cumplirá las metas objetivos - nerales organización. calificación también analiza contexto del proyecto fin determinar cómo complementa, extiende reemplaza sistemas procesos existentes. administración orientada pruebas. proyecto ixp requiere criterios medibles para evaluar estado del proyecto avance realizado. administración orientada pruebas establece una serie “destinos” medibles [ker] luego define los mecanismos para -terminar han alcanzado éstos. retrospectivas. después entregar incremento software, equipo realiza una revisión técnica especializada que llama retrospectiva que examina “los temas, eventos lecciones aprendidas” [ker] largo del incremento software / -beración todo software. objetivo mejorar proceso ixp. aprendizaje continuo. como aprendizaje una parte vital del proceso mejora continua, los miembros del equipo son invitados ( tal vez incentivados) aprender nuevos métodos técnicas que conduzcan una calidad más alta del producto.punto clave las pruebas aceptación derivan las historias los usuarios. ¿qué nuevas prácticas agregan para crear ixp?? cita: “habilidad aquello que eres capaz hacer. motivación determina que haces. acti-tud determina cuán bien haces.” lou holtz (-).indd (-).indd // ::// :: parte uno proceso del software además las seis nuevas prácticas analizadas, ixp modifica algunas las existentes . desarrollo impulsado por historia (dih) insiste que las historias las pruebas acepta- ción escriban antes generar una sola línea código. diseño impulsado por dominio (did) una mejora sobre concepto “metáfora del sistema” usado . did [eva] sugiere creación evolutiva modelo dominio que “represente con exactitud cómo pien-san los expertos del dominio materia” [ker]. formación parejas amplía concepto programación pareja para que incluya los gerentes otros participantes. objetivo mejorar manera compartir conocimientos entre los integrantes del equipo que estén directamente involucrados desarrollo técnico. usabilidad iterativa desalienta diseño una interfaz cargada frente estimula diseño que evoluciona medida que liberan los incrementos software que estudia interacción los usuarios con software. ixp hace modificaciones más pequeñas otras prácticas redefine ciertos roles res- ponsabilidades para hacerlos más asequibles proyectos significativos las organizaciones grandes. para mayores detalles ixp, visite sitio http://industrialxp.org. .. debate los nuevos modelos métodos proceso han motivado análisis provechosos ciertas ins-tancias debates acalorados. programación extrema desencadena ambos. libro intere-sante que examina eficacia , stephens rosenberg [ste] afirman que muchas prácti-cas son benéficas, pero que otras están sobreestimadas unas más son problemáticas. los autores sugieren que naturaleza codependiente las prácticas constituye tanto fortaleza como debilidad. debido que muchas organizaciones adoptan sólo subconjunto prácticas , debilitan eficacia todo proceso. los defensores contradicen esto afir-mar que está evolución continua que muchas las críticas que hacen han lle-vado correcciones conforme maduran sus prácticas. entre los aspectos que destacan algunos críticos están los siguientes: • volatilidad los requerimientos. como cliente miembro activo del equipo , los cambios los requerimientos solicitan manera informal. consecuencia, alcance del proyecto cambia trabajo inicial tiene que modificarse para dar acomodo las nuevas necesidades. los defensores afirman que esto pasa sin importar proceso que aplique que proporciona mecanismos para controlar los vaivenes del alcance. • necesidades conflictivas del cliente. muchos proyectos tienen clientes múltiples, cada uno con sus propias necesidades. , equipo mismo tiene tarea asimilar las necesi-dades distintos clientes, trabajo que tal vez esté más allá del alcance autoridad. • los requerimientos expresan informalmente. las historias usuario las pruebas aceptación son única manifestación explícita los requerimientos . los críticos afirman que frecuente que necesite modelo especificación más formal para garantizar que descubran las omisiones, inconsistencias errores antes que construya sistema. los defensores contraatacan diciendo que naturaleza cambiante los requerimientos vuelve obsoletos esos modelos especificaciones casi tan pronto como desarrollan. • falta diseño formal. desalienta necesidad del diseño arquitectura , muchas instancias, sugiere que diseño todas las clases debe ser relativamente informal. los críticos argumentan que cuando construyen sistemas complejos, debe ponerse énfasis diseño con objeto garantizar que estructura general del software tendrá calidad que será susceptible recibir mantenimiento. los defensores para estudio más detallado ciertas críticas profundas hechas , visite meprogramming.jsp.¿cuáles son algunos los aspectos que llevan debate ?? (-).indd (-).indd // ::// :: desarrollo ágil sugieren que naturaleza incremental del proceso limita complejidad ( sencillez valor fundamental), que reduce necesidad diseño extenso. lector debe observar que todo proceso del software tiene sus desventajas, que muchas -ganizaciones software han utilizado con éxito . clave identificar dónde tiene sus debilidades proceso adaptarlo las necesidades organización. . otros modelos ágiles proceso historia ingeniería software está salpicada decenas descripciones metodolo-gías proceso, métodos modelado notaciones, herramientas tecnología, todos ellos obsoletos. cada uno tuvo notoriedad luego fue eclipsado por algo nuevo (supuestamente) mejor. con introducción una amplia variedad modelos ágiles del proceso —cada uno lucha por aceptación comunidad desarrollo software— movimiento ágil está siguiendo misma ruta histórica. consideración del desarrollo ágil software escena: oficina doug miller. participantes: doug miller, gerente ingeniería software; jamie lazar, miembro del equipo software; vinod raman, inte-grante del equipo software. conversación:(tocan puerta; jamie vinod entran oficina doug.)jamie: doug, ¿tienes minuto?doug: seguro, jamie, ¿qué pasa?jamie: hemos estado pensando nuestra conversación ayer sobre proceso… sabes, que vamos elegir para este nuevo proyecto casasegura. doug: ¿?vinod: hablé con amigo otra compañía, contó sobre programación extrema. modelo proceso ágil… ¿has oído ? doug: , algunas cosas buenas otras malas.jamie: bueno, nosotros nos pareció bien. permite desarrollo software realmente rápido, usa algo llamado programación pare-jas para revisar calidad tiempo real… pienso que muy bueno. doug: tiene muchas ideas realmente buenas. por ejemplo, gusta concepto programación parejas idea que los participantes deben formar parte del equipo. jamie: ¿qué? ¿quieren decir que mercadotecnia trabajará con nosotros proyecto?doug (afirmando con cabeza): ellos son uno los partici-pantes, ¿ ? jamie: … pedirán cambios cada cinco minutos.vinod: necesariamente. amigo dijo que hay formas “adoptar” los cambios durante proyecto . doug: entonces, chicos, ¿piensan que debemos usar ?jamie: definitivamente, sería bueno considerarlo.doug: estoy acuerdo. incluso elegimos modelo incremen- tal como nuestro enfoque, hay razón para incorporar mucho que tiene que ofrecer. vinod: doug, dijiste hace rato “cosas buenas malas”. ¿cuáles son las malas? doug: que gusta forma que desprecia análisis diseño… algo así como decir que escritura del código está donde hay acción… (los miembros del equipo miran entre sonríen.)doug: entonces, ¿están acuerdo con enfoque ?jamie (habla por ambos): ¡escribir código que hacemos, jefe! doug (ríe): cierto, pero gustaría ver que dediquen poco menos tiempo escribir código luego repetirlo, que pasen algo más tiempo análisis que debe hacerse para dise-ñar una solución que funcione. vinod: tal vez tengamos las dos cosas, agilidad con poco disciplina. doug: creo que podemos, vinod. realidad, estoy seguro que puede.casaseguracita: “nuestra profesión pasa por las metodologías como chico años pasa por ropa.” stephen hawrysh jim ruprecht esto algo malo. antes que uno varios modelos acepten como estándar facto, todos deben - char por conquistar las mentes corazones los ingenieros software. los “ganadores” evolucionan hacia las mejores prácticas, mientras que los “perdedores” desaparecen funden con los modelos ganadores. (-).indd (-).indd // ::// :: parte uno proceso del software como dijo sección anterior, más usado todos los modelos ágiles proceso programación extrema (). pero han propuesto muchos otros están uso toda industria. entre ellos encuentran los siguientes: • desarrollo adaptativo software (das) • scrum • método desarrollo sistemas dinámicos (mdsd) • cristal • desarrollo impulsado por las características (dic) • desarrollo esbelto software (des) • modelado ágil () • proceso unificado ágil (pua) las secciones que siguen presenta panorama muy breve cada uno estos modelos ágiles del proceso. importante notar que todos los modelos proceso ágil apegan ( mayor menor grado) manifiesto para desarrollo ágil software los principios descritos sección ... para mayores detalles, consulte las referencias mencionadas cada sub-sección ingrese entrada “desarrollo software ágil” wikipedia. .. desarrollo adaptativo software (das) desarrollo adaptativo software (das) fue propuesto por jim highsmith [hig] como una técnica para elaborar software sistemas complejos. los fundamentos filosóficos del das centran colaboración humana organización propia del equipo. highsmith argumenta que enfoque desarrollo adaptativo basado colaboración “tanto una fuente orden nuestras complejas interacciones, como disciplina ingenie- ría”. define “ciclo vida” del das (véase figura .) que incorpora tres fases: especu-lación, colaboración aprendizaje. consulte http://.wikipedia.org/wiki/agile_software_development#agile_methods.planeación adaptativa del ciclo enunciado misión restricciones del proyecto requerimientos básicosplan entrega tiempo componentes implementados probados grupos enfoque para recibir retroalimentación revisiones técnicas formalesanálisis post mórtemrecabar requerimientos jad miniespeciﬁcaciones incremento software ajustes para los ciclos posterioresentregacolaboración especulación aprendizajefigura . desarrollo adaptativo softwarewebref dirección hay referencias útiles sobre das. (-).indd (-).indd // ::// :: desarrollo ágil durante especulación, inicia proyecto lleva cabo planeación adaptativa del ciclo. especulación emplea información inicio del proyecto —enunciado misión los clientes, restricciones del proyecto (por ejemplo, fechas entrega descripciones usua-rio) requerimientos básicos— para definir conjunto ciclos entrega (incrementos software) que requerirán para proyecto. importa completo previsor que sea plan del ciclo, será inevitable que cambie. con base información obtenida terminar primer ciclo, plan revisa ajusta, modo que trabajo planeado acomode mejor realidad que trabaja equipo das. las personas motivadas usan colaboración manera que multiplica talento produc- ción creativa más allá sus números absolutos. este enfoque tema recurrente todos los métodos ágiles. sin embargo, colaboración fácil. incluye comunicación trabajo equipo, pero también resalta individualismo porque creatividad individual desempeña papel importante pensamiento colaborativo. cuestión, sobre todo, confianza. las personas que trabajan juntas deben confiar una otra fin : ) criticarse sin enojo, ) ayu-darse sin resentimiento, ) trabajar tan duro, más, que como costumbre, ) tener con-junto aptitudes para contribuir trabajo, ) comunicar los problemas preocupaciones manera que conduzcan acción efectiva. conforme los miembros equipo das comienzan desarrollar los componentes que forman parte ciclo adaptativo, énfasis traslada “aprendizaje” todo que hay avance hacia terminación del ciclo. realidad, highsmith [hig] afirma que los desa-rrolladores software sobreestiman con frecuencia propia comprensión ( tecnología, del proceso del proyecto) que aprendizaje los ayudará mejorar nivel entendimiento real. los equipos das aprenden tres maneras: grupos enfoque (véase capítulo ), revi-siones técnicas (véase capítulo ) análisis post mórtem del proyecto. filosofía das tiene mérito, sin importar modelo proceso que use. énfasis general que hace das dinámica los equipos con organización propia, colaboración interpersonal aprendizaje individual del equipo generan equipos para proyectos soft-ware que tienen una probabilidad éxito mucho mayor. .. scrum scrum (nombre que proviene cierta jugada que tiene lugar durante partido rugby) método desarrollo ágil software concebido por jeff sutherland equipo desarro-llo principios década . años recientes, schwaber beedle [sch] han desa-rrollado más los métodos scrum. los principios scrum son congruentes con manifiesto ágil utilizan para guiar activida- des desarrollo dentro proceso análisis que incorpora las siguientes actividades -tructurales: requerimientos, análisis, diseño, evolución entrega. dentro cada actividad estructural, las tareas del trabajo ocurren con patrón del proceso (que estudia párrafo siguiente) llamado sprint. trabajo realizado dentro sprint ( número éstos que -quiere cada actividad estructural variará función complejidad tamaño del producto) adapta problema cuestión define — con frecuencia modifica— tiempo real por parte del equipo scrum. flujo general del proceso scrum ilustra figura .. scrum acentúa uso conjunto patrones proceso del software [noy] que han demostrado ser eficaces para proyectos con plazos entrega muy apretados, requerimientos cambiantes negocios críticos. cada uno estos patrones proceso define grupo -ciones desarrollo: colaboración eficaz con cliente sólo ocurrirá evita cualquier actitud del tipo “nosotros ellos”.consejo forma grupo jugadores alrededor del balón todos trabajan juntos ( veces con violencia) para moverlo través del campo.punto clave das pone énfasis aprendizaje como elemento clave para lograr equipo con “organización propia”. webref dirección com hay información útil sobre scrum. punto clave scrum incorpora conjunto patrones del proceso que ponen énfasis las prioridades del proyecto, las unidades trabajo agrupadas, comunicación retroalimentación frecuente con cliente. (-).indd (-).indd // ::// :: parte uno proceso del software retraso: lista prioridades los requerimientos características del proyecto que dan cliente valor del negocio. posible agregar cualquier momento otros aspectos - traso (ésta forma que introducen los cambios). gerente del proyecto evalúa retraso actualiza las prioridades según requiera. sprints: consiste unidades trabajo que necesitan para alcanzar requerimiento definido retraso que debe ajustarse una caja tiempo predefinida ( común son días). durante sprint introducen cambios (por ejemplo, aspectos del trabajo retra-sado). así, sprint permite los miembros del equipo trabajar ambiente corto plazo pero estable. reuniones scrum: son reuniones breves ( minutos, por general) que equipo scrum efectúa diario. hay tres preguntas clave que pide que respondan todos los miem-bros del equipo [noy]: • ¿qué hiciste desde última reunión del equipo? • ¿qué obstáculos estás encontrando? • ¿qué planeas hacer mientras llega siguiente reunión del equipo? líder del equipo, llamado maestro scrum, dirige junta evalúa las respuestas cada per- sona. junta scrum ayuda equipo descubrir los problemas potenciales tan pronto como sea posible. asimismo, estas juntas diarias llevan “socialización del conocimiento” [bee], con que promueve una estructura equipo con organización propia. demostraciones preliminares: entregar incremento software cliente modo que funcionalidad que haya implementado pueda demostrarse cliente éste pueda evaluarla. cada horas díasscrum: reunión diaria minutos. los miembros del equipo respondena preguntas básicas:) ¿qué hiciste desde última reunión scrum?) ¿tienes algún obstáculo?) ¿qué harás antes próxima reunión? retraso del sprint: característica()asignadas parael sprint retraso del producto características del producto que desea cliente con prioridadaspectos con retraso ampliados por equipo ﬁnal del sprint demuestra nueva funcionalidadfigura . flujo del proceso scrum una caja tiempo término administración proyectos (véase parte este libro) que indica tiempo que asignado para cumplir alguna tarea. (-).indd (-).indd // ::// :: desarrollo ágil importante notar que las demostraciones preliminares contienen toda funcionalidad planeada, sino que éstas entregarán dentro caja tiempo establecida. beedle sus colegas [bee] presentan análisis exhaustivo estos patrones que dicen: “scrum supone entrada existencia caos…” los patrones proceso scrum permiten que equipo software trabaje con éxito mundo que imposible eliminar incer-tidumbre. .. método desarrollo sistemas dinámicos (mdsd) método desarrollo sistemas dinámicos (mdsd) [sta] enfoque desarrollo ágil software que “proporciona una estructura para construir dar mantenimiento sistemas que cumplan restricciones apretadas tiempo mediante realización prototipos incrementales ambiente controlado proyectos” [ccs]. filosofía mdsd está tomada una ver-sión modificada regla pareto: por ciento una aplicación puede entregarse por ciento del tiempo que tomaría entregarla completa ( por ciento). mdsd proceso iterativo software que cada iteración sigue regla por ciento. decir, requiere sólo suficiente trabajo para cada incremento con objeto facilitar paso siguiente. los detalles restantes terminan más tarde, cuando conocen los reque-rimientos del negocio han pedido efectuado cambios. grupo dsdm consortium ( conglomerado mundial compañías que adoptan colectivamente papel “custodios” del método. consorcio definido modelo proceso ágil, llamado ciclo vida mdsd , que define tres ciclos iterativos distintos, precedidos dos actividades adicionales ciclo vida: estudio factibilidad: establece los requerimientos restricciones básicas del negocio, aso- ciados con aplicación que construir, para luego evaluar aplicación candi-dato viable para aplicarle proceso mdsd. estudio del negocio: establece los requerimientos información funcionales que permitirán aplicación para dar valor negocio; asimismo, define arquitectura básica aplica-ción identifica los requerimientos para darle mantenimiento. iteración del modelo funcional: produce conjunto prototipos incrementales que - muestran cliente funcionalidad. (nota: todos los prototipos mdsd están pensados para que evolucionen hacia aplicación que entrega.) objetivo este ciclo iterativo reca-bar requerimientos adicionales por medio obtención retroalimentación los usua-rios cuando practican con prototipo. diseño iteración construcción: revisita los prototipos construidos durante iteración del modelo funcional fin garantizar que cada iteración hecho ingeniería forma que permita dar valor operativo del negocio los usuarios finales; iteración del modelo fun- cional diseño iteración construcción ocurren manera concurrente. implementación: coloca incremento más reciente del software ( prototipo “operacio- nal”) ambiente operación. debe notarse que: ) incremento tal vez sea % final, ) quizá pidan cambios cuando incremento ponga lugar. cual-quier caso, trabajo desarrollo mdsd continúa vuelve actividad iteración del -delo funcional. mdsd combina con (véase sección .) para dar enfoque combinación que define modelo sólido del proceso (ciclo vida mdsd) con las prácticas detalladas () que requieren para elaborar incrementos software. además, los conceptos das adap-tan modelo combinado del proceso.punto clave mdsd una estructura proceso que adopta las tácticas otro enfoque ágil, como .webref dirección hay recursos útiles para mdsd. (-).indd (-).indd // ::// :: parte uno proceso del software .. cristal alistar cockburn [coc] creó familia cristal métodos ágiles fin obtener enfoque desarrollo software que premia “maniobrabilidad” durante que cockburn caracteriza como “ juego cooperativo con recursos limitados, invención comunicación, con obje- tivo primario entregar software útil que funcione con meta secundaria plantear - guiente juego” [coc]. para lograr maniobrabilidad, cockburn highsmith definieron conjunto metodolo- gías, cada una con elementos fundamentales comunes todos, roles, patrones proceso, producto del trabajo prácticas que son únicas para cada uno. familia cristal realidad conjunto ejemplos procesos ágiles que han demostrado ser efectivos para diferentes tipos proyectos. objetivo permitir que equipos ágiles seleccionen miembro -milia cristal más apropiado para proyecto ambiente. .. desarrollo impulsado por las características (dic) desarrollo impulsado por las características (dic) concibió originalmente peter coad sus colegas [coa] como modelo práctico proceso para ingeniería software orientada objetos. stephen palmer john felsing [pal] ampliaron mejoraron trabajo coad con descripción proceso adaptativo ágil aplicable proyectos software tamaño mode-rado grande. igual que otros proyectos ágiles, dic adopta una filosofía que: ) pone énfasis colabo- ración entre los integrantes equipo dic; ) administra complejidad los problemas del proyecto con uso descomposición basada las características, seguida inte-gración incrementos software, ) comunica los detalles técnicos forma verbal, gráfica con medios basados texto. dic pone énfasis las actividades aseguramiento calidad del software mediante estímulo estrategia desarrollo incremental, uso inspecciones del diseño del código, aplicación auditorías aseguramiento -lidad del software (véase capítulo ), conjunto mediciones uso patrones (para análisis, diseño construcción). contexto del dic, una característica “ una función valiosa para cliente que puede implementarse dos semanas menos” [coa]. énfasis definición características proporciona los beneficios siguientes: • debido que las características son bloques pequeños funcionalidad que entrega, los usuarios las describen con más facilidad, entienden cómo relacionan entre las revisan mejor busca ambigüedades, errores omisiones. • las características organizan por jerarquía grupos relacionados con negocio. • como una característica incremento software dic que entrega, equipo desarrolla características operativas cada dos semanas. • diseño representación código las características son más fáciles inspec- cionar con eficacia porque éstas son pequeñas. • planeación, programación actividades seguimiento son determinadas por jerarquía características, por conjunto tareas ingeniería software adoptadas forma arbitraria. coad sus colegas [coa] sugieren esquema siguiente para definir una característica: <acción <resultado <|por||para <objeto nombre “cristal” deriva los cristales minerales, cada uno los cuales tiene propiedades específicas color, forma dureza.punto clave cristal una familia modelos proceso con mismo “código genético” pero diferentes métodos para adaptarse las características del proyecto. webref dirección www. featuredrivendevelopment.com/ encuentra una amplia variedad artículos presentaciones sobre dic. (-).indd (-).indd // ::// :: desarrollo ágil donde <objeto “una persona, lugar cosa (incluso roles, momentos del tiempo intervalos temporales, descripciones parecidas las entradas catálogo)”. algunos ejemplos características para una aplicación comercio electrónico son los siguientes: agregar producto carrito compras mostrar las especificaciones técnicas del productoguardar información envío para cliente conjunto características agrupa las que son similares categorías relacionadas con negocio define así: <acción<ndo <objeto por ejemplo: haciendo una venta del producto conjunto características que agruparía las que mencionaron otras más. enfoque dic define cinco actividades estructurales “colaborativas” [coa] ( enfoque dic llaman “procesos”), como muestra figura .. dic pone más énfasis que otros métodos ágiles los lineamientos técnicas para - ministración proyectos. medida que éstos aumentan tamaño complejidad, raro que administración proyectos hoc sea inadecuada. para los desarrolladores, sus geren- tes otros participantes, esencial entender estado del proyecto, decir, los avances rea-lizados los problemas que han surgido. presión por cumplir plazo entrega mucha, tiene importancia crítica determinar entrega los incrementos del software está progra-mada forma adecuada. para lograr esto, dic define seis puntos referencia durante diseño implementación una característica: “recorrido por diseño, diseño, inspección del diseño, código, inspección del código, decisión construir” [coa]. .. desarrollo esbelto software (des) desarrollo esbelto software (des) adapta los principios manufactura esbelta mundo ingeniería software. los principios esbeltez que inspiran proceso des resumen como sigue ([pop], [pop]): eliminar desperdicio, generar calidad, crear conocimiento, apla-zar compromiso, entregar rápido, respetar las personas optimizar todo. posible adaptar cada uno estos principios proceso del software. por ejemplo, eliminar desperdicio contexto proyecto software ágil significa [das]: ) agregar características funciones extrañas, ) evaluar costo efecto que tendrá programa-ción actividades cualquier nuevo requerimiento solicitado, ) eliminar cualesquiera etapas superfluas del proceso, ) establecer mecanismos para mejorar forma que los miembros desarrollar modelo generalelaborar una lista carac- terísticasplan según carac- terísticasdiseño según carac- terísticasconstruir según carac- terísticas (más forma que contenido)lista caracte-rísticas agrupadasen conjuntosy áreas temáticasplan desarrollopropietarios clasepropietariosde conjuntos decaracterísticaspaquetede diseño(secuencias)función terminadacon valor parael clientefigura . desarrollo impulsado por las características [coa] (con permiso) (-).indd (-).indd // ::// :: parte uno proceso del software del equipo obtienen información, ) asegurar que las pruebas detecten tantos errores como sea posible, ) reducir tiempo requerido para pedir obtener una decisión que afecta software proceso que aplica para crearlo, ) simplificar manera que transmite -formación todos los participantes involucrados proceso. para análisis detallado del des para conocer lineamientos prácticos fin implemen- tar proceso, debe consultarse [pop] [pop]. .. modelado ágil () hay muchas situaciones las que los ingenieros software deben construir sistemas grandes importancia crítica para negocio. alcance complejidad tales sistemas debe mode-larse modo que: ) todos los actores entiendan mejor cuáles son las necesidades que deben satisfacerse, ) problema pueda dividirse con eficacia entre las personas que deben resolverlo, ) asegure calidad medida que hace ingeniería construye sistema. los últimos años propuesto una gran variedad métodos modelado nota- ción para ingeniería software con objeto hacer análisis diseño (tanto arqui-tectura como los componentes). estos métodos tienen mérito, pero demostrado que son difíciles aplicar sostener ( muchos proyectos). parte del problema “peso” dichos métodos modelación. con esto hace referencia volumen notación que requiere, grado formalismo sugerido, tamaño absoluto los modelos para proyectos grandes dificultad mantener (los) modelo() conforme suceden los cambios. sin -bargo, análisis modelado del diseño tienen muchos beneficios para los proyectos grandes, aunque fuera más que porque hacen esos proyectos intelectualmente más manejables. ¿hay algún enfoque ágil para modelado ingeniería software que brinde una alterna-tiva? “sitio oficial modelado ágil”, scott ambler [amb] describe modelado ágil () del modo siguiente: modelado ágil () una metodología basada práctica para modelar documentar con eficacia los sistemas basados software. pocas palabras, conjunto valores, principios prácticas para hacer modelos software aplicables manera eficaz ligera proyecto desa-rrollo software. los modelos ágiles son más eficaces que los tradicionales porque son sólo buenos, sin pretender ser perfectos. modelado ágil adopta todos los valores del manifiesto ágil. filosofía modelado ágil afirma que equipo ágil debe tener valentía para tomar decisiones que impliquen rechazar diseño reconstruirlo. equipo también debe tener humildad reconocer que los tec-nólogos tienen todas las respuestas que los expertos negocio otros participantes deben ser respetados incluidos. aunque sugiere una amplia variedad principios modelado “fundamentales” “suplementarios”, aquellos que son exclusivos del son los siguientes [amb]: modelo con propósito. desarrollador que use debe tener mente una meta específica (por ejemplo, comunicar información cliente ayudarlo entender -jor algún aspecto del software) antes crear modelo. una vez identificada meta para modelo, tipo nivel detalle notación por usar serán más obvios. uso modelos múltiples. hay muchos modelos notaciones diferentes que pueden usarse para describir software. para mayoría proyectos sólo esencial pequeño subconjunto. sugiere que para dar perspectiva necesaria, cada modelo debe pre-sentar diferente aspecto del sistema que sólo deben utilizarse aquellos modelos que den valor público que dirigen.cita: “ otro día fui farmacia por una medicina para resfria-… fue fácil. había toda una pared cubierta produc-tos. recorrerla uno que era acción rápida, pero otro que era larga duración… ¿qué más importante, presente futuro?” jerry seinfeldwebref dirección www. agilemodeling.com hay información amplia sobre modelado ágil. (-).indd (-).indd // ::// :: desarrollo ágil viajar ligero. conforme avanza trabajo ingeniería software, conserve sólo aque- llos modelos que agreguen valor largo plazo elimine los demás. todo producto del tra- bajo que conserve debe recibir mantenimiento cuando haya cambios. esto representa una labor que hace lento equipo. ambler [amb] afirma que “cada vez que decide conservar modelo, pierde agilidad nombre conveniencia tener disponible esa información forma abstracta para equipo ( ese modo mejorar potencialmente comunicación dentro del equipo, así como con los participantes)”. contenido más importante que representación. modelado debe transmitir información público que dirige. modelo con sintaxis perfecta que transmita poco contenido útil tan valioso como otro que tenga notación defectuosa, pero que, obstante, provea contenido valor para los usuarios. conocer los modelos herramientas que utilizan creación. entender las fortalezas debilidades cada modelo las herramientas que emplean para crearlos.adaptación local. enfoque modelado debe adaptarse las necesidades del equipo ágil. segmento importante comunidad ingeniería software adoptado lenguaje unificado modelado (uml, por sus siglas inglés) como método preferido para repre- sentar modelos del análisis del diseño. proceso unificado (véase capítulo ) fue desarro-llado para proveer una estructura para aplicación del uml. scott ambler [amb] desarrolló una versión simplificada del que integra filosofía modelado ágil. .. proceso unificado ágil (pua) proceso unificado ágil (pua) adopta una filosofía “ serie para grande” “iterativa para pequeño” [amb] fin construir sistemas basados computadora. adoptar las activida-des fase clásicas del —concepción, elaboración, construcción transición—, pua brinda revestimiento serie (por ejemplo, una secuencia lineal actividades ingeniería software) que permite que equipo visualice flujo general del proceso proyecto soft-ware. sin embargo, dentro cada actividad, equipo repite con objeto alcanzar agilidad entregar tan rápido como sea posible incrementos software significativos los usuarios finales. cada iteración del pua aborda las actividades siguientes [amb]: • modelado. crean representaciones uml los dominios del negocio problema. obstante, para conservar agilidad, estos modelos deben ser “sólo suficientemente buenos” [amb] para permitir que equipo avance. • implementación. los modelos traducen código fuente. • pruebas. igual que con , equipo diseña ejecuta una serie pruebas para detectar errores garantizar que código fuente cumple sus requerimientos. • despliegue. como actividad general del proceso que estudió los capítulos , despliegue este contexto centra entrega incremento software obtención retroalimentación los usuarios finales. • configuración administración del proyecto. contexto del pua, administración configuración (véase capítulo ) incluye administración del cambio riesgo, control cualesquiera productos del trabajo persistentes que produzca equipo. “viajar ligero” una filosofía apropiada para todo trabajo ingeniería software. construir sólo aquellos modelos que agreguen valor… más menos.consejo apéndice presenta método breve para aprender uml. producto del trabajo persistente modelo documento caso prueba producido por equipo que conservará durante periodo indeterminado. eliminará una vez entregado incremento software. (-).indd (-).indd // ::// :: parte uno proceso del software administración del proyecto seguimiento controla avance del equipo coordina sus actividades. • administración del ambiente. administración del ambiente coordina una infraestruc-tura del proceso que incluye estándares, herramientas otra tecnología apoyo que dispone equipo. aunque pua tiene conexiones históricas técnicas con lenguaje unificado modelado, importante observar que modelado uml puede usarse junto con cualesquiera los modelos proceso ágil descritos sección .. las herramientas mencionadas aquí son obligatorias, sólo son una muestra esta categoría. mayoría casos, sus nombres son marcas registradas por sus respectivos desarrolladores.desarrollo ágil objetivo: objetivo las herramientas desarrollo ágil ayudar uno más aspectos éste, con énfasis facilitar elaboración rápida software funcional. estas herra-mientas también pueden emplearse cuando aplican modelos proceso prescriptivo (véase capítulo ). mecánica: las herramientas mecánica varían. general, las herramientas ágiles incluyen apoyo automatizado para planea-ción del proyecto, desarrollo casos obtención requeri-mientos, diseño rápido, generación código realización pruebas. herramientas representativas: nota: debido que desarrollo ágil tema moda, mayo- ría los vendedores herramientas software tratan colo-car herramientas que apoyan. las que mencionan conti- nuación tienen características que las hacen particularmente útiles para los proyectos ágiles. ontime, desarrollada por axosoft ( presta apoyo administración proceso ágil para distintas activi-dades técnicas dentro del proceso. ideogramic uml, desarrollada por ideogramic ( com), conjunto herramientas uml desarrolladas especí-ficamente para usarlas dentro proceso ágil. together tool set, distribuido por borland ( proporciona grupo herramientas para apoyar muchas acti-vidades técnicas dentro otros procesos ágiles.herramientas software . conjunto herramientas para proceso ágil algunos defensores filosofía ágil afirman que las herramientas automatizadas software (por ejemplo, las diseño) deben verse como complemento menor las actividades del equipo, como algo fundamental para éxito. sin embargo, alistair cockburn [coc] -giere que las herramientas tienen beneficio que “los equipos ágiles favorecen uso herramientas que permiten flujo rápido entendimiento. algunas estas herramientas son sociales comienzan incluso etapa reclutamiento. otras son tecnológicas ayudan que los equipos distribuidos simulen presencia física. muchas herramientas son físicas permiten que las personas las manipulen talleres”. prácticamente todos los modelos proceso ágil son elementos clave contratación del personal adecuado (reclutamiento), colaboración equipo, comunicación con los partici-pantes administración indirecta; por eso, cockburn afirma que las “herramientas” que abocan dichos aspectos son factores críticos para éxito agilidad. por ejemplo, una “herramienta” reclutamiento tal vez sea requerimiento que prospecto miembro del equipo pase algunas horas programando pareja con alguien que integrante del equipo. “ajuste” evalúa inmediato. las “herramientas” colaboración comunicación por general son baja tecnología incorporan cualquier mecanismo (“proximidad física, pizarrones, tableros, tarjetas notas -punto clave “conjunto herramientas” que apoyo los procesos ágiles centra más aspectos persona que los tecnología. (-).indd (-).indd // ::// :: desarrollo ágil heribles” [coc] que provea información coordinación entre los desarrolladores ágiles. comunicación activa logra por medio dinámica del equipo (por ejemplo, programa-ción parejas), mientras que comunicación pasiva consigue con “radiadores infor-mación” ( tablero que muestre estado general los distintos componentes incre-mento). las herramientas administración proyectos ponen énfasis gráfica gantt sustituyen con otras valor agregado “gráficas pruebas creadas versus pasadas; otras herramientas ágiles utilizan para optimizar ambiente que trabaja equipo ágil (por ejemplo, áreas más eficientes para reunirse), mejoran cultura del equipo por medio cultivar las interacciones sociales (equipos con algo común), dispositivos físicos (pizarrones electrónicos) mejoramiento del proceso (por ejemplo, programación por parejas caja tiempo)” [coc]. ¿algunas las mencionadas son verdad herramientas? , son, facilitan trabajo efectuado por miembro del equipo ágil mejoran calidad del producto final. . resumen una economía moderna, las condiciones del mercado cambian con rapidez, los clientes usuarios finales necesitan evolucionar surgen nuevas amenazas competitivas sin aviso previo. los profesionales deben enfocar ingeniería software forma que les permita mantenerse ágiles para definir procesos maniobrables, adaptativos esbeltos que satisfagan las necesidades los negocios modernos. una filosofía ágil para ingeniería software pone énfasis cuatro aspectos clave: importancia los equipos con organización propia que tienen control sobre trabajo que realizan, comunicación colaboración entre los miembros del equipo entre los profesiona-les sus clientes, reconocimiento que cambio representa una oportunidad insisten-cia entrega rápida software que satisfaga consumidor. los modelos proceso ágil han sido diseñados para abordar cada uno estos aspectos. programación extrema () proceso ágil más uso. organizada con cuatro activi- dades estructurales: planeación, diseño, codificación pruebas, sugiere cierto número técnicas innovadoras poderosas que permiten equipo ágil generar entregas frecuentes software que posee características funcionalidad que han sido descritas clasificadas -gún prioridad por los participantes. otros modelos proceso ágil también insisten colaboración humana organiza- ción propia del equipo, pero definen sus actividades estructurales seleccionan diferentes pun-tos importancia. por ejemplo, das utiliza proceso iterativo que incluye ciclo planeación adaptativa, métodos relativamente rigurosos para recabar requerimientos, ciclo desarrollo iterativo que incorpora grupos consumidores revisiones técnicas formales como mecanismos retroalimentación tiempo real. scrum pone énfasis uso conjunto patrones software que han demostrado ser eficaces para proyectos que tienen plazos entrega apretados, requerimientos cambiantes que emplean negocios críticos. cada patrón proceso define conjunto tareas desarrollo permite equipo scrum construir proceso que adapte las necesidades del proyecto. método desarrollo sistemas dinámicos (mdsd) resalta uso programación con caja tiempo sugiere que cada incremento software sólo requiere trabajo suficiente que facilite paso -cremento que sigue. cristal una familia modelos proceso ágil que adaptan las -racterísticas específicas del proyecto. desarrollo impulsado por las características (dic) algo más “formal” que otros métodos ágiles, pero conserva agilidad centrar equipo del proyecto desarrollo caracterís-ticas, funciones valiosas para cliente que pueden implementarse dos semanas menos. (-).indd (-).indd // ::// :: parte uno proceso del software desarrollo esbelto software (des) adaptado los principios manufactura esbelta mundo ingeniería software. modelado ágil () sugiere que modelado esencial para todos los sistemas, pero que complejidad, tipo tamaño del modelo deben ajustarse software que elaborar. proceso unificado ágil (pua) adopta una filosofía “serial grande” “iterativo pequeño” para elaboración software. problemas puntos por evaluar .. vuelva leer “manifiesto para desarrollo ágil software” principio este capítulo. ¿puede pensar una situación que uno más los cuatro “valores” pudieran causar problemas equipo software? .. describa con sus propias palabras agilidad (para proyectos software). .. ¿por qué proceso iterativo hace más fácil administrar cambio? ¿ iterativo todo proceso ágil analizado este capítulo? ¿ posible terminar proyecto sólo una iteración aún así conseguir que sea ágil? explique sus respuestas. .. ¿podría describirse cada uno los procesos ágiles con uso las actividades estructurales genera- les mencionadas capítulo ? construya una tabla que mapee las actividades generales las activida- des definidas para cada proceso ágil. .. proponga “principio agilidad” más que ayudaría equipo ingeniería software ser aún más maniobrable... seleccione principio agilidad mencionado sección .. trate determinar está incluido cada uno los modelos proceso presentados este capítulo. [nota: sólo presentó panorama general estos modelos proceso, por que tal vez fuera posible determinar principio está -cluido uno más ellos, menos que lector hiciera una investigación ( que requiere para este problema)]. .. ¿por qué cambian tanto los requerimientos? después todo, ¿ gente sabe que quiere? .. mayoría modelos proceso ágil recomiendan comunicación cara cara. obstante, los miembros del equipo software sus clientes tal vez estén alejados geográficamente. ¿piensa usted que esto implica que debe evitarse separación geográfica? ¿ ocurren formas resolver este problema? .. escriba una historia usuario que describa característica “lugares favoritos” “marcadores” disponible mayoría navegadores web... ¿qué una solución punta ? .. describa con sus propias palabras los conceptos rediseño programación parejas . .. haga otras lecturas describa que una caja tiempo. ¿cómo ayuda equipo das para que entregue incrementos software corto periodo?.. ¿ logra mismo resultado con regla % del mdsd con enfoque caja tiempo del das?.. con formato patrón proceso presentado capítulo , desarrolle uno para cualquiera los patrones scrum presentados sección ..... ¿por qué llama cristal familia métodos ágiles? .. con formato característica dic descrito sección .., defina conjunto características para navegador web. luego desarrolle conjunto características para primer conjunto... visite sitio oficial modelación ágil elabore lista completa todos los principios fundamen- tales secundarios del ... conjunto herramientas propuestas sección . apoyo muchos los aspectos “suaves” los métodos ágiles. debido que comunicación tan importante, recomiende conjunto herra- mientas reales que podría utilizarse para que los participantes equipo ágil comuniquen mejor. (-).indd (-).indd // ::// :: desarrollo ágil lecturas adicionales fuentes información filosofía general principios que subyacen desarrollo software ágil estudian profundidad muchos los libros mencionados largo este capítulo. además, los textos shaw warden (the art agile development, ’reilly media, inc., ), hunt (agile software construction, springer, ) carmi-chael haywood (better software faster, prentice-hall, ) presentan análisis útiles del tema. aguanno (managing agile projects, multi-media publications, ), highsmith ( agile project management: creating - novative products, addison-wesley, ) larman ( agile and iterative development: manager’ guide , addi- son-wesley, ) presentan punto vista administración consideran ciertos aspectos -ministración proyectos. highsmith ( agile software development ecosystems, addison-wesley, ) expone una encuesta acerca los principios, procesos prácticas ágiles. booch sus colegas ( balancing agility and discipline, addison-wesley, ) hacen análisis fructífero del delicado equilibrio entre agilidad disci-plina. martin (clean code: handbook agile software craftsmanship , prentice-hall, ) explica los principios, patrones prácticas que requieren para desarrollar “código limpio” ambiente ingeniería soft-ware ágil. leffingwell (scaling software agility: best practices for large enterprises , addison-wesley, ) estudia estrategias para ampliar las prácticas ágiles proyectos grandes. lippert rook ( refactoring large software projects: performing complex restructurings succesfully , wiley, ) analizan uso del rediseño cuando aplica sistemas grandes complejos. stamelos sfetsos ( agile software development quality assurance, igi global, ) analizan las técnicas sqa que forman filosofía ágil. última década han escrito decenas libros sobre programación extrema. beck (extreme program- ming explained: embrace change, . ., addison-wesley, ) sigue siendo referencia definitiva res-pecto. además, jeffries sus colegas ( extreme programming installed , addison-wesley, ), succi mar- chesi (extreme programming examined, addison-wesley, ), newkirk martin (extreme programming practice, addison-wesley, ) auer sus colegas ( extreme programming applied: play win , addison- wesley, ) hacen análisis detallado dan una guía para aplicarla mejor forma. mcbreen (questioning extreme programming, addison-wesley, ) adopta enfoque crítico sobre , define cuándo dónde apropiada. estudio profundo programación por parejas presenta mcbreen (pair programming illuminated, addison-wesley, ). highsmith [hig] analiza con detalle das. schwaber ( the enterprise and scrum, microsoft press, ) estudia empleo scrum para proyectos que tienen efecto grande los negocios. los detalles scrum los estudian schwaber beedle ( agile software development with scrum , prentice-hall, ). algu- nos tratamientos útiles del mdsd han sido escritos por dsdm consortium (dsdm: business focused develop-ment, . ., pearson education, ) stapleton ( dsdm: the method practice, addison-wesley, ). cockburn (crystal clear, addison-wesley, ) presenta panorama excelente familia procesos cristal. palmer felsing [pal] dan tratamiento detallado del dic. carmichael haywood (better software faster, prentice-hall, ) proporcionan otro análisis útil del dic, que incluye recorrido, paso paso, por mecánica del proceso. poppendieck poppendieck ( lean development: agile toolkit for software deve- lopment managers, addison-wesley, ) dan lineamientos para administración control proyectos ágiles. ambler jeffries (agile modeling, wiley, ) estudian con cierta profundidad. internet existe una amplia variedad fuentes información sobre desarrollo software ágil. sitio web del libro hay una lista actualizada referencias red mundial que son relevantes para proceso ágil, dirección: (-).indd (-).indd // ::// ::(-).indd (-).indd // ::// :: dos esta parte obra, aprenderá sobre los principios, conceptos métodos que usan para crear requerimientos alta calidad para diseñar modelos. los capítulos que siguen abordan pre- guntas como las siguientes: • ¿qué conceptos principios guían práctica ingeniería soft-ware? • ¿qué son los requerimientos ingeniería cuáles son los conceptos subyacentes que llevan buen análisis requerimientos? • ¿cómo crean los requerimientos del modelo cuáles son sus ele-mentos? • ¿cuáles son los elementos buen diseño? • ¿cómo establece diseño arquitectura una estructura para todas las demás acciones diseño qué modelos utilizan? • ¿cómo diseñan componentes software alta calidad? • ¿qué conceptos, modelos métodos aplican diseñar una inter-faz usuario? • ¿qué diseño basado patrones? • ¿qué estrategias métodos especializados emplean para diseñar webapps? una vez que respondan estas preguntas, lector estará mejor pre- parado para aplicar práctica ingeniería software. (-).indd (-).indd // ::// :: que guían práctica conceptos clave principios fundamentales . . . . principios que gobiernan siguiente: codificación. . . . . . . . . . . . . comunicación. . . . . . . . . . . . despliegue . . . . . . . . . . . . . diseño . . . . . . . . . . . . . . . . modelado . . . . . . . . . . . . . . planeación . . . . . . . . . . . . . pruebas . . . . . . . . . . . . . . . requerimientos . . . . . . . . . . ¿qué ? práctica ingeniería software conjunto amplio principios, conceptos, métodos herramientas que deben considerarse planear desarrollar software. ¿quién hace? los profesionales (ingenieros software) sus gerentes realizan varias tareas ingeniería soft-ware. ¿por qué importante? proceso software propor- ciona todos los involucrados creación sistema producto basado computadora mapa para llegar con éxito destino. práctica proporciona los detalles que necesitarán para circular por carretera. indica dónde localizan los puentes, los caminos cerrados las bifurcaciones. ayuda entender los conceptos principios que deben entenderse seguirse fin llegar con seguri-dad rapidez. enseña manejar, dónde disminuir velo-cidad qué lugares acelerar. contexto inge-niería software, práctica que hace día tras día conforme software evoluciona idea realidad.¿cuáles son los pasos? son tres los elementos práctica que aplican sin importar modelo proceso que elija. trata : principios, conceptos métodos. cuarto elemento práctica —las herramientas— apoyo aplicación los métodos. ¿cuál producto final? práctica incluye las acti- vidades técnicas que generan todos los productos del tra-bajo definidos por modelo del proceso software que haya escogido. ¿cómo aseguro que hice bien? primer lugar, hay que tener una comprensión sólida los princi-pios que aplican trabajo (por ejemplo, diseño) cuestión. después, asegúrese que escogió método apropiado para trabajo, use herramientas automatiza-das cuando sean adecuadas para tarea sea firme respecto necesidad técnicas aseguramiento calidad los productos finales que generen. una mirada rápida algunos escritores afirman que cualquiera estos términos excluye los otros. realidad, ingeniería software las tres cosas. libro que explora las vidas pensamientos los ingenieros software, ellen ull- man [ull] ilustra una parte vida con relato que piensa profesional del software cuando está bajo presión: tengo idea hora que . esta oficina hay ventanas reloj, sólo pantalla horno microondas que parpadea led color rojo: :, :, :. joel hemos estado pro-gramando durante varios días. tenemos una falla, endemoniada testaruda. así que nos sentimos bien con pulso rojo sin tiempo, como fuera pasmo nuestros cerebros, algún modo sin-cronizados mismo ritmo del parpadeo… ¿ qué estamos trabajando? los detalles escapan. tal vez ayudamos personas pobres enfermas mejoramos conjunto rutinas bajo nivel protocolo base datos distri-buida, importa. debería importarme; otra parte ser —más tarde, quizá cuando salga este cuarto lleno computadoras— preocuparé mucho por qué para quién con qué propósito estoy escribiendo software. pero ahora, . cruzado una membrana tras que mundo real sus asuntos importan. soy ingeniera software. anterior una imagen tenebrosa práctica ingeniería software, pero detienen poco pensarlo, muchos los lectores este libro verán reflejados ella. las personas que elaboran software cómputo practican arte, artesanía disciplina conocida como ingeniería software. pero, ¿qué “práctica” ingeniería software? sentido general, conjunto conceptos, principios, métodos herramientas los que ingeniero software recurre forma cotidiana. práctica permite que los gerentes (-).indd (-).indd // ::// :: principios que guían práctica . conocimiento ingeniería software editorial publicado hace diez años ieee software, steve mcconnell [mcc] hizo siguiente comentario: muchos trabajadores del software piensan que conocimiento ingeniería software casi - clusivamente consiste tecnologías específicas: java, perl, html, ++, linux, windows , etc. para programar computadoras necesario conocer los detalles tecnológicos específicos. alguien pide lector que escriba programa ++, tiene que saber algo sobre este lenguaje fin que programa funcione. frecuente escuchar que conocimiento del desarrollo software tiene una vida media tres años, que significa que mitad que necesario saber hoy será obsoleto dentro tres años. dominio del conocimiento relacionado con tecnología probable que eso cumpla. pero hay otra clase conocimiento desarrollo software —algo que autor considera como los “principios ingeniería software”— que tiene una vida media tres años. factible que dichos principios sirvan programador profesional durante toda carrera. mcconnell continúa plantea que cuerpo conocimientos ingeniería software (alrededor del año ) evolucionado para convertirse “núcleo estable” que repre- senta cerca “% del conocimiento necesario para desarrollar sistema complejo”. pero, ¿qué que hay dentro ese núcleo estable? como dice mcconnell, los principios fundamentales —ideas elementales que guían los - genieros software trabajo que realizan— dan ahora fundamento partir del cual pueden aplicarse evaluarse los modelos, métodos herramientas ingeniería. . principios fundamentales práctica ingeniería software está guiada por conjunto principios fundamenta-les que ayudan aplicación del proceso software significativo ejecución méto-dos eficaces ingeniería software. nivel del proceso, los principios fundamentales establecen fundamento filosófico que guía equipo software cuando realiza activida-des estructurales actividades sombrilla, cuando navega por flujo del proceso elabora conjunto productos del trabajo ingeniería software. nivel práctica, los principios fundamentales definen conjunto valores reglas que sirven como guía cuando analiza problema, diseña una solución, implementa prueba ésta cuando, final, entrega software comunidad usuarios. capítulo identificó conjunto principios generales que amplían proceso práctica ingeniería software: ) agregar valor para los usuarios finales, ) mantenerlo sencillo, ) fijar visión (del producto proyecto), ) reconocer que otros consumen ( deben entender) que usted produce, ) abrirse futuro, ) planear reutilización ) ¡pensar! aunque estos principios generales son importantes, caracterizan nivel tan alto abs-tracción que ocasiones son difíciles traducir práctica cotidiana ingeniería administren proyectos software que los ingenieros software elaboren programas cómputo. práctica modelo del proceso software saber técnico administrativo para realizar trabajo. práctica transforma enfoque caprichoso disperso algo más organizado, más eficaz con mayor probabilidad alcanzar éxito. largo que resta del libro estudiarán distintos aspectos práctica inge- niería software. este capítulo, atención pone los principios conceptos que guían general. cita: “ teoría hay diferencia entre teoría práctica. pero práctica hay.” jan van snepscheut (-).indd (-).indd // ::// :: parte dos modelado software. las subsecciones que siguen analizan con más detalle los principios fundamen- tales que guían proceso práctica. .. principios que guían proceso parte este libro estudia importancia del proceso software describen los abundantes modelos proceso que han propuesto para hacer trabajo ingeniería software. sin que importe que modelo sea lineal iterativo, prescriptivo ágil, puede carac-terizarse con empleo estructura general del proceso aplicable todos los modelos proceso. los siguientes principios fundamentales aplican estructura , por extensión, todo proceso software: principio . ser ágil. sea que modelo proceso que elija sea prescriptivo ágil, son los principios básicos del desarrollo ágil los que deben gobernar enfoque. todo aspecto del trabajo que haga debe poner énfasis economía acción: mante-ner enfoque técnico tan sencillo como sea posible, hacer los productos del trabajo que generan tan concisos como pueda tomar las decisiones localmente, siempre que sea posible. principio . cada etapa, centrarse calidad. condición salida para toda actividad, acción tarea del proceso debe centrarse calidad del producto del trabajo que generado. principio . estar listo para adaptar. proceso una experiencia religiosa, hay lugar para dogma. cuando sea necesario, adapte enfoque las restricciones impuestas por problema, gente proyecto . principio . formar equipo eficaz. proceso práctica ingeniería soft- ware son importantes, pero objetivo son las personas. forme equipo con organiza- ción propia que haya confianza respeto mutuos. principio . establecer mecanismos para comunicación coordinación. los pro- yectos fallan porque información importante cae las grietas porque los participantes coordinan sus esfuerzos para crear producto final exitoso. éstos son aspectos administración que deben enfrentarse. principio . administrar cambio. enfoque puede ser formal informal, pero - ben establecerse mecanismos para administrar forma que los cambios solicitan, evalúan, aprueban implementan. principio . evaluar riesgo. son muchas las cosas que pueden salir mal cuando desarrolla software. esencial establecer planes contingencia.principio . crear productos del trabajo que agreguen valor para otros. sólo genere aquellos productos del trabajo que agreguen valor para otras actividades, acciones tareas del proceso. todo producto del trabajo que genere como parte práctica ingenie-ría software pasará alguien más. lista las funciones características requeridas dará persona ( personas) que desarrollará() diseño, diseño pasará quienes generan código así sucesivamente. asegúrese que producto del trabajo imparte información necesaria sin ambigüedades omisiones. parte este libro centra aspectos administración del proyecto del proceso, analiza detalle varios aspectos cada uno dichos principios. .. principios que guían práctica práctica ingeniería software tiene solo objetivo general: entregar tiempo soft- ware operativo alta calidad que contenga funciones características que satisfagan las -todo proyecto equipo son únicos. esto significa que debe adaptar proceso para que ajuste mejor sus necesidades.consejo cita: “ verdad que siempre sabe que correcto hacer. parte difícil hacerlo.” general . norman schwar zkopf (-).indd (-).indd // ::// :: principios que guían práctica cesidades todos los participantes. para lograrlo, debe adoptarse conjunto principios fundamentales que guíen trabajo técnico. estos principios tienen mérito sin que importen los métodos análisis diseño que apliquen, las técnicas construcción (por ejemplo, lenguaje programación las herramientas automatizadas) que usen enfoque veri-ficación validación que elija. los siguientes principios fundamentales son vitales para práctica ingeniería software: principio . divide vencerás. dicho forma más técnica, análisis diseño siem- pre deben enfatizar separación entidades (sde). problema grande más fácil resolver divide conjunto elementos ( entidades). ideal que cada enti- dad entregue funcionalidad distinta que pueda desarrollarse, ciertos casos validarse, independientemente otras entidades. principio . entender uso abstracción. parte medular, una abstracción una simplificación algún elemento complejo sistema usado para comunicar sig- nificado una sola frase. cuando usa abstracción hoja cálculo, supone que comprende que una hoja cálculo, estructura general contenido que presenta las funciones comunes que aplican ella. práctica ingeniería software, usan muchos niveles diferentes abstracción, cada uno los cuales imparte implica significado que debe comunicarse. trabajo análisis diseño, equipo software normalmente comienza con modelos que representan niveles elevados abstracción (por ejemplo, una hoja cálculo) poco poco los refina niveles más bajos abstracción (como una columna función sum). joel spolsky [spo] sugiere que “todas las abstracciones triviales hasta cierto punto son esquivas”. objetivo una abstracción eliminar necesidad comunicar deta-lles. pero, ocasiones, los efectos problemáticos precipitados por estos detalles “fil-tran” por todas partes. sin comprensión los detalles, puede diagnosticarse con -cilidad causa problema. principio . buscar coherencia. sea que esté creando modelo los reque- rimientos, desarrolle diseño software, genere código fuente elaboren casos prueba, principio coherencia sugiere que contexto familiar hace que software sea más fácil usar. como ejemplo, considere diseño una interfaz usuario para una webapp. colocación consistente opciones menú, uso esquema cohe-rencia color uso coherencia íconos reconocibles ayudan hacer que interfaz sea muy buena aspecto ergonómico. principio . centrarse transferencia información. software tiene que ver con transferencia información: una base datos usuario final, sistema heredado una webapp, usuario final una interfaz gráfica usuario (gui, por sus siglas inglés), sistema operativo una aplicación, componente software otro… lista casi interminable. todos los casos, información fluye través una interfaz, como consecuencia hay posibilidades cometer errores, omisiones -bigüedades. este principio implica que debe ponerse atención especial análisis, diseño, construcción prueba las interfaces. principio . construir software que tenga modularidad eficaz. separación enti- dades (principio ) establece una filosofía para software. modularidad proporciona mecanismo para llevar cabo dicha filosofía. cualquier sistema complejo puede dividirse módulos (componentes), pero buena práctica ingeniería software demanda más. modularidad debe ser eficaz. decir, cada módulo debe centrarse exclusivamente aspecto bien delimitado del sistema: debe ser cohesivo función restringido contenido que representa. además, los módulos deben estar interconectados forma punto clave los problemas son más fáciles resolver cuando subdividen entidades separadas, distintas entre , solucionables individualmente verificables. (-).indd (-).indd // ::// :: parte dos modelado relativamente sencilla: cada módulo debe tener poco acoplamiento con otros módulos, fuentes datos otros aspectos ambientales. principio . buscar patrones. brad appleton [app] sugiere que: objetivo los patrones dentro comunidad software crear cúmulo bibliografía que ayude los desarrolladores software resolver problemas recurrentes que surgen largo del desarrollo. los patrones ayudan crear lenguaje compartido para comunicar perspectiva experiencia acerca dichos patrones sus soluciones. codificación formal estas soluciones sus relaciones permite acumular con éxito cuerpo conocimientos que define nuestra com-prensión las buenas arquitecturas que satisfacen las necesidades sus usuarios. principio . cuando sea posible, representar problema solución desde varias perspectivas diferentes. cuando problema solución estudian desde varias perspectivas distintas, más probable que tenga mayor visión que detecten los errores omisiones. por ejemplo, modelo requerimientos puede representarse con empleo punto vista orientado los datos, función comportamiento (véanse los capítulos ). cada uno brinda punto vista diferente del problema sus requerimientos. principio . tener mente que alguien dará mantenimiento software. soft- ware será corregido largo plazo, cuando descubran sus defectos, adapte los cambios ambiente mejore momento que los participantes pidan más capacidades. estas actividades mantenimiento resultan más fáciles aplica una prác-tica sólida ingeniería software largo del proceso software. estos principios son todo que necesita para elaborar software alta calidad, pero establecen fundamento para todos los métodos ingeniería software que estudian este libro. . principios que guían toda actividad estructural las secciones que siguen consideran los principios que tienen mucha relevancia para éxito cada actividad estructural genérica, definida como parte del proceso software. muchos casos, los principios que estudian para cada una las actividades estructurales son refinamiento los principios presentados sección .. tan sólo son principios funda-mentales planteados nivel más bajo abstracción. .. principios comunicación antes que los requerimientos del cliente analicen, modelen especifiquen, deben reca-barse través actividad comunicación. cliente tiene problema que parece abor-dable mediante una solución basada computadora. usted responde solicitud ayuda del cliente. comenzado comunicación. pero frecuente que camino que lleva comunicación comprensión esté lleno agujeros. comunicación efectiva (entre colegas técnicos, con cliente otros participantes, con los gerentes proyecto) encuentra entre las actividades más difíciles que deben enfrentarse. este contexto, aquí estudian principios comunicación aplicados comunicación con cliente. sin embargo, muchos ellos aplican por igual todas las formas comunica-ción que ocurren dentro proyecto software. principio . escuchar. trate centrarse las palabras del hablante lugar for-mular respuesta dichas palabras. algo está claro, pregunte para aclararlo, pero evite las interrupciones constantes. una persona habla, nunca parezca usted beligerante sus palabras actos (por ejemplo, con giros los ojos movimientos cabeza).use patrones (véase capítulo ) fin acumular conocimiento experiencia para las futuras generaciones ingenieros software.consejo cita: “ ingeniero ideal una mez-cla… científico, matemático, soció-logo escritor; pero para resolver problemas ingenie-ría utiliza conocimiento técnicas algunas todas esas disciplinas.” . . dougherty (-).indd (-).indd // ::// :: principios que guían práctica principio . antes comunicarse, prepararse. dedique algún tiempo entender problema antes reunirse con otras personas. necesario, haga algunas investigacio- nes para entender vocabulario propio del negocio. tiene responsabilidad condu-cir reunión, prepare una agenda antes que ésta tenga lugar. principio . alguien debe facilitar actividad. toda reunión comunicación debe tener líder (facilitador) que: ) mantenga conversación movimiento hacia una - rección positiva, ) sea mediador cualquier conflicto que ocurra ) garantice que sigan otros principios. principio . mejor comunicación cara cara. pero por general funciona - jor cuando está presente alguna otra representación información relevante. por ejem- plo, participante quizá genere dibujo documento “borrador” que sirva como centro discusión. principio . tomar notas documentar las decisiones. las cosas encuentran modo caer las grietas. alguien que participe comunicación debe servir como “secreta- rio” escribir todos los temas decisiones importantes. principio . perseguir colaboración. colaboración consenso ocurren cuando conocimiento colectivo los miembros del equipo utiliza para describir funciones características del producto sistema. cada pequeña colaboración sirve para generar con-fianza entre los miembros del equipo crea objetivo común para grupo. principio . permanecer centrado; hacer módulos con discusión. entre más per- sonas participen cualquier comunicación, más probable que conversación salte tema otro. facilitador debe formar módulos conversación para abandonar tema sólo después que haya resuelto (sin embargo, considere principio ). principio . algo está claro, hacer dibujo. comunicación verbal tiene sus límites. con frecuencia, esquema dibujo arroja claridad cuando las palabras bastan para hacer trabajo. principio . ) una vez que acuerde algo, avanzar. ) posible ponerse acuerdo algo, avanzar. ) una característica función está clara puede aclararse momento, avanzar. comunicación, como cualquier actividad ingeniería software, requiere tiempo. vez hacer iteraciones sin fin, las personas que participan deben reconocer que hay muchos temas que requieren análisis (véase principio ) que “avanzar” veces mejor forma tener agilidad comunicación. principio . negociación concurso juego. funciona mejor cuando las dos partes ganan. hay muchas circunstancias las que usted otros participantes deben negociar funciones características, prioridades fechas entrega. equipo cita: “las preguntas directas las respuestas directas son cami- más corto hacia las mayores perplejidades.” mark twainantes comunicarse, asegúrese que entiende punto vista otra parte, conozca poco sus necesidades después escuche.consejo ¿qué pasa puede llegarse acuerdo con cliente algún aspecto relacionado con proyecto?? los ingenieros software comunican con muchos par- ticipantes diferentes, pero los clientes los usuarios finales son quienes tienen efecto más significativo trabajo técnico que desarrollará. ciertos casos, cliente usuario final son misma persona, pero para muchos proyectos son individuos distintos que trabajan para diferentes gerentes distintas organizaciones negocios. cliente persona grupo que ) solicitó originalmente que construyera software, ) define los objetivos generales del nego-cio para software, ) proporciona los requerimientos básicos del producto ) coordina obtención fondos para proyecto. negocio productos sistema, frecuente que cliente sea departamento mercadotecnia. ambiente tecnologías información (), cliente tal vez sea componente departamento del negocio. usuario final persona grupo que ) usará realidad software que elabore para lograr algún propósito del negocio ) definirá los detalles operación del software modo que alcance propósito del negocio.información diferencia entre los clientes los usuarios finales (-).indd (-).indd // ::// :: parte dos modelado colaborado bien, todas las partes tendrán objetivo común. aun así, negociación - mandará compromiso todas las partes. .. principios planeación actividad comunicación ayuda definir las metas objetivos generales (por supuesto, sujetos cambio conforme pasa tiempo). sin embargo, comprensión estas metas objetivos mismo que definir plan para lograrlo. actividad planeación incluye conjunto prácticas administrativas técnicas que permiten que equipo software defina mapa mientras avanza hacia meta estratégica sus objetivos tácticos. créalo, imposible predecir con exactitud cómo desarrollará proyecto software. existe una forma fácil determinar qué problemas técnicos encontrarán, qué información importante permanecerá oculta hasta que proyecto esté muy avanzado, qué malos entendi-dos habrá qué aspectos del negocio cambiarán. obstante, buen equipo software debe planear con este enfoque. hay muchas filosofías planeación. algunas personas son “minimalistas” afirman que frecuente que cambio elimine necesidad hacer plan detallado. otras son “tradiciona-listas” dicen que plan mapa eficaz que entre más detalles tenga menos probable será que equipo pierda. otros más son “agilistas” plantean que tal vez sea necesario “juego planeación” rápido, pero que mapa surgirá medida que comience “trabajo real” con software. ¿qué hacer? muchos proyectos, planear exceso consume tiempo estéril (porque son demasiadas las cosas que cambian), pero planear poco una receta para caos. igual que mayoría cosas vida, planeación debe ser tomada con moderación, suficiente para que una guía útil equipo, más menos. sin importar rigor con que haga pla-neación, siempre aplican los principios siguientes: escena: lugar trabajo del equipo inge- niería software. participantes: jamie lazar, vinod roman robins, miembros del equipo software. conversación:: ¿qué has oído sobre proyecto casasegura?vinod: reunión arranque está programada para semana siguiente. jamie: traté investigar algo, pero salió bien.: ¿qué quieres decir?jamie: bueno, llamé lisa pérez. ella encargada merca- dotecnia esto. vinod: ¿…?jamie: quería que dijera las características funciones casasegura… esa clase cosas. lugar ello, comenzó hacerme preguntas sobre sistemas seguridad, vigilancia… soy experto eso.vinod: ¿qué dice eso? (jamie encoge hombros.)vinod: será que mercadotecnia quiere que actuemos como consul- tores mejor que hagamos alguna tarea sobre esta área produc-tos antes nuestra junta arranque. doug dijo que quería que “colaboráramos” con nuestro cliente, así que será mejor que apren-damos cómo hacerlo. : tal vez hubiera sido mejor oficina. las llamadas por telé- fono simplemente sirven para esta clase trabajos. jamie: están correcto. tenemos que actuar juntos nuestras primeras comunicaciones serán una batalla. vinod: doug leyendo libro acerca “requerimientos ingeniería”. apuesto que enlista algunos principios buena comunicación. voy pedírselo prestado. jamie: buena idea… luego nos enseñas.vinod (sonríe): , acuerdo.casasegura errores comunicación parte este libro hay análisis detallado planeación administración proyectos software.cita: “ prepararme para una bata- lla siempre descubro que los planes son inútiles, pero que planeación indispensable.” general dwight . eisenhower webref dirección repository.htm, hay excelentes materiales informativos sobre planeación administración proyectos. (-).indd (-).indd // ::// :: principios que guían práctica principio . entender alcance del proyecto. imposible usar mapa sabe dónde . alcance destino equipo software. principio . involucrar actividad planeación los participantes del software. los participantes definen las prioridades establecen las restricciones del pro-yecto. para incluir estas realidades, frecuente que los ingenieros software deban -gociar orden entrega, los plazos otros asuntos relacionados con proyecto. principio . reconocer que planeación iterativa. plan para proyecto nunca está grabado piedra. para cuando trabajo comience, muy probable que las cosas hayan cambiado. consecuencia, plan deberá ajustarse para incluir dichos cambios. además, los modelos proceso iterativo incrementales dictan que debe repetirse pla-neación después entrega cada incremento software, con base retroalimen-tación recibida los usuarios. principio . estimar con base que sabe. objetivo estimación obte- ner índice del esfuerzo, costo duración las tareas, con base comprensión que tenga equipo sobre trabajo que realizar. información vaga poco confia-ble, entonces las estimaciones tampoco serán confiables. principio . definir plan, tomar cuenta los riesgos. identificado riesgos que tendrían efecto grande muy probable que ocurran, entonces necesario ela- borar planes contingencia. además, plan del proyecto (incluso programación -tividades) deberá ajustarse para que incluya posibilidad que ocurran uno más -chos riesgos. principio . ser realista. las personas trabajan % todos los días. cualquier - municación humana hay ruido. las omisiones ambigüedad son fenómenos vida. los cambios ocurren. aun los mejores ingenieros software cometen errores. éstas otras realidades deben considerarse establecer proyecto. principio . ajustar granularidad cuando defina plan. granularidad - fiere nivel detalle que adopta cuando desarrolla plan. plan con “mucha granularidad” proporciona detalles significativos las tareas para trabajo que planea, incrementos durante periodo relativamente corto (por que seguimiento control suceden con frecuencia). plan con “poca granularidad” tareas más amplias para trabajo que planea, para plazos más largos. general, granularidad poca mucha conforme tiempo avanza. las siguientes semanas meses, proyecto pla-nea con detalles significativos. las actividades que ocurrirán muchos meses -quieren mucha granularidad (hay demasiadas cosas que pueden cambiar). principio . definir cómo trata asegurar calidad. plan debe identificar forma que equipo software busca asegurar calidad. realizan revisiones técnicas, deben programarse. durante construcción utilizarse programación por parejas (véase capítulo ), debe definirse forma explícita plan. principio . describir cómo busca manejar cambio. aun mejor planeación puede ser anulada por cambio sin control. debe identificarse forma que van - cibirse los cambios medida que avanza trabajo ingeniería software. por ejem-plo, ¿ cliente tiene posibilidad solicitar cambio cualquier momento? soli-cita uno, ¿está obligado equipo implementarlo inmediato? ¿cómo evalúan efecto costo del cambio?cita: “ éxito más una función del sentido común coherente que del genio.” wang punto clave término granularidad refiere detalle con que representan efectúan algunos elementos planeación. las revisiones técnicas estudian capítulo . (-).indd (-).indd // ::// :: parte dos modelado principio . dar seguimiento plan con frecuencia hacer los ajustes que requieran. los proyectos software atrasan respecto programación. por tanto, tiene sentido evaluar diariamente avance, busca áreas situaciones problemáticas las que las actividades programadas apeguen avance real. cuando detecten desviaciones, hay que ajustar plan consecuencia. para ser más eficaz, cada integrante del equipo software debe participar actividad planeación. sólo entonces sus miembros “firmarán” plan. .. principios modelado crean modelos para entender mejor entidad real que construir. cuando ésta física (por ejemplo, edificio, avión, una máquina, etc.), construye modelo forma idén-tica pero escala. sin embargo, cuando entidad que construir software, modelo debe adoptar una forma distinta. debe ser capaz representar información que software transforma, arquitectura las funciones que permiten que esto ocurra, las características que desean los usuarios comportamiento del sistema mientras transformación tiene lugar. los modelos deben cumplir estos objetivos diferentes niveles abstracción, primer lugar con ilustración del software desde punto vista del cliente después con representación nivel más técnico. trabajo ingeniería software crean dos clases modelos: requerimientos diseño. los modelos requerimientos (también conocidos como modelos análisis) repre- sentan los requerimientos del cliente mediante ilustración del software tres dominios -ferentes: información, funcional comportamiento. los modelos diseño repre- sentan características del software que ayudan los profesionales elaborarlo con eficacia: arquitectura, interfaz usuario detalle nivel componente. libro sobre modelado ágil, scott ambler ron jeffries [amb] definen conjunto principios modelado dirigidos todos aquellos que usan modelo proceso ágil (véase capítulo ), pero que son apropiados para todos los ingenieros software que efectúan -ciones tareas modelado: principio . equipo software tiene como objetivo principal elaborar software, crear modelos. agilidad significa entregar software cliente manera más - pida posible. los modelos que contribuyan esto son benéficos, pero deben evitarse aque-llos que hagan lento proceso que den poca perspectiva. principio . viajar ligero, crear más modelos los necesarios. todo modelo que cree debe actualizarse ocurren cambios. más importante aún que todo modelo nuevo exige tiempo, que otra manera destinaría construcción (codificación pruebas). entonces, cree sólo aquellos modelos que hagan más fácil rápido construir software. principio . tratar producir modelo más sencillo que describa problema software. construya software demasía [amb]. mantener sencillos los - delos, software resultante también será. resultado que tendrá software fácil integrar, probar mantener (para que cambie). además, los modelos sencillos son más fáciles entender criticar por parte los miembros del equipo, que como -sultado formato funcional retroalimentación que optimiza resultado final. principio . construir modelos susceptibles cambio. suponga que sus modelos cambiarán, pero vigile que esta suposición haga descuidado. por ejemplo, como los para fines este libro, han abreviado reescrito los principios mencionados esta sección.punto clave los modelos requerimientos representan los requerimientos del cliente. los modelos del diseño dan una especificación concreta para construcción del software. objetivo cualquier modelo comunicar información. para lograr esto, use formato consistente. suponga que usted estará para explicar modelo. por eso, modelo debe describirse por solo. consejo (-).indd (-).indd // ::// :: principios que guían práctica requerimientos modificarán, hay una tendencia ignorar los modelos. ¿por qué? porque sabe que todos modos cambiarán. problema con esta actitud que sin modelo razonablemente completo los requerimientos, creará diseño (modelo diseño) que manera invariable carecerá funciones características importantes. principio . ser capaz enunciar propósito explícito para cada modelo que cree. cada vez que cree modelo, pregúntese por qué hace. encuentra una -zón sólida para existencia del modelo, pierda tiempo . principio . adaptar los modelos que desarrollan sistema cuestión. tal vez sea necesario adaptar aplicación notación del modelo las reglas; por ejemplo, una aplicación juego video quizá requiera una técnica modelado distinta que soft-ware incrustado que controla motor automóvil tiempo real. principio . tratar construir modelos útiles, pero olvidarse elaborar modelos perfectos. cuando ingeniero software construye modelos requerimientos -seño, alcanza punto rendimientos decrecientes. decir, esfuerzo requerido para terminar por completo modelo hacerlo internamente consistente deja beneficiarse por tener dichas propiedades. ¿ sugiere que modelado debe ser pobre baja cali-dad? respuesta “”. pero modelado debe hacerse con mirada puesta las -guientes etapas ingeniería software. las iteraciones sin fin para obtener modelo “perfecto” cumplen necesidad agilidad. principio . ser dogmático respecto sintaxis del modelo. tiene éxito para comunicar contenido, representación secundaria. aunque cada miembro del equipo software debe tratar usar una notación consistente durante modelado, característica más importante del modelo comunicar información que permita reali-zación siguiente tarea ingeniería. modelo tiene éxito hacer esto, perdo-nable sintaxis incorrecta. principio . instinto dice que modelo correcto pesar que vea bien papel, hay razones para estar preocupado. usted ingeniero software experimentado, confíe instinto. trabajo software enseña muchas lec-ciones, algunas nivel del inconsciente. algo dice que modelo diseño está destinado fracasar (aun cuando esto pueda demostrarse forma explícita), hay razo-nes para dedicar más tiempo estudio desarrollar otro distinto. principio . obtener retroalimentación tan pronto como sea posible. todo modelo debe ser revisado por los miembros del equipo. objetivo estas revisiones obtener retroalimentación para utilizarla fin corregir los errores modelado, cambiar las -terpretaciones equivocadas agregar las características funciones omitidas inadvertida-mente. requerimientos los principios modelado. las últimas tres décadas han desa- rrollado numerosos métodos modelado requerimientos. los vestigadores han identifi- cado los problemas del análisis requerimientos sus causas, han desarrollado varias nota-ciones modelado los conjuntos heurísticos correspondientes para resolver aquéllos. cada método análisis tiene punto vista único. sin embargo, todos están relacionados por ciertos principios operacionales: principio . debe representarse entenderse dominio información problema. dominio información incluye los datos que fluyen hacia sistema (usua-rios finales, otros sistemas dispositivos externos), los datos que fluyen fuera del sistema (por interfaz usuario, interfaces red, reportes, gráficas otros medios) los alma-cenamientos datos que recaban organizan objetos persistentes datos (por ejemplo, aquellos que conservan forma permanente). (-).indd (-).indd // ::// :: parte dos modelado principio . deben definirse las funciones que realizará software. las funciones del software dan beneficio directo los usuarios finales también brindan apoyo - terno para las características que son visibles para aquéllos. algunas funciones transfor-man los datos que fluyen hacia sistema. otros casos, las funciones activan algún nivel control sobre procesamiento interno del software sobre los elementos externos del sistema. las funciones describen muchos distintos niveles abstracción, que van enunciado propósito general descripción detallada los elementos del pro-cesamiento que deben invocarse. principio . debe representarse comportamiento del software (como consecuen- cia eventos externos). comportamiento del software computadora está determi- nado por interacción con ambiente externo. las entradas que dan los usuarios finales, control los datos efectuado por sistema externo vigilancia datos reunidos una red son motivo por que software comporta una forma específica. principio . los modelos que representen información, función comportamiento deben dividirse manera que revelen los detalles forma estratificada ( jerárquica). modelado los requerimientos primer paso para resolver pro-blema ingeniería software. eso permite entender mejor problema proporciona una base para solución (diseño). los problemas complejos son difíciles resolver por completo. por esta razón, debe usarse estrategia divide vencerás. problema grande complejo divide subproblemas hasta que cada uno éstos sea relativa-mente fácil entender. este concepto llama partición separación entidades, una estrategia clave modelado requerimientos. principio . trabajo análisis debe avanzar información esencial hacia implementación detalle. modelado requerimientos comienza con descrip- ción del problema desde perspectiva del usuario final. describe “esencia” del pro-blema sin considerar forma que implementará solución. por ejemplo, juego video requiere que jugadora “enseñe” protagonista qué dirección avanzar cuando mueve hacia laberinto peligroso. ésa esencia del problema. imple-mentación detallada (normalmente descrita como parte del modelo del diseño) indica cómo desarrollará esencia. para juego video, quizá use una entrada voz, -criba comando teclado, tal vez joystick ( mouse) apunte una dirección - pecífica, quizá mueva aire dispositivo sensible movimiento. con aplicación estos principios, ingeniero software aborda problema forma sistemática. pero, ¿cómo aplican estos principios práctica? esta pregunta responderá los capítulos . principios del modelado del diseño. modelo del diseño del software análogo los planos arquitectónicos una casa. comienza por representar totalidad que construir (por ejemplo, croquis tridimensional casa) que refina poco poco para que guíe construcción cada detalle (por ejemplo, distribución plomería). manera similar , modelo del diseño que crea para software varios puntos vista distintos del sistema. escasean los métodos para obtener los distintos elementos diseño software. algunos son activados por datos, que hace que sea estructura éstos que determine arquitectura del programa los componentes procesamiento resultantes. otros están moti-vados por patrón, usan información sobre dominio del problema ( modelo requeri-mientos) para desarrollar estilos arquitectura patrones procesamiento. otros más están orientados objetos, utilizan objetos del dominio del problema como impulsores crea-ción estructuras datos métodos que los manipulan. obstante variedad, todos ellos apegan principios diseño que aplican sin importar método empleado.cita: “vea primero que diseño sabio justo: eso comprobado, siga resueltamente; para uno renunciar rechazar propósi- que resuelto llevar cabo.” william shakespearepunto clave modelado del análisis centra tres atributos del software: información que procesar, función que entregar comportamiento que suceder. cita: “ cualquier trabajo diseño, primer problema del ingenie- descubrir cuál realmente problema.” autor desconocido (-).indd (-).indd // ::// :: principios que guían práctica principio . diseño debe poderse rastrear hasta modelo requerimientos. modelo requerimientos describe dominio información del problema, las funciones visibles para usuario, comportamiento del sistema conjunto clases requeri-mientos que agrupa los objetos del negocio con los métodos que les dan servicio. -delo diseño traduce esta información una arquitectura, conjunto subsistemas que implementan las funciones principales conjunto componentes que son reali-zación las clases requerimientos. los elementos del modelo diseño deben poder rastrearse modelo requerimientos. principio . siempre tomar cuenta arquitectura del sistema que construir. arquitectura del software (véase capítulo ) esqueleto del sistema que construir. afecta interfaces, estructuras datos, flujo control comporta-miento del programa, así como manera que realizarán las pruebas, susceptibi-lidad del sistema resultante recibir mantenimiento mucho más. por todas estas razones, diseño debe comenzar con consideraciones arquitectura. sólo después estable-cida ésta deben considerarse los aspectos nivel los componentes. principio . diseño los datos tan importante como las funciones procesamiento. diseño los datos elemento esencial del diseño arquitec- tura. forma que los objetos datos elaboran dentro del diseño puede -jarse azar. diseño datos bien estructurado ayuda simplificar flujo del pro-grama, hace más fácil diseño implementación componentes software más eficiente procesamiento conjunto. principio . las interfaces (tanto internas como externas) deben diseñarse con cuidado. manera que los datos fluyen entre los componentes sistema tiene mucho que ver con eficiencia del procesamiento, propagación del error simplici-dad del diseño. una interfaz bien diseñada hace que integración sea más fácil ayuda quien somete prueba validar las funciones componentes. principio . diseño interfaz usuario debe ajustarse las necesidades del usuario final. sin embargo, todo caso debe resaltar facilidad uso. inter- faz usuario manifestación visible del software. importa cuán sofisticadas sean sus funciones internas, incluyentes que sean sus estructuras datos, bien dise-ñada que esté arquitectura, mal diseño interfaz con frecuencia conduce percepción que software “malo”. principio . diseño nivel componentes debe tener independencia funcional. independencia funcional una medida “mentalidad única” componente software. funcionalidad que entrega componente debe ser cohesiva, decir, debe centrarse una sólo una función subfunción. principio . los componentes deben estar acoplados con holgura entre con ambiente externo. acoplamiento logra muchos modos: con una interfaz com- ponente, con mensajería, por medio datos globales, etc. medida que incrementa nivel acoplamiento, también aumenta probabilidad propagación del error dismi-nuye facilidad general dar mantenimiento software. entonces, acoplamiento componentes debe mantenerse tan bajo como sea razonable. principio . las representaciones del diseño (modelos) deben entenderse con facilidad. propósito del diseño comunicar información los profesionales que gene-rarán código, los que probarán software otros que darán mantenimiento futuro. diseño difícil entender, servirá como medio comunicación eficaz.cita: “las diferencias son meno- res; por contrario, son como las que había entre salieri mozart. estudio tras otro muestran que los mejores dise-ñadores elaboran estructuras más rápidas, pequeñas, senci-llas, claras producidas con menos esfuerzo.” frederick . brookswebref dirección .wwc.edu/ ~aabyan/design/, encuentran comentarios profundos sobre proceso diseño, así como análisis estética del diseño. capítulo hay más análisis cohesión. (-).indd (-).indd // ::// :: parte dos modelado principio . diseño debe desarrollarse forma iterativa. diseñador debe bus- car más sencillez cada iteración. igual que ocurre con casi todas las actividades creativas, diseño ocurre manera iterativa. las primeras iteraciones sirven para mejo-rar diseño corregir errores, pero las posteriores deben buscar diseño tan sencillo como sea posible. cuando aplican forma apropiada estos principios diseño, crea uno que exhibe factores calidad tanto externos como internos [mye]. los factores calidad externos son aquellas propiedades del software fácilmente observables por los usuarios (por ejemplo, veloci- dad, confiabilidad, corrección usabilidad). los factores calidad internos son importancia para los ingenieros software. conducen diseño alta calidad desde punto vista técnico. para obtener factores calidad internos, diseñador debe entender los conceptos básicos del diseño (véase capítulo ). .. principios construcción actividad construcción incluye conjunto tareas codificación pruebas que lleva software operativo listo para entregarse cliente usuario final. trabajo ingenie-ría software moderna, codificación puede ser ) creación directa lenguaje progra-mación código fuente (por ejemplo, java), ) generación automática código fuente que usa una representación intermedia parecida diseño del componente que construir ) generación automática código ejecutable que utiliza “lenguaje programación cuarta generación” (por ejemplo, visual ++). las pruebas dirigen atención inicial componente, con frecuencia denomina prueba unitaria. otros niveles pruebas incluyen ) integración (realizadas mientras sistema está construcción), ) validación, que evalúan los requerimientos han satisfecho para todo sistema ( incremento software) ) aceptación , que efectúa cliente esfuerzo por utilizar todas las características funciones requeridas. los siguientes principios concep-tos son aplicables codificación prueba: principios codificación. los principios que guían trabajo codificación relacionan cerca con estilo, lenguajes métodos programación. sin embargo, puede enunciarse cierto número principios fundamentales: principios preparación: antes escribir una sola línea código, asegúr ese : • entender problema que trata resolver. • comprender los principios conceptos básicos del diseño. • elegir lenguaje programación que satisfaga las necesidades del software que elaborar ambiente que operará. • seleccionar ambiente programación que disponga herramientas que hagan más fácil trabajo. • crear conjunto pruebas unitarias que aplicarán una vez que haya terminado componente codificar. principios programación: cuando comience escribir código, asegúr ese : • restringir sus algoritmos por medio del uso programación estructurada [boh]. • tomar consideración uso programación por parejas. • seleccionar estructuras datos que satisfagan las necesidades del diseño. • entender arquitectura del software crear interfaces que son congruentes con ella. • mantener lógica condicional tan sencilla como sea posible.cita: “durante gran parte vida sido mirón del software, observo furtivamente código sucio otras personas. veces encuentro una verdadera joya, programa bien estructurado escrito estilo consistente, libre errores, desarrollado modo que cada componente sencillo organizado, que está diseñado modo que producto fácil cambiar.” david parnas evite desarrollar programa elegante que resuelva problema equivocado. ponga especial atención primer principio preparación.consejo (-).indd (-).indd // ::// :: principios que guían práctica • crear lazos anidados forma tal que puedan probar con facilidad. • seleccionar nombres significativos para las variables seguir otros estándares locales codificación. • escribir código que documente mismo. • crear una imagen visual (por ejemplo, líneas con sangría blanco) que ayude entender. principios validación: una vez que hay terminado primer intento codifi- cación, asegúrese : • realizar recorrido del código cuando sea apropiado. • llevar cabo pruebas unitarias corregir los errores que detecten. • rediseñar código. han escrito más libros sobre programación (codificación) sobre los principios conceptos que guían que sobre cualquier otro tema del proceso software. los libros sobre tema incluyen obras tempranas sobre estilo programación [ker], construcción software prác-tico [mcc], perlas programación [ben], arte programar [knu], temas pragmáticos programación [hun] muchísimos temas más. análisis exhaustivo estos principios conceptos está más allá del alcance este libro. tiene interés profundizar, estudie una varias las referencias que mencionan. principios prueba. libro clásico sobre las pruebas software , glen myers [mye] enuncia algunas reglas que sirven bien como objetivos prueba: • prueba proceso que ejecuta programa con objeto encontrar error. • buen caso prueba que tiene alta probabilidad encontrar error que detectado hasta momento. • una prueba exitosa que descubre error detectado hasta momento. estos objetivos implican cambio muy grande punto vista ciertos desarrolladores software. ellos avanzan contra opinión común que una prueba exitosa aquella que encuentra errores software. objetivo diseñar pruebas que detecten manera sistemática diferentes clases errores, hacerlo con mínimo tiempo esfuerzo. las pruebas efectúan con éxito ( acuerdo con los objetivos mencionados), descu- brirán errores software. como beneficio secundario, prueba demuestra que las funciones software parecen funcionar acuerdo con las especificaciones, que los requerimientos comportamiento desempeño aparentemente cumplen. además, los datos obtenidos con-forme realiza prueba dan una buena indicación confiabilidad del software ciertas indicaciones calidad éste como todo. pero las pruebas pueden demostrar inexistencia errores defectos; sólo demuestran que hay errores defectos. importante recordar esto (que otro modo parecería muy pesimista) cuando efectúe una prueba. davis [dav] sugiere algunos principios para las pruebas, que han adaptado para usar- los este libro: principio . todas las pruebas deben poder rastrearse hasta los requerimientos del cliente. objetivo las pruebas software descubrir errores. entonces, los defec- contexto amplio del diseño software, recuerde que comienza “por grande” centra arquitectura del software, que termina “ pequeño” atiende los componentes. para prueba sólo invierte proceso.consejo¿cuáles son los objetivos probar software??webref dirección www. literateprogramming.com/fpstyle.html, hay una amplia variedad vínculos estándares codificación. aquí sólo mencionan pocos los principios prueba davis. para más información, consulte [dav]. este principio refiere las pruebas funcionales, por ejemplo, aquellas que centran los requerimientos. las pruebas estructurales (las que centran los detalles arquitectura lógica) tal vez aborden directamente los requerimientos específicos. (-).indd (-).indd // ::// :: parte dos modelado tos más severos (desde punto vista del cliente) son aquellos que hacen que pro- grama cumpla sus requerimientos. principio . las pruebas deben planearse mucho antes que den comienzo. planeación las pruebas (véase capítulo ) comienza tan pronto como termina modelo requerimientos. definición detallada casos prueba principia apenas concluido modelo diseño. por tanto, todas las pruebas pueden planearse dise-ñarse antes generar cualquier código. principio . principio pareto aplica las pruebas software. este con- texto, principio pareto implica que % todos los errores detectados durante las pruebas relacionan con % todos los componentes programas. por supuesto, problema aislar los componentes sospechosos probarlos fondo. principio . las pruebas deben comenzar “ pequeño” avanzar hacia “ grande”. las primeras pruebas planeadas ejecutadas por general centran com-ponentes individuales. conforme avanzan las pruebas, atención cambia intento por encontrar errores grupos integrados componentes , última instancia, todo sistema. principio . son posibles las pruebas exhaustivas. hasta para programa - maño moderado, número permutaciones las rutas demasiado grande. por esta razón, durante una prueba imposible ejecutar todas las combinaciones rutas. sin -bargo, posible cubrir forma adecuada lógica del programa asegurar que han probado todas las condiciones nivel componentes. .. principios despliegue como dijo parte del libro, actividad del despliegue incluye tres acciones: entrega, apoyo retroalimentación. como naturaleza los modelos del proceso del software -derno evolutiva incremental, despliegue ocurre una vez sino varias, medida que software avanza hacia conclusión. cada ciclo entrega pone disposición los clientes usuarios finales incremento software operativo que brinda funciones características utilizables. cada ciclo apoyo provee documentación ayuda humana para todas las funcio-nes características introducidas durante los ciclos despliegue realizados hasta ese -mento. cada ciclo retroalimentación equipo software una guía importante que como resultado modificaciones las funciones, las características del enfoque adoptado para siguiente incremento. entrega incremento software representa punto referencia importante para cualquier proyecto software. cuando equipo prepara para entregar incremento, -ben seguirse ciertos principios clave: principio . deben manejarse las expectativas los clientes. con demasiada fre- cuencia, cliente espera más que equipo prometido entregar, desilusión llega inmediato. esto como resultado que retroalimentación sea productiva arruine moral del equipo. libro sobre administración las expectativas, naomi karten [kar] afirma que “ punto inicio administración las expectativas ser más consciente que comunica forma que esto hace”. ella sugiere que ingeniero software debe tener cuidado con envío mensajes conflictivos cliente (por ejemplo, prometer más que puede entregarse manera razonable plazo previsto, entregar más que prometió incremento software para siguiente entregar menos). principio . debe ensamblarse probarse paquete completo que entregará. debe ensamblarse -rom otro medio (incluso descargas desde web) todo soft-ware ejecutable, archivos datos apoyo, documentos ayuda otra información rele- asegúrese que cliente sabe que puede esperar antes que entregue incremento software. otra manera, puede apostar que cliente espera más que usted dará.consejo (-).indd (-).indd // ::// :: principios que guían práctica vante, para después hacer una prueba beta exhaustiva con usuarios reales. todos los scripts instalación otras características operación deben ejecutarse por completo tantas configuraciones diferentes cómputo como sea posible (por ejemplo, hardware, sistemas operativos, equipos periféricos, configuraciones red, etcétera). principio . antes entregar software, debe establecerse régimen apoyo. usuario final espera respuesta información exacta cuando surja una pregunta pro-blema. apoyo hoc, , peor aún, existe, cliente quedará insatisfecho -mediato. apoyo debe planearse, los materiales respectivos deben prepararse los meca-nismos apropiados registro deben establecerse fin que equipo software realice una evaluación categórica las clases apoyo solicitado. principio . deben proporcionar los usuarios finales materiales aprendizaje apropiados. equipo software entrega algo más que software . deben desa- rrollarse materiales capacitación apropiados ( requirieran); necesario proveer -neamientos para solución problemas , cuando sea necesario, debe publicarse “ que diferente este incremento software”. principio . software defectuoso debe corregirse primero después entregarse.cuando tiempo apremia, algunas organizaciones software entregan incrementos baja calidad con advertencia que los errores “ corregirán siguiente entrega”. esto error. hay adagio negocio del software que dice así: “los clientes olvi-darán pronto que entregaste producto alta calidad, pero nunca olvidarán los proble-mas que les causó producto mala calidad. software los recuerda cada día.” software entregado brinda beneficios usuario final, pero también retroalimentación útil para equipo que desarrolló. cuando incremento libere, debe invitarse los usua- rios finales que comenten acerca características funciones, facilidad uso, confiabilidad cualesquiera otras características. . resumen práctica ingeniería software incluye principios, conceptos, métodos herramientas que los ingenieros software aplican todo proceso desarrollo. todo proyecto inge-niería software diferente. obstante, existe conjunto principios generales que aplican proceso como todo cada actividad estructural, sin importar cuál sea proyecto producto. existe conjunto principios fundamentales que ayudan aplicación proceso software significativo ejecución métodos ingeniería software eficaz. nivel del proceso, los principios fundamentales establecen fundamento filosófico que guía equipo software cuando avanza por proceso del software. nivel práctica, los principios fundamentales establecen conjunto valores reglas que sirven como guía analizar diseño problema solución, implementar ésta someterla prueba para, finalmente, desplegar software comunidad del usuario. los principios comunicación centran necesidad reducir ruido mejorar ancho banda durante conversación entre desarrollador cliente. ambas partes deben colaborar fin lograr mejor comunicación. los principios planeación establecen lineamientos para elaborar mejor mapa del pro- ceso hacia sistema producto terminado. plan puede diseñarse sólo para incremento durante actividad comunicación, equipo software debe determinar los tipos materiales ayuda que quiere usuario. (-).indd (-).indd // ::// :: parte dos modelado del software, para todo proyecto. sin que esto importe, debe definir que hará, quién hará cuándo terminará trabajo. modelado incluye tanto análisis como diseño, describe representaciones cada vez más detalladas del software. objetivo los modelos afirmar entendimiento del trabajo que hacer dar una guía técnica quienes implementarán software. los principios modelado dan fundamento los métodos notación que utilizan para crear representaciones del software. construcción incorpora ciclo codificación pruebas que genera código fuente para cierto componente sometido pruebas. los principios codificación definen las acciones generales que deben tener lugar antes que escriba código, mientras -cribe una vez terminado. aunque hay muchos principios para las pruebas, sólo uno predomina: prueba proceso que lleva ejecutar programa con objeto encontrar error. despliegue ocurre cuando presenta cliente incremento software, incluye entrega, apoyo retroalimentación. los principios clave para entrega consideran adminis-tración las expectativas del cliente darle información apoyo adecuada sobre software. apoyo demanda preparación anticipada. retroalimentación permite cliente sugerir cam-bios que tengan valor para negocio que brinden desarrollador información para ciclo iterativo siguiente ingeniería software. problemas puntos por evaluar .. toda vez que búsqueda calidad reclama recursos tiempo, ¿ posible ser ágil centrarse ella? .. los ocho principios fundamentales que guían proceso ( que estudió sección ..), ¿cuál cree que sea más importante?.. describa con sus propias palabras concepto separación entidades. .. principio comunicación importante establece que hay que “prepararse antes comunicarse”. ¿cómo debe manifestarse esta preparación los primeros trabajos que hacen? ¿qué productos del tra- bajo son resultado preparación temprana? .. haga algunas investigaciones acerca cómo “facilitar” actividad comunicación (use las referen- cias que dan otras distintas) prepare algunos lineamientos que centren facilitación... ¿ qué difiere comunicación ágil comunicación tradicional ingeniería software? ¿ qué parecen?.. ¿por qué necesario “avanzar”? .. investigue sobre “negociación” para actividad comunicación prepare algunos lineamientos que centren sólo ella... describa que significa granularidad contexto programación actividades proyecto. .. ¿por qué son importantes los modelos trabajo ingeniería software? ¿siempre son necesa- rios? ¿hay calificadores para respuesta que dio sobre esta necesidad?.. ¿cuáles son los tres “dominios” considerados durante modelado requerimientos? .. trate agregar principio adicional los que mencionan sección .. para codifica- ción... ¿qué una prueba exitosa? .. diga está acuerdo desacuerdo con enunciado siguiente: “como entregamos incrementos múltiples cliente, debiéramos preocuparnos por calidad los primeros incrementos; las iteracio- nes posteriores podemos corregir los problemas. explique respuesta. .. ¿por qué importante retroalimentación para equipo software? (-).indd (-).indd // ::// :: principios que guían práctica lecturas fuentes información adicionales comunicación con cliente una actividad importancia crítica ingeniería software, pero pocos sus practicantes dedican tiempo leer sobre ella. withall ( software requirements patterns, microsoft press, ) presenta varios patrones útiles que analizan problemas comunicación. sutliff ( user-centred requirements engineering, springer, ) centra mucho los retos relacionados con comunicación. los libros weigers (software requierements, . ., microsoft press, ), pardee ( satisfy and delight your customer, dorset house, ) karten [kar] analizan profundidad los métodos para tener una interacción eficaz con cliente. aunque libro centra software, hooks farry ( customer cen- tered products, american management association, ) presentan lineamientos generales útiles para comunicación con los clientes. young ( effective requirements practices , addison-wesley, ) pone énfa- sis “equipo conjunto” clientes desarrolladores que recaben los requerimientos colaboración. somerville kotonya ( requirements engineering: processes and techniques , wiley, ) analizan concepto “provocación” las técnicas otros requerimientos los principios ingeniería. los conceptos principios comunicación planeación son estudiados muchos libros admi- nistración proyectos. entre los más útiles encuentran los bechtold ( essentials software project management, . ., management concepts, ), wysocki ( effective project management: traditional, adap- tive, extreme, . ., wiley, ), leach (lean project management: eight principles for success, booksurge publishing, ) hughes ( software project management, mcgraw-hill, ) stellman greene (applied software project management, ’reilly media, inc., ). davis [dav] hizo una compilación excelente referencias sobre principios ingeniería soft- ware. además, virtualmente todo libro respecto contiene análisis útil los conceptos principios para análisis, diseño prueba. entre los más utilizados (además éste, claro) encuentran los siguientes: abran, ., . moore, swebok: guide the software engineering body knowledge , ieee, . christensen, ., . thayer, project manager’ guide software engineering best practices , ieee- press (wiley), . jalote, ., integrated approach software engineering, springer, . pfleeger, ., software engineering: theory and practice, . ., prentice-hall, . schach, ., object- oriented and classical software engineering , mcgraw-hill, . ., . sommerville, ., software engineering, . ., addison-wesley, estos libros también presentan análisis detallados sobre los principios modelado construcción. los principios modelado estudian muchos libros dedicados análisis requerimientos diseño software. los libros lieberman (the art software modeling, auerbach, ), rosenberg stephens (use case driven object modeling with uml: theory and practice, apress, ), roques ( uml practice, wiley, ) penker eriksson (business modeling with uml: business patterns work, wiley, ) analizan los principios métodos modelado. todo ingeniero software que trate hacer diseño está obligado leer texto norman ( the design everyday things, currency/doubleday, ). winograd sus colegas (bringing design software, addi- son-wesley, ) editaron una excelente colección ensayos sobre aspectos prácticos del diseño soft-ware. constantine lockwood (software for use, addison-wesley, ) presenta los conceptos asociados con “diseño centrado usuario”. tognazzini ( tog software design, addison-wesley, ) presenta una reflexión filosófica útil sobre naturaleza del diseño efecto que tienen las decisiones sobre calidad capacidad del equipo para producir software que agregue mucho valor para cliente. stahl sus cole-gas (model-driven software development: technology, engineering, wiley, ) estudian los principios del desarrollo determinado por modelo. son cientos los libros que abordan uno más elementos actividad construcción. kernighan plauger [ker] escribieron texto clásico sobre estilo programación, mcconell [mcc] presenta -neamientos prácticos para construcción software, bentley [ben] sugiere una amplia variedad perlas programación, knuth [knu] escribió una serie clásica tres volúmenes acerca del arte programar hunt [hun] sugiere lineamientos pragmáticos para programación. myers sus colegas (the art software testing , . ., wiley, ) desarrollaron una revisión importante texto clásico muchos principios importantes para realización pruebas. los libros perry ( effec- tive methods for software testing, . ., iley ), whittaker (how break software, addison-wesley, ), kaner sus colegas (lessons learned software testing , wiley, ) marick (the craft software testing, prentice-hall, ) presentan por separado conceptos principios importantes para hacer pruebas, así como muchas guías prácticas. (-).indd (-).indd // ::// :: parte dos modelado internet existe una amplia variedad fuentes información sobre práctica ingeniería soft- ware. sitio web del libro encuentra una lista actualizada referencias red mundial que son relevantes para ingeniería software: olc/ser.htm (-).indd (-).indd // ::// :: los requerimientos conceptos clave administración los requerimientos . . . . . . . . . . casos uso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . función calidad. . . . . . . . . . . . . . elaboración. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . los requerimientos . . . . . . . . . . ingeniería requerimientos . . . . . . . . . . modelo del análisis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . análisis . . . . . . del trabajo. . . . . . vista. . . . . . . . . . . . . . . . . . . . . . . . los requerimientos . . . . . . . . . . ¿qué ? antes comenzar cualquier tra- bajo técnico una buena idea aplicar conjunto tareas ingeniería los requeri-mientos. éstas llevarán comprensión cuál será efecto que tendrá software negocio, qué que quiere cliente cómo interactuarán los usuarios finales con software. ¿quién hace? los ingenieros software (que mundo las tecnologías información veces son lla-mados ingenieros sistemas analistas) todos los demás participantes del proyecto (gerentes, clientes usuarios) intervienen ingeniería requerimientos. ¿por qué importante? diseñar construir elegan- programa cómputo que resuelva problema equivo-cado satisface las necesidades nadie. por eso importante entender que cliente desea antes comenzar diseñar construir sistema basado computadora. ¿cuáles son los pasos? ingeniería requerimientos comienza con concepción, tarea que define alcance naturaleza del problema que resolver. segui- indagación, labor que ayuda los participantes definir que requiere. después sigue elaboración, donde refinan modifican los requerimientos básicos. cuando los participantes definen problema, tiene lugar una negociación: ¿cuáles son las prioridades, qué esencial, cuándo requiere? por último, especifica problema algún modo luego revisa valida para garantizar que hay coincidencia entre comprensión que usted tiene del problema que tienen los participantes. ¿cuál producto final? objetivo los requeri- mientos ingeniería proporcionar todas las partes entendimiento escrito del problema. esto logra por medio varios productos del trabajo: escenarios uso, listas funciones características, modelos reque-rimientos especificaciones. ¿cómo aseguro que hice bien? revisan con los participantes los productos del trabajo inge-niería requerimientos fin asegurar que que aprendió que ellos quieren decir realidad. aquí cabe una advertencia: las cosas cambiarán aun después que todas las partes estén acuerdo, seguirán cam-biando durante todo proyecto. una mirada rápidaentender los requerimientos problema una las tareas más difíciles que enfrenta ingeniero software. cuando piensa por primera vez, parece tan difícil desarro-llar entendimiento claro los requerimientos. después todo, ¿acaso sabe cliente que necesita? ¿ deberían tener los usuarios finales una buena comprensión las características funciones que darán beneficio? sorprendentemente, muchas ins-tancias respuesta estas preguntas “”. incluso los clientes los usuarios finales explican sus necesidades, éstas cambiarán mientras desarrolla proyecto. prólogo libro escrito por ralph young [you] sobre las prácticas eficaces respecto los requerimientos, escribí siguiente: peor las pesadillas. cliente entra oficina, toma asiento, mira uno fijamente los ojos dice: “ que cree que entiende que digo, pero que usted entiende que que digo que quiero decir.” invariablemente, esto pasa cuando está avanzado proyecto, después que han hecho compromisos con los plazos entrega, que hay reputaciones juego mucho dinero invertido. todos los que hemos trabajado negocio los sistemas del software durante algunos años hemos vivido pesadilla descrita, pero pocos hemos aprendido escapar. batallamos cuando trata-mos obtener los requerimientos nuestros clientes. tenemos problemas para entender infor-mación que obtenemos. frecuente que registremos los requerimientos manera desorganizada que dediquemos muy poco tiempo verificar que registramos. dejamos que cambio nos controle lugar establecer mecanismos para controlarlo . pocas palabras, fallamos establecer fundamento sólido para sistema software. cada uno los problemas difícil. cuando com-binan, panorama atemorizador aun para los gerentes profesionales más experimentados. pero hay solución. (-).indd (-).indd // ::// :: parte dos modelado razonable afirmar que las técnicas que estudiarán este capítulo son una “solu- ción” verdadera para los retos que mencionaron, pero proveen enfoque sólido para enfrentarlos. . ingeniería requerimientos diseño construcción software computadora difícil, creativo sencillamente diver-tido. realidad, elaborar software tan atractivo que muchos desarrolladores software quieren directo antes haber tenido entendimiento claro que necesita. argu-mentan que las cosas aclararán medida que elaboren, que los participantes proyecto podrán comprender sus necesidades sólo después estudiar las primeras iteraciones del soft-ware, que las cosas cambian tan rápido que cualquier intento entender los requerimientos detalle una pérdida tiempo, que las utilidades salen producción programa que funcione que todo demás secundario. que hace que estos argumentos sean tan seductores que tienen algunos elementos verdad. pero todos son erróneos pueden llevar proyecto software fracaso. espectro amplio tareas técnicas que llevan entender los requerimientos denomina ingeniería requerimientos. desde perspectiva del proceso del software, ingeniería -querimientos una las acciones importantes ingeniería software que comienza durante actividad comunicación continúa modelado. debe adaptarse las -cesidades del proceso, del proyecto, del producto las personas que hacen trabajo. ingeniería requerimientos tiende puente para diseño construcción. pero, ¿dónde origina puente? podría argumentarse que principia los pies los participantes proyecto (por ejemplo, gerentes, clientes usuarios), donde definen las necesidades del negocio, describen los escenarios uso, delinean las funciones características identifican las restricciones del proyecto. otros tal vez sugieran que empieza con una definición más amplia del sistema, donde software más que componente del dominio del sis-tema mayor. pero sin importar punto arranque, recorrido por puente lleva uno muy alto sobre proyecto, que permite examinar contexto del trabajo software que debe realizarse; las necesidades específicas que deben abordar diseño construcción; las prioridades que guían orden que efectúa trabajo, información, las funciones los comportamientos que tendrán profundo efecto diseño resultante. ingeniería requerimientos proporciona mecanismo apropiado para entender que desea cliente, analizar las necesidades, evaluar factibilidad, negociar una solución razona-ble, especificar solución sin ambigüedades, validar especificación administrar los reque-rimientos medida que transforman sistema funcional [tha]. incluye siete tareas diferentes: concepción, indagación, elaboración, negociación, especificación, validación -ministración. importante notar que algunas estas tareas ocurren paralelo que todas adaptan las necesidades del proyecto. concepción. ¿cómo inicia proyecto software? ¿existe solo evento que con vierte catalizador nuevo sistema producto basado computadora necesidad evo-luciona tiempo? hay respuestas definitivas estas preguntas. ciertos casos, una conversación casual todo que necesita para desencadenar trabajo grande inge-niería software. pero general, mayor parte proyectos comienzan cuando identifica una necesidad del negocio descubre nuevo mercado servicio potencial. los partici- esto cierto particular para los proyectos pequeños (menos mes) muy pequeños, que requieren - lativamente poco esfuerzo software sencillo. medida que software crece tamaño complejidad, estos argumentos comienzan ser falsos.cita: “ parte más difícil construir sistema software deci-dir qué construir. ninguna parte del trabajo invalida tanto sis-tema resultante ésta hace mal. nada más difícil corregir después.” fred brooks punto clave ingeniería requerimientos establece una base sólida para diseño construcción. sin ésta, software resultante tiene alta probabilidad satisfacer las necesidades del cliente. cita: “las semillas los desastres enormes del software por general vislumbran los tres primeros meses del inicio del proyecto.” coper jonesespere hacer poco diseño recabar los requerimientos, poco requerimientos durante trabajo diseño.consejo (-).indd (-).indd // ::// :: comprensión los requerimientos pantes comunidad del negocio (por ejemplo, los directivos, personal mercadotecnia, gerentes producto, etc.) definen caso negocios para idea, tratan identificar ritmo profundidad del mercado, hacen análisis gran visión factibilidad identifican una descripción funcional del alcance del proyecto. toda esta información está sujeta cambio, pero suficiente para desencadenar análisis con organización ingeniería software. concepción del proyecto, establece entendimiento básico del problema, las per- sonas que quieren una solución, naturaleza solución que desea, así como eficacia comunicación colaboración preliminares entre los otros participantes equipo software. indagación. verdad que parece muy simple: preguntar cliente , los usuarios otras personas cuáles son los objetivos para sistema producto, qué que lograrse, cómo ajusta sistema producto las necesidades del negocio , finalmente, cómo usarse sistema producto las operaciones cotidianas. pero simple: muy difícil. christel kang [cri] identificaron cierto número problemas que encuentran cuando ocurre indagación: • problemas alcance. frontera los sistemas está mal definida los clientes usuarios finales especifican detalles técnicos innecesarios que confunden, más que clari-fican, los objetivos generales del sistema. • problemas entendimiento. los clientes usuarios están completamente seguros que necesita, comprenden mal las capacidades limitaciones ambiente computación, entienden todo dominio del problema, tienen problemas para comunicar las necesidades ingeniero sistemas, omiten información que creen que “obvia”, especifican requerimientos que están conflicto con las necesidades otros clientes usuarios, solicitan requerimientos ambiguos que pueden someterse prueba. • problemas volatilidad. los requerimientos cambian con tiempo. para superar estos problemas, debe enfocarse obtención requerimientos forma organi-zada. elaboración. información obtenida del cliente durante concepción indagación - pande refina durante elaboración. esta tarea centra desarrollar modelo refinado los requerimientos (véanse los capítulos ) que identifique distintos aspectos función del software , comportamiento información. elaboración está motivada por creación mejora escenarios usuario que descri- ban cómo interactuará usuario final ( otros actores) con sistema. cada escenario usua-rio enuncia con sintaxis apropiada para extraer clases análisis, que son entidades del dominio del negocio visibles para usuario final. definen los atributos cada clase análisis identifican los servicios que requiere cada una ellas. identifican las relaciones colaboración entre clases, producen varios diagramas adicionales. negociación. raro que los clientes usuarios pidan más que puede lograrse dado limitado los recursos del negocio. ambién relativamente común que distintos clientes desarrollarse sistema basado computadora, los análisis comienzan contexto proceso ingeniería sistemas. para más detalles ingeniería sistemas, visite sitio web esta obra. recuerde que proceso unificado (véase capítulo ) define una “fase concepción” más amplia que incluye las fases concepción, indagación elaboración, que son estudiadas dicho capítulo. servicio manipula los datos agrupados por clase. también utilizan los términos operación método. está familiarizado con conceptos orientación objetos, consulte apéndice , que presenta una introducción básica. elaboración algo bueno, pero hay que saber cuándo detenerse. clave describir problema forma que establezca una base firme para diseño. trabaja más allá este punto, está haciendo diseño.consejo¿por qué difícil llegar entendimiento claro que quiere cliente?? (-).indd (-).indd // ::// :: parte dos modelado usuarios propongan requerimientos conflictivos con argumento que versión “esen- cial para nuestras necesidades especiales”. estos conflictos deben reconciliarse por medio proceso negociación. pide clien- tes, usuarios otros participantes que ordenen sus requerimientos según prioridad que después analicen los conflictos. con empleo enfoque iterativo que prioridad los requerimientos, evalúa costo riesgo, enfrentan los conflictos internos; algunos -querimientos eliminan, combinan modifican modo que cada parte logre cierto grado satisfacción. especificación. contexto los sistemas basados computadora ( software), tér- mino especificación tiene diferentes significados para distintas personas. una especificación puede ser documento escrito, conjunto modelos gráficos, modelo matemático for- mal, conjunto escenarios uso, prototipo cualquier combinación éstos. algunos sugieren que para una especificación debe desarrollarse utilizarse una “plantilla estándar” [som], con argumento que esto conduce requerimientos presentados forma consistente por ello más comprensible. sin embargo, ocasiones necesario ser flexible cuando desarrolla una especificación. para sistemas grandes, mejor enfoque puede ser documento escrito que combine descripciones lenguaje natural con modelos grá-ficos. obstante , para productos sistemas pequeños que residan ambientes bien enten- didos, quizá todo que requiera sea escenarios uso.punto clave formalidad formato una especificación varían con tamaño complejidad del software que construir. una especificación requerimientos software (ers) documento que crea cuando debe especificarse una descripción detallada todos los aspectos del software que elaborar, antes que proyecto comience. importante notar que una ers formal siempre está forma escrita. realidad, hay muchas circunstancias las que esfuerzo dedicado ers esta-ría mejor aprovechado otras actividades ingeniería soft-ware. sin embargo, justifica ers cuando software ser desarrollado por una tercera parte, cuando falta una especifica-ción crearía problemas severos negocio, sistema complejo extremo trata negocio importancia crítica. karl wiegers [wie], empresa process impact inc., desa- rrolló formato útil (disponible que sirve como guía para aquellos que deben crear una ers completa. contenido normal siguiente: tabla contenido revisión historia . introducción. propósito. convenciones del documento. audiencia objetivo sugerencias lectura. alcance del proyecto. referencias . descripción general . perspectiva del producto. características del producto. clases características del usuario. ambiente operación. restricciones diseño implementación. documentación para usuario. suposiciones dependencias . características del sistema . característica del sistema. característica del sistema ( así sucesivamente) . requerimientos interfaz externa . interfaces usuario. interfaces del hardware. interfaces del software. interfaces las comunicaciones . otros requerimientos funcionales . requerimientos desempeño. requerimientos seguridad. requerimientos estabilidad. atributos calidad del software . otros requerimientosapéndice : glosario apéndice : modelos análisisapéndice : lista conceptos puede obtenerse una descripción detallada cada ers descar- formato desde url mencionada antes.información formato especificación requerimientos softwareen una negociación eficaz debe haber ganador perdedor. ambos lados ganan porque “trato” con que ambas partes pueden vivir algo sólido.consejo (-).indd (-).indd // ::// :: comprensión los requerimientos validación. calidad los productos del trabajo que generan como consecuencia ingeniería los requerimientos evalúa durante paso validación. validación los requerimientos analiza especificación fin garantizar que todos ellos han sido enuncia- dos sin ambigüedades; que detectaron corrigieron las inconsistencias, las omisiones los errores, que los productos del trabajo presentan conforme los estándares estableci-dos para proceso, proyecto producto. mecanismo principal validación los requerimientos revisión técnica (véase capítulo ). equipo revisión que los valida incluye ingenieros software, clientes, usua-rios otros participantes, que analizan especificación busca errores contenido interpretación, aspectos los que tal vez requiera hacer aclaraciones, falta informa-ción, inconsistencias (problema notable cuando hace ingeniería productos sistemas grandes) requerimientos conflicto irreales ( asequibles). recuerde que naturaleza especificación variará con cada proyecto. ciertos casos, “especificación” más que conjunto escenarios usuario. otros, especificación tal vez sea documento que contiene escenarios, modelos descripciones escritas. administración formal los requerimientos sólo practica para proyectos grandes que tienen cientos requerimientos identificables. para proyectos pequeños, esta actividad tiene considerablemente menos for-malidad. aspecto clave durante validación los requerimientos consistencia. utilice modelo análisis para asegurar que los requerimientos han enunciado manera consistente.consejo lista verificación para validar requerimientos con frecuencia útil analizar cada requerimiento comparación con preguntas verificación. continuación pre- sentan algunas: • ¿los requerimientos están enunciados con claridad? ¿podrían inter- pretarse mal? • ¿está identificada fuente del requerimiento (por ejemplo, una per- sona, reglamento documento)? ¿ estudiado planteamiento final del requerimiento comparación con fuente original? • ¿ requerimiento está acotado términos cuantitativos? • ¿qué otros requerimientos relacionan con éste? ¿están compa- rados con claridad por medio una matriz referencia cruzada otro mecanismo?• ¿ requerimiento viola algunas restricciones del dominio? • ¿puede someterse prueba requerimiento? así, ¿ posible especificar las pruebas ( ocasiones denominan criterios validación) para ensayar requerimiento? • ¿puede rastrearse requerimiento hasta cualquier modelo del sis- tema que haya creado? • ¿ posible seguir requerimiento hasta los objetivos del sistema producto? • ¿ especificación está estructurada forma que lleva entender- con facilidad, con referencias traducción fáciles productos del trabajo más técnicos? • ¿ creado índice para especificación? • ¿están enunciadas con claridad las asociaciones los requeri- mientos con las características rendimiento, comportamiento operación? ¿cuáles requerimientos parecen ser implícitos?información administración los requerimientos. los requerimientos para sistemas basados computadora cambian, deseo modificarlos persiste durante toda vida del sistema. administración los requerimientos conjunto actividades que ayudan equipo del proyecto identificar, controlar dar seguimiento los requerimientos sus cambios cualquier momento del desarrollo del proyecto. muchas estas actividades son idénticas las técnicas administración configuración del software (tas) que estudian capítulo . (-).indd (-).indd // ::// :: parte dos modelado . establecer las bases caso ideal, los participantes ingenieros software trabajan juntos mismo equipo. esas condiciones, ingeniería requerimientos tan sólo consiste sostener conversacio- nes significativas con colegas que sean miembros bien conocidos del equipo. pero frecuente que realidad esto sea muy diferente. los clientes usuarios finales tal vez encuentren ciudades países diferentes, quizá sólo tengan una idea vaga que requiere, puede ser que tengan opiniones conflicto sobre sistema que elaborar, que posean conocimiento técnico limitado que dis-pongan poco tiempo para interactuar con ingeniero que recabará los requerimientos. ninguna estas posibilidades deseable, pero todas son muy comunes frecuente verse forzado trabajar con las restricciones impuestas por esta situación. las secciones que siguen estudian las etapas requeridas para establecer las bases que permiten entender los requerimientos software fin que proyecto comience forma tal que mantenga avanzando hacia una solución exitosa. .. identificación los participantes sommerville sawyer [som] definen participante como “cualquier persona que beneficie forma directa indirecta del sistema desarrollo”. identificaron los candidatos habi-tuales: gerentes operaciones del negocio, gerentes producto, personal mercadotecnia, clientes internos externos, usuarios finales, consultores, ingenieros producto, ingenieros software ingenieros apoyo mantenimiento, entre otros. cada participante tiene punto vista diferente respecto del sistema, obtiene distintos beneficios cuando éste desarrolla con éxito corre distintos riesgos fracasa esfuerzo construcción. las herramientas mencionadas aquí son obligatorias sino una muestra las que hay esta categoría. mayoría casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores. este enfoque ampliamente recomendable para proyectos que adoptan filosofía desarrollo soft- ware ágil.objetivo: las herramientas ingeniería los reque- rimientos ayudan reunir éstos, modelarlos, administrar- los validarlos. mecánica: mecánica las herramientas varía. general, éstas elaboran varios modelos gráficos (por ejemplo, uml) que ilustran los aspectos información, función comportamiento sistema. estos modelos constituyen base todas las demás actividades del proceso software. herramientas representativas: sitio volere requirements, htm, encuentra una lista razonablemente amplia ( actualizada) herramientas para ingeniería requerimientos. los capítulos estudian las herramientas que sirven para modelar aquéllos. las que mencionan continuación centran administración.easyrm, desarrollada por cybernetic intelligence gmbh (www. easy-.com), construye diccionario/glosario especial para proyectos, que contiene descripciones atributos detallados los requerimientos. rational requisitepro, elaborada por rational software (www-. ibm.com/software/awdtools/reqpro/), permite los usuarios construir una base datos requerimientos, represen-tar relaciones entre ellos organizarlos, indicar prioridad rastrearlos. sitio volere mencionado, encuentran muchas herra-mientas adicionales para administrar requerimientos, así como dirección software ingeniería requerimientos punto clave participante cualquier persona que tenga interés directo que beneficie del sistema que desarrollar. (-).indd (-).indd // ::// :: comprensión los requerimientos durante concepción, debe hacerse lista personas que harán aportes cuando reca- ben los requerimientos (véase sección .). lista inicial crecerá cuando haga contac- con los participantes porque cada uno hará pregunta: “¿ quién más piensa que debe consultarse?” .. reconocer los múltiples puntos vista debido que existen muchos participantes distintos, los requerimientos del sistema explora-rán desde muchos puntos vista diferentes. por ejemplo, grupo mercadotecnia inte-resa funciones características que estimularán mercado potencial, que hará que nuevo sistema sea fácil vender. los gerentes del negocio tienen interés conjunto características para que elabore dentro del presupuesto que esté listo para ocupar nichos mercado definidos. los usuarios finales tal vez quieran características que les resulten fami-liares que sean fáciles aprender usar. los ingenieros software quizá piensen fun-ciones invisibles para los participantes sin formación técnica, pero que permitan una infraes-tructura que apoyo funciones características más vendibles. los ingenieros apoyo tal vez centren facilidad del software para recibir mantenimiento. cada uno estos integrantes ( otros más) aportará información proceso ingeniería los requerimientos. medida que recaba información procedente múltiples puntos vista, los requerimientos que surjan tal vez sean inconsistentes estén conflicto uno con otro. debe clasificarse toda información los participantes (incluso los requerimientos -consistentes conflictivos) forma que permita quienes toman las decisiones escoger para sistema conjunto requerimientos que tenga coherencia interna. .. trabajar hacia colaboración proyecto software hay involucrados cinco participantes, tal vez tengan cinco ( más) diferentes opiniones acerca del conjunto apropiado requerimientos. los primeros capítulos mencionó que, para obtener sistema exitoso, los clientes ( otros participantes) debían colaborar entre (sin pelear por insignificancias) con los profesionales ingeniería software. pero, ¿cómo llega esta colaboración? trabajo del ingeniero requerimientos identificar las áreas interés común (por ejem- plo, requerimientos los que todos los participantes estén acuerdo) las conflicto -congruencia (por ejemplo, requerimientos que desea participante, pero que están con-flicto con las necesidades otro). última categoría que, por supuesto, representa reto.cita: “ponga tres participantes cuarto pregúnteles qué clase sistema quieren. pro-bable que escuche cuatro más opiniones diferentes.” anónimo colaboración significa necesariamente que todos los requerimientos los defina - mité. muchos casos, los participantes colaboran con aportación punto vista res- pecto los requerimientos, pero influyente “campeón del proyecto” (por ejemplo, director una manera resolver requerimientos conflictivos , mismo tiempo, mejorar comprensión importancia relativa todos, usar esquema “votación” con base pun- tos prioridad. todos los participantes cierto número puntos prioridad que pueden “gastarse” cualquier número requerimientos. presenta una lista éstos cada participante indica importancia relativa cada uno (desde punto vista) con asignación uno más puntos prioridad. los puntos gas-tados pueden utilizarse otra vez. cuando participante agota sus puntos prioridad, tiene posibilidad hacer algo con los requerimientos. total puntos asignados cada requerimiento por los participantes una indicación importancia general cada requerimiento.información uso “puntos prioridad” (-).indd (-).indd // ::// :: parte dos modelado del negocio tecnólogo experimentado) toma decisión final sobre los requerimientos que integrarán. .. hacer las primeras preguntas las preguntas que hacen concepción del proyecto deben estar “libres del contexto” [gau]. primer conjunto ellas centran cliente otros participantes, las -tas beneficios generales. por ejemplo, tal vez pregunte: • ¿quién está detrás solicitud este trabajo? • ¿quién usará solución? • ¿cuál será beneficio económico una solución exitosa? • ¿hay otro origen para solución que necesita? estas preguntas ayudan identificar todos los participantes con interés software que elaborar. además, las preguntas identifican beneficio mensurable una implementa-ción exitosa las posibles alternativas para desarrollo software personalizado. las preguntas siguientes permiten entender mejor problema hacen que cliente exprese sus percepciones respecto solución: • ¿cuál sería una “buena” salida generada por una solución exitosa? • ¿qué problemas resolvería esta solución? • ¿puede mostrar ( describir) ambiente negocios que usaría solución? • ¿hay aspectos especiales del desempeño restricciones que afecten modo que enfoque solución? las preguntas finales centran eficacia actividad comunicación . gause weinberg [gau] las llaman “metapreguntas” proponen siguiente lista (abreviada): • ¿ usted persona indicada para responder estas preguntas? ¿sus respuestas son “oficiales”? • ¿mis preguntas son relevantes para problema que tiene? • ¿estoy haciendo demasiadas preguntas? • ¿puede otra persona dar información adicional? • ¿debería preguntarle algo más? estas preguntas ( otras) ayudarán “romper hielo” iniciar comunicación, que esen-cial para una indagación exitosa. pero una reunión preguntas respuestas enfoque que haya tenido éxito apabullante. realidad, sesión preguntas respuestas sólo debe usarse para primer encuentro luego ser reemplazada por formato indagación -querimientos que combine elementos solución problemas, negociación especificación. sección . presenta enfoque este tipo. . indagación los requerimientos indagación los requerimientos (actividad también llamada recabación los requerimien-tos) combina elementos solución problemas, elaboración, negociación especificación. fin estimular enfoque colaborativo orientado equipo, los participantes trabajan juntos para identificar problema, proponer elementos solución, negociar distintas visio-nes especificar conjunto preliminar requerimientos para solución [zah]. : “ mejor conocer algunas pre- guntas que todas las respuestas.” james thurber ¿cuáles preguntas ayudarían tener entendimiento preliminar del problema?? cita: “ que hace una pregunta tonto durante cinco minutos; que hace será tonto para siempre.” proverbio chino ocasiones denomina este enfoque técnica facilitada especificación aplicación (tfea). (-).indd (-).indd // ::// :: comprensión los requerimientos .. recabación los requerimientos forma colaborativa han propuesto muchos enfoques distintos para recabar los requerimientos forma colabo- rativa. cada uno utiliza escenario poco diferente, pero todos son variantes los siguien-tes lineamientos básicos: • tanto ingenieros software como otros participantes dirigen intervienen las reuniones. • establecen reglas para preparación participación. • sugiere una agenda con suficiente formalidad para cubrir todos los puntos impor-tantes, pero con suficiente informalidad para que estimule libre flujo ideas. • “facilitador” (cliente, desarrollador participante externo) controla reunión. • utiliza “mecanismo definición” (que pueden ser hojas trabajo, tablas sueltas, etiquetas adhesivas, pizarrón electrónico, grupos conversación foro virtual). meta identificar problema, proponer elementos solución, negociar distintos enfoques especificar conjunto preliminar requerimientos solución una atmós-fera que favorezca logro meta. para entender mejor flujo eventos conforme ocu-rren, presenta escenario breve que bosqueja secuencia hechos que llevan -unión para obtener requerimientos, que sucede durante ésta que sigue después ella. durante concepción (véase sección .), hay preguntas respuestas básicas que esta- blecen alcance del problema percepción general que constituye una solución. fuera estas reuniones iniciales, desarrollador los clientes escriben una dos páginas “soli-citud producto”. selecciona lugar, fecha hora para reunión, escoge facilitador invita asistir integrantes del equipo software otras organizaciones participantes. antes fecha reunión, distribuye solicitud producto todos los asistentes. por ejemplo, considere extracto una solicitud producto escrita por una persona mercadotecnia involucrada proyecto casasegura. esta persona escribe siguiente narra- ción sobre función seguridad hogar que ser parte casasegura: nuestras investigaciones indican que mercado para los sistemas administración del hogar crece razón % anual. primera función casasegura que llevemos mercado deberá ser seguridad del hogar. mayoría gente está familiarizada con “sistemas alarma”, por que ésta deberá ser fácil vender. función seguridad del hogar protegería, reconocería, varias “situaciones” indeseables, como acceso ilegal, incendio niveles monóxido carbono, entre otros. emplearía sensores ina-lámbricos para detectar cada situación. sería programada por propietario telefonearía forma automática una agencia vigilancia cuando detectara una situación como las descritas. realidad, durante reunión para recabar los requerimientos, otros contribuirían esta narración dispondría mucha más información. pero aun con ésta habría ambigüedad, sería probable que existieran omisiones ocurrieran errores. por ahora bastará “descripción funcional” anterior. mientras revisa solicitud del producto antes reunión, pide cada asistente que elabore una lista objetos que sean parte del ambiente que rodeará sistema, los objetos ¿cuáles son los lineamientos básicos para conducir una reunión fin recabar los requerimientos forma colaborativa?? este ejemplo (con extensiones variantes) usa para ilustrar métodos importantes ingeniería software muchos los capítulos siguientes. como ejercicio, sería provechoso que lector realizara propia reunión para recabar requerimientos que desarrollara conjunto listas para ella.cita: “dedicamos mucho tiempo — mayor parte todo esfuerzo del proyecto— implemen-tar hacer pruebas, sino tratar decidir qué construir.” brian lawrence webref solicitud conjunta desarrollo (scd) una técnica popular para recabar requerimientos. dirección encuentra una buena descripción ella. sistema producto servirá muchos usuarios, asegúrese que los requerimientos obtengan una franja representativa ellos. sólo uno define todos los requerimientos, riesgo aceptación elevado.consejo (-).indd (-).indd // ::// :: parte dos modelado que producirá éste los que usará para realizar sus funciones. además, solicita cada asis- tente que haga otra lista servicios (procesos funciones) que manipulen interactúen con los objetos. por último, también desarrollan listas restricciones (por ejemplo, costo, -maño, reglas del negocio, etc.) criterios desempeño (como velocidad exactitud). -forma los asistentes que espera que las listas sean exhaustivas, pero que reflejen percepción que cada persona tiene del sistema. entre los objetos descritos por casasegura tal vez estén incluidos panel control, detec- tores humo, sensores ventanas puertas, detectores movimiento, alarma, evento (activación sensor), una pantalla, una computadora, números telefónicos, una llamada telefónica, etc. lista servicios puede incluir configurar sistema, preparar alarma, vigilar los sensores, marcar teléfono, programar panel control leer pantalla (observe que los servicios actúan sobre los objetos). forma similar, cada asistente desarrollará una lista restricciones (por ejemplo, sistema debe reconocer cuando los sensores estén operando, debe ser amistoso con usuario, debe tener una interfaz directa con una línea telefónica están-dar, etc.) criterios desempeño ( evento sensor debe reconocerse antes segundo, debe implementarse esquema prioridad eventos, etcétera). las listas objetos pueden adherirse las paredes del cuarto con empleo pliegos papel grandes con láminas adhesivas, escribirse tablero. alternativamente, las listas podrían plasmarse boletín electrónico, sitio web interno ambiente grupo conversación para revisarlas antes reunión. ideal que cada entrada las listas pueda manipularse por separado fin combinar las listas modificar las entradas agregar otras. esta etapa, están estrictamente prohibidos las críticas debate. una vez que presentan las listas individuales acerca área temática, grupo crea una lista, eliminando las entradas redundantes agregando ideas nuevas que surjan durante análisis, pero elimina ninguna. después crear listas combinadas para todas las áreas temáticas, sigue análisis, coordinado por facilitador. lista combinada acorta, alarga modifica redacción para que refleje manera apropiada producto sistema que desarrollar. objetivo llegar consenso sobre lista objetos, servicios, restric-ciones desempeño del sistema que construir. muchos casos, objeto servicio descrito lista requerirá mayores explicaciones. para lograr esto, los participantes desarrollan miniespecificaciones para las entradas las lis- tas. cada miniespecificación una elaboración objeto servicio. por ejemplo, corres- pondiente objeto panel control casasegura sería así: panel control una unidad montada muro, sus dimensiones aproximadas son por pulgadas. tiene conectividad inalámbrica con los sensores con una . interacción con usuario tiene lugar por medio tablero que contiene teclas. una pantalla cristal líquido por pulgadas brinda retroalimentación usuario. software hace anuncios interactivos, como eco funciones similares. las miniespecificaciones presentan todos los participantes para que sean analizadas. hacen adiciones, eliminaciones otras modificaciones. ciertos casos, desarrollo las miniespecificaciones descubrirá nuevos objetos, servicios restricciones, requerimientos desempeño que agregarán las listas originales. durante todos los análisis, equipo debe posponer los aspectos que puedan resolverse reunión. conserva una lista aspectos para volver después dichas ideas.cita: “los hechos dejan existir porque les ignore.” aldous huxley evite impulso desechar alguna idea cliente con expresiones como “demasiado costosa” “impráctica”. intención aquí negociar una lista aceptable para todos. para lograrlo, debe tenerse mente abierta.consejo vez crear una miniespecificación, muchos equipos software eligen desarrollar escenarios del usuario llamados casos uso. éstos estudian detalle sección . capítulo . (-).indd (-).indd // ::// :: comprensión los requerimientos .. despliegue función calidad despliegue función calidad (dfc) una técnica administración calidad que traduce las necesidades del cliente requerimientos técnicos para software. dfc “ con- centra maximizar satisfacción del cliente partir del proceso ingeniería del software” [zul]. para lograr esto, dfc pone énfasis entender que resulta valioso para cliente luego despliega dichos valores todo proceso ingeniería. dfc identifica tres tipos requerimientos [zul]: requerimientos normales. objetivos metas que establecen para producto sis- tema durante las reuniones con cliente. estos requerimientos están presentes, cliente queda satisfecho. ejemplos requerimientos normales son los tipos gráficos -didos para aparecer pantalla, funciones específicas del sistema niveles rendi-miento definidos. requerimientos esperados. están implícitos producto sistema quizá sean tan importantes que cliente los mencione manera explícita. ausencia causará - cha insatisfacción. algunos ejemplos requerimientos esperados son: fácil interacción humano/máquina, operación general correcta confiable, facilidad para instalar soft-ware. requerimientos emocionantes. estas características van más allá las expectativas del cliente son muy satisfactorias están presentes. por ejemplo, software para nuevo teléfono móvil viene con características estándar, pero incluye capacidades ines-peradas (como pantalla sensible tacto, correo voz visual, etc.) agrada todos los usuarios del producto. aunque los conceptos del dfc son aplicables todo proceso del software [par], hay téc-nicas específicas aquél que pueden aplicarse actividad indagación los requerimien-tos. dfc utiliza entrevistas con los clientes, observación, encuestas estudio datos histó-ricos (por ejemplo, reportes problemas) como materia prima para actividad recabación escena: sala juntas. está marcha pri- mera reunión para recabar los requerimientos. participantes: jamie lazar, integrante del equipo software; vinod raman, miembro del equipo software; robbins, miem-bro del equipo software; doug miller, gerente ingeniería software; tres trabajadores mercadotecnia; representante ingeniería del producto, facilitador. conversación:facilitador (apunta pizarrón): modo que ésa lista actual objetos servicios para función seguridad del hogar. persona mercadotecnia: eso cubre, desde nuestro punto vista. vinod: ¿ dijo alguien que quería que toda funcionalidad casasegura fuera accesible desde internet? eso incluiría función seguridad, ¿ ? persona mercadotecnia: , así … tendremos que añadir esa funcionalidad los objetos apropiados.facilitador: ¿agrega eso algunas restricciones? jamie: , tanto técnicas como legales.representante del producto: ¿qué significa eso?jamie: nos tendríamos que asegurar que extraño pueda ingresar sistema, desactivarlo robar lugar hacer algo peor. mucha responsabilidad sobre nosotros. doug: muy cierto.mercadotecnia: pero necesitamos así… sólo asegúrense impedir que ingrese extraño. : eso más fácil decir que hacer.facilitador (interrumpe): quiero que debatamos esto ahora. anotémoslo como aspecto continuemos. (doug, que secretario reunión, toma debida nota.)facilitador: tengo sensación que hay más por considerar aquí. ( grupo dedica los siguientes minutos mejorar aumentar los detalles función seguridad del hogar.)casasegura conducción una reunión para recabar los requerimientos punto clave dfc define los requerimientos forma que maximicen satisfacción del cliente. todos desean implementar muchos requerimientos emocionantes, pero hay que tener cuidado. así como empiezan “quedar lisiados los requerimientos”. pero contrapartida, los requerimientos emocionantes llevan avance enorme del producto…consejo webref dirección encuentra información útil sobre dfc. (-).indd (-).indd // ::// :: parte dos modelado los requerimientos. después, estos datos llevan una tabla requerimientos —llamada tabla voz del cliente— que revisa con cliente con otros participantes. luego -plean varios diagramas, matrices métodos evaluación para extraer los requerimientos -perados tratar percibir requerimientos emocionantes [aka]. .. escenarios uso medida que reúnen los requerimientos, comienza materializarse visión general funciones características del sistema. sin embargo, difícil avanzar hacia actividades más técnicas ingeniería software hasta entender cómo emplearán los usuarios finales dichas funciones características. para lograr esto, los desarrolladores usuarios crean conjunto escenarios que identifican naturaleza los usos para sistema que construir. los escenarios, que menudo llaman casos uso [jac], proporcionan des-cripción manera que utilizará sistema. los casos uso estudian con más detalle sección .. escena: una sala juntas, donde continúa primera reunión para recabar los requerimientos. participantes: jamie lazar, integrante del equipo software; vinod raman, miembro del equipo software; robbins, miem-bro del equipo software; doug miller, gerente ingeniería software; tres personas mercadotecnia; representante inge-niería del producto, facilitador. conversación:facilitador: hemos estado hablando sobre seguridad para acceso funcionalidad casasegura ser posible ingreso por internet. gustaría probar algo. desarrollemos escenario uso para entrar función seguridad. jamie: ¿cómo?facilitador: podríamos hacerlo dos maneras, pero momento mantengamos las cosas informales. díganos (señala una persona mercadotecnia), ¿cómo visualiza acceso sistema? persona mercadotecnia: … bueno, clase cosa que haría estuviera fuera casa tuviera que dejar entrar alguien ella —por ejemplo, una trabajadora doméstica técni- reparaciones— que tuviera código seguridad. facilitador (sonríe): ésa razón por que hace… díga- , ¿cómo haría realidad? persona mercadotecnia: bueno… primero que necesita- ría sería una . entraría sitio web que mantendríamos para todos los usuarios casasegura. daría identificación usuario …vinod (interrumpe): página web tendría que ser segura, encriptada, para garantizar que estuviéramos seguros … facilitador (interrumpe): ésa buena información, vinod, pero técnica. centrémonos cómo emplearía usuario final esta capacidad, ¿está bien? vinod: hay problema.persona mercadotecnia: decía que entraría sitio web daría identificación usuario dos niveles clave. jamie: ¿qué pasa olvido clave?facilitador (interrumpe): buena observación, jamie, pero entraremos ella por ahora. anotaremos llamaremos una excepción. estoy seguro que habrá otras. persona mercadotecnia: después que introdujera las claves, aparecería una pantalla que representaría todas las funcio-nes casasegura. seleccionaría función seguridad del hogar. sistema pediría que verificara quién soy, pidiendo dirección número telefónico algo así. entonces aparecería dibujo del panel control del sistema seguridad lista funciones que puede realizar —activar sistema, desactivar sistema desacti-var uno más sensores—. supongo que también permitiría reconfigurar las zonas seguridad otras cosas como ésa, pero estoy seguro. (mientras persona mercadotecnia habla, doug toma muchas notas; esto forma base para primer escenario informal uso. alternativamente, hubiera podido pedirse persona mercado-tecnia que escribiera escenario, pero esto hubiera hecho fuera reunión.)casasegura desarrollo escenario preliminar uso .. indagación los productos del trabajo los productos del trabajo generados como consecuencia indagación los requerimientos variarán función del tamaño del sistema producto que construir. para mayoría sistemas, los productos del trabajo incluyen los siguientes: (-).indd (-).indd // ::// :: comprensión los requerimientos • enunciado necesidad factibilidad. • enunciado acotado del alcance del sistema producto. • una lista clientes, usuarios otros participantes que intervienen indagación los requerimientos. • una descripción del ambiente técnico del sistema. • una lista requerimientos ( preferencia organizados por función) las restricciones del dominio que aplican cada uno. • conjunto escenarios uso que dan perspectiva uso del sistema producto diferentes condiciones operación. • cualesquiera prototipos desarrollados para definir requerimientos. cada uno estos productos del trabajo revisado por todas las personas que participan indagación los requerimientos. . desarrollo casos uso libro que analiza cómo escribir casos uso eficaces, alistair cockburn [coc] afirma que “ caso uso capta contrato […] [que] describe comportamiento del sistema distintas condiciones las que sistema responde una petición alguno sus participan-tes […]”. esencia, caso uso narra una historia estilizada sobre cómo interactúa usuario final (que tiene cierto número roles posibles) con sistema circunstancias espe-cíficas. historia puede ser texto narrativo, lineamiento tareas interacciones, una descripción basada formato una representación diagramática. sin importar forma, caso uso ilustra software sistema desde punto vista del usuario final. primer paso para escribir caso uso definir conjunto “actores” que estarán involucrados historia. los actores son las distintas personas ( dispositivos) que usan sistema producto contexto función comportamiento que describirse. los actores representan los papeles que desempeñan las personas ( dispositivos) cuando opera sistema. con una definición más formal, actor cualquier cosa que comunique con sistema producto que sea externo éste. todo actor tiene uno más objetivos cuando utiliza sistema. importante notar que actor usuario final necesariamente son mismo. usuario normal puede tener varios papeles diferentes cuando usa sistema, mientras que actor representa una clase entidades externas (gente, con frecuencia pero siempre) que sólo tiene papel contexto del caso uso. por ejemplo, considere ope-rador una máquina ( usuario) que interactúa con computadora control una celda manufactura que contiene varios robots máquinas control numérico. después una revisión cuidadosa los requerimientos, software para computadora control requiere cuatro diferentes modos (papeles) para interacción: modo programación, modo prueba, modo vigilancia modo solución problemas. por tanto, posible definir cuatro acto-res: programador, probador, vigilante solucionador problemas. ciertos casos, opera-dor máquina desempeñará todos los papeles. otros, distintas personas tendrán papel cada actor. debido que indagación los requerimientos una actividad evolutiva, todos los actores son identificados primera iteración. ésta posible identificar los actores principales [jac], los secundarios cuando sabe más del sistema. los actores principa-les interactúan para lograr función requerida del sistema obtienen beneficio previsto éste. trabajan con software forma directa con frecuencia. los actores secundarios dan apoyo sistema, modo que los primarios puedan hacer trabajo.¿qué información produce como conse-cuencia recabar los requerimientos?? punto clave los casos uso definen desde punto vista actor. actor papel que desempeñan las personas (usuarios) los dispositivos cuando interactúan con software. webref artículo excelente sobre casos uso puede descargarse desde dirección (-).indd (-).indd // ::// :: parte dos modelado una vez identificados los actores, posible desarrollar casos uso. jacobson [jac] - giere varias preguntas que debe responder caso uso: • ¿quién actor principal quién() (los) secundario()? • ¿cuáles son los objetivos los actores? • ¿qué precondiciones deben existir antes comenzar historia? • ¿qué tareas funciones principales son realizadas por actor? • ¿qué excepciones deben considerarse describir historia? • ¿cuáles variaciones son posibles interacción del actor? • ¿qué información del sistema adquiere, produce cambia actor? • ¿tendrá que informar actor sistema acerca cambios ambiente externo? • ¿qué información desea obtener actor del sistema? • ¿quiere actor ser informado sobre cambios inesperados? relación con los requerimientos básicos casasegura, definen cuatro actores: pro- pietario casa (usuario), gerente arranque (tal vez misma persona que propie- tario casa, pero papel diferente), sensores (dispositivos adjuntos sistema) subsistema vigilancia respuesta (estación central que vigila función seguridad casa casasegura). para fines este ejemplo, consideraremos sólo actor llamado pro- pietario casa. éste interactúa con función seguridad casa varias formas distintas con empleo del panel control alarma con una : • introduce una clave que permita todas las demás interacciones. • pregunta sobre estado una zona seguridad. • interroga acerca del estado sensor. • una emergencia, oprime botón pánico. • activa desactiva sistema seguridad. considerando situación que propietario casa usa panel control, continua-ción plantea caso uso básico para activación del sistema: . propietario observa panel control casasegura (véase figura .) para determinar sistema está listo para recibir una entrada. sistema está listo, muestra mensaje está listo pantalla cristal líquido propietario debe cerrar físicamente ventanas puertas modo que desaparezca dicho mensaje [ mensaje está listo implica que sensor está abierto; por ejemplo, que una puerta ventana está abierta]. . propietario usa teclado para introducir una clave cuatro dígitos. clave compara con que guarda sistema como válida. clave incorrecta, panel control emitirá sonido una vez reiniciará para recibir una entrada adicional. clave correcta, panel control espera otras acciones. . propietario selecciona teclea permanecer fuera (véase figura .) para activar sistema. entrada permanecer activa sólo sensores perimetrales ( desactivan los sensores detección movimiento interior). entrada fuera activa todos los sensores. . cuando ocurre una activación, propietario observa una luz roja alarma. las preguntas jacobson han ampliado para que den una visión más completa del contenido del caso uso. observe que este caso uso difiere situación que accede sistema través internet. este caso, interacción por medio del panel control con interfaz usuario gráfica (gui) que cuando emplea una .¿qué necesita saber fin desarrollar caso uso eficaz?? (-).indd (-).indd // ::// :: comprensión los requerimientos caso uso básico presenta una historia alto nivel que describe interacción entre actor sistema. muchas circunstancias, los casos uso son más elaborados fin que brinden muchos más detalles sobre interacción. por ejemplo, cockburn [coc] sugiere formato siguiente para hacer descripciones detalladas casos uso: caso uso: iniciarvigilancia actor principal: propietario. objetivo contexto: preparar sistema para que vigile los sensores cuando propietario salga casa permanezca dentro. precondiciones: sistema programado para recibir una clave reconocer distintos sensores. disparador: propietario decide “preparar” sistema, por ejemplo, para que encienda las funciones alarma. escenario: . propietario: observa panel control . propietario: introduce una clave . propietario: selecciona “permanecer” “fuera” . propietario: observa una luz roja alarma que indica que casasegur sido activada. excepciones: . panel control está listo: propietario verifica todos los sensores para determinar cuáles están abiertos; los cierra. . clave incorrecta ( panel control suena una vez): propietario introduce clave - rrecta. . clave reconocida: debe contactarse subsistema vigilancia respuesta para reprogra- mar clave. . elige permanecer: panel control suena dos veces enciende letrero luminoso que dice permanecer; activan los sensores del perímetro. . selecciona fuer : panel control suena tres veces enciende letrero luminoso que dice fuera; activan todos los sensores. * permanecer max probar desvío instantáneo código repicar listo #activada energíaalarma comprobación incendiofuera permanecerinstantáneodesvíono está listo pánicofigura . panel control casasegura frecuente que los casos uso escriban manera informal. sin embargo, utilice formato que presenta aquí para asegurar que incluyen todos los aspectos clave.consejo (-).indd (-).indd // ::// :: parte dos modelado prioridad: esencial, debe implementarse cuándo estará disponible: primer incremento frecuencia uso: muchas veces por díacanal para actor: través interfaz del panel controlactores secundarios: técnico apoyo, sensorescanales para los actores secundarios: técnico apoyo: línea telefónica sensores: interfaces cableadas frecuencia radio aspectos pendientes: . ¿debe haber una forma activar sistema sin usar clave con una clave abreviada? . ¿ panel control debe mostrar mensajes texto adicionales? . ¿ cuánto tiempo dispone propietario para introducir clave partir del momento que oprime primera tecla? . ¿hay una forma desactivar sistema antes que active realidad? los casos uso para otras interacciones propietario desarrollarían una forma simi- lar. importante revisar con cuidado cada caso uso. algún elemento interacción ambiguo, probable que revisión del caso uso detecte. apéndice presenta breve método aprendizaje uml para aquellos lectores que estén fami- liarizados con dicha notación. escena: sala juntas, continúa reunión para recabar los requerimientos. participantes: jamie lazar, miembro del equipo software; vinod roman, integrante del equipo software; robbins, inte-grante del equipo software; doug miller, gerente ingeniería software; tres miembros mercadotecnia; representante inge-niería del producto; facilitador. conversación:facilitador: hemos pasado buen tiempo hablando fun- ción seguridad del hogar casasegura. durante receso hice diagrama caso uso para resumir los escenarios importantes que forman parte esta función. veámoslo. (todos los asistentes observan figura ..)jamie: estoy aprendiendo notación uml. veo que función seguridad del hogar está representada por rectángulo grande con óvalos interior, ¿verdad? ¿ los óvalos representan los casos uso que hemos escrito? facilitador: . las figuras pegadas representan los actores —personas cosas que interactúan con sistema según los describe caso uso…—; ¡! usé cuadrado para representar actor que persona… este caso, sensores. doug: ¿ válido eso uml?facilitador: legalidad importante. objetivo comu- nicar información. veo que usar una figura humana para represen-tar equipo sería erróneo. así que adapté las cosas poco. pienso que genere problemas. vinod: está bien, entonces tenemos narraciones casos uso para cada óvalo. ¿necesitamos desarrollarlas con base los for-matos sobre los que leído? facilitador: probable, pero eso puede esperar hasta que haya- mos considerado otras funciones casasegura. persona mercadotecnia: esperen, estado observando este diagrama pronto doy cuenta que hemos olvidado algo. facilitador: ¿ verdad? dime, ¿qué hemos olvidado?( reunión continúa.)casasegura desarrollo diagrama caso uso alto nivel (-).indd (-).indd // ::// :: comprensión los requerimientos . elaboración del modelo los requerimientos objetivo del modelo del análisis describir los dominios información, función compor- tamiento que requieren para sistema basado computadora. modelo cambia forma dinámica medida que aprende más sobre sistema por construir, otros participantes comprenden más que realidad requieren. por esa razón, modelo del análisis una -tografía los requerimientos cualquier momento dado. esperar que cambie. medida que evoluciona modelo requerimientos, ciertos elementos vuelven relati- vamente estables, que fundamento sólido para diseñar las tareas que sigan. sin -bargo, otros elementos del modelo son más volátiles, que indica que los participantes todavía entienden bien los requerimientos para sistema. los capítulos presentan propietario administrador del sistemasistema que activa desactiva responde evento alarmaaccede sistema por internet encuentra una condición error reconﬁgura sensores características del sistema relacionadas sensoresfigura . diagrama caso uso uml para función seguridad del hogar casasegura las herramientas mencionadas aquí son obligatorias, sino una muestra las que hay esta categoría. mayoría casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores. este libro usan como sinónimos las expresiones modelar análisis modelar los requerimientos. ambos refieren representaciones los dominios información, funcional comportamiento que describen los requerimientos del problema.desarrollo caso uso objetivo: ayudar desarrollar casos uso proporcio- nando formatos mecanismos automatizados para eva- luar claridad consistencia. mecánica: mecánica las herramientas varía. general, las herramientas para casos uso dan formatos con espacios blanco para ser llenados crear así casos eficaces. mayor parte fun-cionalidad los casos uso está incrustada conjunto más amplio funciones ingeniería los requerimientos.herramientas representativas gran mayoría herramientas análisis del modelado basadas uml dan apoyo tanto texto como gráfico para desarrollo modelado casos uso. objects design ( html) proporciona vínculos exhaustivos con herramientas este tipo.herramientas software (-).indd (-).indd // ::// :: parte dos modelado detalle modelo del análisis los métodos que usan para construirlo. las secciones - guientes panorama breve. .. elementos del modelo requerimientos hay muchas formas diferentes concebir los requerimientos para sistema basado computadora. algunos profesionales del software afirman que mejor seleccionar modo representación (por ejemplo, caso uso) aplicarlo hasta excluir todos los demás. otros piensan que más benéfico usar cierto número modos representación distintos para ilustrar modelo requerimientos. los modos diferentes representación fuerzan consi-derar los requerimientos desde distintos puntos vista, enfoque que tiene una probabilidad mayor detectar omisiones, inconsistencia ambigüedades. los elementos específicos del modelo requerimientos están determinados por método análisis modelado (véanse los capítulos ) que use. obstante, mayoría -delos tiene común conjunto elementos generales. elementos basados escenario. sistema describe desde punto vista del usuario con empleo enfoque basado escenario. por ejemplo, los casos uso básico (véase sección .) sus diagramas correspondientes casos uso (véase figura .) evolucionan hacia otros más elaborados que basan formatos. los elementos del -delo requerimientos basados escenario con frecuencia son primera parte del modelo desarrollo. como tales, sirven como entrada para creación otros elementos mode-lado. figura . ilustra diagrama actividades uml para indagar los requerimientos representarlos con empleo casos uso. aprecian tres niveles elaboración que cul-minan una representación basada escenario. elementos basados clases. cada escenario uso implica conjunto objetos que manipulan cuando actor interactúa con sistema. estos objetos clasifican clases: conjunto objetos que tienen atributos similares comportamientos comunes. por ejemplo, para ilustrar clase sensor función seguridad casa segur (véase figura .), puede utilizarse diagrama clase uml. observe que diagrama enlista los atributos los sensores (por ejemplo, nombre, tipo, etc.) las operaciones (por ejemplo, identificar permitir) que aplican para modificarlos. además los diagramas clase, otros elementos mode-lado del análisis ilustran manera que las clases colaboran una con otra las relaciones interacciones entre ellas. esto analiza con más detalle capítulo . elementos comportamiento. comportamiento sistema basado computadora tiene efecto profundo diseño que elija enfoque implementación que aplique. por tanto, modelo requerimientos debe pro veer elementos modelado que ilus- tren comportamiento. diagrama estado método representación del comportamiento sistema que ilustra sus estados los eventos que ocasionan que sistema cambie estado. estado cualquier modo comportamiento observable desde exterior. además, diagrama -tado indica acciones (como activación proceso, por ejemplo) tomadas como conse-cuencia evento particular. para ilustrar uso diagrama estado, considere software incrustado dentro del panel control casasegura que responsable leer las entradas que hace usuario. figura . presenta diagrama estado uml simplificado. además las representaciones comportamiento del sistema como todo, también posible modelar clases individuales. sobre esto presentan más análisis capítulo . apéndice presenta instructivo breve sobre uml, para aquellos lectores que estén familiarizados con dicha notación.siempre buena idea involucrar los participantes. una las mejores formas lograrlo hacer que cada uno escriba casos uso que narren modo que utilizará software.consejo una forma aislar las clases buscar sustantivos descriptivos caso usuario expresado con texto. menos algunos ellos serán candidatos cercanos. sobre esto habla más capítulo .consejo punto clave estado modo comportamiento observable desde exterior. los estímulos externos ocasionan transiciones entre los estados. (-).indd (-).indd // ::// :: comprensión los requerimientos ¿ dan prioridades formales? noefectuar reuniones elaborar listas funciones clases hacer listas restricciones, entre otras usar dfc para asignar prioridad los requerimientosdar prioridad los requerimien- tos manera informal crear casos usohacer diagrama del caso usodeﬁnir actores escribir escenario terminar formatoindagación los requerimientosfigura . diagramas actividad del uml para indagar los requerimientos nombre tipoubicaciónáreacaracterísticas identiﬁcar()activar()desactivar()reconﬁgurar()sensor figura . diagrama clase para sensor estado del sistema = “listo” mensaje pantalla = “introducir comando”estado pantalla = establenombre del estado variables del estado actividades del estado entrar /subsistemas listos hacer: panel entradas del grupo usuarioshacer: lectura entrada del usuariohacer: interpretación entrada del usuariocomandos lectura figura . notación uml del diagrama estado (-).indd (-).indd // ::// :: parte dos modelado elementos orientados flujo. información transforma cuando fluye través sistema basado computadora. sistema acepta entradas varias formas, aplica funciones para transformarla produce salidas distintos modos. entrada puede ser una señal control transmitida por transductor , una serie números escritos con teclado por operador humano, paquete información enviado por enlace red archivo grande datos recuperado almacenamiento secundario. transformación quizá incluya una sola comparación lógica, algoritmo numérico complicado enfoque regla inferen-cia para sistema experto. salida quizá encienda diodo emisor luz genere -forme páginas. efecto, posible crear modelo del flujo para cualquier sistema basado computadora, sin importar tamaño complejidad. capítulo hace análisis más detallado del modelado del flujo. .. patrones análisis cualquiera que haya hecho ingeniería los requerimientos varios proyectos software observado que ciertos problemas son recurrentes todos ellos dentro dominio aplicación específico. estos patrones análisis [fow] sugieren soluciones (por ejemplo, una clase, función comportamiento) dentro del dominio aplicación que pueden volverse utilizar cuando modelen muchas aplicaciones. geyer-schulz hahsler [gey] sugieren dos beneficios asociados con uso patrones análisis: primer lugar, los patrones análisis aceleran desarrollo los modelos análisis abstracto que capturan los principales requerimientos del problema concreto, debido que proveen modelos análisis reutilizables con ejemplos, así como una descripción sus ventajas limitaciones. - escena: sala juntas, continúa reunión requerimientos. participantes: jamie lazar, integrante del equipo software; vinod raman, miembro del equipo software; robbins, inte-grante del equipo software; doug miller, gerente ingeniería software; tres trabajadores mercadotecnia; representante ingeniería del producto, facilitador. conversación:facilitador: estamos por terminar hablar sobre funcionalidad seguridad del hogar casasegura. pero antes, quisiera que analizáramos comportamiento función. persona mercadotecnia: entiendo que quiere decir con comportamiento. (sonríe): cuando das “tiempo fuera” producto porta mal. facilitador: exactamente. permítanme explicarlo.( facilitador explica equipo encargado recabar los requeri- mientos los fundamentos modelado del comportamiento.)persona mercadotecnia: esto parece poco técnico. estoy seguro ser ayuda aquí. facilitador: seguro que serás. ¿qué comportamiento obser- desde punto vista usuario? persona mercadotecnia: mmm... bueno, sistema estará vigilando los sensores. leerá comandos del propietario. mostrará estado. facilitador: ¿ves?, puedes hacer.jamie: también estará interrogando para determinar hay alguna entrada desde ella, por ejemplo, acceso por internet información sobre configuración. vinod: , realidad, configurar sistema estado por dere- cho propio. doug: muchachos, hacen bien. pensemos poco más... ¿hay alguna forma hacer diagrama todo esto? facilitador: hay, pero dejaremos para próxima reunión.casasegura modelado preliminar del comportamiento ciertos casos, los problemas vuelven suceder sin importar dominio aplicación. por ejemplo, son comunes las características funciones usadas para resolver problemas interfaz usuario sin importar dominio aplicación consideración. (-).indd (-).indd // ::// :: comprensión los requerimientos gundo lugar, los patrones análisis facilitan transformación del modelo análisis modelo del diseño, sugiriendo patrones diseño soluciones confiables para problemas comunes. los patrones análisis integran modelo del análisis, haciendo referencia nombre del patrón. también guardan medio almacenamiento modo que los ingenieros requerimientos usen herramientas búsqueda para encontrarlos aplicarlos. informa-ción sobre patrón análisis ( otros tipos patrones) presenta formato estándar [gey] que estudia con más detalle capítulo . capítulo dan ejemplos patrones análisis más detalles este tema. . requerimientos las negociaciones contexto ideal ingeniería los requerimientos, las tareas concepción, indaga-ción elaboración determinan los requerimientos del cliente con suficiente detalle como para avanzar hacia las siguientes actividades ingeniería software. desafortunadamente, esto rara vez ocurre. realidad, tiene que entrar negociaciones con uno varios participan-tes. mayoría los casos, pide éstos que evalúen funcionalidad, desempeño otras características del producto sistema, contraste con costo tiempo para entrar mer-cado. objetivo esta negociación desarrollar plan del proyecto que satisfaga las nece-sidades del participante que mismo tiempo refleje las restricciones del mundo real (por ejemplo, tiempo, personas, presupuesto, etc.) que hayan establecido equipo del software. las mejores negociaciones buscan resultado “ganar-ganar”. decir, los participantes ganan porque obtienen sistema producto que satisface mayoría sus necesidades usted (como miembro del equipo software) gana porque trabaja con presupuestos plazos realistas asequibles. boehm [boe] define conjunto actividades negociación principio cada itera- ción del proceso software. lugar una sola actividad comunicación con cliente, definen las actividades siguientes: . identificación los participantes clave del sistema subsistema. . determinación las “condiciones para ganar” los participantes. bibliografía existen varias propuestas formatos para patrones. lector tiene interés, consulte [fow], [gam], [yac] [bus], entre muchas otras fuentes. han escrito decenas libros acerca las aptitudes para negociar (por ejemplo [lew], [rai] [fis]). una las aptitudes más importantes que pueda aprender. lea alguno.cita: “ compromiso arte dividir pastel forma tal que todos crean que tienen trozo mayor.” ludwig erhard webref artículo breve sobre negociación para los requerimientos software puede descargarse desde dirección aprender negociar con eficacia servirá vida personal técnica. útil considerar los lineamientos que siguen: . reconocer que una competencia. para tener éxito, ambas partes tienen que sentir que han ganado logrado algo. las dos tienen que llegar compromiso. . mapear una estrategia. decidir qué que gustaría lograr; qué quiere obtener otra parte cómo hacer para que ocu-rran las dos cosas. . escuchar activamente. trabaje formulación res-puesta mientras otra parte esté hablando. escúchela. pro-bable que obtenga conocimientos que ayuden negociar mejor posición. . centrarse los intereses otra parte. quiere evitar con-flictos, adopte posiciones inamovibles. . tome forma personal. céntrese problema que necesita resolverse. . sea creativo. están empantanados, tenga miedo pen-sar fuera los moldes. . esté listo para comprometerse. una vez que llegue acuerdo, titubee; comprométase con cúmplalo.información arte negociación (-).indd (-).indd // ::// :: parte dos modelado . negociación las condiciones para ganar los participantes fin reconciliarlas conjunto condiciones ganar-ganar para todos los que intervienen (incluso equipo software). realización exitosa estos pasos iniciales lleva resultado ganar-ganar , que convierte criterio clave para avanzar hacia las siguientes actividades ingeniería software. escena: oficina lisa pérez, después primera reunión para recabar los requerimientos. participantes: doug miller, gerente ingeniería software, lisa pérez, gerente mercadotecnia. conversación:lisa: pues escuché que primera reunión salió realmente bien.doug: realidad, . enviaste buenos representantes... contribuye- ron verdad. lisa (sonríe): ; realidad dijeron que habían entrado que había sido una “actividad que les despejara cabeza”. doug (ríe): próxima vez aseguraré quitarme vena tec- nológica... mira, lisa, creo que tenemos problema para llegar toda esa funcionalidad del sistema seguridad para hogar las fechas que propone dirección. que aún temprano, pero hice poco planeación sobre las rodillas ... lisa (con ceño fruncido): debemos tener para esa fecha, doug. ¿ qué funcionalidad hablas? doug: supongo que podemos tener funcionalidad completa fecha establecida, pero tendríamos que retrasar acceso por inter-net hasta segundo incremento.lisa: doug, acceso por internet que casasegura “súper” atractivo. toda nuestra campaña publicidad girar alrededor eso. tenemos que tener… doug: entiendo situación, verdad. problema que para dar acceso por internet tendríamos que tener sitio web por com-pleto seguro operación. esto requiere tiempo personal. tam-bién tenemos que elaborar mucha funcionalidad adicional pri-mera entrega… creo que podamos hacerlo con los recursos que tenemos. lisa (todavía frunce ceño): veo, pero tienes que imaginar una manera hacerlo. tiene importancia crítica para las funciones seguridad del hogar también para otras… éstas podrían espe-rar hasta las siguientes entregas… estoy acuerdo con eso. lisa doug parecen estar suspenso, pero todavía deben negociar una solución este problema. ¿pueden “ganar” los dos este caso? usted fuera mediador, ¿qué sugeriría?casasegura principio una negociación . validación los requerimientos medida que crea cada elemento del modelo requerimientos, estudia para detectar inconsistencias, omisiones ambigüedades. los participantes asignan prioridades los reque-rimientos representados por modelo agrupan paquetes requerimientos que implementarán como incrementos del software. revisión del modelo requerimientos aborda las preguntas siguientes: • ¿ coherente cada requerimiento con los objetivos generales del sistema producto? • ¿ han especificado todos los requerimientos nivel apropiado abstracción? decir, ¿algunos ellos tienen nivel detalle técnico que resulta inapropiado esta etapa? • requerimiento, ¿ realmente necesario representa una característica agregada que tal vez sea esencial para objetivo del sistema? • ¿cada requerimiento está acotado ambiguo? • ¿tiene atribución cada requerimiento? decir, ¿hay una fuente (por general una indi-vidual específica) clara para cada requerimiento? • ¿hay requerimientos conflicto con otros?cuando revisan los requerimientos, ¿qué preguntas deben plantearse?? (-).indd (-).indd // ::// :: comprensión los requerimientos • ¿cada requerimiento asequible ambiente técnico que albergará sistema producto? • una vez implementado cada requerimiento, ¿puede someterse prueba? • modelo requerimientos, ¿refleja manera apropiada información, función comportamiento del sistema que construir? • ¿ “particionado” modelo requerimientos forma que exponga información cada vez más detallada sobre sistema? • ¿ usado patrón requerimientos para simplificar modelo éstos? ¿ han validado todos los patrones manera apropiada? ¿son consistentes todos los patrones con los requerimientos del cliente? éstas otras preguntas deben plantearse responderse para garantizar que modelo reque-rimientos una reflexión correcta sobre las necesidades del participante que provee fun-damento sólido para diseño. . resumen las tareas ingeniería requerimientos realizan para establecer fundamento sólido para diseño construcción. ingeniería requerimientos ocurre durante las actividades comunicación modelado que hayan definido para proceso general del software. los miembros del equipo software llevan cabo siete funciones ingeniería requerimientos: concepción, indagación, elaboración, negociación, especificación, validación administración. concepción del proyecto, los participantes establecen los requerimientos básicos del problema, definen las restricciones generales del proyecto, así como las características fun-ciones principales que debe presentar sistema para cumplir sus objetivos. esta información mejora amplía durante indagación, actividad que recaban los requerimientos que hace uso reuniones que facilitan, dfc desarrollo escenarios uso. elaboración amplía aún más los requerimientos modelo: una colección elemen- tos basados escenarios, clases comportamiento, orientados flujo. modelo hace refe-rencia patrones análisis: soluciones para problemas análisis que observado que son recurrentes diferentes aplicaciones. conforme identifican los requerimientos crea modelo, equipo software otros participantes negocian prioridad, disponibilidad costo relativo cada requerimiento. además, valida cada requerimiento modelo como todo comparado con las necesida-des del cliente fin garantizar que construirse sistema correcto. problemas puntos por evaluar .. ¿por qué muchos desarrolladores software ponen atención suficiente ingeniería requeri- mientos? ¿existen algunas circunstancias que puedan ignorarse? .. lector tiene responsabilidad indagar los requerimientos cliente que dice estar demasiado ocupado para tener una reunión. ¿qué debe hacer?.. analice algunos los problemas que ocurren cuando los requerimientos deben indagarse para tres cuatro clientes distintos... ¿por qué dice que modelo requerimientos representa una fotografía instantánea del sistema tiempo?.. suponga que convencido cliente ( usted muy buen vendedor) para que esté acuerdo con - das las demandas que usted hace como desarrollador. ¿eso convierte gran negociador? ¿por qué? (-).indd (-).indd // ::// :: parte dos modelado .. desarrolle menos tres “preguntas libres contexto” adicionales que podría plantear partici- pante durante concepción. .. desarrolle “kit” para recabar requerimientos. debe incluir conjunto lineamientos fin llevar cabo reunión para recabar requerimientos los materiales que pueden emplearse para facilitar crea- ción listas otros objetos que ayuden definir los requerimientos. .. profesor formará grupos cuatro seis estudiantes. mitad ellos desempeñará papel del departamento mercadotecnia otra mitad adoptará del equipo para ingeniería software. trabajo definir los requerimientos para función seguridad casasegura descrita este capítulo. efectúe una reunión para recabar los requerimientos con uso los lineamientos presentados este capítulo. .. desarrolle caso uso completo para una las actividades siguientes: ) hacer retiro efectivo cajero automático. ) usar tarjeta crédito para pagar una comida restaurante. ) comprar acciones cuenta línea una casa bolsa. ) buscar libros (sobre tema específico) una librería línea. ) actividad que especifique profesor. .. ¿qué representan las “excepciones” caso uso? .. describa con sus propias palabras que patrón análisis. .. con formato presentado sección .., sugiera uno varios patrones análisis para los - guientes dominios aplicación: ) software contabilidad. ) software correo electrónico. ) navegadores internet. ) software procesamiento texto. ) software para crear sitio web. ) dominio aplicación que diga profesor. .. ¿qué significa ganar-ganar contexto una negociación durante actividad ingeniería los requerimientos?.. ¿qué piensa que pasa cuando validación los requerimientos detecta error? ¿quién está invo- lucrado corrección? lecturas adicionales fuentes información ingeniería requerimientos estudia muchos libros debido importancia crítica para creación exitosa cualquier sistema basado computadoras. hood . ( requirements management, springer, ) analizan varios aspectos ingeniería los requerimientos que incluyen tanto ingeniería sistemas como software. young (the requirements engineering handbook, artech house publishers, ) presenta análisis profundo las tareas ingeniería requerimientos. wiegers ( more about software requirements, microsoft press, ) menciona muchas técnicas prácticas para recabar adminis-trar los requerimientos. hull . ( requirements engineering, . ., springer-verlag, ), bray ( intro- duction requirements engineering, addison-wesley, ), arlow (requirements engineering, addison-wes- ley, ), gilb (requirements engineering, addison-wesley, ), graham (requirements engineering and rapid development, addison-wesley, ) sommerville kotonya (requirement engineering: processes and techniques, wiley, ) son sólo algunos los muchos libros dedicados tema. gottesdiener (requi-rements collaboration: workshops for defining needs, addison-wesley, ) proporciona una guía útil para quienes deben generar ambiente colaboración fin recabar los requerimientos con los parti-cipantes. lauesen (software requirements: styles and techniques, addison-wesley, ) presenta una recopilación exhaustiva los métodos notación para análisis requerimientos. weigers ( software requirements, microsoft press, ) leffingwell . ( managing software requirements: use case approach, . ., addison-wesley, ) presentan una colección útil las mejores prácticas respecto los requerimientos sugieren lineamientos prácticos para mayoría los aspectos del proceso ingeniería. (-).indd (-).indd // ::// :: comprensión los requerimientos withall (software requirement patterns, microsoft press, ) describe ingeniería requerimien- tos desde punto vista basado los patrones. ploesch (assertions, scenarios and prototypes, springer- verlag, ) analiza técnicas avanzadas para desarrollar requerimientos software. windle abreo (software requirements using the unified process , prentice-hall, ) estudian ingeniería los requeri- mientos contexto del proceso unificado notación uml. alexander steven (writing better require-ments, addison-wesley, ) presentan conjunto abreviado lineamientos para escribir requerimientos claros, representarlos como escenarios revisar resultado final. frecuente que modelado caso uso sea detonante para crear todos los demás aspectos del modelo análisis. tema estudian mucho rosenberg stephens (use case driven object modeling with uml: theory and practice, apress, ), denny (succeeding with use cases: working smart deliver quality , addison-wesley, ), alexander maiden (eds.) (scenarios, stories, use cases: through the systems deve-lopment life-cycle, wiley, ), leffingwell . ( managing software requirements: use case approach , . ., addison-wesley, ) presentan una colección útil las mejores prácticas sobre los requerimientos. bittner spence (use case modeling, addison-wesley, ), cockburn [coc], armour miller ( advanced use cases modeling: software systems , addison-wesley, ) kulak . (use cases: requirements con- text, addison-wesley, ) estudian obtención requerimientos con énfasis modelado del caso uso. internet hay una variedad amplia fuentes información acerca ingeniería análisis los requerimientos. sitio web del libro, halla una lista actualizada referencias web que son relevantes para ingeniería análisis los requerimientos. (-).indd (-).indd // ::// :: los requerimientos : escenarios , información clases análisis conceptos clave análisis del dominio. . . . . . . análisis gramatical . . . . . . . . . . . . . . . . . . . uso . . . . . . . . . . . . análisis. . . . . . . . . actividades . . . canal . . . . . . . . basado clases . . . . . . . . . . . . . . modelado basado escenarios . . . . . . . . . . . modelado crc. . . . . . . . . . . datos . . . . . . . requerimientos . . . . . . . . . . modelos uml . . . . . . . . . . . análisis . . . . . . ¿qué ? palabra escrita vehículo maravilloso para comunicación, pero necesariamente mejor forma represen-tar los requerimientos software compu- tadora. modelado los requerimientos utiliza una combinación texto diagramas para ilustrarlos forma que sea relativamente fácil entender , más importante, revisar para corregir, completar hacer congruente. ¿quién hace? ingeniero software ( veces llama- “analista”) construye modelo con uso los reque-rimientos recabados del cliente. ¿por qué importante? para validar los requerimientos del software necesita estudiarlos desde varios puntos vista diferentes. este capítulo considerará modelado los requerimientos desde tres perspectivas distintas: mode-los basados escenario, modelos datos (información) modelos basados clase. cada una representa los requerimientos una “dimensión” diferente, con que aumenta probabilidad detectar errores, que afloren las inconsistencias que revelen las omisiones. ¿cuáles son los pasos? modelado basado escena- rios una representación del sistema desde punto vista del usuario. modelado basado datos recrea espacio información ilustra los objetos datos que manipulará software las relaciones entre ellos. modelado orientado clases define objetos, atributos relaciones. una vez que crean los modelos preliminares, mejoran analizan para evaluar están claros com-pletos, son consistentes. capítulo amplían con representaciones adicionales las dimensiones del modela- descritas aquí, que punto vista más sólido los requerimientos. ¿cuál producto final? para construir modelo requerimientos, escoge una amplia variedad repre-sentaciones basadas texto diagramas. cada una dichas representaciones una perspectiva uno más los elementos del modelo. ¿cómo aseguro que hice bien? los produc- tos del trabajo para modelar los requerimientos deben revisarse para saber son correctos, completos consis-tentes. deben reflejar las necesidades todos los partici-pantes establecer fundamento desde que realiza- diseño. una mirada rápida ediciones anteriores este libro, usó término modelo análisis, lugar modelo requerimientos. esta edición, autor decidió usar ambas expresiones para designar actividad que define distintos aspectos del problema por resolver. análisis que ocurre cuando obtienen los requerimientos. nivel técnico, ingeniería software comienza con una serie tareas modelado que conducen especificación los requerimientos representación diseño del software que elaborar. modelo requerimientos — conjunto mode- los, realidad— primera representación técnica sistema. libro fundamental sobre métodos para modelar los requerimientos, tom demarco [dem] describe proceso manera siguiente: mirar retrospectivamente los problemas las fallas detectados fase análisis, concluyo que necesario agregar siguiente conjunto objetivos dicha fase. debe ser muy fácil dar man-tenimiento los productos del análisis. esto aplica particular documento objetivos [espe-cificación los requerimientos del software]. los problemas grandes deben ser enfrentados con empleo método eficaz para dividirlos. especificación victoriana original resulta caduca. -ben usarse gráficas, siempre que sea posible. necesario diferenciar las consideraciones lógicas [esenciales] las físicas [implementación]… finalmente, necesita… algo que ayude dividir los requerimientos documentar dicha partición antes elaborar especificación… algunos medios para dar seguimiento las interfaces evaluarlas… nuevas herramientas para describir lógica política, algo mejor que texto narrativo. (-).indd (-).indd // ::// :: modelado los requerimientos aunque demarco escribió hace más cuarto siglo acerca los atributos del mode- lado del análisis, sus comentarios aún son aplicables los métodos notación modernos del modelado los requerimientos. . análisis los requerimientos análisis los requerimientos como resultado especificación las características ope-rativas del software, indica interfaz éste otros elementos del sistema, establece las restricciones que limitan software. análisis los requerimientos permite profesional (sin importar llama ingeniero software, analista modelista) construir sobre los requerimien- tos básicos establecidos durante las tareas concepción, indagación negociación, que son parte ingeniería los requerimientos (véase capítulo ). acción modelar los requerimientos como resultado uno más los siguientes tipos modelo: • modelos basados escenario los requerimientos desde punto vista distintos “actores” del sistema. • modelos datos, que ilustran dominio información del problema. • modelos orientados clases, que representan clases orientadas objetos (atributos operaciones) manera que las clases colaboran para cumplir con los requeri-mientos del sistema. • modelos orientados flujo, que representan los elementos funcionales del sistema manera como transforman los datos medida que avanza través del sistema. • modelos comportamiento, que ilustran modo que comparte software como consecuencia “eventos” externos. estos modelos dan diseñador del software información que traduce diseños arqui-tectura, interfaz componentes. por último, modelo requerimientos ( especificación requerimientos software) brinda desarrollador cliente los medios para evaluar cali-dad una vez construido software. este capítulo centra modelado basado escenarios, técnica que cada vez más popular entre comunidad ingeniería software; modelado basado datos, más - pecializado, apropiado particular cuando debe crearse una aplicación bien manipular espacio complejo información; modelado orientado clases , representación las clases orientada objetos las colaboraciones resultantes que permiten que funcione sistema. cita: “cualquier ‘vista’ los requeri- mientos insuficiente para entender describir compor-tamiento deseado sistema complejo.” alan . davis punto clave modelo análisis especificación requerimientos proporcionan medio para evaluar calidad una vez construido software. descripción del sistema modelo del análisis modelo del diseñofigura . modelo requerimientos como puente entre descripción del sistema modelo del diseño (-).indd (-).indd // ::// :: parte dos modelado capítulo analizan los modelos orientados flujo, comportamiento, basados - trón webapps. .. objetivos filosofía general durante modelado los requerimientos, atención centra qué, cómo. ¿qué interacción del usuario ocurre una circunstancia particular?, ¿qué objetos manipula sis-tema?, ¿qué funciones debe realizar sistema?, ¿qué comportamientos tiene sistema?, ¿qué interfaces definen? ¿qué restricciones son aplicables? los capítulos anteriores dijo que esta etapa tal vez fuera posible tener especi- ficación completa los requerimientos. cliente quizá esté seguro qué que -quiere con precisión para ciertos aspectos del sistema. puede ser que desarrollador esté inse-guro que algún enfoque específico cumpla manera apropiada función desempeño. estas realidades hablan favor enfoque iterativo para análisis modelado los requerimientos. analista debe modelar que sabe usar modelo como base para diseño del incremento del software. modelo requerimientos debe lograr tres objetivos principales: ) describir que - quiere cliente, ) establecer una base para creación diseño software ) definir conjunto requerimientos que puedan validarse una vez construido software. modelo análisis puente entre descripción nivel del sistema que centra éste general funcionalidad del negocio que logra con aplicación software, hardware, datos, personas otros elementos del sistema diseño software (véanse los capítulos ) que describa arquitectura aplicación del software, interfaz del usuario estruc-tura nivel del componente. esta relación ilustra figura .. importante observar que todos los elementos del modelo requerimientos pueden ras- trearse directamente hasta las partes del modelo del diseño. siempre posible división clara entre las tareas del análisis las del diseño estas dos importantes actividades del -delado. invariablemente, ocurre algo diseño como parte del análisis algo análisis lleva cabo durante diseño. .. reglas prácticas del análisis arlow neustadt [arl] sugieren cierto número reglas prácticas útiles que deben seguirse cuando crea modelo del análisis: • modelo debe centrarse los requerimientos que sean visibles dentro del problema dentro del dominio del negocio. nivel abstracción debe ser relativamente elevado. “ empantane los detalles” [arl] que traten explicar cómo funciona sistema. • cada elemento del modelo requerimientos debe agregarse entendimiento general los requerimientos del software dar una visión del dominio información, función del comportamiento del sistema. • hay que retrasar las consideraciones infraestructura otros modelos funcionales hasta llegar etapa del diseño. decir, quizá requiera una base datos, pero las clases necesarias para implementarla, las funciones requeridas para acceder ella comportamiento que tendrá cuando use sólo deben considerarse después que haya terminado análisis del dominio del problema.cita: “los requerimientos son arquitectura. son diseño interfaz usuario. los requeri-mientos son las necesidades.” andrew hunt david thomas debe notarse que, medida que los clientes tienen más conocimientos tecnológicos, hay una tendencia hacia especificación del cómo tanto como del qué. sin embargo, atención debe centrarse qué. esfuerzo por entender mejor los requerimientos para sistema, equipo del software tiene alternativa escoger creación prototipo (véase capítulo ).punto clave modelo análisis debe describir que quiere cliente, establecer una base para diseño objetivo para validación. ¿hay lineamientos básicos que nos ayuden hacer trabajo análisis los requerimientos? ? (-).indd (-).indd // ::// :: modelado los requerimientos • debe minimizarse acoplamiento través del sistema. importante representar las rela- ciones entre las clases funciones. sin embargo, nivel “interconectividad” extremadamente alto, deben hacerse esfuerzos para reducirlo. • seguro que modelo requerimientos agrega valor para todos los participantes. cada actor tiene propio uso para modelo. por ejemplo, los participantes negocios deben usar modelo para validar los requerimientos; los diseñadores deben usarlo como pase para diseño; personal aseguramiento calidad debe emplear como ayuda para planear las pruebas aceptación. • mantener modelo tan sencillo como pueda. genere diagramas adicionales agregan nueva información. utilice notación compleja basta una sencilla lista. .. análisis del dominio estudiar ingeniería requerimientos ( capítulo ), dijo que frecuente que haya patrones análisis que repiten muchas aplicaciones dentro dominio negocio específico. éstos definen clasifican forma tal que puedan reconocerse aplicarse para resolver problemas comunes, creación del modelo del análisis más expedita. más impor-tante aún que probabilidad aplicar patrones diseño componentes software eje-cutable incrementa mucho. esto mejora tiempo para llegar mercado reduce los costos desarrollo. pero, ¿cómo reconocen por primera vez los patrones análisis clases? ¿quién los - fine, clasifica prepara para usarlos los proyectos posteriores? respuesta estas pregun-tas está análisis del dominio. firesmith [fir] describe del siguiente modo: análisis del dominio del software identificación, análisis especificación los requerimientos comunes, partir dominio aplicación específica, normalmente para usarlo varias veces múltiples proyectos dentro del dominio aplicación […] [ análisis del dominio orientado objetos ] identificación, análisis especificación capacidades comunes reutilizables dentro -minio aplicación específica términos objetos, clases, subensambles estructuras comunes. “dominio aplicación específica” extiende desde control electrónico aviones hasta banca, los juegos video multimedios software incrustado equipos médicos. meta del análisis del dominio clara: encontrar crear aquellas clases patrones análisis que sean aplicables general, modo que puedan volverse usar. con empleo terminología que introdujo antes este libro, análisis del dominio puede considerarse como una actividad sombrilla para proceso del software. esto significa que análisis del dominio una actividad ingeniería software que está conectada cita: “los problemas que benéfico atacar demuestran beneficio con contragolpe.” piet hein webref dirección english/softwareengineering/se_mod.asp, existen muchos recursos útiles para análisis del dominio. análisis del dominiofuentes conocimiento del dominioencuestas clientes consejo expertosrequerimientos actuales futurosaplicaciones existentesbibliografía técnica modelo análisis del dominiomodelos funcionales lenguajes del dominioestándares reutilizacióntaxonomías clasefigura . entradas salidas para análisis del dominiopunto clave análisis del dominio busca una aplicación específica, sino dominio que reside aplicación. objetivo identificar elementos comunes para solución problemas, que sean útiles todas las aplicaciones dentro del dominio. punto vista complementario del análisis del dominio “involucra modelado éste, manera que los ingenieros del software otros participantes aprendan más respecto […] todas las clases dominio nece- sariamente dan como resultado desarrollo clases reutilizables […]” [let]. (-).indd (-).indd // ::// :: parte dos modelado suponga que ingeniero software necesita entender dominio aplicación tan sólo porque hay analista del dominio trabajando. todo miembro del equipo del software debe entender algo del dominio que colocar software. escena: oficina doug miller, después una reunión con personal mercadotecnia. participantes: doug miller, gerente ingeniería software, vinod raman, miembro del equipo ingeniería software. conversación:doug: necesito para proyecto especial, vinod. voy retirarte las reuniones para recabar los requerimientos. vinod (con ceño fruncido): muy mal. ese formato verdad funciona… estaba sacando algo ahí. ¿qué pasa? doug: jamie cubrirán. cualquier manera, departa- mento mercadotecnia insiste que primera entrega casasegura dispongamos capacidad acceso por internet junto con función seguridad para hogar. estamos bajo fuego esto… sin tiempo personal suficiente, así que tenemos que resolver ambos problemas vez: interfaz interfaz web. vinod (confundido): sabía que plan era entregar… siquiera hemos terminado recabar los requerimientos. doug (con una sonrisa tenue): , pero los plazos son tan breves que decidí comenzar estrategia con mercadotecnia… cualquier modo, revisaremos cualquier plan tentativo una vez que tengamos información todas las juntas que efectuarán para recabar los requerimientos. vinod: está bien, ¿entonces? ¿qué quieres que haga?doug: ¿sabes qué “análisis del dominio”?vinod: algo . buscas patrones similares aplicaciones que hagan mismo que que estés elaborando. entonces, posible, calcas los patrones los reutilizas trabajo. doug: estoy seguro que palabra sea calcar, pero básica- mente tienes razón. que gustaría que hicieras que comen-zaras buscar interfaces usuario existentes para sistemas que controlen algo como casasegura. quiero que propongas conjun- patrones clases análisis que sean comunes tanto inter-faz basada que estará hogar como basada navegador que accederá por internet. vinod: ahorraríamos tiempo las hiciéramos iguales… ¿por qué las hacemos así? doug: … grato tener gente que piense como haces . ése meollo del asunto: ahorraremos tiempo esfuerzo las dos interfaces son casi idénticas; las implementamos con mismo código acabamos con insistencia mercadotecnia. vinod: ¿entonces, qué quieres?, ¿clases, patrones análisis, patrones diseño? doug: todo eso. nada formal este momento. sólo quiero que comencemos despacio con nuestros trabajos análisis interno diseño. vinod: iré nuestra biblioteca clases veré qué tenemos. tam- bién usaré formato patrones que libro que leí hace unos meses. doug: bien. manos obra.casasegura análisis del dominio con ningún proyecto software. cierta forma, papel del analista del dominio similar maestro herrero ambiente manufactura pesada. trabajo del herrero diseñar fabricar herramientas que utilicen muchas personas que hacen trabajos similares pero necesariamente iguales. papel del analista dominio descubrir definir patrones análisis, clases análisis información relacionada que pueda ser utilizada por mucha gente que trabaje aplicaciones similares, pero que son necesariamente las mismas. figura . [ara] ilustra entradas salidas clave para proceso análisis del dominio. las fuentes conocimiento del dominio mapean con fin identificar los objetos que pueden reutilizarse través del dominio. .. enfoques del modelado requerimientos enfoque del modelado requerimientos, llamado análisis estructurado, considera que los datos los procesos que los transforman son entidades separadas. los objetos datos -delan modo que definan sus atributos relaciones. los procesos que manipulan los objetos datos modelan forma que muestre cómo transforman los datos medida que los objetos que corresponden con ellos fluyen por sistema.cita: “… análisis frustrante, está lleno relaciones inter-personales complejas, indefinidas difíciles. una palabra, fascinante. una vez atrapado, los antiguos fáciles placeres construcción sistemas nunca más volverán satisfacerte.” tom demarco (-).indd (-).indd // ::// :: modelado los requerimientos segundo enfoque del modelado del análisis, llamado análisis orientado objetos, centra definición las clases manera que colaboran uno con otro para cumplir los requerimientos. uml proceso unificado (véase capítulo ) están orientados obje-tos, sobre todo. aunque modelo requerimientos propuesto este libro combina características - bos enfoques, los equipos software escogen con frecuencia uno excluyen todas las repre-sentaciones del otro. pregunta cuál mejor, sino qué combinación representacio-nes proporcionará los participantes mejor modelo requerimientos del software puente más eficaz para diseño del mismo. cada elemento del modelo requerimientos (véase figura .) presenta problema desde diferentes puntos vista. los elementos basados escenario ilustran cómo interactúa usuario con sistema secuencia específica actividades que ocurren cuando utiliza software. los elementos basados clase modelan los objetos que sistema manipulará, las operaciones que aplicarán ellos para realizar dicha manipulación, las relaciones (algu-nas jerárquicas) entre los objetos las colaboraciones que ocurrirán entre las clases que definan. los elementos del comportamiento ilustran forma que los eventos externos cambian estado del sistema las clases que residen dentro éste. por último, los elemen-tos orientados flujo representan sistema como una transformación información ilustran forma que transforman los objetos datos cuando fluyen través las distintas funciones del sistema. modelado del análisis lleva obtención cada uno estos elementos modelado. sin embargo, contenido específico cada elemento (por ejemplo, los diagramas que -plean para construir elemento modelo) tal vez difiera proyecto otro. como dicho varias veces este libro, equipo del software debe trabajar para mantenerlo sencillo. sólo deben usarse elementos modelado que agreguen valor modelo. . modelado basado escenarios aunque éxito sistema producto basado computadora mide muchas maneras, satisfacción del usuario ocupa primer lugar lista. entiende cómo desean interac-tuar los usuarios finales ( otros actores) con sistema, equipo del software estará mejor preparado para caracterizar adecuadamente los requerimientos hacer análisis significativos requerimientos del softwaremodelos clasepor ejemplo,diagramas clase diagramas colaboración modelos ﬂujopor ejemplo,dfdmodelos datosmodelos basadosen escenariopor ejemplo,casos usohistorias usuario modelos comportamientopor ejemplo,diagramas estadodiagramas secuenciafigura . elementos del modelo análisis cita: “¿por qué construimos modelos? ¿por qué construir sólo sis-tema? respuesta que los construimos para que resalten enfaticen ciertas características críticas sistema, tiempo que ignoran otros aspectos del mismo.” yourdon¿cuáles son los diferentes puntos vista que usan para describir modelo requerimientos?? (-).indd (-).indd // ::// :: parte dos modelado modelos del diseño. entonces, modelado los requerimientos con uml comienza con creación escenarios forma casos uso, diagramas actividades diagramas tipo carril natación. .. creación caso preliminar uso alistair cockburn caracteriza caso uso como “contrato para comportamiento” [coc]. como dijo capítulo , “contrato” define forma que actor utiliza sistema basado computadora para alcanzar algún objetivo. esencia, caso uso capta las interacciones que ocurren entre los productores consumidores información sistema . esta sección estudiará forma que desarrollan los casos uso como parte los requerimientos actividad modelado. capítulo dijo que caso uso describe lenguaje claro escenario específico desde punto vista actor definido. pero, ¿cómo sabe sobre qué escribir, cuánto escribir sobre ello, cuán detallada hacer descripción cómo organizarla? son preguntas que deben responderse los casos uso han tener algún valor como herramienta para modelar los requerimientos. ¿sobre qué escribir? las dos primeras tareas ingeniería requerimientos —concep- ción indagación— dan información que necesita para comenzar escribir casos uso. las reuniones para recabar los requerimientos, dec, otros mecanismos para obtenerlos utilizan para identificar los participantes, definir alcance del problema, especificar los obje-tivos operativos generales, establecer prioridades, delinear todos los requerimientos funciona-les conocidos describir las cosas (objetos) que serán manipuladas por sistema. para comenzar desarrollar conjunto casos uso, enlistan las funciones activi- dades realizadas por actor específico. éstas obtienen una lista las funciones reque-ridas del sistema, por medio con versaciones con los participantes con evaluación los diagramas actividades (véase sección ..) desarrollados como parte del modelado los requerimientos. todo libro usará uml como notación para elaborar modelos. apéndice ofrece método breve enseñanza para aquellos lectores que estén familiarizados con más básico dicha notación. actor una persona específica sino rol que desempeña ésta ( dispositivo) contexto específico. actor “llama sistema para que entregue uno sus servicios” [coc]. los casos uso son una parte del modelado del análisis importancia especial para las interfaces. análisis interfaz estudia detalle capítulo .cita: “[los casos uso] simplemen- son una ayuda para definir que existe fuera del sistema (actores) que debe realizar sistema (casos uso).” ivar jacobson ciertas situaciones, los casos uso convierten mecanismo dominante ingeniería requerimientos. sin embargo, esto significa que deban descartarse otros métodos modelado cuando resulten apropiados.consejo escena: sala juntas, durante segunda reunión para recabar los requerimientos. participantes: jamie lazar, miembro del equipo del software; robbins, integrante del equipo del software; doug miller, gerente ingeniería software; tres miembros mercadotecnia; repre-sentante ingeniería del producto, facilitador. conversación:facilitador: hora que hablemos sobre función vigilan- cia casasegura. vamos desarrollar escenario usuario que accede función vigilancia. jamie: ¿quién juega papel del actor aquí?facilitador: creo que meredith (persona mercadotecnia) estado trabajando dicha funcionalidad. ¿por qué adoptas ese papel? meredith: quieres que hagamos misma forma que vez pasada, ¿verdad? facilitador: ... cierto modo.meredith: bueno, obvio que razón vigilancia permitir que propietario casa revise cuando encuentre fuera, así como poder grabar reproducir video que grabe... esa clase cosas. : ¿usaremos compresión para guardar video?casasegura desarrollo otro escenario preliminar uso (-).indd (-).indd // ::// :: modelado los requerimientos función (subsistema) vigilancia casasegura estudiada recuadro identifica las funciones siguientes (lista abreviada) que realizar actor propietario: • seleccionar cámara para ver. • pedir vistas reducidas todas las cámaras. • mostrar vistas las cámaras una ventana . • controlar ángulo acercamiento una cámara específica. • grabar salida cada cámara forma selectiva. • reproducir salida una cámara. • acceder por internet vigilancia con cámaras. medida que avanzan las conversaciones con participante (quien juega papel propie- tario), equipo que recaba los requerimientos desarrolla casos uso para cada una las funciones estudiadas. general, los casos uso escriben primero forma narración informal. requiere más formalidad, reescribe mismo caso con empleo formato estructurado, similar propuesto capítulo que reproduce recuadro más ade-lante, esta sección. para ilustrar esto, considere función acceder vigilancia con cámaras por internet-mostrar vistas cámaras (avc-mvc). participante que tenga papel del actor llamado propietario escribiría una narración como siguiente: caso uso: acceder vigilancia con cámaras por internet, mostrar vistas cámaras (avc-mvc) actor: propietario estoy una localidad alejada, puedo usar cualquier con software navegación apro- piado para entrar sitio web productos casasegura. introduzco identificación usuario dos niveles claves; una vez validadas, tengo acceso toda funcionalidad sistema instalado. para acceder vista una cámara específica, selecciono “vigilancia” los botones mostra-dos para las funciones principales. luego selecciono “escoger una cámara” aparece plano casa. después elijo cámara que interesa. alternativamente, puedo ver vista todas las -maras simultáneamente selecciono “todas las cámaras”. una vez que escojo una, selecciono “vista” ventana que cubre cámara aparece una vista con velocidad cuadro por segundo. quiero cambiar entre las cámaras, selecciono “escoger una cámara” desaparece vista original nuevo muestra plano casa. después, selecciono cámara que interesa. aparece una nueva ventana vistas.facilitador: buena pregunta, , pero por ahora pospondremos los aspectos implementación. ¿meredith? meredith: bien, básicamente hay dos partes función vigi- lancia... primera configura sistema, incluso plano plan- —tiene que haber herramientas que ayuden propietario hacer esto—, segunda parte función real vigilancia. como plano parte actividad configuración, centraré función vigilancia. facilitador (sonríe): quitaste las palabras boca.meredith: mmm... quiero tener acceso función vigilancia, sea por por internet. tengo sensación que acceso por internet usaría con más frecuencia. cualquier manera, qui-siera poder mostrar vistas cámara una controlar ángulo acercamiento una cámara particular. especificaría cámara seleccionándola plano casa. también quiero poder bloquear acceso una más cámaras con una clave deter-minada. además, desearía tener opción ver pequeñas venta-nas con vistas todas las cámaras luego escoger una que desee agrandar. jamie: ésas llaman vistas reducidas.meredith: bien, entonces quiero vistas reducidas todas las cámaras. también quisiera que interfaz función vigilancia tuviera mismo aspecto sensación que todas las demás del siste- casasegura. quiero que sea intuitiva, que significa que tenga que leer manual para usarla. facilitador: buen trabajo. ahora, veamos esta función con poco más detalle… (-).indd (-).indd // ::// :: parte dos modelado una variación narrativa del caso uso presenta interacción como una secuencia orde- nada acciones del usuario. cada acción está representada como enunciado declarativo. visitar función acs-dcv, escribiría siguiente: caso uso: acceder vigilancia con cámaras por internet, mostrar vistas cámaras (avc-mvc) actor: propietario . propietario accede sitio web productos casasegura. . propietario introduce identificación usuario. . propietario escribe dos claves (cada una menos ocho caracteres longitud). . sistema muestra los botones todas las funciones principales. . propietario selecciona “vigilancia” los botones las funciones principales. . propietario elige “seleccionar una cámara”. . sistema presenta plano casa. . propietario escoge ícono una cámara plano casa. . propietario selecciona botón “vista”. . sistema presenta ventana vista identificada con elección cámara. . sistema muestra video dentro ventana velocidad cuadro por segundo. importante observar que esta presentación secuencia considera interacciones alterna- tivas ( narración fluye con más libertad representa varias alternativas). los casos este tipo ocasiones denominan escenarios primarios [sch]. .. mejora caso uso preliminar para entender por completo función que describe caso uso, esencial describir inter-acciones alternativas. después evalúa cada paso escenario primario, planteando las preguntas siguientes [sch]: • ¿ actor puede emprender otra acción este punto? • ¿ posible que actor encuentre alguna condición error este punto? así fuera, ¿cuál podría ser? • este punto, ¿ posible que actor encuentre otro comportamiento (por ejemplo, alguno que sea invocado por cierto evento fuera del control del actor)? ese caso, ¿cuál sería? las respuestas estas preguntas dan como resultado creación conjunto escenarios secundarios que forman parte del caso uso original, pero que representan comportamientos alternativos. por ejemplo, considere los pasos del escenario primario descrito: . propietario elige “seleccionar una cámara”. . sistema presenta plano casa. ¿ actor puede emprender otra acción este punto? respuesta “”. analizar narra- ción flujo libre, actor puede escoger mirar vistas todas las cámaras simultáneamente. entonces, escenario secundario sería “observar vistas instantáneas todas las cámaras”. ¿ posible que actor encuentre alguna condición error este punto? cualquier número condiciones error puede ocurrir cuando opera sistema basado computadora. este contexto, sólo consideran las condiciones que sean probables como resultado directo acción descrita los pasos . nuevo, respuesta “”. tal vez nunca haya confi-gurado plano con íconos cámara. entonces, elegir “seleccionar una cámara” como cita: “los casos uso emplean muchos procesos [ software]. nuestro favorito que iterativo guiado por riesgo.” gerl schneider jason winters cuando desarrollo caso uso, ¿cómo examino los cursos alternativos acción?? (-).indd (-).indd // ::// :: modelado los requerimientos resultado una condición error: “ hay plano configurado para esta casa.” esta condición error convierte escenario secundario. este punto, ¿ posible que actor encuentre otro comportamiento (por ejemplo, alguno que sea invocado por cierto evento fuera del control del actor)? otra vez, respuesta “”. medida que ocurran los pasos , sistema puede hallar una condición alarma. esto dará como resultado que sistema desplegará una notificación especial alarma (tipo, ubicación, acción del sistema) proporcionará actor varias opciones relevantes según naturaleza alarma. como este escenario secundario puede ocurrir cualquier momento para práctica-mente todas las interacciones, vuelve parte del caso uso avc-mvc. vez ello, desarrollará caso uso diferente —condición alarma encontrada — que hará referencia desde otros casos según requiera. cada una las situaciones descritas los párrafos precedentes caracteriza como una excepción caso uso. una excepción describe una situación ( sea condición falla - ternativa elegida por actor) que ocasiona que sistema presente comportamiento algo distinto. cockburn [coc] recomienda uso una sesión “lluvia ideas” para obtener conjunto razonablemente complejo excepciones para cada caso uso. además las tres preguntas generales sugeridas esta sección, también deben explorarse los siguientes -pectos: • ¿existen casos los que ocurra alguna “función validación” durante este caso uso? esto implica que función validación invocada podría ocurrir una potencial condición error. • ¿hay casos los que una función ( actor) soporte falle responder manera apropiada? por ejemplo, una acción usuario espera una respuesta pero función que responder cae. • ¿ mal desempeño del sistema como resultado acciones inesperadas impropias? por ejemplo, una interfaz con base web responde con demasiada lentitud, que como resultado que usuario haga selecciones múltiples botón procesa-miento. estas selecciones forman modo equivocado , última instancia, generan error. lista extensiones desarrollada como consecuencia preguntar responder estas pregun-tas debe “racionalizarse” [coc] con uso los siguientes criterios: una excepción debe describirse dentro del caso uso software puede detectar debe manejarla una vez detectada. ciertos casos, una excepción precipitará desarrollo otro caso uso ( manejar condición descrita). .. escritura caso uso formal ocasiones, para modelar los requerimientos suficiente con los casos uso informales presentados sección ... sin embargo, cuando caso uso involucra una actividad crítica cuando describe conjunto complejo etapas con número significativo -cepciones, deseable enfoque más formal. caso uso avc-mvc mostrado recuadro página sigue guión común para los casos uso formales. objetivo contexto identifica alcance general del caso este caso, otro actor, administrador del sistema, tendría que configurar plano casa, instalar ini- cializar todas las cámaras (por ejemplo, asignar una identificación los equipos) probar cada una para garan- tizar que encuentren accesibles por sistema través del plano casa. (-).indd (-).indd // ::// :: parte dos modelado uso. precondición describe que sabe que verdadero antes que inicie caso uso. disparador ( trigger) identifica evento condición que “hace que comience caso uso” [coc]. escenario enlista las acciones específicas que requiere actor, las respuestas apropiadas del sistema. las excepciones identifican las situaciones detectadas cuando mejora caso uso preliminar (véase sección ..). pueden incluirse encabezados adiciona- les explican por mismos forma razonable. caso uso: acceder vigilancia con cámaras por internet, mostrar vistas cámaras (avc- mvc). iteración: , última modificación: enero por . raman. actor principal: propietario. objetivo contexto: ver salida las cámaras colocadas casa desde cualquier ubicación remota por medio internet. precondiciones: sistema debe estar configurado por completo; deben obtenerse las identifi-caciones claves usuario apropia-das. disparador: propietario decide ver dentro casa mientras está fuera. escenario: . propietario registra sitio web productos casasegura. . propietario introduce identificación usuario. . propietario proporciona dos claves (cada una con longitud menos ocho caracteres). . sistema despliega todos los botones las funciones princi- pales. . propietario selecciona “vigilancia” entre los botones fun- ciones principales. . propietario escoge “seleccionar una cámara”. . sistema muestra plano casa. . propietario selecciona ícono cámara plano casa. . propietario pulsa botón “vista”. . sistema muestra ventana vista cámara identifi- cada. . sistema presenta una salida video dentro ventana vistas, con una velocidad cuadro por segundo.excepciones: . identificación las claves son incorrectas reconocen (véase caso uso validar identificación claves). . función vigilancia está configurada para este sistema ( sistema muestra mensaje error apropiado; véase caso uso configurar función vigilancia). . propietario selecciona “mirar vistas reducidas todas las cámaras” (véase caso uso mirar vistas reducidas todas las cámaras). . dispone configurado plano casa ( muestra mensaje error apropiado véase caso uso configurar plano casa). . encuentra una condición alarma (véase caso uso condición alarma encontrada). prioridad: moderada, por implementarse después las funciones básicas. cuándo estará disponible: tercer incremento. frecuencia uso: frecuencia moderada.canal actor: través navegador con base conexión internet. actores secundarios: administrador del sistema, cáma-ras. canales los actores secundarios: . administrador del sistema: sistema basado . . cámaras: conectividad inalámbrica. asuntos pendientes: . ¿qué mecanismos protegen uso autorizado esta capa- cidad por parte los empleados productos casasegura? . suficiente seguridad? acceso ilegal esta característica representaría una invasión grave privacidad. . ¿será aceptable respuesta del sistema por internet dado ancho banda que requieren las vistas las cámaras? . ¿desarrollaremos una capacidad que provea video una velocidad más alta cuadros por segundo cuando dispon- conexiones con ancho banda mayor?casasegura formato caso uso para vigilancia muchos casos, hay necesidad crear una representación gráfica escenario uso. sin embargo, representación con diagramas facilita comprensión, particular cuando escenario complejo. como dijo este libro, uml cuenta con capacidad hacer diagramas casos uso. figura . ilustra diagrama caso uso preliminar para producto casasegura. cada caso uso está representado por óvalo. esta sección sólo estudia caso uso avc-mvc.webref ¿cuándo terminado escribir casos uso? para análisis benéfico esto, consulte dirección ootips.org/use-cases-done.html (-).indd (-).indd // ::// :: modelado los requerimientos toda notación modelado tiene sus limitaciones, del caso uso excepción. como cualquier otra forma descripción escrita, caso uso tan bueno como sea() () autor(). descripción poco clara, caso uso será confuso ambiguo. caso uso centra los requerimientos funcionales comportamiento, por general inapropiado para requerimientos disfuncionales. para situaciones las que modelo -querimientos deba tener detalle precisión significativos (por ejemplo, sistemas críticos -guridad), tal vez sea suficiente caso uso. sin embargo, modelado basado escenarios apropiado para gran mayoría todas las situaciones que encontrará ingeniero software. desarrolla bien, caso uso proporciona beneficio sustancial como herramienta modelado. . modelos uml que proporcionan caso uso hay muchas situaciones modelado requerimientos las que modelo basado texto —incluso uno tan sencillo como caso uso— tal vez brinde información forma clara concisa. tales casos, posible elegir entre una amplia variedad modelos uml gráficos. .. desarrollo diagrama actividades diagrama actividad uml enriquece caso uso proporcionar una representación gráfica del flujo interacción dentro escenario específico. diagrama actividades similar uno flujo, utiliza rectángulos redondeados para denotar una función específica del sistema, flechas para representar flujo través éste, rombos decisión para ilustrar una ramificación las decisiones (cada flecha que salga del rombo etiqueta) líneas continuas para indicar que están ocurriendo actividades paralelo. figura . presenta diagrama actividades para caso uso avc-mvc. debe observarse que diagrama actividades agrega detalles adicionales que mencionan directamente (pero que están implícitos) caso uso. por ejemplo, usuario quizá sólo haga algunos intentos introducir identificación password. esto representa por rombo decisión debajo “mensaje para que repita entrada”.propie- tarioacceso por internet las cámaras vigilancia conﬁgura los parámetros del sistema casasegura activa alarmacámarascasasegurafigura . diagrama caso uso preliminar para sistema casasegura punto clave diagrama actividades uml representa las acciones decisiones que ocurren cuando realiza cierta función. (-).indd (-).indd // ::// :: parte dos modelado .. diagramas canal (swimlane) diagrama canal uml una variación útil del diagrama actividades permite repre- sentar flujo actividades descritas por caso uso; mismo tiempo, indica qué actor ( hubiera muchos involucrados caso específico uso) clase análisis ( estudia más adelante, este capítulo) responsable acción descrita por rectángulo actividad. las responsabilidades representan con segmentos paralelos que dividen diagrama forma vertical, como los canales carriles una alberca. son tres las clases análisis: propietario, cámara interfaz, que tienen responsabilidad directa indirecta contexto del diagrama actividades representado figura .. relación con figura ., diagrama actividades reacomodó para que las actividades asociadas con una clase análisis particular queden dentro del canal dicha clase. por ejem-plo, clase interfaz representa interfaz usuario como propietario. diagrama actividades tiene dos mensajes que son responsabilidad interfaz: “mensaje para que repita entrada” “mensaje para otra vista”. estos mensajes las decisiones asociadas con ellos caen dentro del canal interfaz. sin embargo, las flechas van ese canal regreso propietario, donde ocurren las acciones éste. los casos uso, junto con los diagramas actividades canal, están orientados procedimiento. representan manera que los distintos actores invocan funciones espe-cíficas ( otros pasos del procedimiento) para satisfacer los requerimientos del sistema. pero introducir password identiﬁcación usuario seleccionar una función principalpassword identiﬁcación válidas mensaje para que repita entradapasswords identiﬁcación inválidas hay intentos entrada hay intentos entradaseleccionar vigilanciatambién pueden seleccionarse otras funciones vistas reducidas seleccionar una cámara especíﬁca seleccionar ícono cámara mensaje para otra vistaseleccionar una cámara especíﬁca, vista reducida salir esta función ver otra cámaraver salida cámara una ventana etiquetadafigura . diagrama actividades para función acceder vigilancia con cámaras por internet, mostrar vistas cámaras. punto clave diagrama canal (swimlane) representa flujo acciones decisiones indica qué actores efectúan cada una ellas. cita: “ buen modelo guía pensa-miento; uno malo desvía.” brian marick (-).indd (-).indd // ::// :: modelado los requerimientos una vista del procedimiento los requerimientos representa una sola dimensión del sistema. sección . estudia espacio información forma que representan los datos requerimientos. . conceptos modelado datos los requerimientos del software incluyen necesidad crear, ampliar hacer interfaz con una base datos, deben construirse manipularse estructuras datos complejas, equipo del software tal vez elija crear modelo datos como parte del modelado general los requerimientos. ingeniero analista software define todos los objetos datos que procesan dentro del sistema, relación entre ellos otro tipo información que sea pertinente para las relaciones. diagrama entidad-relación (der) aborda dichos aspectos representa -dos los datos que introducen, almacenan, transforman generan dentro una aplicación. .. objetos datos objeto datos una representación información compuesta que debe ser entendida por software. información compuesta quiere decir algo que tiene varias propiedades atributos introducir password identiﬁcación usuario seleccionar una función principalpasswords identiﬁcación válidas mensaje para que repita entradapasswords identiﬁcación inválidas hay intentos entrada hay intentos entradaseleccionar vigilanciatambién pueden - leccionarse otras fun- ciones vistas reducidas seleccionar una cámara especíﬁca seleccionar ícono cámara generar salida videoseleccionar una cámara especíﬁca, vista reducida salir esta función ver otra cámarapropietario cámara interfaz mensaje para otra vista ver salida cámara una ventana etiquetada figura . diagrama canal para función acceder vigilancia con cámaras porinternet, mostrar vistas cámaras webref dirección hay información útil sobre modelado datos. ¿cómo manifiesta objeto datos contexto una aplicación?? (-).indd (-).indd // ::// :: parte dos modelado diferentes. por tanto, ancho ( solo valor) sería objeto datos válido, pero las - mensiones (que incorporan altura, ancho profundidad) podrían definirse como objeto. objeto datos puede ser una entidad externa (por ejemplo, cualquier cosa que produzca consuma información), una cosa (por ejemplo, informe pantalla), una ocurrencia (como una llamada telefónica) evento (por ejemplo, una alarma), rol ( vendedor), una unidad organizacional (por ejemplo, departamento contabilidad), lugar (como una bodega) estructura (como archivo). por ejemplo, una persona auto pueden considerarse como objetos datos tanto cada uno define términos conjunto atributos. des-cripción del objeto datos incorpora ésta todos sus atributos. objeto datos contiene sólo datos —dentro hay referencia las operaciones que apliquen sobre los datos—. entonces, objeto datos puede representarse forma tabla, como que muestra figura .. los encabezados tabla reflejan atributos del objeto. este caso, auto define términos fabricante, modelo, número serie, tipo - rrocería, color propietario . cuerpo tabla representa instancias específicas del objeto datos. por ejemplo, chevy corvette una instancia del objeto datos auto. .. atributos los datos los atributos los datos definen las propiedades objeto datos tienen una tres - ferentes características. usan para ) nombrar una instancia del objeto datos, ) describir instancia ) hacer referencia otra instancia otra tabla. además, debe definirse como identificador uno más los atributos — decir, atributo identificador convierte una “llave” cuando desea encontrar una instancia del objeto datos—. ciertos casos, los valores para (los) identificador() son únicos, aunque esto una exigencia. relación con objeto datos auto, identificador razonable sería número serie . conjunto atributos que apropiado para objeto datos determinado define entendiendo contexto del problema. los atributos para auto podrían servir bien para una aplicación que usara departamento vehículos motorizados, pero serían inútiles para una compañía automotriz que necesitara hacer software control manufactura. este último caso, los atributos para auto quizá también incluyan número serie, tipo carrocería color, pero tendrían que agregarse muchos otros (por ejemplo, código interior, tipo tracción, indicador paquete recorte, tipo transmisión , etc.) para hacer auto objeto significativo contexto control manufactura.punto clave objeto datos una representación cualquier información compuesta que procese software. punto clave los atributos nombran objeto datos, describen sus características , ciertos casos, hacen referencia otro objeto. esta distinción separa objeto datos clase objeto definidos como parte del enfoque orientado obje- tos (véase apéndice ).fabricante modelo número serie carrocería color propietarioidentiﬁcador instancialexus chevybmwfordls. . .. . .. . .. . .sedándeportivocupésedánblancorojoblancoazulrspccdljlblfliga objeto datos con otro, este caso propietarionombrar los atributos atributos descriptivosatributos referenciales figura . representación tabular objetos datoswebref para aquellos que intentan hacer modelado datos, importante concepto llamado “normalización”. dirección encuentra una introducción útil. (-).indd (-).indd // ::// :: modelado los requerimientos .. relaciones los objetos datos están conectados entre diferentes maneras. considere dos objetos datos, persona auto. estos objetos representan con notación simple que ilustra figura .). establece una conexión entre persona auto porque ambos objetos están - lacionados. pero, ¿cuál esa relación? para determinarlo, debe entenderse papel las personas (propiedad, este caso) los autos dentro del contexto del software que ela-borar. establece conjunto parejas objeto/relación que definan las relaciones relevan-tes. por ejemplo, • una persona posee auto. • una persona asegurada para que maneje auto. las relaciones posee asegurada para que maneje definen las conexiones relevantes entre persona auto. figura .) ilustra estas parejas objeto-relación. las flechas esa figura dan información importante sobre dirección relación frecuente que reduzcan las ambigüedades interpretaciones erróneas. los lectores que estén familiarizados con los conceptos terminología orientación objetos deben consultar breve instructivo que presenta apéndice . analizar objetos datos común que surja una pre- gunta: ¿ objeto datos mismo que una clase orientada objetos? respuesta “”. objeto datos define aspecto datos compuestos; decir, incorpora conjunto características datos individuales (atributos) conjunto nombre ( del objeto datos). una clase orientada objetos encierra atributos datos, pero también incorpora las operaciones (métodos) que los manipulan que están determinadas por dichos atributos. además, definición clases implica una infraestructura amplia que parte del enfoque ingeniería software orientada objetos. las clases comu-nican entre por medio mensajes, organizan jerarquías tienen características hereditarias para los objetos que son una instan-cia una clase.información objetos datos clases orientadas objetos: ¿son mismo? persona auto ) conexión básica entre objetos datos posee asegurada para que maneje ) relaciones entre los objetosde datospersona autofigura . relaciones entre objetos datospunto clave las relaciones indican manera que los objetos datos conectan entre . (-).indd (-).indd // ::// :: parte dos modelado pareja objeto-relación piedra angular del mode- datos. estas parejas representan gráficamente con uso del diagrama entidad-relación (der). der fue propuesto por primera vez por peter chen [che] para diseñar sistemas bases datos relacionales sido ampliado por otras personas. identifica conjunto componentes primarios para der: objetos datos, atributos, relaciones distintos indicadores tipo. propósito principal del der representar objetos datos sus relaciones. presentó notación der básica. los objetos datos representan con rectángulo etiquetado. las relaciones indican con una línea etiquetada que conecta objetos. ciertas variantes del der, línea conexión contiene rombo con leyenda relación. las conexiones entre los objetos datos las relaciones establecen con empleo varios símbolos especiales que indican cardinalidad modalidad. lector está interesado obtener más información sobre modelado datos diagrama entidad-relación, consulte [hob] [sim].información diagramas entidad-relación aunque algunas aplicaciones diseño bases datos aún emplean der, ahora utiliza notación uml (véase apéndice ) para diseño datos. cardinalidad una pareja objeto-relación especifica “ número ocurrencias uno [objeto] que rela- ciona con número ocurrencias otro [objeto]” [til]. modalidad una relación hay necesi- dad explícita para que ocurra relación ésta opcional. modalidad una ocurrencia relación obligatoria. las herramientas mencionadas aquí son obligatorias sino una muestra las que hay esta categoría. mayoría casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores.objetivo: las herramientas modelado datos dan ingeniero software capacidad representar objetos datos, sus características relaciones. usan sobre todo para aplicaciones grandes bases datos otros proyectos sis-temas información, proveen medios automatizados para crear diagramas completos entidad-relación, diccionarios objetos datos modelos relacionados. mecánica: las herramientas esta categoría permiten que usua- rio describa objetos datos sus relaciones. ciertos casos, utilizan notación der. otros, modelan relaciones con empleo meca-nismo diferente. frecuente que las herramientas esta categoría usen como parte del diseño una base datos que permitan creación modelo con generación esquema para siste-mas comunes administración bases datos comunes (dbms).herramientas representativas: allfusion erwin, desarrollada por computer associates (www. .com), ayuda diseño objetos datos, estructura apropiada elementos clave para las bases datos. /studio, desarrollada por embarcadero software (www. embarcadero.com), apoyo modelado entidad-relación. oracle designer, desarrollada por oracle systems ( com), “modela procesos negocios, entidades relaciones datos [que] transforman diseños para los que generan aplicaciones bases datos completas”. visible analyst, desarrollada por visible systems ( com), apoyo varias funciones modelado del análisis, incluso modelado datos.herramientas software modelado datos . modelado basado clases modelado basado clases representa los objetos que manipulará sistema, las operaciones (también llamadas métodos servicios) que aplicarán los objetos para efectuar manipu- lación, las relaciones (algunas ellas jerárquicas) entre los objetos las colaboraciones que tienen lugar entre las clases definidas. los elementos modelo basado clases incluyen las clases los objetos, atributos, operaciones, modelos clase-responsabilidad-colaborador (crc), diagramas colaboración paquetes. las secciones siguientes presenta una serie lineamientos informales que ayudarán identificación representación. (-).indd (-).indd // ::// :: modelado los requerimientos .. identificación las clases análisis mirar una habitación, observa conjunto objetos físicos que identifican, clasifican definen fácilmente ( términos atributos operaciones). pero cuando “” espacio del problema una aplicación software, las clases ( objetos) son más difíciles concebir. comienza por identificar las clases mediante análisis los escenarios uso desarro- llados como parte del modelo requerimientos ejecución “análisis gramatical” [abb] sobre los casos uso desarrollados para sistema que construir. las clases determinan subrayando cada sustantivo frase que las incluya para introducirlo una tabla simple. deben anotarse los sinónimos. clase (sustantivo) requiere para implementar una solución, entonces forma parte del espacio solución; otro modo, sólo necesaria para describir solución, parte del espacio del problema. pero, ¿qué debe buscarse una vez identificados todos los sustantivos? las clases análisis manifiestan uno los modos siguientes: • entidades externas (por ejemplo, otros sistemas, dispositivos personas) que producen consumen información que usará sistema basado computadora. • cosas (reportes, pantallas, cartas, señales, etc.) que forman parte del dominio infor-mación para problema. • ocurrencias eventos (como una transferencia propiedad ejecución una serie movimientos robot) que suceden dentro del contexto operación del sistema. • roles (gerente, ingeniero, vendedor, etc.) que desempeñan las personas que interactúan con sistema. • unidades organizacionales (división, grupo, equipo, etc.) que son relevantes para una aplicación. • lugares (piso manufactura plataforma carga) que establecen contexto del problema función general del sistema. • estructuras (sensores, vehículos cuatro ruedas, computadoras, etc.) que definen una clase objetos clases relacionadas éstos. esta clasificación sólo una muchas propuestas bibliografía. por ejemplo, budd [bud] sugiere una taxonomía clases que incluye productores (fuentes) consumidores (- mideros) datos, administradores datos, vista, clases observador clases auxiliares. también importante darse cuenta que son las clases objetos. general, una clase nunca debe tener “nombre procedimiento imperativo” [cas]. por ejemplo, los desarrolladores del software sistema imágenes médicas definieron objeto con nombre invertirimagen incluso inversióndeimagen, cometerían error sutil. imagen obtenida del software podría ser, por supuesto, una clase (algo que parte del dominio información). inversión imagen una operación que aplica objeto. probable que inversión esté definida como una operación para objeto imagen, pero estaría como clase separada con connotación “inversión imagen”. como afirma cashman [cas]: “ intento orientación objetos contener, pero mantener separados, los datos las operaciones sobre ellos”. para ilustrar cómo podrían definirse las clases del análisis durante las primeras etapas del modelado, considere análisis gramatical (los sustantivos están subrayados, los verbos apa-cita: “ problema realmente difícil descubrir primer lugar cuáles son los objetos correctos[clases].” carl argila sección .. estudia otra clasificación importante que define las clases entidad, frontera controladora.¿cómo manifiestan las clases tantos elementos del espacio solución?? (-).indd (-).indd // ::// :: parte dos modelado recen cursivas) una narración procesamiento para función seguridad casa- segura. función seguridad casasegura permite que propietario configure sistema seguridad cuando instala, vigila todos los sensores conectados sistema seguridad interactúa con pro- pietario través internet, una panel control. durante instalación, casasegura utiliza para programar configurar sistema. asigna cada sensor número tipo, programa password maestro para activar desactivar sistema introducen números telefónicos para marcar cuando ocurre evento sensor. cuando reconoce evento sensor, software invoca una alarma audible instalada sistema. después tiempo retraso que especifica propietario durante las actividades con- figuración del sistema, software marca número telefónico servicio monitoreo, propor- ciona información acerca ubicación reporta naturaleza del evento detectado. número - lefónico vuelve marcar cada segundos hasta que obtiene conexión telefónica. propietario recibe información seguridad través panel control, navega- dor, que conjunto llama interfaz. interfaz despliega mensajes aviso información del estado del sistema panel control, ventana del navegador. interacción del propie-tario tiene siguiente forma… con los sustantivos proponen varias clases potenciales: clase potencial clasificación general propietario rol entidad externa sensor entidad externa panel control entidad externa instalación ocurrencia sistema (alias sistema seguridad) cosanúmero, tipo objetos, atributos sensor password maestro cosa número telefónico cosa evento sensor ocurrencia alarma audible entidad externa servicio monitoreo unidad organizacional entidad externa lista continuará hasta que hayan considerado todos los sustantivos narrativa procesamiento. observe que cada entrada lista llama objeto potencial. lector debe considerar cada una antes tomar decisión final. coad yourdon [coa] sugieren seis características selección que deben usarse cuando considere cada clase potencial para incluirla modelo análisis: . información retenida. clase potencial será útil durante análisis sólo debe recor-darse información sobre ella para que sistema pueda funcionar . . servicios necesarios. clase potencial debe tener conjunto operaciones identifi-cables que cambien cierta manera valor sus atributos. una narración procesamiento similar caso uso estilo, pero algo distinto propósito. narración procesamiento hace una descripción general función que desarrollar. esce- nario escrito desde punto vista actor. obstante, importante observar que análisis gramatical también puede emplearse para todo caso uso desarrollado como parte obtención requerimientos (indagación). análisis gramatical prueba todo, pero impulso excelente para arrancar tienen dificultades para definir objetos datos las transformaciones que operan sobre ellos.consejo ¿cómo determino una clase potencial debe, realidad, ser una clase análisis?? (-).indd (-).indd // ::// :: modelado los requerimientos . atributos últiples. durante análisis los requerimientos, atención debe estar información “principal”; realidad, una clase con solo atributo puede ser útil - rante diseño, pero probable que durante actividad análisis represente -jor como atributo otra clase. . atributos com unes. para clase potencial define conjunto atributos apli- can éstos todas las instancias clase. . oper aciones comunes. define conjunto operaciones para clase potencial éstas aplican todas las instancias clase. . requerimientos esenciales. las entidades externas que aparezcan espacio del pro-blema que produzcan consuman información esencial para operación cual-quier solución para sistema casi siempre definirán como clases modelo requerimientos. para que considere una clase legítima para inclusión modelo requerimientos, objeto potencial debe satisfacer todas ( casi todas) las características anteriores. decisión incluir clases potenciales modelo análisis algo subjetiva, una evaluación poste-rior tal vez haga que objeto descarte incluya nuevo. sin embargo, primer paso del modelado basado clases definición éstas, deben tomarse las medidas respecti-vas (aun las subjetivas). con esto mente , aplicarán las características selección lista clases potenciales casasegura: clase potencial número característica que aplica propietario rechazada: fallan, aunque aplica sensor aceptada: aplican todas panel control aceptada: aplican todas instalación rechazada sistema (alias sistema seguridad) aceptada: aplican todasnúmero, tipo rechazada: fallan, atributos sensores password maestro rechazada: falla número telefónico rechazada: falla evento sensor aceptada: aplican todas alarma audible aceptada: aplican , , , servicio monitoreo rechazada: fallan aunque aplica debe notarse que: ) lista anterior exhaustiva; para completar modelo tendrían que agregarse clases adicionales; ) algunas las clases potenciales rechazadas convertirán atributos para otras que fueron aceptadas (por ejemplo, número tipo son atributos sensor, password maestro número telefónico pueden convertirse atributos sistema); ) diferentes enunciados del problema harían que tomaran decisiones distintas para “aceptar rechazar” (por ejemplo, cada propietario tuviera una clave individual identificara con reconoci-miento voz, clase propietario satisfaría las características , aceptaría). .. especificación atributos los atributos describen una clase que sido seleccionada para incluirse modelo - querimientos. esencia, son los atributos los que definen clase (esto aclara que significa clase contexto del espacio del problema). por ejemplo, fuera construir sistema que analiza estadísticas jugadores béisbol profesionales, los atributos clase jugador serían muy distintos los que tendría misma clase cuando usara contexto del sis-cita: “las clases luchan, algunas triunfan, otras son eliminadas.” mao tse tung punto clave los atributos son conjunto objetos datos que definen por completo clase contexto del problema. (-).indd (-).indd // ::// :: parte dos modelado tema pensiones dicho deporte. primera, atributos tales como nombre, porcentaje bateo, porcentaje fildeo, años jugados juegos jugados serían relevantes. para segunda, algunos los anteriores serían significativos, pero otros sustituirían ( crearían) por atributos - les como salario promedio, crédito hacia retiro completo, opciones del plan pensiones elegido, dirección correo , etcétera. para desarrollar conjunto atributos significativos para una clase análisis, debe estu- diarse cada caso uso seleccionar aquellas “cosas” que “pertenezcan” razonablemente clase. además, debe responderse pregunta siguiente para cada clase: “¿qué aspectos los datos (compuestos elementales) definen por completo esta clase contexto del problema cuestión?” para ilustrarlo, considera clase sistema definida para casasegura. propietario confi- gura función seguridad para que refleje información los sensores, respuesta alarma, activación desactivación, identificación, etc. estos datos compuestos repre-sentan del modo siguiente: información identificación = identificación del sistema + número telefónico verificación + estado del sistemainformación respuesta alarma = tiempo retraso + número telefónicoinformación activación desactivación = password maestro + número intentos permisibles + password temporal cada uno los datos derecha del signo igual podría definirse más, hasta nivel elemen- tal, pero para nuestros propósitos constituye una lista razonable atributos para clase sis- tema (parte sombreada figura .). los sensores forman parte del sistema general casasegura, pero están enlistados como datos atributos figura .. sensor definió como clase, asociarán múltiples objetos sensor con clase sistema. general, evita definir algo como atributo más uno asociarse con clase. .. definición las operaciones las operaciones definen comportamiento objeto. aunque existen muchos tipos distintos operaciones, por general dividen cuatro categorías principales: ) operaciones que manipulan datos cierta manera (por ejemplo, los agregan, eliminan, editan, seleccionan, etc.), ) operaciones que realizan cálculo, ) operaciones que preguntan sobre estado objeto ) operaciones que vigilan objeto cuanto ocurrencia evento con-trol. estas funciones llevan cabo con operaciones sobre los atributos sobre asociaciones éstos (véase sección ..). por tanto, una operación debe tener “conocimiento” -turaleza los atributos las asociaciones clase. como primera iteración obtener conjunto operaciones para una clase análisis, estudia otra vez una narración del procesamiento ( caso uso) eligen aquellas que per-tenezcan razonablemente clase. para lograr esto, nuevo efectúa análisis gramatical aíslan los verbos. algunos éstos serán operaciones legítimas conectarán con facili-dad una clase específica. por ejemplo, narración del procesamiento casasegura presentada este capítulo, observa que “ asigna sensor número tipo” “ pro- grama password maestro para activar desactivar sistema” indican cierto número cosas: • que una operación asignar( ) relevante para clase sensor. • que aplicará una operación programar( ) clase sistema. • que activar( ) desactivar( ) son operaciones que aplican clase sistema.cuando definen operaciones para una clase análisis, hay que centrarse comportamiento orientado problema los comportamientos requeridos para implementación.consejo (-).indd (-).indd // ::// :: modelado los requerimientos hasta hacer más investigaciones, probable que operación programar( ) divida cierto número suboperaciones específicas adicionales que requieren para configurar sistema. por ejemplo, programar( ) implica especificación números telefónicos, configu- ración las características del sistema (por ejemplo, crear tabla sensores, introducir las características alarma, etc.) introducción () clave(). pero, momento, progra- mar( ) especifica como una sola operación. además del análisis gramatical, obtiene más perspectiva sobre otras operaciones considera comunicación que ocurre entre los objetos. éstos comunican con transmisión mensajes entre . antes continuar con especificación operaciones, estudiará esto con más detalle.sistema programa( ) pantalla( )reiniciar( )cola( )activar( )desactivar( )identiﬁcación del sistemaveriﬁcación del número telefónicoestado del sistematiempo retrasonúmero telefónicopassword maestropassword temporalnúmero intentosfigura . diagrama clase para clase sistema escena: cubículo , cuando comienza modelado los requerimientos. participantes: jamie, vinod , todos ellos miembros del equipo ingeniería software para casasegura. conversación:[ estado trabajando para obtener las clases partir del forma- del caso uso para avc-mvc (presentado recuadro ante-rior este capítulo) expone sus colegas las que obtenido]. : entonces, cuando propietario quiere escoger una cámara, tiene que elegir del plano. definí una clase llamada plano. éste diagrama.(observan figura ..) jamie: entonces, plano objeto que agrupa paredes, puer- tas, ventanas cámaras. eso significa esas líneas con leyendas, ¿ver-dad? : , llaman “asociaciones”. una clase asocia con otra acuerdo con las asociaciones que ven (las asociaciones estu-dian sección ..). vinod: decir, plano real está constituido por paredes que con- tienen interior cámaras sensores. ¿cómo sabe plano dónde colocar estos objetos?: sabe, pero las otras clases . mira los atributos , diga-mos, segmentodepared, que usa para construir una pared. segmento muro tiene coordenadas inicio final, opera-ción draw( ) hace resto. jamie: mismo vale para las ventanas puertas. parece como cámara tuviera algunos atributos adicionales. : . los necesito para dar información del alcance acerca- miento. vinod: tengo una pregunta. ¿por qué tiene cámara una identifi- cación pero las demás ? veo que tienes atributo llamado paredsiguiente. ¿cómo sabe segmentodepared cuál será pared siguiente? : buena pregunta, pero, como dijimos, ésa una decisión diseño, por que voy retrasar hasta... jamie: momento... apuesto que has imaginado. (sonríe con timidez): cierto, voy usar una estructura lista que modelaré cuando vayamos diseñar. somos puristas cuanto separar análisis diseño, nivel detalle podría parecer sospechoso. jamie: parece muy bien, pero tengo más preguntas.casasegura modelos clase (-).indd (-).indd // ::// :: parte dos modelado .. modelado clase-responsabilidad-colaborador (crc) modelado clase-responsabilidad-colaborador (crc) [wir] proporciona una manera sencilla identificación organización las clases que son relevantes para los requerimientos sistema producto. ambler [amb] describe modelado crc siguiente forma: modelo crc realidad conjunto tarjetas índice estándar que representan clases. las tarjetas dividen tres secciones. parte superior tarjeta escribe nombre clase, parte izquierda del cuerpo enlistan las responsabilidades clase derecha, los -laboradores. realidad, modelo crc hace uso tarjetas índice reales virtuales. objetivo desarro- llar una representación organizada las clases. las responsabilidades son los atributos ope-(jamie hace preguntas que dan como resultado modificaciones menores.) vinod: ¿tienes tarjetas crc para cada uno los objetos? así fuera, debemos actuar con ellas, sólo para estar seguros que hemos omitido nada.: estoy seguro cómo hacerlas. vinod: difícil verdad convienen. mostraré. cita: “ propósito las tarjetas crc que fallen pronto, con frecuencia forma barata. mucho más barato desechar tar-jetas que reorganizar una gran cantidad código fuente.” . horstman plano determinartipo( ) posicionarplano( )escala( )cambiar color( )tiponombredimensionesexteriores cámara determinartipo( ) trasladarubicación( )desplegaridentiﬁcación( )desplegarvista( )desplegaracercamiento( )tipoidentiﬁcaciónubicaciónvistadecampoángulodeaperturafijaracercamiento segmentodepared tipo coordenadasdeiniciocoordenadasfinalessiguientesegmentodepared determinartipo( ) dibujar( )ventana tipo coordenadasdeiniciocoordenadasfinalessiguienteventana determinartipo( ) dibujar( ) coloca dentro pared tipodimensionesdepared determinartipo( )calculardimensiones( ) puerta tipo coordenadasdeiniciocoordenadasfinalessiguientepuerta determinartipo( ) dibujar( ) parte usa para construir usa para construirse usa para construirfigura . diagrama clase para plano (véase análisis recuadro) (-).indd (-).indd // ::// :: modelado los requerimientos raciones relevantes para clase. pocas palabras, una responsabilidad “cualquier cosa que clase sepa haga” [amb]. los colaboradores son aquellas clases que requieren para dar una clase información necesaria fin completar una responsabilidad. general, una colaboración implica una solicitud información cierta acción. figura . ilustra una tarjeta crc índice sencilla para clase plano: lista res- ponsabilidades tarjeta crc preliminar está sujeta agregados modificaciones. las clases pared cámara anotan frente responsabilidad que requerirá colaboración. clases. inicio este capítulo presentaron lineamientos básicos para identificar clases objetos. taxonomía tipos clase presentada sección .. puede ampliarse con las siguientes categorías: • clases entidad, también llamadas clases modelo negocio, extraen directamente del enunciado del problema (por ejemplo, plano sensor). común que estas clases representen cosas almacenadas una base datos que persistan mientras dure aplicación ( menos que eliminen forma específica). • clases frontera utilizan para crear interfaz (por ejemplo, pantallas interactivas reportes impresos) que usuario mira con que interactúa cuando utiliza software. los objetos entidad contienen información que importante para los usuarios, pero muestran por mismos. las clases frontera diseñan con responsabilidad administrar forma que presentan los usuarios los objetos entidad. por ejemplo, una clase frontera llamada ventanadecámara tendría responsabilidad desplegar salida una cámara vigilancia para sistema casasegura. • clases controlador administran una “unidad trabajo” [uml] principio fin. decir, las clases controlador están diseñadas para administrar ) creación actuali-zación objetos entidad, ) las instancias los objetos frontera tanto obtienen información los objetos entidad, ) comunicación compleja entre conjuntos objetos ) validación datos comunicados entre objetos entre usuario aplicación. general, las clases controlador consideran hasta haber comenzado actividad diseño. responsabilidades. las secciones .. .. presentaron los lineamientos básicos para identificar responsabilidades (atributos operaciones). irfs-brock . [wir] sugieren cinco lineamientos para asignar responsabilidades las clases:class: des res llaaborat :class: coollaborator:class: ccollaborat :clase: plano descripción responsabilidad: colaborador: incorpora paredes, puertas ventanas muestra posición las cámaras videodeﬁne nombre tipo del plano administra posicionamiento del planoda escala plano para mostrarlo pantalla pared cámarafigura . modelo tarjeta crc índice webref dirección hay análisis excelente estos tipos clase. cita: “pueden clasificarse científica- mente los objetos tres grandes categorías: los que funcionan, los que descompo-nen los que pierden.” rusell baker ¿qué lineamientos aplican para asignar responsabilidades las clases?? (-).indd (-).indd // ::// :: parte dos modelado . inteligencia del sistema debe estar distribuida entr las clases para enfren- tar mejor las necesidades del problema. toda aplicación contiene cierto grado inteligencia, decir, que sistema sabe que puede hacer. esta inteligencia distribuye entre las clases diferentes maneras. las clases “tontas” (aquellas que tie-nen pocas responsabilidades) pueden modelarse para que actúen como subordinadas ciertas clases “inteligentes” (las que tienen muchas responsabilidades). aunque este enfoque hace directo flujo del control sistema, tiene algunas desventajas: con- centra toda inteligencia pocas clases, que hace que sea más difícil hacer cam-bios, tiende que requieran más clases por ello más trabajo desarrollo. inteligencia del sistema tiene una distribución más pareja entre las clases una aplicación, cada objeto sabe algo, sólo hace unas cuantas cosas (que por general están bien identificadas) cohesión del sistema mejora. esto facilita manteni- miento del software reduce efecto los resultados colaterales del cambio. para determinar inteligencia del sistema está distribuida forma apropiada, deben evaluarse las responsabilidades anotadas cada modelo tarjeta crc índice fin definir alguna clase tiene una lista demasiado larga responsabilidades. esto indica una concentración inteligencia. además, las responsabilidades cada clase deben tener mismo nivel abstracción. por ejemplo, entre las operaciones enlista-das para una clase agregada llamada revisarcuenta, revisor anota dos responsabi-lidades: hacer balance cuenta eliminar comprobaciones concluidas. primera operación (responsabilidad) implica procedimiento matemático complejo lógico. segunda una simple actividad oficina. como estas dos operaciones están mismo nivel abstracción, eliminar comprobaciones concluidas debe colocarse den- tro las responsabilidades revisarentrada, clase que está incluida clase agregada revisarcuenta. . cada esponsabilidad debe enunciarse del modo más general posible. este - neamiento implica que las responsabilidades generales (tanto atributos como operacio-nes) deben residir nivel elevado jerarquía clases (porque son generales aplicarán todas las subclases). . inf ormación comportamiento relacionado con ella deben residir dentro misma clase. esto logra principio orientado objetos llamado encapsula- miento. los datos los procesos que los manipulan deben empacarse como una unidad cohesiva. . inf ormación sobre una cosa debe localizarse con una sola clase, distri- buirse través muchas. una sola clase debe tener responsabilidad almace-nar manipular tipo específico información. general, esta responsabilidad debe ser compartida por varias clases. información está distribuida, más difícil dar mantenimiento software más complicado someterlo prueba. . cuando sea apr opiado, las responsabilidades deben compartirse entre clases relacionadas. hay muchos casos los que varios objetos relacionados deben tener mismo comportamiento mismo tiempo. por ejemplo, considere juego video que deba tener pantalla las clases siguientes: jugador, cuerpodeljugador, brazos- deljugador, piernasdeljugador cabezadeljugador. cada una estas clases tiene sus propios atributos (como posición, orientación, color velocidad) todas deben actuali- zarse desplegarse medida que usuario manipula una palanca juego. las res- cohesión concepto diseño que estudia capítulo . tales casos, puede ser necesario dividir clase una multiplicidad ellas completar subsistemas con objeto distribuir inteligencia modo más eficaz. (-).indd (-).indd // ::// :: modelado los requerimientos ponsabilidades actualizar( ) desplegar( ) deben, por tanto, ser compartidas por cada uno los objetos mencionados. jugador sabe cuando algo cambiado requiere - tualizarse( ). colabora con los demás objetos para obtener una nueva posición orien-tación, pero cada objeto controla propio despliegue pantalla. colaboraciones. una clase cumple sus responsabilidades una dos formas: ) usa sus propias operaciones para manipular sus propios atributos, con que satisface una responsabi-lidad particular ) colabora con otras clases. irfs-brock . [wir] definen las colabora- ciones del modo siguiente: las colaboraciones representan solicitudes que hace cliente servidor para cumplir con sus responsabilidades. una colaboración materialización del contrato entre cliente servidor [...] decimos que objeto colabora con otro , para cumplir una responsabilidad, necesita enviar otro objeto cualesquiera mensajes. una sola colaboración fluye una dirección: representa una -licitud del cliente servidor. desde punto vista del cliente, cada una sus colaboraciones está asociada con una responsabilidad particular implementada por servidor. las colaboraciones identifican determinando una clase puede cumplir cada responsabili- dad. así, entonces necesita interactuar con otra clase. ésa una colaboración. como ejemplo, considere función seguridad casasegura. como parte del procedi- miento activación, objeto paneldecontrol debe determinar están abiertos algunos sensores. define una responsabilidad llamada determinar-estado-delsensor( ). los sensores están abiertos, paneldecontrol debe fijar atributo estado como “ está listo”. información del sensor adquiere cada objeto sensor. por tanto, responsabilidad determinar-estado- delsensor( ) cumple sólo paneldecontrol trabaja colaboración con sensor. para ayudar identificar los colaboradores, estudian tres relaciones generales diferentes entre las clases [wir]: ) relación -parte-, ) relación tiene-conocimiento- ) relación depende-. los párrafos siguientes analizan brevemente cada una estas tres responsabilidades generales. todas las clases que forman parte una clase agregada conectan ésta por medio una relación -parte-. considere las clases definidas por juego mencionado antes, clase cuerpodeljugador -parte- jugador, igual que brazosdeljugador, piernasdeljugador cabezadeljugador. uml, estas relaciones representan como agregado que ilustra figura .. cuando una clase debe adquirir información otra, establece relación tiene-conocimien - . responsabilidad determinar-estado-delsensor( ) mencionada ejemplo ello. jugador cabezadeljugador cuerpodeljugador brazosdeljugador piernasdeljugadorfigura . una clase agregada compuesta (-).indd (-).indd // ::// :: parte dos modelado relación depende- significa que dos clases tienen una dependencia que determina por tiene-conocimiento- por -parte-. por ejemplo, cabezadeljugador siempre debe estar conectada cuerpodeljugador ( menos que juego video sea particularmente violento), pero cada objeto puede existir sin conocimiento directo del otro. atributo del objeto cabe- zadeljugador, llamado posición-central, determina partir posición central cuerpo- deljugador. esta información obtiene por medio tercer objeto, jugador, que obtiene cuerpodeljugador. entonces, cabezadeljugador depende- cuerpodeljugador. todos los casos, nombre clase colaboradora registra modelo tarjeta crc índice, junto responsabilidad que produce colaboración. por tanto, tarjeta índice con-tiene una lista responsabilidades las colaboraciones correspondientes que hacen que cumplan (véase figura .). cuando desarrollado modelo crc completo, los participantes revisan con - pleo del enfoque siguiente [amb]: . todos los participantes que intervienen revisión (del modelo crc) sub- conjunto del modelo tarjetas índice crc. deben separarse aquellas que colaboran ( modo que ningún revisor deba tener dos tarjetas que colaboren). . todos los escenarios casos uso ( los diagramas correspondientes) deben organi- zarse dos categorías. . líder revisión lee caso uso forma deliberada. cuando llega objeto con nombre , entrega una ficha persona que tenga tarjeta índice clase - rrespondiente. por ejemplo, caso uso casasegura contiene narración - guiente: propietario observa panel control casasegura para determinar sistema está listo para recibir una entrada. sistema está listo, propietario debe cerrar físicamente las puertas ventanas modo que indicador listo aparezca [ indicador está listo implica que sensor encuentra abierto, decir, que una puerta ventana está abierta]. cuando narración del caso uso líder revisión llega “panel con- trol”, entrega ficha persona que tiene tarjeta índice paneldecontrol. frase “implica que sensor está abierto” requiere que tarjeta índice contenga una respon- sabilidad que validará esta implicación (esto logra responsabilidad determinar-- tado-delsensor( ). junto responsabilidad, tarjeta índice encuentra sensor colaborador. entonces, ficha pasa objeto sensor. . cuando pasa ficha, pide poseedor tarjeta sensor que describa las res- ponsabilidades anotadas tarjeta. grupo determina una ( más) las respon-sabilidades satisfacen requerimiento del caso uso. . las responsabilidades colaboraciones anotadas las tarjetas índice acomo- dan caso uso, éstas modifican. anterior tal vez incluya definición nue-vas clases ( las tarjetas crc índice correspondientes) especificación las tarjetas existentes responsabilidades colaboraciones nuevas revisadas. este modo operar continúa hasta terminar caso uso. cuando han revisado todos los casos uso, continúa modelado los requerimientos. .. asociaciones dependencias muchos casos, dos clases análisis relacionan cierto modo con otra, forma muy parecida como dos objetos datos relacionan entre (véase sección ..). uml, estas relaciones llaman asociaciones. consultar figura ., clase plano define con identificación conjunto asociaciones entre plano otras dos clases, cámara -punto clave una asociación define una relación entre clases. multiplicidad define cuántas una clase relacionan con cuántas otra clase. (-).indd (-).indd // ::// :: modelado los requerimientos escena: cubículo cuando comienza modelado los requerimientos. participantes: vinod , miembros del equipo ingeniería software casasegura. conversación:[vinod decidido enseñar con ejemplo cómo desarrollar las tarjetas crc.] vinod: mientras trabajabas vigilancia jamie hacía con seguridad, estaba función administración del hogar. : ¿cuál estado eso? mercadotecnia cambia que quiere cada rato. vinod: aquí está primera versión caso uso para toda función... mejoramos poco, pero debe darte panorama general... caso uso: función administración casasegura.narración: queremos usar interfaz administración del hogar una una conexión internet para controlar los dispositi-vos electrónicos que tengan controladores interfaz inalámbrica. sistema debe permitir encender apagar focos específicos, controlar aparatos conectados una interfaz inalámbrica fijar sistema calefacción aire acondicionado temperatura que desee. para hacer esto, quiero seleccionar los aparatos plano casa. cada equipo debe estar identificado plano. como característi- opcional, quiero controlar todos los equipos audiovisuales: soni-, televisión, dvd, grabadoras digitales, etcétera. con una sola selección, quiero preparar toda casa para distin- tas situaciones. una casa, otra salir, tercera viaje nocturno cuarta viaje largo. todas estas situaciones tienen especifica-ciones que aplicarán todos los equipos. los estados viaje nocturno viaje largo, sistema debe encender apagar focos momentos elegidos azar (para que parezca que hay alguien casa) controlar sistema calefacción aire acondicionado. debo poder hacer esta preparación por internet, con protección claves adecuadas... : ¿ personal hardware tiene listas todas las interfaces inalámbricas? vinod (sonríe): están trabajando eso; dicen que hay pro- blema. cualquier forma, obtuve muchas clases para adminis-tración del hogar podemos usar una como ejemplo. tomemos clase interfazdeadministracióndelhogar. : bien... entonces, las responsabilidades son... los atributos ope-raciones para clase, las colaboraciones son las clases que indi-can las responsabilidades.vinod: pensé que habías entendido concepto crc. : poco, quizá, pero continúa.vinod: aquí está definición clase interfazdeadminis- tracióndelhogar. atributos:paneldeopciones: contiene información sobre los botones que permi- ten usuario seleccionar funcionalidad. paneldesituación: contiene información acerca los botones que permiten que usuario seleccione situación. plano: igual que objeto vigilancia, pero éste muestra los equi- pos. íconosdeaparatos: informa sobre los íconos que representan luces, aparatos, calefacción aire acondicionado, etcétera. paneldeaparatos: simula panel control aparato equipo; permite controlarlo. operaciones:desplegarcontrol( ), seleccionarcontrol( ), desplegarsituación( ), seleccionarsituación( ), accederaplano( ), seleccionaríconodeequi-( ), desplegarpaneldeequipo( ), accederapaneldeequipo( ),... clase: interfazdeadministracióndelhogarresponsabilidad colaborador desplegarcontrol( ) paneldeopciones (clase) seleccionarcontrol( ) paneldeopciones (clase) desplegarsituación( ) paneldesituación (clase) seleccionarsituación( ) paneldesituación (clase) accederaplano( ) plano (clase) . . . . . . : modo que cuando invoque operación accederaplano( ), colabora con objeto plano igual manera que que desarro-llamos para vigilancia. espera, aquí tengo descripción (ven figura .). inod: exactamente. quisiéramos revisar todo modelo clase, podríamos comenzar con esta tarjeta índice, luego iríamos del colaborador ahí una los colaboradores del colabo-rador, así sucesivamente. : buena forma encontrar omisiones errores.vinod: .casasegura modelos crc red. clase pared está asociada con tres clases que permiten que construya ésta, que son segmentodepared, ventana puerta. ciertos casos, una asociación puede definirse con más detalle indica multiplicidad. relación con figura ., objeto pared construye partir uno más objetos seg- mentodepared. además, objeto pared puede contener más objetos ventana más objetos puerta. estas restricciones multiplicidad ilustran figura ., donde “uno (-).indd (-).indd // ::// :: parte dos modelado más” representa con ...*, para “ más” usa ...*. lmu, asterisco indica una fron- tera ilimitada ese rango. sucede con frecuencia que entre dos clases análisis existe una relación cliente-servidor. tales casos, una clase cliente depende algún modo clase servidor, establece una relación dependencia. las dependencias están definidas por estereotipo. estereotipo “mecanismo extensible” [arl] dentro del uml que permite definir elemento especial modelado con semántica especialización determinadas. uml, los estereotipos represen-tan entre paréntesis dobles angulares (por ejemplo, <<estereotipo). como ilustración una dependencia simple dentro del sistema vigilancia casasegura, objeto cámara ( clase servidora, este caso) proporciona una imagen objeto mostrar- ventana ( clase cliente). relación entre estos dos objetos una asociación simple sino dependencia. caso uso escrito para vigilancia (que presenta aquí), debe darse una clave especial fin observar ubicaciones específicas las cámaras. una forma lograr esto hacer que cámara pida password luego asegure permiso mostrarventana para que presente video. esto representa figura ., donde <<acceso implica que uso salida cámara controla con una clave especial. .. paquetes análisis una parte importante del modelado del análisis categorización. decir, clasifican dis-tintos elementos del modelo análisis (por ejemplo, casos uso clases análisis) - como parte una asociación, pueden indicarse otras relaciones multiplicidad: una una, una muchas, muchas muchas, una rango específico con límites inferior superior, otras.segmentodepared ventana puertapared usa para construir usa para construir usa para construir..* ..* ..*figura . multiplicidad cámara mostrarventana {password}<<accesofigura . dependencias ¿qué estereotipo?? punto clave paquete utiliza para ensamblar conjunto clases relacionadas (-).indd (-).indd // ::// :: modelado los requerimientos nera que agrupen paquete —llamado paquete análisis— que nombre - presentativo. para ilustrar uso los paquetes análisis, considere juego video que mencionó antes. medida que desarrolla modelo análisis para juego video, obtiene gran número clases. algunas centran ambiente del juego —las escenas visuales que usuario cuando usa—. esta categoría quedan clases tales como árbol, paisaje, - rretera, pared, puente, edificio efectovisual. otras centran los caracteres dentro del juego describen sus características físicas, acciones restricciones. pueden definirse clases como jugador ( descrita), protagonista, antagonista rolesdeapoyo. otras más descri- ben las reglas del juego —cómo desplaza jugador por ambiente—. candidatas para esto son clases como reglasdemovimiento restriccionesdelaacción. pueden existir muchas otras categorías. estas clases agrupan los paquetes análisis que observan figura .. signo más (suma) que precede nombre clase análisis cada paquete, indica que las clases tienen visibilidad pública, por que son accesibles desde otros paquetes. aunque aprecia figura, hay otros símbolos que preceden elemento dentro paquete. signo menos (resta) indica que elemento queda oculto desde todos los demás paquetes. símbolo # señala que elemento accesible sólo para los paquetes contenidos dentro paquete dado. . resumen objetivo del modelado los requerimientos crear varias representaciones que describan que necesita cliente, establecer una base para generar diseño software definir conjunto requerimientos que puedan ser validados una vez construido software. modelo requerimientos cruza brecha entre representación del sistema que describe sistema conjunto funcionalidad del negocio, diseño software que describe arquitec-tura aplicación del software, interfaz usuario estructura componentes. los modelos basados escenario ilustran los requerimientos del software desde punto vista del usuario. caso uso —descripción, hecha con una narración formato, una interacción entre actor software— principal elemento del modelado. caso uso obtiene durante indagación los requerimientos define las etapas clave una función interacción específica. grado formalidad del caso uso nivel detalle varía, pero ambiente +árbol +paisaje+carretera+pared+puente+ediﬁcio+efectovisual+escena actores +jugador +protagonista+antagonista+roldeapoyoreglasdeljuego +reglasdemovimiento+restriccionesdelaacciónnombre del paquete figura . paquetes (-).indd (-).indd // ::// :: parte dos modelado resultado final las entradas necesarias todas las demás actividades del modelado. los escenarios también pueden ser descritos con uso diagrama actividades —represen-tación gráfica parecida diagrama flujo que ilustra flujo del procesamiento dentro escenario específico—. los diagramas canal (swimlane) ilustran forma que asigna flujo del procesamiento distintos actores clases. modelado datos utiliza para describir espacio información que será construido manipulado por software. modelado datos comienza con representación los objetos datos —información compuesta que debe ser entendida por software—. identi-fican los atributos cada objeto datos describen las relaciones entre estos objetos. modelado basado clases utiliza información obtenida los elementos del modelado basado escenario datos, para identificar las clases análisis. emplea análisis gramatical para obtener candidatas clase, atributos operaciones, partir narraciones basadas texto. definen criterios para definir una clase. para definir las relaciones entre clases, emplean tarjetas índice clase-responsabilidad-colaborador. además, aplican varios elementos notación uml para definir jerarquías, relaciones, asociaciones, agregaciones dependencias entre clases. emplean paquetes análisis para clasificar agrupar clases, manera que sean más manejables sistemas grandes. problemas puntos por evaluar .. ¿ posible comenzar codificar inmediato después haber creado modelo análisis? expli- que respuesta luego defienda punto vista contrario. .. una regla práctica del análisis que modelo “debe centrarse los requerimientos visibles dentro del dominio del problema negocio”. ¿qué tipos requerimientos son visibles dichos dominios? algunos ejemplos... ¿cuál propósito del análisis del dominio? ¿cómo relaciona con concepto patrones - querimientos?.. ¿ posible desarrollar modelo análisis eficaz sin desarrollar los cuatro elementos que aparecen figura .? explique respuesta... pide lector que construya uno los siguientes sistemas: ) sistema inscripción universidad basado red. ) sistema procesamiento órdenes basado web para una tienda computadoras. ) sistema facturación simple para negocio pequeño. ) libro cocina basado internet, construido horno eléctrico microondas. seleccione sistema que interese desarrolle diagrama entidad-relación que describa los objetos datos, relaciones atributos. .. departamento obras públicas una gran ciudad decidido desarrollar sistema segui- miento reparación baches, basado web (ssrb). cuando reportan los baches, registran “sistema reparación del departamento obras públi- cas” les asigna número identificación, almacenado según calle, tamaño ( una escala ), ubicación ( medio, cuneta, etc.), distrito ( determina con dirección calle) prioridad reparación (determinada por tamaño del bache). los datos orden trabajo asocian con cada bache incluyen ubicación tamaño, número identificación del equipo reparación, número personas dicho equipo, equipo asignado, horas dedicadas reparación, estado del bache (trabajo proceso, reparado, reparación temporal, reparado), cantidad material relleno utilizado costo reparación (calculado partir las horas dedicadas, número personas, materiales equipo empleado). por último, crea archivo daños para mantener información sobre daños reportados debido bache, incluye nombre dirección del ciudadano, número telefónico, tipo daño cantidad dinero por daño. ssrb sistema línea, todas las solicitudes harán forma interactiva. (-).indd (-).indd // ::// :: modelado los requerimientos ) dibuje diagrama uml para caso uso del sistema ssrb. tendrá que hacer algunas suposicio- nes sobre manera que usuario interactúa con sistema. ) desarrolle modelo clase para sistema ssrb. .. escriba caso uso basado formato para sistema administración del hogar casasegura descrito manera informal recuadro sección ... .. desarrolle conjunto completo tarjetas índice modelo crc, sobre producto sistema que elija como parte del problema .... revise con sus compañeros las tarjetas índice crc. ¿cuántas clases, responsabilidades colaboradores adicionales fueron agregados como consecuencia revisión?.. ¿qué cómo usa paquete análisis? lecturas adicionales fuentes información los casos uso son fundamento todos los enfoques del modelado los requerimientos. tema analiza con amplitud rosenberg stephens ( use case driven object modeling with uml: theory and prac- tice, apress, ), denny (succeeding with use cases: working smart deliver quality, addison-wesley, ), alexander maiden (eds.) (scenarios, stories, use cases: through the systems development life-cycle , wiley, ), bittner spence ( use case modeling, addison-wesley, ), cockburn [coc] otras - ferencias mencionadas los capítulos . modelado datos constituye método útil para examinar espacio información. los libros hoberman [hob] simsion witt [sim] hacen tratamientos razonablemente amplios. además, allen terry (beginning relational data modeling, . ., apress, ), allen ( data modeling for everyone, word press, ), teorey . ( database modeling and design: logical design , . ., morgan kaufmann, ) carlis maguire (mastering data modeling, addison-wesley, ) presentan métodos aprendizaje deta-llados para crear modelos datos calidad industrial. libro interesante escrito por hay ( data modeling patterns, dorset house, ) presenta patrones comunes modelos datos que encuentran muchos negocios diferentes. análisis técnicas modelado uml que pueden aplicarse tanto para análisis como para diseño encuentran ’docherty (object-oriented analysis and design: understanding system development with uml ., wiley, ), arlow neustadt ( uml, and the unified process , . ., addison-wesley, ), roques (uml practice, wiley, ), dennis . (systems analysis and design with uml version ., wiley, ), larman (applying uml and patterns, . ., prentice-hall, ) rosenberg scott (use case driven object modeling with uml, addison-wesley, ). internet existe una amplia variedad fuentes información sobre modelado requerimientos. sitio web del libro, halla una lista actualizada referencias web que son relevantes para modelado del análisis. (-).indd (-).indd // ::// :: los requerimientos : flujo, comportamiento , patrones webapps conceptos clave diagramas secuencia . . . . especificación del proceso. . . navegación . . . . . . . . . . . . . modelo comportamiento . . . . . . . . . modelo configuración. . . . del contenido. . . . . . flujo control . . flujo datos . . . interacción . . . . . funcional . . . . . . . . . análisis . . . . . . . . . . . . . . . . . . . . ¿qué ? modelo requerimientos tiene muchas dimensiones diferentes. este capítu-, lector aprenderá acerca modelos orien-tados flujo, modelos comportamiento las consideraciones especiales del análisis requeri-mientos que entran juego cuando desarrollan web-apps. cada una estas representaciones modelado complementa los casos uso, modelos datos mode-los basados clases que estudiaron capítulo . ¿quién hace? ingeniero software ( veces llama- analista) construye modelo con uso los requeri-mientos recabados entre varios participantes. ¿por qué importante? perspectiva los requeri- mientos del software crece proporción directa núme- dimensiones distintas del modelado los requeri-mientos. aunque quizá tenga tiempo, los recursos inclinación para desarrollar cada representación sugerida este capítulo anterior, debe reconocer- que cada enfoque diferente modelado proporciona una forma distinta ver problema. consecuencia, lector ( otros participantes) estará mejor preparado para evaluar especificado forma apropiada aquello que debe lograrse.¿cuáles son los pasos? modelado orientado flujo una indicación forma que las funciones procesamiento transforman los objetos datos. mode-lado del comportamiento ilustra los estados del sistema sus clases, así como efecto que tienen los eventos sobre dichos estados. modelado basado patrones utiliza conocimiento del dominio existente para facilitar análisis los requerimientos. los modelos requerimientos con webapps están adaptados especialmente para representar requerimientos relacionados con contenido, interacción, función configuración. ¿cuál producto final? para modelado los requerimientos, posible escoger una gran variedad formas basadas texto diagramas. cada una estas representaciones una perspectiva uno más los elementos del modelo. ¿cómo aseguro que hice bien? debe revi- sarse los productos del trabajo del modelado los requerimientos son correctos, completos congruentes. deben reflejar las necesidades todos los participantes establecer los fundamentos desde los que llevará cabo diseño. una mirada rápidadespués estudiar capítulo los casos uso, modelado datos modelos - sados clase, razonable preguntar: “¿ son suficientes representaciones del -delado los requerimientos?” única respuesta razonable : “depende”.para ciertos tipos software, caso uso puede ser única representación para modelar los requerimientos que necesite. para otros, escoge enfoque orientado objetos desarrollan modelos basados clase. pero otras situaciones, los requerimientos las apli-caciones complejas demandan estudio manera como transforman los objetos datos cuando mueven través del sistema; cómo comporta una aplicación consecuencia eventos externos; conocimiento del dominio existente puede adaptarse problema cuestión; , caso sistemas aplicaciones basados web, cómo unificar contenido funcionalidad para dar usuario final capacidad navegar con éxito por una webapp fin lograr sus objetivos. . equerimientos que modelan las estrategias punto vista del modelado los requerimientos, llamada análisis estructurado, considera como entidades separadas los datos los procesos que los transforman. los objetos datos modelan una forma que define sus atributos relaciones. los procesos que manipulan obje-tos datos modelan una forma que muestra cómo transforman los datos cuando los (-).indd (-).indd // ::// :: modelado los requerimientos objetos datos fluyen por sistema. segundo enfoque del modelado análisis, llamado análisis orientado objetos, centra definición clases modo que colaboran una con otra para cumplir con los requerimientos del cliente. aunque modelo análisis que propone este libro combina características ambos enfoques, frecuente que los equipos del software elijan uno ellos excluyan las represen-taciones del otro. pregunta cuál mejor, sino qué combinación representaciones dará los participantes mejor modelo los requerimientos del software cuál será mejor puente para cruzar brecha hacia diseño del software. . modelado orientado flujo aunque algunos ingenieros software perciben modelado orientado flujo como una téc-nica obsoleta, sigue siendo una las notaciones más usadas actualmente para hacer análi-sis los requerimientos. bien diagrama flujo datos (dfd) información relacio- nada son una parte formal del uml, utilizan para complementar los diagramas éste amplían perspectiva los requerimientos del flujo del sistema. dfd adopta punto vista del tipo entrada-proceso-salida para sistema. decir, los objetos datos entran sistema, son transformados por elementos procesamiento los objetos datos que resultan ello salen del software. los objetos datos representan con flechas con leyendas las transformaciones, con círculos (también llamados burbujas). dfd presenta forma jerárquica. decir, primer modelo flujo datos ( ocasiones llamado dfd nivel diagrama contexto) representa sistema como todo. los diagra-mas posteriores flujo datos mejoran diagrama contexto dan cada vez más detalles los niveles siguientes. .. creación modelo flujo datos diagrama flujo datos permite desarrollar modelos del dominio información del dominio funcional. medida que dfd mejora con mayores niveles detalle, efectúa descomposición funcional implícita del sistema. mismo tiempo, mejora del dfd como resultado refinamiento los datos conforme avanzan por los procesos que constituyen aplicación. unos cuantos lineamientos sencillos ayudan muchísimo durante elaboración del diagrama flujo los datos: ) nivel del diagrama debe ilustrar software sistema como una sola modelado del flujo datos una actividad fundamental del análisis estructurado.algunas personas afirman que los dfd son obsoletos que hay lugar para ellos práctica moderna. ese punto vista excluye modo potencialmente útil representación nivel del análisis. ayuda, use dfd.consejo panel controlcomandos datos del usuario sensoresestado del sensorpantalla del panel control línea telefónicaalarmasoftware casasegurainformación pantalla tonos del número telefónicotipo alarmafigura . dfd nivel contexto para función seguridad casaseguracita: “ propósito los diagramas flujo datos proveer puente semántico entre los usuarios los desarrolladores sistemas.” kenneth kozar (-).indd (-).indd // ::// :: parte dos modelado burbuja; ) debe anotarse con cuidado las entradas salidas principales; ) mejora debe - menzar por aislar procesos candidatos, objetos datos almacenamiento éstos, para -presentarlos siguiente nivel; ) todas las flechas burbujas deben etiquetarse con nombres significativos; ) nivel otro, debe mantenerse continuidad del flujo información , ) debe mejorarse una burbuja vez. existe tendencia natural complicar innecesaria-mente diagrama flujo los datos. esto sucede cuando trata ilustrar demasiados detalles una etapa muy temprana representar aspectos procedimiento del software lugar del flujo información. para ilustrar uso del dfd notación relacionada, consideremos nuevo función seguridad casasegura. figura . muestra dfd nivel para dicha función. las entidades externas principales (cuadrados) producen información para uso del sistema consu-men información generada por éste. las flechas con leyendas representan objetos datos jerarquías éstos. por ejemplo, los comandos datos del usuario agrupan todos los coman- dos configuración, todos los comandos activación/desactivación, todas las diferentes interacciones todos los datos que introducen para calificar expandir comando. ahora debe expandirse dfd nivel modelo flujo datos nivel . pero, ¿cómo hacerlo? según enfoque sugerido capítulo , debe aplicarse “análisis gramatical” [abb] narración del caso uso que describe burbuja nivel del contexto. decir, aíslan todos los sustantivos ( frases sustantivadas) verbos ( frases verbales) narra-ción del procesamiento casasegura obtenida durante primera reunión realizada para - cabar los requerimientos. recordemos análisis gramatical del texto que narra procesa-miento presentado sección ..: función seguridad casasegura permite que propietario configure sistema seguridad cuando instala, vigila todos los sensores conectados sistema seguridad interactúa con pro- pietario través internet, una panel control. durante instalación, casasegura utiliza para programar configurar sistema. asigna cada sensor número tipo, programa una clave maestra para activar desactivar sistema, introducen números telefónicos para marcar cuando ocurre evento sensor. cuando reconoce evento sensor, software invoca una alarma audible instalada sistema. después tiempo retraso que especifica propietario durante las actividades configuración del sistema, software marca número telefónico servicio monitoreo, pro- porciona información acerca ubicación reporta naturaleza del evento detectado. número telefónico vuelve marcarse cada segundos hasta que obtiene conexión telefónica. propietario recibe información seguridad través panel control, navega- dor, que conjunto llama interfaz. interfaz despliega panel control, ventana del navegador mensajes aviso información del estado del sistema. interacción del propietario tiene siguiente forma... relación con análisis gramatical, los verbos son los procesos casasegura repre- sentarán como burbujas dfd posterior. los sustantivos son entidades externas (cuadros), datos objetos control (flechas) almacenamiento datos (líneas dobles). estudiado capítulo recuerda que los sustantivos verbos asocian entre (por ejemplo, cada sensor asigna número tipo; entonces, número tipo son atributos del objeto datos sensor). modo que realizar análisis gramatical narración procesamiento cualquier nivel del dfd, genera mucha información útil sobre manera proceder para mejora del nivel siguiente. figura . presenta dfd nivel con empleo esta información. proceso nivel contexto que ilustra figura . sido expandido decir, los objetos datos que entran sistema cualquier transformación cierto nivel deben ser los mismos objetos datos ( sus partes constitutivas) que entran transformación nivel mejorado.punto clave conforme mejora cada nivel del dfd, debe mantenerse continuidad del flujo información. esto significa que las entradas salidas cierto nivel deben ser las mismas nivel mejorado. análisis gramatical prueba todo, pero impulso excelente para arrancar tienen dificultades para definir objetos datos las transformaciones que operan sobre ellos. consejo asegúrese que narración del procesamiento que analizar gramaticalmente está escrita con mismo nivel abstracción.consejo (-).indd (-).indd // ::// :: modelado los requerimientos seis procesos derivados del estudio del análisis gramatical. manera similar, flujo - formación entre procesos del nivel surgido dicho análisis. además, entre los niveles mantiene continuidad del flujo información. los procesos representados nivel del dfd pueden mejorarse más hacia niveles infe- riores. por ejemplo, proceso vigilar sensores mejora dfd nivel , como aprecia figura .. nuevo, observe que entre los niveles mantenido continuidad del flujo información. mejoría los dfd continúa hasta que cada burbuja realiza una función simple. decir, hasta que proceso representado por burbuja ejecuta una función que implementaría fácilmente como componente programa. capítulo estudia concepto llamado conﬁguración informaciónpanel control sensorespantalla del panel control línea telefónicaalarmainteractuar con usuarioconﬁgurar sistema activar desactivar sistema procesar password vigilar sensoresmuestra mensajes estadocomandos datos del usuario passwordiniciar detenerconﬁgurar solicitudconﬁguración datos conﬁguración datos conﬁguración datosmensaje iden- tiﬁcación válidamensaje activar desactivar estado del sensorinformación los sensores tipo alarma tonos del número telefónicomuestra informaciónfigura . dfd nivel para función seguridad casasegura información conﬁguración leer sensoresevalúa contra preparacióndatos conﬁguración tipo identiﬁcación del sensor estado del sensorgenera señal alarmatipo alarma datos alarma número telefónico marcar número tonos del número telefónicoformato para desplegarinformación del sensor tipo identiﬁcación del sensor, ubicaciónfigura . dfd nivel que mejora proceso vigilar sensores (-).indd (-).indd // ::// :: parte dos modelado cohesión, que utiliza para evaluar objeto del procesamiento una función dada. por ahora, trata mejorar los dfd hasta que cada burbuja tenga “ solo pensamiento”. .. creación modelo flujo control para ciertos tipos aplicaciones, modelo datos diagrama flujo datos todo que necesita para obtener una visión significativa los requerimientos del software. sin embargo, como dijo, gran número aplicaciones son “motivadas” por eventos por datos, producen información control lugar reportes pantallas, procesan infor-mación con mucha atención tiempo desempeño. tales aplicaciones requieren uso del modelado del flujo control, además modelar flujo datos. dijo que evento aspecto del control implementa como valor booleano (por ejemplo, verdadero falso, encendido apagado, ) como una lista discreta condiciones (vacío, bloqueado, lleno, etc.). sugieren los lineamientos siguientes para seleccionar eventos candi-datos potenciales: • enlistar todos los sensores que son “leídos” por software. • enlistar todas las condiciones interrupción. • enlistar todos los “interruptores” que son activados por operador. • enlistar todas las condiciones los datos. • revisar todos los “aspectos control” como posibles entradas salidas especifica- ción del control, según análisis gramatical sustantivos verbos que aplicó narración del procesamiento. • describir comportamiento sistema con identificación sus estados, identi- ficar cómo llega cada estado definir las transiciones entre estados. • centrarse las posibles omisiones, error muy común especificar control; por ejemplo, debe preguntar: “¿hay otro modo llegar este estado salir ?” entre los muchos eventos aspectos del control que forman parte del software casase- gura, encuentran evento sensor (por ejemplo, sensor descompone), bandera cambio (señal para que pantalla cambie) interruptor iniciar/detener (señal para encen- der apagar sistema). .. especificación control una especificación control (cspec) representa dos maneras distintas comportamiento del sistema ( nivel desde que hizo referencia ). cspec contiene diagrama estado que una especificación secuencial del comportamiento. también puede contener una tabla activación del programa, especificación combinatoria del comportamiento. figura . ilustra diagrama estado preliminar para nivel del modelo flujo control para casasegura. diagrama indica cómo responde sistema eventos conforme pasa por los cuatro estados definidos este nivel. con revisión del diagrama estado deter-mina comportamiento del sistema, , que más importante, investiga existen “agu-jeros” comportamiento especificado. por ejemplo, diagrama estado (véase figura .) indica que las transiciones del estado ocioso ocurren sistema reinicia, activa apaga. sistema activa (por ejem-¿cómo seleccionar los eventos potenciales para diagrama flujo control, estado cspec?? sección . presenta notación adicional modelado por comportamiento. notación del diagrama estado que emplea aquí sigue del uml. análisis estructurado dispone “diagrama transición estado”, pero formato uml mejor contenido representación información. (-).indd (-).indd // ::// :: modelado los requerimientos plo, enciende sistema alarma), ocurre una transición estado vigilanciadelesta- dodelsistema, los mensajes pantalla cambian como muestra invoca proceso sistemadevigilanciaycontrol. fuera del estado sistemadevigilanciaycontrol ocurren dos tran- siciones: ) cuando desactiva sistema hay una transición regreso estado ocioso; ) cuando dispara sensor estado activaralarma. durante revisión consideran todas las transiciones contenido todos los estados. tabla activación del proceso (tap) modo algo distinto representar compor- tamiento. tap representa información contenida diagrama estado contexto los procesos, los estados. decir, tabla indica cuáles procesos (burbujas) serán invocados modelo del flujo cuando ocurra evento. tap usa como guía para diseñador que debe construir una ejecución que controle los procesos representados este nivel. figura . aprecia una tap para nivel del modelo flujo del software casasegura. cspec describe comportamiento del sistema, pero información acerca del fun- cionamiento interno los procesos que activan como resultado dicho comportamiento. sección .. estudia notación modelación que esta información. .. especificación del proceso especificación del proceso (pspec) utiliza para describir todos los procesos del modelo del flujo que aparecen nivel final mejora. contenido especificación del proceso incluye texto narrativo, una descripción del lenguaje diseño del programa del algoritmo del proceso, ecuaciones matemáticas, tablas diagramas actividad uml. una pspec reiniciar entrar/ﬁjar estadodelsistema “inactivo” entrar/mostrar pantalla mensaje , “iniciando sistema”entrar/mostrar pantalla mensaje , “por favor espere”entrar/ﬁjar estadodepantalla parpadeardespaciohacer: activar diagnósticointerruptor iniciar/detenerse, encendidosistema bien ocioso entrar/ﬁjar estadodelsistema “inactivo”entrar/mostrar pantalla mensaje “listo”entrar/mostrar pantalla mensaje “”entrar/ﬁjar pantalla estadodepantallaoprimirtecla/manipulartecla falladetectada/mostrar lapantalla mensaje “contacteal proveedor” vigilanciadelestadodelsistema entrar/ﬁjar estadodelsistema “vigilancia”entrar/mostrar pantalla mensaje “activada”entrar/mostrar pantalla mensaje “”entrar/ﬁjar pantalla estadodepantallahacer: vigilarycontrolarelsistemaactivaralarma entrar/ﬁjar estadodelsistema “vigilaryalarma”entrar/mostrar pantalla mensaje “alarma”entrar/mostrar pantalla mensaje dispararsensorentrar/ﬁjar estadodepantalla parpadearrápidohacer: sonaralarmahacer: notiﬁcararesponsablesdealarmaoprimirtecla/manipularteclareiniciar falsaalarma tiempoterminado sensordisparado/ comienzacronómetro sensordisparado/ reiniciarcronómetroactivar desactivar passwordapagar/interruptor apagado desactivar passwordfigura . diagrama estado para función seguridad casasegura lenguaje diseño del programa (ldp) mezcla sintaxis del lenguaje programación con texto narrativo fin dar detalles del diseño del procedimiento. capítulo analiza ldp. (-).indd (-).indd // ::// :: parte dos modelado que acompañe cada burbuja del modelo del flujo, crea una “miniespecificación” que sirve como guía para diseñar componente del software que implementará burbuja. para ilustrar uso pspec, considere transformación procesar password representada modelo flujo figura .. pspec esta función adopta forma siguiente: pspec: procesar password ( panel control). transformación procesar password realiza validación panel control para función seguridad casasegura. procesar password recibe password cuatro dígitos función interactuar con usuario. primero, password compara con password maestro almacenado dentro del sistema. password maestro coincide, pasa <mensaje identificación válida = verdadero función mostrar mensaje estado. eventos entrada activación del proceso vigilar controlar sistema activar desactivar sistemamostrar mensajes estadointeractuar con usuarioevento sensorbandera parpadeointerruptor iniciar detenerestado acción pantalla terminadoen marchatiempo terminado salida señal alarma . tabla activación del proceso para función seguridad casasegura escena: cubículo jamie, después que terminó última junta para recabar los requeri-mientos. participantes: jamie, vinod , miembros del equipo inge-niería software casasegura. conversación:(jamie presenta vinod los dibujos que hizo los modelos que muestran las figuras . ..) jamie: universidad tomé curso ingeniería software aprendí esto. profesor dijo que poco anticuado, pero, saben, ayuda aclarar las cosas. : está muy bien. pero veo ninguna clase objetos ahí.jamie: ... esto sólo modelo del flujo con poco com- portamiento ilustrado. vinod: así que estos dfd representan -- del software, ¿ ?: ¿--?vinod: entrada-proceso-salida. realidad, los dfd son muy intui- tivos... observan rato, indican cómo fluyen los objetos datos por sistema cómo transforman mientras hacen.: parece que pudiéramos convertir cada burbuja compo-nente ejecutable... menos nivel más bajo del dfd. jamie: ésa mejor parte, puede. realidad, hay una forma traducir los dfd una arquitectura diseño. : ¿ verdad?jamie: , pero primero tenemos que desarrollar modelo com- pleto los requerimientos, esto . vinod: bueno, primer paso, pero vamos tener que enfrentar los elementos basados clases también los aspectos comporta-miento, aunque diagrama estado tap hacen algo eso. : tenemos mucho trabajo por hacer poco tiempo.(entra bículo doug, gerente ingeniería software.)doug: así que dedicaremos los siguientes días desarrollar modelo los requerimientos, ¿? jamie (con orgullo): comenzamos.doug: qué bueno, tenemos mucho trabajo por hacer poco tiempo. (los tres ingenieros software miran entre sonríen.)casasegura modelado del flujo datospunto clave pspec una “miniespecificación” cada transformación nivel más bajo mejora dfd. (-).indd (-).indd // ::// :: modelado los requerimientos password maestro coincide, los cuatro dígitos comparan con una tabla passwords secunda- rios (que deben asignarse para recibir invitados trabajadores que necesiten entrar casa cuando propietario esté presente). password coincide con una entrada tabla, pasa <mensaje identificación válida = verdadero función mostrar mensaje estado. coinciden, pasa <mensaje identificación válida = falso función mostrar mensaje estado. esta etapa desean detalles algorítmicos adicionales, también puede incluirse una repre- sentación del lenguaje diseño del programa (ldp) como parte pspec. sin embargo, muchos profesionales piensan que versión ldp debe posponerse hasta comenzar diseño los componentes. las herramientas mencionadas aquí son obligatorias sino una muestra las que hay esta categoría. mayoría casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores.objetivo: las herramientas análisis estructurado per- miten que ingeniero software cree modelos datos, flujo comportamiento una forma que permite consisten-cia continuidad con facilidad para hacer revisión, edición ampliación. los modelos creados con estas herramientas dan inge-niero software perspectiva representación del análisis ayudan eliminar errores antes que éstos propaguen diseño , que sería peor, implementación. mecánica: las herramientas esta categoría son “diccionario datos”, como base datos central para describir todos los objetos datos. una vez definidas las entradas del diccionario, crean diagramas entidad-relación desarrollan las jerarquías los objetos. las características los diagramas flujo datos per-miten que sea fácil crear este modelo gráfico también proveen características para generar pspec cspec. asimismo, las herra-mientas análisis permiten que ingeniero software produzca modelos comportamiento con empleo del diagrama estado como notación operativa. herramientas representativas. maca&, wina&, desarrolladas por software excel (www. excelsoftware.com), brinda conjunto herramientas análisis diseño sencillas baratas para computadoras mac windows. metacase workbench, desarrollada por metacase consulting ( una metaherramienta utilizada para definir método análisis diseño (incluso análisis estructurado) sus conceptos, reglas, notaciones generadores. system architect, desarrollado por popkin software ( com), una amplia variedad herramientas análisis diseño, incluso para modelar datos hacer análisis estructurado.herramientas software análisis estructurado . creación modelo comportamiento notación modelado que hemos estudiado hasta momento representa elementos estáti- cos del modelo requerimientos. hora hacer transición comportamiento dinámico del sistema producto. para hacerlo, dicho comportamiento representa como función eventos tiempo específicos. modelo comportamiento indica forma que responderá software eventos estímulos externos. para generar modelo deben seguirse los pasos siguientes: . evaluar todos los casos uso para entender por completo secuencia interacción dentro del sistema. . identificar los eventos que conducen secuencia interacción que entienden modo que éstos relacionan con objetos específicos. . crear una secuencia para cada caso uso. . construir diagrama estado para sistema. . revisar modelo comportamiento para verificar exactitud consistencia. las secciones siguientes estudia cada uno estos pasos.¿cómo modela reacción del software ante algún evento externo?? (-).indd (-).indd // ::// :: parte dos modelado .. identificar los eventos con caso uso capítulo aprendió que caso uso representa una secuencia actividades que involucra los actores sistema. general, evento ocurre siempre que sistema actor intercambian información. sección .. dijo que evento información que intercambia, sino hecho que intercambió información. caso uso estudia para efectos del intercambio información. para ilustrarlo, vol- vamos caso uso una parte función seguridad casasegura. propietario utiliza teclado para escribir password cuatro dígitos. password compara con password válido guardado sistema. password incorrecto, panel control emi-tirá sonido una vez reiniciará para recibir entradas adicionales. password correcto, panel control queda espera otras acciones. las partes subrayadas del escenario del caso uso indican eventos. debe identificarse actor para cada evento, anotarse información que intercambia enlistarse cualesquiera condi-ciones restricciones. como ejemplo evento común considere frase subrayada caso uso “ propieta- rio utiliza teclado para escribir password cuatro dígitos”. contexto del modelo los requerimientos, objeto propietariodecasa transmite evento objeto paneldecon- trol. evento tal vez llame password introducido. información que transfiere son los cuatro dígitos que constituyen password, pero ésta una parte esencial del modelo comportamiento. importante observar que ciertos eventos tienen efecto explícito flujo del control del caso uso, mientras que otros tienen. por ejemplo, evento pas- sword introducido cambia explícitamente flujo del control del caso uso, pero los resul-tados del evento password comparado (derivado interacción “password compara con password válido guardado sistema”) tendrán efecto explícito flujo informa-ción control del software casasegura. una vez identificados todos los eventos, asignan los objetos involucrados. los objetos son responsables generación eventos (por ejemplo, propietario genera evento pas- sword introducido) reconocer los eventos que hayan ocurrido cualquier lugar ( panelde- control reconoce resultado binario del evento password comparado). .. representaciones estado contexto del modelado del comportamiento deben considerarse dos caracterizaciones diferentes los estados: ) estado cada clase cuando sistema ejecuta función ) estado del sistema según observa desde exterior cuando realiza función. estado una clase tiene características tanto pasivas como activas [cha]. estado pasivo sencillamente estado actual todos los atributos objeto. por ejemplo, - tado pasivo clase jugador ( aplicación juego video que vio capítulo ) incluiría los atributos actuales posición orientación jugador, así como otras caracterís- ticas éste que sean relevantes para juego (por ejemplo, atributo que incluya deseos mágicos restantes). estado activo objeto indica estado actual del objeto conforme pasa por una transformación procesamiento continuos. clase jugador tal vez tenga los siguientes estados activos: moverse, descanso, herido, curación, atrapado, perdido , etc. debe ocurrir evento ( ocasiones llamado disparador trigger) para forzar objeto hacer una transición estado activo otro. este ejemplo supone que cada usuario (propietario) que interactúe con casasegura tiene password identificación, por que objeto legítimo. los diagramas estado presentados capítulo sección .. ilustran estado del sistema. esta sección, nuestro análisis centrará estado cada clase dentro del modelo del análisis.punto clave sistema tiene estados que representan comportamiento específico observable desde exterior; una clase tiene estados que representan comportamiento cuando sistema realiza sus funciones. (-).indd (-).indd // ::// :: modelado los requerimientos los párrafos que siguen analizan dos representaciones distintas del comportamiento. primera indica manera que una clase individual cambia estado con base even- tos externos, segunda muestra comportamiento del software como una función del tiempo. diagramas estado para clases análisis. componente modelo comporta- miento diagrama estado uml que representa estados activos para cada clase los eventos (disparadores) que causan cambios dichos estados activos. figura . ilustra diagrama estado para objeto paneldecontrol función seguridad casasegura. cada flecha que aparece figura . representa una transición estado activo objeto otro. las leyendas cada flecha representan evento que dispara transición. aun-que modelo estado activo una perspectiva útil “historia vida” objeto, posible especificar información adicional para llegar más profundidad comprensión del comportamiento objeto. además especificar evento que hace que transi-ción ocurra, puede especificarse una guardia una acción [cha]. una guardia una con- dición booleana que debe satisfacerse para que tenga lugar una transición. por ejemplo, guardia para transición del estado “lectura” “comparación” figura . deter-mina con análisis del caso uso: (password entrada = dígitos) entonces comparar con password guardado general, guardia para una transición depende del valor uno más atributos -jeto. otras palabras, depende del estado pasivo del objeto. una acción sucede forma concurrente con transición estado como consecuencia ella, por general involucra una más operaciones (responsabilidades) del objeto. por lector está familiarizado con uml, puede consultar apéndice una breve introducción esta - portante notación modelación.lecturabloqueado selecciónpassword introducidocomparaciónpassword = incorrecto númerodeintentos < máximodeintentos password = correcto activación exitosaoprimir tecla hacer: validarpasswordnúmerodeintentos máximodeintentoscronómetro ≤ tiempobloqueado cronómetro tiempobloqueadofigura . diagrama estadopara clase paneldecontrol (-).indd (-).indd // ::// :: parte dos modelado ejemplo, acción conectada con evento password introducido (véase figura .) una operación llamada validarpassword ( ) que accede objeto password realiza una compa- ración dígito por dígito para validar password introducido. diagramas secuencia. segundo tipo representación del comportamiento, llamado diagr ama secuencia uml, indica forma que los eventos provocan transiciones objeto otro. una vez identificados los objetos por medio del análisis del caso uso, modelador crea diagrama secuencia: representación del modo que los eventos cau-san flujo uno otro como función del tiempo. esencia, diagrama secuencia una versión taquigráfica del caso uso. representa las clases password los eventos que hacen que comportamiento avance una clase otra. figura . ilustra diagrama parcial secuencia para función seguridad casa- segura. cada flecha representa evento (derivado caso uso) indica forma que éste canaliza comportamiento entre los objetos casasegura. tiempo mide dirección vertical (hacia abajo) los rectángulos verticales angostos representan que toma procesamiento una actividad. los estados presentan largo una línea tiempo vertical. primer evento, sistema listo , deriva del ambiente externo canaliza comportamiento objeto propietario. propietario introduce password. evento solicitud observación pasa sistema, que observa password una base datos sencilla devuelve resultado (encontrada encontrada ) paneldecontrol (ahora estado comparación). pas- sword válido como resultado evento password = correcto hacia sistema, que activa sensores con evento solicitud activación. por último, control pasa nuevo pro- pietario con evento activación exitosa. una vez que desarrollado diagrama secuencia completo, todos los eventos que causan transiciones entre objetos del sistema recopilan conjunto eventos entrada salida (desde objeto). esta información útil generación diseño eficaz para sistema que construir.panel control sistema sistema listolectura solicitud observacióncomparación resultadopassword introducido password = correcto solicitud activación activación exitosabloqueado seleccióncronómetro tiempobloqueadoa activación exitosapropietariosensores númerodeintentos máximodeintentosfigura . diagramade secuencia(parcial) para funcióncasasegura punto clave diferencia diagrama estado que representa comportamiento sin fijarse las clases involucradas, diagrama secuencia representa comportamiento, describiendo forma que las clases pasan estado otro. (-).indd (-).indd // ::// :: modelado los requerimientos . patrones para modelado requerimientos los patrones software son mecanismo para capturar conocimiento del dominio, forma que permita que vuelva aplicarse cuando encuentre problema nuevo. ciertos casos, conocimiento del dominio aplica nuevo problema dentro del mismo dominio aplicación. otros, conocimiento del dominio capturado por patrón puede aplicarse por analogía otro dominio una aplicación diferente por completo. autor original patrón análisis “crea” patrón, sino que descubre medida que realiza trabajo ingeniería requerimientos. una vez descubierto patrón, -cumenta describiendo “explícitamente problema general que aplicable patrón, -lución prescrita, las suposiciones restricciones del uso del patrón práctica , con frecuen-cia, alguna otra información sobre éste, como motivación las fuerzas que impulsan empleo del patrón, análisis las ventajas desventajas del mismo referencias algunos ejemplos conocidos empleo aplicaciones prácticas” [dev]. capítulo presentó concepto patrones análisis indicó que éstos repre- sentan una solución que con frecuencia incorpora una clase, función comportamiento dentro del dominio aplicación. patrón vuelve utilizarse cuando hace modelado los -querimientos para una aplicación dentro del dominio. los patrones análisis guardan depósito para que los miembros del equipo software usen herramientas búsqueda para encontrarlos volverlos emplear. una vez seleccionado patrón apropiado, integra modelo requerimientos, haciendo referencia nombre. .. descubrimiento patrones análisis modelo requerimientos está formado por una amplia variedad elementos: basados escenario (casos uso), orientados datos ( modelo datos), basados clases, orien-tados flujo del comportamiento. cada uno estos elementos estudia problema desde objetivo: las herramientas modelado del análisis dan capacidad desarrollar modelos basados esce- nario, clase comportamiento con uso notación uml. mecánica: las herramientas esta categoría dan apoyo toda variedad diagramas uml requeridos para construir modelo del análisis (estas herramientas también apoyan modelado del diseño). además los diagramas, las herramientas esta categoría ) hacen revisiones respecto consistencia corrección para todos los diagramas uml, ) proveen vínculos para producir diseño generar código, ) construyen una base datos que permite administrar evaluar modelos uml grandes requeridos sistemas complejos. herramientas representativas: las herramientas siguientes apoyan toda variedad diagramas uml que requieren para modelar análisis:argouml una herramienta fuente abierta disponible argouml.tigris.org. enterprise architect, desarrollada por sparx systems (www. sparxsystems.com.). powerdesigner, desarrollada por sybase ( rational rose, desarrollada por ibm (rational) ( com/software/rational/). system architect, desarrollada por popkin software ( com). uml studio, desarrollada por pragsoft corporation (www. pragsoft.com). visio, desarrollada por microsoft ( visual uml, desarrollada por visual object modelers (www. visualuml.com).herramientas software modelación análisis generalizado uml las herramientas mencionadas aquí son obligatorias sino una muestra las que hay esta categoría. mayoría casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores. capítulo presenta análisis profundidad del uso patrones durante diseño del software. (-).indd (-).indd // ::// :: parte dos modelado una perspectiva diferente oportunidad descubrir patrones que tal vez suceden dominio aplicación por analogía distintos dominios aplicación. elemento más fundamental descripción modelo requerimientos caso uso. contexto este análisis, conjunto coherente casos uso sirve como base para descubrir uno más patrones análisis. patrón análisis semántico (pas) “ - trón que describe conjunto pequeño casos uso coherentes que describen vez una aplicación general” [fer]. considere siguiente caso uso preliminar para software que requiere fin con- trolar vigilar una cámara visión real sensor proximidad para automóvil: caso uso: vigilar movimiento reversa descripción: cuando coloca vehículo reversa, software control permite que transmita video una pantalla que está tablero, desde una cámara colocada parte posterior. software superpone varias líneas orientación distancia pantalla fin que operador del auto mantenga orientación cuando éste mueve reversa. software control también vigila sensor proximidad con fin determinar objeto encuentra dentro una distancia pies desde parte trasera del carro. esto frenará vehículo manera automática sen-sor proximidad indica que hay objeto pies defensa trasera, donde determina con base velocidad del automóvil. este caso uso implica varias funciones que mejorarían elaborarían ( conjunto - herente casos uso) durante reunión para recabar modelar los requerimientos. sin importar cuánta elaboración logre, los casos uso sugieren pas sencillo pero con -plias aplicaciones ( vigilancia control sensores actuadores sistema físico con base software). este caso, los “sensores” dan información video sobre proximidad. “actuador” sistema frenado del vehículo (que invoca hay objeto muy cerca éste). pero caso más general, descubre patrón aplicación muy amplio. muchos dominios distintos aplicación, requiere software para vigilar sensores controlar actuadores físicos. concluye que podría usarse mucho patrón análisis que describa los requerimientos generales para esta capacidad. patrón, llamado actuador-sen- sor, aplicaría como parte del modelo requerimientos para casasegura analiza sección .., continuación. .. ejemplo patrón requerimientos: actuador-sensor uno los requerimientos función seguridad casasegura capacidad vigilar sensores seguridad (por ejemplo, sensores frenado, incendio, humo contenido , agua, etc.). las extensiones basadas internet para casasegura requerirán capacidad controlar movimiento (por ejemplo, apertura, acercamiento, etc.) una cámara segu-ridad dentro una residencia. implicación que software casasegura debe manejar varios sensores “actuadores” (como los mecanismos control las cámaras). konrad cheng [kon] sugieren patrón llamado actuador-sensor que una guía útil para modelar este requerimiento dentro del software casasegura. continuación presenta una versión abreviada del patrón actuador-sensor, desarrollada originalmente para aplicacio- nes automotrices. nombre del patrón. actuador-sensor objetivo. especifica distintas clases sensores actuadores sistema incrustado. motivación. por general, los sistemas incrustados tienen varias clases sensores actua- dores, conectados forma directa indirecta con una unidad control. unque muchos esta sección adaptó [kon] con permiso los autores. (-).indd (-).indd // ::// :: modelado los requerimientos los sensores actuadores ven muy distintos, comportamiento bastante similar como para estructurarlos patrón. éste ilustra forma especificar los sensores actuado-res para sistema, incluso los atributos operaciones. patrón actuador-sensor usa mecanismo para jalar (solicitud explícita información) sensorespasivos otro mecanismo para empujar (emisión información) los sensoresactivos. restricciones • cada sensor pasivo debe tener algún método para leer entrada sensor los atributos que representan valor del sensor. • cada sensor activo debe tener capacidades para emitir mensajes actualizados cuando valor cambie. • cada sensor activo debe enviar latido vida, mensaje estado que emite cada cierto tiempo para detectar fallas. • cada actuador debe tener método para invocar respuesta apropiada determinada por cálculodecomponente. • cada sensor actuador deben tener una función implementada para revisar propio estado operación. • cada sensor actuador debe ser capaz someter prueba validez los valores recibidos enviados fijar estado operación los valores encuentran fuera las especificaciones. aplicabilidad. útil cualquier sistema que haya varios sensores actuadores. estructura. figura . presenta diagrama clase uml para patrón actuador - sensor. actuador, sensorpasivo sensoractivo son clases abstractas están escritas con letra cursiva. este patrón hay cuatro tipos diferentes sensores actuadores. las clases booleano, entero real representan los tipos más comunes sensores actuadores. las clases complejas éstos son aquellas que usan valores que representan con facilidad términos tipos datos primitivos, tales como los radar. obstante, estos equipos sensor entero pasivosensor pasivocálculo del componente sensor activosensor booleano pasivo sensor complejo pasivosensor real pasivoactuador booleano actuador enteroactuador complejoactuador realactuador sensor booleano activo sensor entero activosensor complejo activosensor real activofigura . diagrama secuencia uml para patrón actuador-sensor.fuente: adaptado [kon], con permiso. (-).indd (-).indd // ::// :: parte dos modelado deben heredar interfaz las clases abstractas, que deben tener funciones básicas, tales como consultar los estados operación. comportamiento: figura . presenta diagrama secuencia uml para ejemplo patrón actuador-sensor según podría aplicarse función casasegura que controla posicionamiento (como apertura acercamiento) una cámara seguridad. aquí, paneldecontrol consulta sensor (uno posición pasiva) actuador (control apertura) para comprobar estado operación con fines diagnóstico antes leer esta-blecer valor. los mensajes establecer valor físico obtener valor físico son mensa- jes entre objetos. vez ello, describen interacción entre los dispositivos físicos del sis-tema sus contrapartes software. parte inferior del diagrama, bajo línea horizontal, sensordeposición reporta que estado operación igual cero. entonces, cálcu- lodecomponente (representado como paneldecontrol) envía código error para una falla posición sensor manejadordefallas, que decidirá cómo afecta este error sistema qué acciones requieren. obtiene los datos los sensores calcula respuesta requerida por parte los actuadores. participantes. esta sección descripción patrones “clasifica las clases objetos inclui- dos patrón requerimientos” [kon] describe las responsabilidades cada clase objeto (véase figura .). continuación presenta una lista abreviada: • resumen sensorpasivo: define una interfaz para los sensores pasivos. • sensorbooleanopasivo: define los sensores booleanos pasivos. • sensorenteropasivo: define los sensores enteros pasivos. patrón original usa frase general cálculodecomponente.manejadorfavorito (sensor posición. estadodeoperación = )sensor posición panel control obtiene estado operaciónactuador controldeaperturasensor dispositivodeentrada sensor posiciónactuador dispositivodesalida controldeapertura obtiene valor obtiene estado operaciónobtiene estado operación establece valor establece valor físico guarda errorobtiene valor físico (sensor posición. estadodeoperación = )figura . diagrama clase uml para patrón actuador-sensor. fuente: reimpreso [kon], con permiso. (-).indd (-).indd // ::// :: modelado los requerimientos • sensorrealpasivo: define los sensores reales pasivos. • resumen sensoractivo: define una interfaz para los sensores activos. • sensorbooleanoactivo: define los sensores booleanos activos. • sensorenteroactivo: define los sensores enteros activos. • sensorrealactivo: define los sensores reales activos. • resumen actuador: define una interfaz para los actuadores. • actuadorbooleano: define los actuadores booleanos. • actuadorentero: define los actuadores enteros. • actuadorreal: define los actuadores reales. • cálculodecomponente: parte central del controlador; obtiene los datos los sensores calcula respuesta requerida para los actuadores. • sensorcomplejoactivo: los sensores complejos activos tienen funcionalidad básica clase sensoractivo, pero necesario especificar métodos atributos adicionales más elaborados. • sensorcomplejopasivo: los sensores complejos pasivos tienen funcionalidad básica clase abstracta sensorpasivo, pero necesita especificar métodos atributos adicionales más elaborados. • actuadorcomplejo: los actuadores complejos también tienen funcionalidad básica clase abstracta actuador, pero requiere especificar métodos atributos adicio-nales más elaborados. colaboraciones. esta sección describe cómo interactúan los objetos clases entre , cómo efectúa cada uno sus responsabilidades. • cuando cálculodecomponente necesita actualizar valor sensorpasivo, consulta los sensores solicita valor enviando mensaje apropiado. • los sensoresactivos son consultados. inician transmisión los valores del sensor unidad cálculo, con uso del método apropiado para establecer valor cálculodecomponente. durante tiempo especificado, envían latido vida menos una vez con fin actualizar sus parámetros tiempo con reloj del sistema. • cuando cálculodecomponente necesita establecer valor actuador, envía valor éste. • cálculodecomponente consulta establece estado operación los sensores actuadores por medio los métodos apropiados. estado operación cero, entonces envía error manejadordefallas, clase que contiene métodos para manejar mensajes error, tales como reiniciar mecanismo más elaborado recu-peración dispositivo respaldo. posible recuperación, entonces sistema sólo usa último valor conocido para sensor uno preestablecido. • los sensoresactivos ofrecen métodos para agregar retirar los evaluadores evalúan rangos los componentes que quieren que reciban los mensajes caso cambio valor. consecuencias . las clases sensor actuador tienen una interfaz común. . sólo puede accederse los atributos clase través mensajes clase decide aceptan . por ejemplo, establece valor actuador por arriba del (-).indd (-).indd // ::// :: parte dos modelado máximo, entonces clase actuador tal vez acepte mensaje, quizá emplee valor máximo preestablecido. . complejidad del sistema potencialmente reducida debido uniformidad las interfaces para los actuadores sensores. descripción del patrón requerimientos también referencias acerca otros requeri- mientos patrones diseño relacionados. . modelado requerimientos para webapps frecuente que los desarrolladores web manifiesten escepticismo cuando plantea idea del análisis los requerimientos para webapps. acostumbran decir: “después todo, pro-ceso desarrollo web debe ser ágil análisis toma tiempo. nos hará ser lentos justo cuando necesitemos diseñar construir webapp”. análisis los requerimientos lleva tiempo, pero resolver problema equivocado toma aún más tiempo. pregunta que debe responder todo desarrollador web sencilla: ¿estás seguro que entiendes los requerimientos del problema? respuesta “” inequívoco, entonces tal vez sea posible omitir modelado los requerimientos, pero respuesta “”, entonces ésta debe llevarse cabo. .. ¿cuánto análisis suficiente? grado que profundice modelado los requerimientos para las webapps depende los factores siguientes: • tamaño complejidad del incremento webapp. • número participantes ( análisis ayuda identificar los requerimientos conflictivos que provienen distintas fuentes). • tamaño del equipo webapp. • grado que los miembros del equipo han trabajado juntos antes ( análisis ayuda desarrollar una comprensión común del proyecto). • medida que éxito organización depende directamente del éxito webapp. inverso los puntos anteriores que medida que proyecto hace más chico, que número participantes disminuye, que equipo desarrollo más cohesivo que apli-cación menos crítica, razonable aplicar enfoque más ligero para análisis. aunque una buena idea analizar problema antes que comience diseño, verdad que todo análisis deba preceder todo diseño. realidad, diseño una parte específica webapp sólo demanda análisis los requerimientos que afectan sólo esa parte webapp. como ejemplo proveniente casasegura, podría diseñarse con validez estéti- general del sitio web (formatos, colores, etc.) sin tener que analizar los requerimientos fun-cionales las capacidades comercio electrónico. sólo necesita analizar aquella parte del problema que sea relevante para trabajo diseño del incremento que entregar. .. entrada del modelado los requerimientos capítulo analizó una versión ágil del proceso software general que puede aplicarse cuando hace ingeniería las webapps. proceso incorpora una actividad comunica- esta sección adaptó pressman lowe [pre], con permiso. (-).indd (-).indd // ::// :: modelado los requerimientos ción que identifica los participantes las categorías usuario, contexto del negocio, las metas definidas información aplicación, requerimientos generales webapps los esce-narios uso, información que convierte entrada del modelado los requerimientos. esta información representa forma descripciones hechas lenguaje natural, grandes rasgos, bosquejos otras representaciones formales. análisis toma esta información, estructura con empleo esquema representa- ción definido formalmente (donde sea apropiado) luego produce como salida modelos más rigurosos. modelo requerimientos brinda una indicación detallada verdadera estruc-tura del problema una perspectiva forma solución. capítulo introdujo función avc-mvc (vigilancia con cámaras). ese momento, esta función parecía relativamente clara describió con cierto detalle como parte del caso uso (véase sección ..). sin embargo, revisión del caso uso quizá revele información oculta, ambigua poco clara. algunos aspectos esta información faltante emergerían manera natural durante - seño. los ejemplos quizá incluyan formato específico los botones función, aspecto percepción estética, tamaño las vistas instantáneas, colocación del ángulo las -maras plano casa, incluso minucias tales como las longitudes máxima mínima las claves. algunos estos aspectos son decisiones diseño (como aspecto los botones) otros son requerimientos (como longitud las claves) que influyen manera funda-mental los primeros trabajos diseño. pero cierta información faltante podría influir diseño general relaciona más con comprensión real los requerimientos. por ejemplo: : ¿cuál resolución del video salida que dan las cámaras casasegura? : ¿qué ocurre encuentra una condición alarma mientras cámara está siendo vigilada? : ¿cómo maneja sistema las cámaras con vistas panorámicas acercamiento? : ¿qué información debe darse junto con vista cámara (por ejemplo, ubicación, fecha hora, último acceso, etcétera)? ninguna estas preguntas fue identificada considerada desarrollo inicial del caso uso; obstante, las respuestas podrían tener efecto significativo los diferentes aspectos del diseño. por tanto, razonable concluir que aunque actividad comunicación provea buen fundamento para entender, análisis los requerimientos mejora este entendimiento dar una interpretación adicional. como estructura del problema delinea como parte del modelo requerimientos, invariablemente surgen preguntas. son éstas las que llenan los huecos , ciertos casos, realidad ayudan encontrarlos. resumen, información obtenida durante actividad comunicación será entrada del modelo los requerimientos, cualquiera que sea, desde correo electrónico informal hasta proyecto detallado con escenarios uso exhaustivos especificaciones del producto. .. salida del modelado los requerimientos análisis los requerimientos provee mecanismo disciplinado para representar evaluar contenido funcionamiento las webapp, los modos interacción que hallarán los usua- rios ambiente infraestructura las que reside webapp. cada una estas características representa como conjunto modelos que permiten que los requerimientos webapp sean analizados forma estructurada. bien los mode- los específicos dependen gran medida naturaleza webapp, hay cinco clases prin-cipales ellos: (-).indd (-).indd // ::// :: parte dos modelado • modelo contenido: identifica espectro completo contenido que dará webapp. contenido incluye datos texto, gráficos imágenes, video sonido. • modelo interacción: describe manera que los usuarios interactúan con webapp. • modelo funcional: define las operaciones que aplicarán contenido webapp describe otras funciones procesamiento que son independientes del contenido pero necesarias para usuario final. • modelo navegación: define estrategia general navegación para webapp. • modelo configuración: describe ambiente infraestructura que reside webapp. posible desarrollar cada uno estos modelos con empleo esquema representa-ción (llamado con frecuencia “lenguaje”) que permite que objetivo estructura comuni-quen evalúen con facilidad entre los miembros del equipo ingeniería web otros parti-cipantes. consecuencia, identifica una lista aspectos clave (como errores, omisiones, inconsistencias, sugerencias mejora modificaciones, puntos aclaración, etc.) para tra-bajar sobre ellos. .. modelo del contenido las webapps modelo contenido incluye elementos estructurales que dan punto vista importante los requerimientos del contenido una webapp. estos elementos estructurales agrupan los objetos del contenido todas las clases análisis, entidades visibles para usuario que crean manipulan cuando éste interactúa con webapp. contenido puede desarrollarse antes implementación webapp, mientras ésta construye cuando opera. cualquier caso, incorpora por referencia navegación estructura general webapp. objeto contenido una descripción producto forma texto, artículo que describe evento deportivo, una fotografía tomada éste, respuesta usuario foro análisis, una representación animada logotipo corporativo, una película corta discurso una grabación audio para una presentación con diapositivas. los objetos contenido pueden almacenarse como archivos separados, -crustarse directamente páginas web obtenerse forma dinámica una base datos. otras palabras, objeto contenido cualquier aspecto información cohesiva que presente usuario final. los objetos contenido determinan directamente partir casos uso, estudiando descripción del escenario respecto referencias directas indirectas contenido. por ejemplo, establece casaseguraasegurada.com una webapp que apoyo casasegura. caso uso, comprar componentes seleccionados casasegura , describe escenario que requiere para comprar componente casasegura que contiene siguiente oración: podré obtener información descriptiva precios cada componente del producto. modelo contenido debe ser capaz describir objeto contenido componente. muchas circunstancias, para definir los requerimientos para contenido que debe diseñarse implementarse, suficiente una lista sencilla los objetos contenido, junto con descrip-ción breve cada uno. sin embargo, ciertos casos, modelo contenido beneficia análisis más rico que ilustre forma gráfica las relaciones entre los objetos contenido jerarquía que mantiene una webapp. por ejemplo, tome cuenta árbol datos [sri] creado por componente casasegu- raasegurada.com que aparece figura .. árbol representa una jerarquía informa- las clases análisis estudiaron capítulo . (-).indd (-).indd // ::// :: modelado los requerimientos ción que utiliza para describir componente. los aspectos datos simples compuestos (uno más valores los datos) representan con rectángulos sin sombra. los objetos contenido representan con rectángulos con sombra. figura, descripción está definida por cinco objetos (los rectángulos sombreados). ciertos casos, uno más estos objetos mejorará más conforme expanda árbol datos. posible crear árbol datos para cualquier contenido que componga múltiples objetos contenido aspectos datos. árbol datos desarrolla como esfuerzo para definir relaciones jerárquicas entre los objetos contenido para dar medio revisión del contenido fin que descubran las omisiones inconsistencias antes que comience diseño. además, árbol datos sirve como base para diseñar contenido. .. modelo interacción para webapps gran mayoría webapps permiten una “conversación” entre usuario final funcionali- dad, contenido comportamiento aplicación. esta conversación describe con uso modelo interacción que compone uno más los elementos siguientes: ) casos uso, ) diagramas secuencia, ) diagramas estado ) prototipos interfaz usuario. muchas instancias, basta conjunto casos uso para describir interacción nivel del análisis (durante diseño introducirán más mejoras detalles). sin embargo, cuando secuencia interacción compleja involucra múltiples clases análisis -chas tareas, conveniente ilustrarla forma más rigurosa mediante diagrama. formato interfaz usuario, contenido que presenta, los mecanismos interac- ción que implementa estética general las conexiones entre usuario webapp tienen mucho que ver con satisfacción éste con éxito conjunto del software. aunque afir- que creación prototipo interfaz usuario una actividad diseño, una buena idea llevarla cabo durante creación del modelo análisis. entre más pronto revise representación física interfaz usuario, más probable que los consumidores fina-les obtengan que desean. capítulo estudia con detalle diseño interfaces usuario.descripción mercadotecnia fotografía descripción técnica esquema video precio mayoreonúmero parte nombre parte tipo parte componente descripción precio precio menudeofigura . árbol datos para componente casa-seguraasegurada.com los diagramas secuencia los estado modelan con empleo notación uml. los diagramas estado describen sección .. para mayores detalles, consulte apéndice . (-).indd (-).indd // ::// :: parte dos modelado como hay muchas herramientas para construir webapps baratas poderosas sus funcio- nes, mejor crear prototipo interfaz con empleo ellas. prototipo debe imple- mentar los vínculos navegación principales representar pantalla general forma muy parecida que construirá. por ejemplo, van ponerse disposición del usuario final cinco funciones principales del sistema, prototipo debe representarlas tal como las verá cuando entre por primera vez webapp. ¿ darán vínculos gráficos? ¿dónde desplegará menú navegación? ¿qué otra información verá usuario? preguntas como éstas son las que debe responder prototipo. .. modelo funcional para las webapps muchas webapps proporcionan una amplia variedad funciones computación manipu- lación que asocian directamente con contenido (porque utilizan porque producen) frecuente que sean objetivo importante interacción entre usuario webapp. por esta razón, deben analizarse los requerimientos funcionales modelarlos cuando sea -cesario. modelo funcional enfrenta dos elementos procesamiento webapp, cada uno los cuales representa nivel distinto abstracción del procedimiento: ) funciones observables por los usuarios que entrega webapp éstos ) las operaciones contenidas las clases análisis que implementan comportamientos asociados con clase. funcionalidad observable por usuario agrupa cualesquiera funciones procesamiento que inicie directamente usuario. por ejemplo, una webapp financiera tal vez implemente - rias funciones finanzas (como una calculadora ahorros para una colegiatura universitaria fondo para retiro). estas funciones realidad implementan con uso operaciones dentro clases análisis, pero desde punto vista del usuario final; resultado visible función (más correctamente, los datos que provee función). nivel más bajo abstracción del procedimiento, modelo requerimientos describe procesamiento que realizará por medio operaciones clase análisis. estas opera-ciones manipulan los atributos clase involucran como clases que colaboran entre para lograr algún comportamiento que desea. sin que importe nivel abstracción del procedimiento, diagrama actividades uml utiliza para representar detalles éste. nivel análisis, los diagramas actividades deben usarse sólo donde funcionalidad sea relativamente compleja. gran parte comple-jidad muchas webapps ocurre las funciones que proveen, sino naturaleza información que accede las formas las que manipula. ejemplo complejidad relativa funcionalidad para casaseguraasegurada.com aborda caso uso llamado obtener recomendaciones para distribución sensores espacio. usuario desarrollado distribución del espacio que vigilará este caso uso selecciona dicha distribución solicita ubicaciones recomendables para los sensores dentro ella. casaseguraasegurada.com responde con representación gráfica dis- tribución por medio información adicional acerca ubicación recomendable para los sensores. interacción muy sencilla, contenido algo más complejo, pero funciona-lidad subyacente muy sofisticada. sistema debe realizar análisis relativamente complejo planta del piso para determinar conjunto óptimo sensores. debe examinar las dimen-siones habitación, ubicación puertas ventanas, coordinar éstas con capacidad especificaciones los sensores. ¡ una tarea fácil! para describir procesamiento este caso uso utiliza conjunto diagramas actividades. segundo ejemplo caso uso controlar cámaras. éste, interacción relativa- mente sencilla, pero existe potencial una funcionalidad compleja, dado que dicha opera-ción “sencilla” requiere una comunicación compleja con dispositivos ubicados posiciones remotas los que accede por internet. una complicación adicional relaciona con - (-).indd (-).indd // ::// :: modelado los requerimientos gociación del control cuando varias personas autorizadas tratan vigilar controlar mismo sensor mismo tiempo. figura . ilustra diagrama actividades para operación tomarcontroldecámara que forma parte clase análisis cámara usada dentro del caso uso controlar cámaras. debe observarse que con flujo procedimiento invocan dos operaciones adicionales: solicitarbloqueodecámara ( ) , que trata bloquear cámara para este usuario, obtenerusua- rioactualdecámara ( ), que recupera nombre del usuario que controla ese momento -mara. los detalles construcción indican cómo invocan estas operaciones, los -terfaz para cada operación señalan hasta que comienza diseño webapp. .. modelos configuración para las webapps ciertos casos, modelo configuración sino una lista atributos del lado del servi-dor del lado del cliente. sin embargo, para webapps más complejas, son varias las dificultades configuración (por ejemplo, distribuir carga entre servidores múltiples, arquitecturas -ché, bases datos remotas, distintos servidores que atienden varios objetos misma página web, etc.) que afectan análisis diseño. diagrama despliegue uml utiliza situaciones las que deben considerarse arquitecturas configuración compleja. para casaseguraasegurada.com, deben especificarse contenido funcionalidad públi- cos fin que sean accesibles través todos los clientes principales web (como aquéllos con por ciento más participación mercado). inversa, aceptable restringir las funciones más complejas control vigilancia (que sólo accesible para los usuarios tipo propietario) conjunto más pequeño clientes. modelo configuración para casase- guraasegurada.com también especificará operación cruzada con las bases datos productos aplicaciones vigilancia.obtenerusuarioactual decámara( ) reporta que cámara está uso nombre del usuariobloqueo disponible bloqueo disponiblela cámara está uso cámara está uso solicitarbloqueo decámara( ) reporta que cámara sido bloqueada por usuarioreporta que cámara está disponiblefigura . diagrama actividadespara operación tomarcontrol decámara( ) determinación participación mercado para los navegadores notoriamente problemática varía función cuál fuente utilice. obstante, momento escribir este libro, internet explorer firefox eran los únicos que sobrepasaban por ciento, mozilla, opera safari los únicos que superaban manera consistente por ciento. (-).indd (-).indd // ::// :: parte dos modelado .. modelado navegación para modelar navegación considera cómo navegará cada categoría usuario ele- mento webapp (como objeto contenido) otro. mecánica navegación define como parte del diseño. esa etapa debe centrarse atención los requerimientos generales navegación. deben considerarse las preguntas siguientes: • ¿ciertos elementos deben ser más fáciles alcanzar (requieren menos pasos nave- gación) que otros? ¿cuál prioridad presentación? • ¿debe ponerse énfasis ciertos elementos para forzar los usuarios navegar esa dirección? • ¿cómo deben manejarse los errores navegación? • ¿debe darse prioridad navegación hacia grupos elementos relacionados hacia elemento específico? • ¿ navegación debe hacerse por medio vínculos, acceso basado búsquedas por otros medios? • ¿debe presentarse los usuarios ciertos elementos con base contexto acciones navegación previas? • ¿debe mantenerse registro usuarios navegación? • ¿debe estar disponible mapa completo navegación ( oposición solo vínculo para “regresar” apuntador dirigido) cada punto interacción del usuario? • ¿ diseño navegación debe estar motivado por los comportamientos del usuario más comunes esperados por importancia percibida los elementos definidos webapp? • ¿ usuario puede “guardar” navegación previa través webapp para hacer expedito uso futuro? • ¿para qué categoría usuario debe diseñarse navegación óptima? • ¿cómo deben manejarse los vínculos externos hacia webapp? ¿con superposición ventana del navegador existente? ¿como nueva ventana del navegador? ¿ marco separado? estas preguntas muchas otras deben plantearse responderse como parte del análisis navegación. usted otros participantes también deben determinar los requerimientos generales para navegación. por ejemplo, ¿ dará los usuarios “mapa del sitio” panorama toda estructura webapp? ¿ usuario puede hacer una “visita guiada” que resalte los elemen- tos más importantes (objetos funciones contenido) con que disponga? ¿podrá acceder usuario los objetos funciones contenido con base atributos definidos dichos elementos (por ejemplo, usuario tal vez desee acceder todas las fotografías edificio específico todas las funciones que permiten calcular peso)? . resumen los modelos orientados flujo centran flujo objetos datos medida que son transformados por las funciones procesamiento. derivados del análisis estructurado, los modelos orientados flujo usan diagrama flujo datos, notación modelación que ilustra manera que transforma entrada salida cuando los objetos datos mueven través del sistema. cada función del software que transforme datos descrita por (-).indd (-).indd // ::// :: modelado los requerimientos especificación narrativa proceso. además del flujo datos, este elemento modela- ción también muestra flujo del control, representación que ilustra cómo afectan los eventos comportamiento sistema. modelado del comportamiento ilustra comportamiento dinámico. modelo compor- tamiento utiliza una entrada basada escenario, orientada flujo elementos basados clases para representar los estados las clases análisis sistema como todo. para lograr esto, identifican los estados definen los eventos que hacen que una clase ( sistema) haga una transición estado otro, así como las acciones que ocurren cuando efectúa dicha transición. los diagramas estado secuencia son notación que emplea para modelar comportamiento. los patrones análisis permiten ingeniero software utilizar conocimiento del dominio existente para facilitar creación modelo requerimientos. patrón aná-lisis describe una característica función específica del software que puede describirse con conjunto coherente casos uso. especifica objetivo del patrón, motivación para uso, las restricciones que limitan éste, aplicabilidad distintos dominios problemas, estruc-tura general del patrón, comportamiento colaboraciones, así como información suplemen-taria. modelado los requerimientos para las webapps utiliza mayoría, que todos, los elementos modelado que estudian libro. sin embargo, dichos elementos apli-can dentro conjunto modelos especializados que abocan contenido, interacción, función, navegación configuración cliente-servidor que reside webapp. problemas puntos por evaluar .. ¿cuál diferencia fundamental entre análisis estructurado las estrategias orientadas objetos para hacer análisis los requerimientos? .. diagrama flujo datos, ¿una flecha representa flujo del control otra cosa? .. ¿qué “continuidad del flujo información” cómo aplica cuando mejora diagrama flujo datos?.. ¿cómo utiliza análisis gramatical creación dfd? .. ¿qué una especificación del control? .. ¿son mismo una pspec caso uso? así, explique las diferencias. .. hay dos tipos diferentes “estados” que los modelos del comportamiento pueden representar. ¿cuáles son?.. ¿ qué difiere diagrama secuencia diagrama estado? ¿ qué parecen? .. sugiera tres patrones requerimientos para teléfono inalámbrico moderno escriba una descrip- ción breve cada uno. ¿estos patrones podrían usarse para otros equipos? ejemplo... seleccione uno los patrones desarrollados problema . desarrolle una descripción del patrón razonablemente completa, similar contenido estilo que presentó sección ..... ¿cuánto modelado del análisis piensa que requeriría para casaseguraasegurada.com? ¿ nece- sitaría cada uno los tipos modelo descritos sección ..?.. ¿cuál propósito del modelo interacción para una webapp? .. modelo funcional webapp debe retrasarse hasta diseño. diga los pros contras este argu- mento... ¿cuál propósito modelo configuración? .. ¿ qué difiere modelo navegación del modelo interacción? (-).indd (-).indd // ::// :: parte dos modelado lecturas adicionales fuentes información han publicado decenas libros sobre análisis estructurado. todos cubren tema manera ade- cuada, pero algunos son excelentes. demarco plauger escribieron clásico ( structured analysis and system specification, pearson, ) que sigue siendo una buena introducción notación básica. los libros escri-tos por kendall kendall ( systems analysis and design, . ., prentice-hall, ), hoffer . (modern systems analysis and design , addison-wesley, . ., ), davis yen ( the information system consultant’ handbook: systems analysis and design , crc press, ) modell ( professional’ guide systems analysis, . ., mcgraw-hill, ) son buenas referencias. escrito por yourdon (modern structured analysis, your-don-press, ) sobre tema está entre las fuentes más exhaustivas publicadas hasta fecha. modelado del comportamiento presenta punto vista dinámico importante del comportamiento sistema. los libros wagner . ( modeling software with finite state machines: practical approach , auerbach, ) boerger staerk (abstract state machines, springer, ) presentan análisis completo los diagramas estado otras representaciones del comportamiento. mayoría textos escritos sobre patrones software centran diseño éste. sin embargo, los libros evans (domain-driven design, addison-wesley, ) fowler ([fow] ([fow]) abordan específicamente los patrones análisis. pressman lowe presentan tratamiento profundo del modelado del análisis para webapps [pre]. los artículos contenidos dentro una antología editada por murugesan desphande ( web engineering: manag- ing diversity and complexity web application development , springer, ) analizan distintos aspectos los requerimientos para las webapps. además, edición anual proceedings the international conference web engineering analiza forma regular aspectos del modelado los requerimientos. internet hay una amplia variedad fuentes información sobre modelado los requerimientos. sitio web del libro, encuentra una lista actualizada referencias que hay red mundial, relevantes para modelado del análisis. (-).indd (-).indd // ::// :: diseño conceptos clave abstracción . . . . . . . . . . . . . arquitectura . . . . . . . . . . . . . . . . . . . . . . . . . . . calidad . . . . . diseño . . . . . . . . . . . . . . . . . . . . . . . . . . . datos. . . . . . . . . . del software. . . . . . . orientado objeto . . problemas . . . . . funcional . . . . calidad . . . . . . . . . . . . . . información. . . . . . . . . . . . . patrones. . . . . . . . . . . . . . . diseño . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ¿qué ? diseño que casi todo inge- niero quiere hacer. lugar que las reglas creatividad —los requerimientos los participantes, las necesidades del negocio las consideraciones técnicas— unen para formular producto sistema. diseño crea una representación modelo del software, pero, diferencia del modelo los requerimientos (que centra describir los datos que necesitan, función comportamiento), modelo diseño proporciona detalles sobre arquitectura del soft-ware, estructuras datos, interfaces componentes que necesitan para implementar sistema. ¿quién hace? ingenieros software llevan cabo cada una las tareas del diseño. ¿por qué importante? diseño permite modelar sistema producto que construir. este modelo evalúa respecto calidad mejora antes generar código; después, efectúan pruebas involucra muchos usuarios finales. diseño lugar que establece calidad del software. ¿cuáles son los pasos? diseño representa software varias maneras. primer lugar, debe representarse arquitectura del sistema producto. después modelan las interfaces que conectan software con los usuarios finales, con otros sistemas dispositivos, con sus propios componentes constitutivos. por último, diseñan los com-ponentes del software que utilizan para construir sis-tema. cada una estas perspectivas representa una acción diseño distinta, pero todas deben apegarse conjunto básico conceptos diseño que guíe traba- producción software. ¿cuál producto final? trabajo principal que produce durante diseño del software modelo diseño que agrupa las representaciones arquitectónicas, interfaces nivel componente despliegue. ¿cómo aseguro que hice bien? modelo diseño evaluado por equipo software esfuerzo por determinar contiene errores, inconsistencias omisiones, existen mejores alternativas posible implementar modelo dentro las restricciones, plazo costo que hayan establecido. una mirada rápidael diseño software agrupa conjunto principios, conceptos prácticas que llevan desarrollo sistema producto alta calidad. los principios diseño establecen una filosofía general que guía trabajo diseño que debe ejecutarse. deben entenderse los conceptos diseño antes aplicar mecánica éste, práctica del diseño lleva creación distintas representaciones del software que sirve como guía para actividad construcción que siga. diseño crucial para éxito ingeniería software. principios década , mitch kapor, creador lotus --, publicó . dobbs journal “manifiesto del - seño software”. decía siguiente: ¿qué diseño? donde está con pie dos mundos — tecnología las perso- nas los propósitos humanos— que tratan unificarse... vitruvio, romano crítico arquitectura, afirmaba que los edificios bien diseñados eran aquellos que tenían resistencia, funcionalidad belleza. mismo aplica buen software. resistencia: programa debe tener ningún error que impida funcionamiento. funcionalidad: programa debe apropiado para los fines que persigue. belleza: experiencia usar programa debe ser placen- tera. éstos son los comienzos una teoría del diseño software. objetivo del diseño producir modelo representación que tenga resistencia, funciona- lidad belleza. para lograrlo, debe practicarse diversificación luego convergencia. belady [bel] afirma que “ diversificación adquisición repertorio alternativas, materia prima del diseño: componentes, soluciones con los componentes conocimiento, todo cual (-).indd (-).indd // ::// :: parte dos modelado está contenido catálogos, libros texto mente”. una vez que reúne este conjunto diversificado información, deben escogerse aquellos elementos del repertorio que cumplan los requerimientos definidos por ingeniería por modelo análisis (capítulos ). medida que esto ocurre, evalúan las alternativas, algunas rechazan, converge “una configuración particular componentes , con ello, creación del producto final” [bel]. diversificación convergencia combinan intuición criterio con base expe- riencia construcción entidades similares, conjunto principios heurísticos que guían forma que evoluciona modelo, conjunto criterios que permiten evaluar calidad proceso iterativo que finalmente conduce una representación del diseño defini-tivo. diseño del software cambia continuamente conforme evolucionan los nuevos métodos, surgen mejores análisis obtiene una comprensión más amplia. incluso hoy, mayor parte las metodologías diseño software carece profundidad, flexibilidad naturaleza cuantitativa, que normalmente asocian con las disciplinas diseño ingeniería más clási-cas. obstante, existen métodos para diseñar software, dispone criterios para diseño con calidad aplica notación del diseño. este capítulo, estudian los conceptos principios fundamentales aplicables todo diseño software, los elementos del modelo del diseño efecto que tienen los patrones proceso diseño. los capítulos presentarán varias metodologías diseño software, según aplican obtención arquitecturas interfaces nivel componente, así como enfoques diseño basados patrones orientados web. . diseño contexto ingeniería software diseño software ubica área técnica ingeniería software aplica sin importar modelo del proceso que utilice. diseño del software comienza una vez que han analizado modelado los requerimientos, última acción ingeniería soft-ware dentro actividad modelado prepara etapa construcción (generación prueba código). cada uno los elementos del modelo requerimientos (capítulos ) proporciona infor- mación necesaria para crear los cuatro modelos diseño necesarios para especificación completa del diseño. figura . ilustra flujo información durante diseño del software. trabajo diseño alimentado por modelo requerimientos, manifestado por elementos basados escenario, clase, orientados flujo, del comportamiento. empleo notación los métodos diseño estudiados los últimos capítulos produce diseños los datos clases, arquitectura, interfaz los componentes. diseño datos clases transforma los modelos clases (capítulo ) realizaciones clases diseño las estructuras datos que requieren para implementar software. los objetos relaciones definidos diagrama crc contenido detallado los datos ilustrado por los atributos clase otros tipos notación dan base para diseño los datos. parte del diseño clase puede llevarse cabo junto con diseño arquitectura del software. diseño más detallado las clases tiene lugar cuando diseña cada componente del software. diseño arquitectura define relación entre los elementos principales estructura del software, los estilos patrones diseño arquitectura que pueden usarse para alcanzar aquellos lectores interesados filosofía del diseño software pueden consultar inquietante análisis philippe kruchen sobre diseño “posmoderno” [kru].cita: “ milagro más común ingeniería software transición del análisis diseño éste código.” richard due’ diseño del software siempre debe comenzar con análisis los datos, pues son fundamento todos los demás elementos del diseño. una vez obtenido fundamento, obtiene arquitectura. sólo entonces deben realizarse otros trabajos del diseño.consejo (-).indd (-).indd // ::// :: conceptos diseño los requerimientos definidos por sistema las restricciones que afectan forma que implementa arquitectura [sha]. representación del diseño arquitectura — marco sistema basado computadora— obtiene del modelo los requerimientos. diseño interfaz describe forma que software comunica con los sistemas que interactúan con con los humanos que utilizan. una interfaz implica flujo infor-mación (por ejemplo, datos control) tipo específico comportamiento. entonces, los modelos escenarios uso comportamiento dan mucha información requerida para diseñar interfaz. diseño nivel componente transforma los elementos estructurales arquitec- tura del software una descripción sus componentes cuanto procedimiento. infor-mación obtenida partir los modelos basados clase, flujo comportamiento sirve como base para diseñar los componentes. durante diseño toman decisiones que última instancia afectarán éxito cons- trucción del software , igual importancia, facilidad con que puede darse manteni-miento software. pero, ¿por qué tan importante diseño? importancia del diseño del software resume una palabra: calidad. diseño sitio que introduce calidad ingeniería software. representaciones del soft-ware que pueden evaluarse calidad. única manera traducir con exactitud producto sistema terminado los requerimientos los participantes. fundamento toda ingeniería software las actividades que dan apoyo que sigue. sin diseño corre riesgo obtener sistema inestable, que falle cuando hagan cambios pequeños, uno que sea difícil someter prueba, que sea posible evaluar calidad hasta que sea -masiado tarde proceso software, cuando queda mucho tiempo gastado mucho dinero.modelo análisiscasos uso - texto diagramas casos usodiagramas actividadesdiagramas canal elementos basados claseselementos basados escenario diagramas clasespaquetes análisismodelos crcdiagramas colaboracióndiseño datos clasesdiseño interfaz diseño arquitecturadiseño nivel componentes modelo del diseñodiagramas ﬂujo datosdiagramas ﬂujo del controlnarrativas procesamientoelementos orientados ﬂujo elementos del comportamiento diagramas estadodiagramas secuenciafigura . traducción del modelo requerimientos modelo diseño cita: “hay dos formas construir diseño del software. una hacerlo tan simple que sea obvio que hay deficiencias otra hacerlo tan complica- que haya deficiencias obvias. primer método mucho más difícil.” . . . hoare (-).indd (-).indd // ::// :: parte dos modelado . proceso diseño diseño software proceso iterativo por medio del cual traducen los requerimientos “plano” para construir software. principio, plano ilustra una visión holística del software. decir, diseño representa nivel alto abstracción, que rastrea directamente objetivo específico del sistema los requerimientos más detallados datos, funcionamiento comportamiento. medida que tienen lugar las iteraciones del diseño, las mejoras posteriores conducen niveles menores abstracción. éstos también pueden ras-trearse hasta los requerimientos, pero conexión más sutil. .. lineamientos atributos calidad del software través del proceso diseño evalúa calidad éste acuerdo con serie revisiones técnicas que estudia capítulo . mcglaughlin [mcg] sugiere tres características que funcionan como guía para evaluar buen diseño: • debe implementar todos los requerimientos explícitos contenidos modelo requerimientos dar cabida todos los requerimientos implícitos que desean los partici-pantes. • debe ser una guía legible comprensible para quienes generan código para los que prueban dan apoyo posterior. • debe proporcionar panorama completo del software, abordar los dominios los datos, las funciones comportamiento desde punto vista implementación. realidad, cada una estas características una meta del proceso diseño. pero, ¿cómo logran? lineamientos calidad. fin evaluar calidad una representación del diseño, usted otros miembros del equipo software deben establecer los criterios técnicos buen diseño. sección . estudian conceptos diseño que también sirven como crite- escena: cubículo jamie, cuando equi- prepara para traducir diseño los requeri-mientos. participantes: jamie, vinod , miembros del equipo inge-niería software para casasegura. conversación:jamie: ustedes saben, doug [ gerente del equipo] está obsesiona- con diseño. tengo que ser honesto, que realmente amo codificar. denme ++ java soy feliz. : … gusta diseñar.jamie: estás escuchando; codificar mío.vinod: creo que quiere decir que realidad codificar que gusta; gusta diseñar expresarlo código. código lenguaje que usas para representar diseño. jamie: ¿ qué tiene malo?vinod: nivel abstracción.jamie: ¿qué?: lenguaje programación bueno para representar deta- lles tales como estructuras datos algoritmos, pero tan bueno para representar arquitectura colaboración entre com-ponentes… algo así. vinod: una arquitectura complicada arruina mejor código.jamie (piensa unos momentos): entonces, dicen que puede representarse arquitectura con código... eso cierto. vinod: claro que posible implicar arquitectura con código, pero mayor parte lenguajes programación, muy difícil lograr panorama rápido amplio arquitectura con análi-sis del código. : eso que queremos hacer antes empezar codificar.jamie: está bien, tal vez diseñar codificar sean cosas distintas, pero aún así gusta más codificar.casasegura diseño versus codificación cita: “…escribir fragmento inteli- gente código que funcione una cosa; diseñar algo que apoyo largo plazo una empresa otra muy diferente”. . ferguson (-).indd (-).indd // ::// :: conceptos diseño rios calidad del software. este momento, considere los siguientes lineamientos para diseño: . debe tener una arquitectura que ) haya creado con empleo estilos patrones arquitectónicos reconocibles, ) esté compuesta componentes con buenas caracte-rísticas diseño (éstas analizan más adelante , este capítulo), ) implemen- ten forma evolutiva, modo que faciliten implementación las pruebas. . debe ser modular, decir, software debe estar dividido manera lógica elemen- tos subsistemas. . debe contener distintas representaciones datos, arquitectura, interfaces compo- nentes. . debe conducir estructuras datos apropiadas para las clases que van imple- mentar que surjan patrones reconocibles datos. . debe llevar componentes que tengan características funcionales independientes. . debe conducir interfaces que reduzcan complejidad las conexiones entre los componentes ambiente externo. . debe obtenerse con empleo método repetible motivado por información - tenida durante análisis los requerimientos del software. . debe representarse con una notación que comunique con eficacia significado. estos lineamientos diseño logran por azar . consiguen con aplicación los prin- cipios diseño fundamentales, una metodología sistemática con revisión.¿cuáles son las características buen diseño?? para sistemas pequeños, ocasiones diseño puede desarrollarse forma lineal. los factores calidad que estudian capítulo ayudan equipo revisión cuando evalúa aquélla. tal vez lector considere oportuno revisar capítulo este momento. las revisiones técnicas son una parte crítica del proceso diseño mecanismo importante para lograr calidad. diseño importante porque permite que equipo software evalúe calidad éste antes que imple- mente, momento que fácil barato corregir errores, omisio-nes inconsistencias. pero, ¿cómo evalúa calidad durante diseño? software puede someterse prueba porque hay nada ejecutable. ¿qué hacer? durante diseño, calidad evalúa por medio realiza- ción una serie revisiones técnicas (). las estudian con detalle capítulo , pero útil hacer resumen dicha téc- nica este momento. una revisión técnica una reunión celebrada por miembros del equipo software. por general, participan dos, tres cuatro personas, función del alcance información del diseño que revisará. cada persona tiene papel: líder revisión planea reunión, establece agenda coordina junta; secretario toma notas para que pierda nada; productor persona cuyo trabajo (por ejemplo, diseño componente del software) revisa. antes reunión, entrega cada persona del equipo una copia del producto del trabajo diseño pide que lea que busque errores, omisiones ambigüedades. obje-tivo comenzar reunión detectar todos los problemas del pro-ducto, modo que puedan corregirse antes que comience implementación. común que dure entre minutos horas. final ella, equipo revisión determina requiere otras acciones por parte del productor fin que apruebe producto como porción del modelo del diseño final.información evaluación calidad del diseño. revisión técnica atributos calidad. hewlett-packard [gra] desarrolló conjunto atributos calidad del software los que dio acrónimo furps: funcionalidad, usabilidad, confiabili- dad, rendimiento mantenibilidad. los atributos calidad furps representan objetivo todo diseño software:cita: “ calidad algo que deje arriba los sujetos obje-tos como fuera remate árbol navidad.” robert pirsig (-).indd (-).indd // ::// :: parte dos modelado • funcionalidad califica acuerdo con conjunto características capacidades del programa, generalidad las funciones que entregan seguridad general del sistema. • usabilidad evalúa tomando cuenta factores humanos (véase capítulo ), estética general, consistencia documentación. • confiabilidad evalúa con medición frecuencia gravedad las fallas, exactitud los resultados que salen, tiempo medio para que ocurra una falla (tmpf), capacidad recuperación ante ésta predecible del programa. • rendimiento mide con base velocidad procesamiento, tiempo respuesta, uso recursos, conjunto eficiencia. • mantenibilidad combina capacidad del programa para ser ampliable (extensibi-lidad), adaptable servicial (estos tres atributos denotan con término más común: mantenibilidad), además que pueda probarse, ser compatible configurable (capacidad organizar controlar los elementos configuración del software, véase capítulo ) que cuente con facilidad para instalarse sistema para que detecten los problemas. todo atributo calidad del software pondera por igual diseñarlo. una aplicación tal vez aboque funcional con énfasis seguridad. otra quizá busque rendimiento con mira puesta velocidad procesamiento. una tercera persigue confiabilidad. sin importar ponderación, importante observar que estos atributos calidad deben -marse cuenta cuando comienza diseño, cuando haya terminado éste construcción encuentre marcha. .. evolución del diseño del software evolución del diseño del software proceso continuo que cubierto casi seis déca-das. los primeros trabajos diseño concentraban criterios para desarrollo progra-mas modulares [den] métodos para mejorar estructuras software con enfoque arriba abajo [wir]. los aspectos procedimiento del diseño evolucionaron hacia una filoso-fía llamada programación estructurada [dah], [mil]. los trabajos posteriores propusieron métodos para traducir flujo datos [ste] estructura éstos (por ejemplo, [jac], [war]) una definición diseño. los enfoques más nuevos (por ejemplo, [jac], [gam]) propusieron enfoque orientado objeto para diseñar derivaciones. los últimos tiempos, énfasis desarrollar software pone arquitectura éste [kru] los patrones diseño susceptibles emplearse para implementar arquitecturas niveles más bajos abs-tracciones del diseño (por ejemplo, [hol], [sha]). cada vez más importancia los métodos orientados aspecto (por ejemplo, [cla], [jac]), desarrollo orientado modelo [sch] las pruebas [ast], que concentran llegar una modularidad eficaz estructura arquitectónica los diseños que generan. industria del software aplican varios métodos diseño, aparte los menciona- dos. igual que los métodos análisis presentados los capítulos , cada método diseño software introduce heurística notación únicas, así como punto vista sobre que caracteriza calidad diseño. obstante, todos estos métodos tienen algunas caracte-rísticas común: ) mecanismo para traducir modelo requerimientos una repre-sentación del diseño, ) una notación para representar las componentes funcionales sus -terfaces, ) una heurística para mejorar hacer particiones ) lineamientos para evaluar calidad. sin importar método diseño que utilice, debe aplicarse conjunto conceptos básicos diseño nivel datos, arquitectura, interfaz componente. las secciones que siguen estudian estos conceptos.los diseñadores del software tienden centrarse problema que resolver. olvide que los atributos furps siempre forman parte del problema. deben tomarse cuenta.consejo cita: “ diseñador sabe que alcanzó perfección cuando hay nada por agregar, sino cuando hay nada que quitar.” antoine saint-exupery ¿qué características son comunes todos los métodos diseño?? (-).indd (-).indd // ::// :: conceptos diseño . conceptos diseño durante historia ingeniería software, evolucionado conjunto conceptos fundamentales sobre diseño. aunque con paso los años variado grado interés cada concepto, todos han soportado prueba del tiempo. cada uno diseñador del software fundamento desde que pueden aplicarse métodos diseño sofisticados. todos ayudan responder las preguntas siguientes: • ¿qué criterios usan para dividir software sus componentes individuales? • ¿cómo extraen los detalles función estructura datos representación conceptual del software? • ¿cuáles son los criterios uniformes que definen calidad técnica diseño software? . . jackson [jac] dijo: “ principio sabiduría [para ingeniero software] reconocer diferencia que hay entre hacer que programa funcione lograr que haga bien”. los conceptos fundamentales del diseño del software proveen estructura necesaria para “hacerlo bien”. las secciones que siguen, panorama breve los conceptos importantes del - seño software, tanto del desarrollo tradicional como del orientado objeto. .. abstracción cuando considera una solución modular para cualquier problema, posible plantear -chos niveles abstracción. más elevado enuncia una solución términos gruesos con uso del lenguaje del ambiente del problema. niveles más bajos abstracción descripción más detallada solución. terminología orientada problema acopla con que orienta implementación, esfuerzo por enunciar solución. por último, . estudiar modelo del dominio informa- ción diseñar las estructuras datos apropiadas para los objetos datos sus atributos. . seleccionar estilo arquitectura que sea ade- cuado para software con uso del modelo análisis. . hacer partición del modelo análisis subsistemas diseño asignar éstos dentro arquitectura: asegúrese que cada subsistema sea cohesivo sus funciones. diseñe interfaces del subsistema. asigne clases análisis funciones cada subsistema. . crear conjunto clases diseño componentes: traduzca descripción clases análisis una clase diseño. compare cada clase diseño con los criterios diseño; considere los aspectos hereditarios. defina métodos mensajes asociados con cada clase diseño. evalúe seleccione patrones diseño para una clase diseño subsistema. revise las clases diseño , requiere, modifíquelas. . diseñar cualesquiera interfaces requeridas con sistemas dis- positivos externos. . diseñar interfaz usuario. revise los resultados del análisis tareas. especifique secuencia acciones con base los escenarios usuario. cree modelo comportamiento interfaz. defina los objetos interfaz los mecanismos control. revise diseño interfaz , requiere, modifíquelo. . efectuar diseño nivel componente. especifique todos los algoritmos nivel abstracción relativamente bajo. mejore interfaz cada componente. defina estructuras datos nivel componente. revise cada componente corrija todos los errores que detecten. . desarrollar modelo despliegue.conjunto tareas conjunto tareas generales para diseño cita: “ abstracción uno los modos fundamentales con los que los humanos luchamos con complejidad.” grady booch (-).indd (-).indd // ::// :: parte dos modelado nivel abstracción más bajo plantea solución, modo que pueda implementarse directamente. cuando desarrollan niveles abstracción distintos, trabaja para crear abstracciones tanto procedimiento como datos. una abstracción procedimiento una secuencia instrucciones que tienen una función específica limitada. nombre abstracción pro-cedimiento implica estas funciones, pero omiten detalles específicos. ejemplo esto sería palabra abrir, caso una puerta. abrir implica una secuencia larga pasos del procedimiento (caminar hacia puerta, llegar tomar picaporte, girar éste jalar puerta, retroceder para que puerta abra, etcétera). una abstracción datos conjunto éstos con nombre que describe objeto datos. contexto abstracción procedimiento abrir, puede definirse una abstracción datos llamada puerta. como cualquier objeto datos, abstracción datos para puerta agruparía conjunto atributos que describirían puerta (tipo, dirección del abatimiento, mecanismo apertura, peso, dimensiones, etc.). concluye que abstracción procedi-miento abrir usaría información contenida los atributos abstracción datos puerta. .. arquitectura arquitectura del software alude “ estructura general éste las formas las que ésta integridad conceptual sistema” [sha]. forma más sencilla, arquitectura estructura organización los componentes programa (módulos), forma que éstos interactúan estructura datos que utilizan. sin embargo, sentido más amplio, los componentes generalizan para que representen los elementos sistema grande sus interacciones. una meta del diseño del software obtener una aproximación arquitectónica sistema. ésta sirve como estructura partir cual realizan las actividades diseño más detalla-das. conjunto patrones arquitectónicos permite que ingeniero software resuelva problemas diseño comunes. shaw garlan [sha] describen conjunto propiedades que deben especificarse como parte del diseño arquitectura: propiedades estructurales. este aspecto representación del diseño arquitectónico define los componentes sistema (módulos, objetos, filtros, etc.) manera que están agrupados interactúan unos con otros. por ejemplo, los objetos agrupan para que encapsulen tanto datos como procedimiento que los manipula interactúen invocando métodos. propiedades extrafuncionales. descripción del diseño arquitectónico debe abordar forma que arquitectura del diseño satisface los requerimientos desempeño, capacidad, confiabi-lidad, seguridad adaptabilidad, así como otras características del sistema. familias sistemas relacionados. diseño arquitectónico debe basarse patrones repeti- bles que común encontrar diseño familias sistemas similares. esencia, diseño debe tener capacidad reutilizar bloques construcción arquitectónica. dada especificación estas propiedades, diseño arquitectónico representa con uso uno más varios modelos diferentes [gar]. los modelos estructurales representan arquitectura como conjunto organizado componentes del programa. los modelos marco aumentan nivel abstracción del diseño, tratar identificar patrones diseño arquitec-tónico repetibles que encuentran tipos similares aplicaciones. los modelos dinámicos abordan los aspectos estructurales arquitectura del programa indican cómo cambia como diseñador, trabaje mucho para obtener abstracciones tanto procedimiento como datos que sirvan para problema cuestión. será aún mejor sirvieran para dominio completo problemas.consejo sin embargo, debe notarse que conjunto operaciones puede reemplazarse con otro, tanto función que implica abstracción procedimiento sea misma. por tanto, los pasos requeridos para implementar abrir cambiarían mucho puerta fuera automática tuviera sensor.cita: “una arquitectura del software producto del trabajo desarrollo que tiene rentabili-dad más alta para una inversión cuanto calidad, secuencia actividades costo.” len bass . deje azar arquitectura. hace, pasará resto del proyecto forzándola para que ajuste diseño. diseñe arquitectura explícitamente.consejowebref dirección edu/ata/ata_init.html hay análisis profundo arquitectura del software. (-).indd (-).indd // ::// :: conceptos diseño estructura configuración del sistema función eventos externos. los modelos del proceso centran diseño del negocio proceso técnico que debe dar acomodo sistema. por último, los modelos funcionales usan para representar jerarquía funcional sistema. para representar estos modelos, desarrollado cierto número lenguajes descripción arquitectónica (lda) [sha]. aunque han sido propuestos muchos lda diferentes, mayoría tiene mecanismos para describir los componentes del sistema manera que conectan entre . debe observarse que hay debate acerca del papel que tiene arquitectura diseño. algunos investigadores afirman que obtención arquitectura del software debe separarse del diseño que ocurre entre las acciones ingeniería requerimientos las del diseño más convencional. otros piensan que definición arquitectura parte integral del pro-ceso diseño. capítulo estudia forma que caracteriza arquitectura del software papel diseño. .. patrones brad appleton define patrón diseño manera siguiente: “ una mezcla con nombre propio puntos vista que contienen esencia una solución demostrada para pro-blema recurrente dentro cierto contexto necesidades competencia” [app]. dicho otra manera, patrón diseño describe una estructura diseño que resuelve problema particular del diseño dentro contexto específico entre “fuerzas” que afectan manera que aplica que utiliza dicho patrón. objetivo cada patrón diseño proporcionar una descripción que permita dise- ñador determinar ) patrón aplicable trabajo cuestión, ) puede volverse usar (con que ahorra tiempo diseño) ) sirve como guía para desarrollar patrón distinto funciones estructura. capítulo estudian los patrones diseño. .. división problemas división problemas concepto diseño que sugiere que cualquier problema complejo puede manejarse con más facilidad subdivide elementos susceptibles resolverse optimizarse manera independiente. problema una característica comportamiento que especifica modelo los requerimientos para software. separar problema sus piezas más pequeñas por ello más manejables, requiere menos esfuerzo tiempo para resolverlo. para dos problemas, , complejidad que percibe para mayor que percibida para , entonces concluye que esfuerzo requerido para resolver mayor que nece- sario para resolver . como caso general, este resultado intuitivamente obvio. lleva más tiempo resolver problema difícil. también concluye que cuando combinan dos problemas, con frecuencia complejidad percibida mayor que suma complejidad tomada por separado. esto lleva estrategia divide vencerás, pues más fácil resolver problema complejo divide elementos manejables. esto tiene implicaciones importantes relación con modularidad del software. división problemas manifiesta otros conceptos diseño relacionados: modula- ridad, aspectos, independencia funcionamiento mejora. cada uno éstos estudiará las secciones siguientes. .. modularidad modularidad manifestación más común división problemas. software -vide componentes con nombres distintos abordables por separado, ocasiones llamados módulos, que integran para satisfacer los requerimientos del problema.cita: “cada patrón describe pro- blema que ocurre una otra vez nuestro ambiente, por que describe núcleo solución ese problema, forma tal que puede usarse ésta millón veces sin repetir mismo una sola vez.” christopher alexander argumento para separar los problemas puede llevarse demasiado lejos. divide problema número muy grande problemas muy pequeños, será fácil resolver cada uno éstos, pero unificarlos solución (integración) será muy difícil.consejo (-).indd (-).indd // ::// :: parte dos modelado dicho que “ modularidad único atributo del software que permite que pro- grama sea manejable intelectual” [mye]. software monolítico ( programa grande compuesto solo módulo) fácil entender para ingeniero software. número trayectorias control, alcance referencia, número variables complejidad general haría que comprenderlo fuera casi imposible. función las circunstancias, diseño debe descomponerse muchos módulos con esperanza que sea más fácil entenderlos , consecuencia, reducir costo requerido para elaborar software. según punto vista división problemas, sería posible concluir que software dividiera forma indefinida, esfuerzo requerido para desarrollarlo ¡sería despreciable por pequeño! desafortunadamente, hay otras fuerzas que entran juego que hacen que esta conclusión sea (tristemente) inválida. acuerdo con figura ., esfuerzo (costo) desa-rrollar módulo individual software disminuye conforme aumenta número total -dulos. dado mismo conjunto requerimientos, tener más módulos significa tamaños indi-viduales más pequeños. sin embargo, medida que incrementa número módulos, esfuerzo (costo) asociado con integración también aumenta. estas características llevan una curva costo total como que muestra figura. existe número, , módulos que arrojarían mínimo costo desarrollo, pero dispone las herramientas necesarias para predecir con exactitud. las curvas que aparecen figura . constituyen una guía útil considerar modulari- dad. deben hacerse módulos, pero con cuidado para permanecer cercanía . debe evitarse hacer pocos muchos módulos. pero, ¿cómo saber cuál cercanía ? ¿cuán modular debe hacerse software? las respuestas estas preguntas requieren comprensión otros conceptos diseño que analizan más adelante este capítulo. debe hacerse diseño ( programa resultante) con módulos, manera que desarrollo pueda planearse con más facilidad, que sea posible definir desarrollar los incrementos del software, que los cambios realicen con más facilidad, que las pruebas depuración efectúen con mayor eficiencia que mantenimiento largo plazo lleve cabo sin efectos colaterales importancia. .. ocultamiento información concepto modularidad lleva una pregunta fundamental: “¿cómo descomponer una -lución software para obtener mejor conjunto módulos?” principio del ocultamiento información sugiere que los módulos “caractericen por decisiones diseño que ocul-ten (cada una) las demás”. otras palabras, deben especificarse diseñarse módulos, forma que información (algoritmos datos) contenida módulo sea inaccesible para los que necesiten ella.mregión costo mínimo número móduloscosto del esfuerzo costo por módulocosto integracióncosto total del softwarefigura . modularidad costo del software ¿cuál número correcto módulos para sistema dado?? punto clave objetivo ocultar información esconder los detalles las estructuras datos procesamiento tras una interfaz módulo. necesario que los usuarios éste los conozcan. (-).indd (-).indd // ::// :: conceptos diseño ocultamiento implica que modularidad efectiva logra definiendo conjunto - dulos independientes que intercambien sólo aquella información necesaria para lograr fun- ción del software. abstracción ayuda definir las entidades procedimiento ( informativas) que constituyen software. ocultamiento define hace cumplir las restricciones acceso tanto los detalles procedimiento como cualquier estructura datos local que utilice módulo [ros]. uso del ocultamiento información como criterio diseño para los sistemas modulares proporciona los máximos beneficios cuando requiere hacer modificaciones durante las prue-bas, más adelante, dar mantenimiento software. debido que mayoría los datos detalles del procedimiento quedan ocultos para otras partes del software, menos probable que los errores inadvertidos introducidos durante modificación propaguen distintos sitios dentro del software. .. independencia funcional concepto independencia funcional resultado directo separación problemas los conceptos abstracción ocultamiento información. escritos cruciales sobre -seño software, wirth [wir] parnas [par] mencionan técnicas mejora que promueven independencia modular. los trabajos posteriores stevens, myers constantine [ste] dan solidez concepto. independencia funcional logra desarrollando módulos con funciones “miopes” que tengan “aversión” interacción excesiva con otros módulos. dicho otro modo, debe dise-ñarse software manera que cada módulo resuelva subconjunto específico requerimien-tos tenga una interfaz sencilla cuando vea desde otras partes estructura del programa. lógico preguntar por qué importante independencia. software con modularidad eficaz, decir, con módulos independientes, más fácil desarrollar porque función subdivide las interfaces simplifican (cuando desarrollo efectuado por equipo hay que considerar las ramificaciones). los módulos independientes son más fáciles mantener ( probar) debido que los efectos secundarios causados por diseño por modificación del código son limitados, reduce propagación del error posible obtener módulos reutilizables. resumen, independencia funcional una clave para buen diseño éste clave calidad del software. independencia evalúa con uso dos criterios cualitativos: cohesión acopla- miento. cohesión indicador fortaleza relativa funcional módulo. acopla- miento independencia relativa entre módulos. cohesión una extensión natural del concepto ocultamiento información descrito sección ... módulo cohesivo ejecuta una sola tarea, por que requiere interactuar poco con otros componentes otras partes del programa. pocas palabras, módulo -hesivo debe (idealmente) hacer sólo una cosa. aunque siempre debe tratarse lograr mucha cohesión (por ejemplo, una sola tarea), con frecuencia necesario aconsejable hacer que componente software realice funciones múltiples. sin embargo, para lograr buen -seño hay que evitar los componentes “esquizofrénicos” (módulos que llevan cabo funciones relacionadas). acoplamiento una indicación interconexión entre módulos una estructura software, depende complejidad interfaz entre módulos, del grado que entra hace referencia módulo qué datos pasan través interfaz. diseño software, debe buscarse mínimo acoplamiento posible. conectividad simple entre módulos como resultado software que más fácil entender menos propenso “efecto oleaje” [ste], ocasionado cuando ocurren errores sitio propagan por todo sis-tema.¿por qué debe tratarse crear módulos independientes?? punto clave cohesión indicador cualitativo del grado que módulo centra hacer una sola cosa. punto clave acoplamiento indicador cualitativo del grado que módulo está conectado con otros con mundo exterior. (-).indd (-).indd // ::// :: parte dos modelado .. refinamiento refinamiento stepwise una estrategia diseño propuesta originalmente por niklaus wirth [wir]. programa elabora por medio del refinamiento sucesivo los detalles del proce-dimiento. desarrolla una jerarquía con descomposición enunciado macroscópico función (abstracción del procedimiento) forma escalonada hasta llegar los comandos del lenguaje programación. realidad, refinamiento proceso elaboración. comienza con enunciado función ( descripción información), definida nivel abstracción alto. decir, enunciado describe función información manera conceptual, pero dice nada sobre los trabajos internos función estructura interna información. después tra-baja sobre enunciado original, dando más más detalles conforme tiene lugar refinamiento (elaboración) sucesivo. abstracción refinamiento son conceptos complementarios. primera permite espe- cificar internamente procedimiento los datos, pero elimina necesidad que los “extra-ños” conozcan los detalles bajo nivel. refinamiento ayuda revelar estos detalles medida que avanza diseño. ambos conceptos permiten crear modelo completo del diseño con-forme éste evoluciona. .. aspectos conforme tiene lugar análisis los requerimientos, surge conjunto “preocupaciones” que “incluyen requerimientos, casos uso, características, estructuras datos, calidad del servicio, variantes, fronteras las propiedades intelectuales, colaboraciones, patrones con-tratos” [aos]. idealmente, modelo requerimientos organiza manera que permita aislar cada preocupación (requerimiento) fin considerarla forma independiente. sin embargo, práctica, algunas estas preocupaciones abarcan todo sistema fácil dividirlas compartimientos. cuando comienza diseño, los requerimientos son refinados una representación - seño modular. considere dos requerimientos, . interfiere con “ elegido una descomposición [refinamiento] que puede satisfacerse sin tomar cuenta ” [ros]. por ejemplo, considere dos requerimientos para webapp casaseguraasegurada.com. requerimiento describe con caso uso avc-dvc analizado capítulo . refina- miento del diseño centraría aquellos módulos que permitieran que usuarios registrados accedieran video cámaras situadas espacio. requerimiento seguridad establece que usuario registrado debe ser validado antes que use casaseguraasegurada. com. este requerimiento aplicable todas las funciones disponibles para los usuarios regis-trados casasegura. cuando ocurre refinamiento del diseño, * una representación del diseño para requerimiento , * otra para requerimiento . por tanto, * * son - presentaciones las preocupaciones, * interfiere con *. aspecto una representación una preocupación interferencia. entonces, repre- sentación del diseño, *, del requerimiento usuario registrado debe ser validado antes que use casaseguraasegurada.com aspecto webapp casasegura. importante identi- ficar aspectos, modo que diseño les pueda dar acomodo conforme sucede refinamiento división módulos. contexto ideal, aspecto implementa como módulo (compo-nente) separado como fragmentos software “dispersos” “regados” muchos compo-nentes [ban]. para lograr esto, arquitectura del diseño debe apoyar mecanismo para definir aspecto: módulo que permita implementar preocupación todas aquellas con las que interfiera.existe tendencia pasar inmediato los detalles ignorar los pasos del refinamiento. esto genera errores hace que diseño sea mucho más difícil revisar. realice refinamiento stepwise.consejo cita: “ difícil leer libro sobre los principios magia sin echar una mirada vez cuando portada para asegurarse que texto sobre diseño software.” bruce tognazzini punto clave una preocupación interferencia alguna característica del sistema que aplica través muchos requerimientos distintos. (-).indd (-).indd // ::// :: conceptos diseño .. rediseño una actividad diseño importante que sugiere para muchos métodos ágiles (véase capí- tulo ) rediseño, técnica reorganización que simplifica diseño ( código) com- ponente sin cambiar función comportamiento. fowler [fow] define rediseño del modo siguiente: “ proceso cambiar sistema software forma tal que altera comportamiento externo del código [diseño], pero mejora estructura interna.” cuando rediseña software, examina diseño existente busca redundancias, elementos diseño utilizados, algoritmos ineficientes innecesarios, estructuras datos mal construidas inapropiadas cualquier otra falla del diseño que pueda corregirse para -tener diseño mejor. por ejemplo, una primera iteración diseño tal vez genere compo-nente con poca cohesión (realiza tres funciones que tienen poca relación entre ). después análisis cuidadoso, decide rediseñar componente tres componentes separados, cada uno con mucha cohesión. resultado será software más fácil integrar, probar mantener.webref dirección com, encuentran recursos excelentes para rediseño. webref http://.com/cgi/wiki?refactoringpatterns, encuentran varios patrones rediseño. escena: cubículo vinod, cuando comienza modelado del diseño. participantes: vinod, jamie , miembros del equipo inge- niería del software casasegura. también shakira, nueva inte- grante del equipo. conversación: [los cuatro miembros del equipo acaban regresar semina- rio matutino llamado “aplicación los conceptos básicos del dise-”, ofrecido por una profesora local ciencias computación.] vinod: ¿les dejó algo seminario? : sabíamos mayor parte que trató, pero creo que fue mala idea escucharlo nuevo. jamie: cuando estudiaba carrera ciencias compu tación, nunca entendí, realidad, por qué era tan importante, como decían, ocultar información. vinod: por… línea base… una técnica para reducir pro- pagación del error programa. realidad, independencia funcional hace mismo. shakira: estudié una carrera computación, así que mucho que dijo instructor fue nuevo para . soy capaz generar buen código rápido. veo por qué tan importante todo eso.jamie: visto trabajo, shak, aplicas manera natural mucho que habló… ésa razón por que funcionan bien tus diseños códigos. shakira (sonríe): bueno, siempre trato realizar partición del código, hacer que aboque una cosa, construir interfaces senci-llas restringidas, reutilizar código siempre que pueda… esa clase cosas. : modularidad, independencia funcional, ocultamiento, patro- nes… veo. jamie: todavía recuerdo primer curso programación que tomé… nos enseñaron refinar código forma iterativa. vinod: mismo puede aplicarse diseño, sabes.vinod: los únicos conceptos que había escuchado antes fueron los “aspectos” “rediseño”. shakira: eso utiliza programación extrema.: . muy diferente del refinamiento, sólo que haces una vez terminado diseño código. preguntan, diré que algo así como una etapa optimización del software. jamie: volvamos diseño casasegura. pienso que mientras desarrollemos modelo diseño, debemos poner estos concep-tos nuestra lista revisión. vinod: estoy acuerdo. pero importante que todos nos com- prometamos pensar ellos hacer diseño.casasegura conceptos diseño .. conceptos diseño orientados objeto paradigma orientación objeto () utiliza mucho ingeniería software - derna. apéndice está pensado para aquellos lectores que estén familiarizados con los conceptos diseño , tales como clases objetos, herencia, mensajes polimorfismo, entre otros. (-).indd (-).indd // ::// :: parte dos modelado .. clases diseño modelo requerimientos define conjunto clases análisis (capítulo ). cada una describe algún elemento del dominio del problema centra aspectos éste que son -sibles para usuario. nivel abstracción una clase análisis relativamente alto. conforme diseño evoluciona, definirá conjunto clases diseño que refinan las clases análisis, dando detalles del diseño que permitirán que las clases implementen generen una infraestructura para software que apoye solución negocios. pueden desa-rrollarse cinco tipos diferentes clases diseño, cada una las cuales representa una capa distinta arquitectura del diseño [amb]: • clases usuario interfaz. definen todas las abstracciones necesarias para inte-racción humano-computadora (ihc). muchos casos, ihc ocurre dentro del contexto una metáfora (por ejemplo, cuaderno notas, formato orden, máquina fax, etc.) las clases del diseño para interfaz son representaciones visuales los elementos metáfora. • clases del dominio negocios. frecuente que sean refinamientos las clases análisis definidas antes. las clases identifican los atributos servicios (métodos) que requieren para implementar algunos elementos del dominio negocios. • clases proceso. implantan abstracciones negocios bajo nivel que requieren para administrar por completo las clases dominio negocios. • clases persistentes. representan almacenamientos datos (por ejemplo, una base datos) que persistirán más allá ejecución del software. • clases sistemas. implantan las funciones administración control del software que permiten que sistema opere comunique dentro ambiente computación con mundo exterior. medida que forma arquitectura, nivel abstracción reduce cuando cada clase análisis transforma una representación del diseño. decir, las clases análisis repre-sentan objetos datos ( servicios asociados que aplican éstos) que usan terminología del dominio del negocio. las clases diseño presentan muchos más detalles técnicos como guía para implementación. arlow neustadt [arl] sugieren que revise cada clase diseño para asegurar que esté “bien formada”. definen cuatro características las clases diseño bien formadas: completa suficiente. una clase diseño debe ser encapsulado total todos los atributos métodos que sea razonable esperar (con base una interpretación comprensi-ble del nombre clase) que existan para clase. por ejemplo, clase escena defi- nida para software edición video será completa sólo contiene todos los atribu-tos métodos que asocian manera razonable con creación una escena video. suficiencia asegura que clase diseño contiene sólo los métodos que bastan para -grar objetivo clase, más menos. primitivismo. los métodos asociados con una clase diseño deben centrarse cum- plimiento servicio para clase. una vez implementado servicio con método, clase debe proveer otro modo hacer mismo. por ejemplo, clase videoclip para software edición video tal vez tenga los atributos punto-inicial punto-final que - diquen los puntos inicio fin del corto (observe que video original cargado sis-tema puede ser más extenso que corto utilizado). los métodos establecerpuntoinicial ( ) establecerpuntofinal ( ) proporcionan los únicos medios para establecer los puntos -mienzo terminación del corto. mucha cohesión. una clase diseño cohesiva tiene conjunto pequeño centrado responsabilidades; para implementarlas emplea atributos métodos objetivo único. por ¿qué tipos clases crea diseñador?? ¿qué una clase diseño “bien formada”?? (-).indd (-).indd // ::// :: conceptos diseño ejemplo, clase videoclip quizá contenga conjunto métodos para editar corto video. cohesión mantiene tanto cada método centre sólo los atributos aso-ciados con corto. poco acoplamiento. dentro del modelo diseño, necesario que las clases diseño colaboren una con otra. sin embargo, colaboración debe mantenerse mínimo aceptable. modelo diseño está muy acoplado (todas las clases diseño colaboran con todas las demás), sistema difícil implementar, probar mantener con paso del tiempo. general, las clases diseño dentro subsistema deben tener sólo conocimiento limitado otras clases. esta restricción llama ley demeter [lie] - giere que método sólo debe enviar mensajes métodos que están clases vecinas. una manera menos formal ley demeter : “cada unidad debe hablar sólo con sus amigas: hablar con extraños”. apéndice encuentra método enseñanza sobre los conceptos notación básica del uml. escena: cubículo , cuando comienza modelado del diseño. participantes: vinod , miembros del equipo ingeniería software casasegura. conversación:[ está trabajando clase planodelaplanta (véanse recuadro sección .. figura .) refinado para modelo del diseño.] : entonces recuerdas clase planodelaplanta, ¿verdad? usa como parte las funciones vigilancia administración casa. vinod (afirma con cabeza): , recuerdo que usamos como parte nuestros análisis crc para administración casa. : así . cualquier modo, estoy mejorando para diseño. quiero mostrarte cómo implantaremos realidad clase plano-delaplanta. idea implementarla como conjunto listas ligadas [una estructura datos específica] modo que… tuve que refinar clase análisis planodelaplanta (véase figura .) , verdad, simplificarla.vinod: clase análisis sólo mostraba cosas dominio del problema, bueno, pantalla computadora, visibles para usuario final, ¿ acuerdo? : , pero para clase diseño planodelaplanta, tenido que agregar algunas cosas específicas para implantación. necesi- mostrar que planodelaplanta agregado segmentos— ahí clase segmento— que clase segmento está compuesta listas para segmentos pared, ventanas, puertas, etc. clase cámara colabora con planodelaplanta , obvia- mente, hay muchas cámaras piso. vinod: … veamos ilustración esta nueva clase diseño, planodelaplanta. [ muestra vinod diagrama que aparece figura ..]vinod: bien, veo que tratas hacer. esto permite modifi- car plano planta con facilidad porque los nuevos temas agregan, eliminan lista ( agregado), sin problemas. (asiente): , creo que funcionará.vinod: también .casasegura refinamiento una clase análisis una clase diseño . modelo del diseño modelo del diseño puede verse dos dimensiones distintas, como ilustra figura .. dimensión del proceso indica evolución del modelo del diseño conforme ejecutan las tareas éste como parte del proceso del software. dimensión abstracción representa nivel detalle medida que cada elemento del modelo análisis transforma equi-valente diseño luego mejora forma iterativa. relación con figura ., línea punteada indica frontera entre los modelos análisis diseño. ciertos casos, posi-ble hacer una distinción clara entre ambos modelos. otros, modelo análisis mezcla poco poco con diseño distinción menos obvia. los elementos del modelo diseño usan muchos los diagramas uml que utilizaron modelo del análisis. diferencia que estos diagramas refinan elaboran como parte (-).indd (-).indd // ::// :: parte dos modelado del diseño; dan más detalles específicos implantación hace énfasis estructura estilo arquitectónico, los componentes que residen dentro arquitectura las interfaces entre los componentes mundo exterior. obstante, debe observarse que los elementos del modelo indicados largo del eje - rizontal siempre desarrollan forma secuencial. mayoría los casos, diseño preliminar arquitectura establece etapa seguido del diseño interfaz del dise-planodelaplanta agregarcámara( ) agregarpared( )agregarventana( )eliminarsegmento( )dibujar( )tipodimensionesexteriores segmentodeparedsegmento comenzarcoordenadaterminarcoordenada obtenertipo( ) dibujar( ) ventanacámara tipo identiﬁcaciónvistageneralángulodevisiónprepararacercamiento * *figura . clase diseño para planodelaplanta composición del agregado para ella (véase análisis recuadro) dimensión del procesodimensión abstracción elementos arquitecturaelementos interfazelementos nivel componenteselementos nivel del desplieguebajoalto diagramas clase paquetes análisismodelos crcdiagramas colaboracióndiagramas ﬂujo datosdiagramas ﬂujo del controlnarrativas del procesamientocasos uso - texto diagramas actividadescasos uso - diagramasdiagramas canaldiagramas colaboracióndiagramas estadodiagramas secuencia realizaciones clase diseñosubsistemasdiagramas colaboración reﬁnamientos : diagramas desplieguediagramas clasepaquetes análisismodelos crcdiagramas colaboracióndiagramas ﬂujo datosnarrativas del procesamientodiagramas estadodiagramas secuencia diagramas componentes clases diseñodiagramas actividadesdiagramas secuencia reﬁnamientos : diagramas componentesclases diseñodiagramas actividaddiagramas secuenciarealizaciones clase diseñosubsistemasdiagramas colaboracióndiagramas componentesclases diseñodiagramas actividadesdiagramas secuenciamodelo del análisis modelo del diseñorequerimientos: restricciones interoperabilidad objetivos conﬁguración diseño interfaz técnica diseño navegación diseño interfaz gráﬁca usuario realizaciones clase diseño subsistemas diagramas colaboraciónfigura . dimensiones del modelo diseñopunto clave modelo diseño tiene cuatro elementos principales: datos, arquitectura, componentes interfaz. (-).indd (-).indd // ::// :: conceptos diseño del nivel los componentes, los cuales con frecuencia ocurren paralelo. modelo despliegue por general retrasa hasta que diseño haya sido desarrollado por completo. posible aplicar patrones diseño cualquier punto este proceso (véase capítulo ). estos patrones permiten aplicar conocimiento del diseño problemas específicos del dominio que han sido encontrados resueltos por otras personas. .. elementos del diseño datos igual que otras actividades ingeniería software, diseño datos ( ocasiones deno-minado arquitectura datos) crea modelo datos información que representa nivel abstracción elevado ( punto vista del usuario los datos). este modelo los datos refina después forma progresiva hacia representaciones más específicas -plementación que puedan ser procesadas por sistema basado computadora. muchas aplicaciones software, arquitectura los datos tendrá una influencia profunda -quitectura del software que debe procesarlo. estructura los datos siempre sido parte importante del diseño software. nivel componentes del programa, del diseño las estructuras datos los algoritmos requeridos para manipularlos, esencial creación aplicaciones alta calidad. nivel aplicación, traducción modelo datos (obtenido como parte ingeniería los requerimientos) una base datos crucial para lograr los objetivos negocios sistema. nivel negocios, conjunto información almacenada bases datos incompatibles reorganizados “data warehouse” permite minería datos descubri-miento conocimiento que tiene efecto éxito del negocio . cada caso, diseño los datos juega papel importante. diseño datos estudia con más detalle -pítulo . .. elementos del diseño arquitectónico diseño arquitectura del software equivalente del plano una casa. éste ilustra distribución general las habitaciones, tamaño, forma relaciones entre ellas, así como las puertas ventanas que permiten movimiento entre los cuartos. plano una visión gene-ral casa. los elementos del diseño arquitectura dan visión general del software. modelo arquitectónico [sha] proviene tres fuentes: ) información sobre dominio aplicación del software que elaborar, ) los elementos específicos del modelo requerimientos, tales como diagramas flujo datos clases análisis, sus relaciones colaboraciones para problema cuestión ) disponibilidad estilos arquitectónicos (capítulo ) sus patrones (capítulo ). por general, elemento diseño arquitectónico ilustra como conjunto sistemas interconectados, con frecuencia obtenidos paquetes análisis dentro del modelo reque-rimientos. cada subsistema puede tener propia arquitectura (por ejemplo, interfaz gráfica usuario puede estar estructurada acuerdo con estilo arquitectura preexistente para interfaces usuario). capítulo presentan técnicas para obtener elementos específicos del modelo arquitectónico. .. elementos diseño interfaz diseño interfaz para software análogo conjunto trazos ( especificaciones) detalladas para las puertas, ventanas instalaciones una casa. tales dibujos ilustran -maño forma puertas ventanas, manera que operan, forma que llegan las instalaciones servicios (agua, electricidad, gas, teléfono, etc.) vivienda distribuyen entre las habitaciones indicadas plano. indican dónde está timbre puerta, usará intercomunicador para anunciar presencia visitante cómo instalar cita: “las preguntas acerca diseño necesario digno pagarse están más allá discusión: diseño inevita-ble. alternativa buen diseño mal diseño, falta diseño.” douglas martin punto clave nivel arquitectura (aplicación), diseño los datos centra archivos bases datos; los componentes, diseño datos considera las estructuras datos que requieren para implementar objetos datos locales. cita: “puede usarse una goma mesa dibujo marro sitio construido.” frank lloyd wright cita: “ público está más familiariza- con mal diseño que con buen diseño. realidad, está condicionado para que prefiera mal diseño porque con que vive. nuevo parece amenazador; viejo seguridad.” paul rand (-).indd (-).indd // ::// :: parte dos modelado sistema seguridad. esencia, los planos ( especificaciones) detallados para las puertas, ventanas instalaciones externas nos dicen cómo fluyen las cosas información hacia dentro fuera casa dentro los cuartos que forman parte del plano. los elementos diseño interfaz del software permiten que información fluya hacia dentro afuera del sistema, cómo están comunicados los componentes que son parte arquitectura. hay tres elementos importantes del diseño interfaz: ) interfaz usuario (), ) las interfaces externas que tienen que ver con otros sistemas, dispositivos, redes otros produc-tores consumidores información ) interfaces internas que involucran los distintos componentes del diseño. estos elementos del diseño interfaz permiten que software comunique externamente permita comunicación colaboración internas entre los com-ponentes que constituyen arquitectura del software. diseño (denominada cada vez con más frecuencia diseño usabilidad) una acción principal ingeniería software estudia con detalle capítulo . diseño usabilidad incorpora elementos estéticos (como distribución, color, gráficos, mecanismos interacción, etc.), elementos ergonómicos (por ejemplo, distribución colocación infor-mación, metáforas, navegación por , etc.) elementos técnicos (como patrones patrones reutilizables). general, subsistema único dentro arquitectura gene-ral aplicación. diseño interfaces externas requiere información definitiva sobre entidad que envía información desde que recibe. todo caso, esta información debe recabarse -rante ingeniería requerimientos (capítulo ) verificarse una vez que comienza diseño interfaz. diseño interfaces externas debe incorporar revisión busca errores (cuando sea necesario) las medidas seguridad apropiadas. diseño las interfaces internas relaciona cerca con diseño componentes (véase capítulo ). las realizaciones del diseño las clases análisis representan todas las operaciones esquemas mensajería que requieren para permitir comunicación colaboración entre las operaciones distintas clases. cada mensaje debe diseñarse para que contenga información que requiere transmitir los requerimientos específicos fun-ción operación que solicitado. para diseño elige enfoque clásico proceso entrada-salida, interfaz cada componente del software diseña con base las representaciones del flujo datos funcionalidad descrita una narrativa proce-samiento. ciertos casos, una interfaz modela forma muy parecida una clase. uml define interfaz del modo siguiente [omg]: “ especificador para las operaciones visi-bles desde exterior [públicas] una clase, componente otro clasificador (incluso sub-sistemas), sin especificar estructura interna.” pocas palabras, una interfaz conjunto operaciones que describen alguna parte del comportamiento una clase dan acceso aquéllas. por ejemplo, función seguridad casasegura hace uso del panel control que permite que propietario controle ciertos aspectos función seguridad. una versión avanzada del sistema, las funciones del panel control podrían implementarse través pda ina-lámbrico teléfono móvil. clase paneldecontrol (véase figura .) proporciona comportamiento asociado con teclado, por que debe implementar las operaciones leerteclazo ( ) decodificartecla ( ). estas operaciones van dar otras clases ( este caso, pdainalámbrico teléfonomó- vil), útil definir una interfaz como figura. interfaz, llamada teclado, ilustra como estereotipo <<interfaz como círculo pequeño con leyenda conectado clase punto clave hay tres partes para elemento diseño interfaz: interfaz usuario, las interfaces dirigidas hacia sistema externo aplicación las interfaces orientadas hacia los componentes dentro ésta. las características interfaz pueden cambiar con tiempo. por tanto, diseñador debe cerciorarse que especificación para ella sea exacta completa.cita: “ vez cuando apártate, relájate poco, para que cuan- regreses trabajo criterio sea más seguro. toma algo distancia porque entonces tra-bajo parece más pequeño posible apreciar una porción mayor con una sola mirada, modo que detecta con facili-dad falta armonía proporción.” leonardo vinci webref dirección encuentra información sumamente valiosa sobre diseño . cita: “ error común que comete gente cuando trata diseñar algo prueba tontos sub-estimar ingenuidad los completamente tontos.” douglas adams (-).indd (-).indd // ::// :: conceptos diseño con una línea. interfaz define sin atributos con conjunto operaciones que sean necesarias para lograr comportamiento teclado. línea punteada con triángulo abierto extremo ( figura .) indica que clase paneldecontrol proporciona las operaciones teclado como parte comportamiento. uml, esto caracteriza como una realización. decir, parte del comportamiento - neldecontrol implementará con realización las operaciones teclado. éstas darán otras clases que accedan interfaz. .. elementos del diseño nivel los componentes diseño nivel los componentes del software equivalente los planos ( especi-ficaciones) detallados cada habitación casa. estos dibujos ilustran cableado plomería cada cuarto, ubicación cajas eléctricas interruptores, grifos, coladeras, rega-deras, tinas, drenajes, gabinetes closets. también describen tipo piso que usar, las molduras que van aplicar todos los detalles asociados con una habitación. diseño componentes para software describe por completo los detalles internos cada compo-nente. para lograrlo, este diseño define estructuras datos para todos los objetos datos locales detalles algorítmicos para todo procesamiento que tiene lugar dentro compo-nente, así como interfaz que permite acceso todas las operaciones los componentes (comportamientos). contexto ingeniería software orientada objeto, componente representa forma diagrama uml, como ilustra figura .. ésta, aparece componente llamado administracióndesensor (parte función seguridad casasegura). una fle- cha punteada conecta componente con una clase llamada sensor, asignada. compo-paneldecontrol pantalladecristallíquido indicadoresluminososcaracterísticasdetecladobocinainterfazinalámbrica leerteclazo( ) decodiﬁcartecla( )desplegarestado( )encenderindicadoresluminosos( )enviarmensajedecontrol( ) leerteclazo( )decodiﬁcartecla( )teclado <<interfazpdainalámbricoteléfonomóvil tecladofigura . representación interfaz para paneldecontrol cita: “los detalles son los detalles. constituyen diseño.” charles eames administracióndesensor sensorfigura . diagrama componente uml (-).indd (-).indd // ::// :: parte dos modelado nente administracióndesensor lleva cabo funciones asociadas con los sensores casase- gura, incluso vigilancia configuración. capítulo analizan más los diagramas componentes. los detalles del diseño componente modelan muchos niveles abstracción diferentes. utiliza diagrama actividades uml para representar lógica del procesa-miento. flujo detallado del procedimiento para componente representa con seudocó-digo (representación que parece lenguaje programación que describe capí-tulo ) con alguna otra forma diagramática (como diagrama flujo cajas). estructura algorítmica sigue las reglas establecidas para programación estructurada (por ejemplo, conjunto construcciones restringidas procedimiento). las estructuras -tos, seleccionadas con base naturaleza los objetos datos que van procesar, por general modelan con empleo seudocódigo del lenguaje programación que usará para implementación. .. elementos del diseño del despliegue los elementos del diseño del despliegue indican forma que acomodarán funciona-lidad del software los subsistemas dentro del ambiente físico computación que apo-yará. por ejemplo, los elementos del producto casasegura configuran para que operen dentro tres ambientes computación principales: una casa, panel control casase- gura servidor alojado cpi corp. (que provee acceso sistema través internet). durante diseño desarrolla diagrama despliegue que después refina, como ilustra figura .. ella aparecen tres ambientes computación ( realidad habría más, con sensores cámaras, entre otros). indican los subsistemas (funcionalidad) que están alo-jados dentro cada elemento computación. por ejemplo, computadora personal aloja subsistemas que implementan características seguridad, vigilancia, administración del hogar comunicaciones. además, diseñado subsistema acceso externo para manejar -dos los intentos acceder sistema casasegura desde lugar externo. cada subsistema elaboraría para que indicara los componentes que implementa.punto clave los diagramas despliegue comienzan forma descriptor, donde ambiente despliegue describe términos generales. después utilizan formas instancia describen explícitamente los elementos configuración. servidor cpi panel control computadora personal seguridad administración delhogarvigilancia comunicaciónseguridad accesodelpropietario accesoexternofigura . diagrama despliegue uml (-).indd (-).indd // ::// :: conceptos diseño diagrama que aparece figura . formato descriptor. esto significa que diagrama despliegue muestra ambiente computación, pero indica manera explícita los detalles configuración. por ejemplo, mayor identificación “computado- personal”. puede ser una mac basarse windows, una estación trabajo sun sistema linux. estos detalles dan cuando regrese diagrama despliegue formato instan- cia las etapas finales del diseño, cuando comience construcción. identifica cada ins-tancia del despliegue (una configuración específica, llamada configuración del hardware ). . resumen diseño del software comienza cuando termina primera iteración ingeniería reque- rimientos. objetivo del diseño del software aplicar conjunto principios, conceptos prácticas que llevan desarrollo sistema producto alta calidad. meta del diseño crear modelo software que implantará correctamente todos los requerimientos del usuario causará placer quienes utilicen. los diseñadores del software deben elegir entre muchas alternativas diseño llegar solución que mejor adapte las necesidades los participantes proyecto. proceso diseño una visión “panorámica” del software otra más cercana que define detalle requerido para implementar sistema. proceso comienza por centrarse arquitectura. definen los subsistemas, establecen los mecanismos comunicación entre éstos, identifican los componentes desarrolla descripción detallada cada uno. además, diseñan las interfaces externa, interna usuario. los conceptos diseño han evolucionado los primeros años trabajo ingenie- ría software. describen atributos software computadora que debe presentarse sin -portar proceso que elija para hacer ingeniería, los métodos diseño que apliquen los lenguajes programación que utilicen. esencia, los conceptos diseño ponen énfasis necesidad abstracción como mecanismo para crear componentes reutiliza-bles software, importancia arquitectura como forma entender mejor estruc-tura general sistema, los beneficios ingeniería basada patrones como técnica diseño software con capacidad comprobada, valor separación problemas modularidad eficaz como forma elaborar software más entendible, más fácil probar recibir mantenimiento, las consecuencias ocultar información como mecanismo para reducir propagación los efectos colaterales cuando hay errores, efecto indepen-dencia funcional como criterio para construir módulos eficaces, uso del refinamiento como mecanismo diseño, una consideración los aspectos que interfieren con los requeri-mientos del sistema, aplicación del rediseño para optimizar diseño obtenido importancia las clases orientadas objetos las características relacionadas con ellos. modelo del diseño incluye cuatro elementos distintos. conforme desarrolla cada uno, surge una visión más completa del diseño. elemento arquitectónico emplea información -tenida del dominio aplicación, del modelo requerimientos los catálogos disponibles patrones estilos para obtener una representación estructural completa del software, sus subsistemas componentes. los elementos del diseño interfaz modelan las interfaces internas externas usuario. los elementos nivel componentes definen cada uno los módulos (componentes) que constituyen arquitectura. por último, los elementos del diseño albergan arquitectura, sus componentes las interfaces dirigidas hacia configura-ción física que alojará software. problemas puntos por evaluar .. cuando “escribe” programa, ¿ diseña software? ¿ qué difieren diseño software - dificación? (-).indd (-).indd // ::// :: parte dos modelado .. diseño del software programa ( ), entonces, ¿qué ? .. ¿cómo evalúa calidad del diseño del software? .. estudie conjunto tareas presentado para diseño. ¿dónde evalúa calidad dicho conjunto? ¿cómo logra? ¿cómo consiguen los atributos calidad estudiados sección ..? .. ejemplos tres abstracciones datos las abstracciones procedimiento que usan para manipularlas... describa con sus propias palabras arquitectura software. .. sugiera patrón diseño que encuentre una categoría objetos cotidianos (por ejemplo, elec- trónica consumo, automóviles, aparatos, etc.). describa patrón forma breve... describa con sus propias palabras separación problemas. ¿hay algún caso que sea apro- piada estrategia divide vencerás? ¿cómo afecta esto argumento favor modularidad?.. ¿cuándo debe implementarse diseño modular como software monolítico? ¿cómo logra esto? ¿ rendimiento única justificación para implementación software monolítico?.. analice relación entre concepto ocultamiento información como atributo modularidad efectiva independencia los módulos... ¿cómo relacionan los conceptos acoplamiento portabilidad del software? ejemplos que apoyen punto vista... aplique “enfoque refinamiento stepwise” para desarrollar tres niveles distintos abstracciones del procedimiento para uno más los programas siguientes: ) revisor escritura que, dada una cantidad numérica dinero, imprima ésta las palabras que requieren normalmente cheque. ) una resolución forma iterativa las raíces una ecuación trascendente. ) algoritmo programa- ción tareas simples para sistema operativo... considere software requerido para implementar capacidad navegación (con gps) dispositivo móvil comunicación portátil. describa dos tres preocupaciones interferencia que pre- sentarían. analice manera que representaría como aspecto una estas preocupaciones. .. ¿”rediseñar” significa que modifica todo diseño forma iterativa? así, ¿qué significa? .. describa breves palabras cada uno los cuatro elementos del modelo del diseño. lecturas adicionales fuentes información donald norman escrito dos libros (the design everyday things, doubleday, , the psychology everyday things, harpercollins, ) que han convertido clásicos bibliografía sobre diseño una “obligación” lectura para quien diseñe cualquier cosa que utilicen los humanos. adams ( conceptual blockbusting, . ., addison-wesley, ) escribió libro cuya lectura esencial para los diseñadores que deseen ampliar forma pensar. por último, texto clásico polya ( how solve , . ., prince- ton university press, ) proporciona proceso general solución problemas que ayuda los dise-ñadores software cuando enfrentan problemas complejos. misma tradición, winograd . (bringing design software, addison-wesley, ) analizan los diseños software que funcionan, los que por qué. libro fascinante editado por wixon ramsey (field methods casebook for software design , wiley, ) sugiere métodos investigación campo (muy parecidos los los antropólogos) para entender cómo hacen trabajo los usuarios finales luego diseñar software que satisfaga sus necesidades. beyer holtzblatt ( contextual design: customer-centered appro- ach systems designs, academic press, ) ofrecen otro punto vista del diseño software que integra consumidor usuario cada aspecto del proceso diseño. bain (emergent design , addison-wesley, ) acopla los patrones, rediseño desarrollo orientado pruebas enfoque diseño eficaz. tratamiento exhaustivo del diseño contexto ingeniería software presentado por fox (introduction software engineering design , addison-wesley, ) zhu (software design methodology, butterworth-heinemann, ). mcconnell (code complete, . ., microsoft press, ) plantea estudio excelente los aspectos prácticos del diseño software alta calidad. robertson (simple program design, . ., boyd fraser publishing, ) presenta análisis introductorio del diseño software, útil para quienes inician estudio del tema. budgen ( software design, . ., addison-wesley, ) presenta (-).indd (-).indd // ::// :: conceptos diseño varios métodos populares diseño los compara entre . fowler sus colegas ( refactoring: improving the design existing code, addison-wesley, ) estudian técnicas para optimización incremental diseños software. rosenberg stevens (use case driven object modeling with uml, apress, ) estudian -sarrollo diseños orientados objeto con empleo casos uso como fundamento. una antología editada por freeman wasserman ( software design techniques, . ., ieee, ), hay una excelente revisión histórica del diseño software. esta edición contiene muchas reimpresiones los artículos clásicos que forman base las tendencias actuales del diseño del software. card glass ( mea- suring software design quality , prentice-hall, ) presentan mediciones calidad procedentes los campos técnica administración. internet hay una variedad amplia fuentes información acerca del diseño software. sitio web del libro: encuentra una lista actualizada referencias existentes red mundial que son relevantes para diseño soft-ware para ingeniería diseño. (-).indd (-).indd // ::// :: arquitectura conceptos clave arquetipos . . . . . . . . . . . . . arquitectura . . . . . . . . . . . . alternativas . . . . . . . . . . . centrada datos . . . . . . . complejidad. . . . . . . . . . . . componentes. . . . . . . . . . . diseño . . . . . . . . . . . . . . . capas . . . . . . . . . . . . . . estilos . . . . . . . . . . . . . . . flujo datos . . . . . . . . . . formato . . . . . . . . . . . . . . géneros . . . . . . . . . . . . . . orientada objeto. . . . . . . patrones. . . . . . . . . . . . . . refinamiento . . . . . . . . . . . atam . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . descripción arquitectónica . . . . . . . . . . . mapeo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ¿qué ? diseño arquitectónico representa estructura los datos los componentes del programa que requieren para construir sistema basado computadora. considera estilo arquitectura que adoptará sistema, estruc-tura las propiedades los componentes que constitu-yen las interrelaciones que ocurren entre sus componen-tes arquitectónicos. ¿quién hace? aunque ingeniero software quien puede diseñar tanto los datos como arquitectura, frecuente que deben construirse sistemas grandes complejos, trabajo realicen especialistas. diseñador una base datos data warehouse crea arquitec-tura los datos para sistema. “arquitecto del siste-” selecciona estilo arquitectónico apropiado partir los requerimientos obtenidos durante análisis los datos. ¿por qué importante? lector intentaría construir una casa sin plano, ¿ ? tampoco comenzaría los planos con dibujo plomería del lugar. antes preocuparse por los detalles, necesitaría tener panora- general: casa . eso que hace diseño arquitectónico, panorama asegura que sea correcto. ¿cuáles son los pasos? diseño arquitectura comienza con diseño los datos continúa con obtención una más representaciones estructura arquitectónica del sistema. analizan alternativas estilos patrones arquitectónicos para llegar estructu- más adecuada para los requerimientos del usuario para los atributos calidad. una vez seleccionada alternativa, elabora arquitectura con empleo método diseño. ¿cuál producto final? durante diseño arquitec- tónico crea modelo arquitectura que incluye arquitectura los datos estructura del programa. además, describen las propiedades relaciones (inter-acciones) que hay entre los componentes. ¿cómo aseguro que hice bien? cada etapa revisan los productos del trabajo del diseño del software para que sean claros, correctos, completos consistentes con los requerimientos entre . una mirada rápidase descrito diseño como proceso etapas múltiples que, partir los - querimientos información, sintetizan las representaciones los datos estruc-tura del programa, las características interfaz los detalles del procedimiento. esta descripción amplía freeman [fre], como sigue: diseño una actividad que tiene que ver con toma decisiones importantes, con frecuencia naturaleza estructural. comparte con programación objetivo abstraer una representación información las secuencias procesamiento, pero los extremos grado detalle muy distinto. diseño elabora representaciones coherentes bien planeadas programas, que con-centran las relaciones las partes nivel más alto las operaciones lógicas involucradas los niveles bajos. como señaló capítulo , diseño está motivado por información. los métodos diseño del software provienen los tres dominios del modelo análisis. los dominios -tos, funciones comportamiento sirven como guía para creación del diseño del software. este capítulo presentan los métodos requeridos para crear “representaciones coheren- tes bien planeadas” las capas datos arquitectura del modelo diseño. objetivo brindar enfoque sistemático para obtención del diseño arquitectónico, plano prelimi-nar partir del cual elabora software. (-).indd (-).indd // ::// :: diseño arquitectura . arquitectura del software libro clave sobre tema, shaw garlan [sha] plantean siguiente sobre arquitec- tura del software: desde primer programa que dividió módulos, los sistemas software han tenido arquitecturas los programadores han sido los responsables las interacciones entre los módulos las propiedades globales del ensamble. históricamente, las arquitecturas han estado implícitas: accidentes implemen-tación sistemas heredados del pasado. los desarrolladores buen software han adoptado con fre-cuencia uno varios patrones arquitectura como estrategias para organización del sistema, pero los utilizan manera informal tienen manera hacerlos explícitos sistema resultante. presente, arquitectura software eficaz representación diseño explícitos han vuelto los temas dominantes ingeniería software. .. ¿qué arquitectura? cuando piensa arquitectura una construcción, llegan mente muchos atributos distintos. nivel más sencillo, considera forma general estructura física. pero, realidad, arquitectura mucho más que eso. manera que los distintos componen-tes del edificio integran para formar todo cohesivo. forma que construcción adapta ambiente integra los demás edificios vecindad. grado que edificio cumple con propósito que satisface las necesidades del propietario. sensación estética estructura — efecto visual edificación— modo que combinan texturas, colores materiales para crear fachada exterior “ambiente vida” interior. los pequeños detalles: diseño las lámparas, tipo piso, color las cortinas… lista casi interminable. , finalmente, arte. pero arquitectura también algo más. son los “miles decisiones, tanto grandes como pequeñas” [tyt]. algunas éstas toman una etapa temprana del diseño tienen efecto profundo todas las demás acciones. otras dejan para más adelante, con que eliminan las restricciones prematuras que llevarían una mala implementación del estilo arqui-tectónico. pero, ¿qué arquitectura del software? bass, clements kazman [bas] definen este término tan elusivo manera siguiente: arquitectura del software programa sistema cómputo estructura estructuras del sistema, que comprende los componentes del software, sus propiedades externas visibles las relaciones entre ellos. arquitectura software operativo. una representación que permite ) analizar efectividad del diseño para cumplir los requerimientos establecidos, ) considerar alternativas arquitectónicas una etapa que hacer cambios diseño todavía relativamente fácil ) reducir los riesgos asociados con construcción del software. esta definición pone énfasis papel los “componentes del software” cualquier representación arquitectónica. contexto del diseño arquitectura, componente del software puede ser algo tan simple como módulo programa una clase orientada -jeto, pero también puede ampliarse para que incluya bases datos “middleware” que permi-tan configuración una red clientes servidores. las propiedades los componentes son aquellas características necesarias para entender cómo interactúan unos componentes con otros. nivel arquitectónico, especifican las propiedades internas (por ejemplo, deta-lles algoritmo). las relaciones entre los componentes pueden ser tan simples como una invocación procedimiento módulo otro tan complejos como protocolo acceso una base datos.cita: “ arquitectura sistema marco general que descri- forma estructura: sus componentes manera que ajustan entre ”. jerrold grochow punto clave arquitectura del software debe modelar estructura sistema manera que los datos componentes del procedimiento colaboran entre . cita: “cásate con arquitectura prisa, arrepiéntete tiempo libre.” barry boehm (-).indd (-).indd // ::// :: parte dos modelado ciertos miembros comunidad ingeniería software [kaz] hacen una diferencia entre las acciones asociadas con obtención una arquitectura software ( que autor llama “diseño arquitectura”) las que aplican para obtener diseño del software. como dijo revisor esta edición: hay una diferencia entre los términos arquitectura diseño. diseño una instancia una arqui- tectura, similar objeto que una instancia una clase. por ejemplo, considere arquitectura cliente-servidor. con esta arquitectura posible diseñar muchos modos sistema software basado red, con uso una plataforma java (java ) microsoft (estructura .net). entonces, hay una arquitectura, pero con base ella pueden crearse muchos diseños. así, válido mezclar “arquitectura” “diseño”. aunque autor está acuerdo con que diseño software una instancia una arqui- tectura específica software, los elementos estructuras que definen como parte ésta son origen todo diseño que evolucione partir ellos. diseño comienza con consi-deración arquitectura. este libro, diseño arquitectura software considera dos niveles pirámide del diseño (véase figura .): diseño los datos arquitectura. contexto del análisis precedente, diseño los datos permite representar componente datos arquitectura con definiciones sistemas clase convencionales (que incluyen atributos ope-raciones) sistemas orientados objeto. diseño arquitectónico centra representa-ción estructura los componentes del software, sus propiedades interacciones. .. ¿por qué importante arquitectura? libro dedicado arquitectura del software, bass . [bas] identifican tres razones clave por las que importante arquitectura del software: • las representaciones arquitectura del software permiten comunicación entre todas las partes (participantes) interesadas desarrollo sistema basado computadora. • arquitectura resalta las primeras decisiones que tendrán efecto profundo todo trabajo ingeniería software siguiente , también importante, éxito último del sistema como entidad operacional. • arquitectura “constituye modelo relativamente pequeño asequible por vía inte- lectual sobre cómo está estructurado sistema forma que sus componentes trabajan juntos” [bas]. modelo del diseño arquitectura los patrones arquitectónicos contenidos dentro éste son transferibles. decir, los géneros, estilos patrones arquitectónicos pueden aplicarse diseño otros sistemas representan conjunto abstracciones que permite los ingenie-ros software describir arquitectura formas predecibles. .. descripciones arquitectónicas cada uno nosotros tiene una imagen mental que significa palabra arquitectura. sin embargo, realidad que tiene significados diferentes para distintas personas. conclusión que los diversos participantes verán una arquitectura desde puntos vista diferentes motivados por varios conjuntos preocupaciones. esto implica que una descripción arquitectónica rea-lidad conjunto productos del trabajo que reflejan puntos vista distintos del sistema. por ejemplo, arquitecto gran edificio oficinas debe trabajar con distintos partici- pantes. preocupación principal del propietario edificación ( participante) garanti-zar placer estético que brinde suficiente espacio oficinas infraestructura para garantizar rentabilidad. por tanto, arquitecto debe desarrollar una descripción con empleo pers-webref dirección edu/secenter/saresources.html, encuentran apuntadores útiles para muchos sitios arquitectura software. cita: “ arquitectura demasiado importante para dejarla manos una sola persona, importa cuán brillante sea.” scott ambler punto clave modelo arquitectónico punto vista gestalt del sistema, que permite que ingeniero software examine como todo. (-).indd (-).indd // ::// :: diseño arquitectura pectivas del edificio que apeguen las preocupaciones del dueño. los puntos vista - pleados son dibujos del edificio tres dimensiones (para ilustrar aspecto estético) conjunto planos dos dimensiones que expliquen preocupación por espacio oficinas infraestructura. pero espacio oficinas tiene muchos otros participantes, incluido fabricante acero estructural que proveerá dicho material para estructura del edificio. necesita información arquitectónica detallada sobre acero que soportará edificio, incluso las vigas tipo , sus dimensiones, conectividad, materiales muchos otros detalles. estas preocupaciones abo-can diferentes productos del trabajo que representan distintos puntos vista arquitectura. los planos especializados (otro punto vista) estructura acero edificación centran sólo una las muchas preocupaciones del fabricante. descripción arquitectura sistema basado software debe tener características análogas las mencionadas para edificio oficinas. tyree ackerman [tyr] recalcan esto así: “los desarrolladores desean lineamientos claros decisivos sobre forma proceder con diseño. los consumidores desean comprensión clara los cambios ambientales que -ben ocurrir las garantías que arquitectura satisfará las necesidades negocios. otros arquitectos desean una comprensión clara notable los aspectos clave arquitectura.” cada uno estos “deseos” refleja punto vista diferente representado con uso una perspectiva distinta. ieee computer society hizo propuesta ieee-std--, recommended practice for architectural description software-intensive systems, [iee], con los siguientes objetivos: ) establecer marco conceptual con vocabulario que use durante diseño arqui-tectura del software, ) proporcionar lineamientos detallados para representar una descripción arquitectónica ) estimular las mejores prácticas del diseño arquitectónico. estándar ieee define una descripción arquitectónica () como “ conjunto productos para documentar una arquitectura”. descripción representa con uso perspecti-vas múltiples, donde cada perspectiva “una representación del sistema completo desde punto vista conjunto preocupaciones relacionadas [ participante]”. una pers- pectiva crea acuerdo con reglas convenciones definidas punto vista: “especifica- ción las convenciones para construir usar una perspectiva” [iee]. este capítulo estudian varios productos del trabajo que utilizan para desarrollar distintas perspectivas arquitectura del software. .. decisiones arquitectónicas cada perspectiva desarrollada como parte una descripción arquitectónica aboca una preocupación participante específico. para desarrollar cada perspectiva ( descripción arquitectónica conjunto), arquitecto del sistema considera varias alternativas decide última instancia las características arquitectónicas específicas que satisfagan del mejor modo preocupación. entonces, las decisiones arquitectónicas mismas consideran una pers-pectiva arquitectura. las razones por las que tomaron las decisiones dan una visión sistema concordancia con las preocupaciones del participante. como arquitecto simbólico, lector puede usar formato sugerido recuadro para - cumentar cada decisión importante. hacerlo, presenta racionalidad trabajo deja registro histórico que será útil cuando deban hacerse modificaciones del diseño. . géneros arquitectónicos aunque los principios subyacentes del diseño arquitectónico aplican todos los tipos arquitectura, con frecuencia será género arquitectónico que dicte enfoque específico para estructura que deba construirse. contexto del diseño arquitectónico, género implica esfuerzo debe centrarse representaciones arquitectura que guiarán todos los demás aspectos del diseño. hay que dedicar tiempo revisar con cuidado arquitectura. error aquí tendrá efecto negativo largo plazo.consejo (-).indd (-).indd // ::// :: parte dos modelado una categoría específica dentro del dominio general del software. dentro cada categoría hay varias subcategorías. por ejemplo, dentro del género edificios, encuentran los siguientes - tilos generales: casas, condominios, edificios departamentos, edificios oficinas, edificios industriales, bodegas, etc. dentro cada estilo general habrá estilos más específicos (véase sección .). cada estilo tendrá una estructura que puede describirse con uso conjunto patrones predecibles. texto evolutivo handbook software architecture [boo], grady booch sugiere los siguientes géneros arquitectónicos para sistemas basados software: • inteligencia artificial: sistemas que simulan incrementan cognición humana, locomoción otros procesos orgánicos. • comerciales lucrativos: sistemas que son fundamentales para operación una empresa negocios. • comunicaciones: sistemas que proveen infraestructura para transferir manejar datos, para conectar usuarios éstos para presentar datos frontera una infraestructura. • contenido autor: sistemas que emplean para crear manipular artefactos texto multimedios. • dispositivos: sistemas que interactúan con mundo físico fin brindar algún servicio puntual individuo. • entretenimiento deportes: sistemas que administran eventos públicos que proveen una experiencia grupal entretenimiento. • financieros: sistemas que proporcionan infraestructura para transferir manejar dinero otros títulos. • juegos: sistemas que dan una experiencia entretenimiento individuos grupos.toda decisión arquitectónica importancia puede docu- mentarse para que posteriormente revisen los partici- pantes que deseen entender descripción arquitectura propues-. formato que presenta este recuadro una versión adaptada abreviada otro, propuesto por tyree ackerman [tyr]. aspecto del diseño: describen los aspectos del diseño arqui- tectónico que van abordar. resolución: establece enfoque escogido para abordar aspecto diseño. categoría: especifica categoría diseño que aboca aspecto resolución (por ejemplo, diseño datos, estructura del contenido, estructura del componente, inte-gración, presentación, etcétera). suposiciones: indican cualesquiera suposiciones que ayuden dar forma decisión. restricciones: especifican todas las restricciones ambientales que ayuden conformar decisión (como los estándares tecnológicos, patrones disponibles aspectos relaciona-dos con diseño).alternativas: describen con brevedad las alternativas diseño arquitectónico que considera-ron razón por que rechazaron. argumento: establece por qué eligió resolución sobre las demás alternativas. implicaciones: indican las consecuencias que tendrá toma decisión diseño. ¿cómo afectará resolución otros aspectos del diseño arquitectura? ¿ resolución restringe algún modo diseño? decisiones relacionadas: ¿qué otros documentos relacionan con esta decisión? preocupaciones relacionadas: ¿qué otros requerimientos relacionan con esta decisión? productos finales: indica dónde reflejará esta decisión descripción arquitectónica. notas: hace referencia las anotaciones del equipo otra clase documentación que haya empleado para tomar decisión.información formato para descripción una decisión arquitectónica punto clave diversos estilos arquitectónicos pueden aplicarse género específico (también conocido como dominio aplicación). (-).indd (-).indd // ::// :: diseño arquitectura • gobierno: sistemas que dan apoyo conducción operaciones una institución política local, estatal, federal, global otro tipo. • industrial: sistemas que simulan controlan procesos físicos. • legal: sistemas que dan apoyo industria jurídica. • médicos: sistemas que diagnostican, curan contribuyen investigación médica. • militares: sistemas consulta, comunicaciones, comando, control inteligencia ( ), así como armas ofensivas defensivas. • sistemas operativos: sistemas que están inmediatamente instalados hardware para dar servicios software básico. • plataformas: sistemas que encuentran los sistemas operativos para brindar servicios avanzados. • científicos: sistemas que emplean para hacer investigación científica aplicada. • herramientas: sistemas que utilizan para desarrollar otros sistemas. • transporte: sistemas que controlan vehículos acuáticos, terrestres, aéreos espaciales. • utilidades: sistemas que interactúan con otro software para brindar algún servicio específico. desde punto vista del diseño arquitectónico, cada género representa desafío único. por ejemplo, considere arquitectura del software sistema juego. esta clase sistemas, ocasiones llamados aplicaciones interactivas inmersión, requieren cómputo algorit- mos intensivos, gráficas avanzadas computadora, fuentes datos continuas multime-dios, interactividad tiempo real través dispositivos entrada convencionales convencionales, otras preocupaciones especializadas. alexander francois [fra] sugiere una arquitectura del software para inmerpresencia que aplica ambiente juegos. describe arquitectura manera siguiente: asi (arquitectura software inmerpresencia) modelo nuevo arquitectura software para diseñar, analizar implementar aplicaciones que realizan procesamiento distribuido, asín-crono paralelo flujos datos generales. objetivo asi proveer marco universal para implementación distribuida algoritmos fácil integración sistemas complejos […] -delo procesamiento datos extensibles subyacentes modelo procesamiento híbrido (depó-sito transmisión mensajes compartidos), asíncrono paralelo permiten manipulación natu-ral eficiente flujos datos generales con uso indistinto librerías existentes código original. modularidad del estilo facilita desarrollo código distribuido, pruebas reutilización, así como diseño integración rápida del sistema mantenimiento evolución. análisis detallado del asi queda fuera del alcance este libro. obstante, importante reconocer que género sistemas juegos puede abordarse con estilo arquitectónico (véase sección .) diseñado específicamente para resolver preocupaciones sistemas juego. lector tiene especial interés, consulte [fra]. . estilos arquitectónicos cuando constructor usa frase “vestíbulo central colonial” para describir una casa, mayor parte personas familiarizadas con viviendas estados unidos hará una imagen general ella cuál probable distribución. constructor usó estilo arquitectónico como mecanismo descriptivo para diferenciar casa otros estilos (por ejemplo, dos aguas, finca cita: “programar sin una arquitectura diseño general mente como explorar una caverna sólo con una linterna: sabes dónde has estado, dónde vas dónde estás.” danny thorpe francois utiliza término inmerpresencia para denotar aplicaciones interactivas inmersión. (-).indd (-).indd // ::// :: parte dos modelado campestre, cabo cod, etc.). pero, que más importante, estilo arquitectónico también una plantilla para construcción. deben definirse más detalles, especificar sus dimensiones finales, agregar características personalizadas, determinar los materiales construcción, pero estilo ( “vestíbulo central colonial”) orienta constructor trabajo. software construido para sistemas basados computadora también tiene uno muchos estilos arquitectónicos. cada estilo describe una categoría sistemas que incluye ) con-junto componentes (como una base datos módulos cómputo) que realizan una fun-ción requerida por sistema, ) conjunto conectores que permiten “comunicación, coordinación cooperación” entre los componentes, ) restricciones que definen cómo inte-gran los componentes para formar sistema ) modelos semánticos que permiten que diseñador entienda las propiedades generales del sistema analizar las propiedades conocidas sus partes constituyentes [bas]. estilo arquitectónico una transformación que impone diseño todo sistema. objetivo establecer una estructura para todos los componentes del sistema. caso que hacerse reingeniería una arquitectura existente (véase capítulo ), imposición estilo arquitectónico dará como resultado cambios fundamentales -tructura del software, incluida reasignación las funciones los componentes [bos]. patrón arquitectónico, como estilo arquitectura, impone transformación del - seño una arquitectura. sin embargo, patrón difiere estilo varias formas funda-mentales: ) alcance del patrón menos amplio centra aspecto arquitectura más que total ésta, ) patrón impone una regla arquitectura, describe manera que software manejará ciertos aspectos funcionalidad nivel infraestruc-tura (por ejemplo, concurrencia) [bos], ) los patrones arquitectónicos (véase sección .) tienden abocarse aspectos específicos del comportamiento contexto arquitectura (por ejemplo, cómo manejarán sincronización las interrupciones las aplicaciones tiempo real). los patrones utilizan junto con estilo arquitectónico para dar forma estructura cita: “ fondo mente todo artista hay patrón tipo arquitectura.” . . chesterton ¿qué estilo arquitectónico?? webref los estilos arquitectónicos basados atributos (abas) pueden usarse como bloques construcción para las arquitecturas software. dirección hay información respecto. esencia, arquitectura del software representa una estructura que cierta colección entidades (con fre- cuencia llamados componentes) está conectada por conjunto relaciones definidas (usualmente llamadas conectores). tanto las com-ponentes como los conectores están asociados con conjunto propiedades que permiten que diseñador diferencie los tipos componentes conectores que pueden usarse. pero, ¿qué clases estructuras (componentes, conectores propiedades) utilizan para describir una arquitectura? bass kazman [bas] sugieren cinco estructuras canónicas fundamentales: estructura funcional. los componentes representan entidades función procesamiento. los conectores representan interfaces que proveen capacidad “usar” “pasar datos ” componente. las propiedades describen naturaleza los componentes organización las interfaces. estructura implementación. “los componentes son paque- tes, clases, objetos, procedimientos, funciones, métodos, etc., que son vehículos para empacar funciones varios niveles abstracción” [bas]. los conectores incluyen capacidad pasar datos con-trol, compartir datos, “usar” “ser una instancia ”. las propieda-des centran las características calidad (por ejemplo, facili-dad recibir mantenimiento, ser reutilizables, etc.) que surgen cuando implementa estructura. estructura concurrencia. los componentes representan “uni- dades concurrencia” que están organizadas como tareas trayec-torias paralelas. “las relaciones [conectores] incluyen sincronizarse-con, tiene-mayor-prioridad-que, envía-datos-, -corre-sin -corre-con. las propiedades relevantes para esta estructura inclu-yen prioridad, anticipación tiempo ejecución” [bas]. estructura física. esta estructura similar modelo despliegue desarrollado como parte del diseño. los componentes son hardware físico que reside software. los conectores son las interfaces entre los componentes del hardware las propiedades incluyen capacidad, ancho banda rendimiento, entre otros atributos. estructura desarrollo. esta estructura define los componentes, productos del trabajo otras fuentes información que requieren medida que avanza ingeniería software. los conectores repre-sentan las relaciones entre los productos del trabajo; las propiedades identifican las características cada aspecto. cada una estas estructuras presenta punto vista arquitectura del software expone información que útil para equi- software medida que realiza modelación construcción.información estructuras arquitectónicas canónicas (-).indd (-).indd // ::// :: diseño arquitectura general sistema. sección .. consideran los estilos patrones arquitectónicos comunes para software. .. breve taxonomía estilos arquitectura aunque los últimos años han creado millones sistemas basados computadoras, gran mayoría clasifica número relativamente pequeño estilos arquitectura: arquitecturas centradas los datos. centro esta arquitectura halla alma- cenamiento datos (como archivo base datos) que acceden con frecuencia otros componentes que actualizan, agregan, eliminan modifican los datos cierto modo dentro del almacenamiento. figura . ilustra estilo común centrado datos. software cliente accede repositorio (depósito) central. ciertos casos éste pasivo. decir , software cliente accede los datos forma independiente cualesquiera cambios que éstos sufran las acciones del software otro cliente. una variante este enfoque transforma depósito “pizarrón” que envía notificaciones software cliente cuando hay cambio datos interés del cliente. las arquitecturas centradas datos promueven integrabilidad [bas]. decir, los com- ponentes del software pueden ser cambiados agregarse otros nuevos, del cliente, arqui-tectura sin problemas con otros clientes (porque los componentes del cliente operan forma independiente). además, pueden pasarse datos entre clientes con uso mecanismo pizarrón ( componente pizarrón sirve para coordinar transferencia información entre clientes). los componentes del cliente ejecutan los procesos con independencia. arquitecturas flujo datos. esta arquitectura aplica cuando datos entrada van transformarse datos salida través una serie componentes computacionales -nipuladores. patrón tubo filtro (véase figura .) tiene conjunto componentes, llamados filtros, conectados por tubos que transmiten datos componente siguiente. cada filtro trabaja forma independiente aquellos componentes que localizan arriba abajo del flujo; diseña para esperar una entrada datos cierta forma produce datos salida ( filtro siguiente) una forma especificada. sin embargo, filtro requiere ningún conocimiento los trabajos que realizan los filtros vecinos. flujo datos degenera una sola línea transformaciones, denomina lote secuen- cial. esta estructura acepta lote datos luego aplica una serie componentes secuen-ciales (filtros) para transformarlos.cita: “ uso patrones estilos diseño está presente todas las disciplinas ingeniería.” mary shaw david garlan software cliente software cliente software clientesoftware clientesoftware clientesoftware clientesoftware clientesoftware cliente almacenamiento datos (repositorio pizarrón)figura . arquitectura centrada datos (-).indd (-).indd // ::// :: parte dos modelado arquitecturas llamar regresar. este estilo arquitectónico permite obtener una estruc- tura programa que relativamente fácil modificar escalar . dentro esta categoría existen varios subestilos [bas]: • arquitecturas programa principal/subprograma . esta estructura clásica programa descompone una función una jerarquía control que programa “principal” invoca cierto número componentes programa que vez invocan otros. figura . ilustra una arquitectura este tipo. • arquitecturas llamada procedimiento remoto. los componentes una arquitectura programa principal/subprograma están distribuidos través computadoras múltiples una red. arquitecturas orientadas objetos. los componentes sistema incluyen datos las operaciones que deben aplicarse para manipularlos. comunicación coordinación entre los componentes consigue mediante transmisión mensajes. arquitecturas capas. figura . ilustra estructura básica una arquitectura capas. define número capas diferentes; cada una ejecuta operaciones que aproxi-man progresivamente conjunto instrucciones máquina. capa externa, los compo-filtrotubos filtrofiltro filtro filtro filtro filtro filtro tubos ﬁltrosfiltro filtrofigura . arquitectura flujo datos programa principal subprograma controladorsubprograma controladorsubprograma controlador subprograma aplicaciónsubprograma aplicaciónsubprograma aplicaciónsubprograma aplicaciónsubprograma aplicación subprograma aplicaciónsubprograma aplicaciónfigura . arquitectura programa principal/subprograma (-).indd (-).indd // ::// :: diseño arquitectura nentes atienden las operaciones interfaz usuario. interna, los componentes reali- zan interfaz con sistema operativo. las capas intermedias proveen servicios utilerías funciones software aplicación. estos estilos arquitectónicos tan sólo son pequeño subconjunto los que están disponi- bles. una vez que ingeniería requerimientos revela las características restricciones del sistema que elaborar, elige estilo arquitectónico combinación patrones que ajusten mejor esas características restricciones. muchos casos, más patrón apropiado posible diseñar evaluar estilos arquitectónicos alternativos. por ejemplo, muchas aplicaciones bases datos combina estilo capas (apropiado para mayo-ría sistemas) con una arquitectura centrada datos. .. patrones arquitectónicos medida que desarrolle modelo requerimientos, observará que software debe enfrentar cierto número problemas amplios que abarcan toda aplicación. por ejemplo, modelo requerimientos para virtualmente cualquier aplicación comercio electrónico enfrenta con siguiente problema: ¿cómo ofrecer una amplia variedad bienes grupo -tenso consumidores permitir que los adquieran línea? modelo requerimientos también define contexto que debe responderse esta pregunta. por ejemplo, negocio comercio electrónico que venda equipo golf con-sumo operará contexto diferente que otro que venda equipo industrial precio alto corporaciones medianas pequeñas. además, hay varias limitantes restricciones que afectan manera que aborda este problema para resolverlo. los patrones arquitectónicos abocan problema aplicación específica dentro contexto dado sujeto limitaciones restricciones. patrón propone una solución arquitec-tónica que sirve como base para diseño arquitectura. una sección anterior, dijo que mayor parte aplicaciones caen dentro dominio género específico, que para éstas son apropiados uno más estilos arquitectura. por ejem-plo, estilo arquitectura general para una aplicación podría ser llamar regresar que está orientado objeto. pero dentro ese estilo encontrará conjunto problemas comu-capa núcleocomponentes capa interfaz usuario capa aplicación capa utileríasfigura . arquitectura capas para estudio detallado estilos patrones arquitectónicos, véase [bus], [gor], [roz], [bas], [bos] [hof].cita: “tal vez está planta baja. déjame subir revisar.” . . escher (-).indd (-).indd // ::// :: parte dos modelado nes que abordan mejor con patrones arquitectónicos específicos. capítulo presentan algunos estos problemas hace estudio más completo los patrones arquitectura. .. organización refinamiento debido que frecuente que proceso diseño permita varias alternativas arquitectura, importante establecer conjunto criterios diseño que usan para evaluar dise- arquitectónico obtenido. las preguntas que siguen [bas] dan una visión del estilo -quitectura: control. ¿cómo administra control dentro arquitectura? ¿existe una jerarquía control distinta? así, ¿cuál papel los componentes dentro esta jerar-quía control? ¿cómo transfieren control los componentes dentro del sistema? ¿cómo comparten? ¿cuál topología del control (por ejemplo, forma geométrica que adopta control)? ¿ control está sincronizado los componentes operan forma asin-crónica? datos. ¿cómo comunican los datos entre los componentes? ¿ flujo datos conti- nuo los objetos datos pasan sistema forma esporádica? ¿cuál modo transferencia datos (pasan componente otro dispone ellos globalmente para compartirse entre los componentes del sistema)? ¿existen componentes datos (como pizarrón depósito) , así fuera, cuál papel? ¿cómo interactúan los com-ponentes funcionales con los componentes datos? ¿los componentes datos son pasi-vos activos ( componente datos actúa activamente con otros componentes del sis-tema)? ¿cómo interactúan los datos control dentro del sistema? escena: cubículo jamie, cuando comienza modelación del diseño. participantes: jamie , miembros del equipo ingeniería software casasegura. conversación: (frunce ceño): hemos estado modelando función seguridad con empleo uml, sabes, clases, relaciones demás. así que supongo que arquitectura orientada objeto elección apropiada. jamie: ¿pero…?: pero… tengo problemas para visualizar que una arquitec- tura orientada objeto. entiendo arquitectura llamar regre-sar, que algo así como una jerarquía proceso convencional, pero orientada objeto… , parece algo amorfo. jamie (sonríe): amorfo, ¿?: … que quiero decir que visualizo una estructura real, sólo clases diseño que flotan espacio. jamie: bueno, eso cierto. hay jerarquías clase… piensa jerarquía (agregado) que hicimos para objeto plano [figura .]. una arquitectura orientada objetos una combinación esta estructura las interconexiones — sabes, colaboracio-nes— entre las clases. puede mostrarse con descripción completa los atributos operaciones, los mensajes que hay estructura las clases. : voy dedicar una hora mapear una arquitectura llamar regresar; luego volveré considerar orientada objeto. jamie: doug tendrá problemas con eso. dijo que deben consi- derarse alternativas arquitectónicas. por cierto, hay ninguna razón para usar estas arquitecturas combinadas entre . : bueno. estoy eso.casasegura elección estilo arquitectura podría afirmarse que arquitectura casasegura debe considerarse nivel más alto que que comenta. casasegura tiene varios subsistemas: vigilancia las funciones del hogar, vigilancia del sitio empresa subsistema que corre del propietario. dentro los subsistemas son comunes los procesos concurrentes (por ejemplo, los que vigilan sensores) los que manejan eventos. este nivel, algunas decisiones arquitec-tura toman durante ingeniería del producto, pero diseño arquitectónico dentro ingeniería soft-ware muy bien debe considerar estos aspectos.¿cómo evalúa estilo arquitectónico que haya obtenido?? (-).indd (-).indd // ::// :: diseño arquitectura estas preguntas dan diseñador una evaluación temprana calidad del diseño proporcio- nan fundamento para hacer análisis más detallados arquitectura. . diseño arquitectónico cuando comienza diseño arquitectónico, software que desarrollar debe situarse contexto, decir, diseño debe definir las entidades externas (otros sistemas, dispositivos, personas, etc.) con las que interactúa software naturaleza dicha interacción. esta -formación por general adquiere partir del modelo los requerimientos toda que reunió durante ingeniería éstos. una vez que modelado contexto descrito todas las interfaces externas del software, identifica conjunto arquetipos arquitec-tura. arquetipo una abstracción (similar una clase) que representa elemento com- portamiento del sistema. conjunto arquetipos provee una colección abstracciones que deben modelarse cuanto arquitectura sistema construirse, pero los arquetipos por mismos dan suficientes detalles para implementación. por tanto, diseñador espe-cifica estructura del sistema, definiendo refinando los componentes del software que imple-mentan cada arquetipo. este proceso sigue forma iterativa hasta que obtiene una estruc-tura arquitectónica completa. las secciones que siguen estudia cada una estas tareas diseño arquitectónico con poco más detalle. .. representación del sistema contexto nivel diseño arquitectónico, arquitecto del software usa diagrama contexto -quitectónico (dca) para modelar manera que software interactúa con entidades más allá sus fronteras. estructura general del diagrama contexto arquitectónico ilustra figura .. relación con dicha figura, los sistemas que interactúan con sistema objetivo (aquel para que desarrollarse diseño arquitectónico) están representados como sigue: • sistemas superiores: aquellos que utilizan sistema objetivo como parte algún esquema procesamiento alto nivel. • sistemas subordinados: los que son usados por sistema objetivo proveen datos procesamiento que son necesarios para completar las funciones del sistema objetivo. • sistemas entre iguales: son los que interactúan sobre una base igualdad (por ejemplo, información produce consume por los iguales por sistema objetivo). • actores: entidades (personas, dispositivos, etc.) que interactúan con sistema objetivo mediante producción consumo información que necesaria para procesa-miento los requerimientos. cada una estas entidades externas comunica con sistema objetivo través una -terfaz (rectángulos pequeños sombreados). para ilustrar empleo del dca, considere función seguridad del hogar del producto casasegura. controlador general del producto casasegura sistema basado internet son superiores respecto función seguridad muestran por arriba función figura .. función vigilancia sistema entre iguales las versiones posteriores del pro- ducto usa ( usada por) función seguridad del hogar. propietario los paneles con-trol son actores que producen consumen información usada producida por software seguridad. por último, los sensores utilizan por software seguridad muestran como subordinados éste.cita: “ doctor puede sepultar sus errores, pero arquitecto sólo puede aconsejar cliente que siembre enredaderas.” frank lloyd wright punto clave contexto arquitectónico representa manera que software interactúa con las entidades externas sus fronteras. ¿cómo interactúan los sistemas uno con otro? ? (-).indd (-).indd // ::// :: parte dos modelado como parte del diseño arquitectónico, tendrían que especificarse los detalles cada interfaz mostrada figura .. esta etapa deben identificarse todos los datos que fluyen hacia dentro fuera del sistema objetivo. .. definición arquetipos arquetipo una clase patrón que representa una abstracción fundamental impor- tancia crítica para diseño una arquitectura para sistema objetivo. general, requiere conjunto relativamente pequeño arquetipos fin diseñar sistemas incluso algo complejos. arquitectura del sistema objetivo está compuesta estos arquetipos, que repre-sentan elementos estables arquitectura, pero que son implementadas muchos modos diferentes con base comportamiento del sistema. muchos casos, los arquetipos obtienen con estudio las clases análisis definidas como parte del modelo los requerimientos. continuar análisis función seguridad casasegura, definirán los arquetipos siguientes:sistemas superiores sistemas subordinadosdepende deusos usosusados por pares actoressistema objetivofigura . diagrama contexto arquitectónicofuente: adaptado [bos]. sistema objetivo: función seguridad usos usos parespropietarioproducto casasegurasistema basado internet función vigilancia sensorespanel control sensores usosfigura . diagrama contexto arquitectónico para función seguridad casasegurapunto clave los arquetipos son los bloques constructivos diseño arquitectónico. (-).indd (-).indd // ::// :: diseño arquitectura • nodo. representa una colección cohesiva elementos entrada salida función seguridad del hogar. por ejemplo, nodo podría comprender ) varios sensores ) varios indicadores alarma (salida). • detector. abstracción que incluye todos los equipos detección que alimentan con información sistema objetivo. • indicador. abstracción que representa todos los mecanismos (como sirena alarma, luces, campana, etc.) que indican que está ocurriendo una condición alarma. • controlador. abstracción que ilustra mecanismo que permite armar desarmar nodo. los controladores residen una red, tienen capacidad comunicarse entre . figura . muestra cada uno estos arquetipos con empleo notación uml. -cuerde que los arquetipos constituyen base arquitectura, pero son abstracciones que deben refinarse medida que avanza diseño arquitectónico. por ejemplo, detector refi- naría una jerarquía clase sensores. .. refinamiento arquitectura hacia los componentes conforme arquitectura refina hacia los componentes, comienza emerger estructura del sistema. pero, ¿cómo eligen estos componentes? para responder esta pregunta comienza con las clases descritas como parte del modelo requerimientos. estas clases análisis - presentan entidades dentro del dominio aplicación (negocio) que deben enfrentarse dentro arquitectura del software. entonces, dominio aplicación una fuente para obten-ción refinamiento los componentes. otra fuente dominio infraestructura. -quitectura debe albergar muchas componentes infraestructura que hagan posible los componentes aplicación, pero que tengan conexión con dominio ésta. por ejem-plo, los componentes administración memoria, comunicación, base datos administración tareas con frecuencia están integrados arquitectura del software. las interfaces ilustradas diagrama contexto arquitectura (sección ..) impli- can uno más componentes especializados que procesan los datos que fluyen través controlador nodose comunica con detector indicadorfigura . relaciones uml para los arquetipos función seguridad casasegurafuente: adaptado [bos]. cita: “ estructura sistema software provee ecología que código nace, crece muere. hábitat bien diseña- permite evolución exitosa todos los componentes nece-sarios sistema software.” . pattis elige enfoque convencional ( orientado objeto), los componentes obtienen partir los datos del modelo del flujo. este enfoque estudia brevemente sección .. (-).indd (-).indd // ::// :: parte dos modelado interfaz. ciertos casos (por ejemplo, una interfaz usuario gráfica) debe diseñarse una - quitectura completa con muchos componentes para subsistema. seguir con ejemplo función seguridad casasegura, debe definirse conjunto componentes alto nivel que aboque las funciones siguientes: • administración comunicación externa : coordina comunicación función seguridad con entidades externas, tales como otros sistemas basados internet notificación externa una alarma. • procesamiento del panel control: administra toda funcionalidad del panel control. • administración detectores: coordina acceso todos los detectores del sistema. • procesamiento alarmas: verifica actúa todas las condiciones alarma. cada uno estos componentes alto nivel tendría que elaborarse forma iterativa para después posicionarlo dentro arquitectura general casasegura. para cada uno defini- rían las clases diseño (con los atributos operaciones apropiadas). sin embargo, impor-tante observar que los detalles diseño todos los atributos operaciones especifica-rían hasta abordar diseño nivel componentes (véase capítulo ). estructura arquitectónica general (representada como diagrama componentes uml) ilustra figura .. las transacciones son adquiridas por administración comunicación externa medida que mueven desde los componentes que procesan gui casasegura interfaz internet. esta información administrada por componente ejecutivo casa- segura que selecciona función apropiada del producto ( seguridad, este caso). compo- nente procesamiento panel control interactúa con propietario para activar desactivar función seguridad. componente administración detectores prueba los sensores para detectar una condición alarma componente procesamiento alarmas produce salida cuando detecta una alarma. .. descripción las instancias del sistema diseño arquitectónico modelado hasta este momento todavía nivel relativamente alto. representado contexto del sistema, definieron los arquetipos que indican las abstrac-ciones importantes dentro del dominio del problema, visible estructura general del sistema ejecutivo casasegura administración comunicación externa guiinterfaz internetselección función seguridad vigilanciaadministración del hogar procesamiento panel controladministración detectoresprocesamiento alarmas-figura . estructura arquitectónica general para los componentes alto nivel casasegura (-).indd (-).indd // ::// :: diseño arquitectura están identificadas las componentes principales del software. sin embargo, necesario más refinamiento (recuerde que todo diseño iterativo). para lograr esto, desarrollan instancias arquitectura. esto significa que arquitectura aplica problema específico con objeto demostrar que tanto ella como sus componen-tes son apropiados. figura . ilustra instancias arquitectura casasegura para sistema seguridad. los componentes ilustrados figura . elaboraron para mostrar más detalles. por ejemplo, componente administración detectores interactúa con componente -fraestructura programador que implementa prueba cada objeto sensor usado por sistema seguridad. una elaboración similar lleva cabo para cada uno los componentes repre-sentados figura .. . evaluación los diseños alternativos para arquitectura libro sobre evaluación las arquitecturas software, clements . [cle] afirman siguiente: para decirlo sin rodeos, una arquitectura una apuesta, una adivinanza sobre éxito sistema. ¿ sería agradable saber por adelantado apostó ganador vez esperar hasta que sistema esté casi terminado para saber cumplirá con los requerimientos ? usted compra sistema paga por desarrollo, ¿ querría tener alguna seguridad que por camino -rrecto? usted mismo arquitecto, ¿ gustaría tener una buena manera validar sus intui-ciones experiencia para que pudiera dormir por noche con certeza que confianza puesta diseño está bien fundamentada? verdad, las respuestas estas preguntas tendrían valor. diseño como resultado - rias alternativas arquitectura, cada una las cuales evalúa para determinar cuál más apropiada para problema por resolver. las secciones que siguen presentan dos enfoques diferentes para evaluación diseños arquitectónicos alternativos. primero utiliza -todo iterativo para evaluar negociaciones diseño. segundo aplica una técnica seudo-cuantitativa para evaluar calidad del diseño.objetivo: las herramientas diseño arquitectónico modelan estructura general del software mediante representación interfaz los componentes, sus dependen-cias relaciones, así como sus interacciones. mecánica: mecánica las herramientas varía. mayoría casos, capacidad diseño arquitectura parte las funciones provistas por herramientas automatizadas para modela- del análisis diseño. herramientas representativas: adalon, desarrollada por synthis corp. ( una herramienta diseño especializada para diseñar construir arquitecturas componentes específicos basados web.objectif, desarrollada por microtool gmbh ( /objectif//), una herramienta diseño basada uml que conduce arquitecturas (como coldfusion, , fuse-box, etc.) adecuadas para ingeniería software basada componentes (véase capítulo ). rational rose, desarrollada por rational (www-.ibm.com/ software/rational/), una herramienta diseño basada uml que proporciona apoyo todos los aspectos del diseño arquitectura.herramientas software diseño arquitectónico las herramientas mencionadas aquí son obligatorias; sólo son una muestra esta categoría. mayoría casos, sus nombres son marcas registradas por sus desarrolladores respectivos. (-).indd (-).indd // ::// :: parte dos modelado .. método negociación para analizar arquitectura instituto ingeniería software (sei, por sus siglas inglés) desarrolló método negociación para analizar arquitectura (architecture trade-off analysis method -atam) [kaz], que establece proceso evaluación iterativo para arquitecturas software. las actividades análisis del diseño que mencionan continuación llevan cabo forma iterativa: . escenarios investigación. desarrolla conjunto casos uso (véanse los capí-tulos ) para representar sistema desde punto vista del usuario. . obtención los requerimientos restricciones, descripción del ambiente. esta informa-ción determina como parte ingeniería requerimientos utiliza para estar seguros que han detectado todas las preocupaciones los participantes. . descripción los estilos patrones arquitectura elegidos para abordar los escenarios requerimientos. debe describirse estilo arquitectónico con empleo las siguientes perspectivas arquitectónicas: • perspectiva modular para análisis las asignaciones trabajo con componentes grado que logra ocultamiento información. • perspectiva del proceso para análisis del desempeño del sistema. • perspectiva del flujo datos para analizar grado que arquitectura satisface los requerimientos funcionales. . evaluación los atributos calidad, considerando cada atributo por separado. - mero atributos calidad elegidos para análisis una función del tiempo dis-ponible para revisión grado que los atributos calidad son relevantes para sistema cuestión. los atributos calidad para evaluar diseño arquitectónico administración comunicación externa gui interfaz internetseguridad procesamiento panel controladministración detectoresprocesamiento alarmas procesamiento teclado funciones pantalla cpprogramadorcomunicación telefónica alarmaejecutivo casasegura sensorfigura . instancias función seguridad con elaboración componentes webref dirección puede obtenerse mucha información sobre atam. (-).indd (-).indd // ::// :: diseño arquitectura incluyen confiabilidad, desempeño, seguridad, facilidad mantenimiento, flexibilidad, facilidad hacer pruebas, portabilidad, reutilización interactuación. . identificación sensibilidad los atributos calidad varios atributos arquitectónicos par estilo arquitectura específico. eso lleva cabo haciendo cambios pequeños arquitectura fin determinar sensibilidad que tiene atributo calidad, por ejemplo, desempeño ante cambio. cualesquiera atributos que vean afectados forma significativa por variación arquitectura denominan puntos sensibles. . crítica las arquitecturas candidatas (desarrollado paso ) con uso del análisis sensibilidad realizado paso . sei describe este enfoque manera siguiente [kaz]: una vez determinados los puntos sensibles arquitectura, detección puntos negocia- ción simplemente identificación los elementos arquitectura los que atributos múl-tiples son sensibles. por ejemplo, desempeño una arquitectura cliente-servidor podría ser muy sensible número servidores (aumenta desempeño, cierto rango, con incremento del número servidores) […] entonces, número servidores punto negociación con respecto esta arquitectura. estos seis pasos representan primera iteración atam. con base los resultados los pasos , eliminan algunas arquitecturas alternativas modifican una varias las restantes fin representarlas con más detalle para después volver aplicar atam. método análisis arquitectura del software (maas) una alternativa atam mucha utilidad para los lectores interesados análisis arquitectónico. puede descargarse artículo sobre maas dirección escena: oficina doug miller, cuando avan- modelación del diseño arquitectónico. participantes: vinod, jamie , miembros del equipo inge-niería software casasegura, doug miller, gerente del grupo ingeniería software. conversación:doug: que están desarrollando par diferentes arquitectu- ras para producto casasegura, eso bueno. pregunta , ¿cómo vamos elegir mejor? : estoy trabajando estilo llamada regreso, luego algu- los dos, jamie , derivará una arquitectura . doug: muy bien. ¿ cómo podemos elegir?jamie: último año estudios ciencias computación, tomé curso diseño recuerdo que había varios modos hacerlo. vinod: los hay, pero son algo académicos. miren, pienso que podemos evaluarlos escoger correcto con uso casos esce-narios. doug: ¿ mismo?vinod: hablas evaluar arquitectura. tenemos con- junto completo casos uso. así que los aplicaremos las dos arquitecturas veremos cómo reacciona cada sistema cómo funcio-nan los componentes conectores contexto del caso uso. : buena idea. nos aseguramos dejar nada fuera.vinod: cierto, pero también nos dice diseño arquitectónico tiene rizos sistema tiene que volver sobre mismo lazo para hacer trabajo. jamie: los escenarios sólo son otro nombre los casos uso.vinod: , este caso, escenario implica algo diferente.doug: hablas escenario calidad escenario cambio, ¿verdad? vinod: . que hacemos regresar con los participantes pre- guntarles cómo les gustaría que casasegura cambiara, digamos, los próximos tres años. sabes, nuevas versiones, características, esa clase cosas. construimos conjunto escenarios cam-bio. también desarrollamos conjunto escenarios calidad que defina los atributos que nos gustaría ver arquitectura del software. jamie: los aplicamos las alternativas.vinod: exacto. elegiremos estilo que mejor maneje los casos uso los escenarios.casasegura evaluación arquitectura (-).indd (-).indd // ::// :: parte dos modelado .. complejidad arquitectónica una técnica útil para evaluar complejidad general una arquitectura propuesta conside- rar las dependencias entre los componentes dentro arquitectura. estas dependencias están motivadas por flujo información por control dentro del sistema. zhao [zha] - giere tres tipos dependencias: las dependencias compartidas representan relaciones entre consumidores que usan los mismos recur- sos productores que producen para los mismos consumidores. por ejemplo, para dos componentes , refieren los mismos datos globales, entonces existe una relación dependencia compartida entre . las dependencias flujo representan relaciones dependencia entre productores consumidores recursos. por ejemplo, para dos componentes , debe completarse para que control pase (prerrequisito), comunica con por medio parámetros, entonces existe una relación dependencia flujo entre . las dependencias restricción representan restricciones flujo relativo del control entre conjunto actividades. por ejemplo, dos componentes pueden ejecutarse mismo tiempo (son mutuamente excluyentes), entonces existe una relación dependencia restricción entre . las dependencias compartidas flujo propuestos por zhao son similares concepto aco- plamiento estudiado capítulo . acoplamiento importante concepto diseño aplicable nivel arquitectónico componente. capítulo estudian criterios medida sencillos para evaluar acoplamiento. .. lenguajes descripción arquitectónica arquitecto una casa tiene conjunto herramientas notación estandarizadas que permiten que diseño represente sin ambigüedades que sea comprensible. aunque -quitecto software dispone notación uml, para enfoque más formal especifica-ción del diseño arquitectónico necesitan otras formas diagramas algunas herramientas relacionadas. lenguaje descripción arquitectónica (lda) provee semántica sintaxis para describir una arquitectura software. hofmann . [hof] sugieren que lda debe brindar dise-ñador capacidad desintegrar los componentes arquitectónicos, integrar componentes - resumen siguiente varios lda importantes fue prepa- rado por richard land (lan) publica con permiso autor. debe observarse que los primeros cinco lda fueron desa-rrollados con fines investigación son productos comerciales. rapide (http://poset.stanford.edu/rapide/) construye partir del concepto conjuntos parcialmente ordenados, con que genera estructuras programación muy nuevas (pero apa-rentemente poderosas). unicon ( “ lenguaje des- cripción arquitectónica que busca ayudar los diseñadores definir arquitecturas software términos abstracciones que les parezcan útiles”. aesop ( aborda proble- reutilización del estilo. con este lenguaje posible defi-nir estilos usarlos cuando construye sistema real.wright ( lenguaje formal que incluye los elementos siguientes: componentes con puertos, conectores con roles pegamento para unir roles con puertos. los estilos arquitectónicos formalizan lenguaje con predicados, que permite revisiones estáticas para determi-nar consistencia completitud una arquitectura. acme ( puede considerarse como lda segunda generación, que objetivo identificar una clase mínimo común denominador los lda. uml ( incluye muchos los artefactos necesarios para hacer descripciones arquitectónicas: procesos, nodos, pers-pectivas, etc. uml apropiado para hacer descripciones infor-males tan sólo porque trata estándar ampliamente com-prendido. sin embargo, carece toda fortaleza que necesita para hacer una descripción arquitectónica adecuada.herramientas software lenguajes descripción arquitectónica (-).indd (-).indd // ::// :: diseño arquitectura dividuales bloques arquitectónicos más grandes representar las interfaces (mecanismos conexión) que hay entre los componentes. una vez establecidas las técnicas descriptivas basa-das lenguaje para diseño arquitectura, más probable que, medida que diseño evoluciona, obtengan métodos evaluación eficaces para las arquitecturas. . mapeo arquitectura con uso del flujo datos los estilos arquitectónicos analizados sección .. representan arquitecturas radical-mente distintas. por ello, sorprende que exista mapeo exhaustivo que efectúe tran-sición del modelo requerimientos varios estilos arquitectura. realidad, hay mapeo práctico para ciertos estilos diseñador debe enfocar traducción los requerimien-tos diseño con empleo las técnicas descritas sección .. para ilustrar enfoque mapeo arquitectónico, considere arquitectura denominada llamada regreso, estructura muy común para muchos tipos sistemas. arquitectura llamada regreso reside dentro otras más sofisticadas que analizaron este capí-tulo. por ejemplo, arquitectura uno más componentes una arquitectura cliente-servi-dor podría denominarse llamada regreso. una técnica mapeo llamada diseño estructurado [you] caracteriza con frecuencia como método diseño orientado flujo porque provee una transición conveniente diagrama flujo datos (véase capítulo ) arquitectura del software. transición del flujo información (representada con diagrama flujo datos dfd) estructura programa consigue como parte proceso seis pasos: ) establece tipo flujo información, ) indican las fronteras del flujo, ) mapea dfd estructura del programa, ) define jerarquía del control, ) refina estructura resultante con empleo criterios medición para diseño heurísticos, ) mejora elabora descripción arquitectónica. como ejemplo breve del mapeo flujo datos, presenta uno “transformación” paso paso para una pequeña parte función seguridad casasegura. con objeto realizar mapeo, debe determinarse tipo flujo información. tipo flujo información llama flujo transformación presenta una cualidad lineal. los datos fluyen sistema con una trayectoria flujo entrada que transforman una representación del mundo exterior una forma internalizada. una vez internalizados, procesan centro trans-formación. por último, salen del sistema por una trayectoria flujo salida que transforma los datos una forma del mundo exterior. .. mapeo transformación mapeo transformación conjunto pasos diseño que permite mapear dfd con características flujo transformación estilo arquitectónico específico. para ilustrar este enfoque, nuevo consideraremos función seguridad casasegura. elemento del modelo análisis conjunto diagramas flujo datos que describen flujo información dentro función seguridad. para mapear estos diagramas flujo datos una arquitectura software deben darse los siguientes pasos diseño: debe observarse que durante método mapeo también utilizan otros elementos del modelo requeri- mientos. sitio web del libro presenta análisis más detallado del diseño estructurado. este ejemplo considera otro tipo importante flujo información, pero aborda ejemplo diseño estructurado que presenta sitio web del libro. sólo considera parte función seguridad casasegura que utiliza panel control. aquí incluyen otras características analizadas libro. (-).indd (-).indd // ::// :: parte dos modelado paso . revisión del modelo del sistema fundamental. modelo del sistema fundamen- tal diagrama contexto ilustra función seguridad como una transformación única, representa los productores consumidores externos los datos que fluyen hacia dentro fuera función. figura . ilustra modelo contexto nivel , figura . muestra flujo datos refinado para función seguridad. paso . revisar mejorar los diagramas flujos datos para software. infor- mación obtenida del modelo requerimientos refina para producir más detalles. por ejem-plo, estudia dfd nivel para vigilar sensores (véase figura .) obtiene diagrama flujo datos nivel que presenta figura .. nivel , cada trans-formación diagrama flujo datos presenta una cohesión relativamente grande (con-sulte capítulo ). decir , proceso implícito por una transformación realiza una sola distintiva función que implementa como componente software casasegura. enton-ces, dfd figura . contiene detalles suficientes para hacer “primer corte” -seño arquitectura del subsistema vigilar sensores, continúa con más refinamiento.panel controlcomandos datos usuario sensoresestado sensorespantalla del panel control línea teléfonoalarmasoftware casaseguradespliegue información tonos del número telefónicotipo alarmafigura . diagrama flujo datos para función seguridad casasegura este momento mejora más diagrama flujo datos, trate obtener burbujas que presenten mucha cohesión.consejo telephone lineinformación conﬁguraciónpanel control sensorespantalla del panel control línea teléfonoalarmainteractúa con usuarioconﬁgurar sistema activar desactivar sistema procesar clave vigilar sensoresmostrar mensajes estadocomandos datos usuario claveiniciar detenerconﬁgurar solicituddatos conﬁguración datos conﬁguración datos conﬁguraciónmensaje identiﬁcación válidamensaje activar desactivar estado sensoresinformación sensores tipo alarma tonos del número telefónicodesplie- gue informaciónfigura . diagrama flujo datos nivel para función seguridad casasegura (-).indd (-).indd // ::// :: diseño arquitectura paso . determinar dfd tiene características flujo transformación transacción. evaluar dfd (véase figura .) observa que los datos entran software por una trayectoria ingreso abandonan por tres trayectorias salida. por tanto, adoptará una característica general transformación para flujo información. paso . aísle centro transformación, especificando las fronteras entrada salida del flujo. los datos entrada fluyen por una trayectoria que información pasa forma externa forma interna; flujo salida con vierte los datos internalizados forma externa. las fronteras los flujos entrada salida quedan abiertas interpretación. información conﬁguración leer sensoresevaluar contra pre- paracióndatos conﬁguración identiﬁcación tipo sensor estado sensoresgenera señal alarmatipo alarma datos alarma número telefónico marcar teléfono tonos del número telefónicoformato para pantallainformación sensores identiﬁcación, tipo ubicación sensorfigura . diagrama flujo datos nivel que mejora transformación vigilar sensores flujo transacción, solo concepto datos, llamado transacción, ocasiona que flujo datos - mifique través cierto número trayectorias definidas por naturaleza transacción.generar pulsos hacia línea tonos del número telefónicopreparar conexión red telefónicaseleccionar número telefónicoestablecer condiciones alarmaadquirir información respuestaleer sensores generar señal alarmaformatear pantallagenerar pantallainformación conﬁguración datos conﬁguración estado sensores código condición alarma, identiﬁcación del sensor, información tiempolista números número telefónico preparar tonos del número telefónicodatos alarmatipo identiﬁ-cacióndel sensor,ubicaciónidentiﬁcación, tipo ubicación formateados tipo alarmainformación del sensor identiﬁcación preparación sensoresfigura . diagrama flujo datos nivel para vigilar sensores con fronteras del flujopunto clave será frecuente encontrar varios tipos flujo datos dentro del mismo modelo orientado flujo. los flujos dividen estructura del programa obtiene con uso del mapeo apropiado. (-).indd (-).indd // ::// :: parte dos modelado decir, diferentes diseñadores tal vez seleccionen como ubicación frontera diferentes puntos flujo. hecho, posible obtener soluciones alternativas diseño varía colocación las fronteras del flujo. aunque debe tenerse cuidado seleccionar las fronteras, variación una burbuja largo trayectoria del flujo tendrá por general poco efecto estructura final del programa. para ejemplo, figura . ilustran las fronteras del flujo como curvas sombreadas que corren arriba abajo través del flujo. las transformaciones (burbujas) que constituyen centro transformación quedan dentro esas dos fronteras sombreadas. posible dar -gumentos para reajustar una frontera (por ejemplo, podría proponerse una frontera para flujo entrada que separara leer sensores adquirir información respuesta). este diseño, énfasis esta etapa diseño debe estar selección fronteras razonables iteración extensa colocación las divisiones. paso . realizar “rediseño primer nivel”. arquitectura del programa obtenida con este mapeo como resultado una distribución del control arriba abajo. rediseño lleva una estructura programa que los componentes alto nivel ejecutan toma decisio-nes los bajo nivel realizan mayor parte del trabajo entrada, computación salida. los componentes nivel medio llevan cabo cierto control moderan las cantidades trabajo. cuando encuentra una transformación, mapea diagrama flujo datos para una estructura específica (una llamar regresar) que pro vea control para procesamiento información entrada, transformación salida. figura . ilustra este rediseño primer nivel para subsistema vigilar sensores. controlador principal (llamado ejecuti- vigilancia sensores) reside parte superior estructura del programa coordina las siguientes funciones control subordinadas: • controlador del procesamiento información entrada, llamado controlador entradas los sensores, coordina recepción todos los datos que llegan. • controlador del flujo transformación, llamado controlador condiciones alarma, supervisa todas las operaciones sobre los datos forma internalizada (por ejemplo, módulo que invoque varios procedimientos transformación datos. esfuerzo por explorar estructuras alternativas para programa, varíe las fronteras del flujo. esto toma poco tiempo una perspectiva importante.consejo ejecutivo vigilancia sensores controlador condiciones alarmacontrolador salidas alarmacontrolador entradas los sensoresfigura . rediseño primer nivel para vigilar sensores (-).indd (-).indd // ::// :: diseño arquitectura • controlador procesamiento información salida, llamado controlador salidas alarma, coordina producción información salida. aunque figura . sugiere una estructura tres dientes, los flujos complejos que hay sistemas grandes tal vez requieran dos más módulos control para cada una las funciones control generales descritas con anterioridad. número módulos primer nivel debe limitarse mínimo necesario para ejecutar las funciones control mantener buenas carac-terísticas independencia funciones. paso . realizar “rediseño segundo nivel”. rediseño segundo nivel logra con mapeo transformaciones individuales (burbujas) diagrama flujo datos -dulos apropiados dentro arquitectura. comienza frontera del centro transfor-mación avanza hacia afuera largo las trayectorias entrada salida; las trans-formaciones mapean niveles subordinados estructura del software. figura . presenta enfoque general del rediseño segundo nivel. unque figura . ilustra mapeo uno uno entre las transformaciones del diagrama flujo los módulos software, frecuente que haya distintos mapeos. posible combinar representar dos incluso tres burbujas como solo componente, una sola burbuja puede expandirse dos más componentes. son consideraciones prácticas mediciones calidad del diseño las que dictan resultado del rediseño segundo nivel. revisión refinamiento tal vez produzcan cambios esta estructura, pero sirven como diseño “primera iteración”. rediseño segundo nivel para flujo entrada presenta misma manera. rediseño logra nuevo avanzando hacia afuera partir frontera del centro trans- esta etapa debe ser dogmático. tal vez sea necesario establecer dos más controladores para procesamiento las entradas computación, con base complejidad del sistema que elaborar. sentido común sugiere este enfoque, ¡adelante!consejo hay que eliminar los módulos control redundantes. decir, módulo control hace nada más que controlar otro módulo, función controladora debe llevarse módulo nivel más alto.consejo ejecutivo vigilancia sensores controlador condiciones alarmacontrolador salida alarmacontrolador sensor entradasgenerar señal alarmaforma- tear pan- tallagenerar pantalla preparar conexión red telefónica generar pulsos líneafrontera del ﬂujo transformación generar señal alarmapreparar conexión red telefónicaformatear pantalla generar pulsos líneagenerar pantallafigura . rediseño segundo nivel para vigilar sensores (-).indd (-).indd // ::// :: parte dos modelado formación lado del flujo entrada. centro transformación del software del subsis- tema vigilar sensores mapea modo poco distinto. cada conversión datos transfor- mación cálculo parte transformación del diagrama flujo datos mapea módulo subordinado controlador transformación. figura . presenta arqui-tectura completa primera iteración. los componentes así mapeados que aprecian figura . representan diseño ini- cial arquitectura del software. aunque los componentes reciben nombre manera que implique función, para cada uno debe escribirse una narración breve (adaptada -pecificación del proceso desarrollada para transformación datos que generó durante modelado los requerimientos). narración describe interfaz del componente, las -tructuras internas los datos, relato las funciones análisis breve las restricciones otros rasgos especiales (como los archivos entrada salida, características que dependen del hardware, requerimientos especiales tiempo, etcétera). paso . refinar arquitectura primera iteración con empleo heurísticos diseño par mejorar calidad del software. siempre posible refinar arquitectu- primera iteración, aplicando conceptos independencia funciones (véase capí- tulo ). los componentes hacen explosión implosión para producir rediseño sensible, separación problemas, buena cohesión, acoplamiento mínimo , más importante, una estructura que puede implementarse sin dificultad, probar sin confusión mantener sin grandes problemas. los refinamientos son impuestos por análisis los métodos evaluación descritos sección ., así como por consideraciones prácticas sentido común. por ejemplo, hay oca-siones las que controlador para flujo datos entrada totalmente innecesario, cuando requiere algún procesamiento las entradas componente subordinado controlador transformación, cuando posible evitar mucho acoplamiento debido datos globales cuando logran características estructurales óptimas. arbitraje final constituyen los requerimientos del software acoplados con criterio humano. objetivo los siete pasos anteriores desarrollar una representación arquitectónica del software. decir, una vez definida estructura, evalúa mejora considerándola como todo. las modificaciones que hacen este momento exigen poco trabajo adicional, pero tienen efecto profundo calidad del software. debe hacerse una pausa considerar diferencia entre enfoque diseño descrito proceso “escribir programas”. código única representación del software, usted conserve módulos “trabajadores” nivel bajo estructura del programa. esto llevará una arquitectura fácil mantener.consejocontrolador salida alarma generar señal alarmaestablecer conexión red telefónicaformatear pantalla generar pulsos líneagenerar pantallacontrolador condiciones alarma seleccionar número telefónicoestablecer condiciones alarmaejecutivo vigilancia sensores controlador sensor entradas adquirir información respuesta leer sensoresfigura . estructura primera iteración para vigilar sensores cita: “hacerlo tan sencillo como sea posible. pero más.” albert einstein (-).indd (-).indd // ::// :: diseño arquitectura sus colegas tendrán grandes dificultades para evaluarlo mejorarlo nivel global holís- tico , verdad, tendrán dificultades porque “los árboles los dejarán ver bosque”. .. refinamiento del diseño arquitectónico cualquier análisis del refinamiento del diseño debería precedido este comentario: “-cuerde que ‘diseño óptimo’ que funcione tiene mérito cuestionable.” debe ocuparse desarrollar una representación del software que satisfaga todos los requerimientos funcio-nales desempeño, darle mérito según sus mediciones heurísticos diseño. debe estimularse refinamiento arquitectura del software durante las primeras etapas del diseño. como dijo este capítulo, hay estilos alternativos para arquitectura que posible obtener, refinar evaluar busca del “mejor” enfoque. éste, dirigido optimización, escena: cubículo jamie, cuando comien- modelación del diseño. participantes: jamie , miembros del equipo ingeniería software casasegura. conversación:[ acaba terminar diseño primer corte del subsistema vigilancia sensores. detiene para solicitar opinión jamie.] : pues bien, aquí está arquitectura que obtuve.[ muestra jamie figura ., ella estudia unos momen- tos.] jamie: está muy bien, pero creo que podemos hacer algo para que sea más sencilla… mejor. : ¿como qué?jamie: bueno, ¿por qué usaste componente controlador sen- sores entrada? : porque necesita controlador para mapeo.jamie: realidad. controlador hace gran cosa, que estamos manejando una sola trayectoria flujo para los datos entrada. puede eliminarse controlador sin que pase nada. : puedo vivir con eso. cambiaré …jamie (sonríe): espera… también podemos hacer implosión los componentes establecer condiciones alarma seleccionar número telefónico. controlador transformación que presentas realidad necesario poca disminución cohesión tolerable. : simplificación, ¿?jamie: . hacer refinamientos sería buena idea hacer implosión los componentes formatear pantalla generar pantalla. formateo pantalla para panel control algo sencillo. puede definirse nuevo módulo llamado producir pantalla. (dibuja): entonces, ¿esto que piensas que debemos hacer?[muestra jamie figura ..]jamie: buen comienzo.casasegura refinación arquitectura primer corte controlador salida alarma generar señal alarmapreparar conexión red telefónicaproducir pantalla generar pulsos líneaestablecer condiciones alarmaejecutivo vigilancia sensores adquirir información respuesta leer sensoresfigura . estructura refinada del programa para vigilar sensores¿qué pasa después que generó arquitectura?? (-).indd (-).indd // ::// :: parte dos modelado uno los verdaderos beneficios que logran con desarrollo una representación arquitectura del software. importante observar que sencillez estructural con frecuencia refleja tanto elegancia como eficiencia. refinamiento del diseño debe perseguir menor número componentes que sea consistente con modularidad efectiva estructura datos menos compleja que cumpla modo adecuado con los requerimientos información. . resumen arquitectura del software proporciona una visión holística del sistema que construir. ilustra estructura organización los componentes del software, sus propiedades conexio-nes. los componentes del software incluyen módulos programa las distintas representa-ciones datos que manipula éste. por tanto, diseño los datos parte integral -neración arquitectura del software. ésta subraya las primeras decisiones respecto del diseño provee mecanismo para considerar los beneficios las estructuras alternativas para sistema. dentro género arquitectónico dado, hay varios estilos patrones diferentes disponibles para ingeniero software. cada estilo describe una categoría sistemas que agrupa conjunto componentes que realizan una función requerida por sistema; grupo -nectores que permiten comunicación, coordinación cooperación entre los componentes; restricciones que definen cómo pueden integrarse éstos para formar sistema modelos -mánticos que permiten que diseñador entienda las propiedades generales del sistema. sentido general, diseño arquitectónico obtiene con empleo cuatro pasos. primer lugar, sistema debe representarse contexto. decir, diseñador debe definir las entidades externas con las que interactúa software naturaleza interacción. una vez especificado contexto, diseñador debe identificar conjunto abstracciones alto -vel, llamadas arquetipos, que representan elementos fundamentales del comportamiento función del sistema. que definieron las abstracciones, diseño comienza avanzar cerca del dominio implementación. identifican los componentes representan dentro del contexto una arquitectura que les apoyo. por último, desarrollan instancias específicas arquitectura para “probar” diseño contexto del mundo real. como ejemplo sencillo del diseño arquitectónico, método del mapeo presentado este capítulo usa las características del flujo datos para obtener estilo arquitectónico uso muy común. diagrama flujo datos mapea estructura del programa con uso del enfoque del mapeo transformación. éste aplica flujo información que presente fronteras distintas entre los datos entrada los salida. diagrama flujo datos mapea una estructura que asigna control entrada, procesamiento salida junto con tres jerarquías módulos diseñados por separado. una vez que tiene arquitectura, elabora analiza mediante criterios calidad. problemas puntos por evaluar .. con uso arquitectura una casa edificio como metáfora, establezca comparaciones con arquitectura del software. ¿ qué parecen las disciplinas arquitectura clásica del software? ¿ qué difieren? .. diga dos tres ejemplos aplicaciones para cada uno los estilos arquitectónicos mencionados sección ..... algunos los estilos arquitectónicos citados sección .. tienen naturaleza jerárquica, mientras que otros . elabore una lista cada tipo. ¿cómo implementarían los estilos arquitectónicos que son jerárquicos? (-).indd (-).indd // ::// :: diseño arquitectura .. los términos estilo arquitectónico, patrón arquitectónico marco (que estudia este libro) surgen con frecuencia los análisis arquitectura del software. investigue describa qué difiere cada uno ellos los demás. .. seleccione una aplicación con que esté familiarizado. responda cada una las preguntas plantea- das para control los datos sección ..... investige atam ( [kaz]) presente análisis detallado los seis pasos presentados sección ..... hecho, termine problema .. use los métodos diseño descritos este capítulo para desarrollar una arquitectura del software para ssrb... utilice diagrama flujo una narración del procesamiento para describir sistema basado computadora que tenga distintas características transformación del flujo. defina las fronteras del sistema mapee diagrama flujo los datos una arquitectura del software con empleo técnica des-crita sección ... lecturas adicionales fuentes información bibliografía sobre arquitectura del software crecido mucho última década. los libros escritos por gorton ( essential software architecture, springer, ), reekie mcadam ( software architecture primer , angophora press, ), albin (the art software architecture, wiley, ) bass . (software architecture practice, . ., addison-wesley, ), presentan introducciones útiles área del conocimiento con muchos retos intelectuales. buschman . ( pattern-oriented software architecture , wiley, ) kuchana (software architecture design patterns java, auerbach, ) estudian aspectos orientados patrón del diseño arquitectónico. rozanski woods (software systems architecture, addison-wesley, ), fowler ( patterns enterprise appli- cation architecture, addison-wesley, ), clements . (documenting software architecture: view and - yond, addison-wesley, ), bosch [bos] hofmeister . [hof] hacen análisis profundos arqui- tectura del software. hennesey patterson (computer architecture, . ., morgan-kaufmann, ) adoptan punto vista notable, por ser cuantitativo, para los aspectos del diseño arquitectura del software. clements . (evaluating software architectures, addison-wesley, ) analizan los aspectos asociados con evaluación alternativas arquitectónicas selección mejor arquitectura para dominio dado problemas. los libros dedicados implementación sobre arquitectura abordan diseño arquitectónico dentro ambiente tecnología específicos desarrollo. marks bell ( sevice-oriented architecture, wiley, ) estudian enfoque diseño que relaciona los negocios los recursos computacionales con los requeri-mientos definidos por los clientes. stahl . (model-driven software development, wiley, ) analizan arquitectura dentro del contexto los enfoques modelado dirigidos dominio. radaideh -ameed (architecture reliable web applications software , global, ) consideran arquitecturas apropiadas para webapps. clements norhrop (software product lines: practices and patterns , addison-wesley, ) estudian diseño arquitecturas que dan apoyo líneas productos software. shanley ( protected mode software architecture, addison-wesley, ) proporciona una guía del diseño arquitectónico para cualquier persona que diseñe sistemas basados que operen tiempo real, para sistemas operativos tareas múltiples manejadores dispositivos. investigación actual sobre arquitectura del software documenta cada año proceedings the - ternational workshop software architecture, publicación patrocinada por acm otras organizaciones cómputo, proceedings the international conference software engineering. internet encuentra una amplia variedad fuentes información sobre diseño arquitectónico. sitio web del libro, , halla una lista actualizada referencias que hay red mundial, relevantes para diseño arqui-tectura. (-).indd (-).indd // ::// :: nivel componentes conceptos clave acoplamiento . . . . . . . . . . . cohesión . . . . . . . . . . . . . . . adaptación . . . . . . . . . . . calificación . . . . . . . . . . . clasificación . . . . . . . . . . combinación . . . . . . . . . . orientación objetos . . . . . . . . . . . . tradicional . . . . . . . . . . . webapp . . . . . . . . . . . . . desarrollo basadoen componentes . . . . . . . . . diseño del contenido . . . . . . del dominio . . . . . diseño . . . . del diseño tabular . . . . . . . . . . . . . . . . ¿qué ? durante diseño arquitectónico, define conjunto completo componentes software. pero las estructuras internas datos detalles procesamiento cada componente están representadas nivel abs-tracción cercano código. diseño nivel compo-nentes define las estructuras datos, algoritmos, caracte-rísticas interfaz mecanismos comunicación asignados cada componente del software. ¿quién hace? ingeniero software quien realiza diseño nivel componentes. ¿por qué importante? antes elaborar software, tiene que ser capaz determinar funcionará. diseño nivel componentes representa forma tal que permite revisar los detalles del diseño para garan-tizar corrección consistencia con otras representa-ciones del diseño (por ejemplo, los datos diseño arquitectura interfaz). esto proporciona medio para evaluar funcionarán las estructuras datos, interfaces algoritmos. ¿cuáles son los pasos? las representaciones diseño datos, arquitectura interfaces constituyen funda-mento para diseño nivel componentes. defi-nición clase narrativa procesamiento cada componente traduce diseño detallado que utiliza formas diagrama basadas texto que especifican las estructuras datos internas, los detalles interfaz local lógica del procesamiento. notación del diseño incluye diagramas uml formatos complementarios. especifica diseño del procedimiento con empleo construcciones programación estructurada. con fre-cuencia posible obtener componentes software reuti-lizable existentes, lugar construir nuevos. ¿cuál producto final? producto principal que genera esta etapa diseño cada componente, representado con notación gráfica, tabular basada texto. ¿cómo aseguro que hice bien? efectúa revisión del diseño. esto hace para determinar duran- las primeras etapas diseño las estructuras datos, interfaces, secuencias procesamiento condiciones lógicas son correctas producirán los datos apropiados transformación del control asignado componente. una mirada rápidael diseño nivel componentes tiene lugar una vez terminado diseño arqui- tectura. esta etapa establecido estructura general los datos del programa del software. objetivo traducir modelo del diseño software operativo. pero nivel abstracción del modelo diseño existente relativamente alto del programa operativo bajo. traducción difícil está abierta introducción errores sutiles que son difíciles detectar corregir las etapas posteriores del proceso del software. una conferencia famosa, edsgar dijkstra, investigador importante que contribuido mucho nues-tra comprensión del diseño software, dijo [dij]: software parece ser diferente muchos otros productos los que regla que mejor calidad mayor precio. aquellos que desean software verdad confiable descubrirán que deben encontrar medio para evitar inicio mayoría los posibles errores; como resultado, proceso programación hace más barato [...] los programadores eficaces tienen que perder tiempo depurando errores: deben introducirlos arrancar. aunque estas palabras fueron expresadas hace muchos años, siguen siendo ciertas. traducir modelo del diseño código fuente, deben seguirse principios diseño que sólo hagan traducción sino que también eviten “introducción errores desde principio”. posible representar diseño nivel del componente con uso lenguaje programación. esencia, programa crea con empleo del modelo diseño arquitectó-nico como guía. enfoque alternativo consiste representar diseño nivel los componentes con alguna representación intermedia (gráfica, tabular basada texto) que traduzca con facilidad código fuente. sin que importe mecanismo utilizado para representar (-).indd (-).indd // ::// :: diseño nivel componentes . ¿ componente ? componente bloque construcción software cómputo. con más formalidad, especificación omg del lenguaje modelado unificado [omg] define componente como “una parte modular, desplegable sustituible sistema, que incluye implantación -pone conjunto interfaces”. como dijo capítulo , los componentes forman arquitectura del software , consecuencia, juegan papel logro los objetivos los requerimientos del sistema que construir. como los componentes encuentran arquitectura del software, deben comunicarse colaborar con otros componentes con entidades (otros sistemas, dispo-sitivos, personas, etc.) que existen fuera las fronteras del software. verdadero significado del término componente difiere función del punto vista del - geniero software que use. las secciones que siguen, estudian tres visiones importan-tes que componente cómo emplea desarrollo modelación del diseño. .. una visión orientada objetos contexto ingeniería software orientada objetos, componente contiene conjunto clases que colaboran. cada clase dentro componente elabora por com- pleto para que incluya todos los atributos operaciones relevantes para implantación. como parte elaboración del diseño, también deben definirse todas las interfaces que permiten que las clases comuniquen colaboren con otras clases diseño. para lograr esto, -mienza con modelo requerimientos elaboran clases análisis (para los componentes que relacionan con dominio del problema) clases infraestructura (para los componen-tes que dan servicios apoyo para dominio del problema). para ilustrar proceso elaboración del diseño, considere software que ela- borar para taller impresión avanzada. objetivo general del software obtener los -querimientos que plantea cliente mostrador, presupuestar trabajo impresión después pasar éste una instalación automatizada producción. durante ingeniería requerimientos obtuvo una clase análisis llamada imprimirtrabajo. parte superior figura . aparecen los atributos operaciones definidos durante análisis. dise- arquitectura definió imprimirtrabajo como componente dentro arquitec- tura del software está representado con notación abreviada uml que muestra parte media derecha figura. observe que imprimirtrabajo tiene dos interfaces, calculartrabajo, que provee capacidad obtener costo del trabajo, iniciartrabajo, que pasa trabajo través las instalaciones producción. éstas encuentran representadas con los símbolos “paleta” que aparecen lado izquierdo caja del componente. diseño nivel del componente comienza este punto. deben elaborarse los detalles del componente imprimirtrabajo para que den información suficiente que guíe implanta- ción. clase análisis original lleva cabo para dar cuerpo todos los atributos opera-ciones requeridos para implantar clase así como componente imprimirtrabajo. parte inferior derecha figura ., clase diseño elaborada imprimirtrabajo contiene éste, las estructuras datos, interfaces algoritmos definidos deben apegarse varios linea-mientos diseño bien establecidos que ayudan evitar los errores conforme evoluciona diseño del procedimiento. este capítulo estudian estos lineamientos los métodos dispo-nibles para cumplirlos. cita: “los detalles son detalles. son diseño.” charles eames punto clave desde punto vista orientado objetos, componente conjunto clases que colaboran. ciertos casos, componente contiene una sola clase. los lectores que estén familiarizados con notación uml deben consultar apéndice .recuerde que modelado del análisis del diseño son acciones iterativas. probable que elaboración clase análisis original requiera etapas adicionales, que con frecuencia van seguidas etapas modelado del diseño que representan clase diseño elaborada (los detalles del componente).consejo (-).indd (-).indd // ::// :: parte dos modelado información más detallada los atributos, así como una descripción amplia las operaciones que necesitan para implantar componente. las interfaces calculartrabajo iniciartrabajo implican comunicación colaboración con otros componentes (que muestran). por ejem-plo, operación calcularcostoporpágina ( ) (que forma parte interfaz calculartrabajo) -dría colaborar con componente llamado tabladevaluación que contuviera información sobre los precios del trabajo. operación verificarprioridad ( ) (parte interfaz iniciartrabajo) quizá colabore con componente nombre filadetrabajos para determinar los tipos prioridades trabajos que están espera producción. esta actividad elaboración aplica cada componente definido como parte del diseño arquitectura. una vez concluida, aplica más elaboración cada atributo, operación interfaz. deben especificarse las estructuras datos apropiadas para cada atributo. además, diseñan los detalles algorítmicos requeridos para implantar lógica del procesamiento aso-ciada con cada operación. este diseño del procedimiento analiza más adelante, este capí-tulo. por último, diseñan los mecanismos requeridos para implantar interfaz. para soft-ware orientado objetos, esto incluye descripción todos los mensajes que requieren para efectuar comunicación dentro del sistema. .. visión tradicional contexto ingeniería software tradicional, componente elemento funcional programa que incorpora lógica del procesamiento, las estructuras datos internas que imprimirtrabajocalculartrabajo iniciartrabajo númerodepáginas númerodeladostipodepapel pesodelpapel tamañodelpapel colordelpapel escalaampliaciónrequerimientosdecolorcaracterísticasdeproducción opcionesderecopilación opcionesdevinculación inventariodecubiertas extracción prioridadcostototaldeltrabajonúmerowo imprimirtrabajo calcularcostoporpágina( ) calcularcostodelpapel( )calcularcostodeproducción( )calcularcostototaldeltrabajo( )elaborarordendetrabajo( )veriﬁcarprioridad( )pasartrabajoaproducción( )clase diseño elaborada <<interfaz calculartrabajo calcularcostoporpágina( ) calcularcostodepapel( )calcularcostodeproducción( )componente diseñonúmerodepáginas númerodeladostipodepapelescalacaracterísticasdeproducciónimprimirtrabajo calcularcostodeltrabajo( )pasartrabajoaimpresora( )clase análisis <<interfaz iniciartrabajo calcularcostototaldeltrabajo( )elaborarordendetrabajo( ) veriﬁcarprioridad( )pasartrabajoaproducción( )figura . elaboración componente diseño (-).indd (-).indd // ::// :: diseño nivel componentes requieren para implantar lógica del procesamiento una interfaz que permite invocación del componente paso los datos. dentro arquitectura del software encuentra componente tradicional, también llamado módulo, que tiene tres funciones importantes: ) como componente control que coordina invocación todos los demás componentes del dominio del problema, ) como componente del dominio del problema que implanta una función completa parcial que requiere cliente ) como componente infraestructura que res- ponsable las funciones que dan apoyo procesamiento requerido dominio del pro-blema. igual que los componentes orientados objetos, los componentes tradicionales del software provienen del modelo análisis. sin embargo, este caso, elemento datos orientado flujo del modelo análisis sirve base para obtención. cada transformación (burbuja) representada los niveles más bajos del diagrama flujo datos mapea (véase sección .) una jerarquía módulos. cerca parte superior jerarquía (arquitectura del programa) hallan los componentes del control (módulos) hacia parte inferior ella tien-den encontrarse los del dominio del problema. para lograr una modularidad efectiva, cuando elaboran los componentes aplican conceptos diseño, como independencia fun-ciones (véase capítulo ). para ilustrar este proceso elaboración del diseño componentes tradicionales, considere otra vez software que debe elaborarse para taller impresión avanzada. durante -delado los requerimientos obtendrá conjunto diagramas flujo datos. suponga que éstos mapean arquitectura que aprecia figura .. cada rectángulo repre-senta componente del software. observe que los que están sombreados son equivalentes función operaciones los definidos para clase imprimirtrabajo que analizó sección ... sin embargo, este caso, cada operación representa como módulo aislado que invoca como indica figura. para controlar procesamiento utilizan otros módulos, por que son componentes control. cada módulo figura . elabora durante diseño nivel componentes. interfaz del módulo define explícitamente. decir, representa todo objeto datos cita: “invariablemente observa que sistema complejo que funciona evolucionado par-tir sistema sencillo que funcionaba.” john gall leer datos del trabajo impresiónsistema administración del trabajo seleccionar función administración del trabajo desarrollar costo del trabajoelaborar orden trabajoenviar trabajo producción calcular costo por páginacalcular costo del papelcalcular costo producciónveriﬁcar prioridadpasar trabajo producciónfigura . gráfica estructura sistema tradicional (-).indd (-).indd // ::// :: parte dos modelado calcularcostoporpáginacomponente del diseño accederabddecostosobtenerdatosdeltrabajo módulo elaborado costoporpágina entra: númerodepáginas entra: númerodedocumentosentra: lados = , : color = , , , : tamaño página = , , , dsale: costo páginaentra: tamaño del trabajoentra: color = , , , : tamañodepágina = , , , dsale: costo base por página (cbp)sale: factor tamaño () tamaño del trabajo () = númerodepáginas*númerodedocumentos; buscar costo base por página (cbp) - accederabddecostos (, color); buscar factor tamaño () - accederabdde costos (, color, tamaño) factor complejidad del trabajo (fct) = + [(lados-)*costoporlado+ costoporpágina= cbp*fctobtenerdatosdeltrabajo (númerodepáginas, númerodedocumentos, lados, color, tamañodepágina, costoporpágina)accederabddecostos (tamañodeltrabajo,color, tamañodepágina, cbp, ) calcularcostoporpágina( )control que fluya través interfaz. definen las estructuras datos que utilicen interior del módulo. algoritmo que permite que módulo cumpla función prevista -seña con empleo del enfoque refinamiento por etapas que estudió capítulo . comportamiento del módulo representa ocasiones con diagrama estado. para ilustrar este proceso, considere módulo calcularcostoporpágina. objetivo este módulo calcular costo impresión por página con base las especificaciones dadas por cliente. los datos requeridos para realizar esta función son: número páginas documento, número total documentos que producir, impresión por uno dos lados, requerimientos color requeri- mientos tamaño . estos datos pasan calcularcostoporpágina través interfaz del - dulo. calcularcostoporpágina usa estos datos para determinar costo por página con base tamaño complejidad del trabajo, que función todos los datos proporcionados - dulo través interfaz. costo por página inversamente proporcional tamaño del trabajo directamente proporcional complejidad. figura . representa diseño nivel componentes con uso notación uml modificada. módulo calcularcostoporpágina accede los datos invocando módulo obtener- datosdeltrabajo, que permite que todos los datos relevantes pasen componente, una interfaz base datos, accederbddecostos, que permite que módulo acceda una base datos que contiene todos los costos impresión. medida que avanza diseño, elabora -dulo calcularcostoporpágina para que provea los detalles del algoritmo interfaz (véase figura .). los detalles del algoritmo representan con uso del texto seudocódigo que aparece figura, con diagrama actividades uml. las interfaces representan como una colección objetos datos conceptos entrada salida. elaboración del diseño continúa hasta que haya detalles suficientes que guíen construcción del componente.conforme elabora diseño para cada componente del software, atención pasa diseño estructuras datos específicas diseño del procedimiento para manipularlas. sin embargo, hay que olvidar arquitectura que debe albergar los componentes las estructuras datos globales que den servicio muchos componentes.consejo figura . diseño nivel componentes para calcularcostoporpágina (-).indd (-).indd // ::// :: diseño nivel componentes .. visión relacionada con proceso visión orientada objetos tradicional del diseño nivel componentes, presentadas las secciones .. .., suponen que componente diseña desde nada. decir, que crea nuevo componente con base las especificaciones obtenidas del modelo requerimientos. por supuesto, existe otro enfoque. las últimas dos décadas, comunidad ingeniería software puesto énfasis necesidad elaborar sistemas que utilicen componentes software patrones -seño existentes. esencia, medida que avanza trabajo diseño dispone -tálogo diseño probado componentes nivel código. conforme desarrolla arquitectura del software, escogen del catálogo componentes patrones diseño usan para construir arquitectura. como estos componentes fueron construidos teniendo mente reutilizable, dispone totalmente descripción interfaz, las funciones que rea-lizan comunicación colaboración que requieren. sección . estudian algunos aspectos importantes ingeniería software basada componentes. uno los elementos clave que conducen éxito fraca- ingeniería estándares basados componen- tes disponibilidad, que ocasiones recibe nombre middleware. middleware una colección componentes infraestructura que permiten que los componentes del dominio del problema comuniquen entre través una red dentro sistema complejo. los ingenieros software que deseen usar desa-rrollo basado componentes como proceso software pueden ele-gir entre los estándares siguientes:omg corba- microsoft com- asp microsoft.net-http://msdn.microsoft.com/-/ netframework/default.aspx sun javabeans-http://java.sun.com/products/ejb/ estos sitios web tienen una amplia variedad métodos enseñan- , documentos limpio, herramientas recursos generados con dichos estándares importantes middleware.información estándares marcos basados componentes . iseño componentes basados clase como dijo, diseño nivel componentes basa información desarrollada como parte del modelo requerimientos (capítulos ) representa como parte del -delo arquitectónico (véase capítulo ). cuando escoge enfoque ingeniería orientado software, diseño nivel componentes centra elaboración clases especí-ficas del dominio del problema refinamiento las clases infraestructura contenidas modelo requerimientos. descripción detallada los atributos, operaciones inter-faces que emplean dichas clases detalle diseño que requiere como precursor actividad construcción. .. principios básicos del diseño hay cuatro principios básicos que son aplicables diseño nivel componentes que han sido ampliamente aceptados para aplicación ingeniería software orientada objetos. motivación subyacente para aplicar estos principios crear diseños que sean más factibles cambiar, así como reducir propagación efectos colaterales cuando hagan cambios. estos principios pueden usarse como guía cuando desarrolle cada componente del soft-ware. principio abierto-cerrado (pac). “ módulo [componente] debe ser abierto par exten- sión pero cerrado para modificación” [mar]. este enunciado parece ser una contradicción, pero representa una las características más importantes buen diseño nivel (-).indd (-).indd // ::// :: parte dos modelado componentes. dicho pocas palabras, debe especificarse componente forma tal que permita extenderlo (dentro del dominio funcional que está dirigido) sin necesidad hacerle modificaciones internas ( nivel del código lógica). para lograr esto, crean abstrac-ciones que sirven como búfer entre funcionalidad que sea probable extender clase diseño . por ejemplo, suponga que función seguridad casasegura utiliza clase detector que debe revisar estado cada tipo sensor seguridad. probable que, conforme pase tiempo, crezca número tipos sensores seguridad. lógica procesamiento interno implementa como una secuencia comandos -entonces- otro caso, cada uno dirigido tipo diferente sensor, cuando agregue uno nuevo requerirá una lógica procesa-miento interno adicional (otro -entonces- otro caso). esto sería una violación del pac.detector<<interfaz sensor leer( ) activar( )desactivar( )probar( ) ventana/ sensordepuertasensordehumodetectorde movimientosensordecalor sensordeco . seguimiento del pac escena: cubículo vinod. participantes: vinod shakira, miembros del equipo ingeniería software casasegura. conversación:vinod: acaba llamar doug [gerente del equipo]. dice que mercadotecnia quiere agregar nuevo sensor. shakira (con sonrisa cómplice): otra vez, por favor…vinod: … vas creer con que salieron…shakira: sorpréndeme.vinod (ríe): llaman sensor angustia del perro. shakira: ¿qué dijiste?vinod: para gente que deja mascota departamentos condominios casas que están muy cerca una otra. perro comienza ladrar, vecino enoja queja. con este sensor, perro ladra durante, digamos, más minuto, sensor hace sonar una alarma especial que llama propietario teléfono móvil. shakira: bromeas, ¿verdad?vinod: , . doug quiere saber cuánto tiempo nos llevaría agre- gar eso función seguridad. shakira (piensa momento): mucho… mira [muestra vinod figura .]. hemos aislado las clases reales sensor atrás interfaz sensor. cuando tengamos las especificaciones para sensor perrito, será pan comido agregarlo. único que tendré que hacer crear componente apropiado para … mmm, una clase. componente detector cambiará absoluto. vinod: entonces diré doug que hay problema.shakira: conociendo doug, nos estará vigilando; daría asunto del perrito hasta siguiente entrega. vinod: está mal, pero podrías implantarlo ahora quisiera, ¿ ? shakira: , forma que diseñamos interfaz permite hacerlo sin problemas. vinod (piensa momento): ¿has oído hablar del principio abierto-cerrado? shakira (encoge los hombros): nunca.vinod (sonríe): hay problema.casasegura pac acción (-).indd (-).indd // ::// :: diseño nivel componentes figura . ilustra una forma seguir pac para clase detector. interfaz sensor presenta una consistente visión los componentes sensores para los detectores. agregara nuevo tipo sensor, requeriría hacer ningún cambio para clase detector (componente). preservaría pac. principio sustitución liskov (psl). “las subclases deben ser sustituibles por sus clases base” [mar]. este principio diseño, originalmente propuesto por barbara lisko [lis], sugiere que componente que use una clase base debe funcionar bien una clase derivada clase base pasa componente. psl demanda que cualquier clase derivada una clase base debe respetar cualquier contrato implícito entre clase base los componen-tes que usan. contexto este análisis, “contrato” una precondición que debe ser verdadera antes que componente use una clase base una poscondición que debe ser ver dadera después ello. cuando crean clases derivadas hay que asegurarse que respeten precondición poscondición. principio inversión dependencia (pid). “dependa las abstr acciones. - penda las concreciones” [mar]. como vio estudio del pac, las abstracciones son lugar que posible ampliar diseño sin muchas dificultades. entre más dependa componente otros componentes concretos ( abstracciones tales como una interfaz), más difícil será ampliarlo. principio segregación interfaz (psi). “ mejor tener uchas interfaces específicas del cliente que una sola propósito general” [mar]. hay muchas instancias las que múltiples componentes del cliente usan las operaciones que provee una clase servidor. psi sugiere que debe crearse una interfaz especializada que atienda cada categoría principal clientes. interfaz ese cliente, sólo deben especificarse aquellas operaciones que sean relevantes para una categoría particular clientes. por ejemplo, considere clase planodelacasa que usó las funciones seguridad vigilancia casasegura (véase capítulo ). para las funciones seguridad, planodelacasa utiliza sólo durante las actividades configuración emplea las operaciones situardisposi- tivo( ), mostrardispositivo( ), agrupardispositivo( ) quitardispositivo( ) para situar, mostrar, agru- par quitar sensores del plano casa. función vigilancia casasegura usa las cuatro operaciones mencionadas para seguridad, pero también requiere operaciones especiales para administrar cámaras: mostrarfov( ) mostraridentificacióndedispositivo( ). entonces, psi - giere que los componentes cliente las dos funciones casasegura tienen interfaces espe- cializadas definidas para ellas. interfaz para seguridad incluiría sólo las operaciones situar- dispositivo( ), mostrardispositivo( ), agrupardispositivo( ) quitardispositivo( ). interfaz para vigilancia incorporaría esas mismas operaciones pero también mostrarfov( ) mostraridentifi- cacióndedispositivo( ). aunque los principios diseño nivel componentes son una guía útil, los componen- tes existen vacío. muchos casos, los componentes clases individuales están orga-nizados subsistemas paquetes. razonable preguntar cómo debe ocurrir esta actividad agrupamiento. ¿exactamente cómo deben organizarse los componentes conforme avanza diseño? martin [mar] propone principios adicionales agrupamiento que son aplicables diseño nivel componentes: principio equivalencia liberación reutilización (per). “ ánulo reuti- lización gránulo liberación” [mar]. cuando las clases componentes diseñan para ser reutilizables, existe contrato implícito que establece entre desarrollador enti-dad reutilizable las personas que emplearán. desarrollador compromete establecer sistema que controle liberación para que apoyo mantenimiento las versiones ante-riores entidad mientras los usuarios actualizan poco poco con versión más nueva. omite diseño pasa código, sólo recuerde que diseño última “concreción”. estaría violando pid.consejo punto clave para que los componentes sean reutilizables, diseño requiere algo más que buen diseño técnico. también exige mecanismos efectivos configuración (véase capítulo ). (-).indd (-).indd // ::// :: parte dos modelado lugar abordar cada clase individual, frecuente que sea mejor agrupar las que sean reutilizables paquetes que puedan manejarse controlar medida que evolucionen las nue-vas versiones. principio cierre común (pcc). “las clases que cambian juntas pertenecen mismo” [mar]. las clases deben empacarse forma cohesiva. decir , cuando las clases agrupan como parte diseño, deben estar dirigidas misma área funciones comportamiento. cuando deba cambiar alguna característica dicha área, probable que sólo aquellas clases que haya dentro del paquete requieran modificación. esto lleva control cambios manejo liberación más eficaces. principio reutilización común (prc). “las clases que reutilizan juntas deben agruparse juntas” [mar]. cuando cambia una más clases dentro paquete , cambia número liberación del paquete. entonces, todas las demás clases paquetes que permane-cen paquete que cambió deben actualizarse con liberación más reciente someterse pruebas fin garantizar que nueva versión opera sin problemas. las clases agrupan manera cohesiva, posible que cambie una clase sin relación junto con las demás que hay dentro del paquete. esto generará integración pruebas innecesarias. por esta razón, sólo las clases que reutilicen juntas deben incluirse dentro paquete. .. lineamientos diseño nivel componentes además los principios estudiados sección .., conforme avanza diseño nivel componentes aplican lineamientos prácticos los componentes, sus interfaces las características dependencia herencia que tengan algún efecto diseño resultante. -bler [amb] sugiere los lineamientos siguientes: componentes. deben establecerse convenciones para dar nombre los componentes que especifique que forman parte del modelo arquitectónico, para luego mejorarlos elaborarlos como parte del modelo nivel componentes. los nombres los componentes arquitec-tónicos deben pro venir del dominio del problema significar algo para todos los participantes que vean modelo arquitectónico. por ejemplo, nombre clase planodelacasa tiene significado para todos los que lean, aunque tengan formación técnica. por otro lado, los componentes infraestructura clases elaboradas nivel componentes deben recibir nombre que tenga significado específico implantación. como parte implan-tación planodelacasa administrarse una lista vinculada, apropiada operación administrarlista( ), aun una persona sin capacitación técnica pudiera interpretarlo mal. pueden usarse estereotipos para ayudar identificar naturaleza los componentes nivel diseño detallado. por ejemplo, <<infraestructura debiera usarse para identificar componente infraestructura, <<basededatos podría emplearse para identificar una base datos que servicio una más clases diseño todo sistema; usaría <<tabla para identificar una tabla dentro una base datos. interfaces. las interfaces dan información importante sobre comunicación colabora- ción (también nos ayudan cumplir ). sin embargo, representación sin restricciones las interfaces tiende complicar los diagramas componentes. ambler [amb] recomienda que ) los diagramas aumentan complejidad, lugar del enfoque formal del uml con recuadro flecha, debe representarse interfaz con una paleta; ) aras consistencia, las interfaces deben fluir partir del lado izquierdo del recuadro del componente; ) sólo deben aparecer aquellas interfaces que sean relevantes para componente que está considerando, ¿qué que hay que tomar cuenta dar nombre los componentes?? probable que alguien mercadotecnia organización cliente ( tipo técnico) analice infor- mación diseño detallado. (-).indd (-).indd // ::// :: diseño nivel componentes aun estuvieran disponibles otras. estas recomendaciones buscan simplificar naturaleza visual los diagramas uml componentes. dependencias herencia. para tener una mejor legibilidad, buena idea modelar las - pendencias izquierda derecha herencia abajo (clases obtenidas) hacia arriba (clases base). además, las interdependencias componentes deben representarse por medio inter-faces con dependencia componente componente. según filosofía del , esto ayudará hacer que sea más fácil dar mantenimiento sistema. .. cohesión capítulo describió cohesión como “unidad objetivo” componente. contexto del diseño nivel componentes para los sistemas orientados objetos, cohe- sión implica que componente clase sólo contiene atributos operaciones que relacionan cerca uno con otro con clase componente . lethbridge laganiére [let] -finen varios tipos diferentes cohesión ( listan función del nivel cohesión): funcional. tienen sobre todo las operaciones; este nivel cohesión ocurre cuando componente realiza cálculo luego devuelve resultado. capa. tienen los paquetes, componentes clases; este tipo cohesión ocurre cuando una capa más alta accede los servicios otra más baja, pero ésta tiene -ceso las superiores. por ejemplo, considere requerimiento función seguridad casasegura para hacer una llamada telefónica detecta una alarma. podría definirse conjunto paquetes capas, como aprecia figura .. los paquetes som-breados contienen componentes infraestructura. posible realizar acceso del -quete del panel control hacia abajo. comunicación. todas las operaciones que acceden los mismos datos definen dentro una clase. general, tales clases centran únicamente los datos cues-tión, acceden ellos los guardan. las clases componentes que tienen cohesión funcional, capa comunicación son relativa-mente fáciles implantar, probar mantener. siempre que sea posible, deben alcanzarse estos niveles cohesión. sin embargo, importante notar que ocasiones hay aspectos pragmá-ticos del diseño implantación que obligan optar por niveles cohesión más bajos. general, entre más alto sea nivel cohesión, componente más fácil implantar, probar man- tener.aunque instructivo entender los distintos niveles cohesión, más importante tener presente concepto general cuando diseñen componentes. mantenga cohesión tan grande como sea posible.consejo detectorpanel control teléfono módem telecomunicacionesfigura . cohesión capa (-).indd (-).indd // ::// :: parte dos modelado .. acoplamiento estudio anterior del análisis diseño, dijo que comunicación colaboración eran elementos esenciales cualquier sistema orientado objetos. sin embargo, esta característica tan importante ( necesaria) tiene lado oscuro. medida que aumentan comunicación colaboración ( decir, conforme eleva “conectividad” entre las clases), complejidad del sistema también incrementa. complejidad aumenta, también crece dificultad implantar, probar dar mantenimiento software. acoplamiento medición cualitativa del grado que las clases conectan una con otra. conforme las clases ( componentes) hacen más interdependientes, acoplamiento crece. objetivo importante del diseño nivel componente mantener acopla-miento tan bajo como sea posible. acoplamiento las clases manifiesta varias maneras. lethbridge laganiére [let] definen las siguientes categorías acoplamiento: acoplamiento contenido. tiene lugar cuando componente “modifica subrepticia-mente datos internos otro componente” [let]. esto viola ocultamiento infor-mación, concepto básico del diseño. acoplamiento común. sucede cuando cierto número componentes hacen uso una variable global. aunque veces esto necesario (por ejemplo, para establecer valores - escena: cubículo jamie. participantes: jamie , miembros del equipo ingeniería software que trabajan función vigilancia. conversación:: tengo diseño primer corte del componente cámara.jamie: ¿quieres revisarlo rápido?: … pero realidad quisiera que dijeras algo.(con señas, jamie invita que continúe.): originalmente definimos cinco operaciones para cámara. mira… determinartipo( ) dice tipo cámara. cambiarubicación( ) permite mover cámara por plano casa. mostraridentificación( ) obtiene identificación cámara muestra cerca ícono. mostrarvista( ) presenta campo visión cámara forma gráfica. mostraracercamiento( ) muestra gráficamente amplificación cámara. : las diseñé por separado son operaciones muy simples. por eso pensé que sería una buena idea combinar todas las operaciones pantalla una sola que denominé mostrarcámara( ) que mos-trará identificación, vista acercamiento. ¿cómo ves? jamie (hace una mueca): estoy seguro que sea una buena idea. (frunce seño): ¿por qué? todas esas pequeñas operaciones pueden dar dolores cabeza. jamie: problema que las combinemos que pierde cohe- sión, sabes, operación mostrarcámara( ) tendrá único objetivo. ( poco exasperado): ¿ qué? todo este asunto requerirá menos líneas código fuente, acaso. será más fácil implantar… creo. jamie: ¿ qué pasa decidimos cambiar forma que repre- sentamos campo visión? : sólo pasa operación mostrarcámara( ) hace modificación. jamie: ¿qué hay con los efectos colaterales?: ¿qué quieres decir?jamie: bueno, digamos que hace cambio, pero, sin darnos cuenta, genera problema mostrar pantalla identifi-cación. : sería tan torpe.jamie: tal vez , pero, ¿qué tal alguien apoyo tiene que hacer modificación dentro dos años? tal vez entenderá operación tan bien como , , ¿quién sabe?, podría ser torpe. : entonces, ¿estás contra?jamie: eres diseñador… decisión… sólo asegúrate que entiendes las consecuencias poca cohesión. (piensa momento): tal vez haga operaciones pantalla separadas. jamie: buena decisión.casasegura cohesión acción medida que elabora diseño cada componente del software, atención pasa diseño las estr ucturas específicas los datos diseño procedimientos para manipularlas. sin embargo, hay que olvidar arquitectura que debe albergar los componentes las estructuras globales los datos, que tal vez atiendan muchos componentes.consejo (-).indd (-).indd // ::// :: diseño nivel componentes finidos que utilizan toda aplicación), acoplamiento común lleva propagación incontrolada del error efectos colaterales imprevistos cuando hacen los cambios. acoplamiento del control. tiene lugar operación ( ) invoca operación ( ) pasa una bandera control . bandera “dirige” entonces flujo lógica dentro . problema con esta forma acoplamiento que cambio relacionado puede dar como resultado necesidad cambiar significado bandera control que pasa . esto pasa por alto ocurrirá error. acoplamiento molde. presenta cuando declara claseb como tipo para argumento una operación clasea. como claseb ahora forma parte definición clasea, modificación del sistema vuelve más compleja. acoplamiento datos. ocurre las operaciones pasan cadenas largas argumentos datos. “ancho banda” comunicación entre clases componentes crece complejidad interfaz incrementa. hace más difícil hacer pruebas dar manteni-miento. acoplamiento rutina llamada. tiene lugar cuando una operación invoca otra. este nivel acoplamiento común con frecuencia muy necesario. sin embargo, -menta conectividad del sistema. acoplamiento tipo uso. ocurre componente usa tipo datos definidos componente (esto ocurre siempre que “una clase declara una variable instancia una variable local como tuviera otra clase para tipo” [let]). cambia definición tipo, también debe cambiar todo componente que utilice. acoplamiento inclusión importación. pasa cuando componente importa - cluye paquete contenido del componente . acoplamiento externo. sucede componente comunica colabora con compo-nentes infraestructura (por ejemplo, funciones del sistema operativo, capacidad base datos, funciones telecomunicación, etc.). aunque este tipo acoplamiento necesario, debe limitarse número pequeño componentes clases dentro sis-tema. software debe tener comunicación interna externa. por tanto, acoplamiento hecho vida. sin embargo, diseñador debe trabajar para reducirlo siempre que sea posible, entender las ramificaciones que tiene acoplamiento abundante cuando puede evitarse. escena: cubículo shakira. participantes: vinod shakira, miembros del equipo software casasegura, que trabajan función seguridad. conversación:shakira: tuve que considero una gran idea… entonces pensé poco pareció que era tan buena. final deseché, pero pensé hacerla para ustedes. vinod: seguro. ¿cuál idea?shakira: bueno, cada uno los sensores reconoce una condición alarma algún tipo, ¿verdad?vinod (sonríe): por eso llaman sensores, shakira. shakira (exasperada): sarcasmo, vinod, tienes que mejorar tus habilidades interpersonales. vinod: ¿decías?shakira: bien, cualquier modo, pregunté… por qué crear una operación dentro cada objeto sensor llamada hacerllamada( ) que colaboraría directamente con componente salellamada, bueno, con una interfaz hacia componente salellamada. vinod (pensativo): quieres decir, ¿eso vez hacer que esa colaboración ocurra fuera componente como paneldecon-trol algún otro?casasegura acoplamiento acción (-).indd (-).indd // ::// :: parte dos modelado . ealización del diseño nivel componentes antes, este capítulo, dijo que diseño nivel componentes naturaleza ela- borativa. debe transformarse información los modelos requerimientos arquitectónico una representación diseño que suficientes detalles para guiar actividad construc-ción (codificación pruebas). los pasos siguientes representan conjunto tareas comunes para diseño nivel componentes cuando aplica sistema orientado objetos. paso . identificar todas las clases diseño que correspondan dominio del pro- blema. con uso del modelo requerimientos arquitectónico, elabora cada clase análisis componente arquitectura según describió sección ... paso . identificar todas las clases diseño que correspondan dominio infra- estructur . estas clases están descritas modelo los requerimientos con frecuen- cia pierden partir del modelo arquitectónico; sin embargo, deben describirse este punto. como dijo, las clases componentes esta categoría incluyen componentes interfaz gráfica usuario (con frecuencia disponibles como componentes reutilizables), componentes del sistema operativo componentes administración objetos datos. paso . elaborar todas las clases diseño que sean componentes reutilizables. elaboración requiere que describan detalle todas las interfaces, atributos operaciones necesarios para implantar clase. mientras realiza esta tarea, deben considerarse los heurís-ticos del diseño (como cohesión acoplamiento del componente). paso . especificar detalles del mensaje cuando colabor clases componentes. modelo requerimientos utiliza diagrama colaboración para mostrar forma que las clases análisis colaboran una con otra. medida que avanza diseño nivel componentes, ocasiones útil mostrar los detalles estas colaboraciones especificando las estructuras los mensajes que pasan entre los objetos sistema. unque esta actividad diseño opcional, usa como precursor especificación interfaces que muestren modo que comunican colaboran los componentes del sistema. figura . ilustra diagrama sencillo colaboración para sistema impresión que mencionó. los objetos trabajodeproducción, ordendetrabajo filadetrabajos - laboran para preparar trabajo impresión fin ejecutar una secuencia producción. los mensajes entre los objetos transmiten como ilustran las flechas figura. durante modelación los requerimientos, los mensajes especifican como aprecia. sin embargo, conforme diseño avanza, cada mensaje elabora expandiendo sintaxis manera -guiente [ben]: [condición guardia] expresión secuencia (devuelve valor) := nombre del mensaje (lista argumentos)shakira: … pero entonces dije que eso significaba que cada objeto sensor estaría conectado componente salellamada, que eso querría decir que estaría acoplado manera indirecta con mundo exterior … bueno, pensé que sólo complicaría las cosas. vinod: estoy acuerdo. este caso, mejor idea dejar que interfaz del sensor pase información paneldecontrol que ini-cie llamada salida. además, diferentes sensores tal vez darían como resultado números telefónicos distintos. querrías que sensor guardara esa información, porque cambiara… shakira: sentí bien.vinod: heurística del diseño para acoplamiento nos dice que está bien. shakira: pues . cita: “ hubiera tenido más tiempo habría escrito una carta más breve.” blas pascal trabaja ambiente sin espías, los primeros tres pasos dirigen refinar los objetos datos las funciones procesamiento (transformaciones) identificadas como parte del modelo requerimientos.consejo (-).indd (-).indd // ::// :: diseño nivel componentes donde [condición guardia] escribe lenguaje restricción objetos (lro) especifi- cualesquiera condiciones que deban cumplirse antes que pueda enviarse mensaje; - presión secuencia valor entero ( otro indicador ordenación, por ejemplo, ..) que indica orden secuencial que envía mensaje; (devuelve valor) nombre infor- mación que devuelve operación invocada por mensaje; nombre del mensaje identifica ope- ración que invocarse (lista argumentos) lista atributos que pasan opera- ción. paso . identificar interf aces apropiadas para cada componente. contexto del diseño nivel componentes, una interfaz uml “grupo operaciones visibles - ternamente (para público). interfaz contiene estructura interna, atributos asocia-ciones…” [ben]. dicho con más formalidad, una interfaz equivalente una clase abs-tracta que pro vee una conexión controlada entre clases diseño. figura . ilustra elaboración interfaces. esencia, las operaciones definidas para clase diseño cla-sifican una más clases abstractas. cada operación dentro clase abstracta ( interfaz) debe ser cohesiva, decir, debe tener procesamiento que centre una función subfun-ción limitada. relación con figura ., puede afirmarse que interfaz iniciartrabajo tiene sufi- ciente cohesión. realidad, ejecuta tres subfunciones diferentes: elaborar una orden tra-bajo, verificar prioridad del trabajo pasar trabajo producción. interfaz debe redise-ñarse. enfoque podría consistir volver estudiar las clases diseño definir una nueva, ordendetrabajo, que haría cargo todas las actividades asociadas con formación una orden trabajo. operación elaborarordendetrabajo( ) vuelve parte esa clase. manera similar, definiría una clase filadetrabajos que incorporaría operación verificar- prioridad( ). una clase trabajodeproducción podría incorporar toda información asociada con trabajo que pasara las instalaciones producción. interfaz iniciartrabajo podría adoptar forma que muestra figura .. ahora interfaz iniciartrabajo cohesiva centra una función. las interfaces asociadas con trabajodeproducción, ordendetra-bajo filadetrabajos también tienen solo objetivo. paso . elabor atributos definir tipos estructuras datos requeridos para implantarlos. general, las estructuras tipos datos usados para definir atributos definen contexto del lenguaje programación que usar para implantación. uml define tipo datos del atributo que usa siguiente sintaxis: nombre : tipo--expresión = valor-inicial {cadena propiedades} apéndice analiza brevemente lro.:trabajode producción :ordendetrabajo :filadetrabajos: elaborartrabajo (número ordende trabajo): enviartrabajo(número orden trabajo)figura . diagrama colaboración con mensajería (-).indd (-).indd // ::// :: parte dos modelado donde nombre nombre del atributo, tipo--expresión tipo datos, valor-inicial valor que toma atributo cuando crea objeto cadena propiedades define una propiedad - racterística del atributo. durante primera iteración del diseño nivel componentes, los atributos normal- mente describen por nombre. nuevo, figura ., lista atributos para impri- mirtrabajo sólo enlista los nombres los atributos. obstante, medida que avanza elaboración del diseño, cada atributo define con formato atributos uml mencionado. por ejemplo, tipodepapel-peso define del modo siguiente: tipodepapel-peso: cadena = “” {contiene valores – , , } que define tipodepapel-peso como una variable cadena que inicializa valor que puede adoptar uno cuatro valores del conjunto {, , , }. atributo aparece forma repetida varias clases diseño tiene una estructura relativamente compleja, mejor crear una clase separada para que albergue. paso . describir detalle flujo del ocesamiento dentro cada operación. esto logra con uso seudocódigo basado lenguaje programación con diagrama uml actividades. cada componente del software elabora través cierto número iteraciones que apliquen paso paso concepto refinamiento (capítulo ). primera iteración define cada operación como parte clase diseño. cada caso, operación debe caracterizarse forma tal que asegure que haya mucha cohesión; decir , operación debe estar dirigida ejecución una sola función subfunción. siguiente ite-ración hace más que expandir nombre operación. por ejemplo, operación calcu- larcostodelpapel( ) que aparece figura . expande manera siguiente: calcularcostodelpapel (peso, tamaño, color): numérico esto indica que calcularcostodelpapel( ) requiere como entrada los atributos peso, tamaño color, como salida valor numérico (valor dólares). algoritmo requerido para implantar calcularcostodelpapel( ) sencillo entendido por todos, tal vez sea necesaria una mayor elaboración del diseño. ingeniero software que haga codificación proveerá los detalles necesarios para implantar operación. sin embargo, algoritmo fuera más complejo difícil entender, requeriría elaborar más diseño. figura . ilustra diagrama uml actividades para calcularcostodelpapel( ) . cuando usan diagramas actividades para especificar diseño nivel componentes, por imprimirtrabajocalculartrabajo iniciartrabajo trabajode producciónelaborartrabajo enviartrabajoordendetrabajo atributos apropiados elaborarordendetrabajo( )obtenerdescripción deltrabajo filadetrabajos atributos apropiados veriﬁcarprioridad( )<<interfaz iniciartrabajo pasartrabajoaproducción( )figura . rediseño interfaces definiciones clase para imprimirtrabajo para refinar diseño del componente, utilice una elaboración stepwise. siempre pregunte, “¿hay una forma simplificar esto que aun así logre mismo resultado?”consejo (-).indd (-).indd // ::// :: diseño nivel componentes general representan nivel abstracción que algo mayor que código fuente. sección .. estudia enfoque alternativo: uso seudocódigo para hacer las especifi-caciones del diseño. paso . describir las fuentes persistentes datos (bases datos archivos) iden- tificar las clases equeridas para administrarlos. normal que las bases datos - chivos trasciendan descripción del diseño componente individual. mayoría casos, estos almacenamientos persistentes datos especifican inicio como parte del -seño arquitectura. obstante , medida que avanza elaboración del diseño, fre- cuente que sea útil dar detalles adicionales sobre estructura organización dichas fuentes persistentes datos. paso . desarrollar elaborar representaciones del comportamiento para una clase componente. los diagramas estado uml fueron utilizados como parte del modelo los requerimientos para representar comportamiento observable desde exterior del sistema más localizado las clases análisis individuales. durante diseño nivel com-ponentes, ocasiones necesario modelar comportamiento una clase diseño. comportamiento dinámico objeto (instancias una clase diseño cuando pro- grama ejecuta) afectado por eventos externos por estado curso (modo comportamiento) del objeto. para entender comportamiento dinámico objeto, deben estudiarse todos los casos uso que sean relevantes para clase diseño largo validar entrada atributos accederabdpapel (peso) devuelve costobaseporpágina tamaño = costoporpáginadepapel = costoporpáginadepapel*. tamaño = costoporpáginadepapel = costoporpáginadepapel*. tamaño = costoporpáginadepapel = costoporpáginadepapel*. colores estándar costoporpáginadepapel = costoporpáginadepapel*. color estándarcostoporpáginadepapel = costobaseporpágina devuelve (costoporpáginadepapel)figura . diagrama actividades uml para calcular costodelpapel( ) (-).indd (-).indd // ::// :: parte dos modelado vida. estos casos uso dan información que ayuda delinear los eventos que afectan objeto los estados los que éste reside conforme pasa tiempo suceden los eventos. las transi-ciones entre estados (dictadas por los eventos) representan con diagrama estado [ben] como que ilustra figura .. transición estado otro (representada por rectángulo con esquinas redondea- das) ocurre como consecuencia evento que tiene forma siguiente: nombre-del-evento (lista--parámetros) [guardar-condición] / expresión acción donde nombre-del-evento identifica evento, lista--parámetros incorpora datos asociados con evento, guardar-condición escribe lenguaje restricción objetos (lro) especifica una condición que debe cumplirse para que pueda ocurrir evento, expresión acción define una acción que ocurre medida que toma lugar transición. figura ., cada estado define acciones entrada/ salida/ que ocurren cuando - cede transición estado fuera éste, respectivamente. mayor parte los casos, estas acciones corresponden operaciones que son relevantes para clase que modela. indicador hacer/ proporciona mecanismo para señalar actividades que tienen lugar mientras está estado indicador incluir/ proporciona medio para elaborar comporta- miento incrustando más detalles del diagrama estado definición estado. importante observar que modelo del comportamiento con frecuencia contiene informa- ción que obvia primera vista otros modelos del diseño. por ejemplo, análisis cui-dadoso del diagrama estado figura . indica que comportamiento dinámico clase imprimirtrabajo contingente mientras obtengan dos aprobaciones datos costo programación para trabajo impresión. sin las aprobaciones ( condición guar-elaborardatosdeltrabajo entrada/leerdatosdeltrabajo( ) salida/mostrardatosdeltrabajo( )hacer/veriﬁcarconsistencia( )incluir/entradadedatos entrada/calculartrabajosalida/guardar costototaldeltrabajo formacióndeltrabajo entrada/elaborartrabajosalida/guardar número othacer/calcularcostodeltrabajo enviartrabajo entrada/enviartrabajosalida/iniciartrabajohacer/colocar filadetrabajoscomportamiento dentro del estado elaborardatosdeltrabajo entradadedatosterminada (todos los datosson consistentes)/mostraropcionesdelusuarioentradadedatosincompleta fechadeentregaaceptada ( autoriza cliente)/imprimirestimacióndeltrabajocostodeltrabajoaceptado ( autoriza cliente)/obtenerfirmaelectrónica trabajoenviado (todas las autorizacionesobtenidas)/imprimirordendetrabajofigura . fragmento diagrama estado para clase imprimirtrabajo (-).indd (-).indd // ::// :: diseño nivel componentes dar garantiza que cliente está autorizado para aprobar), trabajo impresión puede enviarse porque hay forma alcanzar estado enviartrabajo. paso . elaborar diagramas despliegue para dar más detalles implantación. los diagramas despliegue (véase capítulo ) utilizan como parte del diseño arquitec-tura representan forma descriptor . este modo, las funciones principales sistema (que con frecuencia representan como subsistemas) representan contexto del ambiente computación que las contendrá. durante diseño nivel componentes, pueden elaborarse diagramas despliegue que representen ubicación paquetes componentes clave. sin embargo, diagrama componentes, éstos por general representan manera individual fin evitar complejidad del diagrama. ciertos casos, elaboran diagramas despliegue forma instancia ese momento. esto significa que especifican los ambientes del hardware sistema operativo que emplearán, indica ubicación los paquetes componentes dentro este ambiente. paso . rediseñar cada representación del diseño nivel componentes siem- considerar alternativas. este libro hace hincapié que diseño proceso iterativo. primer modelo nivel componentes que crea será tan completo, con-sistente exacto como enésima iteración que realice. esencial rediseñar medida que ejecuta trabajo diseño. además, debe adoptarse una visión túnel. siempre hay soluciones alternativas para diseño los mejores diseñadores toman cuenta todas ellas ( mayoría) antes decidirse por modelo diseño final. desarrolle las alternativas estudie con cuidado cada una, con los principios conceptos del diseño presentados capítulo éste. . iseño nivel componentes para webapps frecuente que cuando trata sistemas aplicaciones basados web, frontera entre contenido función sea borrosa. por tanto, razonable preguntar: ¿qué componente webapps? contexto este capítulo, componente webapp ) una función cohesiva bien definida que manipula contenido procesamiento cómputo datos para usuario final ) paquete cohesivo contenido funciones que brindan usuario final alguna capacidad solicitada. entonces, diseño nivel componentes webapps con frecuencia incorpora elementos diseño del contenido las funciones. .. diseño del contenido nivel componente diseño del contenido nivel componentes centra objetos contenido forma que empacan para presentación usuario final webapps. por ejemplo, considere una capacidad vigilancia con video dentro casaseguraasegurada.com. entre muchas otras capacidades, usuario selecciona controla cualesquiera cámaras representa-das plano casa, solicita imágenes instantáneas todas las cámaras muestra video desde cualquiera ellas. además, usuario tiene posibilidad abrir ángulo hacer acercamientos con una cámara por medio los íconos apropiados control. para capacidad vigilancia con video, pueden definirse varios componentes potenciales contenido: ) objetos contenido que representen distribución del espacio ( plano casa) con íconos adicionales que representen ubicación sensores cámaras video, ) conjunto imágenes instantáneas video (cada una objeto datos separado) ) ventana del video una cámara específica. cada uno estos componentes recibe nombre por separado manipula como paquete. (-).indd (-).indd // ::// :: parte dos modelado considere plano casa con cuatro cámaras colocadas estratégicamente una casa. solicitud del usuario, captura una toma video desde cada cámara identifica como objeto contenido generado forma dinámica, tomadevideo , donde identifica las cáma- ras . componente contenido, llamado imágenesinstantáneas, combina los cuatro objetos contenido tomadevideon los muestra página vigilancia con video. formalidad del diseño del contenido nivel componentes debe adaptarse las - racterísticas webapp que elaborar. muchos casos, los objetos contenido necesitan estar organizados como componentes pueden manipularse forma individual. sin embargo, medida que aumentan tamaño complejidad ( webapp, los objetos contenido sus interrelaciones), necesario organizar contenido forma que sea fácil hacer referencia manipular diseño. además, contenido muy dinámico (por ejemplo, sitio subastas línea), importante establecer modelo estructural claro que incorpore los componentes del contenido. .. diseño las funciones nivel componentes las aplicaciones web modernas proporcionan funciones procesamiento cada vez más sofis-ticadas que: ) producen procesamiento localizado que genera contenido capacidad navegación forma dinámica; ) dan capacidad computación procesamiento datos que resultan adecuados para dominio del negocio webapp; ) brindan consultas acceso avanzado una base datos, ) establecen interfaces datos con sistemas corporativos externos. para lograr las capacidades anteriores ( muchas otras), diseñan componentes webapp que tengan forma similar los componentes del software convencional. las funciones webapp entregan como una serie componentes desarrollados paralelo con arquitectura información que garantice que sean consistentes. esencia, comienza con consideración del modelo requerimientos arquitectura inicial información, para luego estudiar modo que las funciones afectan interacción del usuario con aplicación, información que presenta las tareas que usuario realiza. durante diseño arquitectura, contenido funciones webapp combinan para crear una arquitectura funcional, que una representación del dominio funciones web- app describe los componentes funcionales clave webapp forma que interactúan una con otra. por ejemplo, las funciones abrir ángulo hacer acercamientos capacidad vigi- lancia con video para casaseguraasegurada.com implementan como las operaciones - correr( ) zoom( ), que forman parte clase cámara. cualquier caso, funcionalidad implícita para recorrer( ) zoom( ) deben implantarse como módulos dentro casasegura- asegurada.com. . iseño componentes tradicionales los fundamentos del diseño nivel componentes para software tradicional estable- cieron principios década formalizaron con trabajo edsger dijkstra . ([boh], [dij] [dij]). finales esa época, ellos propusieron empleo con-junto construcciones lógicas restringidas con las que pudiera elaborarse cualquier programa. los componentes del contenido también pueden volverse utilizar otras webapps. componente tradicional software implementa elemento procesamiento abocado una función subfunción dominio del problema, cierta capacidad dominio infraestructura. los componentes tradicionales, llamados con frecuencia módulos, procedimientos subrutinas, incluyen datos misma forma que hacen los componentes orientados objetos.punto clave programación estructurada una técnica diseño que limita flujo lógica tres construcciones: secuencia, condición repetición. (-).indd (-).indd // ::// :: diseño nivel componentes las construcciones ponían énfasis “mantenimiento del dominio funcional”. decir, cada construcción tenía una estructura lógica predecible que introducía principio salía por final, que permitía que lector siguiera flujo del procedimiento con más facilidad. las construcciones son secuencia, condición repetición. secuencia implementa pasos procesamiento que son esenciales especificación cualquier algoritmo. condición proporciona medio para seleccionar procesamiento con base algún suceso lógico repetición permite ejecución lazos. estas tres construcciones son fundamentales para programación estructurada, técnica importante del diseño nivel componentes. las construcciones estructuradas fueron propuestas para limitar diseño del software orien- tado procedimiento número pequeño estructuras lógicas predecibles. medición complejidad (véase capítulo ) indica que uso las construcciones estructuradas -duce complejidad del programa con ello mejora legibilidad facilidad realizar prue-bas dar mantenimiento. uso número limitado construcciones lógicas también contribuye proceso comprensión humana que los sicólogos denominan lotificación. para entender este proceso, considere lector forma que está leyendo esta página. nece-sita leer las letras individual, sino reconocer patrones grupos letras que forman pala-bras frases. las construcciones estructuradas son grupos lógicos que permiten lector reco-nocer elementos procedimiento módulo, vez leer diseño código línea por línea. comprensión mejora cuando encuentran patrones lógicos que fácil reconocer. con tan sólo las tres construcciones estructuradas posible diseñar implantar cualquier programa, sin importar área aplicación complejidad técnica. sin embargo, debe notarse que empleo dogmático con frecuencia ocasiona dificultades prácticas. sección .. estudia esto con más detalles. .. notación gráfica diseño “una imagen vale más que mil palabras”, pero importante saber qué imagen trata cuáles serían las mil palabras. hay duda que herramientas gráficas, como diagrama uml actividades diagrama flujo, constituyen patrones gráficos útiles que ilustran -cilmente detalles procedimiento. obstante, hace mal uso las herramientas gráfi-cas, surge una imagen equivocada que conduce software equivocado. diagrama actividades permite representar secuencia, condición repetición —todos los elementos que consta programación estructurada— descendiente diseño gráfico anterior (que todavía utiliza mucho) llamado diagrama flujo. como cualquier diagrama actividades, flujo muy simple. emplea rectángulo para indicar paso procesamiento. rombo representa una condición lógica las flechas indican flujo del control. figura . ilustra tres construcciones estructuradas. secuencia representa como dos cajas procesamiento conectadas por una línea (flecha) control. condición, también llamada -entonces- otro caso, ilustra como rombo decisión que, estado “verdadero”, hace que ocurra parte del entonces, estado “falso”, invoca procesamiento parte otro caso. repetición representa con uso dos formas ligeramente distintas. las pruebas hacer mientras, prueban una condición ejecutan repetida- mente lazo tareas mientras condición sea verdadera. parte repetir hasta primero ejecuta lazo tarea después prueba una condición repite tarea hasta que condi-ción vuelve falsa. construcción selección ( caso seleccionar) que aprecia figura realidad una extensión cláusula -entonces- otro caso . parámetro somete prueba por medio decisiones sucesivas hasta que ocurre una condición “verdadero” ejecuta procesamiento por trayectoria parte caso. general, uso dogmático construcciones estructuradas introduce ineficiencia cuando requiere una salida grupo lazos condiciones anidadas. más importante aún, complicación adicional todas las pruebas lógicas ruta salida llega oscurecer (-).indd (-).indd // ::// :: parte dos modelado flujo control del software, aumenta posibilidad errores tiene efecto negativo legibilidad facilidad dar mantenimiento software. ¿qué hacer? hay dos opciones: ) rediseñar representación del procedimiento modo que - quiera que “rama salida” esté una ubicación anidada flujo del control ) violar forma controlada las construcciones estructuradas; decir, diseñar una rama restringida fuera del flujo anidado. obvio que opción enfoque ideal, pero consigue sin violar espíritu programación estructurada. .. notación del diseño tabular muchas aplicaciones software, requiere módulo para evaluar una combinación compleja combinaciones condiciones seleccionar acciones apropiadas con base -tas. las tablas decisión [hur] proporcionan una notación que traduce las acciones condi-ciones (descritas narración del procesamiento caso uso) una forma tabular. difí-cil malinterpretar tabla incluso puede usar como entrada legible por una máquina que use algoritmo dirigido por aquélla. figura . muestra organización tabla decisión. tabla divide cuatro secciones. cuadrante superior izquierdo contiene lista todas las condiciones. inferior izquierdo contiene lista condiciones que son posibles con base combinaciones las condiciones. los cuadrantes del lado derecho forman una matriz que indica combinacio-nes las condiciones las correspondientes acciones que ocurrirán para una combinación específica éstas. por tanto, cada columna matriz interpreta como regla procesa- miento. para desarrollar una tabla decisión emplean los pasos siguientes: . enlistar todas las acciones asociadas con procedimiento ( componente) específico. . enlistar todas las condiciones ( decisiones tomadas) durante ejecución del procedi- miento. . asociar conjuntos específicos condiciones con acciones específicas, con elimina- ción las combinaciones con condiciones imposibles; manera alternativa, desa- rrollar toda posible permutación las condiciones. . definir reglas indicando qué acciones suceden para conjunto dado condiciones. para ilustrar uso una tabla decisión, considere siguiente extracto caso uso informal propuesto para sistema del taller impresión:primera tarea siguientetarea secuencia seleccióncondición -entonces- otro caso (-then-else) repeticiónparte “” parte “entonces” caso condicionalparte del caso tvv vhacer mientras ( while)repetir hasta (repeat until)figura . construcciones los diagramas flujo úsese una tabla decisión cuando dentro componente halle conjunto complejo condiciones acciones.consejo ¿cómo elaboro una tabla decisión?? (-).indd (-).indd // ::// :: diseño nivel componentes definen tres tipos clientes: regular, plateado dorado (que asignan acuerdo con cantidad negocios que realice cliente con taller impresión periodo meses). cliente regular recibe tarifas normales por impresión entrega. uno plateado obtiene descuento por ciento sobre todas sus compras colocado por delante todos los clientes regulares fila trabajos. cliente dorado recibe por ciento descuento sobre los precios lista puesto adelante los clientes regulares los plateados fila trabajos. además los descuentos anteriores, aplica descuento especial porcentaje cualquier cliente según criterio administración. figura . ilustra una representación tabla decisión del caso uso anterior. cada una las seis reglas indica una las seis condiciones posibles. por regla general, tabla decisión usa manera eficaz para dar otra notación diseño orientado procedimiento. .. lenguaje diseño del programa lenguaje diseño del programa (ldp), también llamado castellano estructurado seudocódigo, incorpora estructura lógica lenguaje programación expresividad forma libre lenguaje natural (como castellano). incrusta texto narración ( castellano) una sintaxis programación parecida idioma. para mejorar aplicación del ldp uti-lizan herramientas automatizadas (ver [cai]). una sintaxis básica ldp debe incluir construcciones para: definir los componentes, des- cribir interfaz, hacer declaración los datos, estructurar bloques, hacer construcciones condicionales, repetición entrada salida (/). debe observarse que ldp amplía fin que incluya palabras clave para hacer procesamiento tareas múltiples concu-rrentes, manejar interrupciones, sincronía entre procesos muchas otras características. -seño aplicación para que utilizará ldp que debe dictar forma final para lenguaje del diseño. ejemplo siguiente presenta formato semántica algunas estas construcciones ldp. para ilustrar uso del ldp, piense diseño orientado procedimiento para función seguridad casasegura que estudió secciones anteriores. sistema vigila alarmas incendio, humo, robo, inundación temperatura (por ejemplo, sistema calefacción falla cuando propietario está fuera durante invierno), genera sonido alarma hace una llamada servicio vigilancia con generación mensaje voz sintetizada. recuerde que ldp lenguaje programación. adapta según requiera sin preocuparse por errores sintaxis. sin embargo, diseño para software vigilancia ten-condiciones cliente regular cliente plateadocliente doradodescuento especial acciones sin descuentoaplicar % descuento aplicar % descuento aplicar porcentaje adicional descuentot ftt . nomenclatura una tabla decisión (-).indd (-).indd // ::// :: parte dos modelado dría que revisarse (¿ algún problema lector?) mejorarse más para poder escribir código. siguiente ldp muestra elaboración del diseño del procedimiento para una versión tem- prana componente administración una alarma. componente administraralarma; objetivo este componente administrar los interruptores del panel control las entradas desde los sensores por tipo, actuar cualquier condición alarma que encuentre. establecer valores inicio para estadodelsistema (valor devuelto), todos los grupos datos inician todos los puertos del sistema reinician todo hardwareverificar los interruptoresdelpaneldecontrol (ipc) ipc = “probar” entonces invocar que alarma coloque “” ipc = “alarmaapagada” entonces invocar que alarma coloque “off” ipc = “nuevovalorasignado” entonces invocar entradadeltecladosi ipc = “alarmacontraroboapagada” invocar desactivaralarma;prestablecido para ipc = ninguno reiniciar todos los valordeseñal interruptoreshacer para todos los sensores invocar procedimiento verificarsensor con devolución valordeseñalsi valordeseñal asignar [tipodealarma] entonces mensajetelefónico = mensaje [tipodealarma] iniciar sonidodealarma “” para segundosdetiempo alarmainiciar estado del sistema = “condicióndealarma”comienzapar invocar procedimiento alarma con “”, segundosdetiempo alarma;invocar procedimiento teléfono con tipodealarma, númerotelefónico terminapar otro caso salta terminasi terminahacerpara termina administraralarma observe que diseñador del componente administraralarma usó construcción comienza- par… terminapar , que especifica bloque paralelo. todas las tareas especificadas dentro - mienzapar ejecutan paralelo. este caso, consideran los detalles implanta- ción. . esarrollo basado componentes contexto ingeniería software, reutilización una idea tanto antigua como nueva. los programadores han reutilizado ideas, abstracciones procesos desde los primeros días computación, pero enfoque inicial que aplicaban era hoc. hoy día, los siste- mas basados computadoras, complejos alta calidad, deben elaborarse plazos muy cortos demandan enfoque más organizado reutilización. nivel detalle representado por ldp define localmente. algunas personas prefieren descripción más natural orientada lenguaje, mientras que otras escogen algo más cercano código. (-).indd (-).indd // ::// :: diseño nivel componentes ingeniería software basada componentes (isbc) proceso que pone énfasis diseño construcción sistemas basados computadora que emplean “componentes” reutilizables software. clements [cle] describe isbc del modo siguiente: isbc adopta filosofía “compra, hagas” propuesta por fred brooks otros. del mismo modo que las subrutinas los primeros tiempos liberaron programador pensar los detalles, isbc traslada énfasis programación combinación sistemas software. implantación dado paso integración como aspecto importante. pero surgen varias preguntas. ¿ posible construir sistemas complejos con ensamble componentes reutilizables software procedentes catálogo? ¿ logra esto forma eficaz cuanto costo tiempo? ¿pueden establecerse incentivos apropiados que estimulen los ingenieros software reutilizar, más que reinventar? ¿ dirección está dispuesta incurrir los gastos adicionales asociados creación componentes software reutili-zables? ¿ posible crear biblioteca componentes necesarios para conseguir reutiliza-ción forma tal que sea accesible quienes los necesitan? ¿quienes necesitan los componen-tes que existen pueden encontrarlos? cada vez más, respuesta estas preguntas “”. resto esta sección estudian algunos aspectos que deben tomarse cuenta para hacer que isbc tenga éxito una -ganización ingeniería software. .. ingeniería del dominio objetivo ingeniería del dominio identificar, construir, catalogar diseminar con-junto componentes software que sean aplicables software existente del futuro dominio particular aplicaciones. meta general establecer mecanismos que permitan que los ingenieros software compartan dichos componentes —los reutilicen— cuando traba-jen sistemas nuevos existentes. ingeniería del dominio incluye tres actividades prin-cipales: análisis, construcción diseminación. enfoque general del análisis del dominio caracteriza con frecuencia dentro del contexto ingeniería software orientada objetos. los pasos este proceso definen como sigue: . definir dominio que investigar. . clasificar los aspectos extraídos del dominio. . reunir una muestra representativa aplicaciones dominio. . analizar cada aplicación muestra definir clases análisis. . desarrollar modelo los requerimientos para las clases. importante observar que análisis del dominio aplicable cualquier paradigma -geniería software aplica tanto desarrollo con vencional como orientado objetos. .. calificación, adaptación combinación los componentes ingeniería del dominio genera biblioteca componentes reutilizables que requieren para práctica ingeniería software basada componentes. algunos estos compo-nentes reutilizables desarrollan propia empresa, mientras que otros provienen apli-caciones existentes otros más adquieren terceras personas. desafortunadamente, existencia componentes reutilizables garantiza que éstos integren con facilidad eficacia arquitectura escogida para una nueva aplicación. por cita: “ ingeniería del dominio trata encontrar aspectos común los sistemas fin identifi-car los componentes aplicables muchos ellos…” paul clements capítulo mencionan géneros arquitectónicos que identifican dominios específicos aplicación. proceso análisis que estudia esta sección centra los componentes reutilizables. sin embargo, análisis sistemas con componentes comerciales separados (ccs) completos (por ejemplo, aplicaciones comercio electrónico automatización fuerza ventas) también forma parte del análisis del dominio.consejo (-).indd (-).indd // ::// :: parte dos modelado esta razón que cuando propone empleo componente aplica una secuencia acciones desarrollo basadas componentes. calificación componentes. calificación componentes garantiza que compo- nente candidato ejecute función requerida, “encaje” forma adecuada estilo arquitec- tónico (véase capítulo ) especificado para sistema tenga las características calidad (rendimiento, confiabilidad, usabilidad) que requieren para aplicación. descripción interfaz proporciona información útil sobre operación uso componente software , pero toda que requiere para determinar componente propuesto verdad capaz reutilizarse con eficacia una nueva aplicación. entre los muchos factores que consideran durante calificación componente encuentran los que mencionan continuación [bro]: • aplicación programación interfaz (api). • herramientas desarrollo integración requeridas por componente. • requerimientos durante puesta marcha, incluidos uso recursos (como memoria almacenamiento), sincronía velocidad protocolo redes. • requerimientos servicio, incluidos interfaces del sistema operativo apoyo otros componentes. • características seguridad, incluidos controles acceso protocolo autentifica- ción. • suposiciones incrustadas diseño, incluido empleo algoritmos, numéricos , específicos. • manejo excepciones. cada uno estos factores relativamente fácil evaluar cuando proponen componentes reutilizables desarrollados propia empresa. durante desarrollo componente aplican buenas prácticas ingeniería software, posible responder las preguntas que están implícitas lista. sin embargo, mucho más difícil determinar los trabajos internos los componentes comerciales separados (ccs) los adquiridos terceras personas porque única información disponible especificación interfaz misma. adaptación componentes. situación ideal, ingeniería del dominio crea una - blioteca componentes que integra con facilidad arquitectura una aplicación. implicación una “integración fácil” que ) han implementado métodos consistentes administración recursos para todos los componentes que hay biblioteca; ) para todos los componentes existen actividades comunes, tales como administración datos, ) han implementado manera consistente interfaces dentro arquitectura con ambiente externo. realidad, incluso componente sido calificado para uso dentro una aplicación arquitectura, surgen conflictos una más las áreas mencionadas. para evitar estos conflictos, ocasiones emplea una técnica adaptación llamada voltura componentes [bro]. cuando equipo software tiene acceso total diseño código interno com-ponente (que con frecuencia caso menos que utilicen componentes ccs fuente abierta), aplica envoltura caja blanca. como contraparte las pruebas del software (véase capítulo ), envoltura caja blanca estudia los detalles del procesamiento interno del componente hace modificaciones nivel código para eliminar cualquier conflicto. aplica envoltura caja gris cuando biblioteca componentes proporciona lenguaje extensión del componente api que permite que los conflictos eliminen anulen. envoltura caja negra requiere introducción procesamiento previo posterior inter-faz del componente para eliminar anular los conflictos. debe determinarse justifica ¿cuáles son los factores que consideran durante calificación componentes?? además evaluar justifica costo adaptación para reutilización, también debe analizarse posible lograr funcionalidad que requiere manera rentable.consejo (-).indd (-).indd // ::// :: diseño nivel componentes esfuerzo para envolver manera adecuada componente vez ello debe hacerse ingeniería componente especializado (diseñado para eliminar los conflictos que surjan). combinación componentes. tarea combinar componentes ensambla componen- tes calificados, adaptados con ingeniería necesaria para incluirse arquitectura estable- cida para una aplicación. para lograr esto, debe establecerse una infraestructura que ligue los componentes sistema operativo. infraestructura (por general una biblioteca com-ponentes especializados) pro vee modelo para coordinación componentes servicios específicos que permite que éstos coordinen entre ejecuten tareas comunes. como efecto potencial reutilización isbc industria del software enor- , varias compañías consorcios han propuesto estándares para software los compo-nentes. gao/atocs. grupo administración objetos publicó documento titulado - quitectura intercambio objetos comunes solicitados (gao/atocs). intercambio objetos solicitados (ios) proporciona varios servicios que permiten que los componentes reutilizables (objetos) comuniquen con otros componentes, sin importar ubicación dentro sistema. mco microsoft .net. microsoft desarrolló modelo componentes objetos (mco) que proporciona las especificaciones para uso componentes producidos por varios vendedores dentro campo aplicación que son compatibles con sistema operativo indows. desde punto vista aplicación, “ atención pone forma implementar [los objetos mco], sino hecho que objeto tiene una inter-faz que compatible con sistema que usa sistema componentes para comuni-carse con otros objetos mco” [har]. estructura .net microsoft incluye mco una biblioteca clases reutilizables que cubre una amplia variedad dominios aplicación. componentes javabeans sun. sistema componentes javabeans una infraes- tructura isbc, portátil independiente plataforma, desarrollada con uso del lenguaje programación java. sistema componentes javabeans incluye conjunto herramientas llamado kit desarrollo bean (kdb) que permite que los desarrolladores ) analicen forma que funcionan los beans (componentes) existentes; ) personali-cen comportamiento apariencia; ) establezcan mecanismos para coordinación comunicación; ) desarrollen beans especiales para uso una aplicación específica, ) prueben evalúen comportamiento bean. ninguno estos estándares domina industria. unque muchos desarrolladores han - tandarizado teniendo como modelo uno, probable que las organizaciones grandes soft-ware elijan empleo estándar con base las categorías plataformas aplicación que elijan. .. análisis diseño para reutilización aunque isbc promueve uso componentes software existentes, hay veces las que deben desarrollarse otros nuevos para integrarlos con ccs disponibles con otros propios. como estos nuevos componentes vuelven miembros biblioteca empresa com-ponentes reutilizables, debe hacerse ingeniería para reutilización. los conceptos diseño, tales como abstracción, ocultamiento, independencia funciones, refinamiento programación estructurada, así como los métodos orientados objeto, pruebas, greg olsen [ols] hace análisis excelente los esfuerzos pasados presentes industria para hacer isbc una realidad.webref dirección .omg.org encuentra información más reciente sobre arquitectura transacciones objetos comunes solicitados (gao/atocs). webref información más reciente sobre mco .net obtiene dirección msdn.microsoft.com/-/netframeworkdefault.aspx. webref información más reciente sobre javabeans obtiene java.sun.com/products/javabeans/docs/. (-).indd (-).indd // ::// :: parte dos modelado aseguramiento calidad del software (acs) métodos comprobación corrección (véase capítulo ), contribuyen creación componentes software reutilizables. esta subsección estudian aspectos específicos reutilización que son complementarios las prácticas sólidas ingeniería software. modelo requerimientos analiza para determinar qué elementos apuntan hacia com- ponentes reutilizables existentes. los elementos del modelo los requerimientos comparan con los componentes reutilizables proceso que ocasiones conoce como “ajuste especificaciones” [bel]. ajuste especificaciones señala hacia componente que existe que ajusta las necesidades aplicación cuestión, extrae compo-nente biblioteca reutilización (repositorio) emplea diseño nuevo sis-tema. posible encontrar componente (por ejemplo, hay coincidencia), crea uno nuevo. este punto —cuando comienza crear componente nuevo— donde debe considerarse diseño para reutilización (dpr). como dijo, dpr requiere que apliquen conceptos principios sólidos del diseño software (véase capítulo ). pero las características del dominio aplicación también -ben tomarse cuenta. binder [bin] sugiere varios aspectos clave que constituyen base del diseño para reutilización: datos estándar. dominio aplicación debe investigarse tienen que identificarse las estructuras datos globales estándar (como las archivos una base datos com-pleta). todos los componentes del diseño caracterizan para hacer uso estas estructu-ras datos estándar. protocolos interfaz estándar. deben establecerse tres niveles protocolos inter- faz: naturaleza las interfaces intramodulares, diseño las interfaces externas téc-nicas ( humanas) interfaz humano-computadora. plantillas programa. elige estilo arquitectónico (véase capítulo ) que sirve como plantilla para diseño arquitectura del nuevo software. una vez establecidos los datos estándar, interfaces plantillas del programa, tiene una -tructura cual crear diseño. los componentes nuevos que conforman ésta tienen una probabilidad mayor tener uso posterior. .. clasificación recuperación componentes considere una biblioteca universitaria grande. encuentran disponibles cientos miles libros, revistas otras fuentes información. pero para acceder dichas fuentes debe desarro-llarse esquema clasificación. para navegar este enorme volumen información, los bibliotecarios han definido esquema clasificación que incluye código biblioteca del congreso, palabras clave, nombres los autores otras entradas para índice. todos ellos permiten que usuario encuentre fácil rápidamente fuente que necesita. ahora, considere repositorio grande componentes que encuentran decenas miles componentes software reutilizables. pero, ¿cómo encuentra que necesita? tratar responder esta pregunta surge otra: ¿cómo describimos los componentes soft-ware términos ambiguos clasificables? éstas son preguntas difíciles para las que todavía hay una respuesta definitiva. esta sección estudian las direcciones actuales que permi-tirán que los ingenieros software naveguen través las bibliotecas reutilización. componente software reutilizable puede describirse muchas formas, pero des- cripción ideal incluye que tracz [tra] llama modelo : concepto, contenido contexto. concepto componente software “ descripción que hace componente” general, las preparaciones del dpr deben tomarse como parte ingeniería del dominio. dpr muy difícil hay que hacer las interfaces integrar los componentes con sistemas heredados con sistemas múltiples cuya arquitectura protocolos interfaz son incongruentes.consejo (-).indd (-).indd // ::// :: diseño nivel componentes [whi]. describe por completo interfaz componente identifica semántica, repre- sentada contexto las condiciones previas posteriores. concepto debe comunicar objetivo del componente. contenido componente describe cómo lleva cabo con- cepto. esencia, contenido información que queda oculta los usuarios casuales que sólo necesitan conocer aquellos que pretenden modificar probar componente. contexto coloca componente software reutilizable dominio aplicabilidad. decir, -pecificar las características conceptuales, operativas implantación, contexto permite que ingeniero software encuentre componente apropiado para que cumplan los reque-rimientos aplicación. concepto, contenido contexto deben traducirse esquema concreto especificación para que tengan uso práctico. han escrito decenas textos artículos sobre esquemas clasificación para componentes software reutilizables (por ejemplo, consulte [cec] panorama las tendencias actuales). clasificación permite encontrar recuperar componentes que son candidatos reutili- zación, pero debe existir ambiente propicio para integrarlos con eficacia. éste tiene las -racterísticas siguientes: • una base datos capaz almacenar componentes software información clasificación necesaria para recuperarlos. • sistema administración biblioteca que acceso base datos. • sistema recuperación componentes software (por ejemplo, agente solicitud objetos) que permita que aplicación cliente recupere componentes servicios del servidor biblioteca. • herramientas isbc que apoyen integración componentes reutilizados diseño implantación nuevos. cada una estas funciones interactúa con los confines una biblioteca reutilización halla incrustada ella. biblioteca reutilización elemento repositorio mayor software (véase capítulo ) brinda herramientas para almacenamiento componentes software, así ¿cuáles son las características clave ambiente reutilización componentes?? objetivo: ayudar modelar, diseñar, revisar integrar los componentes software como parte sistema mayor. mecánica: las mecánicas las herramientas varían. general, las herramientas isbc ayudan una más las siguientes capacidades: especificar modelar arquitectura del software, investigar seleccionar los componentes software disponibles; inte-grar los componentes. herramientas representativas componentsource ( proporciona una variedad amplia componentes ( herramientas) soft-ware ccs apoyada dentro muchos estándares componentes distintos. component manager, desarrollado por flashline ( com), “ una aplicación que permite, promueve mide reutili-zación componentes software”. select component factory, desarrollado por select business solutions ( “ conjunto integrado productos para diseñar software, revisar diseño, administrar servicios componentes, manejar requerimientos generar código”. software through pictures-acd, distribuido por aonix (www. aonix.com), permite modelado exhaustivo con uso uml para modelo omg orientado arquitectura, enfoque isbc abierto neutral para vendedor.herramientas software isbc las herramientas mencionadas aquí son obligatorias, sólo son una muestra las que hay esta categoría. mayoría casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolla- dores. (-).indd (-).indd // ::// :: parte dos modelado como una amplia variedad productos finales reutilizables (especificaciones, diseños, patro- nes, estructuras, fragmentos código, casos prueba, guías del usuario, etc.). biblioteca incluye una base datos las herramientas necesarias para hacer consultas recuperar los componentes. esquema clasificación componentes base las consultas -blioteca. frecuente que las consultas clasifiquen con empleo del elemento contexto del modelo mencionado. una consulta inicial como resultado una lista grande compo-nentes candidatos, afina consulta para depurar lista. después extrae información concepto contenido (una vez encontrados los componentes candidatos) que ayuden -leccionar componente apropiado. . esumen proceso diseño nivel componentes incluye una secuencia actividades que -duce poco poco nivel abstracción con que representa software. diseño nivel componentes ilustra definitiva software nivel abstracción cercano código. posible adoptar tres puntos vista diferentes nivel diseño, función - turaleza del software que desarrollar. enfoque orientado objetos centra elaboración clases diseño que provienen tanto del dominio del problema como -fraestructura. punto vista tradicional mejora tres tipos diferentes componentes -dulos: los control, los del dominio del problema los infraestructura. ambos casos aplican los principios conceptos básicos del diseño que llevan software alta calidad. cuando considera diseño nivel componentes desde punto vista del proceso, llega componentes software reutilizables patrones diseño que son elementos cruciales ingeniería software basada componentes. conforme elaboran las clases, varios principios conceptos importantes guían diseña- dor. las ideas agrupadas principio abierto-cerrado principio inversión dependencia, así como conceptos tales como acoplamiento cohesión, guían ingeniero software construcción componentes software susceptibles someterse prueba, implantarse recibir mantenimiento. para hacer diseño nivel componentes este contexto, elaboran las clases especificando detalles mensajería, identificando las interfaces apropiadas, elaborando atributos definiendo estructuras datos que las imple-menten, describiendo flujo del procesamiento dentro cada operación representando comportamiento nivel clase componente. una actividad esencial cada caso diseño iterativo (rediseñar). diseño tradicional nivel componentes requiere representación estructuras datos, interfaces algoritmos para módulo programa con detalle suficiente para guiar generación del código fuente del lenguaje programación. fin lograr esto, diseñador usa una varias notaciones diseño que representan los detalles nivel componente formato gráfico, tabular basado texto. diseño nivel componentes para webapps considera tanto contenido como funcionalidad tal como entregada por sistema basado web. diseño del contenido nivel componentes centra objetos contenido manera que empacan para presentación una webapp usuario final. diseño funcional para las webapps centra funciones procesamiento que manipulan contenido, realizan cálculos, consultan acceden una base datos establecen interfaces con otros sistemas. aplican todos los principios lineamientos del diseño nivel componentes. programación estructurada una filosofía diseño orientado procedimiento que - mita número tipo construcciones lógicas usadas para representar los detalles algorítmi-webref dirección encuentra conjunto exhaustivo recursos isbc. (-).indd (-).indd // ::// :: diseño nivel componentes cos. objetivo programación estructurada auxiliar diseñador definición - goritmos que sean menos complejos por ello más fáciles leer, probar mantener. ingeniería software basada componentes identifica, construye, cataloga disemina conjunto componentes software dominio particular aplicación. después, -tos componentes califican, adaptan integran para usarlos sistema nuevo. los com-ponentes reutilizables deben diseñarse dentro ambiente que establezca para cada domi-nio aplicación estructuras datos estándar, protocolos interfaz arquitecturas programa. problemas puntos por evaluar .. ocasiones resulta difícil definir término componente. primero una definición general luego otras más explícitas para software orientado objetos para tradicional. por último, elija tres lenguajes programación con los que esté familiarizado ilustre manera que cada uno define compo-nente. .. ¿por qué son necesarios los componentes control software tradicional por qué general requieren orientado objetos?.. describa con sus propias palabras pac. ¿por qué importante crear abstracciones que sirvan como interfaz entre los componentes?.. describa pid con sus propias palabras. ¿qué pasaría diseñador dependiera demasiado las concreciones?.. seleccione tres componentes que haya desarrollado recientemente evalúe los tipos cohesión que presente cada uno. tuviera que definir beneficio principal cohesión, ¿cuál sería?.. elija tres componentes que haya elaborado hace poco evalúe los tipos acoplamiento que tenga cada uno. definiera principal beneficio del poco acoplamiento, ¿qué diría?.. ¿ razonable decir que los componentes del dominio del problema nunca deben tener acoplamiento externo? está acuerdo, ¿qué tipos componente tendrían acoplamiento externo?.. desarrolle ) una clase diseño elaborada, ) descripciones interfaz, ) diagrama activida- des para una las operaciones dentro clase diseño ) diagrama estado detallado para una las clases casasegura que estudiaron los capítulos anteriores. .. ¿son mismo refinamiento stepwise rediseño? así, ¿ qué difieren? .. ¿qué componente webapp? .. seleccione una parte pequeña programa existente ( líneas código). separe las construcciones programación estructurada con cuadros que dibuje alrededor ellas código fuente. ¿ extracto programa tiene construcciones que violan filosofía programación estructurada? así, rediseñe código para que apegue las construcciones programación estructurada. así, ¿qué observa los cuadros que dibujó? .. todos los lenguajes modernos programación implementan las construcciones programación estructurada. ejemplos tres lenguajes programación... seleccione componente codificado pequeño represéntelo con ) diagrama actividades, ) diagrama flujo, ) una tabla decisión ) ldp... ¿por qué importante “lotificación” proceso revisión del diseño nivel compo- nentes? lecturas adicionales fuentes información los últimos años han publicado muchos libros sobre desarrollo basado componentes acerca reutilización. apperly . (service- and component-based development, addison-wesley, ), heine-man councill (component based software engineering , addison-wesley, ), brown (large scale compo- (-).indd (-).indd // ::// :: parte dos modelado nent-based development, prentice-hall, ), allen (realizing -business with components, addison-wesley, ), herzum sims (business component factory, wiley, ), allen, frost yourdon (component-based development for enterprise systems: applying the select perspective, cambridge university press, ) cubren todos los aspectos importantes del proceso isbc. cheesman daniels (uml components, addison-wesley, ) estudian isbc con énfasis uml. gao . (testing and quality assurance for component-based software, artech house, ) gross (com- ponent-based software testing with uml, springer, ) estudian las pruebas aseguramiento cali-dad los sistemas basados componentes. los años recientes han sido publicadas decenas libros que describen estándares industria basados componentes. estas obras dirigen los trabajos internos los estándares, pero también consideran muchos temas importantes isbc. trabajo linger, mills witt (structured programming-theory and practice , addison-wesley, ) permanece como análisis definitivo del tema. texto contiene buen ldp también estudios detallados las ramificaciones programación estructurada. otros libros que centran diseño orientado procedimiento para sistemas tradicionales incluyen los robertson ( simple program design, . ., course technology, ), farrell ( guide programming logic and design, course technology, ), bentley (programming pearls, . ., addison-wesley, ) dahl (structured programming, academic press, ). son relativamente pocos los libros dedicados exclusivo diseño nivel componentes. - neral, los libros lenguajes programación están dirigidos diseño del procedimiento con cierto detalle, pero siempre contexto del lenguaje que trata libro. son cientos los títulos disponibles. internet hay una amplia variedad fuentes información sobre diseño nivel componentes. sitio web del libro, , existe una lista actualizada referencias red mundial que son relevantes para diseño nivel componentes. (-).indd (-).indd // ::// :: interfaz usuario conceptos clave accesibilidad . . . . . . . . . . . . análisis interfaz . . . . . consistente . . . . . . . . . . . diseño . . . . . . . . . . . . . . modelos . . . . . . . . . . . . . análisis tarea . . . . . . . del usuario . . . . . . . . . . . . . . . . . . . . . . . una interfaz para webapps. . . . . . . . . . . elaboración tarea . . . . del diseño. . . . . . ayuda . . . . . . . . . . . los comandos . . errores . . . . . . . . . . . . . . . . . . . lineamientos . . . . . . . . . . . . . . . . . . doradas . . . . . . . . . . respuesta . . . . . . . . . . . . . . . . . . . . ¿qué ? diseño interfaz usuario crea medio eficaz comunicación entre los seres humanos computadora. siguiendo conjunto principios diseño interfaz, diseño identifica los objetos acciones ésta luego crea una plantilla pantalla que constituye base del prototipo interfaz usuario. ¿quién hace? ingeniero software diseña inter- faz usuario con aplicación proceso iterativo que sigue principios diseño predefinidos. ¿por qué importante? software difícil usar, fuerza usuario cometer errores, frustra sus esfuer-zos para alcanzar las metas, entonces gustará, sin que importe poder computacional que tenga, conteni- que entregue las funciones que ofrezca. interfaz tiene que estar bien hecha porque moldea percepción que usuario tiene del software. ¿cuáles son los pasos? diseño interfaz usua- rio comienza con identificación los requerimientos del usuario, tarea ambiente. una vez identificadas las tareas del usuario, crean analizan los escenarios para éste define conjunto objetos acciones interfaz. esto forma base para crear una plantilla pantalla que ilustra diseño gráfico coloca-ción los iconos, definición textos descriptivos, especificación títulos las ventanas, especifica-ción aspectos mayores menores del menú. con empleo herramientas, hace prototipo, imple-menta definitiva modelo del diseño evalúa calidad del resultado. ¿cuál producto final? crean los escenarios del usuario generan los formatos pantalla. -sarrolla prototipo interfaz modifica mane- iterativa. ¿cómo aseguro que hice bien? los usuarios “prueban” prototipo interfaz retroalimenta-ción esta prueba utiliza para siguiente modifi-cación iterativa del prototipo. una mirada rápidavivimos mundo productos alta tecnología, virtualmente todos ellos —elec- trónica para consumidor, equipo industrial, sistemas corporativos, sistemas militares, software computadoras personales webapps— requieren interacción humana. producto alcanzar éxito, debe tener buena usabilidad: medición cualitativa facili- dad eficiencia con que humano emplea las funciones características que ofrece producto alta tecnología. usabilidad importa, sea que una interfaz haya sido diseñada para reproductor música digital para sistema control armas avión combate. los mecanismos interfaz están bien diseñados, usuario desliza por interacción ritmo suave que hace que trabajo realice sin esfuerzo. pero interfaz fue mal concebida, usuario avanza retrocede, resultado final frustración poca eficiencia trabajo. durante las tres primeras décadas era computación, usabilidad era pre- ocupación dominante quienes elaboraban software. libro clásico sobre diseño, donald norman [nor] afirmaba que era tiempo cambiar actitud: para producir tecnología que adapte los seres humanos, necesario estudiar éstos. pero actualidad tendemos estudiar sólo primera. resultado que exige las personas que adapten tecnología. tiempo que esta tendencia revierta, momento que tecno-logía adapte las personas. medida que los tecnólogos estudiaban interacción humana, surgieron dos aspectos domi- nantes. primero fue que identificaron reglas doradas (que estudian sección .). éstas aplican toda interacción humana con productos tecnología. segundo fue que definió conjunto mecanismos interacción que permitieron los diseñadores software construir sistemas que implantaban forma correcta las reglas doradas. esos meca- (-).indd (-).indd // ::// :: parte dos modelado . reglas doradas libro sobre diseño interfaz, theo mandel [man] acuñó tres reglas doradas: . dejar control usuario. . reducir carga memoria del usuario. . hacer que interfaz sea consistente. realidad, estas reglas doradas constituyen base conjunto principios diseño interfaz usuario que guían este aspecto tan importante del diseño del software. .. dejar control usuario durante una sesión para recabar los requerimientos nuevo gran sistema información, preguntó una usuaria clave acerca los atributos interfaz gráfica basada venta-nas. “ que realmente gustaría”, respondió con solemnidad, “ sistema que lea mente. que sepa que quiero hacer antes que necesite hacerlo que sea fácil para obtener eso que quiero. eso todo, sólo eso”. primera reacción fue afirmar con cabeza sonreír, pero detuve momento. había absolutamente nada descabellado solicitud usuaria. quería sistema que reaccionara sus necesidades ayudara para que las cosas hicieran. deseaba controlar computadora, que ésta controlara ella. mayor parte limitaciones restricciones que impone diseñador pretenden simplifi- car modo interacción. pero, ¿para quién? como diseñador, tal vez sienta tentado introducir restricciones limitantes que simpli- fiquen implantación interfaz. resultado puede ser una interfaz fácil construir, pero que sea frustrante utilizar. mandel [man] define cierto número principios diseño que permiten que usuario tenga control: definir modos interacción manera que obligue usuario realizar accio- nes innecesarias deseadas. modo interacción estado actual interfaz. por ejemplo, menú procesador textos selecciona revisar ortogr afía, soft- ware pasa modo revisión ortografía. hay razón para obligar usuario perma-necer este modo acaso desea hacer una pequeña edición del texto. usuario debe poder entrar salir del modo con poco ningún esfuerzo. dar una interacción flexible. debido que diferentes usuarios tienen distintas preferencias para interacción, debe darse posibilidad elegir . por ejemplo, software debe permitir que usuario interactúe por medio comandos introducidos con teclado, ratón, una pluma digitalizadora, una pantalla sensible tacto mecanismo reconocimiento voz. pero todas las acciones son accesibles través cualquier mecanismo interacción. por ejemplo, piénsese dificultad usar comandos del teclado ( entradas con voz) para hacer dibujo complicado.nismos interacción, llamados manera colectiva interfaz gráfica del usuario (gui), elimina- ron algunos los problemas más notables asociados con las interfaces humanas. pero aun “mundo windows”, todos hemos encontrado interfaces usuario que son difíciles apren-der usar, que son confusas van contra intuición, que perdonan , muchos casos, resultan frustrantes por completo. obstante, alguien dedicó tiempo energía elaboración estas interfaces, probable que constructor haya creado dichos problemas con toda intención. cita: “ mejor diseñar experiencia del usuario que corregirla.” jon meads (-).indd (-).indd // ::// :: diseño interfaz usuario permitir que interacción del usuario sea interrumpible también reversible. usuario debe poder suspender secuencia trabajo (aun cuando consista una secuencia acciones) para hacer otra cosa (sin perder trabajo realizado hasta ese momento). ambién debe poder “deshacer” cualquier acción. facilitar interacción medida que aumenta habilidad permitir que aquélla personalice. frecuente que los usuarios realicen misma secuencia interacciones forma repetida. benéfico diseñar mecanismo “macros” que permita que usuario avanzado personalice interfaz para facilitar interacción. ocultar los tecnicismos internos usuario ocasional. interfaz usuario debe intro- ducirlo mundo virtual aplicación. usuario debe tener que preocuparse del sistema operativo, las funciones administración archivos ninguna otra tecnología computación secreta. esencia, interfaz debe requerir que usuario interactúe nivel “interno” máquina (nunca debería tener que escribir comandos del sistema operativo desde una aplicación software). diseñar interacción directa con objetos que aparezcan pantalla. usuario tiene sensación control cuando puede manipular los objetos que necesitan fin ejecutar trabajo misma forma que haría objeto fuera algo físico. por ejem-plo, una interfaz aplicación que permita “estirar” objeto (modificar tamaño) una implementación manipulación directa. .. reducir necesidad que usuario memorice entre más cosas tenga que recordar usuario, más fácil será que cometa errores interactuar con sistema. por esto que una interfaz usuario bien diseñada sobrecarga memoria del usuario. siempre que sea posible, sistema debe “recordar” información pertinente ayudar usuario con escenario interacción que ayude recordar. mandel [man] define los siguientes principios diseño que permiten que una interfaz reduzca necesidad que usuario memorice: reducir demanda memoria corto plazo. cuando los usuarios involucran tareas complejas, demanda memoria corto plazo significativa. interfaz debe dise- ñarse para disminuir necesidad recordar acciones, entradas resultados del pasado. esto logra dando claves visuales que permitan usuario reconocer acciones anteriores, lugar que tenga que recordarlas. hacer que preestablecido sea significativo. que principio por preestablecido debe tener sentido para usuario promedio, pero éste debería poder especificar sus preferen-cias individuales. sin embargo, debe disponerse opción “reiniciar” para restablecer los valores originales. definir atajos que sean intuitivos. cuando utilice nemotecnia para ejecutar una función del sistema (como secuencia ctrl- para vocar función buscar), debe estar ligada con acción, modo que sea fácil recordar (por ejemplo, con primera letra tarea que realizar). distribución visual interfaz debe basarse una metáfora del mundo real. por ejemplo, sistema pagos debe usar una metáfora chequera talonario que guíe usua-rio través del proceso pago. esto permite que usuario base claves visuales que comprende bien, vez tener que memorizar una secuencia críptica interacciones. revelar información manera progresiva. interfaz debe estar organizada manera jerárquica. decir , información acerca una tarea, objeto comportamiento debe presen-cita: “siempre deseé que compu- tadora fuera tan fácil usar como teléfono. deseo vuelto realidad. cómo utiliza teléfono.” bjarne stronstrup (iniciador // ) (-).indd (-).indd // ::// :: parte dos modelado tarse primero nivel generalización elevado. después que con ratón usuario manifieste interés, deben darse más detalles. ejemplo, común para muchas aplicaciones procesamiento textos, función subrayar. función una varias menú estilo del texto . obstante, enlista cada una las herramientas para subrayar. usuario debe hacer clic opción subrayar; después presentan todas las opciones para esta función (una raya, doble raya, línea punteada, etcétera). escena: cubículo vinod, cuando comienza diseño interfaz usuario. participantes: vinod jamie, miembros del equipo ingeniería software casasegura. conversación:jamie: estado pensando interfaz función vigilan- cia. vinod (sonríe): bueno pensar.jamie: creo que tal vez podamos simplificar algunas cosas.vinod: ¿qué quieres decir?jamie: bueno, qué tal eliminamos plano casa. bueno, pero requerir mucho esfuerzo desarrollo. vez eso, puede pedirse usuario que especifique cámara que quiere ver que luego despliegue video una ventana. vinod: ¿cómo recordaría propietario cuántas cámaras hay dónde están? jamie (algo irritado): propietario; debe saberlo.vinod: ¿ así?jamie: debería.vinod: eso que estamos discutiendo… ¿qué pasa olvida? jamie: bueno, podríamos darle una lista cámaras sus ubica- ciones. vinod: posible, pero, ¿por qué debería pedir una lista?jamie: bueno, damos lista pida .vinod: eso está mejor. menos tendrá que recordar cosas que podemos dar. jamie (piensa unos instantes): pero, ¿ gusta plano casa? vinod: mmm.jamie: ¿cuál piensas que agrade más mercadotecnia?vinod: bromeas, ¿verdad?jamie: .vinod: mmm… plano… adoran las características bonitas los productos… les importa cuál más fácil elaborar. jamie (suspira): bien, quizá hagamos ambos prototipos.vinod: buena idea… así dejamos que cliente decida.casasegura violación regla dorada interfaz usuario .. hacer consistente interfaz interfaz debe presentar obtener información forma consistente. esto implica: ) que toda información organice acuerdo con reglas diseño que respeten todas las panta-llas desplegadas, ) que los mecanismos entrada limiten conjunto pequeño usado forma consistente toda aplicación, ) que los mecanismos para pasar una tarea otra definan implementen modo consistente. mandel [man] define varios principios diseño que ayudan que interfaz tenga consistencia: permita que usuario coloque tarea curso contexto significativo. muchas interfaces implementan capas complejas interacciones con decenas imágenes pan- talla. importante dar indicadores (títulos las ventanas, iconos gráficos, código colores consistente , etc.) que permitan usuario conocer contexto del trabajo curso. además, debe poder determinar dónde viene qué alternativas hay para hacer transición una nueva tarea. mantener consistencia toda familia aplicaciones. todas las aplicaciones ( productos) que hay grupo deben implementar las mismas reglas diseño fin que mantenga consistencia toda interacción.cita: “las cosas que parezcan dife- rentes deben actuar forma diferente. las cosas que parez-can iguales deben actuar igual.” larry marine (-).indd (-).indd // ::// :: diseño interfaz usuario los modelos interactivos anteriores han creado expectativas usuario, haga cambios menos que haya una razón ineludible para ello. una vez que una secuen- cia interactiva particular con vertido estándar (como uso alt- para guardar archivo), usuario espera toda aplicación que emplea. cambio (como utilizar alt- para invocar función modificar escala) generará confusión. los principios diseño interfaz analizados esta sección las anteriores dan una guía básica. las que siguen, lector aprenderá acerca del proceso diseño interfaz . artículo útil sobre usabilidad, larry constantine [con] plantea una pregunta significativa sobre tema: “ definitiva, ¿qué quieren los usuarios?” responde así: que los usuarios desean son buenas herramientas. todos los sistemas software, desde sistemas operativos lenguajes hasta aplicaciones entrada datos apoyo toma decisiones, sólo son herramientas. los usuarios finales esperan mismo que nosotros las herramientas que usamos. quie-ren sistemas fáciles aprender que les ayuden hacer trabajo. quieren software que los haga más lentos, que tenga trucos los confunda; eso significa que sea más fácil cometer errores más difícil terminar trabajo. constantine afirma que usabilidad proviene estética, mecanismos interacción avanzados interfaces inteligentes. vez eso, obtiene cuando arquitectura interfaz ajusta las necesidades las personas que emplearán. ilusorio llegar una definición formal usabilidad. donahue . [don] definen manera siguiente: “ usabilidad una medida cuán bien sistema cómputo […] facilita aprendizaje, ayuda quienes emplean recordar aprendido, reduce probabilidad cometer errores, les permite ser eficientes los deja satisfechos con sistema.” única forma determinar existe “usabilidad” sistema que construye evaluarla probarla. los usuarios interactúan con sistema responden las preguntas siguientes [con]:• ¿ sistema utilizable sin ayuda enseñanza continua? • ¿las reglas interacción ayudan usuario preparado tra- bajar con eficiencia? • ¿los mecanismos interacción hacen más flexibles medida que los usuarios conocen más? • ¿ adaptado sistema ambiente físico social que usará? • ¿ usuario está tanto del estado del sistema? ¿sabe todo momento dónde está? • ¿ interfaz está estructurada manera lógica consistente? • ¿los mecanismos, iconos procedimientos interacción son con- sistentes toda interfaz? • ¿ interacción prevé errores ayuda usuario corregirlos? • ¿ interfaz tolerante los errores que cometen? • ¿ sencilla interacción? cada una estas preguntas obtiene “” como respuesta, probable que haya logrado usabilidad. entre los muchos beneficios mensurables que obtienen sistema usable encuentran los siguientes [don]: mayores ventas más satisfacción del consumidor, ventaja competitiva, mejores evalua-ciones los medios, recomendaciones boca boca, menores costos apoyo, más productividad del usuario final, menos costos capacitación documentación, disminución probabilidad litigios por parte clientes insatisfechos.información usabilidad . nálisis diseño interfaz usuario proceso general análisis diseño interfaz usuario comienza con creación diferentes modelos del funcionamiento del sistema (según percibe desde fuera). empieza delineando las tareas orientadas usuario — computadora— que requieren fin obtener funcionamiento del sistema, para luego considerar los aspectos que aplican -dos los diseños interfaz. emplean herramientas para hacer prototipos implementar modelo del diseño, los usuarios finales evalúan calidad. .. análisis modelos del diseño interfaz cuando analiza diseña interfaz usuario, entran juego cuatro diferentes modelos. ingeniero ( encargado del software) establece modelo usuario, ingeniero soft-webref dirección encuentra una excelente fuente información acerca del diseño interfaz usuario. (-).indd (-).indd // ::// :: parte dos modelado ware crea modelo del diseño, usuario final desarrolla una imagen mental que frecuente- mente nombra modelo mental percepción del sistema, los implementadores del sistema crean modelo implementación. desafortunadamente, cada uno estos modelos difiere forma significativa. papel del diseñador interfaz conciliar estas diferencias obtener una representación consistente interfaz. modelo del usuario establece perfil los usuarios finales del sistema. columna introductoria sobre “diseño centrado usuario”, jeff patton [pat] afirma siguiente: verdad que los diseñadores desarrolladores —incluido — piensan con frecuencia los usuarios finales. sin embargo, ausencia modelo mental fuerte usuarios específicos, los sustituimos con nosotros. esto centrarse usuario, sino uno mismo. para construir una interfaz usuario eficaz, “todo diseño debe comenzar con comprensión los usuarios que busca, que incluye los perfiles edad, género, condiciones físicas, educación, antecedentes culturales étnicos, motivación, metas personalidad” [shn]. ade-más, los usuarios clasifican como: principiantes. sin conocimiento sintáctico del sistema poco conocimiento semántico aplicación uso computadora general. usuarios intermitentes que saben. con conocimiento semántico razonable aplicación, pero relativamente poco recuerdo información sintáctica necesaria para usar inter-faz. usuarios frecuentes conocedores. con buen conocimiento semántico sintáctico, que con frecuencia les despierta “síndrome del usuario poderoso”; decir, individuos que buscan atajos modos interacción abreviados. modelo mental del usuario (percepción del sistema) imagen del sistema que los usua- rios finales llevan cabeza. por ejemplo, pidiera usuario procesador texto particular que describiera operación, que guiaría respuesta sería percepción que tuviera del sistema. exactitud descripción dependerá del perfil del usuario (por ejemplo, mejor los casos, los principiantes darán una respuesta esquemática) familiaridad general con software dominio aplicación. usuario que entienda bien los proce-sadores texto, pero que haya trabajado con procesador específico una sola vez, tal vez esté más preparado para hacer una descripción más completa funcionamiento que princi-piante que haya pasado semanas tratando entender sistema. modelo implementación combina manifestación externa del sistema basado com- putadora ( vista sensación interfaz) con toda información apoyo (libros, manuales, videos, archivos ayuda, etc.) que describe sintaxis semántica interfaz. cuando modelo implementación modelo mental del usuario coinciden, quienes utilizan soft-ware por general sienten cómodos con éste usan manera eficaz. para lograr esta “fusión” los modelos, modelo del diseño debe haberse desarrollado manera que incluya información contenida modelo del usuario, modelo implementación debe -flejar manera exacta información sintáctica semántica interfaz. los modelos descritos esta sección son “abstracciones que usuario hace piensa que hace que alguien piensa que debe hacerse cuando usa sistema interactivo” [mon]. esencia, estos modelos permiten que diseñador interfaz satisfaga ele-cita: “ hay ‘truco’ ella, interfaz usuario está acaba-.” douglas anderson este contexto, conocimiento sintáctico refiere mecánica interacción que requiere para usar con eficacia interfaz. término conocimiento semántico refiere sentido subyacente aplicación: entendimiento las fun- ciones que realizan, significado entrada salida, las metas objetivos del sistema.incluso usuario principiante quiere atajos; aun los usuarios frecuentes conocedores ocasiones necesitan ser guiados. hay que darles que necesitan.consejo punto clave modelo mental del usuario conforma modo que éste percibe interfaz señala satisface sus necesidades. cita: “… hay que poner atención que los usuarios hacen, que dicen.” jakob nielsen (-).indd (-).indd // ::// :: diseño interfaz usuario mento clave del principio más importante del diseño interfaz usuario: “conocer usuario, conocer las tareas.” .. proceso proceso análisis diseño interfaces usuario iterativo representa con -delo espiral similar que estudió capítulo . relación con figura ., proceso análisis diseño interfaz usuario comienza interior espiral incluye cuatro actividades estructurales distintas [man]: ) análisis modelado interfaz, ) diseño ésta, ) construcción ) validación. espiral que presenta figura . implica que cada una dichas tareas tendrá lugar más una vez que cada recorrido del contorno espi-ral representa una elaboración mayor los requerimientos del diseño resultante. -yoría los casos, actividad modelado involucra hechura prototipos, única forma práctica validar que haya diseñado. análisis interfaz centra perfil los usuarios que interactuarán con sistema. registra nivel habilidad, comprensión del negocio receptividad general hacia nuevo sistema; también definen diferentes categorías usuarios. recaban los requeri-mientos cada una éstas. esencia, trabaja para entender percepción del sistema (véase sección ..) para cada clase usuarios. una vez definidos los requerimientos generales, lleva cabo detallado análisis tarea. asimismo, identifican, describen elaboran aquellas tareas que usuario realice para alcanzar las metas del sistema (por medio varios recorridos espiral). sección ., estudia con más detalle análisis tarea. por último, análisis del ambiente del usua-rio centra las características físicas del lugar trabajo. entre las preguntas por responder encuentran las siguientes: • ¿dónde encontrará físicamente interfaz? • ¿ usuario estará sentado, pie haciendo otras tareas relacionadas con interfaz? • ¿ hardware interfaz cumple las restricciones espacio, iluminación ruido? • ¿hay consideraciones especiales factores humanos generadas por los factores ambientales? información recabada como parte del análisis utiliza para crear modelo análisis interfaz. con este modelo como base comienza acción diseñar.cita: “ mejor diseñar experiencia del usuario que rectificarla.” jon meads diseño interfaz construcción interfazanálisis modelado interfaz validación interfazfigura . proceso diseño interfaz usuario¿qué necesita saber sobre ambiente cuando comienza diseño interfaz usuario?? (-).indd (-).indd // ::// :: parte dos modelado meta del diseño interfaz definir conjunto objetos acciones ésta ( sus representaciones pantalla) que permitan usuario efectuar todas las tareas definidas forma tal que cumpla cada meta usabilidad definida para sistema. diseño inter-faz estudia con más detalle sección .. construcción interfaz comienza por general con creación prototipo que permite evaluar los escenarios uso. medida que avanza proceso diseño, emplea grupo herramientas interfaz usuario (véase sección .) para terminar cons-truirla. validación interfaz centra : ) capacidad interfaz para implementar correctamente todas las tareas del usuario, incluir todas las variaciones éstas alcanzar - dos los requerimientos generales del usuario; ) grado que interfaz fácil usar aprender ) aceptación que tiene por parte del usuario como herramienta útil tra-bajo. como dijo, las actividades descritas esta sección ocurren manera iterativa. por esto, necesario intentar especificar cada uno los detalles (del modelo análisis diseño) primera etapa. los pasos posteriores del proceso, elaboran los detalles tarea, información diseño las características operación interfaz. . nálisis interfaz aspecto clave todos los modelos del proceso ingeniería software éste: entender problema antes tratar diseñar una solución . caso del diseño interfaz usuario, entender problema significa comprender: ) las personas (usuarios finales) que interactua-rán con sistema través interfaz, ) las tareas que los usuarios finales deban realizar como parte trabajo, ) contenido que presenta como parte interfaz ) -biente que efectuarán estas tareas. las secciones siguientes analizan estos ele-mentos del análisis interfaz, intento por establecer fundamento sólido para las tareas diseño siguientes. .. análisis del usuario probable que frase “interfaz usuario” sea toda justificación que necesita para -dicar algo tiempo entender usuario antes preocuparse por los aspectos técnicos. dijo que cada usuario tiene una imagen mental del software que ésta puede ser diferente que forman otros usuarios. además, imagen mental del usuario tal vez sea muy dis-tinta del modelo del diseño que hizo ingeniero software. única manera que logra hacer converger imagen mental modelo diseño trabajando para entender los usuarios forma que usarán sistema. para ello, utiliza información procedente una variedad amplia fuentes: entrevistas. éste enfoque más directo, los miembros del equipo software -únen con los usuarios para entender mejor sus necesidades, motivaciones, cultura laboral una multitud aspectos adicionales. esto logra reuniones individuales través grupos enfoque. información ventas. personal ventas habla con los usuarios manera regular recaba información que ayuda equipo software clasificarlos entender mejor sus requerimientos. razonable afirmar que esta sección debiera formar parte del capítulo , , pues éstos estudian aspec- tos del análisis los requerimientos. situó aquí porque análisis diseño interfaz relacionan cerca entre , frecuente que frontera sea nebulosa.¿cómo aprende que usuario quiere interfaz?? (-).indd (-).indd // ::// :: diseño interfaz usuario información mercadotecnia. análisis del mercado invaluable para definición segmentos del mercado para comprensión sobre cómo usará software formas sutilmente distintas cada uno estos segmentos. información apoyo. equipo apoyo habla diario con los usuarios. constituye fuente información más probable acerca que funciona que , que les gusta los usuarios que les desagrada, qué características generan preguntas cuáles son fáciles usar. las preguntas siguientes (adaptadas [hac]) ayudarán lector entender mejor los usua- rios sistema: • ¿los usuarios son profesionales capacitados, técnicos, oficinistas trabajadores manufactura? • ¿qué nivel educación formal tiene usuario promedio? • ¿los usuarios son capaces aprender mediante materiales escritos han manifestado deseo recibir enseñanzas aula? • ¿los usuarios son mecanógrafos expertos tienen fobia los teclados? • ¿cuál rango edades comunidad usuarios? • ¿los usuarios estarán representados sobre todo por género? • ¿cómo compensa los usuarios por trabajo que realizan? • ¿los usuarios trabajan horario normal oficina hasta terminar trabajo que hacen? • ¿ software ser parte integral del trabajo los usuarios sólo emplearán manera ocasional? • ¿cuál idioma principal los usuarios? • ¿cuáles son las consecuencias usuario comete error emplear sistema? • ¿los usuarios son expertos tema que está centrado sistema? • ¿los usuarios quieren saber sobre tecnología que hay tras interfaz? una vez respondidas estas preguntas, sabrá quiénes son los usuarios finales, qué probable que los motive agrade, cómo clasificarían distintas clases perfiles usuarios, cuáles son sus modelos mentales del sistema cómo debe caracterizarse interfaz usuario para que satisfaga sus necesidades. .. análisis modelado tarea meta del análisis tarea responder las siguientes preguntas: • ¿qué trabajo realizará usuario circunstancias específicas? • ¿qué tareas subtareas efectuarán cuando usuario haga trabajo? • ¿qué dominio problema específico manipulará usuario realizar labor? • ¿cuál secuencia las tareas ( flujo del trabajo)? • ¿cuál jerarquía las tareas? para responder estas preguntas, debe recurrirse las técnicas que estudiaron libro, pero aplicadas este caso interfaz usuario. casos uso. capítulos anteriores aprendió que caso uso describe manera que actor ( contexto del diseño interfaz usuario, actor siempre una persona) interactúa con sistema. cuando utiliza como parte del análisis tarea, caso sobre todo, dedique tiempo hablar con los usuarios reales, pero con cuidado. una opinión enfática necesariamente significa que mayoría usuarios esté acuerdo con ella.consejo punto clave ¿cómo aprende sobre demografía las características los usuarios finales? punto clave meta del usuario cumplir una más las tareas través interfaz. para ello, ésta debe brindar mecanismos que permitan realizarlas. (-).indd (-).indd // ::// :: parte dos modelado uso desarrolla con objeto mostrar forma que usuario final lleva cabo alguna tarea específica relacionada con trabajo. mayoría las veces, caso uso escribe estilo informal ( simple párrafo) primera persona. por ejemplo, suponga que una empresa pequeña software quiere elaborar sistema diseño asistido por computadora dirigido explícitamente diseñadores interiores. para entender mejor forma que realizan trabajo, pide diseñadores reales que describan una función específica del -seño. cuando preguntó diseñador interiores: “¿cómo decide coloca mobiliario una habitación?”, respondió con siguiente caso uso informal: comienzo por hacer plano habitación, las dimensiones ubicación puertas ventanas. preocupa mucho cómo entra luz cuarto, vista que hay por las ventanas ( bella, quiero dirigir atención hacia ese lugar), longitud una pared obstruida flujo del movimiento por habitación. después fijo lista muebles que cliente haya elegido: -sas, sillas, sofá, gabinetes; lista accesorios: lámparas, tapetes, pinturas, esculturas, plantas, adornos, tomo notas acerca cualquier deseo que cliente tenga. después dibujo cada objeto mis listas formato escala casa. pongo letreros que haya dibujado utilizo lápiz porque siempre las muevo. luego hago una perspectiva (dibujo tridimensional) del cuarto para dar cliente sensación cómo vería. este caso uso presenta descripción básica una tarea importante del trabajo para sis- tema diseño asistido por computadora. pueden extraerse tareas, objetos flujo -neral interacción. además, pueden concebirse otras características del sistema que agra-darían diseñador interiores. por ejemplo, podría tomarse una fotografía digital través cada ventana habitación. cuando elabore perspectiva, podría representarse vista exterior real que habrá todas ellas. escena: cubículo vinod, cuando sigue diseño interfaz usuario. participantes: vinod jamie, miembros del equipo ingeniería software casasegura. conversación:jamie: nuestro contacto mercadotecnia pedí que escri- biera caso uso para interfaz vigilancia. vinod: ¿desde punto vista quién?jamie: del propietario, ¿ quién más?vinod: también está papel del administrador del sistema; aun fuera propietario, sería punto vista distinto. “adminis-trador” prepara sistema, configura, elige plano, sitúa las cámaras… jamie: todo que pedí fue que desempeñara papel una propietaria que quiere ver video. vinod: está bien. uno los comportamientos principales interfaz función vigilancia. pero también vamos tener que examinar comportamiento administración del sistema. jamie (irritado): tienes razón.[jamie sale para encontrarse con persona mercadotecnia. regresa pocas horas después.]jamie: tuve suerte, encontré trabajamos juntos caso uso del administrador. básicamente vamos definir “administración” como una función aplicable todas las demás casasegura. aquí está que obtuvimos. [jamie presenta caso uso informal vinod.]caso uso informal: quiero poder preparar editar planti- lla del sistema cualquier momento. cuando preparo sistema, selecciono una función administración. ésta pregunta deseo hacer una nueva sesión editar una existente. selecciono una nueva, sistema presenta una pantalla dibujo que permite dibu-jar plano casa una cuadrícula. habrá iconos para pare-des, ventanas puertas, manera que sea fácil dibujarlas. sólo estiro los iconos sus longitudes apropiadas. sistema mostrará las longitudes pies metros (puedo elegir sistema medidas). selecciono una biblioteca sensores cámaras, las coloco plano casa. etiqueto cada una sistema hace manera automática. puedo establecer los valores los sensores cámaras desde menús apropiados. elijo editarlos, puedo mover sensores cámaras, agregar otros nuevos eliminar los existentes, editar plano casa editar los parámetros sensores cámaras. todo caso, espero que sistema haga una comprobación consistente que ayude evitar los errores.casasegura casos uso para diseño interfaz usuario (-).indd (-).indd // ::// :: diseño interfaz usuario elaboración tarea. capítulo vio elaboración paso paso (también llamada descomposición funciones refinamiento stepwise por etapas) como mecanismo para mejorar las tareas del procesamiento requeridas para que software realice alguna función deseada. análisis tarea para diseño interfaz utiliza enfoque elaboración para ayudar entender las actividades humanas que interfaz usuario debe incluir . análisis tarea aplica dos formas. como dijo, frecuente que sistema interactivo basado computadora utilice para remplazar una actividad manual semima-nual. para entender las tareas que deben realizarse fin lograr objetivo actividad, deben entenderse las tareas que llevan cabo las personas (con enfoque manual) luego mapearlas conjunto tareas similar (pero necesariamente idéntico) que implemen-ten contexto interfaz usuario. forma alternativa, puede estudiarse una especi-ficación existente para obtener una solución basada computadora derivar conjunto tareas usuario que incluirán modelo usuario, del diseño percepción del sistema. sin importar enfoque general del análisis tarea, primero deben definirse clasificarse las tareas. dijo que enfoque elaboración paso paso. por ejemplo, volvamos considerar sistema diseño asistido por computadora para diseñadores interiores. mirar trabajar diseñador interiores, verá que labor comprende varias actividades principales: distribución los muebles (recuerde caso uso mencionado), selección telas materiales, elección cubiertas paredes ventanas, presentación ( cliente), coti-zación compras. cada una estas tareas principales divide subtareas. por ejemplo, con uso información contenida caso uso, distribución del mobiliario desglosa las tareas siguientes: ) dibujar plano con base las dimensiones habitación, ) colocar puertas ventanas las ubicaciones apropiadas, ) usar plantillas muebles para dibujar plano bosquejos del mobiliario escala, ) usar plantillas moldes para dibujar plano formas escala, ) mover los bosquejos muebles las formas para obtener mejor colocación, ) poner leyendas todos los bosquejos muebles formas, ) dibujar dimensiones para mostrar ubicación ) dibujar una perspectiva para cliente. para cada una las demás tareas principales podría emplearse enfoque similar. posible desglosar aún más las subtareas . las subtareas mejorarán, manipulando información realizando acciones dentro interfaz usuario. por otro lado, subtarea ejecuta forma automática software dará como resultado poca interacción directa con usuario. modelo del diseño interfaz debe incluir cada una estas tareas forma consistente con modelo del usuario (perfil diseñador interiores “común”) con percepción del sistema ( que diseñador interiores espera sistema automati-zado). elaboración del objeto. vez centrarse las tareas que debe realizar usuario, puede examinarse caso uso demás información obtenida del usuario para extraer los objetos físicos que usa diseñador interiores. estos objetos dividen clases: definen los atributos las clases, evaluación las acciones aplicadas cada objeto proporciona vinod (después leer escenario): bien, probable que haya algunos patrones diseño útiles [véase capítulo ] componentes reutilizables para las interfaces gráficas usuario para los programas dibujo. apuesto dólares que implemen-tamos una parte total interfaz del administrador con uso ellos. jamie: acuerdo. verificaré. elaboración tarea muy útil, pero también puede ser peligrosa. porque haya hecho una tarea debe suponer que existe otra forma realizarla, que intentará cuando implemente interfaz usuario.consejo sin embargo, tal vez sea éste caso. diseñador interiores podría desear especificar perspectiva que dibujar, escala, uso del color otra información. caso uso relacionado con dibujo pers- pectiva daría información necesaria para efectuar esta tarea. (-).indd (-).indd // ::// :: parte dos modelado una lista operaciones. por ejemplo, plantilla muebles traduce una clase llamada mobiliario con atributos que incluirían tamaño, forma ubicación, entre otros. diseñador interiores seleccionaría objeto clase mobiliario, movería cierta posición plano (otro objeto, este contexto), dibujaría bosquejo del mueble, etc. las tareas seleccionar, mover dibujar son operaciones. modelo del análisis interfaz usuario daría una implementación literal para cada una estas operaciones. obstante, medida que ela-bore diseño, definen los detalles cada operación. análisis del flujo del trabajo. cuando varios usuarios distintos, cada uno con diferentes roles, utilizan una interfaz usuario, veces necesario más allá del análisis tarea elaboración del objeto, aplicar análisis del flujo del trabajo . esta técnica permite - tender cómo efectúa proceso trabajo cuando están involucradas varias personas ( roles). considere una compañía que trate automatizar por completo proceso surtir entregar recetas medicinas. todo proceso giraría alrededor una aplicación basada web accesible para médicos ( sus asistentes), farmacéuticos pacientes. flujo del trabajo puede representarse con eficacia con diagrama uml canal (variación del diagrama actividades). sólo consideraremos una pequeña parte del proceso trabajo: situación que ocurre cuando paciente solicita una nueva entrega. figura . presenta diagrama canal que indica las tareas decisiones para cada uno los tres roles mencionados. esta información obtiene entrevistas casos uso escritos por cada actor. obstante, flujo eventos (mostrados figura) permite reconocer cierto número características clave interfaz: . cada usuario implementa tareas través interfaz: entonces, vista sensación interfaz diseñada para paciente será distinta que definió para farmacéu- ticos médicos. . diseño interfaz para farmacéuticos médicos debe incluir acceso, desplegar información desde fuentes secundarias (por ejemplo, acceder ventario para far- macéutico acceder información acerca medicaciones alternativas para médico). . muchas las actividades anotadas diagrama canal elaboran más con uso del análisis tarea elaboración del objeto (por ejemplo, surtir receta implicaría entrega una orden por correo, una visita farmacia visitar centro distri- bución medicinas especiales). representación jerárquica. comenzar analizar interfaz, ocurre proceso elabo- ración. una vez establecido flujo los trabajos, define una jerarquía tareas para cada tipo usuario. ésta pro viene elaboración paso paso cada tarea identificada para usuario. por ejemplo, considere las tareas usuario siguientes jerarquía las subtareas. tarea del usuario: solicitar que surta una receta • dar información identificación. • especificar nombre. • especificar identificación usuario. • especificar pin clave. • especificar número prescripción. • especificar fecha que requiere surtir. para terminar tarea, definen tres subtareas. una ellas, dar información identificación , elabora más tres subsubtareas adicionales.aunque elaboración del objeto útil, debe usarse como enfoque único. durante análisis tarea debe tomarse cuenta opinión del usuario.consejo este ejemplo adaptó [hac].cita: “ mucho mejor adaptar latecnología usuario que obli-gar éste adaptarse tecnología.” larry marine (-).indd (-).indd // ::// :: diseño interfaz usuario .. análisis del contenido pantalla las tareas identificadas sección .. conducen presentación varios tipos diferen- tes contenido. para las aplicaciones modernas, contenido pantalla varía reportes basados caracteres (como una hoja cálculo), gráficas (histograma, modelo tridimensional, fotografía alguien) información especializada (por ejemplo, archivos audio video). las paciente farmacéutico médico solicita que surta una receta quedan surtidosrevisa los registros del pacientedetermina estado prescripción quedansurtidos apruebaque surtaapruebaque surta evalúa una medicación alternativa recibe solicitud contactar médicoalternativadisponiblerevisa inventario para surtir dar una alternativa hay eninventariorecibe notiﬁcación inexistencia recibe hora fecha para recogerlasí hay eninventario recoge prescripción surte recetafigura . diagrama canal para función surtir receta (-).indd (-).indd // ::// :: parte dos modelado técnicas modelado del análisis estudiadas los capítulos identifican los objetos datos salida producidos por una aplicación. estos objetos datos pueden ser: ) generados por componentes ( relacionados con interfaz) otras partes aplicación, ) adquiri-dos partir datos almacenados una base accesible desde aplicación ) transmitidos desde sistemas externos aplicación cuestión. durante esta etapa del análisis interfaz, toma cuenta formato estética del contenido (según despliega interfaz). entre las preguntas planteadas respondidas, encuentran las siguientes: • ¿ asignan diferentes tipos datos sitios consistentes geografía pantalla (por ejemplo, las fotografías aparecen siempre esquina superior derecha)? • ¿ usuario puede personalizar ubicación del contenido pantalla? • ¿ asigna una identificación apropiada todo contenido que hay pantalla? • presenta reporte grande, ¿cómo debe dividirse para facilitar comprensión? • ¿ dispondrá mecanismos para pasar directamente información resumida grandes conjuntos datos? • ¿las salidas gráficas estarán escala para que ajusten los bordes del dispositivo pantalla que utilice? • ¿cómo empleará color para mejorar comprensión? • ¿ qué manera presentará usuario los mensajes error las advertencias? las respuestas estas ( otras) preguntas ayudarán establecer los requerimientos pre-sentación del contenido. .. análisis del ambiente trabajo hackos redish [hac] estudian importancia del análisis del ambiente trabajo cuando afirman siguiente: las personas realizan aisladas trabajo. están influidas por actividad que las rodea, las carac- terísticas físicas del sitio trabajo, tipo equipo que usan las relaciones laborales que tienen con las demás personas. los productos que usted diseña ajustan ambiente, uso será -fícil frustrante. ciertas aplicaciones coloca interfaz usuario sistema basado computadora una “ubicación amigable” (con iluminación adecuada, buena altura pantalla, acceso fácil teclado, etc.), pero otras (como una fábrica cabina avión) ilumina-ción menos que buena, ruido notable, teclado ratón son opción posición pantalla ideal. diseñador interfaz puede estar restringido por factores que confabulan contra facilidad del uso. además los factores del ambiente físico, también entra juego cultura del sitio trabajo. ¿ medirá algún modo interacción con sistema (por ejemplo, tiempo cada transacción exactitud ésta)? ¿tendrán que compartir información dos más personas para que una entrada? ¿cómo apoyará los usuarios del sistema? estas preguntas muchas otras relacionadas deben responderse antes que comience diseño interfaz. . tapas del diseño interfaz una vez concluido análisis interfaz, todas las tareas ( objetos acciones) requeridas por usuario final habrán sido identificadas detalle comenzará actividad diseño interfaz. diseño interfaz, como todo ingeniería software, proceso ¿cómo determina formato estética del contenido desple-gado como parte interfaz usuario?? (-).indd (-).indd // ::// :: diseño interfaz usuario iterativo. cada etapa del diseño interfaz usuario ocurre varias veces, las que ela- bora refina información desarrollada etapa anterior. aunque han propuesto muchos modelos diferentes para modelo interfaz usua- rio ([nor], [nie]), todos sugieren alguna combinación las etapas siguientes: . definir objetos acciones interfaz (operaciones) con uso información -sarrollada análisis interfaz (sección .). . definir eventos (acciones del usuario) que harán que cambie estado interfaz usuario. hay que modelar este comportamiento. . ilustrar cada estado interfaz como vería realidad usuario final. . indicar cómo interpreta usuario estado del sistema partir información pro-vista través interfaz. ciertos casos, comienza con bosquejos cada estado interfaz ( que vería usua- rio diferentes circunstancias) después trabaja hacia atrás para definir objetos, acciones otra información importante del diseño. sin importar secuencia las tareas diseño, debe ) siempre apegarse las reglas doradas estudiadas sección ., ) modelar forma que implementar interfaz ) considerar ambiente (por ejemplo, tecnología pantalla, sistema operativo, herramientas desarrollo, etc.) que empleará. .. aplicación las etapas diseño interfaz una etapa importante del diseño interfaz definición objetos interfaz las acciones que aplican ellos. para lograr esto, elaboran escenarios uso forma muy parecida descrita capítulo . decir, escribe caso uso. aíslan los sustan-tivos (objetos) verbos (acciones) fin crear una lista objetos acciones. una vez definidos éstos elaborados forma iterativa, clasifican por tipo. identifican los objetos blanco, fuente aplicación. objeto fuente (icono reporte, por ejemplo) arras-tra deja sobre objeto blanco (como icono impresora). consecuencia esta acción que crea informe papel. objeto aplicación representa datos específicos aplicación que manipulan directamente como parte interacción pantalla. por ejemplo, usa una lista correo para guardar nombres. lista tal vez ordene, fusione purgue (acciones basadas menús), pero arrastra suelta por medio alguna interacción del usuario. cuando está satisfecho con definición todos los objetos acciones importantes (para una iteración del diseño), realiza distribución pantalla. como otras actividades del diseño interfaz, distribución pantalla proceso interactivo que llevan cabo diseño gráfico colocación iconos, definición descripciones texto pantalla, especificación títulos las ventanas, definición aspectos grandes peque-ños del menú. hubiera una metáfora apropiada del mundo real para aplicación, éste momento que especifica, distribución organiza forma tal que complemente metáfora. para dar una ilustración breve las etapas diseño mencionadas, considere escenario uso para sistema casasegura (estudiado capítulos anteriores). continuación pre- senta caso uso preliminar (escrito por propietario) para interfaz: caso uso preliminar: quiero tener acceso sistema casasegura través internet, desde cualquier lugar remoto. con uso software navegación que opere computadora por- tátil (cuando estoy trabajo viaje), determino estado del sistema alarma, activo des-activo sistema, vuelvo configurar zonas seguridad veo diferentes habitaciones casa por medio las cámaras video instaladas.cita: “ diseño interactivo [] una mezcla tersa las artes gráfi-cas, tecnología psicología.” brad wieners (-).indd (-).indd // ::// :: parte dos modelado para acceder casasegura desde una ubicación remota, doy una identificación una clave. éstas definen niveles acceso (por ejemplo, todos los usuarios les permite reconfigurar sistema) dan seguridad. una vez validadas, reviso estado del sistema cambio activando desactivando casasegura. reconfiguro sistema con plano casa, con vista cada uno los sensores seguridad, con despliegue cada zona configurada con modificación las zonas según requiera. puedo ver interior casa por medio cámaras video colocadas estratégica-mente. abro ángulo visión acerco toma que cada cámara las diferentes vistas del -terior. con base este caso uso, identifican las siguientes tareas del propietario, objetos datos: • acceder sistema casasegura • introducir una identificación clave que permitan acceso remoto • comprobar estado del sistema • activar desactivar sistema casasegura • mostrar plano las ubicaciones los sensores • mostrar las zonas del plano • cambiar las zonas plano • mostrar las ubicaciones las cámaras video plano • seleccionar una cámara video para ver • ver imágenes video (cuatro cuadros por segundo) • abrir ángulo acercar cámara video esta lista tareas del propietario extraen los objetos ( negritas) las acciones ( cursiva). mayoría objetos anotados son aplicación. sin embargo, ubicación -mara video (objeto fuente) arrastra suelta cámara video (objeto blanco) para crear una imagen video (ventana con pantalla video). crea bosquejo preliminar distribución pantalla para vigilancia con video (véase figura .). para invocar imagen video, selecciona icono ubicación cámara video, , ubicado plano que aparece ventana vigilancia. este caso, continuación arrastra una ubicación cámara sala () suelta icono cámara video que aparece parte superior izquierda pantalla. aparece ventana video muestra una toma cámara localizada sala. los controles deslizantes acercamiento apertura utilizan para controlar aumento dirección imagen video. para seleccionar una vista otra cámara, usuario simplemente arrastra suelta icono diferente ubicación cámara correspondiente cámara que hay esquina -perior izquierda pantalla. bosquejo distribución tendría que darse con una expansión cada objeto menú barra, que indicarían cuáles acciones están disponibles modo vigilancia con video (estado). durante diseño interfaz crearía conjunto completo bosquejos para cada una las tareas del propietario anotadas escenario uso. .. patrones diseño interfaz usuario las interfaces usuario gráficas han vuelto tan comunes que surgido una amplia varie-dad patrones diseño ellas. como dijo este libro, patrón diseño una aunque las herramientas automatizadas pueden ser útiles desarrollo prototipos distribución, ocasiones todo que necesita lápiz papel.consejo observe que esto difiere poco implementación estas características los capítulos anteriores. esto tal vez considere primer bosquejo del diseño represente una alternativa digna tomarse cuenta. (-).indd (-).indd // ::// :: diseño interfaz usuario abstracción que prescribe una solución diseño para problema diseño bien delimi- tado. como ejemplo problema diseño interfaz que común encontrar, considere una situación que usuario debe introducir una más fechas, veces varios meses -tes. hay muchas soluciones para este sencillo problema han propuesto varios patrones distintos. laakso [laa] sugiere patrón llamado calendarstrip que produce calendario continuo, giratorio, que resalta fecha actual eligen las futuras, tomándolas del calendario. metáfora del calendario bien conocida por todos los usuarios meca-nismo eficaz para situar contexto una fecha futura. última década han propuesto muchos patrones diseño interfaz. capítulo presenta análisis más detallado los patrones diseño interfaz usuario. además, erickson [eri] proporciona vínculos muchos grupos basados web. .. aspectos del diseño medida que evoluciona una interfaz usuario, casi siempre surgen cuatro aspectos comunes del diseño: tiempo respuesta del sistema, herramientas ayuda para usuario, manejo información errónea leyendas los comandos. desafortunadamente, son muchos los dise-ñadores que enfrentan estos aspectos hasta que relativamente tarde proceso -seño ( veces sucede que primera sospecha que existe problema ocurre hasta que existe prototipo operativo). frecuente que resultado sean iteraciones innecesarias, retrasos proyecto frustración del usuario final. mucho mejor establecer cada uno ellos como aspecto del diseño que debe tomarse cuenta comenzar diseño del soft-ware, cuando fácil barato hacer cambios. tiempo respuesta. tiempo respuesta del sistema queja principal muchas aplicaciones interactivas. general, mide desde momento que usuario ejecuta - guna acción control (por ejemplo, oprime tecla “enter” hace clic ratón) hasta que software responde con salida acción deseada.acceder configurar estado del sistema vista vigilancia vigilancia primer pisosss imagen video - brlrdr kit ccccasasegura conectar estado cámara video dentro fuera csensor puerta ventana detector movimiento ( muestra rayo) ubicación cámara video acercamiento aperturafigura . distribución preliminar pantalla webref propuesto una amplia variedad patrones diseño interfaces gráficas. dirección encuentran varios vínculos hacia sitios patrones. (-).indd (-).indd // ::// :: parte dos modelado tiempo respuesta tiene dos características importantes: longitud variabilidad. tiempo respuesta demasiado largo, inevitable que usuario sienta frustración ten- sión. variabilidad refiere desviación del tiempo respuesta promedio , por muchos aspectos, característica más importante. variabilidad baja permite que usuario esta-blezca ritmo interacción, aun tiempo respuesta fuera relativamente largo. por ejemplo, tiempo respuesta segundo para comando resulta con frecuencia prefe-rible una respuesta que varíe . . segundos. cuando variabilidad significativa, usuario siempre sale balance, pregunta tras bambalinas ocurrido algo “distinto”. herramientas ayuda. casi siempre, todo usuario sistema interactivo basado computadora requiere ayuda ocasional. ciertos casos, una simple pregunta dirigida colega conocedor resuelve. otros, única opción búsqueda detallada muchos “manuales del usuario”. sin embargo, mayor parte los casos, software moderno brinda herramientas ayuda línea que permiten usuario obtener respuesta para sus preguntas resolver problema sin tener que salir interfaz. cuando consideren las herramientas ayuda, deben tomarse cuenta varios aspectos del diseño [rub]: • ¿habrá ayuda para todas las funciones del sistema todo momento durante inte- racción con éste? las opciones incluyen ayuda para solo subconjunto todas las funciones acciones para todas las funciones. • ¿cómo pedirá ayuda usuario? las opciones incluyen menú, una tecla función especial comando ayuda. • ¿cómo presentará ayuda? las opciones incluyen una ventana por separado, una referencia sobre documento impreso (lejos ser ideal) una sugerencia uno dos renglones generados una posición fija pantalla. • ¿cómo volverá usuario interacción normal? las opciones incluyen botón regreso que muestre pantalla, una tecla función una secuencia control. • ¿cómo ayudaría que información estuviera estructurada? las opciones incluyen una estructura “plana” que acceda información por medio teclado, una jerarquía capas información que provea cada vez más detalles medida que usuario avance estructura uso hipertexto. manejo errores. los mensajes error las advertencias son “malas noticias” que llegan los usuarios desde sistemas interactivos cuando algo sale mal. peor los casos, los men-sajes error advertencias dan información inútil equívoca sólo sirven para aumentar frustración del usuario. son pocos los usuarios computadoras que han encontrado con error del tipo siguiente: “ aplicación xxx terminado porque encontró error del tipo .” algún lado debe existir una explicación del error ; otro modo, ¿por qué habrían -cluido los diseñadores dicha información? obstante, mensaje una indicación real que salió mal dónde buscar más información. mensaje error presentado esta -nera hace nada para mitigar ansiedad del usuario para ayudarlo corregir problema. general, todo mensaje error advertencia producida por sistema interactivo debería tener las siguientes características: • mensaje debe describir problema lenguaje que entienda usuario. • mensaje debe dar consejos constructivos para corregir error. • mensaje debe indicar cualesquiera consecuencias negativas del error (por ejemplo, archivos datos potencialmente corrompidos) para que usuario pueda revisarlas fin asegurarse que hayan tenido lugar ( corregirlas las hubo).cita: “ error común que cometen las personas cuando tratan diseñar algo por completo prueba tontos subestimar ingenuidad los tontos com-pletos.” douglas adams cita: “ interfaz del infierno: ‘para corregir este error continuar, introduzca cualquier número primo dígitos…’”. autor desconocido ¿qué características debe tener “buen” mensaje error?? (-).indd (-).indd // ::// :: diseño interfaz usuario • mensaje debe estar acompañado una clave audible visual. decir, debe generarse sonido que acompañe aparición del mensaje éste debe cintilar momentáneamente desplegarse color que reconozca con facilidad como “color del error”. • mensaje “ debe juzgar”. decir, sus palabras nunca deben culpar usuario. como realidad nadie gustan las malas noticias, pocos usuarios les agradará mensaje error, importa bien diseñado que esté. pero una filosofía eficaz mensajes error puede hacer mucho para mejorar calidad sistema interactivo disminuirá manera significativa frustración del usuario cuando sucedan los problemas. leyendas del menú los comandos. comando escrito fue alguna vez modo más común interacción entre usuario sistema software , era normal usarlo para aplica- ciones todo tipo. hoy día, uso interfaces orientadas las ventanas, apuntar tomar, reducido dependencia los comandos escritos, pero algunos usuarios avanzados aún prefieren modo interacción orientado los comandos. cuando dan comandos leyendas menú como modo interactuar, surgen ciertos aspectos relacionados con diseño: • ¿toda opción menú tiene comando correspondiente? • ¿qué forma tendrán los comandos? las opciones incluyen una secuencia control (por ejemplo, alt-), teclas función palabras escritas. • ¿cuán difícil será aprender recordar los comandos? ¿qué puede hacerse olvida comando? • ¿los comandos pueden ser personalizados abreviados por usuario? • ¿las leyendas del menú explican por mismas contexto interfaz? • ¿son consistentes los submenús con función implicada por tema maestro del menú? como dijo, todas las aplicaciones deben establecerse convenciones para uso los comandos. con frecuencia resultan confusos facilita que usuario cometa errores tiene que escribir alt- cuando duplicar objeto gráfico una aplicación alt- cuando eliminarse otra. resulta obvio potencial que hay para error. accesibilidad aplicación. conforme las aplicaciones computación hacen ubi- cuas, los ingenieros software deben asegurarse que diseño interfaz incluya meca-nismos que permitan acceso fácil las personas con necesidades especiales. accesibilidad para los usuarios ( ingenieros software) que tengan discapacidades físicas imperativo por razones éticas, legales comerciales. son varios los lineamientos accesibilidad (por ejemplo []) —muchos ellos diseñados para aplicaciones web pero aplicables con fre-cuencia todos los tipos software— que hacen sugerencias detalladas para diseño -terfaces que alcancen niveles variables accesibilidad. otras (ver [app], [mic]) brindan lineamientos específicos para “tecnología ayuda” abocan las necesidades quienes tienen discapacidades visuales, auditivas, motrices, del habla aprendizaje. internacionalización. los ingenieros software sus gerentes invariablemente subesti- man esfuerzo aptitudes que requieren para crear interfaces usuario que incluyan las necesidades lugares idiomas diferentes. con demasiada frecuencia, las interfaces dise-ñan para una localidad lenguaje después adaptan para funcionar otros países. -safío para los diseñadores interfaces crear software “globalizado”. decir , las interfa-webref dirección able/guidelines/software/accesssoftware.html dan lineamientos para desarrollar software accesible. (-).indd (-).indd // ::// :: parte dos modelado ces usuario deben emplearse para que incluyan núcleo general funcionalidad que distribuya todos aquellos que utilicen software. las características localización permiten que interfaz personalice para mercado específico. los ingenieros software disponen varios lineamientos para internacionalización (consultar [ibm]. éstos abordan aspectos amplios del diseño (por ejemplo, las pantallas difie-ren mercados distintos) implementación discreta (alfabetos distintos generan requeri-mientos escritura espaciamiento especializados). estándar unicode [uni] desarrolló para resolver difícil desafío manejar decenas idiomas naturales con cientos caracte-res símbolos. objetivo: estas herramientas permiten ingeniero crear una interfaz usuario gráfica con relativamente poco desarrollo software especializado. las herramientas dan acceso componentes reutilizables hacen que creación una interfaz reduzca seleccionar capacidades predefinidas que ensamblan con empleo herramienta. mecánica: las interfaces modernas construyen con empleo conjunto componentes reutilizables que acoplan con algunos componentes personalizados desarrollados para obtener característi-cas especializadas. mayor parte las herramientas para -sarrollo interfaces usuario permiten que ingeniero soft-ware las cree con empleo capacidad “arrastrar soltar”. decir, desarrollador selecciona entre muchas herramientas pre-definidas (como constructores formas, mecanismos interacción, capacidad procesamiento comandos, etc.) las coloca dentro del contenido interfaz que crear.herramientas representativas: legalsuite gui, desarrollada por seagull software ( software.com), permitió creación interfaces usuario gráficas basadas navegador facilidades para hacer reingeniería interfaces anticuadas. motifcommon desktop environment, desarrollada por the open group ( una interfaz usuario gráfica integrada para sistemas abiertos compu-tación escritorio. produce una interfaz gráfica única estandari-zada para administración datos, archivos (escritorio gráfico) aplicaciones. altia design ., desarrollada por altia ( una herramienta para crear interfaces gráficas usuario platafor-mas diferentes (como automóvil, portátiles, industriales, etcétera).herramientas software desarrollo interfaz usuario . iseño una interfaz para webapps toda interfaz usuario —diseñada para una webapp, aplicación software tradicional, pro- ducto consumo dispositivo industrial— debe tener las características usabilidad que estudiaron este capítulo. dix [dix] afirma que debe diseñarse una interfaz webapp modo que responda tres preguntas principales del usuario final: ¿dónde estoy? interfaz debe: ) dar una indicación webapp que accedido ) informar usuario localización jerarquía del contenido. ¿qué puedo hacer ahora? interfaz siempre debe ayudar usuario entender sus opcio- nes actuales: cuáles funciones están disponibles, qué vínculos están vivos, qué contenido relevante, etcétera. ¿dónde estado, hacia dónde voy? interfaz debe facilitar navegación. para ello, debe disponer “mapa” (implementado forma tal que sea fácil entender) que indique las herramientas mencionadas aquí son obligatorias, sino una muestra las que hay esta categoría. mayoría casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores. todos hemos marcado una página web cuando regresamos tiempo después tenemos una indicación del sitio web del contexto para página ( manera pasar otra ubicación dentro del sitio). probable que los usuarios entren webapp por distintos lugares niveles jerarquía del contenido, hay que asegurarse diseñar cada página con características navegación que lleven usuario otros puntos interés.consejo (-).indd (-).indd // ::// :: diseño interfaz usuario dónde estado usuario las trayectorias que pueden tomarse para moverse cualquier punto webapp. una interfaz eficaz webapp debe dar respuestas todas estas preguntas cuando usuario navegue por contenido por sus funciones. .. principios lineamientos del diseño interfaz interfaz usuario una webapp “primera impresión” que recibe. sin importar valor contenido, sofisticación sus capacidades servicios procesamiento, así como beneficio general webapp , una interfaz mal diseñada decepcionará usuario potencial realidad hará que éste vaya cualquier otro sitio. debido enorme volumen webapps competidoras virtualmente toda área temática, interfaz debe “atrapar” inme-diato usuario potencial. bruce tognozzi [tog] define conjunto características fundamentales que todas las interfaces deben tener con ello establece filosofía que todo diseñador interfaces webapps debe seguir: las interfaces eficaces son atractivas visualmente perdonan los errores, que sus usuarios sensación tener control. los usuarios perciben rápidamente totalidad sus opciones, captan cómo lograr sus metas cómo hacer trabajo. las interfaces eficaces preocupan usuario con funcionamiento interno del sistema. tra- bajo guarda manera cuidadosa continua, con opción total para que usuario deshaga cual-quier actividad cualquier momento. las aplicaciones servicios eficaces realizan máximo trabajo, tiempo que requieren mínimo información parte los usuarios. fin diseñar interfaces webapps con estas características, tognozzi [tog] identifica conjunto principios generales diseño: previsión. una webapp debe diseñarse modo que prevea siguiente vimiento del usuario. por ejemplo, considere una webapp ayuda cliente desarrollada por fabricante impre-soras para computadora. usuario solicita objeto contenido que presenta información sobre controlador impresora para sistema operativo reciente. diseñador webapp debe prever que usuario tal vez pida descargar controlador debe brindar facilida-des navegación que permitan, sin requerir que usuario busque esta capacidad. comunicación. interfaz debe com unicar estado cualquier actividad iniciada por usua- rio. comunicación puede ser obvia (por ejemplo, mensaje texto) sutil (como imagen una hoja papel que mueva través una impresora para indicar que hay una impre-sión curso). interfaz también debe comunicar estado del usuario (como identifica-ción) ubicación dentro jerarquía del contenido webapp. consistencia. uso controles navegación, men , iconos estética (color, forma distri- bución) debe ser consistente webapp . por ejemplo, texto color azul subrayado implica vínculo navegación, contenido nunca debe incorporar texto con dichas carac-terísticas que impliquen vínculo. además, objeto, digamos triángulo amarillo, que utilice para indicar mensaje precaución antes que usuario invoque una función acción particular, debe usarse para otros propósitos ningún otro lugar webapp. por los principios originales tognozzi fueron adaptados ampliados para uso este libro. véase [tog] para análisis más amplio ellos.cita: “ sitio perfectamente usable, pero carece estilo elegante apropiado, entonces fallará.” curt cloninger punto clave una buena interfaz webapps entendible benévola, que usuario sensación tener control. ¿hay conjunto principios básicos que apliquen diseño una interfaz usuario gráfica? ? (-).indd (-).indd // ::// :: parte dos modelado último, toda característica interfaz debe responder manera consistente con las expec- tativas del usuario. autonomía controlada. interfaz debe facilitar vimiento del usuario través webapp, pero debe hacer manera que obligue respetar las convenciones que hayan esta- blecido para aplicación. por ejemplo, debe controlarse navegación hacia partes seguras webapp por medio identificación clave del usuario, debe haber ningún mecanismo navegación que permita que usuario evite dichos controles. eficiencia. diseño webapp interfaz deben optimizar eficiencia del abajo del usua- rio, del desarrollador que diseña construye del ambiente cliente-servidor que ejecuta. tognozzi [tog] aborda esto cuando escribe siguiente: “esta sencilla verdad explica por qué tan importante que todos los involucrados proyecto software aprecien importan-cia hacer que productividad del usuario sea meta número uno, entender diferen-cia vital entre construir sistema eficiente dar poder usuario eficiente.” flexibilidad. interfaz debe tener flexibilidad suficiente par permitir que algunos usuarios realicen tareas directamente, que otros exploren webapp forma aleatoria. cada caso, debe permitir usuario entender dónde encuentra darle funcionalidad para deshacer errores volver trazar trayectorias navegación mal elegidas. centrarse. interfaz webapp ( contenido que presente) debe mantenerse centr ada las tareas curso del usuario. todos los hipermedios, existe tendencia llevar usuario contenido poco relacionado. ¿por qué? porque muy fácil hacerlo… problema que usuario puede extraviarse con rapidez muchas capas información apoyo perder vista contenido original que buscaba inicialmente. ley fitt. “ tiempo par llegar objetivo está función distancia que hay hasta del tamaño que tenga” [tog]. con base estudio realizado década [fit], ley fitt “ método eficaz para modelar movimientos rápidos intencionados, donde apéndice (como una mano) comienza reposo una posición específica arranque vuelve reposo dentro área objetivo” [zha]. una secuencia selecciones entradas estandarizadas (con muchas opciones diferentes dentro secuencia) definida por una tarea usuario, primera selección (con ratón, por ejemplo) debe estar físicamente cerca siguiente selección. por ejemplo, considere una interfaz página inicial una webapp sitio comercio electrónico que vende productos consumo electrónicos. cada opción del usuario implica conjunto elecciones acciones por seguir. por ejemplo, opción “comprar producto” requiere que usuario introduzca una categoría producto seguida por nombre éste. categoría del producto (equipo audio, televisiones, reproduc-tores dvd, etc.) aparece como menú desplegable tan pronto como elige “comprar producto”. entonces, elección siguiente resulta obvia inmediato (está cerca) tiempo para llegar ella despreciable. por contrario, elección apareciera menú localizado otro lado pantalla, tiempo para que usuario llegue ( luego elija) será mucho más largo. objetos interfaz humana. desarrollado una vasta biblioteca objetos reutilizables interfaces humanas par webapps. úselas. cualquier objeto interfaz que pueda ser “visto, escuchado, tocado percibido otro modo” [tog] por usuario final, puede obtenerse alguna, entre muchas, librerías objetos. tognozzi [tog] hace observación que única manera asegurarse que entienden bien las expec- tativas del usuario realizando exhaustivamente pruebas las que participe (véase capítulo ).cita: “ mejor recorrido aquel con menor número pasos. hay que acortar distancia entre usuario meta.” autor desconocido webref una búsqueda web revelará muchas bibliotecas disponibles, por ejemplo, paquetes aplicaciones java, interfaces clases, java.sun.com com, dcom bibliotecas tipo msdn.microsoft.com. (-).indd (-).indd // ::// :: diseño interfaz usuario reducción latencia. vez hacer que usuario espere que termine alguna oper - ción interna (como descargar una imagen gráfica compleja), webapp debe usar tareas múltiples, manera que permita que usuario continúe con trabajo mientras finaliza operación. ade- más reducir latencia, los retrasos deben explicarse modo que usuario entienda que esté pasando. esto incluye: ) dar retroalimentación auditiva cuando una selección como resultado una acción inmediata por parte webapp, ) desplegar reloj con animación una barra avance que indique que hay procesamiento marcha ) dar alguna distrac-ción (presentación texto animado) cuando tenga lugar procesamiento tardado. aprendizaje. una interfaz webapp debe diseñarse par minimizar tiempo aprendizaje , una vez aprendida, minimizar que dedique reaprender cuando regrese webapp. general, interfaz debe hacer énfasis diseño sencillo intuitivo que organice contenido funcionalidad categorías que resulten obvias para usuario. metáforas. una interfaz que use una metáfor interacción más fácil aprender usar, medida que metáfora sea apropiada para aplicación usuario. una metáfora debe recurrir imágenes conceptos salidos experiencia del usuario, pero necesita ser una reproducción exacta una experiencia del mundo real. por ejemplo, sitio comercio electrónico que implemente pago automatizado una institución financiera, usa una metá-fora chequera ( que sorprende) para ayudar usuario especificar programar los pagos sus facturas. sin embargo, cuando usuario “escribe” cheque, necesita intro-ducir nombre completo del beneficiario, sino que elige una lista ellos hace que sistema seleccione con base las primeras letras que escriba. metáfora permanece -tacta, pero usuario recibe ayuda webapp. mantener integridad los productos del trabajo. producto del abajo (por ejemplo, formato llenado por usuario una lista especificada por ) debe guardarse forma automá-tica, modo que pierda ocurriera error. todos hemos experimentado frustración que surge cuando terminar llenar formato extenso una webapp, pierde conte-nido debido error (cometido por nosotros, por webapp transmitirlo del cliente servidor). para evitar esto, webapp debe diseñarse para que guarde todos los datos especifi-cados por usuario. interfaz debe apoyar esta función dar usuario mecanismo fácil recuperación información “perdida”. legibilidad. oda información presentada interfaz debe ser legible para jóvenes viejos. diseñador interfaz debe hacer énfasis estilos legibles para las letras, tamaño color del fondo, que debe contrastar. dar seguimiento estado. cuando resulte apropiado, debe darse seguimiento estado inter acción del usuario guardarlo, modo que éste pueda salir volver más tarde para recuperarlo donde haya dejado. general, las cookies pueden diseñarse para que guarden información del estado. sin embargo, son una tecnología controvertida para ciertos usuarios resultan más atractivas otras soluciones diseño. navegación visible. una interfaz webapp bien diseñada “ ilusión que los usuarios están mismo lugar , con trabajo llevado ellos” [tog]. cuando emplea este enfoque, navegación asunto del usuario. vez ello, éste recupera objetos del contenido selecciona funciones que despliegan ejecutan través interfaz. nielsen wagner [nie] sugieren algunos lineamientos prácticos para diseño interfa- ces (basados rediseño una webapp importante), que constituyen buen complemento los principios sugeridos esta sección:las metáforas son una idea excelente porque reflejan experiencia del mundo real. sólo hay que asegurarse que metáfora elegida resulte bien conocida para los usuarios finales.consejo (-).indd (-).indd // ::// :: parte dos modelado • lectura rápida monitor computadora aproximadamente por ciento más lenta que que hace papel. por tanto, obligue usuario leer grandes cantidades texto, particular cuando explique operación webapp, ayuda para navegación. • evite los avisos “ construcción”: vínculo innecesario camino seguro decepción. • los usuarios prefieren desplazar pantalla. información importante debe situarse dentro las dimensiones una ventana normal navegación. • los menús navegación los encabezados deben diseñarse manera consistente deben estar disponibles todas las páginas las que tenga acceso usuario. diseño debe basarse funciones del navegador que ayuden navegación. • estética nunca debe obstaculizar funcionalidad. por ejemplo, solo botón será una mejor opción navegación que una imagen agradable pero vaga que icono cuyo objetivo esté claro. • las opciones navegación deben ser obvias, aun para usuario casual. éste debe tener que buscar pantalla para determinar cómo entrar otro contenido servicios. escena: oficina doug miller. participantes: doug miller (gerente del grupo ingeniería software casasegura) vinod raman, miembro del equipo ingeniería software del producto casasegura. conversación:doug: vinod, ¿han podido revisar equipo prototipo interfaz comercio electrónico casaseguraasegurada.com? vinod: … todos vimos desde punto vista técnico, tengo muchas observaciones. las envié ayer por correo electrónico sharon [gerente del equipo webapp para venta externa del sitio web comercio electrónico casasegura]. doug: sharon pueden reunirse analizar eso… hazme resumen los aspectos importantes. vinod: sobre todo, han hecho buen trabajo, nada grandioso, pero una interfaz normal comercio electrónico, estética acep-table, distribución razonable, atendieron todas las funciones impor-tantes… doug (sonríe contrito): ¿pero?vinod: bueno, hay algunas cosas…doug: cómo…vinod (presenta doug una secuencia esquemas del prototipo interfaz): aquí está menú funciones prin-cipales que aparece página inicio: aprenda sobre casasegura. describa casa.recomendaciones sobre componentes casasegura.compre sistema casasegura. obtenga ayuda técnica. problema está estas funciones. están bien, pero nivel abstracción correcto. doug: todas son funciones principales, ¿ ?vinod: son, pero ahí hay algo… puedes comprar sistema sin introducir una lista componentes… hay una necesidad real describir casa quieres hacerlo. sugiero que sólo haya cuatro opciones menú página inicio. aprenda sobre casasegura. especifique sistema casasegura que necesite. compre sistema casasegura.obtenga ayuda técnica. cuando seleccione especifique sistema casasegura que necesite, entonces tendrán las siguientes opciones: seleccione los componentes casasegura. recomendaciones sobre componentes casasegura. eres usuario conocedor, seleccionarás los componentes conjunto menús desplegables clasificados sensores, cámaras, paneles control, etc. necesitaras ayuda, solicitarás una reco-mendación eso requerirá que describas casa. creo que poco más lógico. doug: estoy acuerdo. ¿has hablado con sharon esto?vinod: , primero quiero analizar esto con gente mercado- tecnia; después llamaré.casasegura revisión del diseño interfaz cita: “las personas tienen muy poca paciencia con los sitios web mal diseñados.” jakob nielsen annette agner (-).indd (-).indd // ::// :: diseño interfaz usuario una interfaz bien diseñada mejora percepción que tenga usuario del contenido los servicios provistos por sitio. necesita ser espectacular, pero siempre debe estar bien -tructurada con ergonomía apropiada. .. flujo trabajos para diseño interfaz webapp comenzar este capítulo, dijo que diseño interfaz usuario comienza con iden-tificación los requerimientos del usuario, tarea los elementos ambientales. una vez identificadas las tareas del usuario, crean analizan los escenarios del usuario (casos uso) con objeto definir conjunto objetos acciones interfaz. información contenida los formatos del modelo requerimientos son base para creación una distribución pantalla que ilustre diseño gráfico ubicación los iconos, definición texto descriptivo pantalla, así como especificación apilamiento las ventanas los temas mayores menores del menú. después utilizan las herramientas para hacer prototipos implementar definitiva modelo diseño interfaz. las tareas que siguen representan flujo trabajo rudimentario para diseñar una interfaz para webapp: . revisar información contenida modelo requerimientos refinarla según equiera. . desarrollar esquema aproximado distribución interfaz para webapp. como parte actividad modelación los requerimientos, tal vez haya desarrollado prototipo interfaz (incluida distribución). existe distribución, debe revisarse refinarse como requiera. hubiera desarrollado distribución interfaz, debe trabajarse con los participantes para hacerlo este momento. figura . presenta una primera distribución esquemática. . mapear los objetivos del usuario acciones específicas interfaz. para gran mayoría webapps, usuario tendrá conjunto objetivos primarios relativa- mente pequeño. éstos deben mapearse acciones específicas interfaz, como muestra figura .. esencia, debe responderse pregunta siguiente: “¿cómo hace interfaz para que usuario logre cada objetivo?” . definir conjunto tareas usuario asociadas con cada acción. cada - ción interfaz (por ejemplo, “comprar producto”) asocia con conjunto lista los objetivos del usuario objetivo # objetivo # # # # objetivo # menú navegaciónbarra menú con las funciones principales gráﬁco, logotipo nombre compañía gráﬁco copia texto página inicialfigura . mapeo los objetivos del usuario acciones interfaz (-).indd (-).indd // ::// :: parte dos modelado tareas usuario. éstas identificaron durante modelación los requerimientos. durante diseño deben mapearse interacciones específicas que incluyan los aspec- tos navegación, objetos contenido funciones webapp. . elaborar guión las imágenes pantalla para cada acción inter- . medida que considera cada acción, debe crearse una secuencia imágenes del guión (imágenes pantalla) fin ilustrar manera que responde -terfaz interacción con usuario. deben identificarse los objetos contenido (aun-que todavía hayan diseñado desarrollado). deben mostrarse las funciones webapp indicarse los vínculos navegación. . refinar distribución interfaz los guiones con entradas del diseño estética. mayor parte casos, lector será responsable hacer distri-bución aproximada elaborar los guiones, pero aspecto estético sensación que genere sitio comercial importante con frecuencia desarrollada por artista, más que por profesionales técnicos. diseño estética (véase capítulo ) - tegra con trabajo realizado por diseñador interfaz. . identificar los objetos interfaz usuario requeridos para implementar interf . esta tarea quizá requiera buscar una biblioteca objetos existen- tes para encontrar aquellos (clases) que sean reutilizables apropiados para interfaz webapp. además, este momento especifican cualesquiera clases personali- zadas. . desarrollar una representación del procedimiento interacción del usua- rio con interf . esta tarea opcional utiliza diagramas uml secuencia diagra- mas actividades (véase apéndice ) fin ilustrar flujo actividades ( deci- siones) que tienen lugar cuando usuario interactúa con webapp. . desarrollar una representación del comportamiento interfaz. esta opción tarea emplea diagramas estado uml (apéndice ) para representar transiciones estado los eventos que las causan. definen los mecanismos control (tales como los objetos acciones que dispone usuario para modificar estado una webapp). . describir distribución interfaz para cada estado. con uso infor- mación diseño desarrollada las tareas , asocia una distribución específica imagen pantalla cada estado webapp descrito tarea . . refinar revisar modelo del diseño interfaz. revisión interfaz debe centrarse usabilidad. importante observar que conjunto definitivo tareas que elijan debe adaptarse los requerimientos especiales aplicación que elaborar . . valuación del diseño una vez que crea prototipo operativo interfaz usuario, debe evaluarse con objeto determinar satisfacen las necesidades éste. evaluación abarca espectro forma-lidad que desde una “prueba manejo” informal, que usuario retroalimentación instantánea estudio diseñado formalmente que utilice métodos estadísticos para evaluar cuestionarios que respondería una población usuarios finales. ciclo evaluación interfaz usuario toma forma que aprecia figura .. una vez terminado modelo del diseño, crea prototipo primer nivel. éste evaluado (-).indd (-).indd // ::// :: diseño interfaz usuario por usuario, quien hace comentarios directos acerca eficacia interfaz. además, emplean técnicas formales evaluación (tales como cuestionarios, hojas calificación, etc.), las que extrae información (por ejemplo: por ciento todos los usuarios gusta mecanismo para guardar archivos datos). las modificaciones del diseño hacen con base las aportaciones los usuarios, así crea siguiente nivel prototipo. ciclo evaluación continúa hasta que necesario modificar más diseño interfaz. enfoque del prototipo eficaz, pero ¿ posible evaluar calidad una interfaz usua- rio antes que construya prototipo? identifican corrigen tiempo los problemas potenciales, reducirá número bucles ciclo evaluación disminuirá tiempo desarrollo. hubiera creado modelo del diseño interfaz, aplicarían los siguientes criterios evaluación [mor] durante las primeras revisiones éste: . longitud complejidad del modelo requerimientos especificaciones escritas del sistema interfaz darán una indicación cantidad aprendizaje requerido por los usuarios del sistema. . número tareas del usuario especificadas número promedio acciones por - rea indicarán tiempo interacción eficiencia general del sistema. . número acciones, tareas estados del sistema indicados por modelo del diseño implicarán carga memoria para los usuarios del sistema. . estilo interfaz, las herramientas ayuda protocolo del manejo errores darán una indicación general complejidad interfaz grado acepta- ción por parte del usuario. una vez construido prototipo, reúnen varios datos cualitativos cuantitativos que ayu- den evaluar interfaz. para obtener los datos cualitativos, distribuyen cuestionarios los usuarios del prototipo. las preguntas pueden ser: ) respuesta simple , , ) respuesta importante observar que los expertos ergonomía diseño interfaces también son quienes revisan éstas. las revisiones denominan evaluaciones heurísticas recorridos cognitivos.construir prototipo número interfaz diseñador estudia interfazel usuario evalúa interfazse realizan las modiﬁcaciones del diseñoconstruir prototipo número interfazdiseño preliminar diseño interfaz queda terminadofigura . ciclo evaluación del diseño interfaz (-).indd (-).indd // ::// :: parte dos modelado numérica, ) escala (subjetiva), ) escalas aprobación (completamente acuerdo, acuerdo), ) respuesta porcentual (subjetiva) ) respuesta abierta. desea obtener datos cuantitativos, puede llevarse cabo alguna forma estudio tiempos. observa los usuarios durante interacción obtienen datos —tales como -mero tareas terminadas correctamente periodo tiempo estándar, frecuencia las acciones, secuencia éstas, tiempo dedicado “mirar” pantalla, número tipos errores, tiempo recuperación del error, tiempo dedicado usar ayuda número referencias por periodo tiempo estándar— que utilizan como guía para modificación interfaz. análisis completo los métodos evaluación interfaz usuario queda más allá del alcance este libro. para mayor información, consulte [hac] [sto]. . esumen interfaz usuario presumiblemente elemento más importante sistema pro-ducto basado computadora. interfaz estuviera mal diseñada, afectaría mucho capa-cidad del usuario aprovechar poder computacional contenido información una aplicación. realidad, una interfaz defectuosa haría que fallara incluso una aplicación bien diseñada con buena implementación. son tres los principios importantes que guían diseño interfaces eficaces: ) dar control usuario, ) reducir memorización del usuario ) hacer que interfaz sea consistente. para lograr que una interfaz cumpla estos principios, debe llevarse cabo proceso diseño bien organizado. desarrollo una interfaz usuario comienza con una serie tareas análisis. aná- lisis del usuario define los perfiles distintos usuarios finales proviene varias fuentes -merciales técnicas. análisis tarea define las tareas acciones del usuario por medio enfoque elaboración bien otro orientado objetos, aplicación casos uso, ela-boración tareas objetos, análisis del flujo trabajo representaciones jerárquicas tarea para entender bien interacción humano-computadora. análisis ambiental identifica las estructuras físicas sociales las que debe operar interfaz. una vez definidas las tareas, crean analizan escenarios usuario para definir con- junto objetos acciones interfaz. esto una base para creación distribución pantalla que ilustre diseño gráfico colocación los iconos, definición texto descriptivo pantalla, especificación apilamiento las ventanas especificación los temas principales secundarios del menú. medida que refina modelo del diseño, consideran aspectos tales como tiempo respuesta, estructura comandos acciones, -nejo errores herramientas ayuda. para construir prototipo fin que evalúe usuario, utilizan varias herramientas implementación. igual que diseño interfaz para software convencional, correspondiente webapps describe estructura organización interfaz usuario incluye una representación distribución pantalla, definición los modos interacción descripción -canismos navegación. conjunto principios diseño interfaz del flujo los trabajos respectivos guía diseñador webapp cuando hace distribución cuando diseña los mecanismos control interfaz. interfaz usuario ventana hacia software. muchos casos, moldea percep- ción del usuario respecto calidad del sistema. “ventana” está manchada, ondulante rota, usuario puede rechazar sistema basado computadora que, demás, sería poderoso. (-).indd (-).indd // ::// :: diseño interfaz usuario problemas puntos por evaluar .. describa peor interfaz con que haya trabajado haga una crítica los conceptos introducidos este capítulo. describa mejor interfaz con que haya laborado critíquela respecto los conceptos estudiados aquí. .. desarrolle dos principios diseño adicionales que “den control usuario”... elabore dos principios diseño adicionales que “reduzcan necesidad memorización por parte del usuario”. .. enuncie otros dos principios diseño que “hagan consistente interfaz”... considere una las siguientes aplicaciones interactivas ( una aplicación asignada por profesor): ) sistema publicación escritorio ) sistema diseño asistido por computadora ) sistema diseño interiores (como descrito sección ..) ) sistema automatizado inscripción materias para una universidad ) sistema administración biblioteca ) encuestas basadas internet para elecciones públicas ) sistema banca casa ) aplicación interactiva asignada por profesor desarrolle los modelos usuario, del diseño, mental implementación para cualquiera dichos siste- mas. .. haga análisis detallado las tareas para alguno los sistemas enlistados problema .. utilice enfoque elaboración orientado objetos. .. agregue menos cinco preguntas adicionales lista desarrollada para análisis del contenido sección ... .. continúe problema . defina los objetos acciones interfaz para aplicación que haya elegido. identifique cada tipo objeto. .. desarrolle conjunto distribuciones pantalla con definición los temas principales - cundarios del menú para sistema que haya escogido problema .. .. desarrolle varias distribuciones pantalla con definición los temas menú principales secundarios para sistema casasegura. puede elegir enfoque distinto del que muestra figura .. .. describa enfoque las herramientas ayuda para usuario fin hacer modelo del diseño del análisis tareas análisis tarea que haya realizado como parte los problemas . .. .. algunos ejemplos que ilustren por qué variabilidad del tiempo respuesta llega ser impor- tante. .. desarrolle enfoque que integre manera automática los mensajes error las herramientas ayuda para usuario. decir, sistema reconocerá automáticamente tipo error dará una ventana ayuda con sugerencias para corregirlo. realice diseño del software razonablemente completo que tome cuenta las estructuras los datos algoritmos. .. elabore cuestionario evaluación interfaz que contenga preguntas generales que apliquen mayoría interfaces. haga que respondan sus compañeros para sistema interac-tivo que todos utilicen. resuma los resultados haga informe para grupo. lecturas adicionales fuentes información aunque este libro trata específicamente las interfaces humano-computadora, gran parte que afirma donald norman (the design everyday things , reimpresión, currency/doubleday, ) sobre psicología del diseño eficaz aplica interfaz usuario. recomienda lectura cualquier persona que piense hacer diseño una interfaz alta calidad. (-).indd (-).indd // ::// :: parte dos modelado las interfaces usuario gráficas son ubicuas mundo moderno computación. trate cajero automático, teléfono inalámbrico, tablero electrónico automóvil, sitio web aplicación - gocios, interfaz usuario constituye una ventana hacia software. por esta razón, abundan los libros que abocan diseño interfaz. butow ( user interface design for mere mortals , addison-wesley, ), galitz (the essential guide user interface design, . ., wiley, ), lehikonen . ( personal content experience: managing digital life the mobile age , wiley-interscience, ), cooper . ( about face : the essentials interaction design, . ., wiley, ), ballard (designing the mobile user experience , wiley, ), nielsen (coordinating user interfaces for consistency , morgan-kauffamn, ), lauesen ( user interface design: software engineering perspective, addison-wesley, ), barfield (the user interface: concepts and design, bosko books, ) son textos que analizan usabilidad, los conceptos interfaz usuario, principios técnicas diseño, que también contienen ejemplos útiles. los libros más antiguos beyer hontzblatt ( contextual design: customer centered approach systems design, morgan-kauffman, ), raskin (the human interface, addison-wesley, ), constantine loc- kwood (software for use, acm press, ) mayhew (the usability engineering lifecycle, morgan-kauffman, ) presentan análisis que dan lineamientos principios diseño adicionales, así como sugerencias para recabar requerimientos interfaz, modelación diseño, implementación prueba. johnson (gui bloopers: don’ and ’ for software developers and web designers, morgan-kauffman, ) ofrece una guía útil para aquellos que aprenden mejor con estudio contraejemplos. libro ameno escrito por cooper ( the inmates are running the asylum , sams publising, ) analiza por qué los productos alta tecnología nos desconciertan cómo diseñarlos para que hagan. existe una amplia variedad fuentes información sobre diseño interfaz disponibles inter- net. sitio web del libro, hay una lista actualizada referencias red mundial que son relevantes para diseño interfaz usuario; dirección : (-).indd (-).indd // ::// :: basado patrones conceptos clave errores diseño . . . . . . . . estructuras . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . usuario . . . . . . . del patrón . . . . . . arquitectónicos . . . . . . . . . . conductuales . . . . . . . . . . creacional . . . . . . . . . . . . estructural . . . . . . . . . . . generativo . . . . . . . . . . . nivel componentes . . . webapps . . . . . . . . . . . . . . ¿qué ? diseño basado patrones crea una aplicación nueva, encontrando conjunto soluciones comprobadas para conjun- problemas delineado con claridad. cada problema solución está descrito por patrón diseño catalogado analizado por otros ingenieros software que han encontrado problema implantado solución cuando diseñaban otras aplicaciones. cada -trón diseño provee enfoque demostrado para una parte del problema que debe resolverse. ¿quién hace? ingeniero software estudia cada problema hallado para una nueva aplicación después trata encontrar una solución relevante, buscando depósito patrones. ¿por qué importante? ¿ escuchado lector frase “reinventar rueda”? eso pasa todo tiempo desarrollo software representa una pérdida tiempo energía. utilizar patrones diseño existentes, -quiere una solución probada para problema específico. medida que aplica cada patrón, las soluciones integran aplicación que elaborar acerca más diseño final.¿cuáles son los pasos? modelo requerimientos estudia con objeto despejar conjunto jerárquico problemas por resolver. divide espacio problemas modo que sea posible identificar subconjuntos pro-blemas asociados con funciones específicas del software. los problemas también pueden organizarse por tipo: arquitectónicos, nivel componentes, algorítmicos, interfaz usuario, etcétera. una vez definido sub-conjunto problemas, busca uno más depósitos patrones fin determinar existe patrón diseño previo representado nivel abstracción apropiado. los patrones aplicables adaptan las necesidades espe-cíficas del software que elaborar. solución específica problemas aplica situaciones las que detectan patrones. ¿cuál producto final? desarrolla modelo del diseño que ilustra arquitectura del software, interfaz usuario los detalles nivel componentes. ¿cómo aseguro que hice bien? medida que cada patrón diseño traduce cierto elemento del modelo del diseño, revisan los productos del trabajo respecto claridad, corrección, completitud consis-tencia con los requerimientos con los demás patrones. una mirada rápidatodos hemos encontrado problema diseño pensamos silencio: pregunto alguien desarrollado una solución para esto… respuesta casi siempre . pro- blema encontrarla; luego, estar seguro que verdad ajusta problema cuestión, entender las limitaciones que restringen aplicación , por último, traducir solu-ción propuesta ambiente diseño. pero, ¿qué pasaría solución estuviera codificada algún modo? ¿qué ocurriría - biera una manera estandarizada describir problema ( modo que destacara) método organizado para representar solución? con empleo formato estándar, puede obser-varse que los problemas software han sido codificados descritos, igual que las soluciones ( sus restricciones) propuestas. este método codificado denomina patrones diseño , emplea para describir problemas sus soluciones permite que comunidad ingeniería software aborde conocimiento diseño forma tal que posible reutilizarlo. historia los patrones software comienza con científico computación, sino con arquitecto constructor, christopher alexander, quien reconoció que siempre que -señaba edificio era reconocible conjunto problemas recurrentes. definió éstos sus soluciones como patrones, los describió del modo siguiente [ale]: cada patrón describe problema que ocurre una otra vez nuestro ambiente, luego describe núcleo solución forma tal que posible usarla millón veces sin elaborarla dos veces misma forma. (-).indd (-).indd // ::// :: parte dos modelado . atrones diseño patrón diseño caracteriza como “una regla tres partes que expresa una relación entre cierto contexto, problema una solución” [ale]. para diseño software, con- texto permite lector entender ambiente que reside problema qué solución sería apropiada dicho ambiente. conjunto requerimientos, incluidas limitaciones restric-ciones, actúan como sistema fuerzas que influyen manera que puede interpretarse problema este contexto cómo podría aplicarse con eficacia solución. para entender mejor estos conceptos, piense una situación que una persona debe viajar entre nueva york los ángeles. dicho contexto, viaje tendrá lugar dentro país industrializado (estados unidos), con empleo una infraestructura transporte (como carreteras, líneas aéreas ferrocarriles). sistema fuerzas que afecta forma que resuelve problema transporte incluye siguiente: cuán rápido quiere persona desde nueva york hasta los ángeles, viaje incluye paradas miradores, cuánto dinero pue- gastar persona, viaje está previsto para lograr propósito específico los vehículos personales que tiene disposición viajero. dadas estas fuerzas, puede definirse mejor problema (viajar nueva york los ángeles). por ejemplo, las investigaciones (recabar reque-rimientos) indican que persona tiene muy poco dinero, posee sólo una bicicleta ( -clista entusiasta), quiere hacer viaje fin reunir dinero para sus obras caridad favoritas dispone mucho tiempo. solución problema, dado contexto sistema fuerzas, viaje bicicleta campo traviesa. las fuerzas fuesen distintas (debe minimizarse tiempo recorrido propósito asistir una reunión negocios), será más apropiada otra solución. razonable afirmar que mayoría problemas tienen muchas soluciones, pero sólo eficaz aquella que resulta apropiada contexto del problema existente. sistema fuerzas que hace que diseñador elija una solución específica. objetivo proporcionar que satisfaga mejor sistema fuerzas, aun cuando éstas sean contradictorias. por último, toda solución tiene consecuencias que afectan otros aspectos del software que vuelven parte del sistema fuerzas otros problemas por resolver sistema mayor. coplien [cop] caracteriza patrón diseño eficaz del modo siguiente: • resuelve problema: los patrones entrañan soluciones, sólo principios estrategias abs- tractas. • concepto probado: los patrones incluyen soluciones con historial, teorías espe-culaciones. • solución obvia: muchas técnicas solución problemas (como los paradigmas métodos diseño software) tratan obtener soluciones partir sus principios origi-nales. los mejores patrones generan indirectamente una solución problema, enfoque necesario para los problemas más difíciles del diseño. • describe una relación: los patrones sólo describen módulos, sino estructuras mecanis-mos más profundos del sistema. existen análisis anteriores los patrones software, pero estos dos libros clásicos fueron los primeros que dieron tratamiento cohesivo tema. este ejemplo adaptó [cor].las ideas alexander fueron traducidas por vez primera mundo del software los libros gamma [gam], buschmann [bus] muchos sus colegas. actualmente, existen dece- nas depósitos patrones diseño basado patrones emplea muchos dominios diferentes aplicación. cita: “nuestra responsabilidad hacer que podamos, aprender que pueda, mejorar las soluciones transmitirlas.” richard . feynmanpunto clave las fuerzas son aquellas características del problema los atributos solución que restringen forma que puede desarrollarse diseño. (-).indd (-).indd // ::// :: diseño basado patrones • patrón tiene componente humano significativo (minimiza intervención humana). todo software sirve para confort humano calidad vida; los mejores patrones recurren -plícitamente estética utilidad. dicho forma más clara, buen patrón diseño incorpora conocimiento diseño prag- mático, ganado con dificultad, una forma que permite que otros reutilicen “ millón veces sin elaborarla dos veces misma forma”. patrón diseño evita “reinventar rueda” , peor aún, inventar una “nueva rueda” que sea poco menos redonda, demasiado pequeña para uso que pretende muy angosta para terreno que rodará. usan con eficacia, los patrones diseño invariablemente harán del lector buen diseñador software. .. clases patrones una las razones por las que los ingenieros software están interesados ( intrigados) por los patrones diseño que los seres humanos son inherentemente buenos para reconocer patrones. fuera así, estaríamos congelados tiempo espacio: seríamos incapaces aprender nuestras experiencias, sin voluntad para más lejos debido que nuestra inca-pacidad reconocer situaciones nos haría correr grandes riesgos, estaríamos desarticulados por mundo que parecería tener regularidades consistencia lógica. por suerte, nada esto sucede debido que reconocemos patrones virtualmente todos los aspectos nuestras vidas. mundo real, los patrones que reconocemos los aprendemos tiempo que dura nuestra vida. los reconocemos instante comprendemos inherentemente que significan cómo podemos usarlos. algunos estos patrones nos permiten detectar fenómenos recurren-tes. por ejemplo, imagine que camino casa desde trabajo, por autopista, cuando sistema navegación ( radio) informa que dirección opuesta ocurrió serio acci-dente. encuentra siete kilómetros del accidente, pero vio que tráfico hace lento, reconoce patrón que llamamos cuellodebotella. las personas que están los carriles dirección que sigue usted disminuyen velocidad para ver que pasó lado opuesto carretera. patrón cuellodebotella produce resultados predecibles (embotellamiento), pero hace nada más que describir fenómeno. habla los patrones, éste sería patrón generativo debido que describe contexto problema, pero ofrece ninguna solución clara. cuando toman cuenta los patrones diseño software, intenta identificar los patrones generativos. decir, identifica patrón que describa aspecto importante - petitivo sistema, que provea una manera construir dicho aspecto dentro sis-tema fuerzas que son únicas contexto determinado. idealmente, podría usarse conjunto patrones diseño generativos para “generar” una aplicación sistema basado computadora cuya arquitectura permita adaptarlo cambio. ocasiones llama generativi- dad “ aplicación sucesiva varios patrones, cada uno los cuales incluye propio pro- blema fuerzas, que despliega una solución más grande que emerge indirectamente como resultado soluciones más pequeñas” [app]. los patrones diseño abarcan amplio espectro abstracción aplicaciones. los patro- nes arquitectónicos describen problemas diseño base amplia que resuelven con -pleo enfoque estructural. los patrones datos describen problemas recurrentes orienta- dos datos las soluciones modelado datos que pueden emplearse para resolverlos. los patrones componentes (también llamados patrones diseño) enfocan problemas asocia- dos con desarrollo subsistemas componentes, así como manera que comu-nican entre ubicación dentro una arquitectura mayor. los patrones diseño - terfaz describen problemas comunes interfaz usuario solución con sistema fuerzas que incluye las características específicas los usuarios finales. los patrones webapp punto clave patrón “generativo” describe problema, contexto las fuerzas, también una solución práctica para problema. (-).indd (-).indd // ::// :: parte dos modelado enfrentan conjunto problemas que surgen cuando elaboran webapps frecuente que incorporen muchas las otras categorías patrones mencionadas. nivel abstracción más bajo, los idiomas describen forma implementar todo algoritmo específico una parte , bien una estructura datos, para componente software contexto lenguaje programación específico. libro fundamental sobre patrones diseño, gamma . [gam] centran tres tipos patrones relevancia especial para diseño orientado objetos: patrones creaciona-les, estructurales conductuales. los patrones creacionales centran “creación, composición representación” obje- tos. gamma . [gam] hacen observación que los patrones creacionales “encierran conocimiento acerca cuáles son las clases concretas que usa sistema”, pero mismo tiempo “ocultan forma que las instancias dichas clases crean agrupan”. los -trones creacionales ofrecen mecanismos que hacen más fácil formación las instancias los objetos dentro sistema establecen “restricciones tipo número objetos que posible crear dentro sistema” [maa].¿hay alguna forma clasificar los tipos patrones?? bibliografía sobre patrones, gamma . [gam] son llamados con frecuencia “ banda los cuatro” (gof, por sus siglas inglés). red mundial hay una amplia variedad patrones diseño que ajustan las categorías creacional, estructural conductual. wikipedia ( encuentran los siguientes ejemplos: patrones creacionales • patrón fábrica abstracta: centraliza decisión acerca para qué fábrica deben hacerse instancias. • patrón método fabricación: centraliza creación objeto tipo específico para elegir una entre varias implemen-taciones. • patrón constructor: separa construcción objeto com-plejo partir representación, modo que mismo proceso construcción pueda crear representaciones distintas. • patrón prototipo: usa cuando costo inherente que implica crear nuevo objeto forma estándar (como con empleo una “nueva” clave) prohibitivo para una aplicación dada. • patrón instancia única: restringe formación instan-cias una clase objeto. patrones estructurales • patrón adaptador: “adapta” una interfaz para una clase otra que espera cliente. • patrón agregado: una versión del patrón compuesto con métodos para agregar hijos. • patrón puente: desacopla una abstracción imple-mentación, modo que las dos puedan variar forma indepen-diente. • patrón compuesto: estructura árbol objetos los que cada uno tiene misma interfaz.• patrón contenedor: crea objetos con único propósito que sostengan otros los administren. • patrón proximidad: clase que funciona como interfaz res-pecto otra cosa. • tubos filtros: cadena procesos los que salida cada uno entrada del siguiente. patrones conductuales • cadena patrones responsabilidad: objetos comando que son manejados pasados otros objetos por medio otros que contienen procesamiento lógico. • patrón comando: objetos comando que encierran una acción sus parámetros. • escucha eventos: distribuyen datos objetos registrados para recibirlos. • patrón intérprete: implementa lenguaje computadora especializado para resolver con rapidez conjunto específico problemas. • patrón iterador: los iteradores utilizan para acceder forma secuencial los elementos agregado sin exponer representación subyacente. • patrón mediador: proporciona una interfaz unificada conjunto interfaces subsistema. • patrón visitante: forma separar algoritmo objeto. • patrón visitante solo servicio: optimiza imple- mentación visitante que haya asignado, utilizado sólo una vez luego eliminado. • patrón visitante jerárquico: brinda una forma visitar cada nodo una estructura jerárquica datos, como árbol. las descripciones detalladas estos patrones pueden obtenerse por medio vínculos patrones creacionales, estructurales conductuales (-).indd (-).indd // ::// :: diseño basado patrones los patrones estructurales centran problemas soluciones asociados con manera que organizan integran las clases objetos para construir una estructura más grande. esencia, ayudan establecer relaciones entre entidades dentro sistema. por ejemplo, los patrones estructurales que centran aspectos orientados clases proporcionan mecanis-mos herencia que conducen interfaces programa más eficaces. los patrones estructu-rales que centran objetos sugieren técnicas para combinar objetos dentro otros objetos para integrarlos una estructura más amplia. los patrones conductuales enfocan problemas asociados con asignación responsa- bilidad entre los objetos manera que efectúa comunicación entre ellos. .. estructuras los patrones mismos podrían ser suficientes para desarrollar diseño completo. ciertos casos, tal vez sea necesario dar esqueleto una infraestructura específica para implementación, llamada estructura, para trabajo diseño. decir, puede seleccionarse una “miniarquitectura reutilizable que provea estructura comportamiento generales para una - milia abstracciones software, así como contexto […] que especifique colaboración uso dominio determinado” [amb]. una estructura patrón arquitectónico, sino esqueleto con varios “puntos - nexión” (también llamados ganchos ranuras ) que permiten adaptarlo dominio pro- blema específico. los puntos conexión permiten integrar clases funciones específicas problema dentro del esqueleto. contexto orientado objetos, una estructura conjunto clases que cooperan. gamma . [gam] describen manera siguiente las diferencias entre los patrones diseño las estructuras: . los patrones diseño son más abstractos que las estructuras. las estructuras están incrustadas código, pero éste sólo posible incrustar ejemplos patrones. una ventaja las estruc- turas que escriben lenguajes programación sólo son estudiadas, sino ejecutadas reutilizadas directamente […] . los patrones diseño son elementos arquitectónicos más pequeños que las estructuras. una estruc- tura normal contiene varios patrones diseño, pero contrario nunca cumple. . los patrones diseño están menos especializados que las estructuras. las estructuras siempre tie- nen dominio particular aplicación. contraste, los patrones diseño usan casi cualquier tipo aplicación. bien posible tener patrones diseño más especializados, -cluso éstos imponen arquitectura una aplicación. esencia, diseñador una estructura afirmará que una miniestructura reutilizable apli- cable todo software por desarrollarse dominio limitado aplicación. para ser más eficaces, las estructuras aplican sin cambio. pueden agregarse otros elementos diseño, pero sólo través los puntos conexión que permiten que diseñador modifique esque-leto estructura. .. descripción patrón diseño basado patrones comienza con reconocimiento patrones aplicación que trata construir, continúa con una búsqueda para determinar otros han usado patrón termina con aplicación patrón apropiado para problema que trate. fre-cuente que segunda sea tarea más difícil. ¿cómo encuentran patrones que ajusten las necesidades? una respuesta esta pregunta debe basarse comunicación eficaz del problema que dirige patrón, contexto que reside ése, sistema fuerzas que moldean con-punto clave una estructura una “miniarquitectura” reutilizable que sirve como base desde que pueden aplicar otros patrones diseño. (-).indd (-).indd // ::// :: parte dos modelado texto solución propuesta. para comunicar esta información sin ambigüedades, requiere formato plantilla estándar del documento. aunque han propuesto varios formatos dife-rentes patrones, casi todos contienen conjunto importante del contenido sugerido por gamma . [gam]. recuadro presenta formato simplificado patrón. christopher alexander originalmente propuso lenguajes patrón para construir arquitecturas hacer planea- ción urbana. actualmente, han desarrollado lenguajes patrón para todo, desde las ciencias sociales hasta proceso ingeniería software. esta descripción wikipedia encuentra dirección http://.wikipedia.org/wiki/pattern_lan- guage.nombre del patrón: describe esencia del patrón con nombre corto pero expresivo problema: describe problema que dirige patrónmotivación: proporciona ejemplo del problemacontexto: describe ambiente que reside problema, incluido dominio aplicación fuerzas: lista sistema fuerzas que afectan manera que debe resolverse problema; incluye análisis las limitaciones restricciones que deben ser tomadas cuenta solución: hace descripción detallada solución propuesta para problema objetivo: describe patrón que hacecolaboraciones: describe manera que otros patrones contri- buyen solución consecuencias: describe los intercambios potenciales que deben ser considerados cuando implementa patrón, las conse-cuencias usar éste implementación: identifica los aspectos especiales que deben conside- rarse cuando implemente patrón usos conocidos: ejemplos usos reales del patrón diseño aplicaciones reales patrones relacionados: menciona referencias patrones diseño relacionadosinformación formato diseño del patrón los nombres los patrones diseño deben escogerse con cuidado. uno los problemas técnicos clave diseño basado patrones incapacidad encontrar los existentes entre cientos miles candidatos. búsqueda del patrón “correcto” simplifica muchísimo con nombre significativo para patrón. formato del patrón medio estandarizado para describir patrón diseño. cada una sus entradas representa características del patrón diseño que pueden ser buscadas ( una base datos, por ejemplo) fin encontrar que sea apropiado. .. lenguajes repositorios patrones cuando utiliza término lenguaje, primero que viene mente lenguaje natural (como inglés, español chino) uno programación (como ++ java). ambos casos, lenguaje tiene una sintaxis semántica que utiliza para comunicar ideas instrucciones procedimiento forma eficaz. cuando emplea término lenguaje contexto los patrones diseño, adopta significado poco distinto. lenguaje patrón agrupa conjunto patrones, cada uno los cuales describe con uso formato estandarizado (véase sección ..) interrelacionado para mostrar cómo colaboran los patrones para resolver problemas -minio aplicación. lenguaje natural, las palabras están organizadas oraciones que dan significado. estructura las oraciones descrita por sintaxis del lenguaje. lenguaje patrón, los patrones diseño están organizados forma tal que proporcionan “método estructu-rado para describir las buenas prácticas diseño dominio particular”. : “los patrones siempre están medio cocinar, que significa que siempre deben ser termina-dos adaptados ambiente específico por usuario.” martin fowler (-).indd (-).indd // ::// :: diseño basado patrones cierta forma, lenguaje patrones análogo manual instrucciones hiper- texto para resolver problemas dominio específico aplicaciones. dominio del pro- blema cuestión primero describe manera jerárquica, comenzando con problemas diseño amplio asociados con dominio, luego refina cada uno ellos niveles abs-tracción más bajos. contexto software, los problemas diseño amplio tienden ser naturaleza arquitectónica abocan estructura general aplicación los datos contenido que dan servicio. los problemas arquitectónicos mejoran hacia niveles más bajos abstracción, que conduce patrones diseño que resuelven los subproblemas que colaboran entre nivel componentes ( clases). vez que lenguaje patrones represente una lista secuencial patrones, hace con conjunto interconectado que usuario comienza con problema diseño amplio “ presta” problemas -pecíficos descubiertos, así como sus soluciones. han propuesto decenas lenguajes patrones para diseño software [hil]. mayor parte casos, los patrones diseño que forman parte lenguaje patrones almacenan repositorio patrones accesible través web (consulte [boo], [cha] [hpr]). repositorio proporciona índice todos los patrones diseño contiene vínculos hipermedios que permiten usuario entender las colaboraciones entre patrones. . iseño software basado patrones los mejores diseñadores cualquier campo tienen una aptitud asombrosa para ver los patro-nes que caracterizan problema los que pueden combinarse para generar una solución. los desarrolladores software microsoft [mic] dicen del siguiente modo: bien diseño basado patrones relativamente nuevo campo del desarrollo software, tecnología industrial utilizado durante décadas, quizá siglos. los catálogos mecanismos configuraciones estándar proporcionan elementos diseño utilizados para hacer ingeniería automóviles, aviones, máquinas herramienta robots. aplicación del diseño basado patrones desarrollo software promete éste los mismos beneficios que tiene tecnología industrial: ser predecible, disminuir riesgo aumentar productividad. través del proceso diseño, debe buscarse toda oportunidad para aplicar los patrones diseño existentes (cuando cumplan las necesidades del diseño), vez crear otros nuevos. .. diseño basado patrones, contexto diseño basado patrones utiliza vacío. los conceptos técnicas analizados para diseño arquitectónico, nivel componentes interfaz usuario (capítulos ), utilizan junto con enfoque basado patrones. capítulo dijo que conjunto lineamientos atributos calidad emplean como base para tomar todas las decisiones del diseño software. éstas reciben influencia conjunto conceptos fundamentales del diseño (como separación problemas, -jora por etapas, independencia funcional, etc.) que logran con uso heurísticos que han evolucionado largo muchas décadas, así como las mejores prácticas (tales como las técnicas notación modelos) que han propuesto para hacer que diseño sea más fácil realizar que tenga más eficacia como base para construcción. figura . ilustra papel que juega todo esto diseño basado patrones. diseñador software comienza con modelo requerimientos (explícito implícito) que muestra una representación abstracta del sistema. modelo requerimientos describe conjunto problema, establece contexto identifica sistema fuerzas que actúan. tal vez implique sistema forma abstracta, pero modelo requerimientos hace poco para -presentar diseño explícitamente. puede encontrar lenguaje patrones que adapte dominio problema, busque analogías otro conjunto patrones.consejo webref para ver una lista lenguajes patrones útiles, consulte dirección .com/ppr/titles.html. además, hillside.net/patterns/ encuentra información adicional respecto. (-).indd (-).indd // ::// :: parte dos modelado cuando lector inicie trabajo como diseñador, importante que recuerde los atributos calidad. éstos (por ejemplo, diseño debe implementar todos los requerimientos explí- citos establecidos modelo los requerimientos) fijan una forma evaluar calidad del software, pero son mucha ayuda para lograrlos realidad. diseño que cree debe tener los conceptos fundamentales del diseño analizados capítulo . entonces, deben aplicarse técnicas probadas para traducir las abstracciones contenidas modelo reque-rimientos una forma más concreta, que diseño del software. para lograr esto, usarán los métodos herramientas modelado disponibles para diseño arquitectónico, nivel componentes interfaz, pero sólo cuando enfrente problema, contexto siste- fuerzas que haya resuelto antes. existe una solución, ¡úsela¡ esto quiere decir aplicar enfoque del diseño basado patrones. .. pensar patrones libro excelente sobre diseño basado patrones, shalloway trott [sha] comentan acerca “nueva forma pensar” cuando utilizan patrones como parte actividad diseño: tuve que abrir mente una nueva forma pensar. cuando hice, escuché [christopher] alexander decir que “ buen diseño software logra sólo poniendo juntas las partes ejecu-toras”. buen diseño comienza con consideración del contexto: panorama. cuando evalúa contexto, extrae una jerarquía problemas que deben resolverse. algunos éstos serán naturaleza global, mientras que otros abocarán características funciones específi-cas del software. todo será afectado por las fuerzas del sistema que influirán naturaleza solución propuesta.comienza diseño considerar conceptos del diseñoextraer problema, fuerzas del contextomodelo los requerimientos considerar atributos calidad del diseño comenzar las tareas del diseño basado patrónaplicar otros métodos notación diseñosí ¿las describe patrón? modelo del diseñofigura . diseño basado patrones, contexto (-).indd (-).indd // ::// :: diseño basado patrones shalloway trott [sha] sugieren siguiente enfoque, que permite que diseñador piense patrones: . asegurarse entender panorama: contexto que encuentra software que elaborar . modelo requerimientos debe transmitir esa comprensión. . estudiar panorama, identificar los patrones presentes ese nivel abstracción. . comenzar diseño con patrones del “panorama” que establezcan contexto - queleto para trabajo diseño adicional. . “trabajar dentro del contexto” [sha] busca patrones niveles más bajos abstracción que contribuyan solución del diseño. . repetir los pasos hasta que diseño esté completo. . mejorar diseño, adaptando cada patrón las especificidades del software que trata elaborar . importante observar que los patrones son entidades independientes. los patrones - seño presentes nivel alto abstracción invariablemente influirán manera que otros patrones aplican niveles más bajos abstracción. además, frecuente que los patrones colaboren entre . esto implica que, cuando selecciona patrón arquitectónico, muy bien puede influir los patrones diseño nivel componentes que elijan. del mismo modo, cuando seleccione patrón diseño interfaz, veces obligatorio usar patrones que colaboren con . para ilustrar anterior, considere webapp casaseguraasegurada.com. considera panorama, webapp debe abordar cierto número problemas fundamentales: • cómo dar información acerca los productos servicios casasegura • qué manera vender los productos servicios casasegura los clientes • qué forma establecer vigilancia control sistema seguridad instalado que base internet. cada uno estos problemas fundamentales puede desglosarse aún más conjunto subproblemas. por ejemplo, cómo vender por internet implica patrón comercio electró- nico que mismo acarrea gran número patrones niveles abstracción más bajos. patrón comercioelectrónico (probablemente patrón arquitectónico) implica mecanis- mos para abrir una cuenta cliente, mostrar los productos que van vender, seleccionar los que van adquirir, etcétera. entonces, piensa patrones, importante determinar existe patrón para abrir una cuenta. dispone abrircuenta como patrón viable para contexto del problema, puede colaborar con otros patrones, tales como elaborarfor-matodeentrada, administrarformatosdeentrada validarformatosdeentrada. cada uno delinea problemas por resolver las soluciones que aplicarán. .. tareas diseño cuando utiliza una filosofía diseño basado patrones, llevan cabo las siguientes tareas: . examinar modelo equerimientos desarrollar una jerarquía del pro- blema. describir cada problema subproblema aislando problema, contexto sistema fuerzas que aplican. hay que trabajar desde los problemas amplios (nivel basado trabajo christopher alexander [ale]. diseño basado patrones parece interesante para problema que debo resolver. pero, ¿por dónde comienzo?? (-).indd (-).indd // ::// :: parte dos modelado abstracción elevado) hasta los subproblemas más pequeños (niveles más bajos abstracción). . determinar desarrollado lenguaje del patrón confiable para - minio del oblema. como dijo sección .., lenguaje del patrón - rige problemas asociados con dominio específico aplicación. equipo software casasegura buscaría lenguaje patrón desarrollado específicamente para productos para seguridad del hogar. encontrara ese nivel especificidad del lenguaje del patrón, equipo dividiría problema del software casasegura una serie dominios generales del problema ( vigilancia dispositivos digitales, -terfaz usuario, administración video digital) búsqueda lenguajes patrón apropiados. . partir problema amplio, determinar para mismo dispone uno más patr ones arquitectónicos. existe patrón arquitectónico, hay que asegurarse estudiar todos los patrones colaboradores. patrón apropiado, debe adaptarse solución del diseño propuesta elaborar elemento del modelo del diseño que represente forma adecuada. como dijo sección .., pro-blema amplio para webapp casaseguraasegurada.com aborda con patrón comercioelectrónico. éste sugerirá una arquitectura específica para enfrentar los - querimientos del comercio electrónico. . con uso colaboraciones provistas para patrón arquitectónico, deben estudiarse los oblemas nivel subsistema componente, buscar los patrones más apropiados para enfrentarlos. tal vez sea necesario buscar varios depósitos patrones, así como lista aquellos que correspondan -lución arquitectónica. encuentra patrón apropiado, hay que adaptar solución del diseño propuesta construir elemento del modelo del diseño que represente manera adecuada. hay que asegurarse aplicar paso . . repetir los pasos hasta que hayan resuelto todos los problemas - plios. esto implica comenzar con panorama general elaborarlo para resolver pro- blemas niveles cada vez más detallados. . los problemas diseño interfaz usuario han sido aislados (éste caso casi siempr ), buscar los muchos depósitos patrones diseño interfaz usuario para encontrar patrones apropiados. procede forma similar los pasos , . . sin importar nivel abstracción, resulta promisorio lenguaje - depósito patrones patrón individual, hay que comparar problema por resolver con patrón patrones presentados. debe asegurarse estudiar contexto las fuerzas para garantizar que patrón, efecto, una - lución factible para problema. . asegurarse refinar diseño medida que obtiene los patrones, con empleo criterios calidad como guía. unque este enfoque del diseño arriba abajo, las soluciones del diseño vida real veces son más complejas. gillis [gil] comenta respecto siguiente: los patrones diseño que manejan ingeniería software deben usarse forma deductiva racionalista. modo que cuando tiene problema requerimiento general patrón diseño resuelve , entonces utilice . pero cuando reflexiono propio proceso — tengo razones para pensar que soy único—, observo que más orgánico que eso, más inductivo que deductivo, más abajo hacia arriba que arriba abajo.¿cuáles son las tareas requeridas para crear diseño basado patrones?? (-).indd (-).indd // ::// :: diseño basado patrones enunciado del problema ...enunciado del problema ...enunciado del problema ...interfaz usuarioenunciado del problema ...enunciado del problema ...enunciado del problema ...nivel componentesenunciado del problema ...enunciado del problema ...enunciado del problema ...arquitecturaenunciado del problema ...enunciado del problema ...enunciado del problema ... nombre() del patrón nombre() del patrónnombre() del patrón nombre() del patrón nombre() del patrón nombre() del patrón nombre() del patrón nombre() del patrón nombre() del patrónnombre() del patrón nombre() del patrón nombre() del patrón nombre() del patrónnombre() del patrón nombre() del patrónnombre() del patrón nombre() del patrónnombre() del patrón nombre() del patrónnombre() del patrónbase datos datos/contenidoaplicación implementación infraestructuraes obvio que debe lograrse balance. cuando proyecto encuentra fase inicial trato dar salto los requerimientos abstractos una solución concreta del diseño, frecuente que tome aire para realizar una búsqueda [...] hallado que los patrones diseño son útiles, que permite enmarcar con rapidez problema diseño términos concretos. además, enfoque basado patrones debe usarse junto con otros conceptos técnicas diseño software. .. construcción una tabla para organizar patrón medida que avanza diseño basado patrones, quizá encuentren problemas para orga-nizar clasificar los candidatos que surjan múltiples lenguajes repositorios patrones. para ayudar organizar evaluación los patrones candidatos, microsoft [mic] sugiere crear una tabla organización patrones que tenga forma general que ilustra figura .. una tabla organizadora patrones puede implementarse como modelo hoja cálculo con uso del formato figura. columna izquierda (sombreada) está organizada por datos/contenido, arquitectura, nivel componentes aspectos interfaz usuario. renglón superior enlistan cuatro tipos patrón: base datos, aplicación, implementación infraestructura. las celdas tabla anotan los nombres los patrones que son can-didatos. para obtener las entradas tabla organizadora, busca lenguajes repositorios patrones que aborden enunciado particular del problema. cuando encuentra uno más patrones candidatos, introducen renglón correspondiente enunciado del pro-blema columna que corresponda tipo patrón. nombre del patrón introduce como hipervínculo hacia url dirección web que contenga descripción completa del patrón. .. errores comunes diseño diseño basado patrones hará mejor diseñador software, pero una panacea. igual que todos los métodos diseño, debe comenzarse con los primeros principios, con -las entidades que aparecen tabla pueden darse con una indicación aplicabilidad relativa del patrón.consejo figura . tabla organización patronesfuente: adaptadade [mic]. (-).indd (-).indd // ::// :: parte dos modelado fasis los fundamentos calidad del software aseguramiento que diseño satis- face las necesidades expresadas por modelo los requerimientos. cuando emplea diseño basado patrones, suelen ocurrir varios errores comunes. ciertos casos, dedica tiempo suficiente entender problema subyacente, contexto fuerzas, consecuencia elige patrón que parece correcto, pero inapropiado para llegar solución que requiere. una vez seleccionado patrón equivocado, renuen- reconocer error fuerza patrón para que ajuste. otros casos, problema tiene fuerzas que son consideradas por patrón escogido, que como resultado ajuste -ficiente erróneo. ocasiones aplica demasiado literalmente implementan las adaptaciones requeridas para espacio del problema. ¿ posible evitar estos errores? mayoría los casos respuesta . todo buen - señador busca una segunda opinión con buenos ojos revisión trabajo. las técnicas revisión que estudian capítulo ayudan garantizar que diseño basado -trones que haya obtenido como resultado una solución alta calidad para problema software que debe resolverse. . atrones arquitectónicos constructor vivienda decide edificar una estilo colonial con vestíbulo centro, sólo hay estilo arquitectónico que puede aplicarse. los detalles éste (como número chi-meneas, fachada, ubicación puertas ventanas, etcétera) variarán forma considerable; pero, una vez tomada decisión arquitectura general, estilo será impuesto por -seño. los patrones arquitectónicos son poco distintos. por ejemplo, toda vivienda ( todo estilo arquitectónico para ellas) emplea patrón cocina. éste aquéllos con los que colabora abor- dan problemas asociados con almacenamiento preparación comida, las herramientas que necesitan para realizar estas tareas las reglas para situarlas relación con flujo trabajo dicho espacio. además, patrón tal vez enfrente problemas asociados con -rras, iluminación, interruptores eléctricos, isla central, pisos, etc. obvio que hay más diseño para cocina, que dictado con frecuencia por contexto sistema fuerzas. pero todo diseño concibe contexto “solución” sugerida por patrón cocina. como dijo, los patrones arquitectónicos para software definen enfoque específico para manejo algunas características del sistema. bosch [bos] booch [boo] definen cierto número dominios del patrón arquitectónico. los párrafos siguientes describen ejemplos representativos: control acceso. hay muchas situaciones las que acceso datos, características funciones realizadas por una aplicación está limitado usuarios finales definidos específica-mente. desde punto vista arquitectónico, acceso cierta parte arquitectura del software debe controlarse manera rigurosa. concurrencia. muchas aplicaciones deben manejar tareas múltiples manera que simule paralelismo (esto ocurre , por ejemplo, siempre que solo procesador administra varias tareas componentes “paralelos”). hay varias formas distintas las que una aplicación maneja concurrencia cada una puede presentarse con patrón arquitectónico diferente. por ejemplo, enfoque consiste usar patrón administracióndeprocesosdelsistemaoperativo fuerce patrón, incluso aboca problema cuestión. contexto las fuerzas son los equivocados, busque otro patrón.consejo punto clave una arquitectura software puede tener cierto número patrones arquitectónicos que aboquen aspectos tales como concurrencia, persistencia distribución. ¿cuáles son algunos dominios comunes del patrón arquitectónico? ? esto implica que habrá atrio vestíbulo central, que las habitaciones estarán situadas izquierda derecha del atrio, que casa tendrá dos ( más) plantas, que las recámaras casa ubicarán planta alta, entre otras características. estas “reglas” son obligatorias una vez que toma decisión usar estilo colonial con vestíbulo central. (-).indd (-).indd // ::// :: diseño basado patrones que proporcione características incrustadas para que permitan que los componentes ejecuten manera concurrente. patrón también incorpora funcionalidad del que admi-nistra comunicación entre procesos, programación tareas otras capacidades que -quieren para lograr concurrencia. otro enfoque tal vez defina programador tareas nivel aplicación. patrón programadordetareas contiene conjunto objetos - tivos que cada uno estos incluye una operación tick () [bos]. programador invoca forma periódica tick () para cada objeto, que luego realiza las funciones que debe antes devolver control programador, que después hace invocación operación tick () para siguiente objeto concurrente. distribución. problema distribución aboca manera que los sistemas componentes los sistemas comunican entre ambiente distribuido. toman cuenta dos subproblemas: ) forma que conectan las entidades una con otra ) naturaleza comunicación que tiene lugar . patrón arquitectónico más común estable- cido para enfrentar problema distribución negociador. negociador actúa como “mediador” entre componente del cliente del servidor. cliente envía mensaje negociador (que contiene toda información apropiada para que efectúe comunicación) éste finaliza conexión. persistencia. los datos persisten sobreviven ejecución del proceso que los creó. los datos persistentes almacenan una base datos archivos que pueden ser leídos -dificados por otros procesos momento posterior . los ambientes orientados objetos, idea objeto persistente extiende poco más concepto persistencia. los valores todos los atributos del objeto, estado general éste otra información complementaria almacenan para recuperación uso futuro. general, emplean dos patrones arquitec-tónicos para lograr persistencia: patrón sistemadeadministracióndebasededatos que aplica capacidad almacenamiento recuperación sabd arquitectura patrón persistenciaaniveldeaplicación que construye las características persistencia red mundial hay muchas fuentes disponibles patrones diseño. algunos obtienen lenguajes patrón publicados forma individual, mientras que otros forman parte portal repositorio patrones. recomendable consul-tar los siguientes recursos web: hillside.net http://hillside.net/patterns/ una las colecciones más amplias patrones lenguajes patrón disponibles web. repositorio patrones portland http://.com/ppr/index.html contiene apuntadores hacia una amplia variedad recursos colecciones patrones. índice patrones http://.com/cgi/wiki?patternindex “colección ecléctica patrones”. manual patrones arquitectónicos booch architecture/index.jsp referencias bibliográficas cientos patrones arquitectónicos diseño componentes. colecciones patrones patrones /hci www .hcipatterns.org/patterns.html patrones jennifer tidwell diseño móviles http://patterns.littlespringsdesign.com/wikka. php?wakka=mobile patrones lenguaje patrones para diseño www .maplefish.com/todd/papers/experiences.html biblioteca diseño interactivo para juegos patrones diseño patrones diseño especializadoaviónica http://.oswego.edu//acs/acs/acs.html sistemas infor mación para negocios procesamiento distribuido ibm para comercio electrónico biblioteca patrones diseño yahoo! http://developer.yahoo.com/ypatterns/ webpatterns.org http://webpatterns.org/información repositorios patrones diseño (-).indd (-).indd // ::// :: parte dos modelado arquitectura aplicación (por ejemplo, software procesamiento textos que administre propia estructura documento). antes que pueda elegirse cualquiera los patrones arquitectónicos representativos men- cionados los párrafos anteriores, debe evaluarse apropiado que para aplicación estilo arquitectónico general, así como contexto sistema fuerzas que especifiquen. . atrones diseño nivel componentes los patrones diseño nivel componentes brindan soluciones comprobadas que abocan uno más subproblemas extraídos del modelo requerimientos. muchos casos, los patrones diseño este tipo centran algún elemento funcional sistema. por ejemplo, aplicación casaseguraasegurada.com debe resolver siguiente subproblema diseño: ¿cómo pueden obtenerse especificaciones del producto información acerca cualquier dispositivo casasegura? después enunciar subproblema que afecta solución, debe considerarse contexto sistema fuerzas que también afecten. estudiar modelo requerimientos apro-piados del caso uso, observa que consumidor utiliza especificación dispositivo casasegura (como sensor seguridad cámara) con propósitos información. sin embargo, cuando selecciona función comercio electrónico, quizá requiera otro tipo información relacionada con especificación (por ejemplo, precio). solución del subproblema involucra una búsqueda. como buscar problema muy común, sorprendente que haya muchos patrones relacionados con dicha tarea. inves-tigar varios repositorios patrones, encuentran los siguientes, así como problema que resuelve cada uno: advancedsearch. los usuarios deben encontrar objeto específico una gran colec-ción ellos. helpwizard. los usuarios necesitan ayuda acerca cierto tema relacionado con sitio web necesitan encontrar una página específica dentro del sitio. searcharea. los usuarios deben encontrar una página.searchtips. los usuarios requieren saber cómo controlar motor búsqueda.searchresults. los usuarios tienen que procesar una lista resultados una bús- queda. searchbox. los usuarios tienen que encontrar objeto información específicos. para casaseguraasegurada.com, número productos particularmente grande cada uno tiene una clasificación relativamente sencilla, por que probable que sean necesa- rios advancesearch helpwizard. manera similar, búsqueda bastante simple como para requerir searchtips. sin embargo, descripción searchbox ( parte) como sigue: search box(adaptado problema: los usuarios necesitan encontrar objeto información específica. motivación: cualquier situación que aplique una búsqueda por medio una - labra clave través una colección objetos contenido organizada como páginas web. contexto: vez navegar para obtener información contenido, usuario quiere hacer una búsqueda directa través del contenido múltiples páginas web. (-).indd (-).indd // ::// :: diseño basado patrones cualquier sitio web que tenga navegación primaria. usuario tal vez - see buscar objeto cierta categoría. usuario quizá quiera especificar una consulta adicional. fuerzas: sitio web cuenta con navegación primaria. los usuarios quieren buscar objeto cierta categoría. los usuarios desean especificar una consulta más profunda con empleo operadores booleanos sencillos. solución: ofrecer funciones búsqueda que consisten una etiqueta búsqueda, campo palabra clave, filtro aplicable botón “”. oprimir tecla return tiene mismo efecto que seleccionar botón . asimismo, proveer suge- rencias búsqueda ejemplos una página distinta. junto función búsqueda coloca vínculo hacia página. cuadro edición para término búsqueda suficientemente grande como para dar acomodo tres consultas normales usuario (alrededor caracteres). número filtros más , usa cuadro mayor para seleccionar los filtros, bien botón radio. los resultados búsqueda presentan una página nueva con una etiqueta clara que contiene menos “resultados búsqueda” algo -milar. función búsqueda repite parte superior página con las palabras clave ingresadas, modo que los usuarios sepan cuáles fueron. descripción continúa con otras entradas, como describe sección ... patrón continúa para describir cómo acceder, presentar, ajustar, etc. los resultados bús-queda. con base esto, equipo casaseguraasegurada.com puede diseñar los compo- nentes requeridos para implementar búsqueda ( que más probable) adquirir los com-ponentes reutilizables existentes. escena: plática informal durante diseño incremento software que implementa con- trol sensores por internet para casaseguraasegurada.com participantes: jamie (responsable del diseño) vinod (arquitecto jefe del sistema casaseguraasegurada.com). conversación: vinod: entonces, ¿cómo diseño interfaz control cámara? jamie: mal. diseñé mayoría las capacidades para conectarla los sensores reales sin demasiados problemas. también comencé pensar acerca interfaz para que los usuarios verdad muevan, abran acerquen las cámaras desde una página web remota, pero estoy seguro haber terminado . vinod: ¿qué que tienes?jamie: bueno, los requerimientos son que control cámara sea muy interactivo: cuando usuario mueva control, cámara debe moverse tan pronto como sea posible. entonces, pensaba disponer varios botones, como una cámara normal, para que cuando usuario controle cámara haga clic ellos.vinod: mmm. , eso funcionaría, pero estoy seguro que esté bien: cada vez que haga clic control, necesitará esperar para que ocurra toda comunicación entre cliente servidor, por que habrá una buena percepción retroalimentación rápida. jamie: eso que pensado por ello estoy muy conforme con enfoque, pero estoy seguro qué más hacer. vinod: bueno, ¿por qué usar patrón controldedispositi- vointeractivo? jamie: mmm… ¿qué eso? nunca oído.vinod: básicamente patrón para problema exacto que des- cribes. solución que propone crear una conexión control entre servidor dispositivo, través del cual pueden enviarse los comandos control. esa forma, necesitas mandar solicitu-des http normales. patrón incluso muestra cómo puedes imple-mentar esto con uso algunas técnicas ajax sencillas. lado del cliente tienes algunos scripts java que comunican directa-mente con servidor que envían los comandos tan pronto como usuario está sin hacer nada.casasegura aplicación patrones (-).indd (-).indd // ::// :: parte dos modelado . atrones diseño interfaz usuario los últimos años, han propuesto cientos patrones interfaz usuario (). mayo- ría ubican una las siguientes categorías ( estudian con ejemplo representativo) según los describen tidwell [tid] vanwelie[wel]: whole . proporciona una guía para diseñar estructura navegación alto nivel tra- vés toda interfaz. patrón: navegacióndealtonivel (toplevelnavigation) descripción breve: usa cuando sitio aplicación implementa cierto número funciones importantes. menú alto nivel, acoplado con frecuencia con logotipo gráfico identificador que permite navegación directa hacia cualquiera las funciones principales del sistema. detalles: las funciones importantes (por general limitadas tener cuatro siete nombres función) enlistan parte superior pantalla (también posible -ner formatos columnas verticales) renglón texto horizontal. cada nombre vínculo hacia función fuente información apropiada. frecuente usarla con patrón migajasdepan (breadcrumbs) que estudia más adelante. elementos navegación: cada nombre función contenido representa vínculo hacia función contenido apropiados. distribución página. aboca organización general páginas (para sitios web) distintas pantallas (para aplicaciones interactivas). patrón: apilartarjetas (cardstack) descripción breve: utiliza cuando deben seleccionarse aleatoriamente cierto número subfunciones categorías contenido específicas relacionadas con una característica función. tiene apariencia una pila tarjetas con “pestaña”, cada una seleccionable con clic del ratón, que representan subfunciones categorías contenido específicas. detalles: las tarjetas con pestañas son una metáfora bien entendida son fáciles - nipular por parte del usuario. cada tarjeta con pestaña (divisor) tiene formato ligera-mente diferente. algunas requieren entradas tienen botones otros mecanismos navegación; otras más son informativas. pueden combinarse con otros patrones, tales como listadesplegable llenarlosespacios, entre otros. elementos navegación: clic una pestaña hace que aparezca tarjeta apro- piada. también están presentes características navegación dentro tarjeta, pero general éstas deben iniciar una función relacionada con los datos tarjeta, estable-cer vínculo real hacia otra pantalla.jamie: genial… eso justo que necesito para resolver pro- blema. ¿dónde encuentro? vinod: está disponible repositorio línea. ésta url.jamie: iré revisarlo.vinod: , pero recuerda revisar campo consecuencias para patrón. creo recordar que había algo acerca tener cuidado con ciertos aspectos seguridad. pienso que porque crea canal control separado ese modo evaden los mecanismos normales seguridad web. jamie: buena observación. probable que hubiera ocurrido… gracias. aquí utiliza formato del patrón abreviado. [tid] [wel] encuentran descripciones del patrón completo (así como decenas otros patrones). (-).indd (-).indd // ::// :: diseño basado patrones formatos entrada. considera varias técnicas diseño para llenar las entradas - vel formato. patrón: llenar los espacios descripción breve: permite introducir datos alfanuméricos “cuadro texto”. detalles: los datos entran cuadro texto. general, validan procesan des- pués pulsar algún indicador texto gráfico (como botón que diga “”, “enviar”, “siguiente”, etc.). muchos casos, este patrón combina con una lista desplegable otros patrones (por ejemplo, buscar <lista desplegable para <llenar los espacios del cua- dro texto). elementos navegación: indicador texto gráfico que inicia validación pro- cesamiento. tablas. dan una guía para diseño fin crear manipular datos tabulares todo tipo. patrón: ordenartabla (sortabletable) descripción breve: despliega una lista larga registros que pueden ordenarse por -dio mecanismo cambio para cualquier etiqueta columna. detalles: cada renglón tabla representa registro completo. cada columna repre- senta campo del registro. cada encabezado columna realidad botón selec-cionable que pulsa para iniciar ordenamiento ascendente descendente campo asociado con columna para todos los registros desplegados. por general, tabla ajustable tiene algún mecanismo desplazamiento para caso que número -gistros sea más grande que espacio disponible ventana. elementos navegación: cada encabezado columna inicia ordenamiento - dos los registros. otro elemento navegación, aunque ciertos casos cada -gistro contiene vínculos navegación hacia otro contenido funciones. manipulación directa los datos. aboca edición, modificación transformación los datos. patrón: migajasdepan (breadcrumbs) descripción breve: brinda una ruta completa navegación cuando usuario trabaja con una jerarquía compleja páginas pantallas. detalles: cada página pantalla identificador único. ruta navegación - cia ubicación actual especifica una ubicación predefinida para cada pantalla. ruta tiene forma siguiente: página inicialpágina del tema principalpágina del subtemapágina específicapágina actual. elementos navegación: cualquiera las entradas pantalla las migajas pan puede usarse como apuntador hacia vínculo regreso hacia nivel más alto jerarquía. navegación. ayuda usuario navegar través menús jerárquicos, páginas web pan-tallas interactivas. patrón: editar (editinplace) descripción breve: brinda capacidades edición texto sencillo para ciertos tipos contenido ubicación que muestra pantalla. necesario que usuario -troduzca explícitamente alguna función edición texto algún modo. detalles: usuario observa pantalla contenido que debe modificarse. con doble clic contenido, indica sistema que desea editar. contenido resalta para - dicar que modo edición está activado para que usuario haga los cambios apropiados. elementos navegación: ninguno. (-).indd (-).indd // ::// :: parte dos modelado búsqueda. permite hacer búsquedas contenido específico través información con- servada sitio web que está contenida almacenamientos persistentes datos acce-sibles través una aplicación interactiva. patrón: búsquedasimple (simplesearch) descripción breve: capacidad buscar sitio web fuente persistente datos para concepto simple datos descritos por una cadena alfanumérica. detalles: brinda capacidad hacer una búsqueda local (una página archivo) global (todo sitio base datos completa) para cadena búsqueda. genera una lista “aciertos” ordenados según probabilidad satisfacer las necesidades del usua-rio. hace búsquedas conceptos múltiples con operaciones booleanas especiales (véase patrón búsqueda avanzada). elementos navegación: cada entrada lista representa vínculo navegación hacia los datos los que hace referencia con entrada. elementos página. implanta elementos específicos una página web una panta-lla del monitor. patrón: mago (wizard) descripción breve: lleva usuario paso paso través una tarea compleja guía para que termine por medio ventanas sencillas pantalla. detalles: ejemplo clásico proceso registro cuatro etapas. patrón mago genera una ventana cada una ellas, las que solicita información del usuario paso paso. elementos navegación: navegación hacia delante atrás permite que usuario vuelva cada etapa proceso mago. comercio electrónico. específicos para sitios web, estos patrones implementan elementos recurrentes las aplicaciones comercio electrónico. patrón: carritodecompras (shoppingcart) descripción breve: una lista artículos seleccionados para compra. detalles: enlista artículos, cantidad, código del producto, disponibilidad ( inventario, fuera inventario), precio, información para entrega, costos envío otra informa- ción relevante para compra. también facilidad editar (por ejemplo, retirar, cam-biar cantidad, etcétera). elementos navegación: contiene capacidad continuar compra salir. varios. son patrones que ajustan fácilmente ninguna las categorías anteriores. ciertos casos, dependen del dominio ocurren sólo para clases específicas usuarios. patrón: indicadordeavance (progressindicator) descripción breve: proporciona una indicación del avance cuando una operación dura más segundos. detalles: representa con icono animado cuadro mensaje que contiene alguna indicación visual (por ejemplo, una “barra peluquero”, barra avance con indicador porcentaje, etc.) que procesamiento está curso. también contiene una indicación texto acerca del estado del procesamiento. elementos navegación: frecuente que contenga botón que permita usuario hacer una pausa cancelar procesamiento. cada uno los ejemplos patrones anteriores ( todos los cada categoría) también pueden tener diseño completo nivel componentes, incluso clases diseño, atributos, ope-raciones interfaces. (-).indd (-).indd // ::// :: diseño basado patrones estudio exhaustivo los patrones interfaz usuario encuentra más allá del alcance este libro. lector está interesado, recomienda consultar [duy], [bor], [tid] [wel]. . atrones diseño webapp este capítulo aprendimos que hay cuatro tipos diferentes patrones muchas formas clasificarlos. cuando consideran los problemas diseño que deben resolverse para construir una webapp, bueno considerar categorías patrones dos dimensiones: centrarse diseño del patrón nivel granularidad. centrarse diseño identifica cuál aspecto del modelo del diseño relevante (por ejemplo, arquitectura información, navegación -teracción). granularidad determina nivel abstracción que considera (¿ patrón aplica toda webapp, una sola página web, subsistema componente individual webapp?) .. centrarse diseño los capítulos anteriores hizo énfasis avance del diseño que comienza por tomar cuenta arquitectura, aspectos nivel del componente representaciones interfaz usuario. cada paso consideran los problemas soluciones propuestos para comenzar nivel alto abstracción fin pasar poco poco otro más detallado específico. otras palabras, diseño “angosta” medida que avanza. los problemas ( soluciones) que encontrarán cuando diseñe una arquitectura información para una webapp serán diferen- tes aquellos que aparecen cuando diseña una interfaz. por tanto, debe sorprender que los patrones para diseño webapps desarrollen para distintos niveles atención, modo que aborden los problemas ( sus soluciones) únicos que encuentren cada nivel. los patrones webapps clasifican con empleo los siguientes niveles atención diseño: • patrones arquitectura información: relacionan con estructura general del espacio información con las formas las que los usuarios interactúan con ésta. • patrones navegación: definen estructuras los vínculos navegación, tales como jerarquías, anillos, recorridos, etcétera. • patrones interacción: contribuyen diseño interfaz usuario. los patrones esta categoría enfrentan modo que interfaz informa usuario las consecuencias una acción específica, cómo expande usuario contenido con base empleo del contexto sus deseos, mejor manera describir destino implícito por vínculo, manera informar usuario acerca del estado una interacción curso aspectos relacionados con interfaz. • patrones presentación: ayudan presentar contenido usuario través interfaz. los patrones esta categoría abocan modo organizar las funciones control interfaz usuario para mejorar uso, mostrar relación entre una acción interfaz los objetos contenido los que afecta forma esta-blecer jerarquías eficaces del contenido. • patrones funcionales: definen los flujos trabajo, comportamientos, procesamiento, comunicación otros elementos algorítmicos dentro una webapp. mayoría casos, sería inútil explorar colección patrones arquitectura infor-mación cuando encuentra problema diseño interacción. estudiarían los punto clave atención hace “más fina” medida que avanza diseño. (-).indd (-).indd // ::// :: parte dos modelado patrones interacción porque atención diseño que relevante para trabajo que está ejecutando. .. granularidad del diseño cuando problema involucra aspectos del “panorama”, debe tratarse desarrollar solucio-nes ( los patrones uso relevantes) que centren éste. inversa, cuando atención muy estrecha (como cuando selecciona únicamente aspecto conjunto reduci- cinco menos ellos), solución ( patrón correspondiente) busca con más -trechez. términos del nivel granularidad, los patrones describen los niveles -guientes: • patrones arquitectónicos. este nivel abstracción relacionará por común con patrones que definen estructura general webapp, que indican las relaciones entre diferentes componentes incrementos que definen las reglas para especificar las rela-ciones entre los elementos (páginas, paquetes, componentes subsistemas) arqui-tectura. • patrones diseño. éstos abocan elemento específico del diseño, como agrupamiento componentes, fin resolver algún problema diseño, relaciones entre los elementos una página, mecanismos para efectuar comunicación entre componentes. ejemplo esto sería patrón broadsheet para distribución página inicial una webapp. • patrones componentes. este nivel abstracción relaciona con elementos indi-viduales pequeña escala una webapp. algunos ejemplos son los elementos interacción individual (botones radio), navegación (¿cómo dar formato los vínculos?) funcionales (algoritmos específicos). también posible definir relevancia distintos patrones para diferentes clases aplica-ciones dominios. por ejemplo, una colección patrones ( diferentes niveles atención diseño granularidad) puede tener relevancia particular para los negocios electrónicos ( -busi- ness). sitio web iawiki (http://iawiki.net/websitepat- terns) espacio colaboración para los arquitectos información contiene muchos recursos útiles. entre ellos hay vínculos hacia varios catálogos repositorios útiles patrones hipermedios. ahí están representados cientos patrones diseño: repositorios patrones diseño hipermedios patrones interacción, por tom erickson patterns.html patrones diseño web, por martijn van welie patrones web para diseño http://harbinger.sims.berkeley.edu/ui_designpatter-/webpatterns/webpatterns/home.phppatrones para sitios web personales mejora sistemas información web con patrones navegación http:// lenguaje patrón html . campos comunes. lenguaje patrón para diseño hci patrones para sitios web personales lenguaje patrón indización repositorios patrones para diseño hipermedios (-).indd (-).indd // ::// :: diseño basado patrones . esumen los patrones diseño dan mecanismo codificado para describir problemas solución forma tal que permiten que comunidad ingeniería software diseñe conocimiento para que sea reutilizado. patrón describe problema, indica contexto permite que usuario entienda ambiente que sucede problema, enlista sistema fuerzas que indican cómo puede interpretarse problema contexto, modo que aplica solución. trabajo ingeniería software identifican documentan patrones generativos que describen aspecto importante repetible sistema para después proporcionar manera elaborar dicho aspecto dentro sistema fuerzas que único para contexto deter-minado. los patrones arquitectónicos describen problemas diseño amplios que resuelven con enfoque estructural. los patrones datos describen problemas recurrentes orientados datos las soluciones para modelar éstos que utilizan para resolverlos. los patrones com-ponentes (también conocidos como patrones diseño) abocan problemas asociados con desarrollo subsistemas componentes, manera que comunican entre ubicación una arquitectura mayor. los patrones diseño interfaces describen problemas comunes interfaz usuario solución con sistema fuerzas que incluye las -racterísticas específicas los usuarios finales. los patrones webapps enfrentan conjunto problemas que surgen cuando construyen webapps, frecuente que incorpo-ren muchas categorías los patrones mencionados. una estructura proporciona marco que residen los patrones los idiomas describen los detalles implementación específicos del lenguaje programación para algoritmo, parte , para una estructura datos específica. para hacer las descripciones patrones, emplea formato plantilla estándar. lenguaje patrón incluye conjunto patrones, cada uno los cuales descrito con empleo una plantilla estándar interrelacionada para que muestre cómo colaboran los patrones para resolver problemas dominio aplicación. diseño basado patrones utiliza junto con métodos diseño arquitectónico, nivel componentes interfaz usuario. enfoque del diseño comienza con estudio del modelo requerimientos fin detectar los problemas, definir contexto describir sistema fuerzas. continuación buscan los lenguajes patrón para dominio del pro-blema con objeto determinar existen patrones para los problemas detectados. una vez que han encontrado los patrones apropiados, usan como guía para diseño. problemas puntos por evaluar .. analice las tres “partes” patrón diseño ejemplo concreto cada uno algún campo distinto del software. .. ¿cuál diferencia entre patrón generativo uno generativo?.. ¿ qué difieren los patrones arquitectónicos los patrones componentes?.. ¿qué estructura qué difiere patrón? ¿qué idioma qué diferencia patrón? .. con uso plantilla diseño patrones presentada sección .., desarrolle descrip- ción completa patrón sugerido por profesor. .. desarrolle lenguaje esqueleto patrón para deporte con que esté familiarizado. - mience por abordar contexto, sistema fuerzas los problemas amplios que deban resolver entre-nador equipo. sólo necesita especificar los nombres los patrones hacer descripción frase por frase cada uno. (-).indd (-).indd // ::// :: parte dos modelado .. encuentre cinco repositorios patrones presente descripción abreviada los tipos patrones que contenga cada uno. .. cuando christopher alexander afirma que “ buen diseño logra con sólo reunir las partes ejecutantes”, ¿qué cree usted que quiere decir? .. con uso las tareas diseño basado patrones mencionadas sección .., desarrolle diseño esqueleto para “sistema diseño interiores” descrito sección ... .. elabore una tabla organización patrones para aquellos que haya utilizado problema .. .. con uso plantilla para diseñar patrones que presentó sección .., desarrolle descripción completa para patrón cocina mencionado sección .. .. banda los cuatro [gam] propuesto varios patrones componentes aplicables sistemas orientados objetos. seleccione uno ellos (disponibles web) analícelo. .. encuentre tres repositorios patrones interfaz usuario. seleccione uno cada repositorio haga una descripción breve . .. encuentre tres repositorios patrones para webapps. seleccione uno cada repositorio descrí- balos brevemente. lecturas adicionales fuentes información última década han escrito muchos libros sobre diseño patrones destinados los ingenieros software. gamma . [gam] escribieron libro fundamental sobre dicho tema. las contribuciones más recientes incluyen los textos lasater ( design patterns, wordware publishing, inc., ), holzner (design patterns for dummies , for dummies, ), freeman . ( head first design patterns, ’reilly media, inc., ) shalloway trott ( design patterns explained , . ., addison-wesley, ). una edición especial ieee software (julio/agosto, ) estudia una amplia variedad temas sobre patrones software. kent beck (implementation patterns, addison-wesley, ) estudia patrones para codificar implementar aspec- tos que encuentran durante actividad construcción. otros libros centran patrones diseño según encuentran desarrollo aplicaciones espe- cíficas ambientes lenguajes. las contribuciones esta área incluyen las siguientes: bowers ( pro css and html design patterns, apress, ), tropashko burleson (sql design patterns: expert guide sql programming, rampant techpress, ), mahemoff ( ajax design patterns, ’reilly media, inc., ), mets- ker wake (design patterns java, addison-wesley, ), nilsson ( applying domain-driven design and patterns: with examples # and .net , addison-wesley, ), sweat (phparchitect’ guide php design patterns, marco tabini & associates, inc., ), metsker (design patterns #, addison-wesley, ), grand merrill ( visual basic .net design patterns, wiley, ), crawford kaplan ( design patterns , ’reilly media, inc., ), juric . ( design patterns applied, wrox press, ), marinescu roman (ejb design patterns, wiley, ). otros libros abocan dominios aplicaciones específicas. entre éstos están las contribuciones kuchana (software architecture design patterns java, auerbach, ), joshi (++ design patterns and deri-vatives pricing , cambridge university press, ), douglass ( real-time design patterns, addison-wesley, ) schmidt rising (design patterns communication software, cambridge university press, ). lectura los libros clásicos escritos por arquitecto christopher alexander ( notes the synthesis form, harvard university press, , pattern language: towns, builidings, construction , oxford university press, ) útil para diseñador software que trata entender por completo los patrones -seño. internet hay una amplia variedad fuentes información sobre diseño patrones. sitio web del libro encuentra lista actualizada referencias red mundial que son relevantes para diseño basado patrones: (-).indd (-).indd // ::// :: webapps conceptos clave arquitectura cvm . . . . . . . . arquitectura webapps . . . del contenido . . objetos. . . . . . . . . . . . . . diseño arquitectónico . . . . . . . . . calidad . . . . . . . . . . . . . . contenido . . . . . . . . . . . . nivel componentes. . . . . . . . . . estética . . . . . . . . . . . . . gráfico . . . . . . . . . . . . . . metas. . . . . . . . . . . . . . . navegación . . . . . . . . . . . pirámide. . . . . . . . . . . . . mdhoo . . . . . . . . . . . . . . . ¿qué ? diseño webapps incluye acti- vidades técnicas técnicas que incluyen siguiente: establecer vista sensación webapp, creando distribución estética interfaz usuario, definiendo estructura arquitectónica general, desarrollando contenido funcionalidad que residen arquitectura planeando navegación que ocurre dentro webapp. ¿quién hace? creación del modelo del diseño una webapp, intervienen ingenieros web, diseñadores gráficos, desarrolladores contenido varios participan-tes más. ¿por qué importante? diseño permite crear modelo que evalúe respecto calidad para mejo-rarlo antes generación contenido código, realización las pruebas del involucramiento gran número usuarios. diseño lugar donde establece calidad webapp. ¿cuáles son los pasos? diseño una webapp incluye seis etapas principales que son orientadas por informa-ción obtenida durante modelación los requerimien-tos. diseño del contenido utiliza contenido del modelo (desarrollado durante análisis) como base para esta-blecer diseño los objetos del contenido. diseño estético (también llamado diseño gráfico) establece vista sensación que usuario final percibe. diseño arqui-tectónico centra estructura general hipermedios todos los objetos funciones del contenido. diseño interfaz establece distribución mecanismos distri-bución que definen interfaz usuario. diseño navegación define forma que usuario final navega través estructura hipermedios. dise- los componentes representa estructura interna detallada los elementos funcionales webapp. ¿cuál producto final? principal producto que genera durante diseño webapp modelo del diseño que incluye aspectos del diseño del contenido, estética, arquitectura, interfaz, navega-ción nivel componentes. ¿cómo aseguro que hice bien? cada ele- mento del modelo del diseño revisa para descubrir errores, inconsistencias omisiones. además, toman cuenta soluciones alternativas evalúa grado que modelo actual del diseño llevará una implementa-ción eficaz. una mirada rápida ingeniería web [pre] una versión adaptada del enfoque ingeniería software que presenta todo este libro. propone una estructura ágil, pero disciplinada, para construir sistemas aplicaciones basados web con calidad industrial. autorizado libro sobre diseño web, jakob nielsen [nie] afirma siguiente: “ esencia, hay dos enfoques fundamentales del diseño: ideal artístico expresarse mismo ideal ingeniería resolver problema para cliente.” primera década del desarrollo web, enfoque que elegían muchos diseñadores era ideal artís-tico. diseño desarrollaba manera hoc por general efectuaba medida que generaba html. después evolucionó partir visión artística que surgió construcción webapps. incluso hoy, muchos desarrolladores web utilizan webapps como cartel infantil para “- seño limitado”. afirman que inmediatez volatilidad una webapp palidecen ante diseño formal, que éste evoluciona conforme elabora ( codifica) una aplicación que debe dedi-carse relativamente poco tiempo crear modelo detallado del diseño. este argumento tiene algo verdad, pero sólo para webapps relativamente sencillas. cuando contenido las fun-ciones son complejos cuando tamaño webapp incluye cientos miles objetos contenido, funciones clases análisis cuando éxito webapp tenga influencia directa éxito del negocio, diseño puede debe tomarse ligera. esta realidad conduce segundo enfoque nielsen: “ ideal ingeniería resolver problema para cliente”. ingeniería web adopta esta filosofía, enfoque más riguroso del diseño webapps permite que los desarrolladores hagan realidad. (-).indd (-).indd // ::// :: parte dos modelado . alidad del diseño webapps diseño actividad ingeniería que genera producto alta calidad. esto lleva una pregunta recurrente que surge todas las disciplinas ingeniería: ¿qué calidad? esta sección estudiaremos respuesta contexto del desarrollo webapps. toda persona que haya navegado red mundial que haya utilizado una intranet corpo- rativa formado una opinión sobre que constituye una “buena” webapp. los puntos vista individuales varían mucho. algunos usuarios les gustan los gráficos brillantes, otros prefieren texto simple, algunos más demandan mucha información, mientras los hay que desean una pre-sentación abreviada. algunos les agradan las herramientas analíticas sofisticadas tener acceso bases datos otros les gusta sencillo. realidad, percepción del usuario acerca que “bueno” ( consecuencia aceptación rechazo webapp) puede ser aspecto más importante que cualquier otro índole técnica sobre calidad las webapps. pero, ¿cómo percibe calidad una webapp? ¿qué atributos debe tener para que haya bondad ante los ojos los usuarios finales vez existan las características técnicas calidad que permitan corregir, adaptar, mejorar dar apoyo aplicación largo plazo? realidad, las webapps aplican todas las características técnicas calidad del diseño estudiadas capítulo los atributos generales calidad que vieron capítulo . sin embargo, los más relevantes estos atributos generales —usabilidad, funcionalidad, con-fiabilidad, eficiencia susceptibilidad recibir mantenimiento— brindan una base útil para evaluar calidad los sistemas basados web. olsina . [ols] han preparado “árbol requerimientos calidad” que identifica conjunto atributos técnicos —usabilidad, funcionalidad, confiabilidad, eficiencia suscepti-bilidad recibir mantenimiento— que generan calidad las webapps. figura . - sume trabajo. los criterios que ahí aparecen tienen interés especial lector diseña, cons-truye mantenimiento webapps largo plazo. offutt [off] agrega los siguientes los cinco atributos principales calidad que men- cionan figura .: seguridad. las webapps han integrado mucho con bases datos críticas, corporativas gubernamentales. las aplicaciones comercio electrónico extraen después almacenan -formación delicada para cliente. por estas muchas otras razones, seguridad las web-apps tiene importancia capital muchas situaciones. medida clave seguridad una webapp ambiente servidor capacidad para rechazar los accesos autorizados para detener ataque pro veniente del exterior. análisis detallado seguridad las webapps está más allá del alcance este libro. lector está interesado este tema, puede consultar [vac], [kiz] [kal]. disponibilidad. aun mejor webapp será incapaz satisfacer las necesidades los usua- rios encuentra disponible. sentido técnico, disponibilidad medida porcentual del tiempo que una webapp puede utilizarse. usuario final común espera que las webapps hallen disponibles las horas los días del año. algo menos que eso tomado como inaceptable. pero “tiempo arriba” único indicador disponibilidad. offutt [off] sugiere que “ empleo características que sólo encuentren disponibles navegador plataforma” hace que quienes tengan una configuración diferente navegador plataforma puedan utilizar webapp. invariablemente, usuario irá otro sitio.cita: “ los productos diseñan para que ajusten mejor las tendencias naturales del com-portamiento humano, entonces las personas estarán más satis-fechas, más complacidas serán más productivas.” susan weinschenk estos atributos calidad son similares los que mencionan los capítulos . esto implica que las características calidad son universales para todo software. por supuesto, esta expectativa realista. para las webapps importantes, deben programarse “tiempos fuera” fin que reciban arreglos actualizaciones.¿cuáles son los principales atributos calidad las webapps?? (-).indd (-).indd // ::// :: diseño webapps escalabilidad. ¿una webapp ambiente servidor pueden crecer para que manejen , , usuarios? ¿ webapp los sistemas con los que tiene interfaz son - paces manejar una variación significativa del volumen respuesta desplomará ( - sará)? basta construir una webapp exitosa. también importante que pueda asimilar carga del éxito (muchos más usuarios) que tenga aún más éxito. tiempo para llegar mercado. aunque tiempo que toma llegar mercado realidad atributo calidad sentido técnico, desde punto vista -presa. frecuente que primera webapp que llega segmento específico del mercado obtenga número desproporcionado usuarios finales.calidad una aplicación webusabilidadcomprensión global del sitio retroalimentación ayuda línea características estética interfazcaracterísticas especiales capacidad búsqueda recuperación características navegación conexión características relacionadas con dominio aplicación procesamiento correcto los vínculos recuperación errores validación recuperación las entradas del usuario facilidad corrección adaptabilidad extensibilidaddesempeño del tiempo respuesta velocidad generación página velocidad generación los gráﬁcosfuncionalidad conﬁabilidad eﬁciencia facilidad para recibirmantenimientofigura . árbol requerimientos calidad.fuente: [ols]. siguiente una lista adaptada información contenida webreference.com, donde plantean preguntas que ayudarán los diseñadores los usuarios finales webapp evaluar calidad aplicación: • ¿ posible adaptar las opciones contenido, función navegación las preferencias del usuario? • ¿puede personalizarse contenido funcionalidad ancho banda con que comunica usuario? • ¿ han utilizado manera apropiada las imágenes otros medios distintos del texto? ¿ posible adaptar tamaño los archivos imagen para mejorar eficiencia pan-talla?• ¿las tablas están organizadas tienen tamaño tal que entienden despliegan modo eficiente? • ¿ html está optimizado fin eliminar las ineficiencias?• ¿ diseño general página tiene lectura navegación fáciles?• ¿todos los vínculos llevan información interés para los usua- rios? • ¿ probable que mayor parte vínculos persistan red mundial? • ¿ webapp tiene herramientas administración del sitio, tales como historial del uso, prueba vínculos, búsqueda local segu-ridad?información diseño una webapp. lista revisión calidad aquellos que buscan información disponen miles millones páginas web. aun las búsquedas bien dirigidas red mundial generan una avalancha contenidos. con tan- tas fuentes información entre las cuales elegir, ¿cómo evalúa usuario calidad ( decir, veracidad, exactitud, completitud, oportunidad, etc.) del contenido que presenta una webapp? tillamn [til] sugiere siguiente conjunto criterios útiles para ello: (-).indd (-).indd // ::// :: parte dos modelado • ¿ fácil determinar alcance profundidad del contenido fin estar seguros que satisface las necesidades del usuario? • ¿puede identificarse fácilmente formación autoridad los autores del contenido? • ¿ posible determinar actualidad del contenido, fecha última actualización qué consistió ésta? • ¿ contenido ubicación son estables (permanecerán url referencia)? además estas preguntas relacionadas con contenido, deben agregarse las siguientes: • ¿ creíble contenido? • ¿ contenido único?, decir, ¿ webapp brinda algún beneficio único quienes emplean? • ¿ valioso contenido para comunidad usuarios que dirige? • ¿está bien organizado contenido? ¿está indizado? ¿ accede con facilidad? las listas comprobación citadas esta sección representan sólo una muestra pequeña los aspectos que deben estudiarse medida que diseño webapp evoluciona. . etas del diseño columna periódica sobre diseño web, jean kaiser [kai] sugiere conjunto metas para diseño que son aplicables virtualmente toda webapp, sin importar dominio apli- cación, tamaño complejidad. simplicidad: aunque parezca algo pasado moda, aforismo “todo con moderación” aplicable las webapps. existe una tendencia entre ciertos diseñadores dar usuario final “demasiado”: contenido exhaustivo, extremos visuales, animaciones intrusas, páginas web enormes… lista sigue. mejor moderación simplicidad. contenido debe ser informativo pero sucinto debe utilizar modo entrega (texto, imágenes, video audio) que resulte apropiado para información que víe. estéti- debe ser agradable pero abrumadora (demasiados colores tienden distraer usuario vez mejorar interacción). arquitectura debe lograr los objetivos webapp manera más sencilla posible. navegación debe ser directa sus mecanismos, obvios para intuición del usuario final. las funciones deben ser fáciles utilizar más fáciles -tender. consistencia. esta meta del diseño aplica virtualmente todo elemento del modelo del diseño. contenido debe construirse modo congruente (formato tipografía del texto deben ser los mismos todos los documentos texto; las imágenes deben tener coherencia aspecto, color estilo). diseño gráfico (estética) debe presentar una vista consistente todas las partes webapp. diseño arquitectónico debe establecer plantillas que generen una estructura hipermedios constante. diseño interfaz debe definir modos consistentes interacción, navegación despliegue del contenido. los mecanismos navegación deben usarse manera consistente todos los elementos webapp. como dice kaiser [kai]: “recuerde que para visitante , sitio web lugar físico. sus páginas tienen - seño consistente, son fuente confusión”. identidad. diseño estética, interfaz navegación una webapp deben ser con-sistentes con dominio aplicación para que elaborar . sitio web para grupo hip-hop sin duda tendrá aspecto sensación distintos que una webapp diseñada para una compañía servicios financieros. arquitectura webapp será diferente por completo, las ¿qué debe considerarse cuando evalúa calidad del contenido?? cita: “que algo pueda hacerse, significa que deba hacerse.” jean kaiser cita: “para ciertas personas, diseño web centra aspecto visual percepción… para otras, trata estructu-rar información navegación través del espacio del documento. otras más consi-deran incluso que diseño web tecnología… realidad, diseño incluye todo esto tal vez más.” thomas powell (-).indd (-).indd // ::// :: diseño webapps interfaces construirán para que reciban distintas categorías usuarios, navegación organizará para que cumpla objetivos diferentes. usted ( quienes contribuyan diseño) debe trabajar para establecer identidad webapp por medio del diseño. robustez. con base identidad que haya establecido, frecuente que una webapp haga una “promesa” implícita usuario. éste espera contenido funciones robustas que sean relevan-tes para sus necesidades. existen son insuficientes, probable que webapp fracase. navegabilidad. dijo que navegación debe ser sencilla consistente. también debe estar diseñada forma tal que sea intuitiva predecible. decir , usuario debe comprender cómo moverse por webapp sin tener que buscar vínculos instrucciones para navegación. por ejemplo, campo iconos gráficos imágenes contiene algunos que serán usados como mecanismos navegación, deben identificarse visualmente. nada más frustrante que intentar encontrar vínculo vivo apropiado entre muchas imágenes. también importante colocar los vínculos hacia contenido las funciones webapp una ubicación predecible cada página web. requiere desplazar página ( que sucede con frecuencia), los vínculos situados las partes superior inferior página hacen que las tareas navegación del usuario sean más fáciles. atractivo visual. todas las categorías software, las aplicaciones web son indiscutible-mente las más visuales, dinámicas estéticas. belleza (atractivo visual) radica sin lugar dudas los ojos del espectador , pero muchas características del diseño (aspecto sensación del contenido, distribución interfaz, coordinación del color, balance del texto, imágenes otros medios) aumentan atractivo visual. compatibilidad. una webapp usará varios ambientes (distinto hardware , tipos - nexión, sistemas operativos, navegadores, etcétera) debe diseñarse para que sea compatible con cada uno. . irámide del diseño webapps ¿qué diseño una webapp? esta sencilla pregunta más difícil responder que creería. nuestro libro [pre] ingeniería web, david lowe analizamos del modo siguiente: creación diseño eficaz requerirá por general conjunto diversificado aptitudes. ocasiones, para proyectos pequeños, desarrollador único necesitará tener varias habilidades. para los proyectos grandes, aconsejable factible confiar experiencia especialistas: ingenieros web, diseñadores gráficos, desarrolladores contenido, programadores, especialistas bases datos, arquitectos información, ingenieros redes, expertos seguridad probadores. depen-der estas distintas aptitudes permite creación modelo cuya calidad puede evaluarse fin mejorar contenido código antes que generen contenido código, que realicen pruebas que involucre gran número usuarios. análisis reside donde establece calidad webapp, entonces diseño está donde calidad está verdad incrustada. mezcla apropiada habilidades diseño variará función naturaleza webapp. figura . ilustra pirámide del diseño las webapps. cada nivel representa una acción del diseño que describe las siguientes secciones. . iseño interfaz webapp cuando usuario interactúa con sistema basado computadora, aplica conjunto principios fundamentales lineamientos generales diseño. éstos estudiaron capítulo cita: “ sitio perfectamente utilizable, pero carece estilo elegante apropiado, fra-casará.” curt cloninger (-).indd (-).indd // ::// :: parte dos modelado . aunque las webapps plantean algunas dificultades especiales diseño interfaz usuario, los principios lineamientos básicos son aplicables. uno los retos del diseño interfaz las webapps naturaleza indeterminada del punto que entra usuario. decir, éste puede ingresar por una ubicación “inicial” webapp ( página arranque, por ejemplo) por algún vínculo cierto nivel inferior arquitectura aquélla. algunos casos, webapp diseña modo que redirija usua-rio una ubicación inicial, pero esto algo indeseable, entonces diseño debe dar caracte-rísticas navegación interfaz que acompañen todos los objetos contenido las cuales disponga sin importar modo que usuario ingrese sistema. los objetivos interfaz una webapp son los siguientes: ) establecer una ventana con- gruente contenido las funciones que brinda, ) guiar usuario través una serie interacciones con webapp ) organizar las opciones navegación contenido disponibles para usuario. para lograr una interfaz consistente, primero debe usarse diseño estético (véase sección .) fin establecer “aspecto” coherente. esto incluye muchas carac-terísticas, pero debe ponerse énfasis distribución forma los mecanismos nave-gación. para guiar interacción del usuario, debe establecerse una metáfora apropiada que permita usuario tener una comprensión intuitiva interfaz. fin implementar las -ciones navegación, puede seleccionarse alguno los siguientes mecanismos: • menús navegación: contienen palabras clave (organizadas forma vertical hori-zontal) que enlistan contenido funciones clave. estos menús implementan modo que usuario pueda elegir entre una jerarquía subtemas que despliegan selec-cionar opción principal menú. • iconos gráficos: botones, interruptores otras imágenes similares que permiten que usuario seleccione alguna propiedad que especifique una decisión. • imágenes: cierta representación gráfica que usuario selecciona para establecer vínculo hacia objeto contenido función webapp. sección . está dedicada diseño interfaz webapp. aún leído, momento hacerlo. este contexto, una metáfora representación (establecida por experiencia del usuario con mundo real) que modela contexto interfaz. ejemplo sencillo sería interruptor deslizable que utilice para controlar volumen auditivo archivo .mpg.diseño interfaz diseño estético diseño del contenido diseño navegación diseño arquitectura diseño los componentesusuario tecnologíafigura . pirámide del diseño las webapps ¿ qué mecanismos interacción disponen los diseñadores webapps?? (-).indd (-).indd // ::// :: diseño webapps importante observar que cada nivel jerarquía del contenido debe proporcionarse uno varios estos mecanismos control. . iseño estética diseño estético, también llamado diseño gráfico, una actividad artística que complementa los aspectos técnicos del diseño las webapps. sin estética, una webapp tal vez sea funcional pero atractiva. con estética, una webapp lleva sus usuarios mundo que los sitúa nivel tanto visceral como intelectual. pero, ¿qué estética? hay viejo refrán que dice que “ belleza está los ojos del espectador”. esto particularmente cierto cuando trata del diseño estético las webapps. para llevar cabo éste con eficacia, hay que volver jerarquía del usuario desarrollada como parte del modelo requerimientos (véase capítulo ) preguntar: ¿quiénes son los usuarios webapp qué “vista” desean tener? .. aspectos distribución toda página web tiene una cantidad limitada “superficie” que utiliza para dar apoyo estética funcional, características navegación, contenido información funciones diri-gidas usuario. desarrollo dicha superficie planea durante diseño estético. igual que todos los temas estética, cuando diseña distribución pantalla hay reglas absolutas. sin embargo, útil considerar varios lineamientos distribución general: tema espacio blanco. aconsejable ocupar con información cada centí-metro cuadrado una página web. amasijo resultante hará difícil que usuario iden-tifique información las características que necesita creará caos visual que será agradable los ojos. hacer énfasis contenido. después todo, ésta razón que usuario esté ahí. nielsen [nie] sugiere que página web común debe tener por ciento conte- nido destinar resto navegación otras características. organizar los elementos con una distribución que vaya desde arriba - quierda hacia abajo derecha. gran mayoría usuarios una página web recorrerán forma muy parecida como hacen con las hojas libro: desde arriba izquierda hacia abajo derecha. los elementos distribución tienen prioridades específicas, aquellos que sean prioritarios deben colocarse parte superior izquierda superficie página. agrupar navegación, contenido función forma geográfica dentro página. los humanos buscamos patrones virtualmente todas las cosas. una -gina web hay patrones discernibles, probable que frustración del usuario aumente (debido búsqueda innecesaria información requerida). aumente superficie con barra desplazamiento. aunque frecuente que necesite desplazamiento, mayor parte estudios indican que los usuarios preferi- rían hacerlo. mejor reducir contenido página presentar varias páginas que sea necesario. cuando diseñe distribución hay que considerar resolución tamaño ventana del navegador. vez definir tamaños fijos dentro una plantilla, -seño debe especificar todos los parámetros términos porcentaje del espacio disponi-ble [nie]. todo ingeniero web ( software) tiene talento artístico (estético). lector encuentra esta categoría, contrate diseñador gráfico experimentado para que haga trabajo diseño estético.? hay excepciones culturales lingüísticas, pero esta regla aplica mayor parte usuarios.cita: “descubrimos que las personas evalúan rápidamente sitio tan sólo por diseño visual.” lineamientos stanford para credibilidad web los usuarios tienden tolerar desplazamiento vertical mejor que horizontal. evite los formatos anchos para página.consejo (-).indd (-).indd // ::// :: parte dos modelado .. aspectos del diseño gráfico diseño gráfico toma cuenta cada aspecto vista sensación webapp. proceso diseño gráfico comienza con distribución (véase sección ..) avanza hacia con- sideración los esquemas color globales; tipos, tamaños estilos del texto; uso medios complementarios (audio, video animación) todos los demás elementos estéticos una aplicación. análisis exhaustivo los temas del diseño gráfico webapps está más allá del alcance este libro. lector puede obtener recomendaciones lineamientos muchos sitios web dedicados dicha materia (como uno más documentos impresos (como [roc] [gor]). veces, mejor manera entender que buen diseño webapps ver algunos ejemplos. artículo “las veinte mejores recomendaciones para diseño web”, marcelle toor ( ) recomienda los siguientes sitios como ejemplos que constituye buen diseño gráfico: empresa diseño dirigida por primo angeli este sitio presenta los portafolios varios ilustradores diseñadores serie televisión radio públicas acerca música estadounidense empresa diseño con portafolio línea buenas recomendaciones diseño buena fuente sitios bien diseñados desarrollados por agencias, empresas artes gráficas otros especialistas comunicación compañía diseño encabezada por beth toudreauinformación sitios web bien diseñados . iseño del contenido diseño del contenido centra dos tareas diferentes del diseño, cada una las cuales dirigida por individuos que poseen habilidades distintas. primer lugar, desarrolla una -presentación del diseño para los objetos del contenido los mecanismos requeridos para esta-blecer una relación entre ellos. además, crea información dentro objeto contenido específico. trabajo posterior llevado cabo por escritores, diseñadores gráficos otros actores que generan contenido que usará webapp. .. objetos contenido relación entre los objetos contenido definidos como parte del modelo requerimientos para webapp los objetos diseño que representan contenido análoga relación que existe entre las clases análisis los componentes del diseño que describió capítulos anteriores. contexto del diseño webapp, objeto contenido parece más objeto datos del software tradicional. objeto contenido tiene atributos que incluyen información contenido específico (normalmente definido durante modelado los reque-rimientos webapp) atributos implementación específica que establecen como parte del diseño. por ejemplo, piense una clase análisis, componentedelproducto, desarrollada para sistema comercio electrónico casasegura. atributo clase análisis, descripción, representa como clase análisis llamada descripcióndecomponente está compuesta por cinco objetos contenido: descripcióndelmercado, fotografía, descripcióntécnica, esquema video, que muestran como objetos sombreados figura .. información cita: “los buenos diseñadores gene- ran regularidad partir del caos; comunican sus ideas con claridad, organizando mani-pulando palabras imágenes.” jeffery veen (-).indd (-).indd // ::// :: diseño webapps contenida dentro del objeto contenido etiqueta como atributos. por ejemplo, fotografía (imagen tipo .jpg) tiene los atributos dimensión horizontal, dimensión vertical estilo bordes. puede usarse una asociación uml agregado para representar relaciones entre los - jetos contenido. por ejemplo, asociación uml que ilustra figura . indica que usa una descripcióndecomponente para cada instancia clase componentedelpro- ducto. descripcióndecomponente está integrada sobre los cinco objetos contenido ilustrados. sin embargo, notación multiplicidad que aprecia indica que esquema video son opcionales (son posibles ocurrencias), que requiere una descripcióndelmer- cado una descripcióntécnica, que emplean una varias instancias fotografía. .. aspectos diseño del contenido una vez modelados los objetos del contenido, información que entregar cada objeto debe registrar autor después editarse para que satisfaga del mejor modo posible las necesidades del consumidor. autoría del contenido trabajo especialistas área relevante quien diseña objeto contenido, dando bosquejo información que entregar una indicación los tipos objetos contenido general (por ejemplo, texto descriptivo, imágenes, fotografías, etc.) que usarán para entregar información. diseño estético (véase sección .) también puede aplicarse para representar vista sensación apropiadas para contenido. los objetos “cortan” [pow] medida que diseñan para formar las páginas web- app. número objetos contenido incorporado una página individual está función las necesidades del usuario, las restricciones impuestas por velocidad descarga conexión internet las restricciones impuestas por cantidad desplazamiento ver-tical que usuario tolerará. apéndice estudian ambas representaciones.componentedelproducto númerodeparte nombredepartetipodepartedescripciónprecio crearnuevoartículo( ) descripcióndelapantalla( )mostrarespeciﬁcacionestécnicas descripcióndemercado color textoestilo fuentetamaño fuenteespacio entre líneastamaño texto usocolor del fondofotografía dimensión horizontaldimensión verticalestilo bordesesquema dimensión horizontaldimensión verticalestilo bordesdescripcióntécnica color textoestilo fuentetamaño fuenteespacio entre líneastamaño texto imagencolor del fondovideo dimensión horizontaldimensión verticalestilo bordesvolumen del audiodescripcióndel componente parte .. .. .. ..*sensor cámara panel controlcaracterísticas del softwarefigura . representación del diseño objetos contenido (-).indd (-).indd // ::// :: parte dos modelado . iseño arquitectónico diseño arquitectónico está ligado con las metas establecidas para una webapp, con conte- nido que presentar, con los usuarios que visitarán con filosofía navegación adoptada. como diseñador arquitectura, lector debe identificar arquitectura del con-tenido webapp. arquitectura del contenido centra manera que los objetos contenido ( compuestos, como páginas web) estructuran para presentación navegación. arquitectura webapp aboca forma que aplicación queda estructurada para administrar interacción con usuario, manejar tareas procesamiento interno, navegar con eficacia presentar contenido. mayoría los casos, diseño arquitectónico lleva cabo paralelo con interfaz, estético del contenido. como arquitectura webapp tal vez esté muy - fluida por navegación, las decisiones que tomen durante esta acción del diseño influirán trabajo realizado durante diseño aquélla. .. arquitectura del contenido diseño del contenido centra definición estructura general los hipermedios webapp. aunque ocasiones crean arquitecturas personalizadas, siempre tiene opción elegir entre cuatro distintas estructuras contenido [pow]: las estructuras lineales (véase figura .) encuentran cuando común una secuencia predecible interacciones (con cierta variación diferencia). ejemplo clásico presen-tación tutoriales los que despliegan páginas información junto con imágenes rela- cionadas, videos cortos audio, sólo después haber mostrado cierta información prerre-quisitos. secuencia presentación del contenido predefinida por general lineal. otro ejemplo sería una secuencia entrada para ordenar producto que debe propor-cionarse información específica orden determinado. tales casos, resultan apropiadas las estructuras mostradas figura .. medida que contenido procesamiento hacen más complejos, flujo exclusivamente lineal que aprecia izquierda figura origen estructuras lineales más complejas las que puede invocarse contenido alternativo cita: “… estructura arquitectónica sitio bien diseñado siempre visible para usua-rio: debe serlo.” thomas powell término arquitectura información también utiliza para denotar estructuras que produzcan una mejor organización, etiquetado, navegación búsqueda objetos contenido.¿qué tipos arquitectura del contenido común encontrar?? lineal lineal con ﬂujo opcionallineal con desviacionesfigura . estructuras lineales (-).indd (-).indd // ::// :: diseño webapps las que sucede una desviación para adquirir contenido complementario (estructura que apa- rece lado derecho figura .). las estructuras malla (véase figura .) son una opción arquitectónica que aplica cuando posible organizar contenido una webapp forma categórica dos ( más) dimensiones. por ejemplo, considere una situación que sitio comercio electrónico vende palos golf. dimensión horizontal malla representa tipo palo (madera, metal, cuña, mazo, etc.). dimensión vertical representa las ofertas que hacen los distintos fabricantes palos golf. entonces, usuario podría navegar por malla forma hori-zontal fin encontrar columna mazos después forma vertical para examinar las ofertas los fabricantes que los venden. esta arquitectura webapps útil sólo cuando encuentra contenido muy regular [pow]. las estructuras jerárquicas (véase figura .) son sin duda arquitectura más común las webapps. diferencia las jerarquías software divididas que estudiaron capítulo que motivan controlar flujo sólo largo las ramas verticales jerarquía, estructura jerárquica las webapps diseña forma tal que permite (por medio rami-ficación del hipertexto) que flujo del control sea sentido horizontal través las ramas verticales estructura. así, contenido presentado última rama del lado izquierdo jerarquía puede tener vínculos hipertexto que llevan directamente contenido que existe parte media rama del lado derecho estructura. sin embargo, debe observarse figura . estructura malla figura . estructura jerárquica (-).indd (-).indd // ::// :: parte dos modelado que aunque dicha ramificación permite una navegación rápida por contenido webapp, genera confusión para usuario. una estructura red “telaraña pura” (véase figura .) similar muchos sentidos arquitectura que evoluciona partir sistemas orientados objetos. los componentes -quitectónicos (páginas web, este caso) diseñan modo que pasan virtualmente control (por medio vínculos hipertexto) cada componente del sistema. este enfoque permite una flexibilidad considerable navegación, pero mismo tiempo confunde usuario. las estructuras arquitectónicas estudiadas los párrafos anteriores combinan para for- mar estructuras compuestas. arquitectura general una webapp puede ser jerárquica, pero una parte estructura puede tener características lineales otra, forma red. meta del diseñador arquitectónico ajustar estructura webapp con contenido que presen- tarse con procesamiento que efectuarse. .. arquitectura las webapps arquitectura una webapp describe una infraestructura que permite que sistema apli-cación basados web alcance sus objetivos empresariales. jacyntho . [jac] describe las características básicas esta infraestructura del modo siguiente: las aplicaciones deben construirse con empleo capas las que tomen cuenta distintas preocupaciones; particular, deben separarse los datos aplicación los contenidos ésta (nodos navegación), éstos, vez, deben separarse con toda claridad del aspecto sensación interfaz (páginas). los autores sugieren una arquitectura del diseño tres capas que desacopla interfaz navegación del comportamiento aplicación. plantean que mantener separadas inter-faz, aplicación navegación, simplifica implementación mejora reutilización. arquitectura controlador vista del modelo (cvm) [kra] uno varios modelos sugeridos para infraestructura webapps que desacoplan interfaz usuario sus fun-ciones contenido informativo. modelo ( veces denominado “objeto modelo”) contiene todo contenido lógica procesamiento específicos aplicación, incluso todos los objetos contenido, acceso fuentes datos información externos todas las funciones procesamiento que son específicas aplicación. vista contiene todas las funciones espe- cíficas interfaz permite presentación contenido lógica procesamiento, incluidos figura . estructura red debe observarse que cvm realidad patrón diseño arquitectónico desarrollado para ambiente smalltalk (véase que puede usarse para cualquier aplicación inter- activa.punto clave arquitectura cvm desacopla interfaz usuario las funciones webapp del contenido información. (-).indd (-).indd // ::// :: diseño webapps todos los objetos contenido, acceso fuentes datos información del exterior todas las funciones procesamiento que requiere usuario final. controlador administra acceso modelo vista, coordina flujo datos entre ellos. una webapp, “ vista actuali-zada por controlador con datos del modelo, basándose las entradas que usuario” [wmt]. figura . muestra una representación arquitectura cvm. relación con figura, controlador maneja las solicitudes datos del usuario. contro- lador también selecciona objeto vista que sea aplicable con base solicitud del usuario. una vez determinado tipo solicitud, transmite modelo pedido comportamiento, que implementa funcionalidad recupera contenido requerido para dar acomodo -licitud. objeto modelo accede los datos almacenados una base datos corporativa, como parte almacén datos locales como una colección archivos independientes. objeto vista apropiado debe dar formato organizar los datos desarrollados por modelo para luego trasmitirlos desde servidor aplicación hacia navegador del cliente para que desplieguen máquina éste. muchos casos, arquitectura webapp define contexto del ambiente desarrollo que implementarse aplicación. lector está interesado, puede con- sultar [fow] análisis los ambientes desarrollo papel que juegan diseño arquitecturas aplicaciones web. . iseño navegación una vez que arquitectura webapp sido establecida han identificado sus componen- tes (páginas, textos, subprogramas otras funciones procesamiento), deben definirse las rutas navegación que permitan los usuarios acceder contenido las funciones web app. para lograr esto, debe hacerse siguiente: ) identificar semántica navegación para los distintos usuarios del sitio ) definir mecánica (sintaxis) para efectuar navegación. .. semántica navegación como muchas acciones del diseño webapps, diseño navegación comienza con consideración jerarquía del usuario los casos uso relacionados (véase capítulo ), nave- gador cliente datos htmlsolicitud datos del usuariocontrolador administra las solicitudesdel usuarioselecciona comportamientodel modeloselecciona respuestade vista vistaprepara los datos del modelosolicita actualizaciones del modelopresenta vista seleccionada porel controladormodelocontiene las funcionescontiene objetos contenidoincorpora estados webapp selección vistasolicitud comportamiento (cambio estado) actualización solicitud servidordatos externosdatos del modelofigura . arquitectura cvmfuente: adaptado [jac]. cita: “gretel, sólo espera que salga luna veremos las migajas del pan que desmenucé; ellas nos mostrarán camino regreso casa.” hansel gretel (-).indd (-).indd // ::// :: parte dos modelado desarrollados para cada categoría usuario (actor). cada actor puede usar webapp forma algo diferente, por que tendrán distintos requerimientos navegación. además, los casos uso desarrollados por cada actor definirán conjunto clases que incluirán uno más obje-tos contenido funciones webapp. medida que cada usuario interactúe con web-app, encuentra una serie unidades semánticas navegación (usn): “conjunto estructuras información navegación relacionadas que colaboran para cumplimiento subcon-junto requerimientos del usuario relacionados” [cac]. una usn está compuesta por conjunto elementos navegación llamados [gna] formas navegar (fdn). una fdn representa mejor ruta navegación fin lograr una meta para tipo usuario específico. cada fdn está organizada como conjunto nodos navegación () conectados por vínculos. ciertos casos, vínculo navegable otra usn. entonces, estructura navegación general una webapp está organizada como jerarquía usn. para ilustrar desarrollo una usn, considere caso uso seleccionarcomponentes decasasegura: caso uso: seleccionar componentes casasegura webapp recomendará componentes del producto (como paneles control, sensores, cámaras, etc.) otras características (como funciones con base implementadas software) para cada habitación entrada exterior. piden alternativas, webapp las dará, caso que existan. podré obtener información descriptiva precios cada componente del producto. webapp creará mostrará una cuenta los materiales conforme seleccione distintos componentes. podré dar nombre cuenta los materiales guardarla para futuras referencias (véase caso uso guardar configuración). los conceptos subrayados descripción del caso uso representan clases objetos contenido que incorporarán una más usn que permitirán que cliente experimente escenario descrito caso uso seleccionar componentes casasegura. figura . ilustra análisis parcial semántica navegación que implica caso uso seleccionar componentes casasegura . con empleo terminología mencionada, figura también representa una forma navegación (fden) para webapp casaseguraasegurada.com. las clases importantes dominio del problema muestran junto con objetos seleccionados contenido ( este caso, paquete objetos contenido llamado descripcióndecomponentes, atributo clase componentedelproducto). estos con- ceptos son nodos navegación. cada flecha representa vínculo navegación tiene leyenda con acción iniciada por usuario que hace que vínculo tenga lugar. posible crear una usn para cada caso uso asociado con cada rol usuario. por ejem- plo, cliente nuevo casaseguraasegurada.com puede tener tres diferentes casos uso, los cuales dan como resultado acceso distintas funciones información webapp. crea entonces una usn para cada meta. durante las etapas iniciales del diseño navegación, evalúa arquitectura del conte- nido webapp fin determinar una más fdn para cada caso uso. como dijo, una fdn identifica los nodos navegación (por ejemplo, contenido) después los vínculos que permiten navegar entre ellos. entonces, las fdn están organizadas usn. .. sintaxis navegación avanzar diseño, tarea siguiente definir mecánica navegación. dispone varias opciones para desarrollar enfoque implementación para cada usn:punto clave una usn describe los requerimientos navegación para cada caso uso. esencia, usn muestra forma que actor avanza entre los objetos contenido entre las funciones una webapp. éstas denominan veces vínculos semánticos navegación (vsn) [cac].cita: “ problema navegación sitio web conceptual, técnico, espacial, filosófico logístico. consecuencia, las soluciones tienden reclamar combinaciones complejas improvisadas arte, ciencia psicología organizacional.” tim horgan (-).indd (-).indd // ::// :: diseño webapps • vínculo navegación individual: incluye vínculos basados texto, iconos, botones interruptores, así como metáforas gráficas. deben elegirse vínculos que sean apropiados para contenido consistentes con heurística que conduzca diseño una interfaz alta calidad. • barra navegación horizontal: enlista las categorías principales contenido funciones una barra que contiene vínculos apropiados. general, enlistan cuatro siete categorías. • columna navegación vertical: ) enlista las principales categorías contenido funciones ) enlista virtualmente todos los principales objetos contenido que hay dentro webapp. elige segunda opción, las columnas navegación pueden “expandirse” para que presenten objetos contenido como parte una jerarquía (seleccionar una entrada columna original ocasiona una expansión que enlista una segunda capa objetos contenido relacionados). • pestañas: metáfora que más que una variación barra columna navega-ción representa categorías contenido funciones como pestañas que selec-cionan cuando requiere vínculo. • mapas del sitio: dan una tabla contenido que incluye todo contenido fin navegar hacia todos los objetos funciones contenidas dentro webapp. además elegir mecánica navegación, también deben establecerse las convenciones ayudas apropiadas para navegar. por ejemplo, los iconos vínculos gráficos deben invitar hacer “clic” ellos, desvaneciendo las aristas fin darles una apariencia tridimensional. debe diseñarse retroalimentación auditiva visual con objeto dar usuario una indicación que escogido cierta opción navegación. para navegación basada texto debe utilizarse color que indique los vínculos navegación que señale aquéllos recorridos. éstas son unas cuantas convenciones entre las decenas que hay para diseño que hacen que navegación sea amigable para usuario. . iseño nivel componentes las webapps modernas dan funciones procesamiento cada vez más complejas que: ) reali- zan procesamiento localizado para generar contenido capacidad navegación forma dinámica, ) proporcionan capacidad cómputo procesamiento datos que resultan apropiados para dominio del negocio webapp, ) dan consulta acceso complejos <<vínculo navegación seleccionar habitación <<vínculo navegación vista cuentadelosmateriales<<vínculo navegación regresar habitación <<vínculo navegación comprar componentedelproducto<<vínculo navegación recommend component()<<vínculo navegación solicitar alternativa <<vínculo navegación mostrar componentedelproducto <<vínculo navegación mostrar descripción<<vínculo navegación comprar componentedelproductohabi- tación cuentadelos materialescomponente delproducto descripcióndelcomponente descripcióntécnicafotografía esquema videodescripcióndemercadofigura . creación una usn mayoría situaciones, elija mecanismos navegación horizontales verticales, pero ambos.consejo mapa del sitio debe ser accesible desde cualquier página. mapa mismo debe estar organizado modo que estructura información webapp vea fácilmente.consejo (-).indd (-).indd // ::// :: parte dos modelado bases datos ) establecen interfaces datos con sistemas corporativos externos. para lograr estas capacidades ( muchas otras) deben diseñarse construirse componentes pro-gramas con forma idéntica los componentes del software tradicional. los métodos diseño estudiados capítulo aplican los componentes las web- apps con poca, ninguna, modificación. ambiente implementación, los lenguajes pro-gramación, los patrones diseño, estructuras software, tal vez varíen poco, pero enfo-que general del diseño mismo. . étodo diseño hipermedios orientado objetos (mdhoo) última década, han propuesto varios métodos diseño para aplicaciones web. hasta hoy, ninguno ellos dominante. esta sección presenta panorama breve uno los métodos diseño webapps más estudiado. daniel schwabe . [sch, sch] propusieron por primera vez método diseño hipermedios orientado objetos (mdhoo), que está compuesto cuatro distintas actividades diseño: diseño conceptual, diseño navegación, diseño abstracto interfaz implemen-tación. figura . presenta resumen estas actividades diseño las sec-ciones que siguen analizan brevemente. .. diseño conceptual del mdhoo diseño conceptual del mdhoo genera una representación los subsistemas, clases rela- ciones que definen dominio aplicación para webapp. puede utilizar uml para crear diagramas clase apropiados, agregaciones representaciones compuestas clase, diagra-mas colaboración otra clase información que describa dominio aplicación. realidad, son relativamente pocos los desarrolladores web que usan método específico cuando trabajan una webapp. hay esperanza que este enfoque -hoc del diseño cambie medida que transcurra tiempo. mdhoo prescribe una notación específica; sin embargo, empleo común cuando aplica este - todo.productos del trabajo mecanismos diseño preocupaciones del diseñosemántica modelado deldominio laaplicaciónclases, subsistemas, relaciones, atributos clasiﬁcación, composición,agregación,generalización,especializacióndiseño conceptual diseño navegacióndiseño abstracto interfaz implementación vínculos nodos,estructuras acceso,contextos navegación,transformacionesde navegación mapeo entre objetos conceptuales denavegación toma cuenta perﬁl del usuario tarea.hace énfasis enaspectos cognitivosobjetos abstractosde interfaz, respuestas aeventos externos,transformaciones mapeo entre navegación losobjetos perceptibles modelado los objetos perceptibles, implementaciónde las metáforas escogidas.descripción interfazpara objetos navegaciónwebappejecutable recurso proporcionadopor elambiente meta corrección; desempeño dela aplicación;completitudfigura . resumen del mdhoofuente: adaptadode [sch]. (-).indd (-).indd // ::// :: diseño webapps como ejemplo sencillo del diseño conceptual del mdhoo, piense aplicación comer- cio electrónico casaseguraasegurada.com. figura ., presenta “esquema con- ceptual”. durante diseño conceptual reutilizan los diagramas clase, agregaciones - formación desarrollada como parte del análisis webapp, con objeto representar las relaciones entre clases. .. diseño navegación para mdhoo diseño navegación identifica conjunto “objetos” que derivan las clases defi- nidas diseño conceptual. para incluir éstos, define una serie “clases navegación” “nodos”. utiliza uml para crear casos uso, tablas estado diagramas secuencia apropiados; todas éstas son representaciones que ayudan entender mejor los requerimientos navegación. además, conforme desarrolla diseño, utilizan patrones para dise- navegación. mdhoo emplea conjunto predefinido clases navegación: nodos, vínculos, anclas estructuras acceso [sch]. estas últimas son más elaboradas incluyen mecanismos tales como índice webapp, mapa del sitio recorrido guiado. una vez definidas las clases navegación, mdhoo “estructura espacio navegación, agrupando los objetos navegación conjuntos llamados contextos” [sch]. contexto incluye descripción estructura navegación local, restricción impuesta acceso los objetos contenido los métodos (operaciones) requeridos para acceder los objetos contenido. desarrolla una plantilla contextual (análoga las tarjetas crc estudiadas capítulo ) que emplea para dar seguimiento los requerimientos navegación cada categoría usuario través los distintos contextos definidos mdhoo. hacer esto, surgen trayectorias específicas navegación (que sección .. llamamos fdn). .. diseño abstracto interfaz implementación acción diseño abstracto interfaz especifica los objetos interfaz que usuario cuando ocurre una interacción con webapp. emplea modelo formal objetos inter-componentedelproducto númerodeparte nombredepartetipodepartedescripciónprecio crearnuevoartículo( ) obtenerdescripción( )obtenerespeciﬁcacionestécnicas( )cuentadelosmateriales identiﬁcadorlistadecdmnúmerodeartículospreciototal agregarentrada( ) eliminarentrada( )editarentrada( )nombre( )calcularprecio( ) artículodecdm cantidadnúmerodepartenombredepartetipodeparteprecio agregaralista( ) eliminardelista( )obtenersiguienteentradadelista( ) orden númerodeordeninformaciónparaelclientecuentadematerialesinformacióndeentregainformacióndecuentahabitación nombredelahabitacióndimensionesventanasexteriorespuertasexteriores sensor cámara panel controlcaracterística del software cliente continúa con selección del componenteel cliente solicita comprarecomendación componente solicitadael cliente selecciona componentefigura . esquema conceptual parcial para casaseguraasegurada. com (-).indd (-).indd // ::// :: parte dos modelado faz, llamado vista datos abstractos (vda), para representar relación entre objetos interfaz navegación, así como las características comportamiento los objetos interfaz. modelo vda define una “plantilla estática” [sch] que representa metáfora - terfaz incluye una representación los objetos navegación dentro interfaz espe- cificación los objetos ésta (como menús, botones iconos) que ayudan navegación interacción. además, modelo vda contiene componente comportamiento (similar diagrama estado uml) que indica forma que los eventos “disparan navegación cuáles son las transformaciones interfaz que ocurren cuando usuario interactúa con aplicación” [sch]. actividad implementación del mdhoo representa una iteración del diseño específica del ambiente que opera webapp. las clases, navegación interfaz caracterizan cada una forma tal que pueden construirse para ambiente cliente-servidor, sistemas operativos, software apoyo, lenguajes programación, otras características ambientales que son -levantes para problema. . esumen calidad una webapp —definida términos usabilidad, funcionalidad, confiabilidad, eficiencia, facilidad mantenimiento, seguridad, escalabilidad tiempo para llegar mer-cado— introduce durante etapa diseño. para lograr estos atributos calidad, buen diseño webapp debe tener las siguientes características: sencillez, consistencia, identidad, robustez, navegabilidad atractivo visual. para lograrlo, actividad diseño webapp centra seis distintos elementos del diseño. diseño interfaz describe estructura organización interfaz usuario - cluye una representación distribución pantalla, una definición los modos inter-acción una descripción los mecanismos navegación. conjunto principios diseño interfaz flujo trabajo del diseño guían trabajo diseño distribución los mecanismos control interfaz. diseño estético, llamado también diseño gráfico, describe “aspecto sensación” webapp, incluye esquemas color; distribución geométrica; tamaño del texto, las fuentes colocación; empleo imágenes otras decisiones relacionadas con estética. con-junto lineamientos diseño gráfico base para enfoque diseño. diseño del contenido define distribución, estructura bosquejo todo contenido que presenta como parte webapp, establece las relaciones entre los objetos del contenido. diseño del contenido comienza con representación sus objetos, así como las asociacio-nes relaciones entre ellos. conjunto primitivas navegación establece base para diseño ésta. diseño arquitectónico identifica estructura general los hipermedios para webapp, incluye arquitectura del contenido webapp. los estilos arquitectónicos para conte- nido incluyen estructuras lineales, malla, jerárquicas red. arquitectura webapp describe una infraestructura que permite que sistema aplicación basado web cumpla con sus objetivos negocios. diseño navegación representa flujo ésta entre los objetos contenido todas las funciones webapp. semántica navegación define, describiendo conjunto unidades semánticas navegación. cada unidad está compuesta por formas navegación, así como vínculos nodos para ello. sintaxis navegación ilustra los mecanismos utilizados para navegar descritos como parte semántica. diseño los componentes desarrolla lógica procesamiento detallada que requiere para implementar componentes funcionales que desarrollen una función completa web- (-).indd (-).indd // ::// :: diseño webapps app. las técnicas diseño descritas capítulo son aplicables para ingeniería los componentes webapp. método diseño hipermedios orientado objetos (mdhoo) una varias pro- puestas para hacer diseño webapps. mdhoo sugiere proceso que incluye diseño conceptual, diseño navegación, diseño abstracto interfaz implementación. problemas puntos por evaluar .. ¿por qué insuficiente para elaborar webapps filosofía diseño del “ideal artístico”? ¿hay algún caso que ésa sea filosofía por seguir? .. este capítulo selecciona conjunto amplio atributos calidad las webapps. seleccione las tres que crea que son las más importantes construya argumento que explique por qué debe hacerse énfasis cada una durante trabajo diseño webapps. .. agregue menos cinco preguntas adicionales lista verificación del diseño webapps que presentó sección .. .. lector diseñador webapps corporación aprendizaje del futuro, compañía aprendi- zaje distancia. trata implementar “motor aprendizaje” basado internet que permita entregar contenido curso los estudiantes. motor aprendizaje brinda infraestructura básica para entre-gar contenido del aprendizaje sobre cualquier tema (los diseñadores del contenido prepararán que sea apropiado). desarrolle diseño prototipo interfaz para motor aprendizaje. .. ¿cuál sitio web estética más agradable que usted haya visitado por qué?.. considere objeto contenido orden, generado una vez que usuario casaseguraasegu- rada.com haya terminado selección todos los componentes esté listo para finalizar compra. - sarrolle una descripción uml para orden, así como todas las representaciones del diseño que sean apropia- das. .. ¿cuál diferencia entre arquitectura del contenido una webapp? .. reconsidere “motor aprendizaje” aprendizaje del futuro que describió problema ., seleccione una arquitectura del contenido que resulte apropiada para webapp. analice porqué selección... utilice uml para desarrollar tres cuatro representaciones del diseño objetos contenido que encontrarían diseñar “motor aprendizaje” descrito problema .. .. investigue poco acerca arquitectura controlador vista del modelo (cvm) decida sería apropiada para webapp del “motor aprendizaje” del problema .. .. ¿cuál diferencia entre sintaxis navegación semántica ésta?.. defina dos tres usn para webapp casaseguraasegurada.com. describa con detalle cada una... escriba texto breve sobre método diseño hipermedios que sea mdhoo. lecturas adicionales fuentes información van duyne . (the design sites , . ., prentice hall, ) escribieron libro exhaustivo que cubre mayoría aspectos importantes del proceso diseño webapps. cubre con detalle los modelos del proceso diseño los patrones diseño. wodtke ( information architecture , new riders publishing, ), rosenfeld morville (information architecture for the world wide web, ’reilly & associates, ), reiss (practical information architecture, addison-wesley, ) abordan arquitectura del contenido otros -mas. aunque han escrito cientos libros sobre “diseño web”, son muy pocos los que estudian métodos técnicos significativos para hacer trabajo diseño. mejor los casos, presentan varios lineamien-tos útiles para diseño webapps, dan ejemplos páginas web programación java analizan los detalles técnicos importantes para implementar webapps modernas. entre los representantes esta cate- (-).indd (-).indd // ::// :: parte dos modelado goría están los libros sklar (principles web design, . ., course technology, ), mcintire (visual design for the modern web, new riders press, ), niederst ( web design nutshell, . ., -reilly, ), eccher (advanced professional web design , charles river media, ), cederholm ( bulletproof web design, new riders press, ) shelly . ( web design, . ., course technology, ). estudio enciclopédico powell [pow] profundo análisis nielsen [nie] sobre diseño también son útiles cualquier biblioteca. los libros beaird ( the principles beautiful web design, sitepoint, ), clarke holzschlag (trans- cending css: the fine art web design, new riders press, ) golbeck (art theory for web design , addi- son wesley, ), hacen énfasis diseño estético son una lectura benéfica para los profesionales con poca experiencia tema. punto vista ágil del diseño ( otros temas) webapps presentado por wallace . (extreme programming for web projects, addison-wesley, ). conallen (building web applications with uml, . ., addison-wesley, ) rosenberg scott (applying use-case driven object modeling with uml , addison- wesley, ) presentan ejemplos detallados webapps modeladas con empleo uml. contexto libros escritos acerca ambientes específicos desarrollo, también mencionan técnicas diseño. los lectores interesados ello deben estudiar textos sobre html, css, , java, .net, xml, perl, ruby rails, ajax varias aplicaciones empleadas para crear webapps ( dreamweaver, homepage, frontpage, golive, macromedia flash, etc.) con trucos diseño útiles. internet hay una amplia variedad fuentes información sobre diseño webapps. sitio web del libro, encuentra una lista actualizada referencias red mundial que son relevantes para -seño webapps: (-).indd (-).indd // ::// :: calidadparte tres esta parte ingeniería del software, aprenderá los principios, con- ceptos técnicas que aplican para administrar controlar - lidad del software. los próximos capítulos responderán pre- guntas como las siguientes: • ¿cuáles son las características generales del software alta cali-dad? • ¿cómo revisa calidad qué manera llevan cabo revisio-nes eficaces? • ¿ qué consiste aseguramiento calidad del software? • ¿qué estrategias son aplicables para probar software? • ¿qué métodos utilizan para diseñar casos prueba eficaces? • ¿hay métodos realistas que aseguren que software correcto? • ¿cómo pueden administrarse controlarse los cambios que siempre ocurren cuando elabora software? • ¿qué medidas unidades medición usan para evaluar calidad los modelos requerimientos diseño, código fuente casos prueba? una vez respondidas estas preguntas, lector estará mejor preparado para asegurar que producido software alta calidad. (-).indd (-).indd // ::// :: calidad conceptos clave acciones administración . . calidad . . . . . . . . . . . . . . . . calidad. . . . . . . . calidad. . . . . . . calidad. . . calidad. . . . . . vista cuantitativo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . bueno. . . . . ¿qué ? respuesta tan fácil como quizá piense. calidad reconoce cuando , por que puede ser algo difícil defi-nir. pero para software computadora, calidad algo que debe definirse, eso que hare-mos este capítulo. ¿quién hace? los involucrados proceso del soft- ware —ingenieros, gerentes todos los participantes— son los responsables calidad. ¿por qué importante? puede hacerse bien puede repetirse. equipo software hace énfasis cali-dad todas las actividades ingeniería software, reduce número repeticiones que deben hacerse. esto como resultado menores costos , que más importante, mejora tiempo llegada mercado.¿cuáles son los pasos? para lograr software alta calidad, deben ocurrir cuatro actividades: usar procesos prácticas probados ingeniería software, adminis-trar bien proyecto, realizar control calidad exhaustivo contar con infraestructura aseguramiento calidad. ¿cuál producto final? software que satisface las necesidades del consumidor, con desempeño apropia- confiable, que agrega valor para todos los que utilizan. ¿cómo aseguro que hice bien? hay que dar seguimiento calidad, estudiando los resultados todas las actividades control calidad midiendo ésta con estudio los errores antes entrega los defectos detectados campo. una mirada rápidael redoble tambores para mejorar calidad del software comenzó tan luego que éste empezó integrarse cada faceta nuestras vidas. década , las principa-les corporaciones reconocieron que cada año desperdiciaban miles millones dólares software que tenía las características funcionalidad que habían prometido. que era peor, tanto gobierno como industria preocupaban por posibilidad que alguna falla software pudiera afectar infraestructura importante provocara pérdidas decenas miles millones dólares. despuntar nuevo siglo, cio magazine [lev] dio alerta: “dejemos desperdiciar $ mil millones dólares año”, lamentaba hecho que “las empresas estadounidenses gastan miles millones dólares software que hace que supone que debe hacer”. informationweek [ric] hizo eco misma preocupación: pesar las buenas intenciones, código defectuoso sigue siendo duende industria del software, responsable hasta % del tiempo que están fuera los sistemas basados compu-tadoras costó las empresas estadounidenses alrededor $ mil millones dólares último año pérdidas productividad reparaciones, afirma standish group, empresa investigación mercados. eso incluye costo que implica perder los clientes disgustados. como los productores tecnologías información escriben aplicaciones que basan software empacado infraes-tructura, código defectuoso también puede inutilizar aplicaciones personalizadas… pero, ¿cuán malo software defectuoso? las respuestas varían, mas los expertos dicen que sólo requiere tres cuatro defectos por cada líneas código para que programa tenga mal desempeño. hay que pensar que mayoría los programadores cometen error cada líneas código que escriben, que, multiplicado por los millones líneas que hay muchos productos comerciales, permite imaginar que corrección los errores cuesta los vendedores software menos mitad sus presupuestos desarrollo durante las pruebas. ¿comprende que esto sig-nifica? (-).indd (-).indd // ::// :: conceptos calidad . ¿ calidad ? libro místico, zen arte del mantenimiento motocicleta, robert persig [per] comenta siguiente acerca que llamamos calidad: calidad… sabes que , pero sabes que . pero eso una contradicción. algunas cosas son mejores que otras; decir, tienen más calidad. pero cuando tratas decir que calidad, ade-más las cosas que tienen, todo desvanece… hay nada qué hablar. pero puede decirse qué calidad, ¿cómo saber que , incluso saber que existe? nadie sabe que , entonces, para todos los propósitos prácticos, existe absoluto. pero para todos los propósitos prácticos, realidad existe. ¿ qué otra cosa basan las calificaciones? ¿por qué paga fortunas gente por algunos artículos tira otros basura? obvio que algunas cosas son mejores que otras… pero, ¿ qué son mejores? así damos vueltas más vueltas, ruedas metal que patinan sin nada que hagan tracción. ¿qué demonios calidad? ¿qué ? cierto: ¿qué ? nivel algo pragmático, david garvin [gar], harvard business school, sugiere que “ calidad concepto complejo facetas múltiples” que puede describirse desde cinco diferentes puntos vista. punto vista trascendental dice (como persig) que calidad algo que reconoce inmediato, pero que posible definir explícitamente. punto vista del usuario concibe calidad términos las metas específicas del usuario final. producto las satisface, tiene calidad. punto vista del fabricante define términos las especificaciones originales del producto. éste las cumple, tiene calidad. punto vista del producto sugiere que calidad tiene que ver con las características inherentes (funciones características) producto. por último, punto vista basado valor mide acuerdo con que cliente está dispuesto pagar por producto. realidad, calidad incluye todo esto más. calidad del diseño refiere las características que los diseñadores especifican para producto. tipo materiales, tolerancias especificaciones del desempeño, todo contribuye calidad del diseño. utilizan mejores materiales, tolerancias más estrictas especi-fican mayores niveles desempeño, calidad del diseño producto incrementa fabrica acuerdo con las especificaciones. desarrollo del software, calidad del diseño incluye grado que diseño cumple las funciones características especificadas modelo requerimientos. calidad conformidad centra grado que implementación apega diseño que sistema resultante cumple sus metas requerimientos desempeño. , computerworld [hil] quejaba que “ mal software una plaga casi todas las organizaciones que emplean computadoras, que ocasiona horas trabajo perdidas por tiempo que están fuera uso las máquinas, por datos perdidos corrompidos, oportunida-des venta perdidas, costos elevados apoyo mantenimiento, poca satisfacción del cliente. año después, infoworld [fos] escribió acerca del “lamentable estado calidad del software” informaba que problema calidad había mejorado. actualmente, calidad del software preocupante, pero, ¿ quién culpa? los clientes culpan los desarrolladores, pues afirman que sus prácticas descuidadas producen software mala calidad. los desarrolladores culpan los clientes ( otros participantes) con afirmación que las fechas entrega irracionales flujo continuo cambios los obligan entregar software antes haber sido validado por completo. ¿quién tiene razón? ambos, ése problema. este capítulo analiza concepto calidad del software por qué útil estu-diarlo con seriedad siempre que apliquen prácticas ingeniería software. cita: “ gente olvida cuán rápido hiciste trabajo, pero siem-pre recuerda cuán bien realizaste.” howard newton¿cuáles son las diferentes maneras enlas que puede verse lacalidad?consejo (-).indd (-).indd // ::// :: parte tres administración calidad pero, ¿son calidad del diseño conformidad los únicos aspectos que deben conside- rar los ingenieros software? robert glass [gla] afirma que mejor plantear una relación más intuitiva: satisfacción del usuario = producto que funciona + buena calidad + entrega dentro del presupuesto plazo última instancia, glass sostiene que calidad importante, pero que usuario está satisfecho, nada demás importa. demarco [dem] refuerza esta opinión decir que “ calidad producto está función cuánto cambia mundo para bien”. este punto vista calidad afirma que producto software beneficia mucho los usuarios -nales, éstos mostrarán dispuestos tolerar problemas ocasionales confiabilidad desem-peño. . alidad del software incluso los desarrolladores software más experimentados estarán acuerdo que obtener software alta calidad una meta importante. pero, ¿cómo define calidad del software? sentido más general define como: proceso eficaz software que aplica manera que crea producto útil que proporciona valor medible quienes producen quienes utilizan. hay pocas dudas acerca que definición anterior podría modificarse ampliarse debate sin fin. para propósitos este libro, misma sirve fin enfatizar tres puntos impor-tantes: . proceso eficaz software establece infraestructura que apoyo cualquier -fuerzo elaboración producto software alta calidad. los aspectos -ministración del proceso generan las verificaciones equilibrios que ayudan evitar que proyecto caiga caos, contribuyente clave mala calidad. las prácticas ingeniería software permiten desarrollador analizar problema diseñar una solución sólida, ambas actividades críticas construcción software alta cali-dad. por último, las actividades sombrilla, tales como administración del cambio revi-siones técnicas, tienen tanto que ver con calidad como cualquier otra parte práctica ingeniería software. . producto útil entrega contenido, funciones características que usuario final - sea; sin embargo, igual importancia que entrega estos activos forma confiable libre errores. producto útil siempre satisface los requerimientos establecidos forma explícita por los participantes. además, satisface conjunto requerimientos (por ejemplo, facilidad uso) con los que espera que cuente software alta calidad. . agregar valor para productor para usuario producto, software alta calidad proporciona beneficios organización que produce comunidad usuarios finales. organización que elabora software obtiene valor agregado por-que software alta calidad requiere menor esfuerzo mantenimiento, menos errores que corregir poca asistencia cliente. esto permite que los ingenieros soft-ware dediquen más tiempo crear nuevas aplicaciones menos repetir trabajos mal hechos. comunidad usuarios obtiene valor agregado porque aplicación provee una capacidad útil forma tal que agiliza algún proceso negocios. resultado final ) mayores utilidades por producto software, ) más rentabilidad cuando una esta definición sido adaptada [bes] sustituye aquélla más orientada manufactura presentada ediciones anteriores este libro. (-).indd (-).indd // ::// :: conceptos calidad aplicación apoya proceso negocios ) mejor disponibilidad información, que crucial para negocio. .. dimensiones calidad garvin david garvin [gar] sugiere que calidad debe tomarse cuenta, adoptando punto vista multidimensional que comience con evaluación conformidad termine con una -sión trascendental (estética). aunque las ocho dimensiones garvin calidad fueron desarrolladas específicamente para software, aplican calidad éste: calidad del desempeño. ¿ software entrega todo contenido, las funciones las -racterísticas especificadas como parte del modelo requerimientos, manera que -lor usuario final? calidad las características. ¿ software tiene características que sorprenden agra- dan primera vez que emplean los usuarios finales? confiabilidad. ¿ software proporciona todas las características capacidades sin fallar? ¿está disponible cuando necesita? ¿entrega funcionalidad libre errores? conformidad. ¿ software concuerda con los estándares locales externos que son rele- vantes para aplicación? ¿concuerda con diseño facto las convenciones código? por ejemplo, ¿ interfaz usuario está acuerdo con las reglas aceptadas del diseño para selección menú para entrada datos? durabilidad. ¿ software puede recibir mantenimiento (cambiar) corregirse (depurarse) sin generación inadvertida eventos colaterales? ¿los cambios ocasionarán que tasa errores confiabilidad disminuyan con tiempo? servicio. ¿existe posibilidad que software reciba mantenimiento (cambios) - rrecciones (depuración) periodo tiempo aceptablemente breve? ¿ equipo apoyo puede adquirir toda información necesaria para hacer cambios corregir defec-tos? douglas adams [ada] hace comentario irónico que parece pertinente: “ dife-rencia entre algo que puede salir mal algo que posiblemente salga mal que cuando esto último sale mal, por general imposible corregirlo repararlo.” estética. hay duda que todos tenemos una visión diferente muy subjetiva que estético. aun así, mayoría nosotros estaría acuerdo que una entidad -tética posee cierta elegancia, flujo único una “presencia” obvia que difícil cuanti-ficar que, obstante, resulta evidente. software estético tiene estas características. percepción. ciertas situaciones, existen prejuicios que influirán percepción calidad por parte del usuario. por ejemplo, introduce producto software elabo-rado por proveedor que pasado demostrado mala calidad, estará receloso percepción calidad del producto tendrá influencia negativa. manera similar, vendedor tiene una reputación excelente percibirá buena calidad, aun ésta reali-dad existe. las dimensiones calidad garvin dan una visión “suave” calidad del software. muchas estas dimensiones (aunque todas) sólo pueden considerarse manera subjetiva. por esta razón, también necesita conjunto factores “duros” calidad que clasifican dos grandes grupos: ) factores que pueden medirse forma directa (por ejemplo, defectos descubiertos durante las pruebas) ) factores que sólo pueden medirse indirectamente (como usabilidad facilidad recibir mantenimiento). cada caso deben hacerse medi-ciones: debe compararse software con algún dato para llegar indicador calidad. (-).indd (-).indd // ::// :: parte tres administración calidad .. factores calidad mccall mccall, richards walters [mcc] proponen una clasificación útil los factores que afectan calidad del software. éstos ilustran figura . centran tres aspectos impor-tantes del producto software: sus características operativas, capacidad ser modificado adaptabilidad nuevos ambientes. relación con los factores mencionados figura ., mccall ., hacen las descrip- ciones siguientes: corrección. grado que programa satisface sus especificaciones que cumple con los objetivos misión del cliente. confiabilidad. grado que espera que programa cumpla con función con precisión requerida [debe notarse que han propuesto otras definiciones más completas confiabilidad (véase capítulo )]. eficiencia. cantidad recursos cómputo código requeridos por programa para llevar cabo función.integridad. grado que posible controlar acceso personas autorizadas software los datos.usabilidad. esfuerzo que requiere para aprender, operar, preparar las entradas interpretar las salidas programa.facilidad recibir mantenimiento. esfuerzo requerido para detectar corregir error programa (ésta una definición muy limitada). flexibilidad. esfuerzo necesario para modificar programa que opera.susceptibilidad someterse pruebas. esfuerzo que requiere para probar programa fin garantizar que realiza función que pretende. portabilidad. esfuerzo que necesita para transferir programa ambiente sistema hard- ware software otro.reusabilidad. grado que programa ( partes uno) pueden volverse utilizar otras apli- caciones ( relaciona con empaque alcance las funciones que lleva cabo programa).interoperabilidad. esfuerzo requerido para acoplar sistema con otro. difícil — , ciertos casos, imposible— desarrollar mediciones directas estos factores calidad. realidad, muchas las unidades medida definidas por mccall ., sólo operación del productotransición del producto revisión del producto corrección usabilidad eﬁciencia conﬁabilidad integridadfacilidad recibir mantenimiento flexibilidadsusceptibilidad someterse pruebasportabilidadreusabilidadinteroperabilidad figura . factores calidad mccall cita: “ amargura mala cali- dad permanece mucho tiempo después que olvida- dulzura haber cumplido plazo programado.” karl weigers (cita sin acreditación) una medición directa implica que hay solo valor cuantificable que una indicación directa del atributo estudio. por ejemplo, “tamaño” programa mide directamente, contando número sus líneas código. (-).indd (-).indd // ::// :: conceptos calidad pueden obtenerse manera indirecta. sin embargo, evaluación calidad una aplica- ción por medio estos factores dará indicio sólido ella. .. factores calidad iso estándar iso desarrolló con intención identificar los atributos clave del software cómputo. este sistema identifica seis atributos clave calidad: funcionalidad. grado que software satisface las necesidades planteadas según las establecen los atributos siguientes: adaptabilidad, exactitud, interoperabilidad, cumpli-miento seguridad. confiabilidad. cantidad tiempo que software encuentra disponible para uso, según indican los siguientes atributos: madurez, tolerancia fallas recuperación. usabilidad. grado que software fácil usar, según indican los siguientes subatributos: entendible, aprendible operable. eficiencia. grado que software emplea óptimamente los recursos del sistema, - gún indican los subatributos siguientes: comportamiento del tiempo los recursos. facilidad recibir mantenimiento. facilidad con que pueden efectuarse reparacio- nes software, según indican los atributos que siguen: analizable, cambiable, estable, susceptible someterse pruebas. portabilidad. facilidad con que software puede llevarse ambiente otro según indican los siguientes atributos: adaptable, instalable, conformidad sustituible. igual que otros factores calidad del software estudiados las subsecciones anteriores, los factores iso necesariamente conducen una medición directa. sin embargo, pro- porcionan una base útil para hacer mediciones indirectas una lista comprobación excelente para evaluar calidad del sistema. .. factores calidad que persiguen las dimensiones factores calidad presentados las secciones .. .. centran software como todo pueden utilizarse como indicación general calidad una aplicación. equipo software puede desarrollar conjunto características calidad las preguntas asociadas correspondientes que demuestren grado que satisface cada factor. por ejemplo, mccall identifica usabilidad como factor importante calidad. pidiera revisar una interfaz usuario para evaluar usabilidad, ¿cómo haría? comen-zaría con los subatributos propuestos por mccall —entendible, aprendible operable— pero sentido práctico: ¿qué significan éstos? para hacer evaluación, necesita determinar atributos específicos medibles ( menos reconocibles) interfaz. por ejemplo [bro]: intuitiva. grado que interfaz sigue patrones esperados uso, modo que hasta vato pueda utilizar sin mucha capacitación. • ¿ interfaz lleva hacia una comprensión fácil? • ¿todas las operaciones son fáciles localizar iniciar? • ¿ interfaz usa una metáfora reconocible? • ¿ entrada está especificada modo que economiza uso del teclado del ratón?aunque resulta tentador desarrollar mediciones cuantitativas para los factores calidad mencionados aquí, también puede crearse una lista comprobación atributos que den una indicación sólida presencia del factor.consejo estas características preguntas plantearían como parte revisión del software (véase capítulo ).cita: “cualquier actividad vuelve creativa cuando quien reali- importa hacerla bien, mejor.” john updike (-).indd (-).indd // ::// :: parte tres administración calidad • ¿ entrada sigue las tres reglas oro? (véase capítulo ) • ¿ estética ayuda comprensión uso? eficiencia. grado que posible localizar iniciar las operaciones información. • ¿ distribución estilo interfaz permite que usuario introduzca con eficiencia las operaciones información? • ¿una secuencia operaciones ( entrada datos) puede realizarse con economía movimientos? • ¿los datos salida contenido están presentados modo que entienden inmediato? • ¿las operaciones jerárquicas están organizadas manera que minimizan profun- didad con que debe navegar usuario para hacer que alguna ejecute? robustez. grado que software maneja entradas erróneas datos que pre- senta interacción inapropiada por parte del usuario. • ¿ software reconocerá error entran datos límite permitido más allá , que más importante, continuará operando sin fallar degradarse? • ¿ interfaz reconocerá los errores cognitivos manipulación guiará forma explícita usuario vuelta camino correcto? • ¿ interfaz diagnóstico guía útiles cuando descubre una condición error (asociada con funcionalidad del software)? riqueza. grado que interfaz provee conjunto abundante características. • ¿puede personalizarse interfaz según las necesidades específicas del usuario? • ¿ interfaz tiene gran capacidad para permitir usuario identificar una secuencia operaciones comunes con una sola acción comando? medida que desarrolla diseño interfaz, equipo del software revisa prototipo del diseño plantea las preguntas anteriores. respuesta mayor parte éstas “”, probable que interfaz usuario sea buena calidad. para cada factor calidad que desee evaluar desarrollan preguntas similares. .. transición punto vista cuantitativo las subsecciones anteriores presentaron varios factores cualitativos para “medición” calidad del software. comunidad ingeniería software trata obtener mediciones precisas calidad éste veces frustrada por naturaleza subjetiva actividad. cavano mccall [cav] analizan esta situación: determinación calidad factor clave los eventos cotidianos: concursos para catar - nos, eventos deportivos [como gimnasia], competencias talento, etc. estas situaciones juzga calidad del modo más fundamental directo: comparación directa objetos condiciones idénticas con conceptos predeterminados. vino juzga acuerdo con claridad, color, buqué, sabor, etc. sin embargo, este tipo juicio muy subjetivo; para que tenga algún valor, debe ser hecho por experto. subjetividad especialización también aplican determinación calidad del soft- ware. para ayudar resolver este problema, necesario tener una definición más precisa cali-dad del software, así como una forma realizar mediciones cuantitativas calidad fin hacer análisis objetivos… como existe algo parecido conocimiento absoluto, debe esperarse medir con toda exactitud calidad del software, porque toda medición imperfecta. jacob bronkowski (-).indd (-).indd // ::// :: conceptos calidad describió esta paradoja del conocimiento del modo siguiente: “año con año desarrollamos instrumen- tos más precisos para observar naturaleza con más nitidez. cuando vemos las observaciones, nos decepcionamos porque son borrosas sentimos que son tan inciertas como siempre”. capítulo presenta conjunto unidades medida aplicables evaluación cuantitativa calidad del software. todos los casos, las unidades representan mediciones indirectas, decir, nunca miden realmente calidad, sino alguna manifestación ella. factor que complica todo relación precisa entre variable que mide calidad del software. . dilema calidad del software una entrevista [ven] publicada web, bertrand meyer analiza que denomina dilema calidad: produce sistema software mala calidad, usted pierde porque nadie querrá comprar. por otro lado, dedica tiempo infinito, demasiado esfuerzo enormes sumas dinero para obtener elemento perfecto software, entonces tomará tanto tiempo terminarlo será tan caro produ-cir que todos modos quedará fuera del negocio. cualquier caso, habrá perdido ventana mercado, simplemente habrá agotado sus recursos. modo que las personas industria tratan situarse ese punto medio mágico donde producto suficientemente bueno para ser -chazado inmediato, evaluación, pero tampoco objeto perfeccionista con dema-siado trabajo que convierta algo que requiera demasiado tiempo dinero para ser terminado. correcto afirmar que los ingenieros software deben tratar producir sistemas alta calidad. mejor aplicar buenas prácticas intento lograrlo. pero situación descrita por meyer proviene vida real representa dilema incluso para las mejores organizaciones ingeniería software. .. software “suficientemente bueno” palabras sencillas, damos por válido argumento meyer, ¿ aceptable producir soft-ware “suficientemente bueno”? respuesta esta pregunta debe ser “”, porque las principa-les compañías software hacen diario. crean software con errores detectados distri-buyen una gran población usuarios finales. reconocen que algunas las funciones características versión . tal vez sean calidad más alta planean hacer mejoras versión .. hacen esto, sabiendo que algunos clientes quejarán; reconocen que tiempo para llegar mercado actúa contra mejor calidad, liberan software, siempre cuando producto entregado sea “suficientemente bueno”. exactamente, ¿qué significa “suficientemente bueno”? software suficientemente bueno contiene las funciones características alta calidad que desean los usuarios, pero mismo tiempo tiene otras más oscuras especializadas que contienen errores conocidos. vendedor software espera que gran mayoría usuarios finales perdone los errores gracias que estén muy contentos con funcionalidad aplicación. esta idea resulta familiar para muchos lectores. usted uno ellos, pido que considere algunos los argumentos contra “suficientemente bueno”. verdad que “suficientemente bueno” puede funcionar ciertos dominios aplicación para unas cuantas compañías grandes software. después todo, una empresa tiene presupuesto enorme para mercadotecnia convence suficientes personas que compren versión ., habrá tenido éxito capturarlos. como dijo, puede sostener que las ver-siones posteriores mejorará calidad. entregar versión . suficientemente buena, habrá capturado mercado.cuando enfrente dilema calidad ( todos hacen momento otro), trate alcanzar balance: suficiente esfuerzo para producir una calidad aceptable sin que sepulte proyecto.consejo (-).indd (-).indd // ::// :: parte tres administración calidad lector trabaja para una compañía pequeña, debe tener cuidado con esta filosofía. entregar producto suficientemente bueno (defectuoso), corre riesgo causar daño permanente reputación compañía. tal vez nunca tenga oportunidad entregar una versión . porque los malos comentarios quizá ocasionen que las ventas desplomen que empresa desaparezca. trabaja ciertos dominios aplicación (por ejemplo, software incrustado tiempo real) construye software aplicación integrado con hardware (como software automotriz telecomunicaciones), entregar software con errores conocidos una negligencia deja expuesta compañía litigios costosos. ciertos casos, incluso, puede ser delito. ¡nadie quiere tener software suficientemente bueno los aviones! así que proceda con cautela piensa que “suficientemente bueno” atajo que puede resolver los problemas calidad software. tal vez funcione, pero sólo para unos cuantos conjunto limitado dominios aplicación. .. costo calidad argumento algo parecido esto: sabemos que calidad importante, pero cuesta tiempo dinero —demasiado tiempo dinero— lograr nivel calidad software que realidad que-remos. visto así, este argumento parece razonable (véanse los comentarios anteriores meyer esta sección). hay duda que calidad tiene costo, pero mala calidad también tiene — sólo para los usuarios finales que deban vivir con software defectuoso, sino tam-bién para organización del software que elaboró que debe darle mantenimiento—. pregunta real ésta: ¿por cuál costo debemos preocuparnos? para responder esta pregunta debe entenderse tanto costo tener calidad como del software mala calidad. costo calidad incluye todos los costos los que incurre buscar calidad realizar actividades relacionadas con ella los costos posteriores falta calidad. para entender estos costos, una organización debe contar con unidades medición que provean fundamento del costo actual calidad, que identifiquen las oportunidades para reducir -chos costos que den una base normalizada comparación. costo calidad puede dividirse los costos que están asociados con prevención, evaluación falla. los costos prevención incluyen siguiente: ) costo las actividades administración requeridas para planear coordinar todas las actividades control aseguramiento -lidad, ) costo las actividades técnicas agregadas para desarrollar modelos completos los requerimientos del diseño, ) los costos planear las pruebas ) costo toda capacitación asociada con estas actividades. los costos evaluación incluyen las actividades investigación condición del pro- ducto “primera vez” que pasa por cada proceso. algunos ejemplos costos evaluación incluyen los siguientes: • costo efectuar revisiones técnicas (véase capítulo ) los productos del trabajo ingeniería software. • costo recabar datos unidades medida para evaluación (véase capítulo ) • costo hacer las pruebas depurar (véanse los capítulos ) los costos falla son aquellos que eliminarían hubiera errores antes después enviar producto los consumidores. los costos falla subdividen internos externos. incurre costos internos falla cuando detecta error producto antes del envío. los costos internos falla incluyen los siguientes: análisis útil los pros contras del software “suficientemente bueno” encuentra [bre]. tema incurrir costos significativos por prevención. esté seguro que inversión tendrá rendimiento excelente.consejo (-).indd (-).indd // ::// :: conceptos calidad • costo requerido por efectuar repeticiones (reparaciones para corregir error). • costo que incurre cuando una repetición genera inadvertidamente efectos colaterales que deban mitigarse. • los costos asociados con colección las unidades medida calidad que permitan que una organización evalúe los modos falla. los costos externos falla asocian con defectos encontrados después que producto envió los consumidores. algunos ejemplos costos externos falla son los solución quejas, devolución sustitución del producto, ayuda línea trabajo asociado con -rantía. mala reputación pérdida resultante negocios otro costo externo falla que resulta difícil cuantificar que, sin embargo, real. cuando produce software mala calidad, suceden cosas malas. que constituye una acusación contra los desarrolladores software que rehúsan considerar los costos falla externos, cem kaner [kan] afirma siguiente: muchos los costos falla externos, tales como los fondos comercialización, son difíciles cuantificar, por que muchas compañías los ignoran cuando calculan sus relaciones costo-bene-ficio. otros costos externos falla pueden reducirse ( dar apoyo barato debido mala calidad después hacer venta, cobrar apoyo los consumidores) sin que incremente satisfac-ción del cliente. ignorar los costos que los malos productos generan nuestros compradores, los ingenieros calidad estimulan una toma decisiones que los hace víctimas lugar satisfa-cerlos. como esperar, los costos relacionados con detección corrección errores defectos incrementan forma abrupta cuando pasa prevención detección, falla interna externa. figura ., basada datos obtenidos por boehm basili [boe] elaborada por cigital, inc. [cig], ilustra este fenómeno. costo promedio industria por corregir defecto durante generación código aproximadamente $ por error. promedio del costo que incurre industria por corregir mismo error descubre durante las pruebas del sistema $ . cigital, inc. [cig] tome cuenta que una aplicación grande contiene errores introducidos -rante codificación. acuerdo con datos promedio, costo encontrar corregir defectos durante fase codifica- ción $ por defecto. entonces, costo total por corregir los errores “críticos” durante esta fase ( × $) $ , aproximadamente.cita: “toma menos tiempo hacer algo bien que explicar por qué hizo mal.” . . longfellowrequerimientos$$ $$ $ diseño codiﬁcación pruebas mantenimiento$ . $ .$ .$ . $ .$ .$ .$ . $-figura . costo relativo corregir errores defectos (cifras dólares estadounidenses)fuente: adaptado [boe]. (-).indd (-).indd // ::// :: parte tres administración calidad los datos promedio industria indican que costo encontrar corregir defectos durante fase pruebas del sistema $ por cada uno. este caso, supone que dicha fase descubren aproximadamente defectos críticos (tan sólo % los descubiertos por cigital fase codificación), costo encontrarlos corregirlos ( × $ ) sería aproximadamente $ . esto también habría resultado errores críticos detectados corregidos. costo encontrar corregir estos defectos fase mantenimiento ( × $ ) habría sido $ . entonces, costo total encontrar corregir los defectos ($ + $ ) después fase codificación habría sido $ . aun organización software tuviera costos que fueran mitad del promedio industria ( mayor parte compañías tiene idea cuáles son sus costos), los ahorros asociados con control calidad temprano las actividades para aseguramiento (efectua-das durante análisis los requerimientos diseño) serían notables. .. riesgos capítulo este libro dijo que “ gente basa trabajo, confort, seguridad, entreteni-miento, decisiones propia vida, software cómputo. más vale que esté bien hecho”. implicación que software mala calidad aumenta los riesgos tanto para desarrollador como para usuario final. subsección anterior analizó uno dichos riesgos ( costo). pero perjudicial las aplicaciones mal diseñadas implementadas siempre mide dólares tiempo. ejemplo extremo [gag] servirá para ilustrar esto. mes noviembre , hospital panamá, pacientes recibieron dosis masivas rayos gama durante tratamiento contra diversos tipos cáncer. los meses que siguieron, estos pacientes murieron por envenenamiento radiactivo más sufrieron complicaciones serias. ¿qué fue que ocasionó esta tragedia? paquete software, desa-rrollado por una compañía estadounidense, que fue modificado por técnicos del hospital para calcular las dosis radiación para cada paciente. los tres médicos panameños que “pellizcaron” software para que diera capacidad adicio- nal fueron acusados asesinato segundo grado. empresa estados unidos enfrentó litigios serios los dos países. gage mccormick comentan siguiente: éste relato para prevenir los médicos, aun cuando luchen por estar fuera cárcel entienden hacen mal uso tecnología. tampoco narración cómo pueden salir heridos, algo peor, los seres humanos causa del software mal diseñado poco explicado, aunque hay -chos ejemplos respecto. ésta alerta para cualquier creador programas cómputo: cali-dad del software importa, las aplicaciones deben ser prueba tontos código mal desplegado — sea incrustado motor automóvil, brazo robótico dispositivo curación hospital— puede matar. mala calidad conlleva riesgos, algunos muy serios. .. negligencia responsabilidad historia muy común. una entidad gubernamental corporativa contrata una compañía importante desarrollo software una consultoría para que analice los requerimientos luego diseñe construya “sistema” basado software para apoyar alguna actividad -portancia. sistema debe auxiliar una función corporativa principal (como administración pensiones) alguna función gubernamental (por ejemplo, administración del cuidado salud los créditos hipotecarios). trabajo comienza con las mejores intenciones por ambas partes, pero momento que sistema entrega, las cosas han marchado mal. sistema retrasado, los resultados funciones deseadas, comete errores cuenta con aprobación del cliente. -mienzan los litigios. (-).indd (-).indd // ::// :: conceptos calidad mayor parte los casos, cliente afirma que desarrollador sido negligente ( cuanto manera que aplicó las prácticas del software), por que merece pago. frecuente que desarrollador diga que cliente cambiado repetidamente sus requeri-mientos trastornado diversas maneras los acuerdos para trabajo. cualquier caso, calidad del sistema que está entredicho. .. calidad seguridad medida que aumenta importancia crítica los sistemas aplicaciones basados web, seguridad las aplicaciones vuelto más importante. pocas palabras, software que tiene alta calidad fácil penetrar por parte intrusos , consecuencia, software mala calidad aumenta indirectamente riesgo seguridad, con todos los costos proble-mas que eso conlleva. una entrevista para computerworld, autor experto seguridad gary mcgraw - menta siguiente [wil]: seguridad del software relaciona por completo con calidad. debe pensarse seguridad, confiabilidad, disponibilidad dependencia, fase inicial, diseño, arquitectura, pruebas codificación, durante todo ciclo vida del software [proceso]. incluso las personas cons-cientes del problema seguridad del software centran las etapas finales del ciclo vida. entre más pronto detecte problema software, mejor. hay dos clases problemas. uno son los errores, que son problemas implementación. otro son las fallas del software: problemas arquitectura diseño. gente presta demasiada atención los errores pero suficiente las fallas. para construir sistema seguro hay que centrarse calidad, eso debe comenzar - rante diseño. los conceptos métodos analizados parte del libro llevan una arqui- tectura del software que reduce las “fallas”. eliminar las fallas arquitectura (con que mejora calidad del software) será más difícil que intrusos penetren software. .. efecto las acciones administración frecuente que calidad del software reciba influencia tanto las decisiones administrativas como las tecnológicas. incluso las mejores prácticas ingeniería software pueden ser arruinadas por malas decisiones gerenciales por acciones cuestionables administración del proyecto. parte este libro analiza administración del proyecto contexto del proceso del software. iniciar toda tarea del proyecto, líder éste tomará decisiones que tienen efecto significativo calidad del producto. decisiones estimación. como dice capítulo , equipo software rara vez puede darse lujo dar una estimación para proyecto antes que hayan establecido las fechas entrega especificado presupuesto general. vez ello, equipo realiza “filtro sanitario” para garantizar que las fechas entrega puntos revisión son racionales. muchos casos, hay una presión enorme del tiempo para entrar mercado que fuerza equipo aceptar fechas entrega irreales. consecuencia, toman atajos, pasan por alto las actividades que elevan calidad del software disminuye calidad del producto. una fecha entrega irracional, importante poner los pies sobre tierra. explique por qué necesita más tiempo , alternativamente , sugiera subconjunto funciones que puedan entregarse (sin demasiada calidad) tiempo programado. decisiones programación. cuando establece programa desarrollo pro- yecto software (véase capítulo ), establece secuencia las tareas con base dependencias. por ejemplo, como componente depende del procesamiento que ocurra (-).indd (-).indd // ::// :: parte tres administración calidad dentro los componentes , , componente puede programarse para ser probado hasta que los componentes , hayan sido probados por completo. programación del proyecto reflejaría esto. pero tiempo demasiado escaso debe disponerse para realizar pruebas importancia crítica, puede decidirse probar sin sus componentes subor- dinados (que están poco retrasados) fin que esté disponible para otras pruebas que realicen antes entrega. después todo, plazo final acerca. consecuencia, - dría tener defectos ocultos que sólo descubrirían mucho tiempo después. calidad bajaría. decisiones orientadas riesgo. administración del riesgo (véase capítulo ) uno los atributos clave proyecto exitoso software. realidad necesita saber que puede salir mal establecer plan contingencia para ese caso. demasiados equipos software prefieren optimismo ciego establecen programa desarrollo con suposi-ción que nada saldrá mal. que peor , tienen manera manejar las cosas que salgan mal. consecuencia, cuando riesgo convierte realidad, reina caos aumenta grado locuras que cometen, con que invariablemente calidad desploma. dilema calidad del software resume mejor con enunciado ley meskimen: nunca hay tiempo para hacerlo bien, pero siempre hay tiempo para hacerlo otra vez. consejo : tomarse tiempo para hacerlo bien casi nunca decisión equivocada. . ograr calidad del software calidad del software sólo . resultado buena administración del proyecto una correcta práctica ingeniería software. administración práctica aplican contexto cuatro actividades principales que ayudan equipo software lograr una alta calidad éste: métodos ingeniería software, técnicas administración proyectos, acciones control calidad aseguramiento calidad del software. .. métodos ingeniería software espera construir software alta calidad, debe entender problema que quiere resolver. también debe ser capaz crear diseño que esté acuerdo con problema que mismo tiempo tenga características que lleven software las dimensiones factores calidad que estudiaron sección .. parte este libro presentó una amplia variedad conceptos métodos que con- ducen una comprensión razonablemente completa del problema diseño exhaustivo que establece fundamento sólido para actividad construcción. lector aplica estos con-ceptos adopta métodos apropiados análisis diseño, eleva sustancialmente probabi-lidad crear software alta calidad. .. técnicas administración proyectos efecto las malas decisiones administración sobre calidad del software estudió sección ... las implicaciones son claras: ) gerente proyecto usa estimaciones para verificar que las fechas pueden cumplirse, ) comprenden las dependencias las acti-vidades programadas equipo resiste tentación usar atajos, ) planeación del riesgo lleva cabo manera que los problemas alienten caos, entonces calidad del soft-ware verá influida manera positiva. además, plan del proyecto debe incluir técnicas explícitas para administración calidad cambio. las técnicas que llevan buenas prácticas administración proyectos estudian parte este libro.¿qué necesito hacer para influir calidad manera positiva?? (-).indd (-).indd // ::// :: conceptos calidad .. control calidad control calidad incluye conjunto acciones ingeniería software que ayudan asegurar que todo producto del trabajo cumpla sus metas calidad. los modelos revisan para garantizar que están completos que son consistentes. código inspecciona con objeto descubrir corregir errores antes que comiencen las pruebas. aplica una serie eta- pas prueba para detectar los errores procesamiento lógico, manipulación datos -municación con interfaz. combinación mediciones con retroalimentación permite que equipo del software sintonice proceso cuando cualquiera estos productos del trabajo falla cumplimiento las metas calidad. las actividades control calidad estu-dian detalle que resta parte este libro. .. aseguramiento calidad aseguramiento calidad establece infraestructura apoyo los métodos sólidos ingeniería software, administración racional proyectos las acciones control calidad, todo importancia crucial trata elaborar software alta calidad. además, aseguramiento calidad consiste conjunto funciones auditoría reportes para evaluar eficacia completitud las acciones control calidad. meta del asegura-miento calidad proveer equipo administrativo técnico los datos necesarios para mantenerlo informado sobre calidad del producto, con que obtiene perspectiva confianza que las acciones necesarias para lograr calidad del producto funcionan. por supuesto, los datos provistos través del aseguramiento calidad identifican los problemas, res-ponsabilidad administración enfrentarlos aplicar los recursos necesarios para resolver los correspondientes calidad. capítulo estudia detalle aseguramiento calidad del software. . esumen preocupación por calidad los sistemas basados software aumentado medida que éste integra cada aspecto nuestras vidas cotidianas. pero difícil hacer descrip-ción exhaustiva calidad del software. este capítulo define calidad como proceso eficaz del software aplicado modo que crea producto útil que valor medible quie- nes generan quienes utilizan. con tiempo han propuesto varias dimensiones factores calidad del software. todos ellos tratan definir conjunto características que, logran, llevarán software alta calidad. mccall los factores calidad norma iso establecen características tales como confiabilidad, usabilidad, facilidad dar mantenimiento, funcionalidad portabili-dad, como indicadores existencia calidad. toda organización software enfrenta dilema calidad del software. esencia, todos quieren elaborar sistemas alta calidad, pero mundo dirigido por mercado, sencillamente dispone del tiempo esfuerzo requeridos para producir software “per-fecto”. cuestión siguiente: ¿debe elaborarse software que sea “suficientemente bueno”? aunque muchas compañías hacen eso, hay una desventaja notable que debe tomarse cuenta. sin importar enfoque que elija, calidad tiene costo que puede estudiarse térmi- nos prevención, evaluación falla. los costos prevención incluyen todas las acciones ingeniería software diseñadas para prevenir los defectos. los costos evaluación están asociados con aquellas acciones que evalúan los productos del trabajo software para deter-minar calidad. los costos falla incluyen precio interno fallar los efectos externos que precipitan mala calidad.¿qué control calidad del software?? webref pueden encontrarse vínculos útiles acerca técnicas aseguramiento calidad dirección (-).indd (-).indd // ::// :: parte tres administración calidad calidad del software consigue por medio aplicación métodos ingeniería software, prácticas adecuadas administración control calidad exhaustivo, todo cual apoyado por infraestructura aseguramiento calidad. los capítulos que siguen estudian con cierto detalle control aseguramiento calidad. problemas puntos por evaluar .. describa cómo evaluaría calidad una universidad antes inscribirse. ¿cuáles factores serían importantes? ¿cuáles tendrían importancia crítica? .. garvin [gar] describe cinco puntos vista distintos sobre calidad. ejemplo cada uno con uso uno más productos electrónicos conocidos con los que esté familiarizado. .. con uso definición calidad del software propuesta sección ., diga cree posible crear producto útil que genere valor medible sin uso proceso eficaz. explique respuesta. .. agregue dos preguntas adicionales cada una las dimensiones calidad garvin presentadas sección ... .. los factores calidad mccall desarrollaron década . casi todos los aspectos computación han cambiado mucho desde entonces, obstante cual aún aplican software moderno. ¿qué conclusiones saca con base ello? .. con empleo los subatributos mencionados sección .. para factor calidad llamado “facilidad recibir mantenimiento”, iso , desarrolle preguntas que exploren estos atributos existen . continúe ejemplo presentado sección ... .. describa con sus propias palabras dilema calidad del software... ¿qué software “suficientemente bueno”? mencione una compañía dada productos específicos que crea que fueron desarrollados con uso filosofía suficientemente bueno. .. considere cada uno los cuatro aspectos calidad diga cuál piensa que más caro por qué. .. haga una búsqueda web encuentre otros tres ejemplos “riesgos” para público que puedan atribuirse directamente mala calidad software. comience búsqueda http://catless.ncl. ./risks. .. ¿son mismo calidad seguridad? explique respuesta... explique por qué que muchos nosotros utilizamos ley meskimen. ¿qué ocurre con software negocios que causa esto? lecturas fuentes información adicionales los conceptos básicos calidad del software estudian los libros henry hanlon (software quality assurance, prentice-hall, ), kahn . ( software quality: concepts and practice, alpha science internatio- nal, ltd., ), ’regan ( practical approach software quality , springer, ) daughtrey ( fundamental concepts for the software quality engineer, asq quality press, ). duvall . ( continuous integration: improving software quality and reducing risk, addison-wesley, ), tian (software quality engineering, wiley-ieee computer society press, ), kandt (software engineering quality practices, auerbach, ), godbole (software quality assurance: principles and practice, alpha science international, ltd., ) galin ( software quality assurance: from theory implementation, addison-wes- ley, ) presentan estudios detallados del aseguramiento calidad del software. stamelos sfetsos (agile software development quality assurance, igi global, ) estudian aseguramiento calidad contexto del proceso ágil. diseño sólido conduce una alta calidad del software. jayasawal patton ( design for trustworthy soft- ware, prentice-hall, ) ploesch ( contracts, scenarios and prototypes, springer, ) analizan las herra- mientas técnicas para desarrollar software “robusto”. medición componente importante ingeniería calidad del software. ejiogu ( software - trics: the discipline software quality , booksurge publishing, ), kan ( metrics and models software (-).indd (-).indd // ::// :: conceptos calidad quality engineering, addison-wesley, ) nance arthur (managing software quality , springer, ) estudian unidades medida modelos importantes relacionados con calidad. los aspectos calidad del software orientados equipo los estudia evans ( achieving software quality through teamwork, artech house publishers, ). internet existe una amplia variedad fuentes información acerca calidad del software. sitio web del libro, dirección: htm, encuentra una lista actualizada referencias existentes red mundial que son relevantes para calidad del software. (-).indd (-).indd // ::// :: revisión conceptos clave amplificación del defecto . . . defectos . . . . . . . . . . . . . . . del error. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . revisión . . . . . . . . . . . . . . reporte. . . . . . . . . . . . . . . revisiones eficacia del costo las . . . informales . . . . . . . . . . . . orientadas muestreo . . . técnicas . . . . . . . . . . . . . . ¿qué ? conforme desarrollen los pro- ductos del trabajo ingeniería software cometerán errores. vergonzoso, mien-tras trate detectarlos corregirlos con ahínco —con mucho ahínco— antes que lleguen los usuarios finales. las revisiones técnicas son mecanismo más eficaz para detectar los errores una etapa tempra- del proceso software. ¿quién hace? son los ingenieros software quienes realizan una revisión técnica, también llamada revisión pares, con sus colegas. ¿por qué importante? encuentra error prin- cipio del proceso, menos caro corregirlo. además, los errores tienen modo amplificarse medida que avanza proceso. por ello, error relativamente peque- que deje sin atender comenzar proceso amplifica conjunto más grande errores una etapa posterior del proyecto. finalmente, las revisiones ahorran tiempo, reduciendo cantidad repeticiones que requerirán hacia final del proyecto. ¿cuáles son los pasos? enfoque las revisiones variará función del grado formalidad que elija. general, utilizan seis etapas, aunque todas emplean siempre: planeación, preparación, estructurar reunión, resaltar los errores, hacer las correcciones (fuera revisión) verificar que las correcciones hayan hecho forma apropiada. ¿cuál producto final? resultado una revisión una lista conceptos errores descubiertos. además, también indica estado técnico del producto final. ¿cómo aseguro que hice bien? primer lugar, seleccione tipo revisión que sea apropiada para cultura desarrollo. siga los lineamientos que lleven ejecutar revisiones exitosas. éstas conducen software alta calidad, habrá hecho bien. una mirada rápidalas revisiones del software son “filtro” para proceso del software. decir, aplican varios puntos durante ingeniería software sirven para descubrir errores defec-tos fin poder eliminarlos. las revisiones del software “purifican” los productos del trabajo ingeniería software, incluso los modelos requerimientos diseño, código datos prueba. freedman weinberg [fre] analizan del modo siguiente necesidad hacer revisiones: trabajo técnico necesita las revisiones por misma razón que los lápices necesitan borradores: errar humano. segunda razón por que son necesarias las revisiones técnicas porque, bien las personas son buenas para detectar algunos sus propios errores, muchas clases ellos pasan desapercibidos con más facilidad para quien los comete que para otras personas. por tanto, este pro-ceso revisión respuesta oración robert burns: , quiera algún dios regalo darnos vernos nosotros como los demás nos ven una revisión —cualquiera — una forma utilizar diversidad grupo para siguiente: . resaltar las mejoras necesarias producto que elaboró una sola persona equipo; . confirme aquellas partes producto las que desea necesita hacer una mejora; . realice trabajo técnico calidad más uniforme, menos más predecible, que pueda lograrse sin hacer revisiones, fin que trabajo técnico sea más manejable. como parte ingeniería software, pueden realizarse muchos diferentes tipos revi- siones. cada uno tiene lugar. una reunión informal alrededor máquina del café una forma revisión analizan problemas técnicos. presentación formal arquitectura del software público clientes, administradores técnicos también una forma revi-las revisiones son como filtros flujo del trabajo del proceso software. son muy pocas, flujo queda “sucio”. son demasiadas, hace lento hasta detenerse. utilice métricas para determinar cuáles son las revisiones que funcionan haga énfasis ellas. elimine del flujo las revisiones ineficaces, con objeto acelerar proceso.consejo (-).indd (-).indd // ::// :: técnicas revisión . fecto los defectos del software costo contexto del proceso del software, los términos defecto falla son sinónimos. los dos - plican problema calidad descubierto después haberse liberado software los usua- rios finales ( otra actividad estructural del proceso del software). capítulos anteriores empleó término error para denotar problema calidad descubierto por ingenieros software ( otra clase) antes entregar software usuario final ( alguna actividad estructural del proceso del software).sión. sin embargo, este libro nos centramos las revisiones técnicas por pares, ejemplifi- cadas por las revisiones casuales, walkthroughs inspecciones. desde punto vista del con- trol calidad, una revisión técnica () filtro más eficaz. realizado por ingenieros software ( otro tipo) para ingenieros software, medio eficaz para detectar errores mejorar calidad. considera una mejora proceso del software, problema calidad que propague una actividad estructural del proceso (como modelado) otra (como construcción) también llama “defecto”, porque debe encontrarse problema antes que producto del trabajo (como modelo del diseño) “libere” siguiente actividad. meta del control calidad del software, senti- más amplio administración calidad gene- ral, eliminar los problemas calidad que encuentren soft-ware. hace referencia estos problemas con diferentes nombres: equivocaciones, fallas, errores defectos, por mencionar algunos. ¿son sinónimos estos términos hay diferencias sutiles entre ellos? este libro hace una distinción clara entre error (problema calidad que detecta antes que software entregue los usuarios finales) defecto (problema calidad que encuentra después haber entregado software los usuarios finales ). esta distinción hace porque los errores defectos tienen muy distinto efecto económico, empresarial, sicológico humano. como ingenie-ros software, queremos encontrar corregir tantos errores como sea posible antes que consumidor usuario final los encuen-tren. queremos evitar los defectos porque hacen (justificadamente) que personal software vea mal. sin embargo, importante observar que distinción temporal entre errores defectos que hace este libro constituye prin-cipal forma pensar. consenso general comunidad inge-niería software que defectos, errores, fallas equivocaciones son sinónimos. decir, punto tiempo que encontró problema tiene que ver con término que usa para describirlo. parte argumentación favor este punto vista que ocasiones difícil hacer una distinción clara entre antes des-pués liberación (por ejemplo, considere proceso incremental desarrollo ágil). sin que importe modo que elija interpretar estos térmi- nos, hay que reconocer que momento que descubre problema importa, que los ingenieros software deben tratar detectar con ahínco —con mucho ahínco— los problemas antes que sus clientes usuarios finales los encuentren. lector está más interesado este tema, puede hallar análisis razonablemente completo terminología acerca las “equivocaciones” dirección equivocaciones, errores defectos objetivo principal las revisiones técnicas encontrar errores durante proceso fin que conviertan defectos después liberar software. beneficio obvio las revisiones técnicas descubrimiento temprano los errores, modo que propaguen siguiente etapa del proceso del software. varios estudios industria indican que las actividades diseño introducen por ciento todos los errores ( realidad todos los defectos) durante proceso del soft-ware. sin embargo, las técnicas revisión han demostrado tener una eficacia hasta por ciento [jon] para descubrir fallas del diseño. detectar eliminar gran porcentaje estos objetivo principal una revisión técnica formal detectar los errores antes que pasen otra actividad ingeniería software que entreguen usuario final.consejo (-).indd (-).indd // ::// :: parte tres administración calidad errores, proceso revisión reduce manera sustancial costo las actividades posterio- res proceso del software. . mplificación eliminación del defecto para ilustrar generación detección errores durante las acciones diseño generación código proceso software, puede usarse modelo amplificación del defecto [ibm]. figura . ilustra esquemáticamente modelo. cuadro representa una acción ingeniería software. durante acción, los errores generan manera inad-vertida. revisión puede fracasar descubrir los errores nuevos que generan los come-tidos etapas anteriores, que como resultado cierto número errores pasados por alto. ciertos casos, los errores etapas anteriores ignorados son amplificados ( factor amplificación) por trabajo curso. las subdivisiones los cuadros representan cada una estas características porcentaje eficiencia detección errores, que una fun-ción profundidad revisión. figura . ilustra ejemplo hipotético amplificación del defecto para proceso software que hacen revisiones. figura, supone que cada etapa prueba detecta corrige por ciento todos los errores entrada sin que introduzcan nuevos errores (suposición optimista). diez defectos preliminares diseño amplifican errores antes que comiencen las pruebas. liberan campo errores latentes (defectos). figura . considera las mismas condiciones, excepto porque efectúan revisiones del diseño -digo como parte cada acción ingeniería software. este caso, son los errores cita: “dicen los médicos que sus inicios algunas enfermedades son fáciles curar pero difíciles reconocer… mas con paso del tiempo, detectaron trataron principio, vuelven fáciles reconocer pero difíci-les curar.” nicolás maquiaveloerrores pasados por altoetapa del desarrollo defectos detección errores etapa anteriorerrores amplificados : nuevos errores generadosporcentaje eficiencia detección erroreserrores que pasan etapa siguientefigura . modelo amplificación del defecto preliminar % detalle × . = . % /prueba unitaria × = % integración integración % validación % del sistema % errores latentes (defectos)figura . amplificación del defecto. sin revisiones (-).indd (-).indd // ::// :: técnicas revisión iniciales diseño preliminar (arquitectura) que amplifican antes comenzar las prue- bas. sólo existen tres errores latentes. pueden establecerse los costos relativos asociados con descubrimiento corrección errores, así como costo general (con sin revisión para nues-tro ejemplo hipotético). número errores detectados durante cada una las etapas citadas las figuras . . multiplica por costo que implica eliminar error (. unidades costo para diseño, . unidades costo antes las pruebas, unidades costo durante las pruebas unidades costo después entrega). con estos datos, costo total del desarrollo mantenimiento cuando efectúan revisiones unidades costo. cuando hacen revisiones, costo total unidades, casi tres veces más caro. debe dedicarse tiempo esfuerzo realización revisiones organización desa- rrollo debe destinar dinero para ello. sin embargo, los resultados del ejemplo anterior dejan pocas dudas acerca que puede pagar ahora que después deberá pagar mucho más. . étricas revisión empleo las revisiones técnicas son una las muchas acciones que requieren como parte las buenas prácticas ingeniería software. cada acción requiere esfuerzo humano diri-gido. como esfuerzo disponible para proyecto finito, importante que una organización software comprenda eficacia cada acción, definiendo conjunto métricas (véase capítulo ) que puedan utilizarse para evaluar esa eficacia. aunque han definido muchas métricas para las revisiones técnicas, conjunto relativa- mente pequeño una perspectiva útil. las siguientes métricas para revisión pueden obte-nerse conforme efectúe ésta: • esfuerzo preparación, : esfuerzo ( horas-hombre) requerido para revisar producto del trabajo antes reunión revisión real. • esfuerzo evaluación, : esfuerzo requerido ( horas-hombre) que dedica revisión real. • esfuerzo repetición, : esfuerzo ( horas-hombre) que dedica corrección los errores descubiertos durante revisión.diseño preliminar detalle /prueba unitaria integraciónprueba integración %prueba validación %prueba del sistema % errores latentes (defectos) % % . % • • . amplificación del defecto. efectúan revisiones estos multiplicadores son algo diferentes los datos presentados figura ., que más actual. sin - bargo, sirven para ilustrar los costos amplificación del defecto. (-).indd (-).indd // ::// :: parte tres administración calidad • tamaño del producto del trabajo, tpt: medición del tamaño del producto del trabajo que revisado (por ejemplo, número modelos uml número páginas documento líneas código). • errores menores detectados, errmenores: número errores detectados que pueden clasifi- carse como menores (requieren menos algún esfuerzo especificado para corregirse). • errores mayores detectados, errmayores: número errores encontrados que pueden clasifi- carse como mayores (requieren más que algún esfuerzo especificado para corregirse). estas métricas pueden mejorarse, asociando tipo producto del trabajo que revisó con las métricas obtenidas. .. análisis las métricas antes comenzar análisis deben hacerse algunos cálculos sencillos. esfuerzo total revisión número total errores descubiertos definen como sigue: revisión / / / errtot / errmenores / errmayores densidad del error representa los errores encontrados por unidad producto del trabajo - visada. densidad del error / errtot tpt por ejemplo, revisa modelo requerimientos con objeto encontrar errores, incon-sistencias omisiones, posible calcular densidad del error varias formas diferentes. modelo requerimientos contiene diagramas uml como parte páginas materiales descriptivos. revisión detecta errores menores mayores. por tanto, err tot = . den- sidad del error . errores por diagrama uml . errores por página del modelo reque-rimientos. las revisiones llevan cabo para varios tipos distintos productos del trabajo (por ejemplo, modelo requerimientos, modelo del diseño, código, casos prueba, etc.), por-centaje errores descubiertos por cada revisión confronta con número total errores detectados todas las revisiones. además, puede calcularse densidad del error para cada producto del trabajo. una vez recabados los datos para muchas revisiones efectuadas muchos proyectos, los valores promedio densidad del error permiten estimar número errores por hallar nuevo documento (aún revisado). por ejemplo, densidad promedio error para modelo requerimientos . errores por página, nuevo modelo requerimientos tiene una longitud páginas, una estimación gruesa sugiere que equipo software -contrará alrededor errores durante revisión del documento. sólo encuentra errores, habrá hecho trabajo extremadamente bueno desarrollar modelo requeri-mientos enfoque revisión fue tan profundo. una vez llevada cabo prueba (véanse los capítulos ), posible obtener datos adicionales del error, incluso esfuerzo requerido para detectar corregir errores descubier-tos durante las pruebas densidad del error del software. los costos asociados con detec-ción corrección error durante las pruebas pueden compararse con los las revisiones. esto analiza sección ... .. eficacia del costo las revisiones difícil medir tiempo real eficacia del costo cualquier revisión técnica. una organiza-ción ingeniería software puede evaluar eficacia las revisiones relación costo- (-).indd (-).indd // ::// :: técnicas revisión beneficio sólo después que éstas han terminado, que las unidades medida revisión han recabado, que los datos promedio han sido calculados que calidad posterior del software sido medida (mediante pruebas). regresamos ejemplo presentado sección .., determinó que densidad pro- medio del error para los modelos requerimientos era . errores por página. reveló que esfuerzo requerido para corregir error menor modelo era horas-hombre. vio que esfuerzo necesario para error mayor los requerimientos era horas-hombre. estudiar los datos recabados observa que los errores menores ocurrieron con una frecuen-cia cercana veces más que los errores mayores. por tanto, puede estimarse que esfuerzo promedio para detectar corregir error los requerimientos durante revisión alrededor horas-hombre. los errores relacionados con los requerimientos detectados durante las pruebas requieren promedio horas-hombre para encontrarse corregirse ( hay datos disponibles acerca severidad relativa del error). con estos promedios obtiene siguiente: esfuerzo ahorrado por error / pruebas / erevisiones / / horas-hombre/error como durante revisión del modelo requerimientos encontraron errores, tendrá ahorro cercano horas-hombre esfuerzo dedicado las pruebas. esto refiere sólo los errores relacionados con los requerimientos. beneficio general suman aquellos aso-ciados con diseño código. esfuerzo total conduce ciclos entrega más cortos mejor tiempo para llegar mercado. libro sobre revisión por pares, karl wiegers [wie] analiza datos procedentes anécdotas compañías grandes que han utilizado inspecciones ( tipo relativamente formal revisión técnica) como parte sus actividades control calidad del software. hewlett packard reportó rendimiento sobre inversión gracias las inspecciones afirmó que entrega real del producto aceleró promedio . meses-calendario. & -dicaba que las inspecciones habían reducido costo general los errores software factor , que calidad había mejorado orden magnitud que productividad había incrementado por ciento. otras empresas reportaban beneficios similares. las revisio-nes técnicas ( diseño otras actividades) generan una buena relación costo-beneficio verdad ahorran tiempo. pero para muchos profesionales del software, esta afirmación contra intuición. “las revisiones toman tiempo”, dicen, “ tenemos tiempo que perder…”. afirman que tiempo precioso cada proyecto software que actividad revisar “todo producto del trabajo con detalle” absorbe demasiado. los ejemplos presentados esta sección indican otra cosa. más importante que los datos industria sobre revisiones del software han recabado durante más dos décadas resumen cualitativamente las gráficas que aparecen figura . figura, trabajo efectuado cuando utilizan revisiones refleja pronto desa- rrollo incremento software, pero esta inversión temprana paga dividendos debido que reduce esfuerzo necesario para hacer pruebas correcciones. igual importancia que fecha entrega del desarrollo con revisiones ocurre antes que que hace sin revi-siones. ¡las revisiones quitan tiempo, ahorran! . evisiones : espectro formalidad las revisiones técnicas deben aplicarse con nivel formalidad apropiado para producto que elaborar, para plazo que tiene proyecto para personal que realice trabajo. (-).indd (-).indd // ::// :: parte tres administración calidad figura . ilustra modelo referencia para las revisiones técnicas [lai] que identifica cuatro características que contribuyen formalidad con que efectúa una revisión. cada una las características del modelo referencia ayuda definir nivel formalidad revisión. formalidad una revisión incrementa cuando: ) definen explícitamente roles distintos para los revisores, ) hay suficiente cantidad planeación preparación para revisión, ) define una estructura distinta para revisión (incluso tareas productos internos del trabajo) ) seguimiento por parte los revisores tiene lugar para cualesquiera correc-ciones que efectúen. para entender modelo referencia, supongamos que lector decidió revisar diseño interfaz para casaseguraasegurada.com. esto puede hacerse varias maneras diferentes, que van relativamente casual riguroso extremo. decide que enfoque casual más apropiado, pide algunos colegas (pares) que examinen prototipo interfaz esfuerzo por descubrir problemas potenciales. todos deciden que habrá preparación previa, pero que evaluarán prototipo una forma razonablemente estructurada: primero verán distribución, luego estética, después las opciones navegación, etc. como diseñador que , lector decide tomar algunas notas, pero nada formales. pero, ¿qué pasa interfaz crucial para éxito todo proyecto? ¿qué sucede acertado ergonomía dependen vidas humanas? debió concluirse que era necesario enfoque más riguroso. forma entonces equipo revisión. cada integrante éste tendrá planeaciónrequerimientos sin inspecciones con inspecciones deploymentdiseño código pruebaesfuerzo tiempofigura . esfuerzo realizado, con sin revisionesfuente: adaptado [fog]. revisiónplaneación preparación roles los individuosestructura reunión corrección veriﬁcaciónfigura . modelo referencia para hacer revisiones técnicas (-).indd (-).indd // ::// :: técnicas revisión rol específico: dirigir equipo, registrar las reuniones, presentar material, etc. cada revisor tendrá acceso producto del trabajo ( este caso, prototipo interfaz) antes que revisión tenga lugar dedicará tiempo búsqueda errores, inconsistencias omisiones. realizará conjunto tareas específicas con base una agenda que desarrollará antes que ocurra revisión. los resultados ésta serán registrados manera formal equipo decidirá sobre estado del producto del trabajo con base resultado revisión. los miembros del equipo también verificarán que las correcciones hagan manera adecuada. este libro consideran dos grandes categorías revisiones técnicas: revisiones infor- males revisiones técnicas más formales. dentro cada una ellas escogen varios enfo-ques diferentes. éstos presentan las secciones que siguen. . evisiones informales las revisiones informales incluyen una simple verificación escritorio trabajo inge-niería software, hecha con algún colega, una reunión casual (con más dos personas) con objeto revisar producto aspectos orientados revisión programación por pares (véase capítulo ). una verificación escritorio simple una reunión casual realizada con colega constituye una revisión. sin embargo, como hay una planeación preparación por adelantado, agenda estructura reunión, seguimiento los errores descubiertos, eficacia tales revisiones mucho menor que los enfoques más formales. pero una verificación escritorio sencilla descubre errores que otro modo propagarían proceso del soft-ware. una forma mejorar eficacia una verificación escritorio desarrollar conjunto listas revisión para cada producto grande del trabajo generado por equipo software. las preguntas que plantean lista son generales, pero servirán para guiar los revisores verificación del producto. por ejemplo, veamos una verificación escritorio del prototipo interfaz casaseguraasegurada.com. vez sólo jugar con prototipo esta-ción trabajo del diseñador, éste colega examinan con empleo una lista para -terfaces: • ¿ distribución está diseñada con empleo convenciones estándar? ¿ izquierda derecha? ¿ arriba abajo? • ¿ presentación necesita ser desplazada verticalmente? • ¿ usan con eficacia color ubicación, tipografía tamaño? • ¿todas las opciones funciones navegación están representadas mismo nivel abstracción? • ¿están etiquetadas con claridad todas las elecciones navegación? así sucesivamente. cualesquiera errores aspectos señalados por los revisores son registra-dos por diseñador para resolverlos tiempo después. las verificaciones escritorio progra-man forma hoc son obligatorias como parte las buenas prácticas ingeniería software. general, cantidad material por revisar relativamente pequeña tiempo total dedicado una revisión escritorio poco más una hora dos. capítulo describió programación por pares forma siguiente: “ reco- mienda que dos personas trabajen juntas una estación trabajo con objeto crear -digo una narración. esto proporciona mecanismo para resolver problemas asegurar calidad tiempo real (dos cabezas piensan más que una).” programación por pares caracteriza por una verificación escritorio continua. vez programar una revisión algún momento dado, programación por pares invita hacer (-).indd (-).indd // ::// :: parte tres administración calidad una revisión continua medida que crea producto (diseño código). beneficio inmediato descubrimiento los errores , consecuencia, mejora calidad del pro-ducto. estudio sobre eficacia programación por pares, williams kessler [wil] afir- man siguiente: las evidencias anecdóticas iniciales señalan que programación por pares una técnica poderosa para generar productivamente trabajos software alta calidad. los elementos pareja laboran comparten sus ideas para resolver las complejidades del desarrollo del software. realizan manera continua inspecciones que hace cada quien, que conduce una forma eliminación -fectos más rápida eficiente. además, mantienen centrados intensamente tarea uno del otro. algunos ingenieros software dicen que redundancia inherente construida programa- ción por parejas desperdicio recursos. después todo, ¿por qué asignar dos personas trabajo que podría ejecutar sólo una? respuesta esta pregunta encuentra sec-ción ... calidad del producto del trabajo generado como consecuencia programa-ción parejas mucho mejor que trabajo individuo, los ahorros relacionados con calidad justifican sobra “redundancia” implícita programación por parejas. aun cuando las revisiones estén bien organizadas lle- ven cabo manera apropiada, mala idea dar los revisores una “criba”. decir, útil tener una lista verifica-ción que cada revisor las preguntas que debe plantear acerca del producto específico del trabajo que revisa. una las listas más completas desarrollada por nasa centro goddard vuelos espaciales, disponible direc-ción http://-assurance.gsfc.nasa.gov/disciplines/qua-lity/index.php hay otras listas útiles revisión técnica que han sido propuestas por las siguientes entidades:process impact ( shtml) software dioxide ( conview.asp?=) macadamian ( open group architecture review checklist ( group.org/architecture/togaf-doc/arch//comp/clists/syseng.htm) dfas (puede descargarse, pal/ssps/docstds/spm.doc)información listas verificación para revisión . evisiones técnicas formales una revisión técnica formal (rtf) una actividad del control calidad del software realizada por ingenieros software ( otras personas). los objetivos una rtf son: ) descubrir los errores funcionamiento, lógica implementación cualquier representación del software; ) verificar que software que revisa cumple sus requerimientos; ) garantizar que soft-ware está representado acuerdo con estándares predefinidos; ) obtener software desarro-llado manera uniforme ) hacer proyectos más manejables. además, rtf sirve como método capacitación, pues permite que los ingenieros principiantes observen distintos enfo-ques análisis, diseño implementación del software. rtf también funciona para estimu-lar respaldo continuidad debido que varias personas familiarizan con software que otra manera hubieran visto. rtf realidad una clase que incluye walkthroughs inspecciones. cada rtf reali- como una reunión tendrá éxito sólo planea, controla ejecuta forma apropiada. las secciones que siguen presentan lineamientos similares aquellos usados para walk-through, como representativos revisión técnica formal. lector tiene interés las ins-cita: “ hay nada más urgente para alguien que corregir trabajo los demás.” mark twain (-).indd (-).indd // ::// :: técnicas revisión pecciones software obtener más información sobre walkthroughs, consulte [rad], [wie] [fre]. .. reunión revisión sin importar cuál formato rtf elija, cualquiera ellos debe cumplir las restricciones -guientes: • revisión deben involucrarse tres cinco personas (normalmente). • debe haber preparación previa, pero debe exigir más dos horas trabajo cada persona. • duración reunión revisión debe ser menos dos horas. dadas estas restricciones, debe resultar obvio que una rtf centra una parte específica ( pequeña) del software general. por ejemplo, vez tratar revisar todo diseño, hacen walkthrougs para cada componente grupo pequeño componentes. reducir alcance, rtf tiene mayor probabilidad detectar errores. atención rtf dirige producto (por ejemplo, una parte del modelo requeri- mientos, diseño detallado componente código fuente, etc.). individuo que haya desarrollado producto — productor— informa líder del proyecto que terminado que requiere hacer una revisión. líder del proyecto contacta líder revisión, quien evalúa producto cuanto conclusión, genera copias los materiales del producto las distri-buye dos tres revisores para preparación previa. espera que cada revisor dedique una dos horas inspección del producto, tome notas familiarice con trabajo. mismo tiempo, líder del proyecto también revisa producto establece una agenda para reunión revisión, que por general programa para día siguiente. reunión revisión acuden líder ésta, todos los revisores productor. uno los revisores adopta rol secretario, decir, quien registra (por escrito) todos los acontecimien- tos importantes que surjan durante revisión. rtf comienza con análisis agenda una introducción breve por parte del productor. después, éste procede “recorrer” producto del trabajo, explicando material, mientras los revisores hacen sus comentarios con base preparación que hicieron. cuando descubren problemas errores válidos, secretario toma nota ellos. terminar revisión, todos los asistentes deben decidir : ) aceptan producto sin - dificaciones, ) rechazan debido errores graves (una vez corregidos, realiza otra revisión) ) aceptan producto manera provisional ( encontraron errores menores que deben corregirse, pero necesita otra revisión). una vez tomada decisión, todos los asistentes rtf firman acta que indica participación acuerdo con los descubrimientos del equipo revisión. .. reporte registro revisión durante rtf, revisor ( secretario) registra activamente todos los asuntos que planteen. éstos resumen final reunión produce lista pendientes revisión . además elabora reporte técnico formal revisión. éste responde tres preguntas: . ¿qué fue que revisó? . ¿quién revisó? . ¿cuáles fueron los descubrimientos las conclusiones? resumen del reporte revisión una sola página (quizá con anexos) que vuelve par- del registro histórico del proyecto entrega líder del proyecto otras partes intere- sadas.webref documento formal inspection guidebook, nasa, puede descargarse del sitio satc.gsfc.nasa.gov/documents//gdb/.pdf punto clave una rtf centra una parte relativamente pequeña producto del trabajo. ciertas situaciones, buena idea que alguien distinto del productor haga walkthroug del producto que revisa. esto lleva una interpretación literal del producto mejorar reconocimiento errores.consejo (-).indd (-).indd // ::// :: parte tres administración calidad lista pendientes revisión tiene dos propósitos: ) identificar áreas problemas producto ) servir como lista verificación acciones que guíe productor cuando hagan las correcciones. lista pendientes normalmente anexa reporte técnico. debe establecerse procedimiento seguimiento para garantizar que los pendientes lista corrijan manera apropiada. menos que esto haga, posible que los pendien-tes anotados “ pierdan camino”. enfoque consiste asignar responsabilidad del seguimiento líder del proyecto. .. lineamientos para revisión los lineamientos para efectuar revisiones técnicas formales deben establecerse por adelantado, distribuirse todos los revisores, llegar consenso , después, seguirse. una revisión sin con-trol con frecuencia peor que hiciera ninguna. los siguientes representan conjunto mínimo lineamientos para hacer revisiones técnicas formales: . revise producto, productor . una rtf involucra personas sus egos. lleva cabo forma adecuada, rtf debe dejar todos los participantes una sensación logro. efectúa modo inapropiado, adopta aire inquisitorial. los errores deben señalarse forma amable; tono reunión debe ser relajado constructivo; tra-bajo debe apenar menospreciar nadie. líder revisión debe conducir -unión tono actitud apropiados debe detenerla inmediato sale control. . establezca una agenda sígala. una las fallas clave las reuniones todo tipo dispersión. una debe mantenerse encarrilada dentro del programa. líder revisión tiene responsabilidad que así sea debe sentir temor llamar - den las personas cuando dispersen. . limite debate las contestaciones. cuando revisor plantee asunto, quizá haya acuerdo universal acerca efecto. vez perder tiempo debatir cuestión, ésta debe registrarse para discutirla después. . uncie áreas problemas, pero intente resolver cada uno. una revisión una sesión para resolver problemas. frecuente que solución problema obtenga productor, solo con ayuda otra persona. solución los problemas debe pos- ponerse para después reunión revisión. . ome notas por escrito. veces buena idea que secretario tome notas piza- rrón fin que redacción prioridades sean evaluadas por los demás revisores medida que información registra. manera alternativa, pueden tomarse notas - rectamente una computadora. . limite úmero participantes insista preparación previa. dos cabezas piensan más que una, pero son necesariamente mejor que . mantenga limitado - mero personas involucradas. sin embargo, todos los miembros del equipo revi-sión deben prepararse. líder revisión tiene que solicitar comentarios por escrito ( que proporciona indicador que revisor inspeccionado material). . desarrolle una lista verificación par cada producto que sea probable que revise. una lista verificación ayuda líder del proyecto estructurar rtf cada revisor centrarse los aspectos importantes. deben desarrollarse listas para los productos del análisis, diseño, código incluso las pruebas. . asigne recursos progr ame tiempo para las rtf. para que las revisiones sean eficaces, deben programarse como tareas del proceso software. además, debe programarse tiempo para hacer las inevitables modificaciones que ocurrirán como resultado rtf. señale los errores forma grosera. una manera amable hacerlo plantear preguntas que lleven productor descubrir error.consejo cita: “una reunión muy frecuente-mente evento cual los minutos son tomados las horas son gastadas.” autor desconocido cita: “ una las más hermosas compensaciones vida, que ningún hombre pueda sincera-mente ayudar otro sin ayudarse mismo.” ralph waldo emerson (-).indd (-).indd // ::// :: técnicas revisión . una capacitación significativa todos los revisores. para que una revisión sea eficaz, todos los revisores deben recibir cierta capacitación formal. ésta debe hacer énfasis tanto aspectos relacionados con proceso como lado sicología humana revisión. freedman einberg [fre] estiman mes curva aprendizaje para que personas participen modo eficaz una revisión. . revise las primer revisiones. volver revisar puede ser benéfico para descubrir proble- mas con proceso revisión mismo. primer producto por revisar deben ser los lineamientos revisión. debido que son muchas las variables (número participantes, tipo productos del tra- bajo, tiempo duración, enfoque específico revisión, etc.) que influyen que una revisión sea exitosa, organización software debe experimentar para determinar enfoque que mejor funcione contexto local. .. revisiones orientadas muestreo idealmente, todo producto del trabajo ingeniería software debe pasar por una revisión técnica. mundo real los proyectos software, los recursos son limitados tiempo, escaso. consecuencia, frecuente que las revisiones omitan, aun cuando reconozca valor como mecanismo control calidad. thelin . [the] sugieren proceso revisión orientado muestreo que - man muestras todos los productos del trabajo ingeniería software fin inspeccio-narlos para determinar cuáles son más susceptibles tener errores. después enfocan todos los recursos rtf sólo aquellos productos los que sea muy probable encontrar errores (con base los datos obtenidos durante muestreo). para que sea eficaz, proceso revisión orientada muestreo debe tratar identificar aquellos productos del trabajo que sean objetivos principales para hacer rtf. para lograrlo sugiere seguir las etapas siguientes [the]: . inspeccionar una fracción cada producto del trabajo . registrar número fallas encontradas dentro . . desarrollar una estimación gruesa del número fallas producto del trabajo , con multiplicación por /. . ordenar los productos del trabajo orden descendente acuerdo con estimación gruesa del número fallas que hay cada uno. . dedicar los recursos disponibles para revisión aquellos productos que tengan - mero estimado más grande fallas. fracción del producto del trabajo que tomen muestras debe ser representativa del producto del trabajo total suficientemente grande fin que tenga significado para todos los revisores que hagan muestreo. medida que aumenta incrementa probabilidad que muestra sea una representación válida del producto del trabajo. sin embargo, los recursos requeridos para hacer muestreo también aumentan. equipo ingeniería software debe establecer mejor valor para los tipos productos generados. revisiones toman tiempo, éste estará bien invertido. sin embargo, hay poco tiempo hay otra opción, omita las revisiones. vez ello, aplique revisión orientadas muestreo.consejo thelin ., realizaron una simulación detallada que puede ayudar hacer esto. consulte [the] para mayores detalles. (-).indd (-).indd // ::// :: parte tres administración calidad . esumen objetivo toda revisión técnica detectar errores descubrir aspectos que tendrían efecto negativo software que desarrollar. entre más pronto descubra corrija error, menos probable que propague otros productos del trabajo ingeniería software que amplifique, que provocaría mayor esfuerzo para corregirlo. fin determinar las actividades control calidad funcionan, deben determinarse varias métricas. éstas centran esfuerzo requerido para realizar revisión los tipos severidad errores descubiertos durante revisión. una vez recabadas las métricas, usan para evaluar eficacia las revisiones que efectúen. los datos industria indican que las revisiones tienen rendimiento elevado sobre inversión. modelo referencia para formalidad revisión identifica roles las personas, planeación preparación, estructura reunión, enfoque corrección verificación como las características que indican grado formalidad con que realiza una revisión. las revisiones informales son naturaleza casual, pero pueden usarse con eficacia para detectar errores. las revisiones formales son más estructuradas tienen una probabilidad mayor dar como resultado software alta calidad. las revisiones informales caracterizan por tener una planeación preparación mínimas poco registro desarrollo. las verificaciones escritorio programación por parejas forman parte esta categoría revisión. una revisión técnica formal una reunión estilizada que demostrado ser extremada- mente eficaz para detectar errores. los walkthrougs las inspecciones establecen roles defini-dos para cada revisor, estimulan planeación preparación previa, requieren aplicación lineamientos revisión definidos ordenan llevar registros hacer reportes. las revisiones escena: oficina doug miller, comen- zar proyecto software casasegura. participantes: doug miller (gerente del equipo ingeniería software casasegura) otros miembros del equipo. conversación:doug: que hemos dedicado tiempo desarrollar plan calidad para este proyecto, pero estamos tenemos que tomar cuenta calidad… ¿correcto? jamie: seguro. decidimos que conforme desarrollemos modelo requerimientos [capítulos ], hará procedimiento para probar cada uno ellos. doug: eso realmente bueno, pero vamos esperar las pruebas para evaluar calidad, ¿verdad? vinod: , por supuesto que … hemos programado revisiones plan del proyecto para este incremento software. comenza-remos control calidad con las revisiones. jamie: preocupa poco que tengamos tiempo suficiente para hacer todas las revisiones. realidad, que tendremos. doug: mmm… ¿qué proponen?jamie: que seleccionemos aquellos elementos del modelo requerimientos diseño que tengan más importancia crítica para casasegura que los revisemos. vinod: pero, ¿qué pasa hay algo mal una parte que haya- mos revisado? shakira: leí algo sobre una técnica muestreo [sección ..] que podría ayudarnos determinar candidatos revisión (shaki- explica este enfoque.) jamie: quizá… pero estoy seguro que tengamos tiempo incluso para tomar muestras cada elemento los modelos. vinod: doug, ¿qué quieres que hagamos?doug: tomemos algo programación extrema [véase capítu- ]. desarrollaremos los elementos cada modelo parejas—dos personas— haremos una revisión informal cada una con-forme avancemos. entonces nos abocaremos los elementos “críticos” para hacer una revisión más formal equipo, pero hay que mantener esas revisiones mínimo. ese modo, todo será observado por más par ojos también cumpliremos nues-tras fechas entrega. jamie: eso significa que vamos tener que revisar programa- ción actividades. doug: así . calidad altera programación este proyecto.casasegura aspectos calidad (-).indd (-).indd // ::// :: técnicas revisión por muestreo utilizan cuando posible efectuar revisiones técnicas formales para todos los productos del trabajo. problemas puntos por evaluar .. explique diferencia entre error defecto. .. ¿por qué puede esperarse las pruebas para encontrar corregir todos los errores del software? .. suponga que modelo requerimientos han cometido errores que cada uno amplifi- cará factor : diseño, que cometerán otros errores diseño adicionales que luego amplificarán factor .: código, donde cometerán otros errores adicionales. suponga que todas las pruebas unitarias encontrarán por ciento todos los errores, que integración descubrirá por ciento los restantes que las pruebas validación hallarán por ciento los que queden. efectuarán revisiones. ¿cuántos errores saldrán público? .. vuelva considerar situación descrita problema ., pero ahora suponga que realizan revisiones los requerimientos, diseño código, con por ciento eficacia descubrimiento todos los errores esa etapa. ¿cuántos errores saldrán público? .. estudie nuevo situación descrita los problemas . .. cada uno los errores que salen público tiene costo $ por ser detectado corregido, hacer mismo para cada error descubierto revisión cuesta $, ¿cuánto dinero ahorra por efectuar revisiones? .. sus propias palabras, describa significado figura .... ¿cuál las características del modelo referencia piensa usted que tiene mayor efecto formalidad revisión? explique por qué. .. ¿ ocurren algunos casos los que una verificación escritorio genere problemas lugar beneficios? .. una revisión técnica formal eficaz sólo cada quien prepara por adelantado. ¿cómo reconoce participante que haya preparado? ¿qué haría usted fuera líder revisión? .. considerar todos los lineamientos para revisión presentados sección .., ¿cuál piensa que sea más importante por qué? lecturas fuentes información adicionales han escrito relativamente pocos libros sobre las revisiones software. algunas las ediciones recien-tes que dan una guía útil incluyen los textos wong ( modern software review, irm press, ), radice (high quality, low cost software inspections, paradoxicon publishers, ), wiegers ( peer reviews software: practical guide, addison-wesley, ) gilb graham ( software inspection, addison-wesley, ). freedman weinberg (handbook walkthroughs, inspections and technical reviews , dorset house, ) sigue siendo texto clásico todavía proporciona información útil acerca este tema tan importante. internet existe una amplia variedad fuentes información acerca calidad del software. sitio web del libro, encuentra una lista actualizada referencias existentes red mundial que son relevantes para las revisiones software, dirección professional/olc/ser.htm. (-).indd (-).indd // ::// :: calidad del software conceptos clave confiabilidad del software . . elementos del acs. . . . . . . . estadístico . . . . . . . . . . . . plan . . . . . . . . . . . . . . . . . tareas . . . . . . . . . . . . . . . enfoques formales. . . . . . . . iso - . . . . . . . . . . . . . . . . . . . del software . . . . sigma . . . . . . . . . . . . . ¿qué ? basta hablar por hablar para decir que calidad del software importante. tiene que ) definirse explícitamente que quiere decir “calidad del software”, ) crearse conjunto actividades que ayuden garantizar que todo producto ingeniería software tenga alta cali-dad, ) desarrollarse control calidad las actividades para asegurar ésta todo proyecto software, ) usar- métricas para desarrollar estrategias fin mejorar proceso del software , consecuencia, calidad del producto final. ¿quién hace? todos los involucrados proceso ingeniería software son los responsables calidad. ¿por qué importante? las cosas pueden hacerse bien pueden volverse hacer. equipo software pone énfasis calidad todas las actividades inge-niería software, reduce cantidad repeticiones que debe hacer. eso como resultado costos más bajos , que más importante, mejor tiempo para llegar mercado.¿cuáles son las etapas? antes iniciar las actividades aseguramiento calidad del software (acs), importante definir calidad del software varios niveles diferentes abstracción. una vez que entiende que calidad, equipo software debe identificar conjunto actividades acs que filtren los errores los productos del trabajo antes que aprueben. ¿cuál producto final? crea plan asegu- ramiento calidad del software para definir una estrategia acs del equipo. durante modelación codificación, producto principal del acs salida las revisiones técnicas (véase capítulo ). durante las pruebas (capítulos ), generan los planes pro-cedimientos prueba, así como otros productos del tra-bajo asociados con proceso mejora. ¿cómo aseguro que hice bien? hay que encontrar los errores antes que vuelvan defectos... decir, debe trabajarse para mejorar eficiencia eliminación defectos (capítulo ), fin reducir cantidad repeticiones que tenga que hacer equipo del software. una mirada rápida leído capítulo , debe leerlo ahora. enfoque ingeniería software descrito este libro dirige una sola meta: producir software tiempo alta calidad. pero muchos lectores preguntarán: “¿qué calidad del software?”. philip crosby [cro], libro clásico sobre calidad, una respuesta irónica esta pre- gunta: problema administración calidad que gente ignora ella. problema que piensan que saben… ese sentido, calidad tiene mucho común con sexo. todo mundo busca ( ciertas condiciones, por supuesto). todos creen que entienden (aunque querrían explicarlo). todos piensan que ejecución sólo consiste seguir las inclinaciones naturales (después todo, -cemos algún modo). , por supuesto, mayoría gente siente que los problemas esta área los causan las demás personas ( sólo dieran tiempo hacer las cosas bien). realidad, calidad concepto difícil ( abordó con cierto detalle capítulo ). algunos desarrolladores software todavía creen que calidad del software algo por que hay que empezar preocuparse una vez generado código. nada podría estar más lejos verdad... aseguramiento calidad del software (con frecuencia llamado administración (-).indd (-).indd // ::// :: aseguramiento calidad del software calidad) una actividad sombrilla (véase capítulo ) que aplica todo proceso del software. aseguramiento calidad del software (acs) incluye siguiente: ) proceso acs, ) tareas específicas aseguramiento control calidad (incluidas revisiones técnicas una estrategia pruebas relacionadas entre ), ) prácticas eficaces ingeniería software (métodos herramientas), ) control todos los productos del trabajo software los cambios que sufren (véase capítulo ), ) procedimiento para garantizar cumplimiento los estándares del desarrollo software (cuando sea aplicable) ) mecanismos medi-ción reporte. este capítulo centra aspectos administración las actividades específicas del proceso que permiten una organización software garantizar que hace “las cosas correctas momento correcto forma correcta”. . ntecedentes control aseguramiento calidad son actividades esenciales para cualquier negocio que genere productos que utilicen otras personas. antes del siglo , control calidad era res- ponsabilidad única del artesano que elaboraba producto. cuando pasó tiempo las técnicas producción masa hicieron comunes, control calidad convirtió una activi-dad ejecutada por personas diferentes aquellas que elaboraban producto. primera función formal aseguramiento control calidad introdujo los labo- ratorios bell difundió con rapidez resto del mundo manufactura. durante década , sugirieron enfoques más formales del control calidad. éstos basaban medición proceso mejora continua [dem] como elementos clave -ministración calidad. actualmente, toda compañía tiene mecanismos para asegurar calidad sus productos. realidad, las últimas décadas, las afirmaciones explícitas del compromiso una compa-ñía con calidad han vuelto mantra mercadotecnia. historia del aseguramiento calidad desarrollo del software corre manera paralela con historia calidad manufactura del hardware. los primeros días computación (décadas ), calidad era responsabilidad única del programador. los estándares para asegurar calidad del software introdujeron los contratos para -sarrollar software militar década extendieron con rapidez desarrollo software mundo comercial [iee]. amplía definición presentada principio, aseguramiento calidad del software “patrón planeado sistemático acciones” [sch] que requieren para garantizar alta calidad software. alcance respon-sabilidad del aseguramiento calidad caracteriza mejor parafrasea comercial automóvil popular: “ calidad empleo número .” implicación para software que muchas entidades diferentes tienen responsabilidad aseguramiento calidad del software: ingenieros software, gerentes proyecto, clientes, vendedores los individuos que trabajan grupo acs. grupo acs funciona como representante del cliente interior empresa. decir, gente que realiza acs debe ver software desde punto vista del cliente. ¿ software cumple adecuadamente los factores calidad mencionados capítulo ? ¿ desarrollo del software condujo acuerdo con estándares preestablecidos? ¿las discipli-nas técnicas han cumplido con sus roles como parte actividad acs? grupo acs trata responder éstas otras preguntas para garantizar que mantenga calidad del soft-ware.cita: “cometes demasiados errores equivocados.” yogi berra (-).indd (-).indd // ::// :: parte tres administración calidad . lementos aseguramiento calidad del software aseguramiento calidad del software incluye rango amplio preocupaciones acti- vidades que centran administración calidad del software. éstas resumen como sigue [hor]: estándares. ieee, iso otras organizaciones que establecen estándares han produ-cido una amplia variedad ellos para ingeniería software documentos relacionados. los estándares los adopta manera voluntaria una organización software los -pone cliente otros participantes. trabajo del acs asegurar que los estándares que hayan adoptado sigan, que todos los productos del trabajo apeguen ellos. revisiones auditorías. las revisiones técnicas son una actividad del control cali- dad que realizan ingenieros software para otros ingenieros software (véase capí- tulo ). objetivo detectar errores. las auditorías son tipo revisión efectuada por personal acs con objeto garantizar que sigan los lineamientos calidad trabajo ingeniería software. por ejemplo, una auditoría del proceso revisión efectúa para asegurar que las revisiones lleven cabo manera que tengan máxima probabilidad descubrir errores. pruebas. las pruebas del software (capítulos ) son una función del control cali- dad que tiene objetivo principal: detectar errores. trabajo del acs garantizar que las pruebas planeen forma apropiada que realicen con eficiencia, modo que probabilidad que logren objetivo principal sea máxima. colección análisis los errores. única manera mejorar medir cómo está haciendo algo. acs reúne analiza errores datos acerca los defectos para - tender mejor cómo cometen los errores qué actividades ingeniería software son más apropiadas para eliminarlos. administración del cambio. cambio uno los aspectos que más irrumpe cualquier proyecto software. administra forma adecuada, lleva confusión ésta casi siempre genera mala calidad. acs asegura que hayan instituido prácticas adecuadas administración del cambio (véase capítulo ). educación. toda organización software quiere mejorar sus prácticas ingeniería software. contribuyente clave mejora educación los ingenieros soft-ware, sus gerentes otros participantes. organización acs lleva liderazgo mejora del proceso software (capítulo ) clave para proponer patrocinar pro-gramas educativos. administración los proveedores. son tres las categorías software que adquie- ren proveedores externos: paquetes contenidos una caja (por ejemplo, office, micro- soft); shell personalizado [hor], que una estructura básica, tipo esqueleto, que adapta manera única las necesidades del comprador; software contratado, que -seña construye especialmente partir especificaciones provistas por organización cliente. trabajo organización acs garantizar que obtenga software alta calidad partir las sugerencias prácticas específicas calidad que proveedor debe seguir (cuando sea posible) incorporación cláusulas calidad como parte cualquier contrato con proveedor externo. administración seguridad. con aumento los delitos cibernéticos las nuevas regulaciones gubernamentales respecto privacidad, toda organización soft-ware debe instituir políticas para proteger los datos todos los niveles, establecer corta-fuegos protección para las webapps asegurar que software ser vulnerado -webref dirección com/newsletter/vol//vol.html, encuentra análisis profundo del acs, que incluye una amplia variedad definiciones. cita: “ excelencia capacidad ilimitada mejorar calidad que tenga para ofre-cer.” rick petin (-).indd (-).indd // ::// :: aseguramiento calidad del software ternamente. acs garantiza que para lograr seguridad del software, utilicen proceso tecnología apropiados. seguridad. debido que software casi siempre componente crucial los siste- mas humanos (como aplicaciones automotrices aeronáuticas), consecuencia defec- tos ocultos puede ser catastrófica. acs responsable evaluar efecto las fallas del software dar los pasos que requieren para disminuir riesgo. administración riesgos. aunque análisis mitigación riesgos (véase capí- tulo ) asunto los ingenieros software, organización del acs garantiza que las actividades administración riesgos efectúen forma apropiada que establez-can planes contingencia relacionados con los riesgos. además cada una estas preocupaciones actividades, acs tiene como preocupación dominante asegurar que las actividades apoyo del software (como mantenimiento, líneas ayuda, documentación manuales) lleven cabo produzcan con calidad. red mundial existen decenas recursos para administración calidad, incluidas sociedades profe- sionales, organizaciones emisoras estándares fuentes infor-mación general. los sitios siguientes constituyen buen punto partida: american society for quality (asq), división software, association for computer machinery, centro datos análisis del software (dacs), international organization for standardization (iso), iso spiece, baldridge national quality award, software engineering institute, testing and quality engineering, six sigma resources, tickit international, temas sobre certificación calidad, total quality management (tqm) información general: artículos: glosario: recursos para administración calidad . areas , metas métricas del acs aseguramiento calidad del software compone varias tareas asociadas con dos entidades diferentes: los ingenieros software que hacen trabajo técnico grupo acs que tiene responsabilidad planear, supervisar, registrar, analizar hacer reportes acerca calidad. los ingenieros software abordan calidad ( ejecutan actividades para controlarla), apli- cando métodos medidas técnicas sólidos, realizando revisiones técnicas haciendo pruebas software bien planeadas. .. tareas del acs objetivo del grupo acs auxiliar equipo del software para lograr producto final alta calidad. instituto ingeniería software recomienda conjunto acciones acs que dirigen planeación, supervisión, registro, análisis elaboración reportes para aseguramiento calidad. estas acciones son realizadas ( facilitadas) por grupo indepen-diente acs que hace siguiente: (-).indd (-).indd // ::// :: parte tres administración calidad prepara plan acs para proyecto. plan desarrolla como parte pre- paración del proyecto revisado por todos los participantes. las acciones asegura- miento calidad efectuadas por equipo ingeniería software por grupo acs son dirigidas por plan. éste identifica las evaluaciones que van realizar, las -ditorías revisiones por efectuar, los estándares aplicables proyecto, los procedimientos para reportar dar seguimiento los errores, los productos del trabajo que genera grupo acs retroalimentación que dará equipo del software. participa desarrollo descripción del software del proyecto. equipo software selecciona proceso para trabajo que realizar. grupo acs - visa descripción del proceso fin cumplir con política organizacional, los estánda-res internos para software, los estándares impuestos desde exterior (como norma iso-) otras partes del plan del proyecto software. revisa las actividades ingeniería software fin verificar cumpli- miento mediante proceso definido para software. grupo acs identifica, documenta seguimiento las desviaciones del proceso verifica que hayan hecho las correcciones pertinentes. audita los productos del trabajo software designados para verificar que cumpla con aquellos definidos como parte del proceso software. grupo acs revisa productos del trabajo seleccionados; identifica, documenta seguimiento las desviaciones; verifica que hayan hecho las correcciones necesarias reporta periódi-camente los resultados trabajo gerente del proyecto. asegura que las desviaciones trabajo software sus productos docu- menten manejen acuerdo con procedimiento documentado. las desvia- ciones pueden encontrarse plan del proyecto, descripción del proceso, los estánda-res aplicables los productos del trabajo ingeniería software. registra toda falta cumplimiento reporta alta dirección. segui- miento los incumplimientos hasta que son resueltos. además estas acciones, grupo acs coordina control administración del cambio (véase capítulo ) ayuda recabar analizar métricas para software. .. metas, atributos métricas las acciones acs descritas sección anterior realizan con objeto alcanzar con-junto metas pragmáticas: calidad los requerimientos. corrección, completitud consistencia del modelo requerimientos tendrá una gran influencia calidad todos los productos del tra-bajo que sigan. acs debe garantizar que equipo software revisado forma apropiada modelo requerimientos fin alcanzar alto nivel calidad. calidad del diseño. todo elemento del modelo del diseño debe ser evaluado por equipo del software para asegurar que tenga alta calidad que diseño apegue los requerimientos. acs busca atributos del diseño que sean indicadores calidad. calidad del código. código fuente los productos del trabajo relacionados (por ejem- plo, otra información descriptiva) deben apegarse los estándares locales codificación tener características que faciliten darle mantenimiento. acs debe identificar aquellos atributos que permitan hacer análisis razonable calidad del código. eficacia del control calidad. equipo software debe aplicar recursos limitados, forma tal que tenga máxima probabilidad lograr resultado alta calidad. ¿cuál rol grupo acs?? cita: “ calidad nunca acciden-; siempre resultado una intención clara, esfuerzo sincero, una dirección inteligen- una ejecución hábil; representa elección sabia muchas alternativas”. william . foster (-).indd (-).indd // ::// :: aseguramiento calidad del software acs analiza asignación recursos para las revisiones pruebas fin evaluar asignan forma más eficaz. figura . (adaptada [hya]) identifica los atributos que son indicadores exis- tencia calidad para cada una las metas mencionadas. también presentan las métricas que utilizan para indicar fortaleza relativa atributo. . nfoques formales acs las secciones anteriores, dijo que calidad del software trabajo cada quien que puede lograrse por medio una práctica competente ingeniería software, así como aplicación revisiones técnicas, una estrategia pruebas con relaciones múltiples, mejor control los productos del trabajo software los cambios efectuados sobre figura . meta atributo métrica calidad los ambigüedad número modificadores ambiguos (por ejemplo, muchos, grande, amigable, etc.) requerimientos completitud número tba tbd comprensibilidad número secciones subsecciones volatilidad número cambios por requerimiento tiempo (por actividad) cuando solicita cambio trazabilidad número requerimientos trazables hasta diseño código claridad del modelo número modelos uml número páginas descriptivas por modelo número errores uml calidad del diseño integridad arquitectónica existencia del modelo arquitectónico completitud componentes número componentes que siguen hasta modelo arquitectónico complejidad del diseño del procedimiento complejidad interfaz número promedio pasos para llegar una función contenido normal distribución apropiada patrones número patrones utilizados calidad del código complejidad complejidad ciclomática facilidad mantenimiento factores diseño (capítulo ) comprensibilidad porcentaje comentarios internos convenciones variables nomenclatura reusabilidad porcentaje componentes reutilizados documentación índice legibilidad eficacia del control asignación recursos porcentaje personal por hora por actividad calidad tasa finalización tiempo terminación real versus planeado eficacia revisión ver medición revisión (capítulo ) eficacia las pruebas número errores importancia crítica encontrados esfuerzo requerido para corregir error origen del errormetas atributos métricas calidad del software fuente: adaptado [hya]. (-).indd (-).indd // ::// :: parte tres administración calidad ellos, así como aplicación estándares aceptados ingeniería software. además, calidad define términos una amplia variedad atributos calidad mide (indirectamente) con empleo varios índices métricas. las últimas tres décadas, segmento pequeño pero sonoro comunidad inge- niería software afirmado que requiere enfoque más formal para acs. puede -cirse que programa cómputo objeto matemático. para cada lenguaje programa-ción, posible definir una sintaxis semántica rigurosas, dispone enfoque igualmente riguroso para especificación los requerimientos del software (véase capítulo ). modelo los requerimientos (especificación) lenguaje programación representan forma rigurosa, debe ser posible usar una demostración matemática para corrección, modo que confirme que programa ajusta exactamente sus especificaciones. los intentos demostrar corrección programa son nuevos. dijkstra [dij] linger, mills witt [lin], entre otros, han invocado pruebas corrección programas las han relacionado con uso conceptos programación estructurada (véase capí-tulo ). . seguramiento estadístico calidad del software aseguramiento estadístico calidad del software refleja una tendencia creciente industria para que vuelva más cuantitativo respecto calidad. para software, asegu-ramiento estadístico calidad implica los pasos siguientes: . recaba clasifica información acerca errores defectos del software. . hace intento por rastrear cada error defecto hasta sus primeras causas (por ejemplo, conformidad con las especificaciones, error diseño, violación los - tándares, mala comunicación con cliente , etc.). . con uso del principio pareto ( por ciento los defectos debe por ciento todas las causas posibles), identifica por ciento las causas errores -fectos (las pocas vitales). . una vez identificadas las pocas causas vitales, corrigen los problemas que han dado origen los errores defectos. este concepto relativamente simple representa paso importante hacia creación pro- ceso adaptativo del software que hacen cambios para mejorar aquellos elementos del proceso que introducen errores. .. ejemplo general fin ilustrar uso los métodos estadísticos para trabajo ingeniería software, suponga que una organización ingeniería software recaba información sobre los errores defectos cometidos periodo año. algunos dichos errores descubren medida que desarrolla software. otros (defectos) encuentran después haber liberado soft-ware sus usuarios finales. aunque descubren cientos problemas diferentes, todos pue-den rastrearse hasta una ( más) las causas siguientes: • especificaciones erróneas incompletas (eei) • mala interpretación comunicación con cliente (mcc) • desviación intencional las especificaciones (die) • violación los estándares programación (vep) • error representación los datos (erd)webref dirección edu/~rpollock/tqm.html, encuentra información útil acerca del acs los métodos formales calidad. ¿qué pasos requieren para efectuar acs estadístico?? cita: “ análisis estadístico, realiza forma apropiada, una disección delicada las incertidumbres, una cirugía las suposiciones.” . . moroney (-).indd (-).indd // ::// :: aseguramiento calidad del software • interfaz componente inconsistente (ici) • error diseño lógico (edl) • pruebas incompletas erróneas (pie) • documentación inexacta incompleta (dii) • error traducción del lenguaje programación del diseño (lpd) • interfaz humano/computadora ambigua inconsistente (ihc) • varios () para aplicar acs estadístico, elabora tabla figura .. tabla indica que eei, mcc erd son las pocas causas vitales que originan por ciento todos los errores. sin embargo, debe notarse que eei, erd, lpd edl habrían seleccionado como las pocas causas vitales consideran sólo errores serios. una vez que las pocas causas vitales han sido determinadas, organización ingeniería software comienza acción correctiva. por ejemplo, fin corregir mcc, deben implementarse técnicas para recabar requerimientos (capítulo ) que mejoren calidad comunicación las especificaciones con cliente. para mejorar erd, deben adquirirse herramientas para desarrollar modelación casos realizar datos revi-siones del diseño más significativos. importante notar que acción correctiva centra sobre todo las pocas causas vitales. tanto éstas corrigen, nuevas candidatas van cumbre pila. las técnicas para aseguramiento correctivo han sido propuestas para dar una mejora sus- tancial calidad [art]. ciertos casos, las organizaciones software han tenido una reducción anual por ciento defectos después aplicar esta técnica. aplicación del acs estadístico principio pareto resumen una sola oración: pasa tiempo viendo las cosas que realmente importan, pero primero asegúrate que entiendes que realmente importa... .. seis sigma para ingeniería software seis sigma estrategia más ampliamente usada hoy para aseguramiento estadístico calidad industria. estrategia seis sigma fue popularizada originalmente por motorola década “ una metodología rigurosa disciplinada que usa datos análisis esta-dísticos para medir mejorar desempeño operativo una compañía, identificando elimi-nando defectos procesos manufactura servicios” [isi]. término seis sigma deriva cita: “ por ciento del código tiene por cierto los errores. encuéntrelos, corríjalos”. lowell arthurtotal serio moderado menor error . % . % . % . % ies % % % % mcc % % % % ids % % % % vps % % % % edr % % % % ici % % % % edl % % % % iet % % % % iid % % % % plt % % % % hci % % % % mis % % % % totales % % % %figura . colección datos para hacer acs estadístico (-).indd (-).indd // ::// :: parte tres administración calidad seis desviaciones estándar —. casos (defectos) por millón ocurrencias—, que implica estándar calidad extremadamente alto. metodología seis sigma define tres etapas fundamentales: • definir los requerimientos del cliente los que entregan, así como las metas del proyecto través métodos bien definidos comunicación con cliente. • medir proceso existente resultado para determinar desempeño actual calidad (recabar métricas para los defectos). • analizar las métricas los defectos determinar las pocas causas vitales. trata proceso software existente que requiere mejorar, seis sigma sugiere dos etapas adicionales: • mejorar proceso, eliminando las causas originales los defectos. • controlar proceso para asegurar que trabajo futuro vuelva introducir las causas los defectos. estas etapas fundamentales adicionales ocasiones son conocidas como método dmamc (definir, medir, analizar, mejorar controlar). una organización desarrollar proceso software ( vez mejorar uno exis- tente), las etapas fundamentales agregan las siguientes: • diseñar proceso para ) evitar las causas originales los defectos ) cumplir los requerimientos del cliente. • verificar que modelo del proceso realidad evite los defectos cumpla los requeri-mientos del cliente. esta variación ocasiones denominada método dmadv (definir, medir, analizar, diseñar verificar). estudio detallado seis sigma deja fuentes dedicadas ese tema. lector tiene interés respecto, consulte [isi], [pyz] [sne]. . onfiabilidad del software hay duda que confiabilidad programa cómputo elemento importante calidad general. programa falla repetida frecuentemente desempeño, importa poco otros factores calidad del software son aceptables. confiabilidad del software, diferencia muchos otros factores calidad, mide estima directamente mediante uso datos históricos del desarrollo. confiabilidad del software define términos estadísticos como “ probabilidad que tiene programa cómputo operar sin fallas ambiente específico por tiempo específico” [mus]. para ilustrar anterior, digamos que estima que programa tiene una confiabilidad . durante ocho horas procesamiento continuo. otras palabras, programa fuera ejecutarse veces requiriera total ocho horas tiempo procesamiento continuo (tiempo procesamiento), probable que operara correctamente (sin fallas) veces. siempre que trate confiabilidad del software, surge una pregunta crucial: ¿qué signi- fica término falla? contexto cualquier análisis calidad confiabilidad del soft-ware, falla significa falta conformidad con los requerimientos del software. pero, incluso con esta definición, hay gradaciones. las fallas pueden ser leves catastróficas. una falla podría corregirse segundos, mientras que otra tal vez requiera varias semanas meses trabajo para ser corregida. para complicar más asunto, corrección una falla quizá como -sultado introducción otros errores que vez originen otras fallas.¿cuáles son las etapas fundamentales metodología seis sigma?? cita: “ precio inevitable con-fiabilidad simplicidad.” . . . hoare (-).indd (-).indd // ::// :: aseguramiento calidad del software .. mediciones confiabilidad disponibilidad los primeros trabajos sobre confiabilidad del software trataban extrapolar teoría matemá- tica confiabilidad del hardware predicción confiabilidad del software. mayor parte modelos relacionados con hardware abocan falla debida uso, lugar que tiene origen los defectos diseño. hardware, las fallas debidas uso físico (por ejemplo, los efectos temperatura, corrosión golpes) son más probables que las debidas diseño. desafortunadamente, con software ocurre contrario. realidad, todas las fallas del software pueden rastrearse problemas diseño implementación; uso (véase capítulo ) entra escenario. habido debate permanente acerca relación que existe entre los conceptos clave confiabilidad del hardware aplicabilidad software. aunque posible establecer vínculo irrefutable, útil considerar algunos conceptos sencillos que aplican ambos ele-mentos del sistema. considera sistema basado computadora, una medida sencilla confiabilidad tiempo medio entre fallas (tmef): tmef / tmpf / tmpr donde las siglas tmpf tmpr significan tiempo medio para falla tiempo medio para repa-ración, respectivamente. muchos investigadores afirman que tmef una medición más útil que otras relacionadas con calidad del software que estudian capítulo . pocas palabras, usuario final preocupan las fallas, cuenta total defectos. como cada defecto contenido programa tiene misma tasa fallas, cuenta total defectos indica muy poco acerca confiabilidad del sistema. por ejemplo, considere programa que haya estado opera-ción durante horas procesador sin falla. muchos defectos este programa estarían sin detectar durante decenas miles horas antes ser descubiertos. tmef tales errores oscuros podría ser hasta horas procesador. otros defectos, descubier-tos, podrían tener una tasa fallas horas. aun cada uno los errores esta categoría (los que tienen tmef largo) eliminara, efecto que tendrían sobre soft-ware sería despreciable. sin embargo, tmef puede ser problemático por dos razones: ) proyecta tiempo entre fallas, pero una tasa fallas proyectada ) puede interpretarse mal, como vida pro-medio, cuando esto que implica. una medición alternativa confiabilidad las fallas tiempo (fet): medición - tadística cuántas fallas tendrá componente mil millones horas operación. por tanto, fet equivalente una falla cada mil millones horas operación. además una medida confiabilidad, también debe desarrollarse otra para disponi- bilidad. disponibilidad del software probabilidad que programa opere acuerdo con los requerimientos momento determinado tiempo, define así: disponibilidad / tmpf tmpf / tmpr / % medición del tmef para confiabilidad igualmente sensible tmpf tmpr. medición disponibilidad poco más sensible tmpr, que una medición indirecta facilidad que tiene software para recibir mantenimiento.punto clave los problemas confiabilidad del software casi siempre pueden seguirse hasta encontrar defectos diseño implementación. punto clave importante observar que tiempo medio entre fallas otras medidas relacionadas basa tiempo del cpu, tiempo reloj. aunque tal vez requiera depurar ( hacer otras correcciones relacionadas) como consecuencia falla, muchos casos software funcionará manera apropiada después reiniciar, sin ningún otro cambio.algunos aspectos disponibilidad (que estudian aquí) tienen que ver con las fallas. por ejemplo, programación del tiempo fuera operación (para funciones apoyo) hace que software esté disponible.consejo (-).indd (-).indd // ::// :: parte tres administración calidad .. seguridad del software seguridad del software una actividad del aseguramiento del software que centra identificación evaluación los peligros potenciales que podrían afectarlo negativamente que podrían ocasionar que falle todo sistema. los peligros identifican principio del proceso del software, las características diseño especifican modo que los eliminen controlen. como parte seguridad del software, lleva cabo proceso modelado análisis. inicialmente identifican los peligros clasifican según riesgo. por ejemplo, algunos los peligros asociados con control crucero basado computadora para automóvil podrían ser los siguientes: ) ocasionar una aceleración incontrolada que pudiera detenerse, ) responder presión pedal frenado (porque apague), ) encender cuando active interruptor ) perder ganar velocidad poco poco. una vez identificados estos peligros nivel del sistema, utilizan técnicas análisis para asignar severidad proba-bilidad ocurrencia cada uno. para ser eficaz, software debe analizarse contexto todo sistema. por ejemplo, error sutil entrada usuario (las personas son com-ponentes del sistema) podría ampliarse por una falla del software producir datos control que situaran equivocadamente dispositivo mecánico. sólo encontrara único conjunto condiciones ambientales externas, posición falsa del dispositivo mecánico oca-sionaría una falla desastrosa. podrían usarse técnicas análisis [eri], tales como árbol fallas, lógica tiempo real modelos red petri, para predecir cadena eventos que ocasionarían los peligros, así como probabilidad ocurrir que tendría cada uno los even-tos para generar cadena. una vez identificados analizados los peligros, pueden especificarse requerimientos relacio- nados con seguridad para software. decir, especificación contendría una lista eventos indeseables las respuestas deseadas del sistema ante ellos. después indicaría papel del software administración indeseable los mismos. aunque confiabilidad seguridad del software están muy relacionadas, importante entender sutil diferencia entre ellas. primera utiliza técnicas análisis estadístico para determinar probabilidad que ocurra una falla del software. sin embargo, ocurrencia una falla necesariamente como resultado peligro riesgo. seguridad del software examina las formas las que las fallas generan condiciones que llevan peligro. decir, las fallas consideran vacío, sino que evalúan contexto totalidad del sistema basado computadora ambiente. estudio exhaustivo seguridad del software está más allá del alcance este libro. lector está interesado seguridad del software otros aspectos relacionados, consulte [smi], [dun] [lev]. . normas calidad iso sistema aseguramiento calidad define como estructura organizacional, respon- sabilidades, procedimientos, procesos recursos necesarios para implementar administra-ción calidad [ans]. los sistemas aseguramiento calidad crean para ayudar las organizaciones asegurar que sus productos servicios satisfagan las expectativas del con-cita: “ seguridad las personas debe ser ley máxima.” cicerón este enfoque similar los métodos análisis del riesgo descritos capítulo . diferencia principal énfasis que pone aspectos tecnología lugar los relacionados con proyecto. esta sección, escrita por michael stovski, sido adaptada partir “fundamentos iso ”, libro tra- bajo desarrollado para essential software engineering, video desarrollado por . . pressman & associates, inc. reimprime con autorización.cita: “ puedo imaginar ninguna condición que hiciera que esta nave hundiera. construc-ción naval moderna llegado más allá eso”. . . smith, capitán del itanic webref dirección eng.com/, encuentran varios artículos sobre seguridad del software. (-).indd (-).indd // ::// :: aseguramiento calidad del software sumidor gracias que cumplan con sus especificaciones. estos sistemas cubren una amplia variedad actividades, que contemplan todo ciclo vida del producto, incluidos planea-ción, control, medición, pruebas informes, así como mejora los niveles calidad todo proceso desarrollo manufactura. norma iso describe términos generales los elementos aseguramiento calidad que aplican cualquier negocio, sin importar los productos servicios ofrecidos. para registrarse alguno los modelos del sistema aseguramiento calidad conte- nidos iso , por medio auditores externos revisan detalle sistema las operaciones calidad una compañía, respecto del cumplimiento del estándar ope-ración eficaz. después registro exitoso, grupo registro representado por los auditores emite certificado para compañía. auditorías semestrales supervisión aseguran cum-plimiento continuo norma. los requerimientos esbozados por norma iso : dirigen temas tales como responsabilidad administración, sistema calidad, revisión del contrato, control del -seño, documentación control datos, identificación del producto seguimiento, control del proceso, inspección pruebas, acciones correctivas preventivas, registros del control calidad, auditorías internas calidad, capacitación, servicio técnicas estadísticas. fin que una organización software registre iso :, debe establecer políticas proce-dimientos que cumplan cada uno los requerimientos mencionados ( otros más), después demostrar que sigue dichas políticas procedimientos. lector desea más información sobre norma iso :, consulte [ant], [mut] [dob]. webref dirección /info.htm, encuentran muchos vínculos hacia los recursos norma iso /. descripción siguiente define los elementos básicos norma iso :. información completa sobre misma obtiene organización internacional normas ( otras fuentes internet (como establecer los elementos sistema administración cali- dad. desarrollar, implementar mejorar sistema. definir una política que ponga énfasis importancia del sis- tema. documentar sistema calidad. describir proceso. producir manual operación. desarrollar métodos para controlar (actualizar) documentos. establecer métodos registro.apoyar control aseguramiento calidad. promover importancia calidad entre todos los participantes. centrarse satisfacción del cliente. definir plan calidad que aboque los objetivos, responsa- bilidades autoridad. definir mecanismos comunicación entre los participantes.establecer mecanismos revisión para sistema administración calidad. identificar métodos revisión mecanismos retroalimentación. definir procedimientos para dar seguimiento.identificar recursos para calidad, incluidos personal, capacitación elementos infraestructura. establecer mecanismos control. para planeación para los requerimientos del cliente para las actividades técnicas (tales como análisis, diseño pruebas) para vigilancia administración del proyectodefinir métodos corrección. evaluar datos métricas calidad. definir enfoque para mejora continua del proceso cali- dad.información norma iso : . plan acs plan acs proporciona mapa ruta para instituir aseguramiento calidad del software. desarrollado por grupo acs ( por equipo del software existe grupo acs), plan funciona como plantilla para las actividades acs que instituyen para cada proyecto software. (-).indd (-).indd // ::// :: parte tres administración calidad ieee [ieee] publicado una norma para acs. ésta recomienda una estructura que identifica siguiente: ) propósito alcance del plan, ) descripción todos los productos del trabajo ingeniería software (tales como modelos, documentos, código fuente, etc.) que ubiquen dentro del ámbito del acs, ) todas las normas prácticas aplicables que utilicen durante proceso del software, ) acciones tareas del acs (incluidas revisiones auditorías) ubicación proceso del software, ) herramientas métodos que den apoyo las -ciones tareas acs, ) procedimientos para administración configuración del soft-ware (véase capítulo ), ) métodos para unificar las salvaguardas para mantener todos los registros relacionados con acs ) roles responsabilidades relacionados con calidad del producto. objetivos: objetivo las herramientas del acs ayudar equipo del proyecto evaluar mejorar cali- dad del producto del trabajo software. mecánica: mecánica las herramientas varía. general, objetivo consiste evaluar calidad producto específico. nota: frecuente que dentro categoría herramientas para acs, incluya una amplia variedad herramientas para someter prueba software (véanse los capítulos ). herramientas representativas arm, desarrollada por nasa (state.gsfc.nasa.gov/tools/ index.html), proporciona mediciones que utilizan para eva- luar calidad documento requerimientos software.qpr processguide and scorecard, desarrollada por qpr software ( apoyo para establecer seis sigma otros enfoques administración calidad. quality tools and templates, desarrollada por isixsigma (www. isixsigma.com//), describe amplio abanico herra-mientas métodos útiles para administración calidad. nasa quality resources, desarrollada por centro coddard vuelos espaciales (-assurance.gsfc.nasa.gov/index.php), contiene formatos, plantillas, listas verificación herra-mientas que son útiles para acs.herramientas software administración calidad del software . esumen aseguramiento calidad del software una actividad sombrilla ingeniería soft- ware que aplica cada etapa del proceso del software. acs incluye procedimientos para aplicación eficaz métodos herramientas, supervisa las actividades control calidad, tales como las revisiones técnicas las pruebas del software, procedimientos para adminis-tración del cambio, procedimientos para asegurar cumplimiento las normas mecanis-mos medición elaboración reportes. para llevar cabo aseguramiento calidad del software manera adecuada, deben recabarse, evaluarse divulgarse datos sobre proceso ingeniería software. los -todos estadísticos aplicados acs ayudan mejorar calidad del producto del proceso software mismo. los modelos confiabilidad del software amplían las mediciones, que permite que los datos obtenidos acerca los defectos extrapolen hacia tasas falla pro-yectadas hacia elaboración pronósticos confiabilidad. resumen, deben tomarse cuenta las palabras dunn ullman [dun]: “ asegura- miento calidad del software mapeo los preceptos administrativos las discipli-nas diseño del aseguramiento calidad, ámbito administrativo tecnológico apli-cable ingeniería software.” capacidad asegurar calidad medida una las herramientas mencionadas aquí son obligatorias, sino una muestra las que hay esta categoría. mayoría casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores. (-).indd (-).indd // ::// :: aseguramiento calidad del software disciplina madura ingeniería. cuando mapeo lleva cabo con éxito, resultado una ingeniería software madura. problemas puntos por evaluar .. algunas personas afirman que “ control variación corazón del control calidad”. como todo programa que crea diferente cualquier otro programa, ¿cuáles son las variaciones que bus-can cómo controlan? .. ¿ posible evaluar calidad del software cliente cambia continuamente que supone que debe hacerse? .. calidad confiabilidad son conceptos relacionados, pero difieren fundamental por varias razones. analice las diferencias. .. ¿ programa puede corregirse aún así ser confiable? explique respuesta... ¿ programa puede corregirse tener buena calidad? explique que responda... ¿por qué frecuente que haya tensiones entre grupo ingeniería software del asegura- miento calidad? ¿ saludable eso? .. lector tiene responsabilidad mejorar calidad del software organización. ¿qué primero que debe hacer? ¿qué siguiente? .. además contar los errores defectos, ¿hay otras características cuantificables software que impliquen calidad? ¿cuáles son cómo podrían medirse directamente? .. concepto del tiempo medio para falla del software objeto críticas. explique por qué... considere dos sistemas cuya seguridad sea crítica que estén controlados por computadora. enliste menos tres peligros que relacionen directamente con fallas del software. .. obtenga una copia las normas iso : iso -. prepare una presentación que analice tres requerimientos iso forma que apliquen contexto del software. lecturas fuentes información adicionales los libros hoyle (quality management fundamentals, butterworth-heinemann, ), tian (software qua-lity engineering, wiley-ieee computer society press, ), emam (the roi from software quality, auer-bach, ) horch (practical guide software quality management , artech house, ), nance arthur (managing software quality , springer, ) son presentaciones excelentes nivel administración acerca los beneficios los programas formales aseguramiento calidad del software compu-tadora. las obras deming [dem], juran ( juran quality design, free press, ) crosby ([cro], así como quality still free, mcgraw-hill, ) abocan software, pero son una lectura obligada para los altos directivos que tengan responsabilidades desarrollo del software. gluckman roome ( everyday heroes the quality movement, dorset house, ) humanizan los aspectos calidad través historia los actores participantes proceso. kan (metrics and models software quality engineering, addison-wesley, ) presenta enfoque cuantitativo calidad del software. los libros evans (total quality: management, organization and strategy, . ., south western college publishing, ), bru (six sigma for managers, mcgraw-hill, ) dobb (iso : quality registration step--step, . ., butterworth-heinemann, ) son representativos los muchos que han escrito sobre seis sigma iso :, respectivamente. pham ( system software reliability, springer, ), musa ( software reliability engineering: more reliable software, faster development and testing, . ., mcgraw-hill, ) peled ( software reliability methods, springer, ) proporcionan guías prácticas que describen los métodos para medir analizar confiabili-dad del software. vincoli (basic guide system safety, wiley ), dhillon (engineering safety, world scientific publishing ., inc., ), hermann (software safety and reliability, wiley-ieee computer society press, ), storey (safety-critical computer systems, addison-wesley, ) leveson [lev] aportan los análisis más exhaus-tivos que hayan publicado hasta fecha acerca seguridad del software del sistema. además, van (-).indd (-).indd // ::// :: parte tres administración calidad der meulen (definitions for hardware and software safety engineers, springer-verlag, ) ofrece compen- dio completo conceptos términos importantes para confiabilidad seguridad; gartner ( testing safety-related software, springer-verlag, ) ofrece una guía especializada para probar sistemas cuya -guridad sea crítica; friedman voas ( software assesment: reliability safety and testability , wiley, ) pro- veen modelos útiles para evaluar confiabilidad seguridad. ericson ( hazard analysis techniques for system safety, wiley, ) estudia dominio cada vez más importante del análisis los peligros. internet, hay una amplia variedad fuentes información sobre aseguramiento calidad del software otros temas relacionados. sitio web del libro, man/professional/olc/ser.htm, existe una lista actualizada referencias existentes red mundial que son relevantes para acs. (-).indd (-).indd // ::// :: prueba software conceptos clave depuración . . . . . . . . . . . . . grupo prueba independiente . . . . . . . . . prueba alfa. . . . . . . . . . . . . beta . . . . . . . . . . . . clase. . . . . . . . . . despliegue. . . . . . integración . . . . . regresión . . . . . . unidad . . . . . . . . validación . . . . . . del sistema . . . . . . . configuración . . . . . . . . . &. . . . . . . . . . . . . . . . . . ¿qué ? software prueba para descu- brir errores que cometieron manera inad- vertida conforme diseñó construyó. pero, ¿cómo realizan las pruebas? ¿debe realizar- plan formal para las mismas? ¿debe probarse programa completo, como todo, aplicar pruebas sólo sobre una pequeña parte ? ¿debe volverse aplicar las pruebas que realizaron mientras agregan nuevos componentes sistema grande? ¿cuándo debe involucrarse cliente? éstas muchas otras preguntas responden cuando desarrolla una estrategia prueba software. ¿quién hace? gerente proyecto, los ingenieros software los especialistas pruebas desarrollan una estrategia para probar software. ¿por qué importante? con frecuencia, prueba requiere más esfuerzo que cualquiera otra acción inge-niería del software. realiza sin orden, desperdicia tiempo, emplea esfuerzo innecesario , todavía peor, posible que algunos errores pasen desapercibidos. por tanto, parecería razonable establecer una estrategia siste-mática para probar software. ¿cuáles son los pasos? prueba comienza “por pequeño” avanza “hacia grande”. decir que las primeras etapas prueba enfocan sobre solo com-ponente pequeño grupo componentes relaciona-dos aplican pruebas para descubrir errores los datos lógica procesamiento que encapsularon los componentes. después probar éstos, deben inte-grarse hasta que construya sistema completo. este punto, ejecuta una serie pruebas orden superior para descubrir errores satisfacción los requeri-mientos del cliente. conforme descubren, los errores deben diagnosticarse corregirse usando proceso que llama depuración. ¿cuál producto final? una especificación pruebas documenta forma que equipo software pre-para prueba definir plan que describe una estra-tegia global procedimiento con pasos prueba específicos los tipos pruebas que realizarán. ¿cómo aseguro que hice bien? revisar especificación pruebas antes realizar las pruebas, posible valorar están completos los casos prueba las tareas misma. plan prueba procedimientos efectivos conducirán construcción ordenada del soft-ware descubrimiento errores cada etapa del proceso construcción. una mirada rápidauna estrategia prueba software proporciona una guía que describe los pasos que deben realizarse como parte prueba, cuándo planean llevan cabo dichos pasos, cuánto esfuerzo, tiempo recursos requerirán. por tanto, cualquier estrategia prueba debe incorporar planificación prueba, diseño casos prueba, ejecu-ción prueba recolección evaluación los resultados. una estrategia prueba software debe ser suficientemente flexible para promover uso personalizado prueba. mismo tiempo, debe ser suficientemente rígida para alentar planificación razonable seguimiento gestión conforme avanza proyecto. shooman [sho] analiza estos temas: muchas formas, prueba proceso individualización, número tipos diferentes pruebas varía tanto como los diferentes acercamientos para desarrollo. durante muchos años, única defensa contra los errores programación fue diseño cuidadoso inteligencia natural del programador. ahora estamos una era que modernas técnicas diseño ( revisiones técnicas) ayudan reducir número errores iniciales que son inherentes código. igual modo, diferen-tes métodos prueba comienzan agruparse métodos filosofías distintos. estos “enfoques filosofías” los que denomino estrategias son tema que presenta este capítulo. los capítulos , exponen los métodos técnicas prueba que permiten desarrollar estrategia. (-).indd (-).indd // ::// :: parte tres administración calidad . enfoque estratégico para prueba software prueba conjunto actividades que pueden planearse por adelantado realizarse manera sistemática. por esta razón, durante proceso software, debe definirse una plantilla para prueba del software: conjunto pasos que incluyen métodos prueba técnicas diseño casos prueba específicos. literatura sobre tema, han propuesto algunas estrategias prueba software. todas proporcionan una plantilla para prueba tienen las siguientes características genéri-cas: • para realizar una prueba efectiva, debe realizar revisiones técnicas efectivas (capítulo ). hacerlo, eliminará muchos errores antes comenzar prueba. • prueba comienza los componentes opera “hacia afuera”, hacia integración todo sistema cómputo. • diferentes técnicas prueba son adecuadas para distintos enfoques ingeniería software diferentes momentos tiempo. • las pruebas las realiza desarrollador del software (para proyectos grandes) grupo prueba independiente. • prueba depuración son actividades diferentes, pero depuración debe incluirse cualquier estrategia prueba. una estrategia para prueba software debe incluir pruebas bajo nivel, que son nece- sarias para verificar que pequeño segmento código fuente implementó correctamente, así como pruebas alto nivel, que validan las principales funciones del sistema partir los requerimientos del cliente. una estrategia debe proporcionar una guía para profesional conjunto guías para jefe proyecto. puesto que los pasos estrategia prueba ocu-rren cuando comienza aumentar presión por las fechas límite, avance debe ser medible los problemas deben salir superficie tan pronto como sea posible. .. verificación validación prueba software elemento tema más amplio que usualmente conoce como verificación validación (&). verificación refiere conjunto tareas que garantizan que software implementa correctamente una función específica. validación conjunto diferente tareas que aseguran que software que construye sigue los requerimientos del cliente. boehm [boe] afirma esto esta forma: verificación: “¿construimos producto correctamente?” validación: “¿construimos producto correcto?” definición & abarca muchas actividades aseguramiento calidad del software (capítulo ). verificación validación incluyen amplio arreglo actividades sqa: revisiones técnicas, auditorías calidad configuración, monitoreo rendimiento, simulación, estudio factibilidad, revisión documentación, revisión base datos, análisis algoritmos, pruebas desarrollo, pruebas usabilidad, pruebas calificación, pruebas aceptación webref pueden encontrarse útiles recursos para prueba software. debe notarse que hay una fuerte divergencia opinión acerca qué tipos pruebas constituyen “valida- ción”. algunas personas creen que todas las pruebas sirven para verificación que validación lleva cabo cuando los requerimientos revisan aprueban, , más tarde, por usuario, cuando sistema resulta opera-tivo. otras personas ven las pruebas unidad integración (secciones .. ..) como verificación las orden superior (secciones . .) como validación.cita: “probar parte inevitable cualquier esfuerzo responsable por desarrollar sistema software”. william howden (-).indd (-).indd // ::// :: estrategias prueba software pruebas instalación. aunque las pruebas juegan papel extremadamente importante &, también son necesarias muchas otras actividades. las pruebas representan último bastión desde donde puede valorarse calidad , - nera más pragmática, descubrirse errores. pero las pruebas deben verse como una red seguridad. como dice: “ puede probar calidad. está ahí antes comenzar las pruebas, estará cuando termine probar”. calidad incorpora software largo todo proceso ingeniería del software. adecuada aplicación métodos herramien-tas, revisiones técnicas efectivas, gestión medición sólidas conducen calidad que confirma durante las pruebas. miller [mil] relaciona prueba del software con aseguramiento calidad afirmar que “ motivación subyacente las pruebas los programas afirmar claridad del soft-ware con métodos que puedan aplicarse manera económica efectiva sistemas gran pequeña escala”. .. organización las pruebas del software todo proyecto software hay conflicto inherente intereses que ocurre conforme -mienzan las pruebas. hoy día, las personas que construyen software les pide probarlo. , esto parece sencillo; después todo, ¿quién conoce mejor programa que sus desarro-lladores? por desgracia, estos mismos desarrolladores tienen mucho interés demostrar que programa está libre errores, que funciona acuerdo con los requerimientos del cliente que completará tiempo dentro del presupuesto. cada uno estos intereses tienen efecto negativo sobre las pruebas más cuidadosas. desde punto vista psicológico, análisis diseño software (junto con codifica- ción) son tareas constructivas. ingeniero software analiza, modela luego crea pro-grama computadora documentación. como cualquier constructor, ingeniero soft-ware está orgulloso del edificio que construyó con desconfianza quien intente derrumbarlo. cuando comienzan las pruebas, hay sutil, pero definitivo, intento por “romper” que cons-truyó ingeniero software. desde punto vista del constructor, las pruebas pueden considerarse como (psicológicamente) destructivas. modo que constructor actuará con cuidado, diseñará ejecutará pruebas que demostrarán que programa funciona, lugar descubrir errores. desafortunadamente, los errores estarán presentes. ingeniero soft-ware los encuentra, ¡ cliente hará! con frecuencia, existen algunas malas interpretaciones que pueden inferirse manera erró- nea partir discusión anterior: ) que desarrollador software debe hacer pruebas absoluto, ) que software debe “ponerse tras una pared” que separe los extraños que probarán sin misericordia, ) que quienes realicen las pruebas deben involucrarse con proyecto sólo cuando los pasos las pruebas estén por comenzar. cada uno estos enuncia-dos incorrecto. desarrollador software siempre responsable probar las unidades individuales (componentes) del programa asegurarse que cada una desempeña función muestra comportamiento para cual diseñó. muchos casos, desarrollador también realiza pruebas integración, una etapa las pruebas que conduce construcción ( prueba) arquitectura completa del software. sólo después que arquitectura software está completa involucra grupo prueba independiente (gpi). papel grupo prueba independiente (gpi) remover los problemas inherentes que están asociados con dejar constructor probar que construyó. las pruebas independientes remueven conflicto intereses que otro modo puede estar presente. después todo, personal del gpi paga por encontrar errores. sin embargo, desarrollador software gpi retira. gpi trabajan - nera cercana largo del proyecto software para garantizar que realizarán pruebas - error pensar que las pruebas son una “red seguridad” que atrapará todos los errores que ocurran como producto deficientes prácticas ingeniería software. hará. enfatice calidad detección errores largo del proceso software.consejo cita: “ optimismo riesgo ocu-pacional programación; prueba tratamiento”. kent beck punto clave grupo prueba independiente tiene “conflicto intereses” que pueden experimentar los constructores del software. (-).indd (-).indd // ::// :: parte tres administración calidad haustivas. mientras realizan éstas, desarrollador debe estar disponible para corregir los errores que descubran. gpi parte del equipo proyecto desarrollo del software pues involucra durante análisis diseño, sigue involucrado (mediante planificación especificación procedimien-tos prueba) largo proyecto grande. obstante, muchos casos, gpi reporta organización aseguramiento calidad del software, por tanto logra grado inde-pendencia que puede existir fuese parte organización ingeniería del software. .. estrategia prueba del software. visión general proceso software puede verse como espiral que ilustra figura .. inicialmente, ingeniería sistemas define papel del software conduce análisis los requerimientos del mismo, donde establecen los criterios dominio, función, comportamiento, desempeño, restricciones validación información para software. avanzar hacia adentro largo espiral, llega diseño finalmente codificación. para desarrollar software computadoras, avanza espiral hacia adentro (contra las manecillas del reloj) largo una línea que reduce nivel abstracción cada vuelta. una estrategia para probar software también puede verse contexto espiral (- gura .). prueba unidad comienza vértice espiral concentra cada unidad (por ejemplo, componente, clase objeto contenido una webapp) del software como implementó código fuente. prueba avanza moverse hacia afuera largo espiral, hacia prueba integración , donde enfoque centra diseño cons- trucción arquitectura del software. dar otra vuelta hacia afuera espiral, encuen-tra prueba validación, donde los requerimientos establecidos como parte modelado validan confrontándose con software que construyó. finalmente, llega prueba del sistema, donde software otros elementos del sistema prueban como todo. para probar software cómputo, avanza espiral hacia afuera dirección las manecillas del reloj largo líneas que ensanchan alcance las pruebas con cada vuelta. considerar proceso desde punto vista procedural, las pruebas dentro del contexto ingeniería del software realidad son una serie cuatro pasos que implementan manera secuencial. éstos muestran figura .. inicialmente, las pruebas enfocan cada componente manera individual, que garantiza que funcionan adecuadamente como unidad. ahí nombre prueba unidad . esta prueba utiliza mucho las técnicas prueba que ejercitan rutas específicas una estructura control componentes para ase-gurar una cobertura completa máxima detección errores. continuación, los componen-tes deben ensamblarse integrarse para formar paquete software completo. prueba integración aborda los conflictos asociados con los problemas duales verificación construc-ción programas. durante integración, usan más las técnicas diseño casos cita: “ primer error que comete gente creer que equipo prueba responsable ase-gurar calidad.” brian marick prueba del sistema prueba validación prueba integración prueba unidad código diseño requerimientos ingeniería del sistemafigura . estrategia pruebas¿cuál estrategia global para prueba del software?? webref quienes prueban software pueden encontrar recursos útiles (-).indd (-).indd // ::// :: estrategias prueba software prueba que enfocan entradas salidas, aunque también pueden usarse técnicas que ejer- citan rutas programa específicas para asegurar cobertura las principales rutas con-trol. después integrar (construir) software, realiza una serie pruebas orden supe-rior. deben evaluarse criterios validación (establecidos durante análisis requerimientos). prueba validación proporciona garantía final que software cumple con todos los requerimientos informativos, funcionales, comportamiento rendimiento. último paso prueba orden superior cae fuera las fronteras ingeniería software contexto más amplio ingeniería sistemas cómputo. software, una vez validado, debe combinarse con otros elementos del sistema (por ejemplo, hardware, perso-nal, bases datos). prueba del sistema verifica que todos los elementos mezclan - nera adecuada que logra funcionamiento/rendimiento global del sistema.prueba unidadcódigodiseñorequerimientos “dirección” pruebaprueba integraciónpruebas orden superiorfigura . pasos prueba del software escena: oficina doug miller, mientras con- tinúa diseño nivel componentes comienza construcción algunos ellos. participantes: doug miller, jefe ingeniería software; vinod, jamie, shakira, miembros del equipo ingeniería software casasegura. conversación: doug: parece que hemos dedicado suficiente tiempo para hablar las pruebas. vinod: cierto, pero todos hemos estado poco ocupados. ade- más hemos pensado ello... realidad, hemos hecho más que pensar. doug (sonríe): ... tenemos exceso trabajo, pero todavía debemos pensar las cosas importantes. shakira: gusta idea diseñar pruebas unidad antes comenzar codificar cualquiera mis componentes, así que eso que intentado hacer. tengo archivo pruebas bastante grande para aplicar cuando codifique mis componentes por com-pleto.doug: ése concepto programación extrema [proceso desarrollo software ágil, véase capítulo ], ¿ ? : . aun cuando usamos programación extrema per , decidimos que sería buena idea diseñar pruebas unidad antes construir componente; diseño nos dará información que nece-sitamos. jamie: hecho mismo.vinod: tomé papel integrador, así que cada vez que uno los muchachos pase componente, integraré correré una serie pruebas regresión sobre programa parcialmente integrado. trabajado para diseñar conjunto pruebas ade-cuadas para cada función sistema. doug ( vinod): ¿con qué frecuencia corres las pruebas?vinod: todos los días... hasta que sistema esté integrado... bueno, quiero decir hasta que esté integrado incremento soft-ware que planeamos entregar. doug: ¡muchachos, van adelante !vinod (ríe): anticipación todo negocio del software, jefe.casasegura preparación para prueba (-).indd (-).indd // ::// :: parte tres administración calidad .. criterios para completar las pruebas cada vez que analiza prueba del software, surge una pregunta clásica: “¿cuándo terminan las pruebas?, ¿cómo sabe que probado suficiente?”. lamentablemente, hay una respuesta definitiva esta pregunta, pero existen algunas respuestas pragmáticas intentos tempranos manera guía empírica. una respuesta pregunta : “nunca termina probar; carga simplemente pasa usted ( ingeniero software) usuario final”. cada vez que usuario ejecuta programa cómputo, programa pone prueba. este instructivo hecho subraya importancia otras actividades fin garantizar calidad del software. otra respuesta ( tanto cínica, mas obstante precisa) : “las pruebas terminan cuando agota tiempo dinero”. aunque algunos profesionales usarían estas respuestas, necesitan criterios más rigurosos para determinar cuándo han realizado suficientes pruebas. enfoque ingeniería soft-ware salas limpias (capítulo ) sugiere uso técnicas estadísticas [kel] que ejecutan una serie pruebas derivadas una muestra estadística todas las posibles ejecuciones programa por parte todos los usuarios una población objetivo. otros (por ejemplo, [sin]) abogan por uso del modelado estadístico teoría confiabilidad del software para prede-cir cuándo están completas las pruebas. coleccionar estadísticas durante las pruebas del software usar los modelos existentes confiabilidad del mismo, posible desarrollar lineamientos significativos para responder pregunta: “¿cuándo terminan las pruebas?”. hay poco debate acerca que todavía queda -cho trabajo por hacer antes poder establecer reglas cuantitativas para las pruebas, pero los acercamientos empíricos que existen actualidad son considerablemente mejores que intuición pura. . spectos estratégicos más adelante este capítulo, presenta una estrategia sistemática para probar software. pero incluso mejor estrategia fracasará aborda una serie aspectos decisivos. tom gilb [gil] arguye que una estrategia software triunfará cuando quienes prueban software: especifican los requerimientos del producto forma cuantificable mucho antes comenzar con las pruebas. aunque objetivo predominante una prueba encontrar errores, una buena estrategia prueba también valora otras características calidad, como portabi-lidad, mantenimiento facilidad uso (capítulo ). esto debe especificarse una forma medible, modo que los resultados las pruebas sean ambiguos. establecen manera explícita los objetivos las pruebas. los objetivos específicos las pruebas deben enunciarse términos medibles. por ejemplo, efectividad las pruebas, cobertura, tiempo medio antes aparecer una falla, costo por descubrir corregir defec-tos, densidad defectos restantes frecuencia ocurrencia, las horas trabajo prueba deben enunciarse dentro del plan prueba. entienden los usuarios del software desarrollan perfil para cada categoría usuario . los casos uso que describen escenario interacción para cada clase usuario pueden reducir esfuerzo prueba global enfocar las pruebas uso real del producto. desarrollan plan prueba que enfatice “pruebas ciclo rápido” . gilb [gil] recomienda que equipo software “aprenda probar ciclos rápidos ( por ciento del esfuerzo del proyecto) cliente-utilidad menos ‘comprobabilidad’ campo, los incrementos fun-cionalidad / mejora calidad”. retroalimentación generada partir estas prue-bas ciclo rápido puede usarse para controlar niveles calidad las correspondientes -trategias prueba.¿cuándo terminan las pruebas?? webref glosario amplio términos pruebas puede encontrarse sitio ¿qué lineamientos conducen una exitosa estrategia prueba del software?? webref una excelente lista recursos prueba puede encontrarse sitio (-).indd (-).indd // ::// :: estrategias prueba software construyen software “robusto” que esté diseñado para probarse mismo. software debe diseñarse forma que use técnicas antierrores (sección ..), decir, software debe poder diagnosticar ciertas clases errores. además, diseño debe incluir pruebas automati-zadas pruebas regresión. usan revisiones técnicas efectivas como filtro previo las pruebas. las revisiones técnicas (- pítulo ) pueden ser tan efectivas como probar para descubrir errores. por esta razón, las -visiones pueden reducir cantidad del esfuerzo pruebas que requieren para producir software alta calidad. realizan revisiones técnicas para valorar estrategia prueba los casos prueba. las - visiones prueba pueden descubrir inconsistencias, omisiones errores evidentes abordaje las pruebas. esto ahorra tiempo también mejora calidad del producto. desarrollan enfoque mejora continuo para proceso prueba. estrategia prue- bas debe medirse. las métricas recopiladas durante las pruebas deben usarse como parte enfoque control proceso estadístico para prueba del software. . strategias prueba para software convencional existen muchas estrategias que pueden usarse para probar software. extremo, puede esperarse hasta que sistema esté completamente construido luego realizar las pruebas sobre sistema total, con esperanza encontrar errores. este enfoque, aunque atractivo, simple-mente funciona. dará como resultado software defectuoso que desilusionará todos los par-ticipantes. otro extremo, podrían realizarse pruebas diariamente, siempre que construya alguna parte del sistema. este enfoque, aunque menos atractivo para muchos, puede ser muy efectivo. por desgracia, algunos desarrolladores software son reacios usarlo. ¿qué hacer? una estrategia prueba que eligen mayoría los equipos software coloca entre los dos extremos. toma una visión incremental las pruebas, comenzando con unidades programa individuales, avanza hacia pruebas diseñadas para facilitar integración las unidades culmina con pruebas que ejercitan sistema construido. cada una estas clases pruebas describe las secciones que siguen. .. prueba unidad prueba unidad enfoca los esfuerzos verificación unidad más pequeña del diseño software: componente módulo software. usar descripción del diseño compo-nente como guía, las rutas control importantes prueban para descubrir errores dentro frontera del módulo. relativa complejidad las pruebas los errores que descubren están limitados por ámbito restringido que establece para prueba unidad. las pruebas unidad enfocan lógica procesamiento interno las estructuras datos dentro las fronteras componente. este tipo pruebas puede realizarse paralelo para múl-tiples componentes. consideraciones las pruebas unidad. las pruebas unidad ilustran manera esquemática figura .. interfaz del módulo prueba para garantizar que informa- ción fluya manera adecuada hacia desde unidad software que está probando. las estructuras datos locales examinan para asegurar que los datos almacenados temporal-cita: “probar sólo los requerimien- tos del usuario final como inspeccionar edificio con base trabajo realizado por decorador interiores costa cimientos, vigas plomería.” boris beizer largo este libro, usan los términos software convencional software tradicional para referirse arqui- tecturas software jerárquica común, “llamar regresar”, que con frecuencia encuentran una varie- dad dominios aplicación. las arquitecturas software tradicional son orientadas objetos abarcan webapps. mala idea diseñar casos prueba unidad antes desarrollar código para componente. eso ayuda garantizar que desarrollará código que pasará las pruebas.consejo (-).indd (-).indd // ::// :: parte tres administración calidad mente mantienen integridad durante todos los pasos ejecución algoritmo. todas las rutas independientes través estructura control ejercitan para asegurar que todos los estatutos módulo ejecuten menos una vez. las condiciones frontera prue-ban para asegurar que módulo opera adecuadamente las fronteras establecidas para limi-tar restringir procesamiento. , finalmente, ponen prueba todas las rutas para manejo errores. flujo datos través interfaz componente prueba antes iniciar cual- quiera otra prueba. los datos entran salen manera adecuada, todas las demás pruebas son irrelevantes. además, deben ejercitarse las estructuras datos locales averiguarse ( posible) impacto local sobre los datos globales durante las pruebas unidad. prueba selectiva las rutas ejecución una tarea esencial durante prueba uni- dad. los casos prueba deben diseñarse para descubrir errores debidos cálculos erróneos, comparaciones incorrectas flujo control inadecuado. las pruebas frontera son una las tareas prueba unidad más importantes. con frecuencia, software falla sus fronteras. decir: con frecuencia los errores ocurren cuando procesa enésimo elemento arreglo ene-dimensional, cuando invoca enésima repetición bucle con pasadas, cuando encuentra valor máximo mínimo permisi- ble. muy probable que los casos prueba que ejercitan estructura datos, flujo control los valores datos justo abajo arriba máximos mínimos descubran errores. buen diseño anticipa las condiciones error establece rutas manejo errores para enrutar terminar limpiamente procesamiento cuando ocurre error. yourdon [you] llama este enfoque antierrores. desafortunadamente, hay una tendencia incorporar -nejo errores software luego nunca probarlo. una historia verídica puede servir como ilustración: sistema diseño asistido por computadora desarrolló bajo contrato. módulo proce- samiento transacción, bromista colocó siguiente mensaje manejo error después una serie pruebas condicionales que invocaban varias ramas flujo control: ¡error! hay forma que pueda llegar aquí. ¡este “mensaje error” descubrió cliente durante entrenamiento para usuarios! entre los potenciales errores que deben ponerse prueba cuando evalúa manejo erro- res están: ) descripción error ininteligible, ) error indicado corresponde con error que encuentra, ) condición del error causa intervención del sistema antes manejar casos pruebamódulo interfaz estructuras datos localescondiciones fronterarutas independientesrutas manejo errorfigura . prueba unidad ¿qué errores encuentran comúnmente durante las pruebas unidad?? webref puede encontrar información útil acerca una gran variedad artículos recursos para “prueba ágil” testing.com/agile (-).indd (-).indd // ::// :: estrategias prueba software error, ) procesamiento excepción-condición incorrecto ) descripción del error pro- porciona suficiente información para auxiliar localización causa del error. procedimientos prueba unidad. las pruebas unidad por general consideran como adjuntas paso codificación. diseño las pruebas unidad puede ocurrir antes comenzar codificación después generar código fuente. revisión informa-ción del diseño proporciona una guía para establecer casos prueba que probable que descubran errores cada una las categorías analizadas anteriormente. cada caso prue- debe acoplarse con conjunto resultados esperados. puesto que componente programa independiente, con frecuencia debe desarro- llarse software controlador / resguardo para cada prueba unidad. figura . ilustran los entornos prueba unidad. mayoría las aplicaciones, controlador más que “programa principal” que acepta datos caso prueba, pasa tales datos componente (que ponerse prueba) imprime resultados relevantes. los representantes ( inglés stubs) sirven para sustituir módulos que están subordinados (invocados por ) componente que probar. representante “subprograma tonto” usa interfaz módulo subordinado, puede realizar mínima manipulación datos, imprimir verificación entradas regresar control módulo sobre que realiza prueba. los controladores representantes añaden una “sobrecarga” las pruebas. decir: ambos son software que debe escribirse ( diseño formal usualmente aplica), pero que entrega con producto software final. los controladores representantes mantienen simples, sobrecarga real relativamente baja. por desgracia, muchos componentes pue-den tener prueba unidad adecuada con software sobrecarga simple. tales casos, prueba completa puede posponerse hasta paso prueba integración (donde también usan controladores representantes). las pruebas unidad simplifican cuando diseña componente con alta cohesión. cuando componente aborda una sola función, número casos prueba reduce los errores pueden predecirse descubrirse con mayor facilidad. .. pruebas integración neófito mundo del software podrá plantear una pregunta aparentemente legítima una vez que todos los módulos hayan probado manera individual: “ todos ellos funcionan casos pruebainterfaz estructuras datos localescondiciones fronterarutas independientesrutas manejo error módulo que probar represen- tanterepresen- tantecontrolador resultadosfigura . entorno prueba unidad asegúrese diseñar pruebas para ejecutar cada ruta manejo error. hace, ruta puede fallar cuando invoque, que agrava una situación por peligrosa.consejo existen algunas situaciones donde tienen los recursos para realizar una prueba unidad amplia. seleccione los módulos cruciales complejos aplique sólo ellos las pruebas unidad.consejo (-).indd (-).indd // ::// :: parte tres administración calidad individualmente, ¿por qué dudan que funcionarán cuando junten todos?”. desde luego, problema “juntarlos todos”: conectarlos. los datos pueden perderse través una interfaz; componente puede tener inadvertido efecto adverso sobre otro; las subfunciones, cuando combinan, pueden producir función principal deseada; imprecisión aceptable indivi-dualmente puede magnificarse niveles inaceptables; las estructuras datos globales pueden presentar problemas. lamentablemente, lista sigue sigue. las pruebas integración son una técnica sistemática para construir arquitectura del software mientras llevan cabo pruebas para descubrir errores asociados con interfaz. objetivo tomar los componentes probados manera individual construir una estructura programa que haya dictado por diseño. con frecuencia existe una tendencia intentar integración incremental, decir, construir programa usando enfoque big bang. todos los componentes combinan por adelantado. todo programa prueba como todo. ¡ usualmente resulta caos! des-cubre conjunto errores. corrección dificulta pues aislamiento las causas complica por vasta extensión todo programa. una vez corregidos estos errores, otros nuevos aparecen proceso continúa bucle aparentemente interminable. integración incremental antítesis del enfoque big bang. programa construye prueba pequeños incrementos, donde los errores son más fáciles aislar corregir; las -terfaces tienen más posibilidades probarse por completo; puede aplicarse enfoque prueba sistemático. los siguientes párrafos exponen algunas estrategias diferentes -tegración incremental. integración descendente. prueba integr ación descendente enfoque incremental construcción arquitectura software. los módulos integran moverse hacia abajo través jerarquía control, comenzando con módulo control principal (pro-grama principal). los módulos subordinados módulo control principal incorporan estructura una forma primero profundidad primero anchura. con referencia figura ., integración primero profundidad integra todos los com- ponentes sobre una ruta control mayor estructura del programa. selección una ruta mayor tanto arbitraria depende las características específicas aplicación. por ejemplo, seleccionar ruta izquierda, los componentes , , integrarían primero. continuación, ( necesario para adecuado funcionamiento ) inte-tomar enfoque "big bang" para integración una estrategia perezosa condenada fracaso. integre manera incremental pruebe conforme avance.consejo cuando desarrolle calendario proyecto, considere forma que ocurrirá integración, modo que los componentes estén disponibles cuando les necesite.consejo . integración descendente (-).indd (-).indd // ::// :: estrategias prueba software graría . luego construyen las rutas control central derecha. integración primero anchura incorpora todos los componentes directamente subordinados cada nivel, mueve horizontalmente través estructura. figura, los componentes , integra- rían primero. sigue siguiente nivel control, , , etc. proceso integración realiza una serie cinco pasos: . módulo control principal usa como controlador prueba los representan- tes (stubs) sustituyen con todos los componentes directamente subordinados -dulo control principal. . dependiendo del enfoque integración seleccionado ( decir, primero profundidad anchura), los representantes subordinados sustituyen uno vez con componen- tes reales. . las pruebas llevan cabo conforme integra cada componente. . completar cada conjunto pruebas, otro representante sustituye con compo- nente real. . las pruebas regresión (que analizan más adelante esta sección) pueden reali- zarse para asegurar que introdujeron nuevos errores. proceso continúa desde paso hasta que construye todo estructura del pro- grama. estrategia integración descendente verifica los principales puntos control deci- sión principio proceso prueba. una estructura programa “bien factorizada”, toma decisiones ocurre niveles superiores jerarquía , por tanto, encuentra pri- mero. existen grandes problemas control, reconocimiento temprano esencial. selecciona integración primero profundidad, posible implementar demostrar fun-cionamiento completo del software. demostración temprana capacidad funcional constructor confianza para todos los participantes. pareciera que estrategia descendente tiene complicaciones, pero, práctica, pueden surgir problemas logísticos. más común éstos ocurre cuando requiere procesamiento niveles bajos jerarquía fin probar manera adecuada los niveles superiores. los representantes (stubs) sustituyen los módulos bajo nivel comienzo prueba descen-dente; por tanto, ningún dato significativo puede fluir hacia arriba estructura del programa. persona que realiza prueba quedan tres opciones: ) demorar muchas pruebas hasta que los representantes sustituyan con módulos reales, ) desarrollar resguardos que realicen funciones limitadas que simulen módulo real ) integrar software desde fondo jerarquía hacia arriba. primer enfoque (demorar las pruebas hasta que los representantes sustituyan con - dulos reales) puede hacerle perder algo control sobre correspondencia entre pruebas -pecíficas incorporación módulos específicos. esto puede conducir dificultades para determinar causa los errores tiende violar naturaleza enormemente restrictiva del enfoque descendente. segundo enfoque vale pena, pero puede conducir una sobrecarga significativa conforme los representantes vuelven cada vez más complejos. tercero, lla-mado integración ascendente, analiza los siguientes párrafos. integración ascendente. prueba integr ación ascendente, como nombre implica, - mienza construcción prueba con módulos atómicos ( decir, componentes los niveles inferiores dentro estructura del programa). puesto que los componentes integran abajo hacia arriba, funcionalidad que proporcionan los componentes subordinados deter-minado nivel siempre está disponible elimina necesidad representantes (stubs). una estrategia integración ascendente puede implementarse con los siguientes pasos:¿cuáles son los pasos para integración descendente?? ¿qué problemas pueden encontrarse cuando elige integración descendente?? (-).indd (-).indd // ::// :: parte tres administración calidad . los componentes nivel inferior combinan grupos ( ocasiones llamados construcciones builds) que realizan una subfunción software específica. . escribe controlador ( programa control para pruebas) fin coordinar entrada salida casos prueba. . prueba grupo. . los controladores remueven los grupos combinan moviéndolos hacia arriba estructura del programa. integración sigue patrón que ilustra figura .. los componentes combinan para formar los grupos , . cada uno ellos prueba usando controlador (que muestra como bloque rayado). los componentes los grupos subordinan . los controladores remueven los grupos ponen interfaz directamente con . igual modo, controlador para grupo remueve antes integración con módulo . tanto como final integrarán con componente , así sucesivamente. conforme integración avanza hacia arriba, reduce necesidad controladores prueba separados. hecho, los dos niveles superiores del programa integran manera descendente, número controladores puede reducirse manera sustancial integra-ción grupos simplifica enormemente. prueba regresión. cada vez que agrega nuevo módulo como parte las pruebas integración, software cambia. establecen nuevas rutas flujo datos, ocurren nuevas operaciones entrada/salida voca nueva lógica control. dichos cambios pueden causar problemas con las funciones que anteriormente trabajaban sin fallas. contexto una estrategia prueba integración, prueba regresión nueva ejecución algún subconjunto pruebas que realizaron fin asegurar que los cambios propagaron efectos colaterales deseados. contexto más amplio, las pruebas exitosas ( cualquier tipo) dan como resultado descubrimiento errores, los errores deben corregirse. siempre que corrige software, cambia algún aspecto configuración del software ( programa, documentación los datos que sustenta). las pruebas regresión ayudan garantizar que los cambios (debidos ¿cuáles son los pasos para integración ascendente?? punto clave integración ascendente elimina necesidad representantes (stubs) complejos. grupo grupo . integración ascendentela prueba regresión una importante estrategia para reducir “efectos colaterales”. corra pruebas regresión cada vez que realiza cambio importante software (incluida integración nuevos componentes).consejo (-).indd (-).indd // ::// :: estrategias prueba software pruebas por otras razones) introducen comportamiento planeado errores adicio- nales. las pruebas regresión pueden realizar manualmente, volver ejecutar subcon- junto todos los casos prueba usando herramientas captura/reproducción automati-zadas. las herramientas captura/reproducción permiten ingeniero software capturar casos prueba resultados para una posterior reproducción comparación. suite prueba regresión ( subconjunto pruebas que ejecutar) contiene tres clases diferentes casos prueba: • una muestra representativa pruebas que ejercitará todas las funciones software. • pruebas adicionales que enfocan las funciones del software que probablemente resulten afectadas por cambio. • pruebas que enfocan los componentes del software que cambiaron. conforme avanza prueba integración, número pruebas regresión puede vol- verse muy grande. por tanto, suite pruebas regresión debe diseñarse para incluir sola-mente aquellas que aborden una más clases errores cada una las funciones del programa principal. impráctico ineficiente volver ejecutar toda prueba para cada función del programa cada vez que ocurre cambio. prueba humo. prueba humo enfoque prueba integración que usa cuando desarrolla software producto. diseña como mecanismo ritmo para pro-yectos críticos tiempo, que permite equipo del software valorar proyecto manera frecuente. esencia, enfoque prueba humo abarca las siguientes actividades: . los componentes software traducidos código integran una construcción. una construcción incluye todos los archivos datos, bibliotecas, módulos reutilizables componentes sometidos ingeniería que requieren para implementar una más funciones del producto. . diseña una serie pruebas para exponer los errores que evitarán construcción realizar adecuadamente función. intención debe ser descubrir errores “paralizan- tes” que tengan mayor probabilidad retrasar proyecto. . construcción integra con otras construcciones, todo producto ( forma actual) somete prueba humo diariamente. enfoque integración puede ser descendente ascendente. frecuencia diaria las pruebas todo producto puede sorprender algunos lectores. sin embargo, las pruebas constantes brindan, tanto gerentes como profesionales, una valo- ración realista del progreso prueba integración. mcconnell [mcc] describe prueba humo forma siguiente: prueba humo debe ejercitar todo sistema extremo extremo. tiene que ser exhaustiva, pero debe poder exponer los problemas principales. prueba humo debe ser suficientemente profunda para que, construcción pasa, pueda suponer que suficientemente estable para pro-barse con mayor profundidad. prueba humo proporciona algunos beneficios cuando aplica sobre proyectos software complejos cruciales tiempo: • minimiza riesgo integración . puesto que las pruebas humo realizan diaria- mente, las incompatibilidades otros errores paralizantes pueden descubrirse tempra- namente, que reduce probabilidad impacto severo sobre calendario cuando descubren errores.cita: “trate construcción diaria como latido del proyecto. hay latido, proyecto está muerto.” jim mccarthypunto clave prueba humo puede caracterizarse como una estrategia integración constante. software reconstruye (con agregado nuevos componentes) prueba cada día. ¿qué beneficios pueden derivarse las pruebas humo? ? (-).indd (-).indd // ::// :: parte tres administración calidad • calidad del producto final mejora. probable que prueba humo descubra errores funcionales así como errores diseño arquitectónico componente debido que enfoque está orientado construcción (integración). tales errores corrigen temprano, tendrá una mejor calidad del producto. • diagnóstico corrección errores simplifican. como todo enfoque prueba integración, probable que los errores descubiertos durante prueba humo asocien con “nuevos incrementos software”; decir, software que acaba agregar () construcción() causa probable error recientemente descu-bierto. • progreso más fácil valorar. con cada día que transcurre, más software integra demuestra que funciona. esto incrementa moral del equipo brinda los gerentes buen indicio que está progresando. opciones estratégicas. habido mucha discusión (por ejemplo, [bei]) acerca las - lativas ventajas desventajas las pruebas integración descendente comparación con las ascendentes. general, las ventajas una estrategia tienden ser desventajas para otra. principal desventaja del enfoque descendente necesidad representantes las dificultades prueba que pueden asociarse con ellos. los problemas asociados con los repre-sentantes pueden compensarse con ventaja probar tempranamente las principales funcio-nes control. principal desventaja integración ascendente que “ programa como entidad existe hasta que agrega último módulo” [mye]. este incon veniente atem- pera con mayor facilidad diseño casos prueba falta representantes. selección una estrategia integración depende las características del software , ocasiones, del calendario del proyecto. general, enfoque combinado ( veces llamado prueba sándwich), que usa pruebas descendentes para niveles superiores estructura del programa acopladas con pruebas ascendentes para niveles subordinados, puede ser mejor arreglo. conforme realiza integración, quien efectúa prueba debe identificar los módulos crí- ticos. módulo crítico tiene una más las siguientes características: ) aborda muchos -querimientos software, ) tiene alto nivel control (reside relativamente alto -tructura del programa), ) complejo proclive error ) tiene requerimientos rendimiento definidos. los módulos críticos deben probarse tan pronto como sea posible. además, las prue-bas regresión deben enfocarse función del módulo crítico. productos trabajo las pruebas integración. plan global para integración del software una descripción las pruebas específicas documentan una especificación pruebas. este producto trabajo incorpora plan prueba procedimiento prueba, vuelve parte configuración del software. prueba divide fases construcciones que abordan características del software funcionales comportamiento específicas. por ejemplo, prueba integración para sistema seguridad casasegur puede dividirse las siguientes fases prueba: • interacción con usuario (entrada salida comandos, representación despliegue, procesamiento representación errores) • procesamiento sensores (adquisición salida sensor, determinación condi-ciones del sensor, acciones requeridas como consecuencia las condiciones) • funciones comunicación (capacidad para comunicarse con estación monitoreo central) • procesamiento alarma (pruebas acciones del software que ocurren cuando encuentra una alarma)webref pueden encontrarse enlaces comentarios acerca estrategias pruebas. ¿qué “módulo crítico” por qué debe identificársele?? (-).indd (-).indd // ::// :: estrategias prueba software cada una estas fases prueba integración delinea una amplia categoría funcional dentro del software por general puede relacionarse con dominio específico dentro arquitectura del software. por tanto, las construcciones programas (grupos módulos) crean para corresponder cada fase. los siguientes criterios pruebas correspondientes apli-can todas las fases prueba: integridad interfaz. las interfaces internas externas prueban conforme cada módulo ( grupo) incorpora estructura. validez funcional. realizan pruebas diseñadas para descubrir errores funcionales ocultos. contenido información. realizan pruebas diseñadas para descubrir errores ocultos asociados con las estructuras datos locales globales. rendimiento. realizan pruebas diseñadas para verificar los límites del rendimiento esta- blecidos durante diseño del software. como parte del plan prueba, también discute calendario para integración, - sarrollo software sobrecarga del sistema temas relacionados. establecen las fechas inicio fin cada fase definen “ventanas disponibles” para módulos prueba uni-dad. una breve descripción del software sobrecarga (representantes controladores) concentra las características que pueden requerir esfuerzo especial. finalmente, describe entorno los recursos prueba. configuraciones inusuales hardware, simuladores peculiares herramientas técnicas prueba especial son algunos los muchos temas que también pueden analizarse. continuación describe procedimiento prueba detallado que requiere para lograr plan prueba. señala orden integración las pruebas correspondientes cada paso ésta. también incluye una lista todos los casos prueba (anotados para referen-cia posterior) los resultados esperados. reporte prueba, que puede anexarse especificación pruebas desea, regis- tra una historia resultados, problemas peculiaridades prueba reales. información contenida esta sección puede ser vital durante mantenimiento del software. también presentan las referencias apéndices apropiados. como todos los demás elementos una configuración software, formato especi- ficación pruebas puede adaptarse las necesidades locales una organización ingeniería software. sin embargo, importante señalar que una estrategia integración (contenida plan prueba) los detalles prueba (descritos procedimiento prueba) son ingredientes esenciales deben aparecer. . strategias prueba para software orientado objeto enunciado manera simple, objetivo probar encontrar mayor número posible errores con una cantidad manejable esfuerzo aplicado durante lapso realista. aunque este objetivo fundamental mantiene invariable para software orientado objeto, naturaleza este software cambia tanto estrategia como las tácticas prueba (capítulo ). .. prueba unidad contexto cuando considera software orientado objeto, concepto unidad cambia. encapsula-ción determina definición clases objetos. esto significa que cada clase cada instancia una clase empaqueta los atributos (datos) las operaciones que manipulan estos datos. por ¿qué criterios deben usarse para diseñar pruebas integración?? apéndice presentan conceptos básicos orientados objeto. (-).indd (-).indd // ::// :: parte tres administración calidad general, una clase encapsulada foco prueba unidad. obstante, las operaciones (métodos) dentro clase son las unidades comprobables más pequeñas. puesto que una clase puede contener algunas operaciones diferentes, una operación particular puede existir como parte algunas clases diferentes, las tácticas aplicadas prueba unidad deben cambiar. posible probar una sola operación aislamiento ( visión convencional prueba unidad) sino más bien como parte una clase. para ilustrarlo, considere una jerar-quía clase que una operación define para superclase heredan algunas sub-clases. cada subclase usa operación , pero aplica dentro del contexto los atributos operaciones privados que definieron para subclase. dado que contexto que usa operación varía sutilmente, necesario probar operación contexto cada una las subclases. esto significa que por general efectivo probar operación forma aislada ( enfoque prueba unidad convencional) contexto orientado objeto. prueba clase para software equivalente prueba unidad para software convencional. diferencia prueba unidad del software convencional, que tiende -focarse sobre detalle algorítmico módulo los datos que fluyen través inter-faz módulo, prueba clase para software dirigen las operaciones encapsuladas por clase comportamiento estado ésta. .. prueba integración contexto puesto que software orientado objeto tiene una estructura control jerárquico obvia, las estrategias tradicionales descendente ascendente (sección ..) tienen poco significado. además, con frecuencia imposible integrar las operaciones una vez una clase ( -foque integración incremental convencional) debido las “interacciones directa indirecta los componentes que constituyen clase” [ber]. existen dos estrategias diferentes para prueba integración los sistemas [bin]. primera, prueba basada hebra, integra conjunto clases requeridas para responder una entrada evento para sistema. cada hebra integra prueba manera individual. prueba regresión aplica para asegurar que ocurran efectos colaterales. segundo enfoque integración, prueba basada uso , comienza construcción del sistema probar dichas clases (llamadas clases independientes) que usan muy pocas clases servidor ( que usan alguna). después probar las clases independientes, prueba siguiente capa clases, llamadas dependientes, que usan las clases independientes. esta secuencia probar capas clases dependientes continúa hasta que construye todo sistema. uso controladores representantes también cambia cuando realiza prueba integración los sistemas . los controladores pueden usarse para probar operaciones nivel más bajo, para prueba todos los grupos clases. también puede usarse con-trolador para sustituir interfaz usuario, modo que las pruebas funcionalidad del sistema puedan realizarse antes implementación interfaz. los representantes ( stubs) pueden usarse situaciones donde requiere colaboración entre clases pero donde una más las clases colaboradoras todavía implementan por completo. prueba grupo paso prueba integración del software . aquí, grupo clases colaboradoras (determinadas examinar crc modelo objeto relacional) ejercita diseñar casos prueba que intentan descubrir errores las colaboraciones. . strategias prueba para webapps estrategia para probar webapps adopta los principios básicos para todas las pruebas soft- ware aplica una estrategia tácticas que usan para sistemas orientados objetos. los -guientes pasos resumen enfoque:punto clave prueba clase para software análoga prueba módulo para software convencional. aconsejable probar operaciones aislamiento. punto clave una importante estrategia para prueba integración del software prueba basada hebra. las hebras son conjuntos clases que responden una entrada evento. las pruebas basadas uso enfocan clases que colaboran fuertemente con otras clases. (-).indd (-).indd // ::// :: estrategias prueba software . modelo contenido para webapp revisa para descubrir errores. . modelo interfaz revisa para garantizar que todos los casos uso pueden ade- cuarse. . modelo diseño para webapp revisa para descubrir errores navegación. . interfaz usuario prueba para descubrir errores los mecanismos presenta- ción / navegación. . cada componente funcional aplica una prueba unidad. . prueba navegación largo toda arquitectura. . webapp implementa varias configuraciones ambientales diferentes prueba compatibilidad con cada configuración. . las pruebas seguridad realizan con intención explotar vulnerabilidades webapp dentro ambiente. . realizan pruebas rendimiento. . webapp prueba mediante una población usuarios finales controlada monito- reada. los resultados interacción con sistema evalúan por errores conte- nido navegación, preocupaciones facilidad uso, preocupaciones compatibili- dad, así como confiabilidad rendimiento webapp. puesto que muchas webapps evolucionan continuamente , proceso prueba una acti- vidad siempre marcha, realiza para apoyar personal que usa pruebas regresión derivadas las pruebas desarrolladas cuando elaboró por primera vez webapp. capítulo consideran métodos para probar webapp. . ruebas validación las pruebas validación comienzan culminación las pruebas integración, cuando ejercitaron componentes individuales, software está completamente ensamblado como paquete los errores interfaz descubrieron corrigieron. nivel validación sistema, desaparece distinción entre software convencional, software orientado objetos webapps. las pruebas enfocan las acciones visibles para usuario las salidas del sistema reconocibles por usuario. validación puede definirse muchas formas, pero una definición simple (aunque dura) que validación exitosa cuando software funciona una forma que cumpla con las expectativas razonables del cliente. este punto, desarrollador software curtido batalla puede protestar: “¿quién qué árbitro las expectativas razonables?”. desa-rrolló una especificación requerimientos software, ella describen todos los atributos del software visibles para usuario; contiene una sección criterios validación que forman base para enfoque pruebas validación. .. criterios pruebas validación validación del software logra través una serie pruebas que demuestran conformi-dad con los requerimientos. plan prueba subraya las clases pruebas que van realizar procedimiento prueba define casos prueba específicos que diseñan para garantizar que: satisfacen todos los requerimientos funcionamiento, logran todas las características comportamiento, todo contenido preciso presenta manera ade-cuada, logran todos los requerimientos rendimiento, documentación correcta punto clave estrategia global para probar webapps puede resumirse los pasos que anotan aquí. webref testing.asp pueden encontrarse excelentes artículos acerca pruebas las webapps. punto clave como todos los demás pasos las pruebas, validación intenta descubrir errores, pero enfoque orienta los requerimientos: sobre las cosas que serán inmediatamente aparentes para usuario final. (-).indd (-).indd // ::// :: parte tres administración calidad satisfacen facilidad uso otros requerimientos (por ejemplo, transportabilidad, compatibi- lidad, recuperación error, mantenimiento). después realizar cada caso prueba validación, existen dos posibles condiciones: ) característica función rendimiento conforma acuerdo con las especificaciones acepta, ) descubre una desviación especificación crea una lista deficien-cias. las desviaciones errores descubiertos esta etapa proyecto rara vez pueden corregirse antes entrega calendarizada. con frecuencia necesario negociar con cliente para establecer método para resolver deficiencias. .. revisión configuración elemento importante del proceso validación una revisión configuración. inten- ción revisión garantizar que todos los elementos configuración del software desarrollaron manera adecuada, que cataloga tiene detalle necesario para refor-zar las actividades apoyo. revisión configuración, ocasiones llamada auditoría, estudia con más detalle capítulo . .. pruebas alfa beta virtualmente, imposible que desarrollador software prevea cómo usará cliente real-mente programa. las instrucciones para usarlo pueden malinterpretarse; regularmente pueden usarse combinaciones extrañas datos; salida que parecía clara quien realizó prueba puede ser ininteligible para usuario. cuando construye software medida para cliente, realiza una serie pruebas aceptación fin permitir cliente validar todos los requerimientos. realizada por usuario final lugar por los ingenieros software, una prueba aceptación puede variar desde una “prueba conducción” informal hasta una serie pruebas planificadas ejecutadas sis-temáticamente. hecho, prueba aceptación puede realizarse durante periodo -manas meses, mediante ella descubrir errores acumulados que con tiempo puedan degra-dar sistema. software desarrolla como producto que ser usado por muchos clientes, práctico realizar pruebas aceptación formales con cada uno ellos. mayoría los cons-tructores productos software usan proceso llamado prueba alfa prueba beta para descubrir errores que parecer sólo usuario final capaz encontrar. prueba alfa lleva cabo sitio del desarrollador por grupo representativo usuarios finales. software usa escenario natural con desarrollador “mirando -bre hombro” los usuarios registrando los errores problemas uso. las pruebas alfa realizan ambiente controlado. prueba beta realiza uno más sitios del usuario final. diferencia prueba alfa, por general desarrollador está presente. por tanto, prueba beta una aplicación “ vivo” del software ambiente que puede controlar desarrollador. cliente registra todos los problemas (reales imaginarios) que encuentran durante prueba beta los -porta desarrollador periódicamente. como resultado los problemas reportados durante las pruebas beta, posible hacer modificaciones luego preparar liberación del producto software toda base clientes. ocasiones realiza una variación prueba beta, llamada prueba aceptación del cliente, cuando software entrega cliente bajo contrato. cliente realiza una serie pruebas específicas con intención descubrir errores antes aceptar software del desa-rrollador. algunos casos (por ejemplo, gran corporativo sistema gubernamental) prueba aceptación puede ser muy formal abarcar muchos días incluso semanas prueba.cita: “teniendo los suficientes ojos, todos los errores son superficia-les (por ejemplo, con una base suficientemente grande per-sonas que realizan pruebas beta codesarrolladores, casi todo problema caracterizará rápi-damente corrección será obvia para alguien).” . raymond ¿cuál diferencia entre una prueba alfa una prueba beta?? (-).indd (-).indd // ::// :: estrategias prueba software . ruebas del sistema comienzo este libro, resaltó hecho que software sólo elemento sis- tema basado computadora más grande. final cuentas, software incorpora con otros elementos del sistema (por ejemplo, hardware, personas, información), lleva cabo una serie pruebas integración validación del sistema. estas pruebas quedan fuera del ámbito del proceso software llevan cabo exclusivamente por parte ingenieros software. sin embargo, los pasos que toman durante diseño prueba del software pueden mejorar enormemente probabilidad integración exitosa del software sistema más grande. problema clásico prueba del sistema “dedo acusador”. esto ocurre cuando descubre error los desarrolladores diferentes elementos del sistema culpan unos otros por problema. lugar abandonarse tal sinsentido, deben anticiparse los potenciales pro-blemas interfaz : ) diseñar rutas manejo error que prueben toda información prove-niente otros elementos del sistema, ) realizar una serie pruebas que simulen los datos malos otros errores potenciales interfaz del software, ) registrar los resultados las pruebas para usar como “evidencia” ocurre dedo acusador, ) participar planificación diseño pruebas del sistema para garantizar que software prueba manera adecuada. realidad, prueba del sistema una serie diferentes pruebas cuyo propósito principal ejercitar por completo sistema basado computadora. aunque cada prueba tenga propósito diferente, todo funciona para verificar que los elementos del sistema hayan -tegrado manera adecuada que realicen las funciones asignadas. las secciones que siguen estudian los tipos pruebas del sistema que valen pena para los sistemas basados software. .. pruebas recuperación muchos sistemas basados computadora deben recuperarse fallas reanudar procesa-miento con poco ningún tiempo inactividad. algunos casos, sistema debe ser tole- escena: oficina doug miller, mientras con- tinúan tanto diseño nivel componentes como construcción ciertos componentes. participantes: doug miller, jefe ingeniería del software, vinod, jamie, shakira, miembros del equipo ingeniería del software casasegura. conversación:doug: primer incremento estará listo para validación ... ¿cuán- tiempo? ¿tres semanas? vinod: más menos. integración bien. hacemos pruebas humo todos los días encontramos algunos bugs, pero nada que podamos manejar. hasta momento bien. doug: háblame validación.shakira: bueno, para diseño prueba, usaremos todos los casos uso como base. todavía empiezo, pero desarrollaré pruebas para todos los casos uso las que sea responsable. : igual .jamie: también, pero debemos actuar juntos para prueba aceptación también para las pruebas alfa beta, ¿ ? doug: . hecho pensado; podríamos traer contratista externo para ayudarnos con validación. tengo dinero presu-puesto... nos daría nuevo punto vista. vinod: creo que tenemos bajo control.doug: estoy seguro que , pero gpi nos vistazo indepen- diente del software. jamie: estamos apretados tiempo, doug. tengo tiempo para vigilar alguien que traigan para hacer trabajo. doug: , . pero gpi funciona partir los requeri- mientos los casos uso, necesitará demasiada vigilancia. vinod: todavía creo que tenemos bajo control.doug: escuché, vinod, pero voy sostener opinión esta ocasión. más tarde planearemos reunión con representante del gpi para esta semana. dejemos que comiencen veamos que proponen. vinod: muy bien, tal vez eso aligere poco carga.casasegura preparación para validación cita: “como muerte los impues- tos, las pruebas son desagradables inevitables”. yourdon (-).indd (-).indd // ::// :: parte tres administración calidad rante las fallas, decir, las fallas del procesamiento deben causar cese del funciona- miento del sistema global. otros casos, falla sistema debe corregirse dentro periodo tiempo específico ocurrirán severos daños económicos. recuperación una prueba del sistema que fuerza software fallar varias formas que verifica que recuperación realice manera adecuada. recuperación automá-tica (realizada por sistema ), evalúa reinicio, los mecanismos puntos verifica-ción, recuperación datos reanudación para correcciones. recuperación requiere intervención humana, evalúa tiempo medio reparación (tmr) para determinar está dentro límites aceptables. .. pruebas seguridad cualquier sistema basado computadora que gestione información sensible cause acciones que puedan dañar ( beneficiar) manera inadecuada individuos blanco penetra-ción inadecuada ilegal. penetración abarca amplio rango actividades: hackers que intentan penetrar los sistemas por deporte, empleados resentidos que intentan penetrar por venganza, individuos deshonestos que intentan penetrar para obtener ganancia personal ilícita. prueba seguridad intenta verificar que los mecanismos protección que construyen sistema realidad protegerán cualquier penetración impropia. para citar beizar [bei]: “ seguridad del sistema debe, desde luego, probarse para ser invulnerable ante ata-ques frontales; pero también debe probarse invulnerabilidad contra ataques laterales tra-seros.” durante prueba seguridad, quien realiza prueba juega papel del individuo que - sea penetrar sistema. ¡cualquier cosa vale! quien realice prueba puede intentar adquirir contraseñas por medios administrativos externos; puede atacar sistema con software medida diseñado para romper cualquier defensa que haya construido; puede abrumar sis-tema, por tanto negar servicio los demás; puede causar propósito errores del sistema con esperanza penetrar durante recuperación; puede navegar través datos insegu-ros para encontrar llave entrada sistema. con los suficientes tiempo recursos, las buenas pruebas seguridad final cuentas penetran sistema. papel del diseñador sistemas hacer que costo penetra-ción sea mayor que valor información que obtendrá. .. pruebas esfuerzo los primeros pasos prueba del software dieron como resultado una evaluación extensa las funciones rendimiento normales del programa. las pruebas esfuerzo diseñan para enfrentar los programas con situaciones anormales. esencia, persona que realiza las prue-bas esfuerzo pregunta: “¿cuánto podemos doblar esto antes que rompa?”. prueba esfuerzo ejecuta sistema forma que demanda recursos cantidad, fre- cuencia volumen anormales. por ejemplo, pueden ) diseñarse pruebas especiales que gene-ren diez interrupciones por segundo, cuando una dos tasa promedio, () aumentarse las tasas entrada datos orden magnitud para determinar cómo responderán las fun-ciones entrada, ) ejecutarse casos prueba que requieran memoria máxima otros recur-sos, ) diseñarse casos prueba que puedan causar thrashing (que quebranto del sistema por hiperpaginación) sistema operativo virtual, ) crearse casos prueba que puedan causar búsqueda excesiva por datos residentes disco. esencia, persona que realiza prueba intenta romper programa. una variación prueba esfuerzo una técnica llamada prueba sensibilidad. algunas situaciones ( más común ocurre algoritmos matemáticos), rango muy pequeño cita: “ intenta encontrar verdaderos errores del sistema sujeta software una verdadera prueba esfuerzo, entonces momento comenzar.” boris beizer (-).indd (-).indd // ::// :: estrategias prueba software datos contenidos dentro las fronteras los datos válidos para programa pueden cau- sar procesamiento extremo, incluso erróneo, profunda degradación del rendimiento. prueba sensibilidad intenta descubrir combinaciones datos dentro clases entrada válidas que puedan causar inestabilidad procesamiento inadecuado. .. pruebas rendimiento para sistemas tiempo real sistemas embebidos , software que proporcione función requerida, pero que adecue los requerimientos rendimiento, inaceptable. prueba rendimiento diseña para poner prueba rendimiento del software tiempo corrida, dentro del contexto sistema integrado. prueba del rendimiento ocurre largo todos los pasos del proceso prueba. incluso nivel unidad, puede accederse rendi-miento módulo individual conforme realizan las pruebas. sin embargo, sino hasta que todos los elementos del sistema están plenamente integrados cuando puede determinarse verdadero rendimiento sistema. las pruebas rendimiento con frecuencia aparean con las pruebas esfuerzo por general requieren instrumentación hardware software, decir, con frecuencia nece-sario medir utilización los recursos (por ejemplo, ciclos del procesador) forma meticu-losa. instrumentación externa puede monitorear intervalos ejecución eventos registro (por ejemplo, interrupciones) conforme ocurren, los muestreos del estado máquina manera regular. con instrumentación sistema, persona que realiza prueba puede descubrir situaciones que conduzcan degradación posibles fallas del sistema. .. pruebas despliegue muchos casos, software debe ejecutarse varias plataformas bajo más entorno sistema operativo. prueba despliegue , ocasiones llamada prueba configuración , ejercita software cada entorno que debe operar. además, examina todos los proce- objetivo: estas herramientas ayudan equipo soft- ware planificar estrategia pruebas que elija administrar proceso prueba mientras lleva cabo. mecánica: las herramientas esta categoría abordan planifica- ción las pruebas, almacenamiento, administración control las mismas; seguimiento los requisitos, integración, rastreo errores generación reportes. los gestores proyecto los usan para complementar las herramientas calendarizadas del proyec-. quienes realizan las pruebas usan estas herramientas para pla-near actividades prueba controlar flujo información confor- avanza proceso pruebas. herramientas representativas: qatraq test case management tool, desarrollada por traq software ( “alienta enfoque estructu- rado gestión pruebas”.qadirector, desarrollada por compuware corp. (www. compuware.com/qacenter), proporciona solo punto control para gestionar todas las fases del proceso pruebas. testworks, desarrollada por software research, inc. ( com/products/index.html), contiene una suite completamen- integrada herramientas prueba, incluidas herramientas para administración reporte pruebas. opensourcetesting.org ( testmgt.php), cita varias herramientas gestión planifica-ción pruebas fuente abierta. teststand, desarrollada por national instruments corp. (www. .com), permite “desarrollar, gestionar ejecutar secuencias pruebas escritas cualquier lenguaje programación”.herramientas software planeación administración pruebas las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus res- pectivos desarrolladores. (-).indd (-).indd // ::// :: parte tres administración calidad dimientos instalación software instalación especializado (por ejemplo, “instaladores”) que usarán los clientes, así como toda documentación que usará para introducir software los usuarios finales. como ejemplo, piense versión accesible internet del software casasegura que permi- tiría cliente monitorear sistema seguridad desde ubicaciones remotas. webapp casasegura debe probarse usando todos los navegadores web que probable que encuen-tren. una prueba despliegue más profunda puede abarcar combinaciones navegadores web con varios sistemas operativos (por ejemplo, linux, mac , windows). puesto que -guridad tema principal, juego completo pruebas seguridad integraría con prueba despliegue. . arte depuración prueba del software proceso que puede planearse especificarse manera sistemá-tica. puede realizarse diseño casos prueba, definir una estrategia evaluar los resulta-dos comparándolos con las expectativas prescritas. depuración ocurre como consecuencia las pruebas exitosas. decir, cuando caso prueba descubre error, depuración proceso que como resultado remoción del error. aunque depuración puede debe ser proceso ordenado, todavía mucho arte. los ingenieros software con frecuencia enfrentan con indicios “sintomáticos” problema software mientras evalúan los resultados una prueba, decir, manifesta-ción externa del error causa interna pueden tener relación obvia una con otra. proceso mental, pobremente comprendido, que conecta síntoma con una causa conoce como depuración. .. proceso depuración depuración una prueba, pero con frecuencia ocurre como consecuencia una prueba. acuerdo con figura ., proceso depuración comienza con ejecución caso prueba. los resultados valoran encuentra falta correspondencia entre rendi-miento esperado real. muchos casos, correspondencia los datos síntoma una causa subyacente escondida. proceso depuración intenta relacionar síntoma con causa, que por tanto conduce corrección del error. por general, proceso depuración dará como resultado que: ) causa encontrará corregirá ) causa encontrará. último caso, persona que realiza depuración puede sospechar una causa, diseñar caso prueba para auxiliarse validación dicha suposición trabajar hacia corrección del error forma iterativa. ¿por qué tan difícil depuración? con toda probabilidad, psicología humana (vea sección ..) tiene más que ver con respuesta que tecnología del software. sin embargo, ciertas características los errores brindan algunas pistas: . síntoma causa pueden ser geográficamente remotos. decir, síntoma puede aparecer una parte programa, mientras que causa realidad puede ubi-carse sitio que esté alejado. los componentes altamente acoplados (capítulo ) exacerban esta situación. . síntoma puede desaparecer (temporalmente) cuando corrige otro error.cita: “para nuestra sorpresa, descu- brimos que fue tan fácil obtener programas justo como los habíamos pensado. recuerdo instante exacto que cuenta que una gran parte vida, partir entonces, iba pasar descubriendo los errores mis propios progra-mas”. maurice wilkes, descubre depuración, hacer esta afirmación, toma visión más amplia posible las pruebas. sólo desarrollador prueba software previo liberación, ¡sino que cliente/usuario prueba software cada vez que usa!asegúrese evitar tercer resultado: encuentra causa, pero “corrección” resuelve problema incluso introduce otro error.consejo ¿por qué tan difícil depuración?? (-).indd (-).indd // ::// :: estrategias prueba software . síntoma realidad puede ser causado por errores (por ejemplo, imprecisiones redondeo). . síntoma puede ser causado por error humano que rastrea con facilidad. . síntoma puede ser resultado problemas temporización más que problemas procesamiento. . puede ser difícil reproducir con precisión las condiciones entrada (por ejemplo, una aplicación tiempo real que orden entrada esté indeterminado). . síntoma puede ser intermitente, particularmente común sistemas embebidos que acoplan hardware software manera inextricable. . síntoma puede deberse causas que distribuyen través algunas tareas que corren diferentes procesadores. durante depuración, encontrará errores que varían desde los ligeramente desconcertantes (por ejemplo, formato salida incorrecto) hasta los catastróficos (por ejemplo, falla del sistema, que pro voca serio daño económico físico). conforme aumentan las consecuencias error, también aumenta cantidad presión por encontrar causa. con frecuencia, presión fuerza algunos los desarrolladores del software corregir error , mismo tiempo, introducir dos más. .. consideraciones psicológicas por desgracia, parece haber cierta evidencia que hazaña depuración rasgo humano innato. algunas personas son buenas ello otras son. aunque evidencia experimental depuración está abierta muchas interpretaciones, reportan grandes -riaciones habilidad depuradora para programadores con misma educación experien-cia. comentar acerca los aspectos humanos depuración, shneiderman [shn] afirma:pruebas regresión correcciones causas identiﬁcadaspruebas adicionales causas sospechosasresultados depuracióncasos pruebafigura . proceso depuración “todo mundo sabe que depuración doble difícil que escribir programa por primera vez. modo que, tan inteligente como puede ser cuando escribe programa, ¿cómo que depurará?”. brian kernighan? (-).indd (-).indd // ::// :: parte tres administración calidad depuración una las partes más frustrantes programación. tiene elementos resolución problemas rompecabezas, junto con desconcertante reconocimiento que cometió error. elevada ansiedad falta voluntad para aceptar posibilidad los errores aumentan dificultad tarea. por fortuna, hay gran alivio tensión aligera cuando finalmente error… corrige. aunque puede ser difícil “aprender” depurar, posible proponer algunos enfoques pro- blema. revise sección ... escena: cubículo mientras realiza codificación prueba unidad. participantes: shakira, miembros del equipo ingeniería software casasegura. conversación:shakira (observa través entrada del cubículo): hola... ¿dónde estuviste hora del almuerzo?: aquí... trabajando.shakira: ves horrible... ¿cuál problema? (suspira): estado trabajando este... error desde que descubrí las : esta mañana , ¿qué?, :... tengo idea. shakira: creí que todos estuvimos acuerdo pasar más una hora tareas depuración por cuenta propia; luego pediría-mos ayuda, ¿verdad?: , pero... shakira (entra cubículo): ¿así que cuál problema?: complicado , además, visto durante, ¿cuánto?, horas. vas ver minutos. shakira: permíteme... ¿cuál problema?[ explica problema shakira, quien observa durante segundos sin hablar, luego...] shakira ( asoma una sonrisa cara): , justo ahí, variable llamada setalarmcondition. ¿ debería ponerse “falso” antes comenzar bucle? [ mira pantalla con incredulidad, dobla hacia adelante - mienza golpear cabeza suavemente contra monitor. shakira, quien ahora sonríe abiertamente, incorpora sale del cubículo].casasegura depuración .. estrategias depuración sin importar enfoque que tome, depuración tiene objetivo dominante: encontrar corregir causa error defecto software. objetivo realiza mediante una combi-nación evaluación sistemática, intuición suerte. bradley [bra] describe enfoque depuración siguiente forma: depuración una aplicación directa del método científico que desarrollado durante más años. base depuración localizar fuente del problema [ causa] mediante una par-tición binaria, través del trabajo con hipótesis que predicen nuevos valores por examinar. tome ejemplo simple que sea software: una lámpara casa funciona. nada casa funciona, causa debe estar interruptor principal exterior; observo alrededor para ver vecindario está oscuras. conecto lámpara sospechosa tomacorriente que funcione electrodoméstico operativo circuito sospechoso. así continúo alternación entre hipótesis pruebas. general, han propuesto tres estrategias depuración [mye]: ) fuerza bruta, ) vuelta atrás (del inglés backtracking) ) eliminación causas. cada una estas estrategias puede llevarse cabo manera manual, pero modernas herramientas depuración pueden hacer proceso mucho más efectivo. tácticas depuración. categoría fuerza bruta depuración probablemente método más común menos eficiente para aislar causa error software. los métodos establezca límite, por decir, dos horas, cantidad tiempo que empleará intentar depurar problema por cuenta propia. después eso, ¡pida ayuda!consejo (-).indd (-).indd // ::// :: estrategias prueba software depuración fuerza bruta aplican cuando todo demás falla. usar una filosofía “deje que computadora encuentre error”, toman copias memoria ( dumps), invo- can rastreos tiempo corrida programa carga con enunciados salida. espe-ranza que, alguna parte del pantano información que produzca, encontrará una pista que pueda conducir causa error. aunque masa información producida final cuentas puede conducir éxito, con más frecuencia conduce desperdicio esfuerzo tiempo. ¡piense que primero debe gastarse! seguimiento hacia atrás vuelta atrás enfoque depuración bastante común que puede usarse exitosamente programas pequeños. comenzar sitio donde descubrió síntoma, código fuente rastrea hacia atrás ( manera manual) hasta que encuentra causa. por desgracia, conforme aumenta número líneas fuente, número rutas -tenciales hacia atrás puede volverse inmanejable. tercer enfoque depuración, eliminación causa, manifiesta mediante induc- ción deducción, introduce concepto partición binaria. los datos relacionados con ocurrencia del error organizan para aislar las causas potenciales. plantea una “hipótesis causa” los datos anteriormente mencionados usan para probar refutar hipótesis. manera alternativa, desarrolla una lista las posibles causas realizan pruebas para eliminar cada una. las pruebas iniciales indican que una hipótesis causa particular muestra prometedora, los datos refinan con intención aislar error. depuración automatizada. cada uno estos enfoques depuración puede complemen- tarse con herramientas depuración que puedan proporcionar apoyo semiautomático con-forme intenten estrategias depuración. hailpern santhanam [hai] resumen estado estas herramientas cuando apuntan: “... han propuesto muchos nuevos enfoques están disponibles muchos entornos depuración comerciales. los entornos desarrollo integrados (ide) brindan una forma capturar algunos los errores predeterminados específicos del lenguaje (por ejemplo, falta caracteres fin sentencia , variables indefinidas, etc.) sin requerir compilación”. dispone una gran variedad compiladores depuración, ayudas dinámicas depuración (“trazadores”), generadores automáticos casos prueba herra-mientas mapeo referencia cruzada. sin embargo, las herramientas son sustituto cita: “ primer paso para reparar programa descompuesto hacerlo fallar repetidamente ( ejemplo más simple posible).” . duff objetivo: estas herramientas proporcionan asistencia automatizada para quienes deben depurar problemas software. intención proporcionar conocimiento que puede ser difícil obtener aborda proceso depuración forma manual. mecánica: mayoría las herramientas depuración son espe- cíficas del lenguaje programación del entorno. herramientas representativas: borland gauntlet, distribuido por borland ( com), auxilia tanto las pruebas como depuración. coverty prevent sqs, desarrollada por coverty ( com), proporciona asistencia depuración tanto para ++ como para java.++test, desarrollada por parasoft ( una herramienta prueba unidad que soporta rango completo pruebas código ++. las características depuración ayudan diagnóstico errores que encuentren. codemedic, desarrollada por newplanet software (www. newplanetsfotware.com/medic/), proporciona una inter-faz gráfica para depurador estándar unix, gdb, implementa sus características más importantes. actualidad, gdb soporta /++, java, palmos, varios sistemas incrustados, lenguaje ensamblador, fortran modula-. gnats, una aplicación freeware ( gnats), conjunto herramientas para rastrear reportes error.herramientas software depuración las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus res- pectivos desarrolladores. (-).indd (-).indd // ::// :: parte tres administración calidad para evaluación cuidadosa basada modelo completo diseño código fuente claro. factor humano. cualquier discusión los enfoques herramientas depuración está incompleta sin mencionar poderoso aliado: ¡otras personas! punto vista fresco, empañado por horas frustración, puede hacer maravillas. una máxima final para depura- ción puede ser: “cuando todo demás falle, ¡consiga ayuda!” .. corrección del error una vez encontrado error, debe corregirse. pero, como señaló, corrección error puede introducir otros errores , por tanto, hacer más daño que bien. van vleck [van] sugiere tres preguntas simples que deben plantearse antes hacer “corrección” que remueva causa error: . ¿ causa del error reproduce otr parte del programa? muchas situaciones, defecto programa causado por patrón lógica erróneo que puede reprodu-cirse alguna otra parte. consideración explícita del patrón lógico puede resultar descubrimiento otros errores. . ¿qué “siguiente error” puede introducirse con corrección que está punto realizar? antes hacer corrección, debe evaluarse código fuente (, mejor , diseño) para valorar acoplamiento las estructuras lógica datos. corrección realizará una sección altamente acoplada del programa, debe tenerse especial cuidado cuando realice algún cambio. . ¿qué debió hacerse par evitar este error desde principio? esta pregunta primer paso hacia establecimiento enfoque aseguramiento calidad estadística del software (capítulo ). corrigen tanto proceso como producto, error removerá del programa actual podrá eliminarse todos los programas futuros. . esumen las pruebas software representan porcentaje más grande esfuerzo técnico proceso software. sin importar tipo software que construya, una estrategia para planificar, ejecutar controlar pruebas sistemáticas comienza por considerar pequeños elementos del software moverse hacia afuera, hacia programa como todo. objetivo las pruebas del software descubrir errores. para software convencional, este objetivo logra mediante una serie pasos prueba. las pruebas unidad integración concentran verificación funcional componente incorporación compo-nentes una arquitectura software. las pruebas validación demuestran conformidad con los requerimientos del software las pruebas del sistema validan software una vez que incorporó sistema más grande. cada paso prueba logra través una serie técnicas prueba sistemáticas que auxilian diseño casos prueba. con cada paso prueba, amplía nivel abstracción con que considera software. estrategia para probar software orientado objeto comienza con pruebas que ejercitan las operaciones dentro una clase luego avanzan hacia prueba basada hebra para -tegración. las hebras son conjuntos clases que responden una entrada evento. las prue-bas basadas uso enfocan clases que colaboran demasiado con otras clases. concepto programación por parejas (recomendado como parte del modelo programación extrema que estudió capítulo ), proporciona mecanismo “depuración” conforme diseña codifica soft- ware.cita: “ mejor examinador aquel que encuentra más erro-res... mejor quien consigue corrección más errores.” cem kaner . (-).indd (-).indd // ::// :: estrategias prueba software las webapps prueban forma muy parecida los sistemas . sin embargo, las pruebas diseñan para ejercitar contenido, funcionalidad, interfaz, navegación aspectos rendi- miento seguridad webapp. diferencia las pruebas (una actividad sistemática planificada), depuración puede verse como arte. comenzar con una indicación sintomática problema, actividad depuración debe rastrear causa error. los muchos recursos disponibles durante depuración, más valioso consejo otros miembros del equipo ingeniería del soft-ware. problemas puntos por evaluar .. con sus palabras, describa diferencia entre verificación validación. ¿ambas usan los métodos diseño casos prueba estrategias pruebas? .. mencione algunos problemas que pueden asociarse con creación grupo prueba indepen- diente. ¿los gpi sqa integran con las mismas personas? .. ¿siempre posible desarrollar una estrategia para probar software que usa secuencia pasos prueba descritos sección ..? ¿qué posibles complicaciones pueden surgir para sistemas incrusta-dos? .. ¿por qué módulo altamente acoplado difícil para prueba unidad?.. concepto “antierrores” (sección ..) una forma extremadamente efectiva brindar asis- tencia depuración interna cuando descubre error: ) desarrolle conjunto lineamientos para antierror. ) analice las ventajas usar técnica. ) analice las desventajas. .. ¿cómo puede calendarización del proyecto afectar prueba integración?.. ¿ prueba unidad posible incluso deseable todas las circunstancias? proporcione ejemplos para justificar respuesta. .. ¿quién debe realizar prueba validación: desarrollador usuario del software? justifique respuesta. .. desarrolle una estrategia prueba completa para sistema casasegura que estudió anterior- mente este libro. documéntela una especificación pruebas... como proyecto clase, desarrolle una guía depuración para instalación. ¡ guía debe brindar lenguaje sugerencias orientadas sistemas aprendidos escuela vida! comience por destacar los temas que revisarán clase instructor. publique guía para otros entorno local. lecturas fuentes información adicionales virtualmente todo libro acerca las pruebas del software analiza estrategias junto con métodos para diseño casos prueba. everett raymond (software testing, wiley-ieee computer society press, ), black (pragmatic software testing, wiley, ), spiller . (software testing process: test management, rocky nook, ), perry ( effective methods for software testing, . ., wiley, ), lewis (software testing and continuous quality improvement, . ., auerbach, ), loveland . (software testing techniques, charles river - dia, ), burnstein ( practical software testing, springer, ), dustin (effective software testing, addison- wesley, ), craig kaskiel (systematic software testing, artech house, ), tamres (introducing software testing, addison-wesley, ), whittaker (how break software, addison-wesley, ), kaner . (les- sons learned software testing, wiley, ) son sólo una pequeña muestra muchos libros que estudian los principios, conceptos, estrategias métodos las pruebas. para aquellos lectores con interés los métodos desarrollo software ágiles, crispin house ( testing extreme programming, addison-wesley, ) beck (test driven development: example, addison-wesley, ) presentan estrategias tácticas prueba para programación extrema. kamer . (lessons learned (-).indd (-).indd // ::// :: parte tres administración calidad software testing, wiley, ) presentan una colección más “lecciones” pragmáticas (lineamien- tos) que todo examinador software debe aprender. watkins (testing : off-the-shelf testing process , cambridge university press, ) establece marco conceptual prueba efectivo para todo tipo soft-ware desarrollado adquirido. manges ’brien ( agile testing with ruby and rails, apress, ) abordan estrategias técnicas prueba para lenguaje programación ruby marco conceptual web. sykes mcgregor (practical guide testing object-oriented software, addison-wesley, ), bashir goel (testing object-oriented software, springer-verlag, ), binder ( testing object-oriented systems, addi- son-wesley, ), kung . . (testing object- oriented software, ieee computer society press, ) marick (the craft software testing, prentice-hall, ) presentan estrategias métodos para probar siste- mas . lineamientos para depuración encuentran los libros grötker . (the developer’ guide - bugging, springer, ), agans (debugging, amacon, ), zeller (why programs fail: guide systematic debugging, morgan kaufmann, ), tells hsieh ( the science debugging, the coreolis group, ), robbins (debugging applications, microsoft press, ). kaspersky (hacker debugging uncovered, -list publishing, ) addresses the technology debugging tools. younessi ( object-oriented defect management software, prentice-hall, ) aborda tecnología las herramientas para depuración. younessi (object- oriented defect management software, prentice-hall, ) presenta técnicas para manejar defectos que encuentran sistemas orientados objetos. beizer [bei] presenta una interesante “taxonomía errores” que puede conducir métodos efectivos para planificación pruebas. los libros madisetti akgul ( debugging embedded systems, springer, ), robbins ( debugging - crosoft.net . applications, microsoft press, ), best (linux debugging and performance tuning, prentice- hall, ), ford teorey ( practical debugging ++, prentice-hall, ), brown ( debugging perl, mcgraw- hill, ) mitchell ( debugging java, mcgraw-hill, ) abordan naturaleza especial depuración para los entornos implicados sus títulos. una gran variedad fuentes información acerca estrategias para pruebas está disponible inter- net. una lista actualizada referencias world wide web, que son relevantes para las estrategias prueba software, puede encontrarse sitio web del libro: (-).indd (-).indd // ::// :: aplicaciones convencionales conceptos clave análisis valor frontera . . . . . . . . . . . . . complejidad ciclomática . . . . especializados. . . . flujo . . . . . . . . . . grafo . . . . . . . . prueba basados gráficos . . . . . . . . . . . . . partición equivalencia . . . . . . . . . . . . . . . . . . basada modelo . . arreglo ortogonal . . . . . . . . . . . . . . prueba caja blanca . . . . . caja negra . . . . . . estructura control . . . . . . . . . . . . . . prueba ruta básica . . . . . ¿qué ? una vez generado código fuente, software debe probarse para descubrir ( corregir) tantos errores como sea posible antes entregarlo cliente. meta diseñar una serie casos prueba que tengan una alta probabili-dad encontrar errores; ¿pero cómo? ahí donde entran escena las técnicas prueba software. dichas técnicas proporcionan lineamientos sistemáticos para diseñar pruebas que: ) revisen lógica interna las interfaces todo componente software ) revisen los dominios entrada salida del programa para descubrir errores funcionamiento, comportamiento rendi-miento del programa. ¿quién hace? durante las primeras etapas del proceso, ingeniero software realiza todas las pruebas. sin embargo, conforme avanza proceso, pueden involucrar- especialistas pruebas. ¿por qué importante? las revisiones otras acciones sqa pueden deben descubrir errores, pero son sufi-cientes. cada vez que programa ejecuta, ¡ cliente prueba! por tanto, tiene que ejecutarse programa antes que llegue cliente, con intención específica encontrar remover todos los errores. para encontrar mayor número posible éstos, las pruebas deben reali-zarse manera sistemática deben diseñarse casos prueba usando técnicas sistematizadas. ¿cuáles son los pasos? para aplicaciones convenciona- les, software prueba desde dos perspectivas diferen-tes: ) lógica programa interno revisa usando técnicas diseño casos prueba “caja blanca” ) los requerimientos software revisan usando técni-cas diseño casos prueba “caja negra”. uso casos auxilia diseño pruebas para descubrir errores validación del software. todo caso, inten-ción encontrar máximo número errores con mínima cantidad esfuerzo tiempo. ¿cuál producto final? diseña documenta conjunto casos prueba elaborados para revisar lógica interna, las interfaces, las colaboraciones com-ponentes los requerimientos externos; definen los resultados esperados registran los resultados reales. ¿cómo aseguro que hice bien? cuando realizan pruebas, cambia punto vista. ¡intente con ahínco “romper” software! diseñe casos prueba forma sistemática revise minuciosamente los casos prueba creados. además, puede evaluar cobertura prueba rastrear las actividades detección errores. una mirada rápidalas pruebas presentan una interesante anomalía para los ingenieros software, quienes por naturaleza son personas constructivas. las pruebas requieren que desarrollador deseche nociones preconcebidas sobre “correcto” del software recién desarrollado luego trabajen duro para diseñar casos prueba fin “romper” software. beizer [bei] describe esta situación manera efectiva cuando afirma: existe mito que habría errores que pescar fuésemos realmente buenos programación. realmente nos pudiéramos concentrar, todo mundo usara programación estructurada, diseño des-cendente... entonces habría errores. ése mito. hay errores, dice mito, porque somos malos que hacemos; somos, deberíamos sentirnos culpables por ello. por tanto, aplicación pruebas diseño casos prueba una admisión del fracaso, que inspira una buena dosis culpa. tedio las pruebas justo castigo por nuestros errores. ¿ castigo por qué? ¿por ser humanos? ¿culpa por qué? ¿por fracasar lograr perfección inhumana? ¿por distinguir entre que otro programador piensa que dice? ¿por poder ser telépatas? ¿por resolver problemas comunicación humana los que les dado vuelta... durante siglos? ¿las pruebas deben inspirar culpa? ¿las pruebas son realmente destructivas? respuesta estas preguntas : “¡!” este capítulo estudian técnicas para diseño casos prueba software para aplicaciones convencionales. este diseño enfoca conjunto técnicas para creación casos prueba que satisfacen los objetivos prueba globales las estrategias pruebas que estudiaron capítulo . (-).indd (-).indd // ::// :: parte tres administración calidad . undamentos las pruebas del software meta probar encontrar errores, una buena prueba aquella que tiene una alta pro- babilidad encontrar uno. por tanto, sistema basado computadora producto debe diseñarse implementarse teniendo mente “comprobabilidad”. mismo tiempo, las prue-bas mismas deben mostrar conjunto características que logren meta encontrar mayor cantidad errores con mínimo esfuerzo. comprobabilidad. james bach proporciona siguiente definición comprobabilidad: “ comprobabilidad del software significa simplemente saber con cuánta facilidad puede probarse [ programa cómputo].” las siguientes características conducen software comprobable. operatividad. “mientras mejor funcione, más eficientemente puede probarse.” sistema diseña implementa teniendo como objetivo calidad, relativamente pocos errores blo- quearán ejecución las pruebas, que permitirá avanzar ellas sin interrupciones. observabilidad. “ que que prueba.” las entradas proporcionadas como parte las pruebas producen distintas salidas. los estados del sistema las variables son visibles consultables durante ejecución. salida incorrecta identifica con facilidad. los errores internos detectan reportan manera automática. código fuente accesible. controlabilidad. “mientras mejor pueda controlar software, más podrá automatizar opti- mizar las pruebas.” todas las salidas posibles pueden generarse través alguna combina-ción entradas, los formatos entrada/salida (/) son consistentes estructurados. todo código ejecutable través alguna combinación entradas. ingeniero prue-bas puede controlar directamente los estados del software, del hardware las variables. las pruebas pueden especificarse, automatizarse reproducirse convenientemente. descomponibilidad. “ controlar ámbito las pruebas, posible aislar más rápida- mente los problemas realizar pruebas nuevas más inteligentes.” sistema software construye partir módulos independientes que pueden probarse manera independiente. simplicidad. “mientras haya menos que probar, más rápidamente puede probar.” programa debe mostrar simplicidad funcional (por ejemplo, conjunto característico -nimo necesario para satisfacer los requerimientos); simplicidad estructural ( arquitectura modular para limitar propagación fallos) simplicidad código ( adopta estándar codificación para facilitar inspección mantenimiento). estabilidad. “mientras menos cambios, menos perturbaciones para probar.” los cambios software son raros, controlan cuando ocurren invalidan las pruebas existentes. soft-ware recupera bien los fallos. comprensibilidad. “mientras más información tenga, probará con más inteligencia.” diseño arquitectónico las dependencias entre componentes internos, externos compartidos son bien comprendidos. documentación técnica accesible instante, está bien organi-zada, específica, detallada precisa. los cambios diseño son comunicados los exami-nadores. pueden usarse los atributos sugeridos por bach para desarrollar una configuración software ( decir, programas, datos documentos) que sean fáciles probar. características prueba. ¿ qué hay acerca las pruebas ? kaner, falk nguyen [kan] sugieren los siguientes atributos una “buena” prueba: los párrafos que siguen usan con permiso james bach (copyright ) adaptaron material que originalmente apareció comentario grupo noticias comp.software-eng.cita: “todo programa hace algo bien, sólo que puede ser aquello que queremos que haga.” anónimo ¿cuáles son las características comprobabilidad?? cita: “los errores son más comunes, más dominantes más proble-máticos software que otras tecnologías.” david parnas (-).indd (-).indd // ::// :: prueba aplicaciones convencionales una buena prueba tiene una alta probabilidad encontrar error. para lograr esta meta, examinador debe comprender software intentar desarrollar una imagen mental cómo puede fallar. manera ideal, prueban las clases fallas. por ejemplo, una clase fallas potenciales una interfaz gráfica usuario falla para reconocer posición adecuada del ratón. diseña entonces conjunto pruebas para revisar ratón con intención demostrar error reconocimiento posición del ratón. una buena prueba redundante. tiempo los recursos prueba son limitados. trata realizar una prueba que tenga mismo propósito que otra. cada una debe tener propósito diferente (incluso sutilmente diferente). una buena prueba debe ser “ mejor camada” [kan]. grupo pruebas que tengan una intención similar, las limitaciones tiempo recursos pueden mitigar ejecu-ción sólo subconjunto dichas pruebas. tales casos, debe usarse prueba que tenga mayor probabilidad descubrir toda una clase errores. una buena prueba debe ser demasiado simple demasiado compleja. aunque ocasio- nes posible combinar una serie pruebas caso prueba, los efectos colaterales posibles asociados con este enfoque pueden enmascarar errores. general, cada prueba debe ejecutarse por separado.¿qué una “buena” prueba?? escena: cubículo vinod. participantes: vinod , miembros del equipo ingeniería software casasegura. conversación:vinod: así que éstos son los casos prueba que quieres aplicar para operación passwordvalidation. : , deben cubrir muchas las posibilidades para los tipos contraseñas que pueda ingresar usuario. vinod: veamos... observas que contraseña correcta será , ¿verdad? : ajá.vinod: ¿ especificas las contraseñas para probar error reconocimiento las contraseñas inválidas? : exacto, también pruebo las contraseñas que están cerca contraseña correcta, ver... .vinod: ésos están bien, pero veo mucho caso aplicar las entradas . son redundantes... prueban misma cosa, ¿ ? : bueno, son valores diferentes.vinod: cierto, pero descubre error... otras palabras... operación passwordvalidation detecta que una con-traseña inválida, probable que nos muestre algo nuevo. : veo que dices.vinod: intento ser quisquilloso... sólo que tenemos tiempo limitado para hacer las pruebas, así que buena idea aplicar prue-bas que tengan una alta probabilidad encontrar nuevos errores. : hay problema... pensaré esto poco más.casasegura diseño pruebas únicas . isiones interna externa las pruebas cualquier producto sometido ingeniería ( mayoría otras cosas) pueden probarse una dos formas: ) conocer función específica que asignó producto para realiza-ción, pueden llevarse cabo pruebas que demuestren que cada función completamente operativa mientras mismo tiempo buscan errores cada función, ) conocer funcio-namiento interno producto, pueden realizarse pruebas para garantizar que “todos los engranes embonan”; decir, que las operaciones internas realizan acuerdo con las espe-cificaciones que todos los componentes internos revisaron manera adecuada. primer cita: “sólo hay una regla diseño casos prueba: cubrir todas las características, mas hacer demasiados casos prueba.” tsuneo yamaura (-).indd (-).indd // ::// :: parte tres administración calidad enfoque pruebas considera una visión externa llama prueba caja negra. segundo requiere una visión interna denomina prueba caja blanca. prueba caja negra refiere las pruebas que llevan cabo interfaz del soft- ware. una prueba caja negra examina algunos aspectos fundamentales sistema con poca preocupación por estructura lógica interna del software. prueba caja blanca del software basa examen cercano los detalles procedimiento. las rutas lógicas través del software las colaboraciones entre componentes ponen prueba revisar con-juntos específicos condiciones / bucles. primera vista, parecería que las pruebas caja blanca muy extensas conducirían “pro- gramas por ciento correctos”. único que necesita definir todas las rutas lógicas, desarrollar casos prueba para revisarlas evaluar resultados, decir, generar casos prueba para revisar manera exhaustiva lógica del programa. por desgracia, las pruebas exhaustivas presentan ciertos problemas logísticos. hasta para programas pequeños, número posibles rutas lógicas puede ser muy grande. sin embargo, las pruebas caja blanca deben descartarse como imprácticas. puede seleccionarse revisarse número limitado rutas lógicas importantes. puede probarse validez las estructuras datos importantes. ocasiones, lugar pruebas caja negra caja blanca, usan, respectivamente, los términos prueba funcional prueba estructural.punto clave las pruebas caja blanca pueden diseñarse sólo después que existe diseño nivel componentes ( código fuente). debe disponerse los detalles lógicos del programa. considere programa líneas lenguaje . después alguna declaración básica datos, pro- grama contiene dos bucles anidados que ejecutan veces cada uno, dependiendo las condiciones especificadas entra-. dentro del bucle interior, requieren cuatro constructos -then-else. ¡existen aproximadamente rutas posibles que pueden ejecu- tarse este programa! para poner este número perspectiva, suponga que desarrolló procesador prueba mágico (“mágico” porque existe tal pro-cesador) para realizar pruebas exhaustivas. procesador puede desarrollar caso prueba, ejecutarlo evaluar los resultados milisegundo. trabajara horas día los días del año, procesador trabajaría durante años para probar programa. esto, sin duda alguna, causaría estragos mayoría los calen-darios desarrollo. por tanto, razonable afirmar que prueba exhaustiva impo- sible para sistemas software grandes.información pruebas exhaustivas . rueba caja blanca prueba caja blanca, ocasiones llamada prueba caja vidrio, una filosofía diseño casos prueba que usa estructura control descrita como parte del diseño nivel componentes para derivar casos prueba. usar los métodos prueba caja blanca, puede derivar casos prueba que: ) garanticen que todas las rutas independientes dentro módulo revisaron menos una vez, ) revisen todas las decisiones lógicas sus lados ver-dadero falso, ) ejecuten todos los bucles sus fronteras dentro sus fronteras operativas ) revisen estructuras datos internas para garantizar validez. . rueba ruta básica prueba ruta trayectoria básica una técnica prueba caja blanca propuesta por primera vez por tom mccabe [mcc]. método ruta básica permite diseñador casos prueba derivar una medida complejidad lógica diseño procedimiento usar esta cita: “los errores esconden las esquinas congregan las fronteras.” boris beizer (-).indd (-).indd // ::// :: prueba aplicaciones convencionales medida como guía para definir conjunto básico rutas ejecución. los casos prueba derivados para revisar conjunto básico tienen garantía para ejecutar todo enunciado programa, menos una vez durante prueba. .. notación gráfico grafo flujo antes considerar método ruta básica, debe introducirse una notación simple para representación del flujo control, llamado gráfico flujo ( gráfico programa ). gráfico flujo muestra flujo control lógico que usa notación ilustrada figura .. cada cons-tructo estructurado (capítulo ) tiene correspondiente símbolo gráfico flujo. para ilustrar uso gráfico flujo, considere representación del diseño procedi- miento figura .). aquí usó diagrama flujo para mostrar estructura control del programa. figura .) mapea diagrama flujo gráfico flujo correspondiente (suponiendo que diagrama flujo contiene condiciones compuestas los diamantes decisión). con referencia figura . ), cada círculo, llamado nodo gráfico flujo, repre- senta uno más enunciados procedimiento. una secuencia cajas proceso dia-mante decisión pueden mapearse solo nodo. las flechas gráfico flujo, llamadas aristas enlaces, representan flujo control son análogas las flechas diagrama flujo. una arista debe terminar nodo, incluso nodo representa algún enunciado pro- actualidad, método ruta básica puede realizarse sin uso gráficos flujo. obstante, sirven como una notación útil para comprender flujo control ilustrar enfoque. mientraslos constructos estructurados gráﬁco ﬂujo forman: donde cada círculo representa una más pdl ramiﬁcadas enunciados código fuentehastacaso secuenciafigura . notación gráfico flujo ) ) , , oaristafigura . ) diagrama flujo ) gráfico flujoun gráfico flujo debe dibujarse sólo cuando estructura lógica componente compleja. gráfico flujo permite rastrear rutas programa con más facilidad.consejo (-).indd (-).indd // ::// :: parte tres administración calidad cedimiento (por ejemplo, vea símbolo gráfico flujo para constructo -then-else). las áreas acotadas por aristas nodos llaman regiones. cuando cuentan las regiones, área afuera del gráfico incluye como región. cuando diseño procedimiento encuentran condiciones compuestas, genera- ción gráfico flujo vuelve ligeramente más complicada. una condición compuesta ocurre cuando uno más operadores booleanos (, and, nand, nor lógicos) presenta enunciado condicional. figura ., segmento lenguaje diseño programa (pdl, por sus siglas inglés) traduce gráfico flujo mostrado. observe que crea nodo separado para cada una las condiciones enunciado . cada nodo que contiene una condición llama nodo predicado caracteriza por dos más aristas que emanan . .. rutas programa independientes una ruta independiente cualquiera que introduce menos nuevo conjunto enunciados procesamiento una nueva condición programa. cuando establece como gráfi- flujo, una ruta independiente debe moverse largo menos una arista que haya recorrido antes definir ruta. por ejemplo, conjunto rutas independientes para gráfico flujo que ilustra figura . ) ruta : - ruta : ------- : -------- : -------- observe que cada nueva ruta introduce una nueva arista. ruta-------------- considera como independiente porque simplemente una combinación rutas - pecificadas recorre alguna arista nueva. las rutas constituyen conjunto básico para gráfico flujo figura .). decir, pueden diseñar pruebas para forzar ejecución estas rutas ( con-junto básico), todo enunciado programa tendrá garantizada ejecución menos una vez, cada condición ejecutará sus lados verdadero falso. debe señalarse que con- sección .. presenta análisis más detallado los gráficos sus usos.nodo predicado . .. entonces procede también procede endifyba xfigura . lógica compuesta (-).indd (-).indd // ::// :: prueba aplicaciones convencionales junto básico único. hecho, para diseño procedimiento dado, pueden derivarse algunos conjuntos básicos diferentes. ¿cómo saber cuántas rutas buscar? cálculo complejidad ciclomática proporciona respuesta. complejidad ciclomática una medición software que proporciona una evalua-ción cuantitativa complejidad lógica programa. cuando usa contexto del método prueba ruta básica, valor calculado por complejidad ciclomática define número rutas independientes del conjunto básico programa brinda una cota supe-rior para número pruebas que debe realizar fin asegurar que todos los enunciados ejecutaron menos una vez. complejidad ciclomática tiene fundamentos teoría gráficos proporciona una medición software extremadamente útil. complejidad calcula una tres formas: . número regiones del gráfico flujo corresponde complejidad ciclomática. . complejidad ciclomática () para gráfico flujo define como () / / / donde número aristas del gráfico flujo número nodos del gráfico flujo. . complejidad ciclomática () para gráfico flujo también define como () / / donde número nodos predicado contenidos gráfico flujo . gráfico flujo figura . ), complejidad ciclomática puede calcularse usando cada uno los algoritmos recién indicados: . gráfico flujo tiene cuatro regiones. . () / aristas / nodos / / . . () / nodos predicado / / . por tanto, complejidad ciclomática del gráfico flujo figura . ) . más importante , valor para () proporciona una cota superior para número rutas independientes que forman conjunto básico , por implicación, una cota superior sobre número pruebas que deben diseñarse ejecutarse para garantizar cobertura todos los enunciados del programa. complejidad ciclomática una medición útil para predecir aquellos módulos proclives error. úsela para planificar las pruebas así como para diseño casos prueba.consejo ¿cómo calcula complejidad ciclomática?? punto clave complejidad ciclomática proporciona cota superior sobre número casos prueba que requerirán para garantizar que cada enunciado programa ejecuta menos una vez. escena: cubículo shakira. participantes: vinod shakira, miembros del equipo ingeniería del software casasegura, quienes trabajan planificación las pruebas para función seguridad. conversación:shakira: mira... que debemos hacer pruebas unidad todos los componentes para función seguridad, pero hay muchos ellos, consideras número operaciones que tie-nen que revisar, ... tal vez deberíamos olvidar prueba caja blanca, integrar todo comenzar aplicar las pruebas caja negra.vinod: ¿supones que tenemos tiempo suficiente para hacer pruebas componentes, revisar las operaciones luego integrar? shakira: fecha límite para primer incremento está más cerca que quisiera... , estoy preocupada. vinod: ¿por qué menos aplicas pruebas caja blanca sobre las operaciones que tienen probabilidad ser más proclives erro-res? shakira (exasperada): ¿ exactamente cómo cuáles son las más proclives errores? vinod: .casasegura uso complejidad ciclomática (-).indd (-).indd // ::// :: parte tres administración calidad .. derivación casos prueba método prueba ruta básica puede aplicarse diseño procedimientos código fuente. esta sección presenta prueba ruta básica como una serie pasos. proce-dimiento average (promedio), que figura . muestra pdl, usará como ejemplo para ilustrar cada paso del método diseño caso prueba. observe que average, aunque algoritmo extremadamente simple, contiene condiciones bucles compuestos. posible aplicar los siguientes pasos para derivar conjunto básico: . usar diseño código como cimiento, dibuje gráfico flujo corres-pondiente. gráfico flujo crea usando los símbolos reglas construcción que presentaron sección ... pdl para aver age figura ., gráfico flujo crea numerar aquellos enunciados pdl que mapearán los nodos correspondientes del gráfico flujo. figura . muestra gráfico deflujo correspondiente. . determine complejidad ciclomática del gráfico flujo resultante. com- plejidad ciclomática () determina aplicar los algoritmos descritos sección ... debe observarse que () puede determinarse sin desarrollar gráfico flujo, shakira: ¿qué? vinod: complejidad ciclomática, . sólo calcula () para cada una las operaciones dentro cada uno los componen-tes cuáles tienen los valores más altos para (). ésas son las que tienen más probabilidad ser proclives errores. shakira: ¿ cómo calculo ?vinod: realmente sencillo. aquí hay libro que describe cómo hacerlo.shakira (hojea libro): muy bien, parece difícil. inten- taré. las operaciones con () más altas serán las candidatas para las pruebas caja blanca. vinod: sólo recuerda que hay garantías. componente con una () baja puede ser proclive errores. shakira: bien. pero menos esto ayudará reducir núme- componentes que tienen que experimentar pruebas caja blanca. cita: “ cohete ariane estalló despegue debido exclusivamen- defecto software ( bug, error) que involucra conversión valor punto flotante bits entero bits. cohete sus cua-tro satélites estaban asegurados valían millo-nes dólares. [pruebas ruta que revisaran ruta conver-sión] habrían descubierto error, pero vetaron por razo-nes presupuestarias.” reporte noticioso procedimiento average; interface returns average, total.input, total.valid; interface accepts value, minimum, maximum; type value[:] scalar array; type average, total.input, total.valid; minimum, maximum, sum scalar;type integer;* este procedimiento calcula promedio menos números que encuentran entre valores frontera; también calcula suma número total válido. = ; total.input = total.valid = ;sum = ; while value[] < – and total.input < enddo total.valid endif end averageincrement total.input ; value[] = minimum and value[] < = maximum endif increment ; then average = sum / total.valid; else average = –;then increment total.valid ; sum = sum + value[]else skip . pdl con identificación nodos (-).indd (-).indd // ::// :: prueba aplicaciones convencionales contar todos los enunciados condicionales pdl (para procedimiento average, las condiciones compuestas son dos) sumar . figura ., () / regiones () / aristas / nodos / / () / nodos predicado / / . determine conjunto básico rutas linealmente independientes. valor () proporciona cota superior sobre número rutas linealmente independien-tes través estructura control del programa. caso del procedimiento ave- , espera especificar seis rutas: ruta : ---- ruta : ---- : ----- : --------...ruta : ---------...ruta : ----------... elipsis (...) después las rutas , indica que aceptable cualquier ruta tra- vés del resto estructura control. con frecuencia, vale pena identificar nodos predicado como auxiliar para derivación los casos prueba. este caso, los nodos , , , son nodos predicado. . prepare casos prueba que fuercen ejecución cada ruta conjunto básico. los datos deben elegirse modo que las condiciones los nodos predicado establezcan manera adecuada conforme prueba cada ruta. cada caso prueba ejecuta compara con los resultados esperados. una vez completados todos los casos prueba, examinador puede estar seguro que todos los enunciados del programa ejecutaron menos una vez. importante notar que algunas rutas independientes (tomemos por caso ruta del ejem- plo) pueden probarse forma individual, decir , combinación datos requerida para recorrer ruta puede lograrse flujo normal del programa. tales casos, dichas rutas prueban como parte otra prueba ruta. . gráfico flujo para procedimiento average (-).indd (-).indd // ::// :: parte tres administración calidad .. matrices grafo procedimiento para derivar gráfico flujo incluso determinar conjunto rutas - sicas sensible mecanización. una estructura datos, llamada matriz grafo, puede ser bastante útil para desarrollar una herramienta software que auxilie prueba ruta básica. una matriz grafo una matriz cuadrada cuyo tamaño ( decir, número filas colum- nas) igual número nodos del gráfico flujo. cada fila columna corresponde nodo identificado las entradas matriz corresponden conexiones (una arista) entre nodos. figura . muestra ejemplo simple gráfico flujo correspondiente matriz grafo [bei]. esa figura, cada nodo gráfico flujo identifica mediante números, mientras que cada arista identifica con letras. una entrada letra matriz corresponde una conexión entre dos nodos. por ejemplo, nodo conecta con nodo mediante arista . este punto, matriz grafo más que una representación tabular gráfico flujo. sin embargo, agregar enlace ponderado cada entrada matriz, matriz grafo puede convertirse una poderosa herramienta para evaluar durante las pruebas estructura control del programa. enlace ponderado proporciona información adicional acerca del flujo control. forma más simple, enlace ponderado (existe una conexión) ( existe conexión). pero los enlaces ponderados puede asignárseles otras propiedades más -teresantes: • probabilidad que enlace (arista) ejecutará. • tiempo procesamiento que emplea durante recorrido enlace. • memoria requerida durante recorrido enlace. • los recursos requeridos durante recorrido una prueba. beizer [bei] proporciona tratamiento fondo algoritmos matemáticos adicionales que pueden aplicarse las matrices gráficas. con estas técnicas, análisis requerido para dise-ñar casos prueba puede ser parcial completamente automatizado. . rueba estructura control técnica prueba ruta básica descrita sección . una varias técnicas para probar estructura control. aunque prueba ruta básica simple enormemente efec-tiva, suficiente misma. esta sección estudian otras variaciones acerca prueba estructura control. esta prueba más amplia cubre mejora calidad prueba caja blanca. cde gráﬁco ﬂujo gcfdbconecta nodo nodo matriz grafofigura . matriz grafo ¿qué una matriz grafo cómo extiende para uso las pruebas?? (-).indd (-).indd // ::// :: prueba aplicaciones convencionales .. prueba condición prueba condición [tai] método diseño casos prueba que revisa las condi- ciones lógicas contenidas módulo programa. una condición simple una variable booleana una expresión relacional, posiblemente precedida operador not (¬). una expresión relacional toma forma <operador relacional donde son expresiones aritméticas <operador relacional uno los siguientes: /, /, /, / ( igualdad), / /. una condición compuesta integra con dos más condiciones simples, operadores booleanos paréntesis. supone que los operadores booleanos permiti-dos una condición compuesta incluyen (/ ), and (&) not (¬). una condición sin expre- siones relacionales conoce como expresión booleana. una condición incorrecta, entonces menos componente condición - correcto. por tanto, los tipos errores una condición incluyen errores operador booleano (operadores booleanos incorrectos/perdidos/adicionales), variable booleana, paréntesis booleanos, operador relacional expresión aritmética. método prueba condición enfoca prueba cada condición del programa para asegurar que contiene errores. .. prueba flujo datos método prueba flujo datos [fra] selecciona rutas prueba programa acuerdo con las ubicaciones las definiciones con uso variables programa. para ilustrar enfoque prueba flujo datos, suponga que cada enunciado programa asigna número enunciado único que cada función modifica sus parámetros variables globales. para enunciado con como número enunciado, def() / { | enunciado contiene una definición } use() / { | enunciado contiene uso } enunciado enunciado loop, conjunto def vacío conjunto use basa condición del enunciado . dice que definición variable enunciado está viva enunciado / existe una ruta desde enunciado hasta enunciado / que contiene otra definición . una cadena definición uso () variable forma [, , /], donde / son números enunciado, está def() use(/), definición enunciado está viva enunciado /. una estrategia prueba flujo datos simple requerir que toda cadena cubra menos una vez. esta estrategia conoce como estrategia prueba . demostrado que prueba garantiza cobertura todas las ramas programa. sin embargo, prueba garantiza cobertura una rama sólo raras situaciones, como los constructos -then-else los cuales parte then tiene definición alguna variable parte else existe. esta situación, rama else del enunciado necesariamente cubre con prueba . .. prueba bucle los bucles son piedra toque gran mayoría todos los algoritmos implementados software. aún así, con frecuencia les pone poca atención mientras realizan las pruebas software. prueba bucle una técnica prueba caja blanca que enfoca exclusivamente validez los constructos bucle. pueden definirse cuatro clases diferentes bucles [bei]: simples, concatenados, anidados estructurados (figura .).cita: “poner más atención aplica- ción las pruebas que diseño error clásico.” brian marick punto clave los errores son mucho más comunes cercanía las condiciones lógicas que lugar los enunciados procesamiento secuencial. cita: “los buenos examinadores son maestros para notar ‘algo diver-tido’ actuar sobre ello.” brian marick irreal suponer que prueba flujo datos usará manera extensa cuando prueba sistema grande. sin embargo, puede usarse forma dirigida para áreas software que sean sospechosas.consejo (-).indd (-).indd // ::// :: parte tres administración calidad bucles simples. siguiente conjunto pruebas puede aplicarse los bucles simples, donde máximo número pasadas permisibles través del bucle. . saltar por completo bucle. . sólo una pasada través del bucle. . dos pasadas través del bucle. . pasadas través del bucle , donde / . . / , , / pasadas través del bucle. bucles anidados. tuviera que extender enfoque prueba para bucles simples los bucles anidados, número pruebas posibles crecería geométricamente conforme nivel anidado aumenta. esto daría como resultado número impráctico pruebas. beizer [bei] sugiere acercamiento que ayudará reducir número pruebas: . comience con bucle más interno. establezca todos los otros bucles valores míni-mos. . realice pruebas bucle simple para bucle más interno mientras mantiene los bucles exteriores sus valores mínimos parámetro iteración (por ejemplo, contador bucle). agregue otras pruebas para valores fuera--rango excluidos. . trabaje hacia afuera realice pruebas para siguiente bucle, pero mantenga los otros bucles exteriores valores mínimos los otros bucles anidados valores “típicos”. . continúe hasta que todos los bucles hayan probado. bucles concatenados. los bucles concatenados pueden probarse usando enfoque defi- nido para bucles simples cada uno los bucles independiente los otros. obstante , dos bucles concatenan usa contador bucle para bucle como valor inicial para bucle , entonces los bucles son independientes. cuando los bucles son independientes, recomienda enfoque aplicado bucles anidados. bucles estructurados. siempre que sea posible, esta clase bucles debe rediseñarse para reflejar uso los constructos programación estructurada (capítulo ).bucles simplesbucles anidados bucles concatenados bucles estructuradosfigura . clases bucles posible probar los bucles estructurados manera efectiva. deben refactorizar.consejo (-).indd (-).indd // ::// :: prueba aplicaciones convencionales . ruebas caja negra las pruebas caja negra, también llamadas pruebas comportamiento, enfocan los - querimientos funcionales del software; decir, las técnicas prueba caja negra permiten derivar conjuntos condiciones entrada que revisarán por completo todos los requerimien-tos funcionales para programa. las pruebas caja negra son una alternativa para las técnicas caja blanca. vez ello, enfoque complementario que probable que descubra una clase errores diferente que los métodos caja blanca. las pruebas caja negra intentan encontrar errores las categorías siguientes: ) funcio- nes incorrectas faltantes, ) errores interfaz, ) errores las estructuras datos acceso bases datos externas, ) errores comportamiento rendimiento ) errores inicialización terminación. diferencia las pruebas caja blanca, que realizan tempranamente proceso pruebas, prueba caja negra tiende aplicarse durante las últimas etapas prueba (vea capítulo ). puesto que, propósito, prueba caja negra considera estructura control, atención enfoca dominio información. las pruebas diseñan para responder las siguientes preguntas: • ¿cómo prueba validez funcional? • ¿cómo prueban comportamiento rendimiento del sistema? • ¿qué clases entrada harán buenos casos prueba? • ¿ sistema particularmente sensible ciertos valores entrada? • ¿cómo aíslan las fronteras una clase datos? • ¿qué tasas volumen datos puede tolerar sistema? • ¿qué efecto tendrán sobre operación del sistema algunas combinaciones específicas datos? aplicar las técnicas caja negra, deriva conjunto casos prueba que satisfacen los siguientes criterios [mye]: ) casos prueba que reducen, por una cuenta que mayor que uno, número casos prueba adicionales que deben diseñarse para lograr pruebas razonables ) casos prueba que dicen algo acerca presencia ausencia clases errores, lugar error asociado solamente con prueba específica mano. .. métodos prueba basados gráficos primer paso prueba caja negra entender los objetos que modelan software las relaciones que conectan dichos objetos. una vez logrado esto, siguiente paso definir una serie pruebas que verifiquen “que todos los objetos tengan relación mutua esperada” [bei]. dicho otra forma, prueba software comienza con creación gráfico objetos importantes sus relaciones, luego diseña una serie pruebas que cubrirán gráfico, modo que cada objeto relación revise descubran errores. para lograr estos pasos, comience por crear gráfico: una colección nodos que represen- ten objetos, enlaces que representen las relaciones entre objetos, nodos ponderados que descri- ban las propiedades nodo (por ejemplo, valor datos comportamiento estado específicos) enlaces ponderados que describan alguna característica enlace. figura .) muestra representación simbólica gráfico. los nodos repre- sentan como círculos conectados mediante ligas que tienen algunas formas diferentes. -cita: “errar humano, pero encon- trar error divino.” robert dunn ¿qué preguntas responden las pruebas caja negra?? punto clave una gráfica representa las relaciones entre objetos datos objetos programa, que permite derivar casos prueba que buscan errores asociados con dichas relaciones. este contexto, debe considerar término objetos contexto más amplio posible. abarca objetos datos, componentes tradicionales (módulos) elementos orientados objeto del software cómputo. (-).indd (-).indd // ::// :: parte tres administración calidad lace dirigido (representado mediante una flecha) indica que una relación sólo mueve una dirección. enlace bidireccional, también llamado enlace simétrico , implica que relación aplica ambas direcciones. los enlaces paralelos usan cuando entre los nodos gráficos establecen algunas relaciones diferentes. como ejemplo simple, considere una porción gráfico para una aplicación proce- sador palabras (figura .) donde objeto # / newfile (selección menú) objeto # / documentwindowobjeto # / documenttext figura, una selección menú newfile genera una ventana documento. nodo ponderado documentwindow proporciona una lista los atributos ventana que esperan cuando genere ventana. enlace ponderado indica que ventana debe generar- menos . segundo. enlace dirigido establece una relación simétrica entre selección menú newfile documenttext, los enlaces paralelos indican relaciones entre documentwindow documenttext. realidad, tendría que generarse gráfico más detallado como precursor para diseño casos prueba. entonces podrían derivarse casos prueba recorrer gráfico cubrir cada una las relaciones mostradas. dichos casos prueba designan con intención encontrar errores alguna las relaciones. beizer [bei] describe algunos métodos prueba comportamiento que pueden usar gráficos: modelado flujo transacción. los nodos representan pasos alguna transacción (por ejemplo, los pasos requeridos para hacer una reservación una aerolínea con uso servicio línea) los enlaces representan conexión lógica entre los pasos (por ejemplo, ingresarinformaciónvuelo sigue validaciónprocesamientodisponibilidad). diagrama flujo datos (capítulo ) puede usarse para auxiliar creación gráfi-cos este tipo. modelado estado finito. los nodos representan diferentes estados del software - servables por usuario (por ejemplo, cada una las “pantallas” que aparecen cuando nuevo archivo selección menúgenera selección menúventana documento texto documentose representa como contiene )objeto # dirigidaobjeto # objeto # dirigida ligas paralelasnodo ponderado (valor) ) permite edición (liga ponderada) (tiempo generación < . ) atributos: dimensión inicio: establecimiento preferencias por defectocolor fondo: blancocolor texto: color preferencias por defectofigura . ) notación gráfico; ) ejemplo simple (-).indd (-).indd // ::// :: prueba aplicaciones convencionales empleado ingresa información conforme toma una orden telefónica) los enlaces repre- sentan las transiciones que ocurren para moverse estado estado (por ejemplo, pedi- doinformación verifica durante inventariobusquedadisponibilidad, seguido entrada clientefacturainformación). diagrama estado (capítulo ) puede usarse para auxiliar creación gráficos este tipo. modelado flujo datos. los nodos son objetos datos los enlaces son las transfor- maciones que ocurren para traducir objeto datos otro. por ejemplo, nodo retención impuesto fica (ftw) calcula partir los ingresos brutos (), usando relación ftw / . / . modelado temporización. los nodos son objetos programa los enlaces son las - nexiones secuenciales entre dichos objetos. los enlaces ponderados usan para espe-cificar los tiempos ejecución requeridos conforme ejecuta programa. análisis detallado cada uno estos métodos prueba basados gráfico está más allá del ámbito este libro. tiene mayor interés, consulte [bei] para conocer una cober- tura más amplia. .. partición equivalencia partición equivalencia método prueba caja negra que divide dominio - trada programa clases datos los que pueden derivarse casos prueba. caso prueba ideal descubre primera mano una clase errores (por ejemplo, procesamiento incorrecto todos los datos carácter) que otro modo podrían requerir ejecución -chos casos prueba antes observar error general. diseño casos prueba para partición equivalencia basa una evaluación las clases equivalencia para una condición entrada. con los conceptos introducidos sección precedente, conjunto objetos puede vincularse mediante relaciones que son simétricas, transitivas reflexivas, presenta una clase equivalencia [bei]. una clase equivalencia representa conjunto estados válidos inválidos para condiciones entrada. por general, una condición entrada valor numérico específico, rango valores, conjunto valores relacionados una condición booleana. las clases equivalencia pue-den definirse acuerdo con los siguientes lineamientos: . una condición entrada especifica rango, define una clase equivalencia válida dos válidas. . una condición entrada requiere valor específico, define una clase equiva- lencia válida dos válidas. . una condición entrada especifica miembro conjunto, define una clase equivalencia válida una válida. . una condición entrada booleana, define una clase válida una inválida. aplicar los lineamientos para derivación clases equivalencia, pueden desarrollarse ejecutarse los casos prueba para cada ítem datos del dominio entrada. los casos prueba seleccionan modo que revise vez número más grande atributos una clase equivalencia. .. análisis valor frontera mayor número errores ocurre las fronteras del dominio entrada “centro”. por esta razón que análisis valor frontera (bva, del inglés boundary value analysis) desarrolló como una técnica prueba. análisis valor frontera conduce una selección casos prueba que revisan los valores frontera.las clases entrada conocen relativamente pronto proceso del software. por esta razón, debe pensar acerca partición equivalencia conforme crea diseño.consejo ¿cómo definen las clases equivalencia para pruebas?? cita: “una forma efectiva para pro-bar código revisarlo sus fronteras naturales.” brian kernighan (-).indd (-).indd // ::// :: parte tres administración calidad análisis valor frontera una técnica diseño casos prueba que complemen- tan partición equivalencia. lugar seleccionar algún elemento una clase equi- valencia, bva conduce selección casos prueba los “bordes” clase. lugar enfocarse exclusivamente las condiciones entrada, bva también deriva casos prueba partir del dominio salida [mye]. los lineamientos para bva son similares muchos aspectos los proporcionados para partición equivalencia: . una condición entrada especifica rango acotado por valores , los casos prueba deben designarse con valores , justo arriba justo abajo . . una condición entrada especifica número valores, deben desarrollarse casos prueba que revisen los números mínimo máximo. ambién prueban los valores justo arriba abajo, mínimo máximo. . aplicar lineamientos condiciones salida. por ejemplo, suponga que como - lida programa análisis ingeniería requiere una tabla temperatura con-tra presión. deben diseñarse casos prueba para crear reporte salida que pro- duzca número máximo ( mínimo) permisible entradas tabla. . las estructuras datos programa internos tienen fronteras prescritas (por ejem- plo, una tabla que tenga límite definido entradas), asegúrese diseñar caso prueba para revisar estructura datos frontera. mayoría los ingenieros software realizan intuitivamente cierta medida. aplicar dichos lineamientos, prueba fronteras será más completa , por tanto, tendrá una mayor probabilidad detectar errores. .. prueba arreglo ortogonal existen muchas aplicaciones las cuales dominio entrada relativamente limitado, decir, número parámetros entrada pequeño los valores que cada uno los pará-metros puede tomar están claramente acotados. cuando dichos números son muy pequeños (por ejemplo, tres parámetros entrada que toman tres valores discretos cada uno), posible considerar cada permutación entrada probar manera exhaustiva dominio entrada. sin embargo, conforme crece número valores entrada número valores discretos para cada ítem datos, prueba exhaustiva vuelve impráctica imposible. prueba arreglo ortogonal puede aplicarse problemas los que dominio entrada relativamente pequeño pero demasiado grande para alojar prueba exhaustiva. método prueba arreglo ortogonal particularmente útil para encontrar los fallos región, una categoría error asociada con lógica defectuosa dentro componente software. para ilustrar diferencia entre prueba arreglo ortogonal enfoques más convencionales del tipo “ ítem entrada vez”, piense sistema que tiene tres ítems entrada, , . cada uno tiene tres valores discretos asociados consigo. existen = posibles casos prueba. phadke [pha] sugiere una visión geométrica los posibles casos prueba asocia-dos con , , que ilustra figura .. figura, ítem entrada vez puede variar secuencia largo cada eje entrada. esto como resultado cobertura relati-vamente limitada del dominio entrada (representado por cubo izquierda -gura). cuando ocurre prueba arreglo ortogonal, crea arreglo ortogonal casos prueba. arreglo ortogonal tiene una “propiedad equilibrio” [pha]. decir, los casos prueba (representados con puntos oscuros figura) “dispersan manera uniforme largo todo dominio prueba”, como ilustra cubo derecha figura .. cobertura prueba través del dominio entrada más completa.punto clave bva extiende partición equivalencia enfocarse datos los “bordes” una clase equivalencia. punto clave prueba arreglo ortogonal permite diseñar casos prueba que proporcionan cobertura máxima prueba con número razonable casos prueba. (-).indd (-).indd // ::// :: prueba aplicaciones convencionales para ilustrar uso del arreglo ortogonal , considere función send para una aplicación fax. función send pasan cuatro parámetros: , , . cada uno toma tres valores discretos. por ejemplo, toma los valores: / , enviar ahora / , enviar una hora más tardep / , enviar después medianoche , también tomarían los valores , , que significan otras funciones envío. eligiera estrategia prueba “ ítem entrada vez”, siguiente secuencia pruebas (, , , ) especificaría: (, , , ), (, , , ), (, , , ), (, , , ), (, , , ), (, , , ), (, , , ), (, , , ) (, , , ). phadke [pha] valora estos casos prueba afirmar: tales casos prueba son útiles sólo cuando uno está seguro que estos parámetros prueba interactúan. pueden detectar fallas lógicas donde solo valor parámetro genere mal funciona-miento del software. estas fallas llaman fallos modo individual. este método puede detectar fallos lógicos que causen mal funcionamiento cuando dos más parámetros toman simultáneamente ciertos valores; decir, pueden detectar todas las interacciones. por tanto, habilidad para -tectar fallas limitada. dado número relativamente pequeño los parámetros entrada los valores discre- tos, posible prueba exhaustiva. número pruebas requeridas = , grande pero manejable. encontrarían todos los fallos asociados con permutación ítems datos, pero esfuerzo requerido relativamente elevado. enfoque prueba arreglo ortogonal permite proporcionar una buena cobertura pruebas con muchos menos casos prueba que estrategia exhaustiva. figura . ilustra arreglo ortogonal para función send fax. phadke [pha] valora resultado las pruebas usando arreglo ortogonal - guiente forma: detectar aislar todos los fallos modo individual. fallo modo individual problema congruente con cualquier nivel cualquier parámetro individual. por ejemplo, todos los casos prueba del factor = causan una condición error, trata una falla modo individual. este ejemplo, las pruebas , [figura .] mostrarán errores. analizar información acerca qué pruebas muestran errores, uno puede identificar cuáles valores parámetro causan fallo. este ejemplo, notar que las pruebas , causan error, uno puede aislar [procesamiento lógico asociado con “enviar ahora” ( = )] fuente del error. tal aislamiento del fallo importante para corregirlo. detectar todos los fallos modo doble. existe problema consistente cuando ocurren conjunto niveles específicos dos parámetros, llama fallo modo doble . hecho, fallo ítem entrada vez arreglo ortogonal . visión geométrica casos pruebafuente: [pha] (-).indd (-).indd // ::// :: parte tres administración calidad modo doble indicio incompatibilidad pareada interacciones dañinas entre dos paráme- tros prueba. fallos multimodo. los arreglos ortogonales [del tipo mostrado] sólo pueden garantizar detec- ción fallos modo individual doble. obstante, muchos fallos multimodo también son -tectables por estas pruebas. [pha] puede encontrar análisis detallado prueba arreglo ortogonal.caso pruebaparámetros prueba . arreglo ortogonal las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas que existen esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores.objetivo: auxiliar equipo software desarrollo conjunto completo casos prueba tanto para prueba caja negra como caja blanca. mecánica: estas herramientas clasifican dos categorías amplias: las herramientas prueba estáticas las herramientas prueba dinámicas. industria utilizan tres diferentes tipos herramientas prueba estáticas: herramientas prueba basadas código, lenguajes prueba especializados herramientas prueba basadas requerimientos. las primeras aceptan código fuente como entrada realizan algunos análisis que dan como resul-tado generación casos prueba. los lenguajes prueba especializados (por ejemplo, atlas) permiten ingeniero soft-ware escribir especificaciones prueba detalladas que describen cada caso prueba logística para ejecución. las herramien-tas prueba basadas requerimientos aíslan requerimientos usuario específicos sugieren casos prueba ( clases pruebas) que revisarán los requerimientos. las herramientas prueba dinámi-cas interactúan con programa ejecución, comprueban cober-tura ruta, prueban las afirmaciones acerca del valor variables específicas instrumentan flujo ejecución del programa.herramientas representativas: mccabetest, desarrollada por mccabe & associates (www. mccabe.com), implementa una variedad técnicas prueba trayectoria derivadas una valoración complejidad ciclo-mática otras mediciones software. testworks, desarrollada por software research, inc. ( com/products), conjunto completo herramientas prueba automatizadas que auxilia diseño casos prue- para software desarrollado /++ java, que proporcio- apoyo para pruebas regresión. -vec test generation system, desarrollada por -vec technologies ( conjunto herramientas que sopor-tan pruebas unidad, integración validación asistir diseño casos prueba, usando información contenida una especificación requerimientos . -test suite, desarrollada por empirix, inc. ( abarca conjunto completo herramientas para probar webapps, incluidas herramientas que auxilian diseño casos prueba planificación pruebas.herramientas software diseño casos prueba (-).indd (-).indd // ::// :: prueba aplicaciones convencionales . rueba basada modelo prueba basada modelo (pbm) una técnica prueba caja negra que usa informa- ción contenida modelo requerimientos como base para generación casos prueba. muchos casos, técnica prueba basada modelo usa diagramas estado uml, elemento del modelo comportamiento (capítulo ), como base para diseño los casos prueba. técnica pbm requiere cinco pasos: . analizar modelo comportamiento existente par software crear uno. recuerde que modelo comportamiento indica cómo responderá software los eventos estímulos externos. para crear modelo, debe realizar los pasos expues-tos capítulo : ) evaluar todos los casos uso para comprender por completo secuencia interacción dentro del sistema, ) identificar los eventos que impul-sen secuencia interacción entender cómo dichos eventos relacionan con objetos específicos, ) crear una secuencia para cada caso uso, ) construir diagrama estado uml para sistema (por ejemplo, véase figura .), ) revisar modelo comportamiento para verificar precisión congruencia. . recorr modelo comportamiento especificar las entradas que forza- rán software realizar transición estado estado. las entradas dispara- rán eventos que harán que ocurra transición. . visar modelo comportamiento observar las salidas esperadas, conforme software realiza transición estado estado. recuerde que cada transición estado dispara mediante evento que, como consecuencia transición, invoca alguna función crean salidas. para cada conjunto entra-das (casos prueba) especificado paso , las salidas esperadas especifican como caracterizan modelo comportamiento. “una suposición fundamental esta prueba que existe cierto mecanismo, oráculo prueba, que determinará los resultados una prueba ejecución son correctos” [dac]. esencia, oráculo prueba establece base para cualquier determinación correcto salida. mayoría los casos, oráculo modelo requerimientos, pero también podría ser otro documento aplicación, datos registrados cualquier otro lado , incluso, experto humano. . ejecutar los casos prueba. las pruebas pueden ejecutarse manualmente crearse ejecutarse guión prueba usando una herramienta prueba. . compar los resultados reales esperados adoptar una acción correctiva según requiera. pbm ayuda descubrir errores comportamiento del software , como consecuencia, extremadamente útil cuando prueban aplicaciones impulsadas por evento. . rueba para entornos , arquitecturas aplicaciones especializados ocasiones, los lineamientos enfoques únicos para pruebas garantizan cuando consi- deran entornos, arquitecturas aplicaciones especializados. aunque las técnicas prueba estudiadas anteriormente este capítulo, los capítulos , con frecuencia pueden prueba basada modelo también puede usarse cuando los requerimientos del software representan con tablas decisión, gramáticas cadenas markov [dac].cita: “ suficientemente difícil encontrar error código cuando busca; pero todavía más difícil cuando supone que código está libre errores.” steve mcconnell (-).indd (-).indd // ::// :: parte tres administración calidad adaptarse situaciones especializadas, vale pena considerar individualmente sus necesida- des únicas. .. pruebas interfaces gráficas usuario las interfaces gráficas para usuario (gui, por sus siglas inglés) presentan interesantes -tos prueba. puesto que los componentes reutilizables ahora son parte común los entornos desarrollo gui, creación interfaz para usuario vuelto menos consumidora tiempo más precisa (capítulo ). pero, mismo tiempo, complejidad las gui crecido, que conduce más dificultad diseño ejecución los casos prueba. debido que muchas gui modernas tienen misma apariencia ambiente, puede derivarse una serie pruebas estándar. posible usar las gráficas modelado estado finito para derivar una serie pruebas que aborden objetos datos programa específicos que sean relevantes para gui. esta técnica prueba basada modelo estudió sección .. como producto del gran número permutaciones asociadas con las operaciones gui, prueba gui debe abordarse usando herramientas automatizadas. durante los últimos años apareció una amplia gama herramientas prueba gui. .. prueba arquitecturas cliente-servidor naturaleza distribuida los entornos cliente-servidor, los conflictos rendimiento asocia-dos con procesamiento transacciones, potencial presencia algunas plataformas hardware diferentes, las complejidades comunicación red, necesidad atender múltiples clientes desde una base datos centralizada ( algunos casos, distribuida) los requerimientos coordinación impuestos servidor combinan para realizar las pruebas las arquitecturas cliente-servidor software que reside dentro ellas considerablemente más difícil que las aplicaciones independientes. hecho, estudios industriales recientes indi-can aumento significativo tiempo costo las pruebas cuando desarrollan los entornos cliente-servidor. general, prueba del software cliente-servidor ocurre tres niveles diferentes: ) las aplicaciones cliente individuales prueban modo “desconectado”; considera operación del servidor red subyacente. ) software cliente las aplicaciones servidor asociadas prueban concierto, pero las operaciones red revisan manera explí-cita. ) prueba arquitectura cliente-servidor completa, incluidos operación red rendimiento. aunque cada uno estos niveles detalle realizan muchos tipos pruebas diferen- tes, para las aplicaciones cliente-servidor encuentran comúnmente los siguientes abordajes prueba: • pruebas función aplicación. funcionalidad las aplicaciones cliente prueba usando los métodos analizados anteriormente este capítulo los capítulos . esencia, aplicación prueba forma independiente con intención descubrir errores operación. • pruebas servidor. prueban las funciones coordinación gestión datos del servidor. también considera rendimiento del servidor (tiempo respuesta global cantidad datos transmitidos). • pruebas base datos. prueban precisión integridad los datos alma-cenados por servidor. examinan las transacciones colocadas por las aplicaciones cientos, miles, recursos acerca herramientas prueba gui pueden evaluarse web. buen punto partida para herramientas fuente abierta “ tema las pruebas área que existe una buena cantidad comunión entre los sistemas tradicionales los sis-temas cliente-servidor.” kelley bourne webref pueden encontrarse información recursos útiles para pruebas cliente-servidor. ¿qué tipos pruebas llevan cabo para los sistemas cliente-servidor?? (-).indd (-).indd // ::// :: prueba aplicaciones convencionales cliente para asegurar que los datos almacenen, actualicen recuperen manera adecuada. también prueba forma archivar. • pruebas transacción. crea una serie pruebas para garantizar que cada clase transacciones procese acuerdo con los requerimientos. las pruebas enfocan comprobar correcto del procesamiento también los conflictos rendimiento (por ejemplo, tiempos procesamiento transacción volumen transacción). • pruebas comunicación red. estas pruebas verifican que comunicación entre los nodos red ocurre manera correcta que mensaje que pasa, las transac-ciones tráfico red relacionado ocurren sin errores. como parte estas pruebas, también pueden realizarse pruebas seguridad red. para lograr estos abordajes prueba, musa [mus] recomienda desarrollo perfiles operativos derivados escenarios uso cliente-servidor. perfil operativo indica cómo - teractúan con sistema cliente-servidor diferentes tipos usuarios. decir, los perfiles pro-porcionan “patrón uso” que puede aplicarse cuando las pruebas diseñan ejecutan. por ejemplo, para tipo particular usuario, ¿qué porcentaje transacciones serán consultas?, ¿cuántas serán actualizaciones?, ¿cuántos serán pedidos? para desarrollar perfil operativo, necesario derivar conjunto escenarios que sean similares los casos uso (capítulos ). cada escenario aborda quién, dónde, qué por qué. decir: quién usuario, dónde ( arquitectura cliente-servidor física) ocurre interacción del sistema, cuál transacción por qué ocurre. los escenarios pueden derivarse usando técnicas respuesta requerimientos (capítulo ) través análisis menos forma-les con los usuarios finales. sin embargo, resultado debe ser mismo. cada escenario debe proporcionar indicio las funciones del sistema que requerirán para atender usua-rio particular, orden que requieren dichas funciones, temporización respuesta que espera, así como frecuencia con que usa cada función. luego, estos datos combinan (para todos los usuarios) fin crear perfil operativo. general, esfuerzo prueba número casos prueba por ejecutar asignan cada escenario uso con base frecuencia uso crítico las funciones realizadas. .. documentación prueba centros ayuda término prueba software invoca imágenes gran número casos prueba preparados para revisar los programas cómputo los datos que manipulan. recordar definición software que presentó capítulo , importante notar que las pruebas también deben extenderse tercer elemento configuración del software: documentación. los errores documentación pueden ser tan devastadores para aceptación del pro- grama como los errores los datos código fuente. nada más frustrante que seguir con exactitud una guía usuario centro ayuda línea obtener resultados compor-tamientos que coinciden con los predichos por documentación. por esta razón, las pruebas documentación deben ser parte significativa todo plan prueba software. prueba documentación puede abordarse dos fases. primera, revisión técnica (capítulo ), examina documento claridad editorial. segunda, prueba vivo, usa documentación conjunto con programa real. sorprendentemente, una prueba vivo para documentación puede abordarse usando técnicas que son análogas muchos los métodos prueba caja negra estudiados ante-riormente. prueba basada gráfico puede usarse para describir uso del programa; partición equivalencia análisis del valor frontera pueden usarse para definir varias debe señalarse que los perfiles operativos pueden usarse para probar todo tipo arquitecturas sistema, sólo arquitectura cliente-servidor. (-).indd (-).indd // ::// :: parte tres administración calidad clases entrada interacciones asociadas. pbm puede usarse para garantizar que com- portamiento documentado comportamiento real coinciden. entonces, uso del programa puede rastrearse través documentación. .. prueba para sistemas tiempo real naturaleza asíncrona, dependiente del tiempo muchas aplicaciones tiempo real, agrega nuevo potencialmente difícil elemento mezcla pruebas: tiempo. diseñador casos prueba sólo debe considerar los casos prueba convencionales, sino también manipulación eventos ( decir, procesamiento interrupciones), temporización los datos paralelismo las tareas (procesos) que manejan los datos. muchas situaciones, probar los datos proporcionados cuando sistema tiempo real está estado dará como resultado procesamiento adecuado, mientras que los mismos datos proporcionados cuando sistema está estado diferente pueden conducir error. por ejemplo, software tiempo real que controla una nueva fotocopiadora acepta - terrupciones del operador ( decir, operador máquina presiona teclas control como reset darken) sin error cuando máquina saca copias ( estado “copying”). estas mis-mas interrupciones del operador, ingresan cuando máquina está estado “jammed”, generan una pantalla del código diagnóstico que indica ubicación del atasco que tiene que resolver ( error). además, íntima relación que existe entre software tiempo real entorno hard- ware también puede causar problemas las pruebas. las pruebas del software deben consi-derar impacto los fallos hardware procesamiento del software. tales fallos pueden ser extremadamente difíciles simular manera realista. los métodos amplios diseño casos prueba para sistemas tiempo real continúan evolucionando. sin embargo, puede proponerse una estrategia global cuatro pasos: • prueba tareas. primer paso prueba del software tiempo real probar cada tarea manera independiente. decir, las pruebas convencionales diseñan para cada tarea ejecutan independientemente durante dichas pruebas. prueba tareas descubre errores lógica función, mas temporización comporta-miento.las siguientes preguntas deben responderse durante las pruebas documentación / centro ayuda: • ¿ documentación describe con precisión cómo lograr cada modo uso? • ¿ descripción cada secuencia interacción precisa? • ¿los ejemplos son precisos? • ¿ terminología, descripciones menú respuestas del sistema son consistentes con programa real? • ¿ relativamente fácil localizar guías dentro documentación? • ¿ solución problemas puede lograrse con facilidad usando documentación? • ¿ tabla contenido índice del documento son consistentes, precisos completos?• ¿ diseño del documento (plantilla, fuentes, sangrías, gráficos) contribuye comprender asimilar rápidamente información? • ¿todos los mensajes error del software que muestran usua- rio describen con más detalle documento? ¿las acciones por tomar como consecuencia mensaje error delinean con claridad? • usan enlaces hipertexto, ¿son precisos completos? • usa hipertexto, ¿ diseño navegación apropiado para información requerida? única forma viable para responder estas preguntas hacer que una tercera parte independiente (por ejemplo, usuarios seleccio-nados) pruebe documentación contexto del uso del programa. todas las discrepancias anotan las áreas ambigüedad debi-lidad documento definen para potencial reescritura.información pruebas documentación ¿cuál una estrategia efectiva para probar sistema tiempo real?? (-).indd (-).indd // ::// :: prueba aplicaciones convencionales • prueba comportamiento. con modelos sistema creados con herramientas auto- matizadas, posible simular comportamiento sistema tiempo real examinar comportamiento como consecuencia eventos externos. estas activi-dades análisis pueden servir base para diseño los casos prueba que realizan cuando construye software tiempo real. usar una técnica similar partición equivalencia (sección ..), los eventos (por ejemplo, interrupciones, señales control) categorizan para las pruebas. por ejemplo, los eventos para fotocopiadora pueden ser interrupciones del usuario (contador restablecimiento), interrupciones mecánicas (atasco papel), interrupciones del sistema (baja tóner) modos fallo (sobrecalentamiento del rodillo). cada uno prueba manera indivi-dual comportamiento del sistema ejecutable examina para detectar los errores que ocurren como consecuencia del procesamiento asociado con dichos eventos. comportamiento del modelo del sistema (desarrollado durante actividad análisis) software ejecutable pueden compararse para asegurar que actúan conformidad. una vez que prueba cada clase eventos, éstos presentan sistema orden aleatorio con frecuencia aleatoria. comportamiento del software examina para detectar errores comportamiento. • prueba intertarea. una vez aislados los errores las tareas individuales comportamiento del sistema, las pruebas cambian los errores relacionados con tiempo. las tareas asíncronas que sabe que comunican mutuamente prueban con diferentes tasas datos carga procesamiento para determinar ocurrirán errores sincronización intertarea. además, las tareas que comunican vía cola mensaje almacenamiento datos prueban para descubrir errores tamaño estas áreas almacenamiento datos. • prueba sistema. integrar software hardware, lleva cabo amplio rango pruebas del sistema con intención descubrir errores interfaz software-hardware. mayoría los sistemas tiempo real procesan las interrupciones. por tanto, probar manipulación estos eventos booleanos esencial. usar diagrama estado (capítulo ), examinador desarrolla una lista las posibles -terrupciones del procesamiento que ocurre como consecuencia las interrupciones. entonces diseñan pruebas para valorar las siguientes características del sistema: • ¿las prioridades interrupción asignan manejan manera adecuada? • ¿ procesamiento para cada interrupción maneja manera correcta? • ¿ rendimiento (por ejemplo, tiempo procesamiento) cada procedimiento manejo interrupción apega los requerimientos? • ¿ alto volumen interrupciones que llegan momentos críticos crea problemas funcionamiento rendimiento? además, las áreas datos globales que usan para transferir como parte del procesa- miento interrupción deben probarse fin valorar potencial para generación efec-tos colaterales. . atrones para pruebas software uso patrones como mecanismo para describir soluciones problemas diseño espe-cíficos estudió capítulo . pero los patrones también pueden usarse para proponer soluciones otras situaciones ingeniería software; este caso, prueba del software. los patrones prueba describen problemas soluciones prueba comunes que pueden auxiliar tratamiento. webref catálogo patrones prueba software puede encontrarse (-).indd (-).indd // ::// :: parte tres administración calidad los patrones prueba sólo proporcionan lineamientos útiles conforme comienzan las actividades prueba; también proporcionan tres beneficios adicionales descritos por marick [mar]: . proporcionan vocabulario para quienes solucionan problemas. “oiga, usted sabe, debemos usar objeto nulo”. . enfocan atención las fuerzas que hay detrás problema. esto permite que los diseñado-res [ caso prueba] entiendan mejor cuándo por qué aplica una solución. . alientan pensamiento iterativo. cada solución crea nuevo contexto que pueden resol-verse nuevos problemas. aunque estos beneficios son “leves”, deben pasarse por alto. gran parte las pruebas del software, incluso durante década pasada, han sido actividades hoc. los patrones prueba pueden ayudar equipo software comunicarse manera más efectiva acerca las pruebas, comprender las fuerzas motivación que conducen enfoque específico para las pruebas abordar diseño las pruebas como una actividad evolutiva que cada iteración resulta una suite más completa casos prueba, entonces los patrones lograron mucho. los patrones prueba describen forma muy similar los patrones diseño (capítulo ). literatura han propuesto decenas patrones prueba (por ejemplo, [mar]). los siguientes tres (presentados sólo forma resumida) proporcionan ejemplos representativos: nombre del patrón: pairtesting resumen: patrón orientado proceso, pairtesting describe una técnica que análoga pro- gramación por parejas (capítulo ) que dos examinadores trabajan conjunto para diseñar ejecutar una serie pruebas que pueden aplicarse actividades prueba unidad, integración validación. nombre del patrón: separatetestinterface resumen: hay necesidad probar cada clase sistema orientado objetos, incluidas “clases internas” ( decir, clases que exponen alguna interfaz afuera del componente que los usa). patrón separatetestinterface describe cómo crear “una interfaz prueba que puede usarse para describir pruebas específicas sobre clases que son visibles solamente manera interna com-ponente” [lan]. nombre del patrón: scenariotesting resumen: una vez realizadas las pruebas unidad integración, hay necesidad determinar software desempeñará forma que satisfaga los usuarios. patrón scenariotesting des- cribe una técnica para revisar software desde punto vista del usuario. fallo este nivel indica que software fracasó para satisfacer requisito visible del usuario [kan]. análisis amplio los patrones prueba está más allá del ámbito este libro. tiene más interés, vea [bin] [mar] para información adicional acerca este importante tema. . esumen objetivo principal para diseño casos prueba derivar conjunto pruebas que tienen mayor probabilidad descubrir errores software. para lograr este objetivo, usan dos categorías diferentes técnicas diseño caso prueba: pruebas caja blanca pruebas caja negra. las pruebas caja blanca enfocan estructura control del programa. los casos prueba derivan para asegurar que todos los enunciados programa ejecutaron -punto clave los patrones prueba pueden ayudar equipo software comunicarse manera más efectiva acerca las pruebas comprender mejor las fuerzas que conducen enfoque prueba específico. webref patrones que describen organización, eficiencia, estrategia resolución problemas las pruebas pueden encontrarse (-).indd (-).indd // ::// :: prueba aplicaciones convencionales nos una vez durante las pruebas que todas las condiciones lógicas revisaron. prueba ruta trayectoria básica, una técnica caja blanca, usa gráficos programa ( matrices grá-ficas) para derivar conjunto pruebas linealmente independientes que garantizarán -bertura del enunciado. las pruebas condición flujo datos revisan aún más lógica del programa, prueba bucles complementa otras técnicas caja blanca proporcionar procedimiento para revisar los bucles varios grados complejidad. hetzel [het] describe las pruebas caja blanca como “pruebas pequeño”. impli- cación que las pruebas caja blanca que consideraron este capítulo por general aplican pequeños componentes del programa (por ejemplo, módulos pequeños grupos módulos). las pruebas caja blanca, por otra parte, amplían foco pueden llamarse “prue-bas grande”. las pruebas caja negra diseñan para validar los requerimientos funcionales sin consi- derar funcionamiento interno programa. las técnicas prueba caja negra enfo-can dominio información del software, derivan casos prueba mediante partición los dominios entrada salida programa forma que proporciona cobertura prueba profunda. partición equivalencia divide dominio entrada clases datos que probable que revisen una función software específica. análisis del valor frontera sondea habilidad del programa para manejar datos los límites aceptable. prueba arreglo ortogonal proporciona método sistemático eficiente para probar sistemas con pequeño número parámetros entrada. prueba basada modelo usa elementos del modelo requerimientos para probar comportamiento una aplicación. los métodos prueba especializados abarcan amplio arreglo capacidades soft- ware áreas aplicación. prueba para interfaces gráficas usuario, arquitecturas cliente-servidor, documentación centros ayuda, los sistemas tiempo real requieren cada uno lineamientos técnicas especializadas. con frecuencia, los desarrolladores software experimentados dicen: “las pruebas nunca terminan, sólo transfieren uno [ ingeniero software] cliente. cada vez que cliente usa programa, realiza una prueba”. aplicar diseño casos prueba, pueden lograrse pruebas más completas , consecuencia, descubrir corregir mayor número errores antes comenzar “las pruebas del cliente”. problemas puntos para reflexionar .. myers [mye] usa siguiente programa como una autovaloración habilidad para especificar pruebas adecuadas: programa lee tres valores enteros. los tres interpretan como representación las longitudes los lados triángulo. programa imprime mensaje que indica triángulo esca-leno, isósceles equilátero. desarrolle conjunto casos prueba que crea que probarán este programa manera adecuada. .. diseñe implemente programa (con manipulación error donde sea adecuado) que especifica problema .. derive gráfico flujo para programa aplique prueba ruta básica para -sarrollar casos prueba que garanticen prueba todos los enunciados programa. ejecute los casos muestre sus resultados. .. ¿puede pensar algunos objetivos prueba adicionales que estudiaron sección ..? .. seleccione componente software que haya diseñado implementado recientemente. diseñe conjunto casos prueba que garantice que todos los enunciados ejecutan, usando prueba ruta trayectoria básica. .. especifique, diseñe implemente una herramienta software que calcule complejidad ciclomática para lenguaje programación elección. use matriz grafo como estructura datos operativa diseño. (-).indd (-).indd // ::// :: parte tres administración calidad .. lea beizer [bei] una fuente web relacionada (por ejemplo, discret%.htm) determine cómo puede extenderse programa que desarrolló problema . fin alojar varias enlaces ponderados. extienda herramienta para procesar probabili-dades ejecución tiempos procesamiento liga. .. diseñe una herramienta automatizada que reconozca bucles que los clasifique como indica sección ... .. extienda herramienta descrita problema . fin generar casos prueba para cada - tegoría bucle, una vez encontrada. será necesario realizar esta función manera interactiva con examinador. .. proporcione menos tres ejemplos los que prueba caja negra puede dar impresión que “todo está bien”, mientras que las pruebas caja blanca pueden descubrir error. proporcione menos tres ejemplos los que las pruebas caja blanca pueden dar impresión que “todo está bien”, mientras que las pruebas caja negra pueden descubrir error. .. ¿las pruebas exhaustivas (incluso posible para programas muy pequeños) garantizarán que programa por ciento correcto? .. pruebe manual usuario ( centro ayuda) para una aplicación que use con frecuencia. - cuentre menos error documentación. lecturas adicionales fuentes información virtualmente, todos los libros dedicados las pruebas software consideran tanto estrategia como tácticas. por tanto, las lecturas adicionales anotadas para capítulo son igualmente aplicables para este capítulo. everett raymond (software testing, wiley-ieee computer society press, ), black ( pragmatic software testing, wiley, ), spiller . (software testing process: test management, rocky nook, ), perry ( effec- tive methods for software testing, . ., wiley, ), lewis ( software testing and continuous quality impro- vement, . ., auerbach, ), loveland . (software testing techniques, charles river media, ), burnstein (practical software testing, springer, ), dustin (effective software testing, addison-wesley, ), craig kaskiel (systematic software testing, artech house, ), tamres (introducing software testing, addison-wesley, ) whittaker (how break software, addison-wesley, ) son sólo una pequeña muestra muchos libros que analizan los principios, conceptos, estrategias métodos las pruebas. una segunda edición del texto clásico myers [mye], producido por myers . ( the art software testing, . ., wiley, ), cubre con mucho detalle las técnicas diseño casos prueba. pezze young (software testing and analysis, wiley, ), perry ( effective methods for software testing, . ., wiley, ), copeland ( practitioner’ guide software test design, artech, ), hutcheson (software testing fundamentals, wiley, ), jorgensen ( software testing: craftsman’ approach, . ., crc press, ) proporcionan cada uno presentaciones útiles los métodos técnicas del diseño casos prueba. texto clásico beizer [bei] proporciona una amplia cobertura las técnicas caja blanca introduce nivel rigor matemático que con frecuencia falta otros tratamientos las pruebas. último libro [bei] presenta tratamiento conciso métodos importantes. prueba del software una actividad que consume muchos recursos. por esto que muchas organi- zaciones automatizan partes del proceso prueba. los libros ( effective software test automation, sybex, ); mosely posey (just enough software test automation, prentice-hall, ); dustin, rashka, poston ( automated software testing: introduction, management, and performance, addison-wesley, ); graham . (software test automation, addison-wesley, ) poston (automating specification-based software testing, ieee computer society, ) exponen herramientas, estrategias métodos para pruebas automatizadas. nquyen . (global software test automation, happy about press, ) presentan pano- rama ejecutivo automatización las pruebas. thomas . (java testing patterns, wiley, ) binder [bin] describen patrones prueba que abar- can pruebas métodos, clases/grupos, subsistemas, reutilización componentes, marcos conceptuales sistemas, así como automatización las pruebas prueba bases datos especializadas. internet está disponible una amplia variedad recursos información acerca los métodos diseño casos pruebas. una lista actualizada referencias world wide web que son relevantes para las técnicas prueba puede encontrarse sitio del libro: (-).indd (-).indd // ::// :: aplicaciones orientadas objetos conceptos clave prueba aleatoria . . . . . . . . . prueba basada escenario . basada fallo . . . . basada hebra. . . . basada uso . . . . . clase. . . . . . . . . . clase múltiple . . . grupo . . . . . . . . . partición . . . . . . . ¿qué ? arquitectura del software orien- tado objetos () como resultado una serie subsistemas capas que encapsulan clases colaboradoras. cada uno estos ele- mentos sistema (subsistemas clases) realiza funciones que ayudan lograr los requerimientos del sistema. necesario probar sistema varios niveles diferen-tes con intención descubrir errores que puedan ocu-rrir conforme las clases colaboran unas con otras confor- los subsistemas comunican través capas arquitectónicas. ¿quién hace? ingenieros software examinadores especializados realizan prueba orientada objetos. ¿por qué importante? programa tiene que ejecu- tarse antes que llegue cliente con intención especí-fica remover todos los errores, modo que cliente experimente frustración que produce encontrarse con producto calidad pobre. con finalidad encon-trar mayor número posible errores, las pruebas deben realizarse manera sistemática los casos prueba deben diseñarse usando técnicas disciplinadas. ¿cuáles son los pasos? las pruebas son estratégica- mente análogas prueba sistemas convencionales, pero tácticamente diferentes. puesto que análisis los modelos diseño son similares estructura conte-nido con programa resultante, las “pruebas” inician con revisión dichos modelos. una vez gene-rado código, prueba comienza “ pequeño”, con las pruebas clase. diseña una serie pruebas que ejercitan las operaciones clase que examinan existen errores conforme una clase colabora con otras clases. medida que las clases integran para formar subsistema, aplican pruebas basadas hebra, uso grupo, junto con enfoques basados fallo, fin ejercitar por completo clases colaborado-ras. finalmente, usan casos uso (desarrollados como parte del modelo requerimientos) para descubrir erro-res validación del software. ¿cuál producto final? diseña documenta conjunto casos prueba, diseñados para ejercitar clases, sus colaboraciones comportamientos; definen los resultados esperados registran los resultados rea-les. ¿cómo aseguro que hice bien? cuando comienzan las pruebas, cambia punto vista. ¡intente “romper” software! diseñe casos prueba forma disciplinada revise con minuciosidad los casos prueba creados. una mirada rápidaen capítulo señaló que objetivo las pruebas, dicho manera simple, - contrar mayor cantidad posible errores con una cantidad manejable esfuerzo aplicado durante lapso realista. aunque este objetivo fundamental permanece invaria- ble para software orientado objetos (), naturaleza los programas cambia estrategia las tácticas las pruebas. podría argumentarse que, conforme las bibliotecas clase reutilizables crecen tamaño, reuso mayor mitigará los sistemas necesidad pruebas pesadas. opuesto exactamente cierto. binder [bin] analiza esto cuando afirma: cada reuso nuevo contexto uso prudente una nueva comprobación. parece probable que necesitarán más pruebas, menos, para obtener alta confiabilidad los sistemas orientados objetos. para probar adecuadamente los sistemas , deben realizarse tres cosas: ) ampliar defi- nición prueba para incluir las técnicas descubrimiento error aplicadas análisis orien- tado objetos modelos diseño, ) cambiar significativamente estrategia para prueba unidad integración ) explicar las características únicas del software mediante -seño casos prueba. (-).indd (-).indd // ::// :: parte tres administración calidad . mpliación definición las pruebas construcción software orientado objetos comienza con creación modelos - querimientos (análisis) diseño. debido naturaleza evolutiva del paradigma ingenie- ría del software , dichos modelos comienzan como representaciones relativamente informa-les los requisitos sistema evolucionan hacia modelos detallados clases, relaciones clase, diseño asignación sistema, diseño objetos (que incorpora modelo conec-tividad objetos mediante mensajería). cada etapa, los modelos pueden “probarse” con intención descubrir errores previamente propagación hacia siguiente iteración. puede argumentarse que revisión los modelos análisis diseño especial- mente útil, pues los mismos constructos semánticos (por ejemplo, clases, atributos, operacio-nes, mensajes) aparecen los niveles análisis, diseño código. por tanto, problema definición los atributos clase que descubra durante análisis soslayará los efectos colaterales que puedan ocurrir problema descubriera hasta diseño código ( incluso siguiente iteración análisis). por ejemplo, considere una clase que define número atributos durante pri- mera iteración análisis. atributo extraño anexa clase (debido una mala interpre-tación del dominio del problema). entonces pueden especificarse dos operaciones para mani-pular atributo. lleva cabo una revisión experto dominio puntualiza problema. eliminar atributo extraño esta etapa, durante análisis pueden evitarse los siguientes problemas esfuerzo innecesario: . tal vez generen subclases especiales para alojar atributo innecesario las excep- ciones. evita trabajo volucrado creación subclases innecesarias. . una mala interpretación definición clase puede conducir relaciones clase incorrectas extrañas. . comportamiento del sistema sus clases puede caracterizarse manera inade- cuada para alojar atributo extraño. problema descubre durante análisis propaga aún más, podrían ocurrir los siguientes problemas durante diseño (que evitarían con revisión temprana): . durante diseño del sistema, puede ocurrir asignación inadecuada clase subsistema algunas tareas. . puede emplearse trabajo diseño innecesario fin crear diseño procedimien- tos para las operaciones que abordan atributo extraño. . modelo mensajería será incorrecto (porque los mensajes deben diseñarse para las operaciones que son extrañas). problema sigue sin detectarse durante diseño pasa hacia actividad codificación, empleará esfuerzo considerable para generar código que implemente atributo innecesa-rio, dos operaciones innecesarias, mensajes que activen comunicación interobjetos -chos otros conflictos relacionados. además, prueba clase absorberá más tiempo que necesario. una vez que finalmente haya descubierto problema, modificación del sistema debe realizarse con potencial siempre presente efectos colaterales que generen por cambio. durante las últimas etapas desarrollo, los modelos análisis ( ) diseño (doo) orientado objetos proporcionan información sustancial acerca estructura comporta- las técnicas modelado análisis diseño presentan parte este libro. los conceptos básicos presentan apéndice .aunque revisión los modelos análisis diseño parte integral “ prueba” una aplicación , reconozca que ésta suficiente por misma. también debe realizar pruebas ejecutables.consejo cita: “las herramientas que usamos tienen profunda (¡ tortuosa!) influencia sobre nuestros hábi-tos pensamiento , por tanto, sobre nuestras habilidades pensamiento.” edsger dijkstra (-).indd (-).indd // ::// :: prueba aplicaciones orientadas objetos miento del sistema. por esta razón, dichos modelos deben sujetarse una rigurosa revisión, previa generación del código. todos los modelos orientados objetos deben probarse ( este contexto, término prueba incorpora revisiones técnicas) relación con exactitud, completitud consistencia dentro del contexto sintaxis, semántica pragmática del modelo [lin]. . odelos prueba aoo doo los modelos análisis diseño pueden probarse manera convencional porque pueden ejecutarse. sin embargo, pueden usarse revisiones técnicas (capítulo ) para examinar exactitud consistencia. .. exactitud los modelos aoo doo notación sintaxis utilizadas para representar los modelos análisis diseño ligarán los métodos análisis diseño específicos que elijan para proyecto. por tanto, exac-titud sintáctica juzga mediante uso adecuado simbología; cada modelo revisa para garantizar que mantienen las convenciones modelado adecuadas. durante análisis diseño, exactitud semántica puede valorarse con base confor- midad del modelo con dominio problemas del mundo real. modelo refleja con preci-sión mundo real ( nivel detalle que sea apropiado para etapa desarrollo que revisó modelo), entonces semánticamente correcto. para determinar modelo verdaderamente refleja los requerimientos del mundo real, debe presentarse expertos -minio problemas, quienes examinarán las definiciones jerarquía clase busca omi-siones ambigüedad. las relaciones clase (conexiones instancia) evalúan para deter-minar reflejan con precisión conexiones objetos mundo real. .. consistencia los modelos orientados objetos consistencia los modelos orientados objetos puede juzgarse “considerar las relaciones entre entidades modelo. modelo análisis diseño inconsistente tiene representacio-nes una parte del modelo que reflejan manera correcta otras porciones” [mcg]. para valorar consistencia, debe examinarse cada clase sus conexiones con otras clases. fin facilitar esta actividad, puede usarse modelo clase-responsabilidad-colaboración (crc) diagrama objeto-relación. como estudió capítulo , modelo crc compone tarjetas índice crc. cada tarjeta crc menciona nombre clase, sus respon-sabilidades (operaciones) sus colaboradores (otras clases las que envía mensajes las que depende para lograr sus responsabilidades). las colaboraciones implican una serie rela-ciones ( decir, conexiones) entre clases del sistema . modelo objeto-relación propor-ciona una representación gráfica las conexiones entre clases. toda esta información puede obtenerse partir del modelo análisis (capítulos ). para evaluar modelo clase, recomienda seguir los siguientes pasos [mcg]: . uelva consultar modelo crc modelo objeto-relación. realice una com- probación cruzada para garantizar que todas las colaboraciones implicadas por -delo requerimientos reflejan manera adecuada ambas. los casos uso pueden ser invaluables para cotejar los modelos análisis diseño contra escenarios uso del sistema mundo real. (-).indd (-).indd // ::// :: parte tres administración calidad . inspeccione descripción cada tarjeta índice crc par determinar una responsabilidad delegada parte definición del colaborador. por ejemplo, considere una clase definida por sistema comprobación punto venta que llame creditsale. esta clase tiene una tarjeta índice crc como que ilustra - gura .. para esta colección clases colaboraciones, pregunte una responsabilidad (por ejemplo, leer tarjeta crédito) cumple delegándola colaborador mencionado ( credit- card). decir, ¿ clase creditcard tiene una operación que permite leerse? este caso, respuesta “”. objeto-relación recorre para garantizar que tales - nexiones son válidas. . vertir conexión para garantizar que cada colaborador que solicita servicio recibe solicitud una fuente razonable. por ejemplo, clase credit-card recibe una solicitud para purchase amount (cantidad compra) clase credit- sale, habría problema. creditcard conoce cantidad compra. . usar las conexiones vertidas que examinaron paso , deter- mina posible requerir otras clases las responsabilidades agrupan manera adecuada entre las clases. . determinar las esponsabilidades amplia solicitud pueden combinarse una sola responsabilidad. por ejemplo, leer tarjeta crédito obtener autorización ocurren toda situación. pueden combinarse una responsabilidad validar solicitud crédito que incorpora obtener número tarjeta crédito conseguir autoriza-ción. los pasos del deben aplicarse manera iterativa cada clase largo cada evo- lución del modelo requerimientos. una vez creado modelo diseño (capítulos del ), también deben realizarse revisio- nes del diseño del sistema del diseño del objeto. diseño del sistema bosqueja arquitectura producto global, los subsistemas que abarca producto, forma que los subsistemas asignan los procesadores, asignación clases los subsistemas diseño inter-faz usuario. modelo objetos presenta los detalles cada clase las actividades mensajería que necesitan para implementar las colaboraciones entre clases. diseño del sistema revisa examinar modelo comportamiento del objeto desarro- llado durante análisis mapeo orientado objetos requerido por comportamiento del nombre clase: credit sale tipo clase: evento transaccióncaracterísticas clase: tangible, atómica, secuencial, permanente, guardadaresponsabilidades: leer tarjeta crédito obtener autorizacióncantidad postcompra generar facturacolaboradores: tarjeta crédito autoridad créditocomprobante productolibro ventasarchivo auditoríafacturafigura . ejemplo tarjeta índice crc utilizada para revisión (-).indd (-).indd // ::// :: prueba aplicaciones orientadas objetos sistema contra los subsistemas diseñados para lograr este comportamiento. concurrencia asignación tarea también revisan contexto del comportamiento del sistema. los estados comportamiento del sistema evalúan para determinar cuál existe manera con-currente. los casos uso utilizan para ejercitar diseño interfaz usuario. modelo objetos debe ponerse prueba contra red relación objetos fin asegurar que todos los objetos diseñados contienen los atributos operaciones necesarios para implementar las colaboraciones definidas para cada tarjeta índice crc. además, revisa especificación minuciosa los detalles operación ( decir, los algoritmos que implementan las operaciones). . strategias pruebas orientadas objetos como anotó capítulo , estrategia clásica prueba software comienza “pro-bando pequeño” funciona hacia afuera, “probando grande”. dicho lenguaje las pruebas software (capítulo ), comienza con prueba unidad, luego avanza hacia prueba integración culmina con las pruebas validación sistema. aplicaciones con- vencionales, prueba unidad enfoca unidad programa compatible más pequeña: subprograma (por ejemplo, componente, módulo, subrutina, procedimiento). una vez que cada una estas unidades prueba manera individual, integra una estructura programa mientras aplica una serie pruebas regresión para descubrir errores debidos puesta interfaz los módulos los efectos colaterales que generan sumar nuevas unidades. finalmente, sistema como todo prueba para garantizar que descubren los errores los requerimientos. .. prueba unidad contexto cuando piensa software orientado objetos, cambia concepto unidad. encapsu-lación impulsa definición clases objetos. esto significa que cada clase cada instancia una clase (objeto) encapsulan los atributos (datos) las operaciones (también conocidas como métodos servicios) que manipulan dichos datos. lugar probar módulo indivi-dual, unidad comprobable más pequeña clase encapsulada. puesto que una clase puede contener algunas operaciones diferentes una operación particular puede existir como parte número clases diferentes, significado prueba unidad cambia dramáticamente. posible probar una sola operación aislada ( visión convencional prueba unidad) sino, más bien, como parte una clase. para ilustrar anterior, considere una jerar-quía clase que define una operación ( ) para superclase heredan algunas subclases. cada subclase usa operación ( ), pero aplica dentro del contexto los atribu- tos operaciones privados que definieron para cada subclase. puesto que contexto donde usa operación ( ) varía formas sutiles, necesario probarla contexto cada una las subclases. esto significa que probar operación ( ) vacío ( enfoque tradicional prueba unidad) efectivo contexto orientado objetos. prueba clase para software equivalente prueba unidad para software convencional. diferencia prueba unidad del software convencional, que tiende enfocarse detalle algorítmico módulo los datos que fluyen través interfaz módulo, prueba clase para software activa mediante las operaciones encap-suladas por clase por comportamiento estado misma.punto clave “unidad” comprobable más pequeña software clase. prueba clase activa mediante las operaciones encapsuladas por clase por comportamiento estado misma. las secciones . . estudian los métodos diseño casos prueba para clases . (-).indd (-).indd // ::// :: parte tres administración calidad .. prueba integración contexto puesto que software orientado objetos tiene una estructura control jerárquica, las estrategias integración tradicionales, descendente ascendente, tienen poco significado. además, integrar operaciones una vez una clase ( enfoque integración incremental convencional) con frecuencia imposible debido las “interacciones directas indirectas los componentes que constituyen clase” [ber]. existen dos diferentes estrategias para prueba integración los sistemas [bin]. primera, prueba basada hebra, integra conjunto clases requeridas para responder una entrada evento del sistema. cada hebra integra prueba manera individual. prueba regresión aplica para asegurar que ocurran efectos colaterales. segundo enfoque integración, prueba basada uso, comienza construcción del sistema probar aquellas clases (llamadas independientes) que usan muy pocas clases servidor ( que - plean alguna). después probar las clases independientes, examina siguiente capa clases que usan las clases independientes, llamadas dependientes. esta secuencia pruebas para las capas clases dependientes continúa hasta que construye todo sistema. dife-rencia integración convencional, cuando sea posible debe evitarse uso controladores representantes (proxies) (capítulo ) como operaciones reemplazo. prueba grupo [mcg] paso prueba integración del software . ella, ejercita grupo clases colaboradoras (determinadas examinar crc mode- objeto-relación) diseñar casos prueba que intentan descubrir errores las colabora-ciones. .. prueba validación contexto nivel validación sistema, desaparecen los detalles las conexiones clase. como validación convencional, del software enfoca las acciones visibles para usuario las salidas del sistema reconocibles por mismo. para auxiliar derivación pruebas validación, examinador debe recurrir casos uso (capítulos ) que sean parte del modelo requerimientos. caso uso proporciona escenario que tiene una alta probabilidad descubrir errores los requerimientos interacción usuario. los métodos convencionales prueba caja negra (capítulo ) pueden usarse para acti- var pruebas validación. además, puede elegirse derivar casos prueba del modelo com-portamiento del objeto diagrama flujo evento creado como parte del aoo. . étodos prueba orientada objetos arquitectura del software orientado objetos como resultado una serie subsistemas capas que encapsulan clases colaboradoras. cada uno estos elementos sistema (subsis-temas clases) realiza funciones que ayudan lograr requerimientos sistema. necesario probar sistema varios niveles diferentes con intención descubrir errores que puedan ocurrir conforme las clases colaboran unas con otras conforme los subsistemas comunican través las capas arquitectónicas. los métodos diseño casos prueba para software orientado objetos siguen evo- lucionando. sin embargo, berard [ber] sugiere enfoque global diseño casos prueba : . cada caso prueba debe identificarse manera única explícita asociado con clase que probar . . debe establecerse propósito prueba.punto clave prueba integración para software examina conjunto clases que requieren para responder evento dado. cita: “veo los examinadores como los guardaespaldas del proyec-. defendemos del fallo flanco nuestros desarrollado-res, mientras ellos enfocan crear éxito.” james bach (-).indd (-).indd // ::// :: prueba aplicaciones orientadas objetos . debe desarrollarse una lista pasos prueba para cada una ellas, que debe con- tener: . una lista estados especificados para clase que probará . una lista mensajes operaciones que ejercitarán como consecuencia prueba . una lista excepciones que pueden ocurrir conforme prueba clase . una lista condiciones externas ( decir , con finalidad realizar adecuada- mente las pruebas, cambios entorno externo software que debe existir) . información complementaria que ayudará comprender implementar prueba diferencia del diseño con vencional casos prueba, que activan mediante una visión entrada-proceso-salida del software con detalle algorítmico módulos individuales, prueba orientada objetos enfoca diseño secuencias apropiadas operaciones para ejercitar los estados una clase. .. implicaciones del diseño casos prueba los conceptos conforme una clase evoluciona través los modelos requerimientos diseño, convierte blanco para diseño casos prueba. puesto que los atributos las operaciones -tán encapsulados, por general improductivo probar operaciones afuera clase. aunque encapsulación concepto diseño esencial para , puede crear obstáculo menor cuando prueba. como anota binder [bin]: “las pruebas requieren reportar estado con-creto abstracto objeto”. obstante, encapsulación puede hacer que esta información sea poco difícil obtener. menos que proporcionen operaciones internas fin -portar los valores para los atributos clase, puede ser difícil adquirir una instantánea del -tado objeto. herencia también puede presentar retos adicionales durante diseño casos prueba. anotó que cada nuevo contexto uso requiere nuevo examen, aun cuando haya logrado reuso. además, herencia múltiple complica prueba todavía más aumentar número contextos para los cuales requiere prueba [bin]. dentro del mismo domi-nio problema usan subclases instanciadas una superclase, probable que conjunto casos prueba derivados para superclase pueda usarse cuando prueba subclase. sin embargo, superclase usa contexto completamente diferente, los casos prueba superclase tendrán poca aplicabilidad debe diseñarse nuevo conjunto pruebas. .. aplicabilidad los métodos convencionales diseño casos prueba los métodos prueba caja blanca descritos capítulo pueden aplicarse las opera- ciones definidas para una clase. las técnicas ruta básica, prueba bucle flujo datos pueden ayudar garantizar que probaron todos los enunciados una operación. sin -bargo, estructura concisa muchas operaciones clase hace que algunos argumenten que esfuerzo aplicado prueba caja blanca puede redirigirse mejor para probar nivel clase. los métodos prueba caja negra son tan apropiados para los sistemas como para los sistemas desarrollados, usando métodos ingeniería del software convencional. como observó capítulo , los casos uso pueden proporcionar entrada útil diseño las pruebas caja negra las basadas estado. concepto que debe usarse con cuidado extremo.webref puede encontrar una excelente serie documentos recursos sobre pruebas (-).indd (-).indd // ::// :: parte tres administración calidad .. prueba basada fallo objeto prueba basada fallo dentro sistema diseñar pruebas que tengan una alta probabilidad descubrir fallos plausibles. puesto que producto sistema debe adecuarse los requerimientos del cliente, planificación preliminar requerida para realizar alguna prueba basada fallo comienza con modelo análisis. examinador busca fallos plausibles, decir, aspectos implementación del sistema que pueden resultar defectos. para determi-nar existen dichos fallos, los casos prueba diseñan fin ejercitar diseño código. desde luego, efectividad dichas técnicas depende cómo perciben los examinadores fallo plausible. los fallos reales sistema perciben como improbables, entonces este enfoque realmente mejor que cualquier técnica prueba aleatoria. sin embargo, los modelos análisis diseño pueden proporcionar comprensión acerca que probable que vaya mal, entonces prueba basada fallo puede encontrar significativo número errores con gastos esfuerzo relativamente bajos. prueba integración busca fallos plausibles los llamados operación las conexio- nes mensaje. este contexto encuentran tres tipos fallos: resultado inesperado, uso operación/mensaje equivocado invocación incorrecta. para determinar fallos plausibles cuando invocan funciones (operaciones), debe examinarse comportamiento operación. prueba integración aplica los atributos así como las operaciones. los “compor- tamientos” objeto están definidos por los valores que son asignados sus atributos. las pruebas deben ejercer los atributos para determinar los valores adecuados ocurren para los distintos tipos comportamiento los objetos. importante observar que prueba integración intenta encontrar errores objeto cliente, servidor. dicho términos convencionales, foco prueba integración determinar existen errores código que llama, código llamado. llamada operación usa como pista: una forma encontrar requerimientos prueba que ejerciten código que llama. .. casos prueba jerarquía clase herencia dispensa necesidad pruebas amplias todas las clases derivadas. -cho, realidad puede complicar proceso prueba. considere siguiente situación. una clase base contiene operaciones inherited( ) redefined( ). una clase derived redefine redefi- ned( ) para servir contexto local. hay poca duda que derived::redefined( ) tiene que pro- barse porque representa nuevo diseño nuevo código. pero, ¿ derived::inherited( ) debe probarse nuevamente? derived::inherited( ) llama redefined( ) comportamiento redefined( ) cambió, derived:: inherited( ) puede manejar mal nuevo comportamiento. por tanto, necesita nuevas pruebas aun cuando diseño código hayan cambiado. obstante, importante observar que posible que sólo ejecute subconjunto todos las pruebas para derived::inherited( ). parte del diseño código para inherited( ) depende redefined( ) ( decir, llama llama código alguno que llama manera indirecta), dicho código necesita probarse nuevo clase derivada. base::redefined( ) derived::redefined( ) son dos operaciones diferentes con diferentes especifica- ciones implementaciones. cada una tendrá conjunto requerimientos prueba deriva-das especificación implementación. dichos requerimientos prueba sondean fallos plausibles: integración, condición, frontera, etcétera. pero probable que las opera- las secciones .. .. realizó una adaptación artículo brian marick publicado grupo noticias internet llamado comp.testing. esta adaptación incluye con permiso del autor. para mayor información acerca estos temas, vea [mar]. debe observarse que las técnicas estudiadas estas secciones también son aplicables software convencional.punto clave estrategia para prueba basada fallo elaborar hipótesis acerca conjunto fallos plausibles luego derivar pruebas para corroborar descartar cada hipótesis. ¿qué tipos fallos encuentran los llamados operación las conexiones mensaje? ? punto clave aun cuando una clase base probó ampliamente, todavía tendrá que probar todas las clases derivadas ella. (-).indd (-).indd // ::// :: prueba aplicaciones orientadas objetos ciones sean similares. sus conjuntos requerimientos prueba traslaparán. mientras - jor sea diseño , mayor traslape. necesario derivar nuevas pruebas sólo para aque-llos requerimientos derived::redefined( ) que satisfagan con las pruebas base::redefined( ). para resumir, las pruebas base::redefined( ) aplican objetos clase derived. las - tradas prueba pueden ser adecuadas tanto para clase base como para derivada, pero los resultados esperados pueden diferir clase derivada. .. diseño pruebas basadas escenario las pruebas basadas fallo pierden dos tipos principales errores: ) especificaciones -correctas ) interacciones entre subsistemas. cuando ocurren errores asociados con una -pecificación incorrecta, producto hace que cliente quiere. puede hacer correcto omitir funcionalidad importante. pero cualquier circunstancia, calidad (conformidad con los requerimientos) resiente. los errores asociados con interacción subsistemas ocurren cuando comportamiento subsistema crea circunstancias (por ejemplo, eventos, flujo datos) que hacen que otro subsistema falle. prueba basada escenario concentra que hace usuario, que hace producto. esto significa capturar las tareas (por medio casos uso) que usuario tiene que realizar luego aplicar éstas sus variantes como pruebas. los escenarios descubren errores interacción. pero, para lograr esto, los casos prueba deben ser más complejos más realistas que las pruebas basadas fallo. prueba basada escenario tiende ejercitar múltiples subsistemas una sola prueba (los usuarios limitan uso subsistema vez). como ejemplo, tome cuenta diseño pruebas basadas escenario para editor texto revisar los casos uso que siguen: caso uso: corrección del borrador final antecedentes: raro imprimir borrador “final”, leerlo descubrir algunos errores descon- certantes que fueron obvios imagen pantalla. este caso uso describe secuencia eventos que ocurren cuando esto sucede. . imprimir todo documento. . moverse documento, cambiar ciertas páginas.. conforme cada página cambia, imprimirla.. ocasiones imprime una serie páginas. este escenario describe dos cosas: una prueba necesidades específicas del usuario. las necesidades del usuario son obvias: ) método para imprimir páginas solas ) método para imprimir rango páginas. mientras avanzan las pruebas, hay necesidad probar edición después imprimir (así como inverso). por tanto, trabaja para diseñar pruebas que descubrirán errores función edición que fueron provocados por función -presión, decir, errores que indicarán que las dos funciones software son adecuada-mente independientes. caso uso: imprimir una nueva copia antecedentes: alguien pide usuario una copia reciente del documento. debe imprimirla. . abrir documento.. imprimirlo.. cerrar documento. nuevo, enfoque las pruebas relativamente obvio. excepto que este documento aparece nada. creó una tarea anterior. ¿dicha tarea afecta actual?punto clave prueba basada escenario descubrirá errores que ocurren cuando cualquier actor interactúa con software. cita: “ quiere espera que pro-grama funcione, muy probablemente verá progra- funcionamiento: percibirá los errores.” cem kaner . (-).indd (-).indd // ::// :: parte tres administración calidad muchos editores modernos, los documentos recuerdan cómo imprimieron última vez. por defecto, imprimen misma forma siguiente ocasión. después del escenario correc- ción del borrador final , seleccionar solamente “imprimir” menú dar clic botón imprimir recuadro diálogo hará que última página corregida imprima nuevo. manera que, acuerdo con editor, escenario correcto debe verse del modo siguiente: caso uso: imprimir una nueva copia . abrir documento.. seleccionar “imprimir” menú.. comprobar imprime rango páginas; así, dar clic para imprimir todo documento. . dar clic botón imprimir.. cerrar documento. pero este escenario indica una potencial especificación error. editor hace que usuario razonablemente espera que haga. los clientes con frecuencia pasan por alto compro- bación anotada paso . entonces quedarán desconcertados cuando vayan impresora encuentren una página cuando querían . los clientes desconcertados señalan errores especificación. esta dependencia puede perderse cuando diseñan pruebas, pero probable que pro- blema salga luz durante las pruebas. entonces tendría que lidiar con probable respuesta: “¡así supone que debe trabajar!” .. pruebas las estructuras superficial profunda cuando habla estructura superficial hace referencia estructura observable externa-mente programa , decir, estructura que inmediatamente obvia para usuario final. lugar realizar funciones, los usuarios muchos sistemas les pueden dar objetos para manipular alguna forma. pero, cualquiera que sea interfaz, las pruebas basan todavía tareas usuario. capturar estas tareas involucra comprensión, observación hablar con usuarios representativos ( tantos usuarios representativos como valga pena considerar). seguramente habrá alguna diferencia los detalles. por ejemplo, sistema convencio- nal con una interfaz orientada comandos, usuario puede usar lista todos los comandos como una lista comprobación prueba. existieran escenarios prueba para ejer-citar comando, prueba probablemente pasaría por alto algunas tareas ( interfaz tendría comandos inútiles). una interfaz orientada objetos, examinador puede usar lista todos los objetos como una lista comprobación prueba. las mejores pruebas derivan cuando diseñador observa sistema una forma nueva convencional. por ejemplo, sistema producto tiene una interfaz basada comando, derivarán pruebas más profundas diseñador casos prueba pretende que las opera-ciones sean independientes los objetos. plantee preguntas como “¿ usuario querrá usar esta operación, que aplica sólo objeto scanner, mientras trabaja con impresora?”. cualquiera que sea estilo interfaz, diseño casos prueba que ejercitan estructura superficial debe usar objetos operaciones como pistas que conduzcan tareas pasadas por alto. cuando habla estructura profunda, hace referencia los detalles técnicos internos programa , decir, estructura que comprende examinar diseño / código. prueba estructura profunda diseña para ejercitar dependencias, comportamientos mecanismos comunicación que establezcan como parte del modelo diseño para software . los modelos requerimientos diseño usan como base para prueba estructura profunda. por ejemplo, diagrama colaboración uml modelo despliegue muestran aunque prueba basada escenario tiene méritos, obtendrá mayor rendimiento tiempo invertido revisar los casos uso cuando estas pruebas desarrollen como parte del modelo análisis.consejo punto clave examinar estructura superficial análogo prueba caja negra. prueba estructura profunda similar prueba caja blanca. cita: “ avergüence por los erro-res , por tanto, los convierta crímenes.” confucio (-).indd (-).indd // ::// :: prueba aplicaciones orientadas objetos colaboraciones entre objetos subsistemas que pueden ser visibles manera externa. - tonces diseño caso prueba pregunta: “¿ capturó (como prueba) alguna tarea que ejercita colaboración anotada diagrama colaboración? fue así, ¿por qué hizo?” . étodos prueba aplicables nivel clase prueba “ pequeño” enfoca una sola clase los métodos que encapsula ésta. prueba aleatoria partición son métodos que pueden usarse para ejercitar una clase durante prueba . .. prueba aleatoria para clases para ofrecer breves ilustraciones estos métodos, considere una aplicación bancaria que una clase account (cuenta) tiene las siguientes operaciones: open( ), setup( ), deposit( ), withdraw( ), balance( ) , sumaries( ) , creditlimit( ) close( ) (abrir, configurar, depósito, retiro, saldo, resumen, límite crédito cerrar) [kir]. cada una estas operaciones puede aplicarse account, pero ciertas restricciones (por ejemplo, cuenta debe abrirse antes que otras operaciones puedan aplicarse debe cerrarse después que todas las operaciones comple-ten) están implícitas por naturaleza del problema. incluso con estas restricciones, existen muchas permutas las operaciones. historia vida comportamiento mínima una instancia account incluye las siguientes operaciones: opensetupdepositwithdrawclose esto representa secuencia prueba mínima para account. sin embargo, dentro esta secuencia puede ocurrir una amplia variedad otros comportamientos: opensetupdeposit[deposit|withdraw|balance|summarize|creditlimit]withdrawclose varias secuencias diferentes operaciones pueden generarse azar. por ejemplo: caso prueba : opensetupdepositdepositbalancesummarizewithdrawclose caso prueba : opensetupdepositwithdrawdepositbalancecreditlimitwithdrawclose éstas otras pruebas orden aleatorio realizan para ejercitar diferentes historias vida las instancias clase. número posibles permutas para prueba aleatoria puede volverse muy grande. para mejorar eficiencia prueba, puede usarse una estrategia similar prueba arreglo ortogonal.consejo escena: cubículo shakira. participantes: jamie shakira, miembros del equipo ingeniería software casasegura, que trabajan diseño casos prueba para función seguridad. conversación:shakira: desarrollé algunas pruebas para clase detector [figu- .]; sabes, que permite acceso todos los objetos sen- sor para función seguridad. ¿estás familiarizado con ella?jamie (ríe): seguro, que permite agregar sensor “angus-tia perrito”. shakira: única. cualquier forma, tiene una interfaz con cua- tro operaciones: read( ), enable( ), disable( ) test( ). antes poder leer sensor, debe habilitársele. una vez habilitado, puede leerse probarse. puede deshabilitarse cualquier momento, excepto procesa una condición alarma. así que definí una secuencia prueba simple que ejercitará historia vida comportamiento. [muestra jamie siguiente secuencia].casasegura prueba clase (-).indd (-).indd // ::// :: parte tres administración calidad .. prueba partición nivel clase prueba partición reduce número casos prueba requeridos para ejercitar clase, una forma muy similar partición equivalencia (capítulo ) para software tradicio- nal. las entradas salidas categorizan los casos prueba diseñan para ejercitar cada categoría. ¿pero cómo derivan las categorías partición? partición con base estado categoriza las operaciones clase partir capacidad para cambiar estado clase. considere nuevo clase account, las operaciones estado incluyen deposit( ) withdraw( ), mientras que las operaciones estado incluyen balance( ), sumaries( ) creditlimit( ). las pruebas diseñan para que ejerciten por separado las operaciones que cambian estado aquellas que cambian. consecuencia, caso prueba : opensetupdepositdepositwithdrawwithdrawclose caso prueba : opensetupdepositsummarizecreditlimitwithdrawclose caso prueba cambia estado, mientras que ejercita las operaciones que cambian estado (distintas las que están secuencia prueba mínima). partición con base atributo categoriza las operaciones clase con base los atributos que usan. para clase account, los atributos balance creditlimit pueden usarse para definir particiones. las operaciones dividen tres particiones: ) operaciones que usan creditlimit, ) operaciones que modifican creditlimit ) operaciones que usan modifican creditlimit. entonces diseñan secuencias prueba para cada partición. partición basada categoría jerarquiza las operaciones clase con base función genérica que cada una realiza. por ejemplo, las operaciones clase account pueden cate- gorizarse operaciones inicialización ( open, setup), cálculo (deposit, withdraw), consultas (balance, summarize, creditlimit) terminación (close). . iseño casos prueba interclase diseño casos prueba vuelve más complicado conforme comienza integración del sistema orientado objetos. esta etapa debe comenzar prueba las colaboraciones entre clases. para ilustrar “ generación casos prueba interclase” [kir], expande ejemplo bancario presentado sección . fin incluir las clases colaboraciones anotadas figura .. dirección las flechas figura indica dirección los mensajes las etiquetas indican las operaciones que involucran como consecuencia las colaboraciones que implican los mensajes.#: enable•test•read•disable jamie: eso funcionará, ¡pero tienes que hacer más pruebas que eso! shakira: , , aquí hay otras secuencias que encontré. [muestra jamie las siguientes secuencias]. #: enable•test*[read]•test•disable #: [read] #: enable*disable•[test | read] jamie: déjame ver entiendo intención éstos. número pasa través una historia vida normal, una especie uso convencional. número repite operación leer veces, ése escenario probable. número intenta leer sensor antes que esté habilitado... eso produciría mensaje error algún tipo, ¿cierto? número habilita deshabilita sensor luego intenta leerlo. ¿ mismo que prueba ? shakira: realidad, . número , sensor habilitó. que realmente prueba número operación deshabilitar funciona como debe. read( ) test( ) después disable( ) gene- raría mensaje error. hace, entonces hay error operación deshabilitar. jamie: bien. sólo recuerda que las cuatro pruebas tienen que apli- carse para cada tipo sensor, pues todas las operaciones pueden tener diferencias sutiles dependiendo del tipo sensor. shakira: hay que preocuparse. ése plan. ¿qué opciones prueba están disponibles nivel clase?? (-).indd (-).indd // ::// :: prueba aplicaciones orientadas objetos igual que prueba clases individuales, colaboración clase puede lograrse aplicando métodos aleatorios partición, así como pruebas basadas escenario pruebas comportamiento. .. prueba clase múltiple kirani tsai [kir] sugieren siguiente secuencia pasos para generar casos prueba aleatorios clase múltiple: . para cada clase cliente, use lista operaciones clase fin generar una serie secuencias prueba aleatorias. las operaciones viarán mensajes otras clases ser- vidor. . para cada mensaje generado, determine clase colaborador correspondiente ope- ración objeto servidor . . para cada operación objeto servidor (invocado por los mensajes enviados desde objeto cliente), determine los mensajes que transmite. . para cada uno los mensajes, determine siguiente nivel operaciones que - vocan incorpore esto secuencia prueba. para ilustrar [kir], considere una secuencia operaciones para clase bank relación con una clase (figura .): verifyacctverifypin[[verifypolicywithdrawreq]|depositreq|acctinforeq] caso prueba aleatorio para clase bank puede ser caso prueba / verifyacctverifypindepositreq para considerar los colaboradores involucrados esta prueba, consideran los mensajes asociados con cada una las operaciones anotadas caso prueba . bank debe - laborar con validationinfo para ejecutar verifyacct( ) verifypin( ). bank debe colaborar con account para ejecutar depositreq( ) . por tanto, nuevo caso prueba que ejercita estas - laboraciones caso prueba / verifyacct [bank:validacctvalidationinfo]verifypin [bank: validpinvalidationinfo]depositreq [bank: depositaccount]cita: “ frontera que define ámbi- las pruebas unidad integración diferente para desarrollo orientado obje-tos. las pruebas pueden diseñarse ejercitarse muchos puntos proceso. por tanto, “diseñe poco, codifique poco” convierte “diseñe poco, codifique poco, pruebe poco”. robert binder atmatm user interface cardinserted passworddepositwithdrawaccntstatusterminate verifystatusdepositstatus dispensecash printaccntstat readcardinfo getcashamnt bankverifyacctverifypinverifypolicywithdrawreqdepositreqacctinfo creditlimitaccnttype balance withdraw deposit close account validation info validpinvalidacct cashieropenacctinitialdeposit authorizecard deauthorize closeacctfigura . diagrama colaboración clases para aplicación bancariafuente: adaptado [kir]. (-).indd (-).indd // ::// :: parte tres administración calidad enfoque prueba partición clase múltiple similar que usó para prueba partición clases individuales. una sola clase divide, como estudió sección ... sin embargo, secuencia prueba expande para incluir aquellas operaciones que invo-can mediante mensajes clases que colaboran. enfoque alternativo divide las pruebas con base las interfaces una clase particular. figura ., clase bank recibe mensajes las clases atm cashier. por tanto, los métodos dentro bank pueden probarse divi- dirlos los que sirven atm los que sirven cashier. partición con base estado (sección ..) puede usarse para refinar aún más las particiones. .. pruebas derivadas partir modelos comportamiento uso del diagrama estado como modelo que representa comportamiento dinámico una clase analiza capítulo . diagrama estado para una clase puede usarse fin ayudar derivar una secuencia pruebas que ejercitarán comportamiento dinámico clase ( aquellas clases que colaboran con ella). figura . [kir] ilustra diagrama estado para clase account estudiada anteriormente. figura, las transiciones iniciales mueven través los estados empty acct (cuenta vacía) setup acct (configuración cuenta). mayoría los comportamientos para instancias clase ocurren mientras está estado working acct (cuenta operativa). retiro final cierre cuenta harán que clase account realice transiciones hacia los estados nonworking acct (cuenta operativa) dead acct (cuenta muerta), respectivamente. las pruebas que van diseñar deben lograr cobertura todos los estados, decir, las secuencias operación deben hacer que clase account realice transiciones través - dos los estados permisibles: caso prueba : opensetupaccntdeposit (initial)withdraw (final)close debe observarse que esta secuencia idéntica prueba mínima que estudió sección ... agregar secuencias prueba adicionales secuencia mínima, caso prueba : opensetupaccntdeposit(initial)depositbalance creditwithdraw (final)close caso prueba : opensetupaccntdeposit(initial)depositwithdrawaccntinfowithdraw (final)close necesario derivar todavía más casos prueba para garantizar que todos los comporta- mientos para clase ejercitaron adecuadamente. situaciones las que compor-openempty acctset acct working acct nonworking acctdead acctsetup accnt deposit (inicial) balance credit accntinfodeposit withdraw withdrawal (ﬁnal) closefigura . diagrama estado para clase accountfuente: adaptado [kir]. (-).indd (-).indd // ::// :: prueba aplicaciones orientadas objetos tamiento clase como resultado una colaboración con una más clases, usan diagramas estado múltiple para rastrear flujo comportamiento del sistema. modelo estado puede recorrerse una forma “ancho primero” [mcg]. este con- texto, ancho primero implica que caso prueba ejercita una sola transición que, cuando prueba una nueva transición, sólo usan transiciones previamente probadas. considere objeto creditcard que parte del sistema bancario. estado inicial cre- ditcard indefinido ( decir, proporcionó número tarjeta crédito). hasta leer tarjeta crédito durante una venta, objeto toma estado definido, decir, definen los atributos card number expiration date, junto con identificadores específicos del banco. tarjeta crédito somete cuando envía para autorización aprueba cuando recibe autoriza-ción. transición creditcard estado otro puede probarse derivar casos prueba que hacen que ocurra transición. enfoque ancho primero aplicado este tipo prue- ejercitaría submitted antes ejercitar undefined defined. hiciera, usaría transiciones que probaron anteriormente , por tanto, violaría criterio ancho primero. . esumen objetivo global las pruebas orientadas objetos (encontrar número máximo errores con una cantidad mínima esfuerzo) idéntico prueba software convencional. pero estrategia las tácticas prueba difieren significativamente. visión las pruebas ensancha para incluir revisión los modelos requerimientos diseño. además, foco prueba mueve alejándose del componente procedimental ( módulo) acercándose hacia clase. puesto que los modelos requerimientos diseño código fuente resultante están semánticamente acoplados, prueba ( forma revisiones técnicas) comienza durante actividad modelado. por esta razón, revisión los modelos crc, objeto-relación objeto-comportamiento puede verse como pruebas primera etapa. una vez disponible código, prueba unidad aplica para cada clase. diseño pruebas para una clase usa varios métodos: prueba basada fallo, prueba aleatoria prueba partición. cada uno éstos ejercita las operaciones encapsuladas por clase. las secuen-cias prueba diseñan para garantizar que ejercitan las operaciones relevantes. estado clase, representado por los valores sus atributos, examina para determinar existen errores. prueba integración puede lograrse usando una estrategia basada hebra uso. prueba basada hebra integra conjunto clases que colaboran para responder una -trada evento. prueba basada uso construye sistema capas, comenzando con aque-llas clases que utilizan clases servidor. integración métodos diseño caso prueba también puede usar pruebas aleatorias partición. además, prueba basada escenario las pruebas derivadas los modelos comportamiento pueden usarse para pro-bar una clase sus colaboradores. una secuencia prueba rastrea flujo operaciones través las colaboraciones clase. prueba validación del sistema está orientada caja negra puede lograrse apli- car los mismos métodos caja negra estudiados para software convencional. sin embargo, prueba basada escenario domina validación los sistemas , que hace caso uso impulsor primario para prueba validación. problemas puntos por evaluar .. con sus palabras, describa por qué clase unidad razonable más pequeña para probar dentro sistema . (-).indd (-).indd // ::// :: parte tres administración calidad .. ¿por qué necesario volver probar las subclases que instancian partir una clase existente ésta probó ampliamente? ¿puede usarse diseño casos prueba para clase existente? .. ¿por qué “prueba” debe comenzar con análisis diseño orientado objetos?.. derive conjunto tarjetas índice crc para casasegura realice los pasos anotados sección .. para determinar existen inconsistencias. .. ¿cuál diferencia entre las estrategias basadas hebra basadas uso para prueba inte- gración? ¿cómo encaja prueba grupo? .. aplique pruebas aleatorias partición tres clases definidas diseño del sistema casasegura. produzca casos prueba que indiquen las secuencias operación que invocarán... aplique prueba clase múltiple pruebas derivadas del modelo comportamiento diseño casasegura. .. derive cuatro pruebas adicionales usando prueba aleatoria métodos partición, así como prueba clase múltiple pruebas derivadas del modelo comportamiento, para aplicación bancaria que presentó las secciones . .. lecturas adicionales fuentes información muchos los libros acerca pruebas mencionados las secciones lecturas adicionales fuentes infor- mación los capítulos estudian cierta medida las pruebas los sistemas . schach ( object- oriented and classical software engineering, mcgraw-hill, . ., ) considera prueba dentro del contexto una práctica ingeniería software más amplia. sykes mcgregor ( practical guide testing object-oriented software, addison-wesley, ), bashir goel (testing object-oriented software, springer ), binder (testing object-oriented systems, addison-wesley, ) kung . ( testing object-oriented software, wiley-ieee computer society press, ) tratan prueba con significativo detalle. internet está disponible gran variedad fuentes información acerca métodos prueba orien- tados objeto. sitio del libro htm puede encontrarse una lista actualizada referencias world wide web que son relevantes para las técnicas prueba. (-).indd (-).indd // ::// :: aplicaciones web conceptos clave dimensiones calidad . . . . estrategia. . . . . . . . . . . . . . . . . . . . . . . . . . base datos . . . carga . . . . . . . . . configuración. . . . contenido . . . . . . esfuerzo . . . . . . . interfaz. . . . . . . . navegación . . . . . rendimiento. . . . . seguridad . . . . . . usabilidad . . . . . . nivel componente . . . . . . . . . . pruebas compatibilidad . . ¿qué ? prueba una webapp una colección actividades relacionadas con una sola meta: descubrir errores contenido, función, utilidad, navegabilidad, rendimiento, capacidad seguridad esa aplicación. para lograr esto, aplica una estrategia prueba que abarca tanto revisiones como pruebas ejecutables. ¿quién hace? las pruebas una webapp participan ingenieros web otros participantes proyecto (gestores, clientes usuarios). ¿por qué importante? los usuarios finales encuen- tran errores que derrumben webapp, irán algún otro lado busca del contenido función que necesitan, aplicación fracasará. por esta razón, debe trabajarse para eliminar tantos errores como sea posible antes poner línea webapp. ¿cuáles son los pasos? proceso prueba una webapp comienza enfocándose los aspectos visibles para usuario aplicación avanza hacia pruebas que ejercitan tecnología infraestructura. realizan siete pasos durante prueba: prueba contenido, prue- interfaz, prueba navegación, prueba compo-nente, prueba configuración, prueba rendimiento prueba seguridad. ¿cuál producto final? algunas ocasiones, produce plan prueba para webapp. todo caso, desarrolla una suite casos prueba para cada paso prueba mantiene archivo los resultados prueba para uso futuro. ¿cómo aseguro que hice bien? aunque nunca puede estar seguro que realizaron todas las pruebas que necesitan, posible tener certeza que descubrieron errores ( corrigieron). además, estableció plan prueba, puede realizarse com-probación para garantizar que todas las pruebas planea-das llevaron cabo. una mirada rápidaexiste una urgencia que siempre impregna proyecto web. los participantes (intranquilos por competencia otras webapps, presionados por las demandas del cliente preocu-pados porque perderán ventana mercado) fuerzan para poner webapp línea. como consecuencia, ocasiones desechan por completo las actividades técnicas que frecuen-temente ocurren tarde proceso, como las pruebas aplicación web. esto puede ser error catastrófico. para evitarlo, los miembros del equipo deben asegurarse que cada pro-ducto resultante muestre alta calidad. wallace . [wal] observan esto cuando afirman: las pruebas deben esperar hasta que proyecto finalice. comience probar antes escribir una línea código. pruebe constante efectivamente, desarrollará sitio web mucho más dura-dero. los modelos requerimientos diseño pueden probarse sentido clásico: por ello, equipo debe realizar revisiones técnicas (capítulo ) pruebas ejecutables. intención descubrir corregir errores antes que webapp esté disponible para sus usuarios finales. . onceptos pruebas para aplicaciones web probar proceso ejecución del software con intención encontrar ( final cuen-tas corregir) errores. esta filosofía fundamental, que expuso por primera vez capítulo , cambia para las webapps. hecho, puesto que los sistemas las aplicaciones basadas web residen una red interactúan con muchos sistemas operativos, navegado- (-).indd (-).indd // ::// :: parte tres administración calidad res (residentes varios dispositivos), plataformas hardware, protocolos comunicaciones aplicaciones “ cuarto trasero” diferentes, búsqueda errores representa reto signifi-cativo. para entender los objetivos las pruebas dentro contexto ingeniería web, debe considerar las muchas dimensiones calidad webapp. contexto esta discusión, consideran las dimensiones calidad que son particularmente relevantes cualquier aná-lisis las pruebas webapp. también considera naturaleza los errores que -cuentran como consecuencia las pruebas estrategia prueba que aplica para descu-brir dichos errores. .. dimensiones calidad calidad incorpora una aplicación web como consecuencia buen diseño. evalúa aplicando una serie revisiones técnicas que valoran varios elementos del modelo diseño proceso prueba que estudia largo este capítulo. tanto las revisiones como las pruebas examinan una más las siguientes dimensiones calidad [mil]: • contenido evalúa tanto nivel sintáctico como semántico. primero, valora vocabulario, puntuación gramática para documentos basados texto. segundo, valora corrección ( información presentada), consistencia ( través todo objeto contenido los objetos relacionados) falta ambigüedad. • función prueba para descubrir errores que indican falta conformidad con los requerimientos del cliente. cada función webapp valora corrección, inesta- bilidad conformidad general con estándares implantación adecuados (por ejemplo, estándares lenguaje java ajax). • estructura valora para garantizar que entrega adecuadamente contenido función aplicación, que extensible que puede soportarse conforme agregue nuevo contenido funcionalidad. • usabilidad prueba para asegurar que interfaz soporta cada categoría usuario que puede aprender aplicar toda sintaxis semántica navegación requerida. • navegabilidad prueba para asegurar que toda sintaxis semántica navega-ción ejecutan para descubrir cualquier error navegación (por ejemplo, vínculos muertos, inadecuados erróneos). • rendimiento prueba bajo condiciones operativas, configuraciones cargas dife-rentes fin asegurar que sistema responde interacción con usuario que maneja carga extrema sin degradación operativa inaceptable. • compatibilidad prueba ejecutar webapp varias configuraciones anfitrión, tanto cliente como servidor. intención encontrar errores que sean espe-cíficos una configuración anfitrión única. • interoperabilidad prueba para garantizar que webapp tiene interfaz adecuada con otras aplicaciones / bases datos. • seguridad prueba valorar las vulnerabilidades potenciales intenta explotar cada una. cualquier intento penetración exitoso estima como fallo seguridad. estrategia las tácticas para probar las webapps desarrollaron fin ejercitar cada una estas dimensiones calidad estudian más adelante, este capítulo. las dimensiones genéricas calidad del software, igualmente válidas para las webapps, estudiaron capítulo .¿cómo valora calidad dentro del contexto una webapp entorno?? cita: “ innovación una negocia-ción agridulce para los examinadores software. justo cuando parece que sabe cómo probar una tecnología particular, aparece una nueva [webapp] cualquier cosa puede ocurrir.” james bach (-).indd (-).indd // ::// :: prueba aplicaciones web .. errores dentro entorno webapp los errores que encuentran como consecuencia una prueba exitosa una webapp tienen algunas características únicas [ngu]: . puesto que muchos tipos pruebas webapps descubren problemas que eviden- cian primero lado del cliente ( decir , mediante una interfaz implantada navegador específico dispositivo comunicación personal), con frecuencia síntoma del error, error . . puesto que una webapp implanta algunas configuraciones distintas dentro - ferentes entornos, puede ser difícil imposible reproducir error afuera del entorno que originalmente encontró. . aunque algunos errores son resultado diseño incorrecto codificación html ( otro lenguaje programación) impropia, muchos errores pueden rastrearse configu-ración webapp. . dado que las webapps residen dentro una arquitectura cliente-servidor , los errores pueden ser difíciles rastrear través tres capas arquitectónicas: cliente, servi-dor red . . algunos errores deben entorno oper ativo estático ( decir, configuración espe- cífica donde realiza prueba), mientras que otros son atribuibles entorno opera- tivo dinámico ( decir, carga recurso instantánea errores relacionados con tiempo). estos cinco atributos error sugieren que entorno juega importante papel diagnós- tico todos los errores descubiertos durante prueba webapps. algunas situaciones (por ejemplo, prueba contenido), sitio del error obvio, pero muchos otros tipos prueba webapps (por ejemplo, prueba navegación, prueba rendimiento, prueba -guridad), causa subyacente del error puede ser considerablemente más difícil determi-nar. .. estrategia las pruebas estrategia para probar webapps adopta los principios básicos todas las pruebas soft- ware (capítulo ) aplica una estrategia las tácticas que recomendaron para los sistemas orientados objetos (capítulo ). los siguientes pasos resumen enfoque: . modelo contenido para webapp revisa fin descubrir errores. . modelo interfaz examina para garantizar que todos los casos uso pueden alojarse. . modelo diseño para webapp revisa para descubrir errores navegación. . interfaz usuario prueba para descubrir errores mecánica presentación / navegación. . los componentes funcionales someten prueba unidad. . prueba navegación largo toda arquitectura. . webapp implanta varias configuraciones entorno diferentes prueba para asegurar compatibilidad con cada configuración. . las pruebas seguridad realizan con intención explotar las vulnerabilidades webapp dentro entorno.¿qué hace que los errores encontrados durante ejecución una webapp sean poco diferentes los que encuentran para software convencional?? punto clave estrategia global para probar webapp puede resumirse los pasos que anotan aquí. (-).indd (-).indd // ::// :: parte tres administración calidad . realizan pruebas rendimiento. . webapp prueba con una población controlada monitoreada usuarios finales; los resultados interacción con sistema evalúan para detectar errores con- tenido navegación, preocupaciones usabilidad compatibilidad, seguridad, confiabilidad rendimiento webapp. puesto que muchas webapps evolucionan continuamente , proceso prueba una actividad siempre marcha que realiza personal apoyo web, quien usa pruebas regresión deri- vadas las pruebas desarrolladas cuando comenzó ingeniería las webapps. .. planificación pruebas uso palabra planificación ( cualquier contexto) anatema para algunos desarro- lladores web que planifican; sólo arrancan, con esperanza que surja una webapp ase- sina. enfoque más disciplinado reconoce que planificación establece mapa ruta para todo trabajo que después. vale pena esfuerzo. libro acerca las pruebas webapps, splaine jaskiel [spl] afirman: excepto por más simple los sitios web, rápidamente resulta claro que necesaria alguna espe- cie planificación pruebas. con demasiada frecuencia, número inicial errores encontrados partir una prueba hoc suficientemente grande como para que todos corrijan primera vez que detectan. esto impone una carga adicional sobre personal que prueba sitios webapps. sólo deben idear nuevas pruebas imaginativas, sino que también deben recordar cómo ejecuta-ron las pruebas anteriores con finalidad volver probar manera confiable sitio/ webapp, garantizar que removieron los errores conocidos que introdujeron algunos nuevos. las preguntas que deben plantearse son: ¿cómo “idean nuevas pruebas imaginativas” sobre qué deben enfocarse dichas pruebas? las respuestas estas preguntas integran plan prueba que identifica: ) conjunto tareas que van aplicar cuando comiencen las pruebas, ) los productos trabajo que van producir conforme ejecuta cada tarea prueba ) forma que evalúan, registran reutilizan los resultados prueba cuando realizan pruebas regresión. algunos casos, plan prueba integra con plan del proyecto. otros, documento separado. . panorama del proceso prueba proceso prueba webapps comienza con pruebas que ejercitan funcionalidad del con-tenido interfaz que son inmediatamente visibles para usuario final. conforme avanza prueba, ejercitan aspectos arquitectura del diseño navegación. finalmente, atención centra las pruebas que examinan las capacidades tecnológicas que siempre son aparentes para los usuarios finales: los temas infraestructura instalación/ implantación webapp. figura . yuxtapone proceso prueba webapp con pirámide diseño para este tipo aplicaciones (capítulo ). observe que, conforme flujo prueba avanza izquierda derecha arriba abajo, los elementos visibles para usuario del diseño webapp (elementos superiores pirámide) prueban primero, seguidos por los elementos diseño infraestructura.punto clave plan prueba identifica conjunto tareas pruebas, los productos trabajo que van desarrollar forma que deben evaluarse, registrarse reutilizarse los resultados.webref testing.asp encuentran excelentes artículos acerca pruebas webapps los conjuntos tareas estudian capítulo . también usa término relacionado, flujo trabajo, para describir una serie tareas requeridas para lograr una actividad ingeniería del software. (-).indd (-).indd // ::// :: prueba aplicaciones web . rueba contenido los errores contenido webapp pueden ser tan triviales como errores tipográficos menores tan significativos como información incorrecta, organización inadecuada violación leyes propiedad intelectual. prueba contenido intenta descubrir éstos muchos otros problemas antes que usuario los encuentre. prueba contenido combina tanto revisiones como generación casos prueba eje- cutables. las revisiones aplican para descubrir errores semánticos contenido (que estudia sección ..). las pruebas ejecutables usan para descubrir errores conte-nido que puedan rastrearse fin derivar dinámicamente contenido que impulse por los datos adquiridos una más bases datos. .. objetivos prueba contenido prueba contenido tiene tres objetivos importantes: ) descubrir errores sintácticos (por ejemplo, errores tipográficos gramaticales) documentos texto, representaciones gráficas otros medios; ) descubrir errores semánticos ( decir, errores precisión completitud información) cualquier objeto contenido que presente conforme ocurre nave-gación ) encontrar errores organización estructura del contenido que presenta usuario final. para lograr primer objetivo, pueden usarse correctores automáticos vocabulario gra- mática. sin embargo, muchos errores sintácticos evaden detección tales herramientas los debe descubrir revisor humano (examinador). hecho, sitio web grande debe con-siderar los servicios editor profesional para descubrir errores tipográficos, gazapos gra-maticales, errores consistencia del contenido, errores las representaciones gráficas referencias cruzadas.prueba contenido prueba interfaz prueba navegación prueba componente prueba conﬁguración prueba rendimientoprueba seguridaddiseño interfaz diseño estético diseño contenido diseño navegación diseño arquitectónico diseño componenteusuario tecnologíafigura . proceso prueba aunque las revisiones técnicas son parte las pruebas, debe realizarse revisión del contenido para garantizar que éste tiene calidad.consejo punto clave los objetivos prueba contenido son: ) descubrir errores sintácticos contenido, ) descubrir errores semánticos ) encontrar errores estructurales. (-).indd (-).indd // ::// :: parte tres administración calidad prueba semántica enfoca información presentada dentro cada objeto con- tenido. revisor (examinador) debe responder las siguientes preguntas: • ¿ información realmente precisa? • ¿ información concisa puntual? • ¿ plantilla del objeto contenido fácil comprender para usuario? • ¿ información incrustada dentro objeto contenido puede encontrarse con facilidad? • ¿ proporcionaron referencias adecuadas para toda información derivada otras fuentes? • ¿ información presentada consistente internamente con información presen- tada otros objetos contenido? • ¿ contenido ofensivo, confuso abre puerta demandas? • ¿ contenido infringe derechos autor nombres comerciales existentes? • ¿ contenido incluye vínculos internos que complementan contenido existente? ¿los vínculos son correctos? • ¿ estilo estético del contenido entra conflicto con estilo estético interfaz? obtener respuestas cada una estas preguntas para una gran webapp (que contiene cientos objetos contenido) puede ser una tarea atemorizante. sin embargo, fracaso para des- cubrir los errores semánticos sacudirá del usuario webapp puede conducir fracaso aplicación basada web. los objetos contenido existen dentro una arquitectura que tiene estilo específico (capítulo ). durante prueba contenido, estructura organización arquitectura contenido prueba para garantizar que contenido requerido presente usuario final orden relaciones adecuados. por ejemplo, webapp casaseguraasegurada.com presenta información variada acerca los sensores que utilizan como parte los productos -guridad vigilancia. los objetos contenido proporcionan información descriptiva, especifi-caciones técnicas, una representación fotográfica información relacionada. las pruebas arquitectura contenido casaseguraasegurada.com luchan por descubrir errores presentación esta información (por ejemplo, una descripción del sensor presenta con una fotografía del sensor ). .. prueba base datos las webapps modernas hacen mucho más que presentar objetos contenido estáticos. muchos dominios aplicación, webapp tiene interfaz con sofisticados sistemas gestión base datos construyen objetos contenido dinámico que crean tiempo real, usando los datos adquiridos desde una base datos. por ejemplo, una webapp servicios financieros puede producir información compleja - sada texto, tablas tabulares gráficas acerca fondo específico (por ejemplo, una acción fondo mutualista). objeto contenido compuesto que presenta esta información crea manera dinámica después que usuario hace una solicitud información acerca fondo específico. para lograrlo, requieren los siguientes pasos: ) consulta una gran base datos fondos, ) extracción datos relevantes base datos, ) organización los datos extraídos como objeto contenido ) transmisión este objeto contenido (que representa información personalizada que requiere usuario final) entorno del cliente para despliegue. los errores pueden ocurrir, ocurren, como consecuencia cada uno estos pasos. objeto prueba base datos descubrir dichos errores, pero esta prueba complicada por varios factores:¿qué preguntas deben plantearse responderse para descubrir errores semánticos contenido?? cita: “ general, las técnicas prueba del software que emplean otras aplicaciones son las mismas que las usadas aplicaciones basadas web [...] diferencia [...] que las variables tecnológicas entorno web multiplican.” hung nguyen (-).indd (-).indd // ::// :: prueba aplicaciones web . lado cliente original solicita información que ara vez presenta forma [por ejem- plo, lenguaje consulta estructurado (sql)] que puede ingresarse sistema gestión base datos (dbms). por tanto, las pruebas deben diseñarse para descubrir errores cometidos traducir solicitud del usuario manera que pueda procesar dbms. . base datos puede ser remota relación con servidor que alberga webapp. consecuencia, deben desarrollarse pruebas que descubran errores comunicación entre webapp base datos remota. . los datos brutos adquiridos base datos deben ansmitirse servidor webapp formatearse manera adecuada para posterior transmisión cliente. por tanto, - ben desarrollarse pruebas que demuestren validez los datos brutos recibidos por servidor webapp también deben crearse pruebas adicionales que demuestren validez las transformaciones aplicadas los datos brutos para crear objetos contenido válidos. . objeto contenido dinámico debe ansmitirse cliente forma que pueda desple- garse usuario final. por ende, debe diseñarse una serie pruebas para ) descubrir errores formato del objeto contenido ) probar compatibilidad con diferen- tes configuraciones del entorno del cliente. considerar estos cuatro factores, los métodos diseño caso prueba deben aplicarse cada una las “capas interacción” [ngu] que mencionan figura .. las pruebas deben garantizar que ) información válida pasa entre cliente servidor desde capa -terfaz, ) webapp procesa los guiones manera correcta extrae formatea adecuadamente los datos del usuario, ) los datos del usuario pasan correctamente una función transfor-mación datos del lado servidor que formatea consultas adecuadas (por ejemplo, sql) ) las ¿qué cosas complican prueba base datos para webapps?? estos datos pueden volverse complejos cuando encuentran bases datos distribuidas cuando requiere acceso almacén datos (capítulo ).capa cliente-interfaz usuario guiones html datos del usuario datos del usuario datos brutossql sqlcapa servidor-webapp capa servidor-transformación datos capa servidor-gestión datos capa base datos-acceso datos base datosfigura . capas interacción (-).indd (-).indd // ::// :: parte tres administración calidad consultas pasan una capa gestión datos que comunica con las rutinas acceso base datos (potencialmente ubicadas otra máquina). las capas transformación datos, gestión datos acceso base datos que muestran figura ., con frecuencia construyen con componentes reutilizables que validaron por separado como paquete. éste caso, prueba webapps - foca diseño casos prueba para ejercitar las interacciones entre capa cliente las primeras dos capas servidor (webapp transformación datos) que muestran figura. capa interfaz usuario prueba para garantizar que los guiones construyeron manera adecuada para cada consulta usuario que transmiten adecuadamente lado ser-vidor. capa webapp lado servidor prueba para asegurar que los datos usuario extraen manera adecuada los guiones que transmite adecuadamente capa transformación datos lado servidor. las funciones transformación datos prueban para asegurar que creó sql correcto que pasó componentes gestión datos adecuados. análisis detallado tecnología subyacente que debe comprenderse para diseñar ade- cuadamente estas pruebas base datos está más allá del ámbito este libro. usted tiene interés adicional, vea [sce], [ngu] [bro]. . rueba interfaz usuario verificación validación una interfaz usuario webapp ocurre tres puntos distintos. durante análisis requerimientos, modelo interfaz revisa para garantizar que conformidad los requerimientos los participantes otros elementos del modelo reque-rimientos. durante diseño, revisa modelo diseño interfaz para garantizar que logran los criterios calidad genéricos establecidos para todas las interfaces usuario (capí-tulo ) que los temas diseño interfaz específicos aplicación abordaron -nera adecuada. durante prueba, atención centra ejecución aspectos específicos aplicación interacción con usuario, conforme manifiesten por sintaxis semántica interfaz. además, prueba proporciona una valoración final usabilidad. .. estrategia prueba interfaz prueba interfaz ejercita los mecanismos interacción valida los aspectos estéticos interfaz usuario. estrategia global para prueba interfaz ) descubrir errores rela-cionados con mecanismos interfaz específicos (por ejemplo, ejecución adecuada vínculo menú forma como entran los datos formulario) ) descubrir errores forma como interfaz implanta semántica navegación, funcionalidad webapp despliegue contenido. para lograr esta estrategia, inician algunos pasos tácticos: • las características interfaz prueban para garantizar que las reglas del diseño, estética contenido visual relacionado estén disponibles sin error para usuario. las carac- terísticas incluyen tipo fuente, uso color, marcos, imágenes, bordes, tablas carac-terísticas interfaz relacionadas que generan conforme avanza ejecución webapp. • los mecanismos interfaz individuales prueban forma análoga prueba unidad. por ejemplo, las pruebas diseñan para ejercitar todas las formas, guiones del lado cliente, html dinámicos, guiones, contenido streaming (transmisión continua) capa gestión datos por general incorpora una interfaz sql nivel llamado (sql-cli), como microsoft ole/ado java database connectivity (jdbc).cita: “... improbable que uno tenga confianza sitio web que sufre constantes perio-dos inactividad, que pasma medio una tran-sacción que tiene una pobre sensación funcionalidad. por tanto, las pruebas tienen papel vital proceso desarrollo global.” wing lam con excepción especificaciones orientadas webapp, estrategia interfaz que anota aquí aplicable todo tipo software cliente-servidor.consejo (-).indd (-).indd // ::// :: prueba aplicaciones web mecanismos interfaz específicos aplicación (por ejemplo, carro mandado para una aplicación comercio electrónico). muchos casos, prueba puede enfocarse exclusivamente uno estos mecanismos ( “unidad”) excluir otras características funciones interfaz. • cada mecanismo interfaz prueba dentro del contexto caso uso una unidad semántica navegación (usn) (capítulo ) para una categoría usuario especí- fica. este enfoque pruebas análogo prueba integración porque las pruebas realizan conforme los mecanismos interfaz integran para permitir ejecución caso uso usn. • interfaz completa prueba contra los casos uso seleccionados las usn fin descubrir errores semántica interfaz. este enfoque prueba análogo prueba validación porque propósito demostrar conformidad con semántica casos uso usn específicas. esta etapa lleva cabo una serie pruebas usabilidad. • interfaz prueba dentro varios entornos (por ejemplo, navegadores) para garantizar que será compatible. realidad, esta serie pruebas también puede considerarse como parte las pruebas configuración. .. prueba mecanismos interfaz cuando usuario interactúa con una webapp, interacción ocurre través uno más mecanismos interfaz. los párrafos que siguen presenta breve panorama las con-sideraciones prueba para cada mecanismo interfaz [spl]. vínculos. cada vínculo navegación prueba para garantizar que alcanza objetivo contenido función apropiados. construye una lista todos los vínculos asociados con plantilla interfaz (por ejemplo, barras menú ítems índice) luego ejecuta cada uno individualmente. además, deben ejercitarse los vínculos dentro cada objeto contenido para descubrir url vínculos defectuosos con objetos contenido funciones inadecuadas. finalmente, los vínculos con webapps externas deben probarse precisión también eva-luarse para determinar riesgo que vuelvan inválidos con tiempo. formularios. nivel macroscópico, las pruebas realizan para asegurarse que ) las etiquetas identifican correctamente los campos dentro del formulario los campos obligatorios identifican visualmente para usuario, ) servidor recibe toda información contenida dentro del formulario ningún dato pierde transmisión entre cliente servidor , ) usan valores por defecto adecuados cuando usuario selecciona menú desplegable conjunto botones, ) las funciones del navegador (por ejemplo, flecha “retroceso”) corrompen entrada datos formulario ) los guiones que realizan comproba- ción errores los datos ingresados funcionan manera adecuada proporcionan mensa-jes error significativos. nivel más dirigido, las pruebas deben garantizar que ) los campos del formulario tie- nen ancho tipos datos adecuados, ) formulario establece salvaguardas adecuadas que prohíben que usuario ingrese cadenas texto más largas que cierto máximo predefinido, ) todas las opciones adecuadas para menús desplegables especifican ordenan forma sig-nificativa para usuario final, ) las características “autollenado” del navegador condu-cen errores entrada datos ) tecla tabulación ( alguna otra) inicia movi-miento adecuado entre los campos del formulario. estas pruebas pueden realizarse como parte prueba interfaz navegación. prueba vínculos externos debe ocurrir durante vida webapp. parte una estrategia apoyo debe ser calendarización regular pruebas vínculos.consejo (-).indd (-).indd // ::// :: parte tres administración calidad guión lado cliente. las pruebas caja negra realizan para descubrir cualquier error procesamiento conforme ejecuta guión. estas pruebas con frecuencia aco- plan con pruebas formularios porque entrada del guión con frecuencia deriva los datos proporcionados como parte del procesamiento formulario. debe realizarse una prueba compatibilidad para garantizar que lenguaje del guión elegido funcionará adecuadamen- las configuraciones entorno que soporten webapp. además probar guión , splaine jaskiel [spl] sugieren que “debe asegurarse que los estándares [ webapps] compañía enuncien lenguaje versión preferidos del lenguaje guión que usar para escritura guiones lado cliente ( lado servidor)”. html dinámico. cada página web que contenga html dinámico ejecuta para asegurar que despliegue dinámico correcto. además, debe llevarse cabo una prueba compati-bilidad para asegurarse que html dinámico funciona adecuadamente las configuraciones entorno que soportan webapp. ventanas pop-. una serie pruebas garantiza que ) aparición instantánea tiene tamaño posición adecuadas, ) aparición cubre ventana webapp original, ) diseño estético aparición consistente con diseño estético interfaz ) las barras desplazamiento otros mecanismos control anexados ventana aparición ubican funcionan manera adecuada, como requiere. guiones cgi. las pruebas caja negra realizan con énfasis sobre integridad los datos (conforme los datos pasan guión cgi) del procesamiento del guión (una vez recibidos los datos validados). además, prueba rendimiento puede realizarse para garantizar que configuración del lado servidor puede alojar las demandas procesamiento múltiples - caciones los guiones cgi [spl]. contenido str eaming. las pruebas deben demostrar que los datos streaming están actualizados, que despliegan manera adecuada que pueden suspenderse sin error -anudarse sin dificultad. cookies. requieren pruebas tanto del lado servidor como del lado cliente. primero, las pruebas deben garantizar que una cookie construyó adecuadamente (que contiene datos correctos) que transmitió manera adecuada lado cliente cuando solicitó contenido funcionalidad específico. además, persistencia adecuada cookie prueba para ase- gurar que fecha expiración correcta. lado cliente , las pruebas determinan webapp liga adecuadamente las cookies existentes una solicitud específica (enviada servi- dor). mecanismos interfaz específicos aplicación. las pruebas siguen conforme una lista comprobación funcionalidad características que definen mediante mecanismo interfaz. por ejemplo, splaine jaskiel [spl] sugieren siguiente lista comprobación para funcionalidad carro compras definida para una aplicación comercio electrónico: • prueba frontera (capítulo ) del número mínimo máximo artículos que pueden colocarse carro compras. • prueba una solicitud “salida” para carro compras vacío. • prueba borrado adecuado artículo del carro compras. • prueba para determinar una compra vacía contenido del carro. • prueba para determinar persistencia del contenido del carro compras (esto debe especificarse como parte los requerimientos del cliente). • prueba para determinar webapp puede recordar contenido del carro compras alguna fecha futura (suponiendo que realizó compra alguna).las pruebas guión lado cliente las pruebas asociadas con html dinámico deben repetirse siempre que libera una nueva versión navegador popular.consejo (-).indd (-).indd // ::// :: prueba aplicaciones web .. prueba semántica interfaz una vez que cada mecanismo interfaz sido sometido prueba “unidad”, atención prueba interfaz cambia hacia una consideración semántica interfaz. esta prueba “evalúa cuán bien cuida diseño los usuarios, ofrece instrucciones claras, entrega retroali-mentación mantiene consistencia lenguaje enfoque” [ngu]. una revisión profunda del modelo diseño interfaz puede proporcionar respuestas par- ciales las preguntas implicadas párrafo precedente. sin embargo, cada escenario caso uso (para cada categoría usuario) debe probarse una vez implantada webapp. esen- cia, caso uso convierte entrada para diseño una secuencia prueba. intención secuencia prueba descubrir errores que evitarán que usuario logre objetivo asociado con caso uso. conforme cada caso uso prueba, buena idea mantener una lista comprobación para asegurar que cada objeto del menú ejercitó menos una vez que utilizó cada vínculo incrustado dentro objeto contenido. además, serie pruebas debe incluir selección menú inadecuada uso vínculos. intención determinar webapp pro-porciona manejo recuperación efectivos del error. .. pruebas usabilidad prueba usabilidad similar semántica interfaz (sección ..) porque también evalúa grado cual los usuarios pueden interactuar efectivamente con webapp grado que webapp guía las acciones del usuario, proporciona retroalimentación signifi-cativa refuerza enfoque interacción consistente. lugar enfocarse atentamente semántica algún objetivo interactivo, las revisiones pruebas usabilidad diseñan para determinar grado cual interfaz webapp facilita vida del usuario. invariablemente, ingeniero software contribuirá con diseño las pruebas usabi- lidad, pero las pruebas las realizan los usuarios finales. siguiente secuencia pasos aplicable para tal fin [spl]: . definir conjunto categorías prueba usabilidad identificar las metas cada una. . diseñar pruebas que permitirán evaluación cada meta. . seleccionar los participantes que realicen las pruebas. . instrumentar interacción los participantes con webapp mientras lleva cabo prueba. . desarrollar mecanismo para valorar usabilidad webapp. prueba usabilidad puede ocurrir varios niveles diferentes abstracción: ) puede -lorarse usabilidad mecanismo interfaz específico (por ejemplo, formulario), ) puede evaluarse usabilidad una página web completa (que abarque mecanismos interfaz, objetos datos funciones relacionadas) ) puede considerarse usabilidad webapp completa. primer paso prueba usabilidad identificar conjunto categorías usabi- lidad establecer los objetivos prueba para cada categoría. las siguientes categorías objetivos prueba (escritos forma pregunta) ilustran este enfoque: este contexto usado término amigable con usuario. desde luego, problema que percepción usuario acerca una interfaz “amigable” puede ser radicalmente diferente otro. para información adicional acerca usabilidad, vea capítulo .webref design//.html encuentra una valiosa guía para las pruebas usabilidad. (-).indd (-).indd // ::// :: parte tres administración calidad interactividad: ¿los mecanismos interacción (por ejemplo, menús desplegables, botones, punteros) son fáciles entender usar? plantilla: ¿los mecanismos navegación, contenido funciones colocan forma que usuario pueda encontrarlos rápidamente? legibilidad: ¿ texto está bien escrito comprensible? ¿las representaciones gráficas entienden con facilidad? estética: ¿ plantilla, color, fuente características relacionadas facilitan uso? ¿los usuarios “ sienten cómodos” con apariencia sentimiento webapp? características despliegue: ¿ webapp usa manera óptima tamaño resolución pantalla? sensibilidad temporal: ¿las características, funciones contenido importantes pueden usarse adquirir forma oportuna? personalización: ¿ webapp adapta las necesidades específicas diferentes catego- rías usuario usuarios individuales? accesibilidad: ¿ webapp accesible personas que tienen discapacidades? dentro cada una estas categorías diseña una serie pruebas. algunos casos, “prueba” puede ser una revisión visual una página web. otros, pueden ejecutarse nuevo pruebas semánticas interfaz, pero esta instancia las preocupaciones por usabilidad son primordiales. como ejemplo, considere valoración usabilidad para los mecanismos interacción interfaz. constantine lockwood [con] sugieren que debe revisarse siguiente lista -racterísticas interfaz probar usabilidad: animación, botones, color, control, diálogo, campos, formularios, marcos, gráficos, etiquetas, vínculos, menús, mensajes, navegación, -ginas, selectores, texto barras herramientas. conforme valora cada característica, calificada por los usuarios que realizan prueba sobre una escala cualitativa. figura . muestra posible conjunto “calificaciones” valoración que pueden seleccionar los usua-rios, mismas que aplican cada característica individualmente, una página web completa webapp como todo.¿qué características usabilidad convierten centro atención las pruebas qué objetivos específicos señalan?? puede usarse índice legibilidad fog otros para proporcionar una valoración cuantitativa legibilidad. véase http://developer.gnome.org/documents/usability/usability-readability.html para más detalles.fácil usar fácil aprender efectiva sencilla poco ambigua confusa generalmente uniforme predecible predecibilidadfácil comprendercomplicada difícil aprenderinformativaclara engañosa inconsistente carece uniformidadfigura . valoración cualitativa usabilidad (-).indd (-).indd // ::// :: prueba aplicaciones web .. pruebas compatibilidad diferentes computadoras, dispositivos despliegue, sistemas operativos, navegadores velo- cidades conexión red pueden tener influencia significativa sobre operación una webapp. cada configuración cómputo puede dar como resultado diferencias velocidades procesamiento lado cliente, resolución despliegue velocidades conexión. los caprichos los sistemas operativos ocasiones pueden producir conflictos procesa-miento webapp. ocasiones, diferentes navegadores producen resultados ligeramente distintos, sin importar grado estandarización html dentro webapp. los plug-ins -queridos pueden conseguirse con facilidad para una configu ración particular. algunos casos, pequeños conflictos compatibilidad representan problemas signifi- cativos, pero otros pueden encontrarse serios errores. por ejemplo, las velocidades des-carga pueden volverse inaceptables, carecer plug- requerido puede hacer que conte-nido esté disponible, las diferencias navegador pueden cambiar dramáticamente plantilla página, los estilos fuente pueden alterarse volverse ilegibles los formularios pueden organizarse manera inadecuada. prueba compatibilidad busca descubrir dichos problemas antes que webapp esté línea. primer paso prueba compatibilidad definir conjunto configuraciones cómputo, sus variantes, que “ encuentran comúnmente” lado cliente. esencia, crea una estructura árbol, identificación cada plataforma cómputo, dispositivos despliegue usuales, sistemas operativos aceptados plataforma, navegadores disponibles, probables velocidades conexión internet información similar. continuación deriva una serie pruebas validación compatibilidad, con frecuencia adaptadas pruebas interfaz existentes, navegación, rendimiento seguridad. intención estas pruebas descubrir errores problemas ejecución que pueden rastrearse para identificar diferen-cias configuración. punto clave las webapps ejecutan dentro varios entornos lado cliente. objetivo prueba compatibilidad descubrir errores asociados con entorno específico (por ejemplo, navegador). escena: oficina doug miller. participantes: doug miller (gerente del grupo ingeniería del software casasegura) vinod raman (miembro del equipo ingeniería del software del producto). conversación:doug: ¿qué piensas versión . webapp comercio electrónico para casaseguraasegurada.com? vinod: proveedor subcontratado hizo buen trabajo. sharon [gerente desarrollo del proveedor] dijo que ahora están haciendo pruebas. doug: gustaría que resto del equipo hicieran una prueba poco informal sitio comercio electrónico. vinod (hace muecas): creo que vamos contratar una compa- ñía externa para validar webapp. todavía nos estamos matando intento poner producto línea. doug: vamos contratar proveedor pruebas para las prue- bas rendimiento seguridad, nuestro proveedor subcontratado está haciendo pruebas. sólo pienso que otro punto vista sería útil , además, nos gustaría conservar los costos línea, modo que... vinod (suspira): ¿qué buscas?doug: quiero estar seguro que interfaz toda navegación son sólidas. vinod: supongo que podemos comenzar con los casos uso para cada una las principales funciones interfaz: aprenda acerca casasegura. especifique sistema casasegura que necesita.compre sistema casasegura.obtenga soporte técnico. doug: bien. pero sigan las rutas navegación durante todo tra- yecto hasta conclusión. vinod (observa cuaderno casos uso): , cuando seleccionas especifique sistema casasegura que necesita, eso llevará hacia: seleccione componentes casasegura.casasegura prueba webapp (-).indd (-).indd // ::// :: parte tres administración calidad . rueba nivel componente prueba nivel componente , también llamada prueba función, enfoca con- junto pruebas que intentan descubrir errores funciones las webapps. cada función una webapp componente software (implantado uno varios lenguajes progra- mación lenguajes guiones) puede probarse usando técnicas caja negra ( algunos casos caja blanca), como estudió capítulo . los casos prueba nivel componente con frecuencia derivan entrada formularios. una vez definidos los datos los formularios, usuario selecciona botón otro mecanismo control para iniciar ejecución. son usuales los siguientes métodos -seño caso prueba (capítulo ): • partición equivalencia. dominio entrada función divide categorías clases entrada partir las cuales derivan casos prueba. formulario entrada valora para determinar cuáles clases datos son relevantes para función. los casos prueba para cada clase entrada derivan ejecutan, mientras que otras clases entrada mantienen constantes. por ejemplo, una aplicación comercio electrónico puede implantar una función que calcule los cargos embarque. entre una variedad información embarque proporcionada mediante formulario, está código postal del usuario. los casos prueba diseñan con intención descubrir errores procesamiento del código postal especificar valores código postal que puedan descubrir diferentes clases errores (por ejemplo, código postal incompleto, código postal incorrecto, código postal inexistente, formato código postal erróneo). • análisis valor frontera. los datos los formularios prueban sus fronteras. por ejemplo, función cálculo embarque anotada anteriormente solicita número máximo días requeridos para entrega del producto. formulario anota mínimo días máximo . sin embargo, las pruebas valor frontera pueden ingresar valores , , , , para determinar cómo reacciona función datos afuera las fronteras entrada válida. • prueba rutas. complejidad lógica función alta, puede usarse prueba rutas ( método diseño casos prueba caja blanca) para garantizar que ejercitó cada ruta independiente programa. además estos métodos diseño casos prueba, usa una técnica llamada prueba error forzado [ngu] para derivar casos prueba que propósito conducen componente obtenga recomendaciones componentes casasegura podemos ejercitar semántica cada ruta.doug: mientras estás ahí, verifica contenido que aparece cada nodo navegación. vinod: desde luego... los elementos funcionales también. ¿quién prueba usabilidad?doug: ... proveedor examinador coordinará prueba usabilidad. contratamos una firma investigación mercado fin alinear usuarios comunes para estudio usabilidad, pero tus chicos descubren algún conflicto usabilidad... vinod: , pásenlos largo.doug: gracias, vinod. este caso, mejor diseño entrada puede eliminar errores potenciales. número máximo días podría seleccionarse menú desplegable, que impide usuario especificar entrada fuera fronteras. complejidad lógica puede determinarse calcular complejidad ciclomática del algoritmo. vea capítulo para detalles adicionales. (-).indd (-).indd // ::// :: prueba aplicaciones web web una condición error. propósito descubrir los errores que ocurren durante - nipulación del error (por ejemplo, mensajes error incorrectos inexistentes, falla web- app como consecuencia del error, salida errónea activada por entrada errónea, efectos colate-rales que relacionan con procesamiento componentes). cada caso prueba nivel componente especifica todos los valores entrada salida que espera que proporcione componente. salida real producida como consecuencia prueba registra para futuras referencias durante soporte mantenimiento. muchas situaciones, ejecución correcta función una webapp liga interfaz adecuada con una base datos que puede ser externa webapp. por tanto, prueba base datos convierte parte integral del régimen prueba componente. . rueba navegación usuario viaja través una webapp forma muy parecida como visitante camina través una tienda museo. existen muchas rutas que pueden tomarse, muchas paradas que pueden realizarse, muchas cosas que aprender mirar, actividades por iniciar decisiones por tomar. este proceso navegación predecible porque cada visitante tiene conjunto objetivos cuando llega. mismo tiempo, proceso navegación puede ser impredecible porque visitante, influido por algo que aprende, puede elegir una ruta iniciar una acción que usual conforme objetivo original. labor prueba navegación ) garan-tizar que son funcionales todos los mecanismos que permiten usuario webapp recorrerla ) validar que cada unidad semántica navegación (usn) pueda lograr categoría usua-rio apropiada. .. prueba sintaxis navegación primera fase prueba navegación realidad comienza durante prueba interfaz. los mecanismos navegación prueban para asegurarse que cada interfaz realiza función que encargado. splaine jaskiel [spl] sugieren que debe probarse cada uno los siguientes mecanismos navegación: • vínculos navegación: estos mecanismos incluyen vínculos internos dentro webapp, vínculos externos hacia otras webapps anclas dentro una página web espe- cífica. cada vínculo debe ser probado para asegurarse que alcanza contenido funcionalidad adecuados cuando elige vínculo. • redirecciones: estos vínculos entran juego cuando usuario solicita una url inexis-tente cuando selecciona vínculo cuyo contenido removió cuyo nombre cambió. despliega mensaje para usuario navegación redirige hacia otra página (por ejemplo, página inicio). los redireccionamientos deben probarse solicitar vínculos internos incorrectos url externas debe valorarse cómo maneja webapp estas solicitudes. • marcas página (favoritos, bookmarks): aunque las marcas página son función del navegador, webapp debe probarse para garantizar extracción título página significativo conforme crea marca. • marcos framesets: cada marco incluye contenido una página web específica; frameset contiene múltiples marcos habilita despliegue múltiples páginas web mismo tiempo. puesto que posible anidar marcos framesets unos dentro otros, estos mecanismos navegación despliegue deben probarse para que tengan contenido correcto, plantilla tamaño adecuados, rendimiento descargas compa-tibilidad navegador.cita: “ estamos perdidos. tenemos desafío posicional.” john . ford (-).indd (-).indd // ::// :: parte tres administración calidad • mapas sitio: mapa sitio proporciona una tabla contenido completa para todas las páginas web. cada entrada del mapa sitio debe probarse para garantizar que los vínculos llevan usuario contenido funcionalidad adecuados. • motores búsqueda internos: las webapps complejas con frecuencia contienen cientos incluso miles objetos contenido. motor búsqueda interno permite usuario realizar una búsqueda palabra clave dentro webapp para encontrar contenido necesario. prueba del motor búsqueda valida precisión completitud búsqueda, las propiedades manejo error del motor búsqueda las caracterís-ticas búsqueda avanzadas (por ejemplo, uso operadores booleanos campo búsqueda). algunas las pruebas anotadas pueden realizarse mediante herramientas automatizadas (por ejemplo, comprobación vínculos), mientras que otras diseñan ejecutan manualmente. intención principio fin garantizar que los errores mecánica navegación encuentran antes que webapp entre línea. .. prueba semántica navegación capítulo , una unidad semántica navegación (usn) define como “ conjunto estructuras información navegación relacionada que colaboran cumplimiento subconjunto requerimientos usuario relacionados” [cac]. cada usn define mediante conjunto trayectorias navegación (llamadas “rutas navegación”) que conectan los nodos navegación (por ejemplo, páginas web, objetos contenido funcionalidad). consi-derado como todo, cada usn permite usuario lograr requerimientos específicos defini-dos por uno más casos uso para una categoría usuario. prueba navegación ejercita cada usn para asegurarse que dichos requerimientos pueden lograrse. necesario respon-der las siguientes preguntas conforme prueba cada usn: • ¿ usn logra totalidad sin error? • ¿todo nodo navegación (definido por una usn) alcanza dentro del contexto las rutas navegación definidas por usn? • usn puede lograrse usando más una ruta navegación, ¿ probó cada ruta relevante? • interfaz usuario proporciona una guía para auxiliar navegación, ¿las instrucciones son correctas comprensibles conforme avanza navegación? • ¿existe mecanismo (distinto flecha “retroceso” del navegador) para regresar nodo navegación anterior comienzo ruta navegación? • ¿los mecanismos navegación dentro gran nodo navegación ( decir, una página web grande) funcionan manera adecuada? • una función debe ejecutarse nodo usuario elige proporcionar entrada, ¿ resto usn puede completarse? • una función ejecuta nodo ocurre error procesamiento función, ¿ usn puede completarse? • ¿existe alguna forma para descontinuar navegación antes que todos los nodos hayan alcanzado, pero luego regresar donde descontinuó navegación avanzar desde ahí? • ¿todo nodo alcanzable desde mapa sitio? ¿los nombres nodo son significa- tivos para los usuarios finales?¿qué preguntas deben plantearse respon-derse conforme prueba cada usn?? han creado usn como parte del análisis diseño webapp, puede aplicar casos uso para diseño casos prueba navegación. mismo conjunto preguntas plantean responden.consejo (-).indd (-).indd // ::// :: prueba aplicaciones web • nodo dentro una usn alcanza desde alguna fuente externa, ¿ posible avanzar hacia nodo siguiente ruta navegación? ¿ posible regresar nodo anterior ruta navegación? • ¿ usuario entiende ubicación dentro arquitectura contenido conforme ejecuta usn? prueba navegación, como las pruebas interfaz usabilidad, debe realizarse por tantos departamentos como sea posible. usted tiene responsabilidad durante las primeras etapas prueba navegación, pero las etapas posteriores las deben realizar otros participantes proyecto, equipo prueba independiente , final cuentas, usuarios técnicos. -tención ejercitar navegación webapp profundidad. . rueba configuración variabilidad inestabilidad configuración son factores importantes que hacen prueba webapps desafío. hardware, los sistemas operativos, navegadores, capacidad almacenamiento, velocidades comunicación red varios otros factores lado cliente son difíciles predecir para cada usuario. además, configuración para usuario dado puede cambiar manera regular [por ejemplo, actualizaciones del sistema operativo (), nuevos isp velocidades conexión]. resultado puede ser entorno lado cliente que proclive errores sutiles significativos. impresión que usuario tiene webapp forma que interactúa con ella pueden diferir significativamente experiencia otro usuario ambos usuarios trabajan dentro misma configuración lado cliente. labor prueba configuración ejercitar toda configuración posible lado cliente. vez ello, probar conjunto probables configuraciones los lados cliente servidor para garantizar que experiencia del usuario será misma todos ellos que aislará los errores que puedan ser específicos una configuración particular. .. conflictos lado servidor lado servidor, los casos prueba configuración diseñan para verificar que confi-guración servidor proyectada [ decir, servidor webapp, servidor base datos, sistemas operativos, software firewall (cortafuegos), aplicaciones concurrentes] pueden soportar webapp sin error. esencia, webapp instaló dentro del entorno del lado servidor probó para asegurar que opera sin error. conforme diseñan las pruebas configuración del lado servidor, debe considerarse cada componente configuración del servidor. entre las preguntas que deben plantearse res-ponderse durante prueba configuración del lado servidor encuentran: • ¿ webapp completamente compatible con servidor ? • ¿los archivos sistema, directorios datos sistema relacionados crean correcta- mente cuando webapp operativa? • ¿las medidas seguridad del sistema (por ejemplo, firewalls encriptado) permiten webapp ejecutarse atender los usuarios sin interferencia degradación del rendi-miento? • ¿ webapp probó con configuración servidor distribuido ( existe alguno) que eligió?¿qué preguntas deben plantearse respon-derse conforme realiza prueba configuración lado servidor?? por ejemplo, puede usarse servidor aplicación separado servidor base datos. comunicación entre las dos máquinas ocurre través una conexión red. (-).indd (-).indd // ::// :: parte tres administración calidad • ¿ webapp integró adecuadamente con software base datos? ¿ webapp sensible diferentes versiones del software base datos? • ¿los guiones webapp lado servidor ejecutan adecuadamente? • ¿los errores del administrador del sistema examinaron sus efectos sobre las operaciones webapp? • usan servidores proxy, ¿las diferencias configuración abordaron con pruebas sitio? .. conflictos lado cliente lado cliente, las pruebas configuración enfocan con más peso compatibilidad webapp con las configuraciones que contienen una más permutas los siguientes com-ponentes [ngu]: • hardware: cpu, memoria, almacenamiento dispositivos impresión • sistemas operativos: linux, macintosh , microsoft windows, móvil • software navegador: firefox, safari, internet explorer, opera, chrome otros • componentes interfaz usuario: active , java applets otros • plug-ins: quicktime, realplayer muchos otros • conectividad: cable, dsl, módem regular, , wifi además estos componentes, otras variables incluyen software redes, caprichos isp aplicaciones que corren manera concurrente. para diseñar pruebas configuración lado cliente, debe reducir número variables configuración número manejable. para lograr esto, cada categoría usuario valora para determinar las probables configuraciones que pueden encontrarse dentro categoría. además, pueden usarse datos participación mercado para predecir las combinaciones componentes más probables. entonces webapp prueba dentro estos entornos. . rueba seguridad seguridad webapp tema complejo que debe comprenderse por completo antes que pueda lograrse una prueba seguridad efectiva. las webapps los entornos los lados cliente servidor donde albergan representan blanco atractivo para hackers externos, empleados descontentos, competidores deshonestos para quien quiera robar información sensible, modificar contenido maliciosamente, degradar rendimiento, deshabilitar funcio-nalidad avergonzar una persona, organización negocio. las pruebas seguridad diseñan para sondear las vulnerabilidades del entorno lado cliente, las comunicaciones red que ocurren conforme los datos pasan cliente servidor viceversa, entorno del lado servidor. cada uno estos dominios puede atacarse, tarea del examinador seguridad descubrir las debilidades que puedan explotar quienes ten-gan intención hacerlo. lado cliente, las vulnerabilidades con frecuencia pueden rastrearse errores preexis- tentes navegadores, programas correo electrónico software comunicación. nguyen [ngu] describe hueco seguridad común: aplicar pruebas toda combinación posible componentes configuración consume demasiado tiempo. los libros cross fischer [cro], andrews whittaker [and] trivedi [tri] proporcionan información útil acerca del tema.cita: “internet lugar riesgoso para realizar negocios alma-cenar valores. hackers, crackers, snoops, spoofers... vándalos, lanzadores virus proveedores programas maliciosos corren sus anchas.” dorothy peter denning (-).indd (-).indd // ::// :: prueba aplicaciones web uno los errores comúnmente mencionados desbordamiento buffer, que permite que código malicioso ejecute máquina cliente. por ejemplo, ingresar una url navegador que mucho más larga que tamaño buffer asignado para url provocará error sobreescritu- memoria (desbordamiento buffer) navegador tiene código detección error para validar longitud url ingresada. hacker experimentado puede explotar astutamente este error escribir una url larga con código que ejecutar que puede hacer que navegador derribe altere las configuraciones seguridad ( alto bajo) , peor aún, corromper datos del usuario. otra vulnerabilidad potencial lado cliente acceso autorizado las ookies - locadas dentro del navegador. los sitios web creados con intenciones maliciosas pueden adqui- rir información contenida dentro cookies legítimas usar esta información formas que ponen riesgo privacidad del usuario , peor aún, que montan escenario para robo identidad. los datos comunicados entre cliente servidor son vulnerables spoofing (engaño). spoofing ocurre cuando extremo ruta comunicación trastorna por una entidad con intenciones maliciosas. por ejemplo, usuario puede ser engañado por sitio malicioso que actúa como fuese servidor webapp legítimo (apariencia sensación idénticas). -tención robar contraseñas, información personal datos crédito. lado servidor, las vulnerabilidades incluyen ataques negación servicio guiones maliciosos que pueden pasar hacia lado cliente usarse para deshabilitar operaciones del servidor. además, puede accederse sin autorización las bases datos lado servidor (robo datos). para proteger contra éstas ( muchas otras) vulnerabilidades, implanta uno más los siguientes elementos seguridad [ngu]: • firewall: mecanismo filtrado, que una combinación hardware software que examina cada paquete información entrante para asegurarse que proviene una fuente legítima que bloquea cualquier dato sospechoso. • autenticación: mecanismo verificación que valida identidad todos los clientes servidores, permite que comunicación ocurra solamente cuando ambos lados verifican. • encriptado: mecanismo codificación que protege los datos sensibles modificarlos forma que hace imposible leerlos por quienes tienen intenciones maliciosas. encriptado fortalece usando certificados digitales que permiten cliente verificar destino que transmiten los datos. • autorización: mecanismo filtrado que permite acceso entorno cliente servidor sólo aquellos individuos con códigos autorización apropiados (por ejemplo, usuario contraseña). las pruebas seguridad deben diseñarse para sondear cada una estas tecnologías segu-ridad con intención descubrir huecos seguridad. diseño real las pruebas seguridad requiere conocimiento profundo del trabajo - terno cada elemento seguridad amplia comprensión una gran gama tecnologías redes. muchos casos, prueba seguridad subcontrata con firmas que especiali-zan dichas tecnologías. . rueba rendimiento nada más frustrante que una webapp que tarda minutos cargar contenido cuando sitios competencia descargan contenido similar segundos. nada más exasperante que webapp crucial para negocio, mantiene datos sensibles blanco probable los hackers, buena idea subcontratar pruebas seguridad con proveedor que especialice ellas.consejo punto clave las pruebas seguridad deben diseñarse para ejercitar firewalls, autenticación, encriptado autorización. (-).indd (-).indd // ::// :: parte tres administración calidad intentar ingresar una webapp recibir mensaje “servidor ocupado”, con sugerencia que intente nuevo más tarde. nada más desconcertante que una webapp que res- ponde instantáneamente algunas situaciones luego otras parece caer estado espera infinita. estos eventos suceden web todos los días todos ellos relacionan con rendimiento. las pruebas rendimiento usan para descubrir problemas rendimiento que pueden ser resultado : falta recursos lado servidor, red con ancho banda inadecuada, capaci-dades base datos inadecuadas, capacidades sistema operativo deficientes débiles, funcionalidad webapp pobremente diseñada otros conflictos hardware software que pueden conducir rendimiento cliente-servidor degradado. intención doble: ) compren-der cómo responde sistema conforme aumenta carga ( decir, número usuarios, -mero transacciones volumen datos global) ) recopilar mediciones que conducirán modificaciones diseño para mejorar rendimiento. .. objetivos prueba rendimiento las pruebas rendimiento diseñan para simular situaciones carga del mundo real. con-forme aumenta número usuarios simultáneos webapp número transacciones línea cantidad datos (descargados subidos), las pruebas rendimiento ayudarán responder las siguientes preguntas: • ¿ tiempo respuesta del servidor degrada punto donde apreciable inaceptable? • ¿ qué punto ( términos usuarios, transacciones carga datos) rendimiento vuelve inaceptable? • ¿qué componentes del sistema son responsables degradación del rendimiento? • ¿cuál tiempo respuesta promedio para los usuarios bajo diversas condiciones carga? • ¿ degradación del rendimiento tiene impacto sobre seguridad del sistema? • ¿ confiabilidad precisión webapp resulta afectada conforme crece carga sobre sistema? • ¿qué sucede cuando aplican cargas que son mayores que capacidad máxima del servidor? • ¿ degradación del rendimiento tiene impacto sobre los ingresos compañía? para desarrollar respuestas estas preguntas, realizan dos tipos diferentes pruebas rendimiento: ) prueba carga examina carga del mundo real varios niveles carga varias combinaciones, ) prueba esfuerzo fuerza aumentar carga hasta punto rompimiento para determinar cuánta capacidad puede manejar entorno webapp. cada una estas estrategias prueba considera las secciones siguientes. .. prueba carga intención prueba carga determinar cómo responderán las webapps entorno del lado servidor varias condiciones carga. conforme avanzan las pruebas, las permutas las siguientes variables definen conjunto condiciones prueba: , número usuarios concurrentes , número transacciones línea por unidad tiempo , carga datos procesados por servidor cada transacciónalgunos aspectos del rendimiento webapp, menos como los percibe usuario final, son difíciles poner prueba. carga red, los caprichos del hardware interfaz con red conflictos similares son fáciles poner prueba webapp.consejo (-).indd (-).indd // ::// :: prueba aplicaciones web todo caso, dichas variables definen dentro fronteras operativas normales del sistema. conforme aplica cada condición prueba, recopila una más las siguientes medidas: respuesta usuario promedio, tiempo promedio para descargar una unidad estandarizada datos tiempo promedio para procesar una transacción. estas medidas deben examinarse para determinar una disminución abrupta rendimiento puede rastrearse una combinación específica , . prueba carga también puede usarse para valorar las velocidades conexión recomen- dadas para los usuarios webapp. rendimiento global, , calcula forma -guiente: / / / tome como ejemplo sitio popular noticias deportivas. momento dado, usua-rios concurrentes envían una solicitud (una transacción, ) una vez cada minutos prome- dio. cada transacción requiere que webapp descargue nuevo artículo que promedia longitud. por tanto, rendimiento global puede calcularse como: / [ / . / ]/ / kbytes/ / megabits por segundo por ende, conexión red para servidor tendría que soportar esta tasa datos debería ponerse prueba para asegurarse que hace. .. prueba esfuerzo prueba esfuerzo una continuación prueba carga, pero esta instancia las -riables , fuerzan satisfacerse luego superan los límites operativos. intención estas pruebas responder cada una las siguientes preguntas: • ¿ sistema degrada “suavemente” servidor apaga conforme capacidad supera? • ¿ software servidor genera mensajes “servidor disponible”? manera más general, ¿los usuarios están conscientes que pueden llegar servidor? • ¿ servidor pone cola los recursos solicitados vacía cola una vez que disminuye demanda capacidad? • ¿las transacciones pierden conforme capacidad excede? • ¿ integridad los datos resulta afectada conforme capacidad excede? • ¿qué valores , fuerzan fallo del entorno servidor? ¿cómo manifiesta falla? ¿ envían notificaciones automáticas personal apoyo técnico sitio servidor? • sistema falla, ¿cuánto tiempo tardará regresar línea? • ¿ciertas funciones webapp (por ejemplo, funcionalidad cálculo intenso, capaci- dades transmisión datos) quedan descontinuadas conforme capacidad alcanza nivel por ciento? una variación las pruebas esfuerzo ocasiones conoce como prueba pico/- bote ( spike/bounce) [spl]. este régimen pruebas, carga alcanza pico capacidad, luego baja rápidamente condiciones operativas normales después alcanza nuevo pico. rebotar carga del sistema, posible determinar cuán bien servidor puede ordenar los recursos para satisfacer una demanda muy alta entonces liberarlos cuando reaparecen condiciones normales ( modo que esté listo para siguiente pico). una webapp usa múltiples servidores para proporcionar una capacidad significativa, prueba carga debe realizarse entorno multiservidor.consejo punto clave objetivo prueba esfuerzo comprender mejor manera como falla sistema medida que forzado más allá sus límites operacionales. (-).indd (-).indd // ::// :: parte tres administración calidad las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas que existen esta categoría. además, los nombres las herramientas son marcas registradas las compañías señaladas. ensayo acerca las pruebas los sistemas comercio electrónico, lam [lam] presenta una útil taxo- nomía herramientas automáticas que tienen aplicabilidad directa para probar contexto ingeniería web. anexan las herra-mientas representativas cada categoría. las herramientas configuración gestión conteni- gestionan versión cambian control los objetos conte-nido web los componentes funcionales. herramientas representativas: una lista amplia encuentra herramientas rendimiento base datos miden rendimiento base datos, como tiempo para realizar consultas seleccionadas bases datos. dichas herramientas facilitan optimización base datos. herramientas representativas: bmc software ( los depuradores son herramientas programación usuales que encuentran resuelven defectos software código. son parte mayoría los entornos modernos desarrollo aplicaciones. herramientas representativas: accelerated technology ( apple debugging tools (developer.apple.com/tools/ performance/) ibm visualage environment ( microsoft debugging tools ( sistemas gestión defecto registran los defectos ras- trean estado resolución. algunos incluyen herramientas reporte para ofrecer información gestión acerca disper-sión del defecto tasas resolución del mismo. herramientas representativas: excel quickbigs ( foresoft bugtrack ( mccabe truetrack ( herramientas monitoreo red vigilan nivel tráfi- red. son útiles para identificar cuellos botella red probar vínculo entre sistemas frontales traseros. herramientas representativas: una lista exhaustiva encuentra xorg/nmtf/nmtf-tools.html las herramientas prueba regresión almacenan casos prueba datos prueba, pueden volver aplicar los casos prueba después cambios sucesivos software. herramientas representativas: compuware qarun ( qacenter/qarun) rational visualtest ( seque software ( herramientas monitoreo sitio monitorean rendi- miento sitio, con frecuencia desde perspectiva del usua-rio. usan para recopilar estadísticas tales como tiempo res-puesta extremo extremo rendimiento global, para comprobar periódicamente disponibilidad sitio. herramientas representativas: keynote systems ( herramientas esfuerzo ayudan los desarrolladores explorar comportamiento del sistema bajo niveles altos uso operativo encuentran los puntos ruptura sistema. herramientas representativas: mercury interactive ( herramientas prueba fuente abierta ( testing.org/performance .php) web performance load tester ( com) los monitores recursos del sistema son par mayo- ría los servidores software servidor web; monitorean recursos tales como espacio disco, uso cpu memoria. herramientas representativas: successful hosting.com ( quest software foglight ( herramientas generación datos prueba auxilian los usuarios generación datos prueba. herramientas representativas: una lista exhaustiva encuentra com/qatweb.html los comparadores resultado prueba ayudan compa- rar los resultados conjunto pruebas con los otro con-junto. usan para comprobar que los cambios código han introducido cambios adversos comportamiento del sistema. herramientas representativas: una lista útil encuentra html los monitores transacción miden rendimiento los siste- mas procesamiento alto volumen transacciones. herramientas representativas: quotiumpro ( software research evalid ( html) las herramientas seguridad website ayudan detectar potenciales problemas seguridad. con frecuencia puede esta-blecerse sondeo seguridad herramientas monitoreo para correr sobre una base calendarizada. herramientas representativas: una lista amplia encuentra gies.com/products/ software taxonomía herramientas para prueba webapp (-).indd (-).indd // ::// :: prueba aplicaciones web . esumen meta prueba las webapps ejercitar cada una las muchas dimensiones calidad webapp con intención encontrar errores descubrir conflictos que puedan conducir fallas calidad. las pruebas enfocan contenido, función, estructura, usabilidad, -vegabilidad, rendimiento, compatibilidad, interacción, capacidad seguridad. estas pruebas incorporan revisiones que ocurren conforme diseña webapp pruebas que llevan cabo una vez que implanta misma. estrategia prueba webapps ejercita cada dimensión calidad examinar inicial- mente “unidades” contenido, funcionalidad navegación. una vez validadas las unidades individuales, atención cambia hacia pruebas que ejercitan webapp como todo. para lograr esto, muchas pruebas derivan desde perspectiva del usuario activan mediante información contenida casos uso. desarrolla plan prueba webapps identifican los pasos prueba, productos trabajo (por ejemplo, casos prueba) meca-nismos para evaluación los resultados prueba. proceso prueba abarca siete tipos diferentes pruebas. prueba contenido ( las revisiones) enfocan varias categorías contenido. intención descubrir errores semánticos sintácticos que afectan precisión del contenido forma que presenta usuario final. prueba interfaz ejercita los mecanismos interacción que permiten usuario comunicarse con webapp valida los aspectos estéticos interfaz. intención descubrir errores que resultan partir mecanismos interac-ción pobremente implantados omisiones, inconsistencias ambigüedades semántica interfaz. las pruebas navegación aplican casos uso, derivados actividad modelado, diseño casos prueba que ejercitan cada escenario uso contra diseño navega-ción. los mecanismos navegación ponen prueba para garantizar que cualquier error que impida completar caso uso identifique corrija. prueba componente ejercita las unidades contenido funcionales dentro webapp. prueba configuración intenta descubrir errores / problemas compatibilidad que son específicos entorno cliente servidor particular. entonces realizan pruebas para descubrir errores asociados con cada posible configuración. las pruebas seguridad incorpo-ran una serie pruebas diseñadas para explotar las vulnerabilidades webapp entorno. intención encontrar huecos seguridad. prueba rendimiento abarca una serie pruebas que diseñan para valorar tiempo respuesta confiabilidad webapp con- forme aumenta demanda capacidad recursos lado servidor. problemas puntos por evaluar .. ¿existen algunas situaciones las que prueba webapps deba descartarse por completo? .. con sus palabras, analice los objetivos las pruebas contexto webapp. .. compatibilidad una importante dimensión calidad. ¿qué debe probarse para garantizar que existe compatibilidad para una webapp? .. ¿cuáles errores tienden ser más serios: los que hay lado cliente los del lado servidor? ¿por qué? .. ¿qué elementos webapp pueden recibir “prueba unidad”? ¿qué tipos pruebas deben reali- zarse sólo después que integran los elementos webapp? .. ¿siempre necesario desarrollar plan prueba escrito formalmente? explique. (-).indd (-).indd // ::// :: parte tres administración calidad .. ¿ justo decir que estrategia prueba webapps global comienza con los elementos visibles para usuario que avanza hacia los elementos tecnológicos? ¿existen excepciones esta estrategia? .. ¿ prueba contenido realmente una prueba sentido convencional? explique... describa los pasos asociados con prueba base datos para una webapp. ¿ prueba base datos predominantemente una actividad lado cliente lado servidor?.. ¿cuál diferencia entre las pruebas que asocian con los mecanismos interfaz las que abordan semántica interfaz? .. suponga que desarrolla una farmacia línea ( farmaciadelaesquina.com) que abastece adul- tos mayores. farmacia proporciona las funciones usuales, pero también mantiene una base datos para cada cliente, modo que puede ofrecer información medicamentos advertir potenciales interaccio-nes medicamentosas. analice algunas pruebas usabilidad especiales para esta webapp. .. suponga que establece una función comprobación interacción medicamentosa para farma- ciadelaesquina.com (problema .). analice los tipos las pruebas nivel componente que deberían realizarse para garantizar que esta función opera adecuadamente. [nota: tendría que usar una base datos para establecer esta función]. .. ¿cuál diferencia entre probar sintaxis navegación probar semántica navegación?.. ¿ posible probar toda configuración que una webapp probablemente encuentre lado servidor? ¿ posible hacerlo lado cliente? , ¿cómo selecciona conjunto significativo pruebas con-figuración? .. ¿cuál objetivo prueba seguridad? ¿quién realiza esta prueba?.. farmaciadelaesquina.com (problema .) volvió muy exitosa número usuarios - mentó dramáticamente los primeros dos meses operación. dibuje una gráfica que muestre probable tiempo respuesta como función del número usuarios para conjunto fijo recursos lado ser-vidor. etiquete gráfica para indicar los puntos interés “curva respuesta”. .. respuesta éxito, farmaciadelaesquina.com (problema .) implementó servidor especial exclusivamente para manejar reabastecimiento recetas. promedio, usuarios concu-rrentes envían una solicitud reabastecimiento una vez cada dos minutos. respuesta, webapp des- carga bloque datos bytes. ¿cuál rendimiento global aproximado requerido para este ser-vidor megabits por segundo? .. ¿cuál diferencia entre prueba carga prueba esfuerzo? lecturas adicionales fuentes información literatura acerca pruebas webapps continúa evolucionando. los libros andrews whittaker (how break web software, addison-wesley, ), ash ( the web testing companion, wiley, ), nguyen . (testing applications for the web, . ., wiley, ), dustin . (quality web systems, addison-wesley, ) splaine jaskiel [spl] están entre los tratamientos más completos del tema publicados hasta fecha. mosley (client-server software testing the desktop and the web , prentice hall, ) aborda los temas prueba los lados cliente servidor. información útil acerca las estrategias métodos prueba webapps, así como valioso análisis las herramientas prueba automáticas, presenta stottlemeyer ( automated web testing toolkit, wiley, ). graham . (software test automation, addison-wesley, ) presentan material adicional acerca herramientas automáticas. microsoft (performance testing guidance for web applications, microsoft press, ) subraya (integrated approach web performance testing, irm press, ) exponen tratamientos detallados acerca prueba rendimiento para webapps. chirillo (hack attacks revealed, . ., wiley, ), splaine (testing web - curity, wiley, ), klevinsky . (hack ..: security through penetration testing, addison-wesley, ) skoudis (counter hack, prentice hall, ) proporcionan mucha información útil para quienes deben diseñar pruebas seguridad. además, los libros que abordan prueba seguridad para software general pue-den ofrecer una guía importante para quienes deben poner prueba webapps. los títulos representativos incluyen: basta halton (computer security and penetration testing, thomson delmar learning, ), - (-).indd (-).indd // ::// :: prueba aplicaciones web sopal . (the art software security testing, addison-wesley, ) gallagher . (hunting security bugs, microsoft press, ). internet está disponible gran variedad fuentes información acerca pruebas webapps. sitio del libro: puede encon- trarse una lista actualizada referencias que hay world wide web que son relevantes para las pruebas webapps. (-).indd (-).indd // ::// :: verificación formal conceptos clave certificación . . . . . . . . . . . . diseño cuarto limpio . . . . estructura caja . . . . . . . . . . . . . . . . especificación funcional . . . . especificación . . . . . . . . . . . . . . . . . . . . lenguaje restricción objeto (ocl). . . . . . . . . . lenguajes especificación formal . . . . . . . . . . . . . . . . modelo proceso cuarto limpio. . . . . . . . . . . . . . . . . refinamiento diseño . . . . exactitud . . . ¿qué ? ¿cuántas veces escuchado alguien decir “hazlo bien desde primera vez”? esto lograra software, habría considerablemente menos esfuerzo empleado innecesario. dos métodos avanzados ingeniería del software (ingeniería del software cuarto limpio métodos formales) ayudan equipo software “hacer- bien desde primera vez” proporcionar enfoque basado matemáticas para programar modelado capacidad verificar que modelo correcto. inge-niería del software cuarto limpio enfatiza verificación matemática exactitud antes que comience cons-trucción del programa certificación confiabilidad del software como parte actividad prueba. los métodos formales usan teoría conjuntos notación lógica para crear enunciado claro los hechos (reque-rimientos) que pueden analizarse para mejorar ( incluso probar) exactitud consistencia. línea base para ambos métodos creación software con tasas falla extremadamente bajas. ¿quién hace? ingeniero del software especialmente capacitado. ¿por qué importante? los errores obligan que haya revisiones. las revisiones toman tiempo aumentan los costos. ¿ sería bueno pudiera reducir dramáticamen- número errores (bugs) introducidos mientras software diseña construye? ésa premisa del modelado verificación formales. ¿cuáles son los pasos? los modelos requerimientos diseño crean usando notación especializada que susceptible verificación matemática. ingeniería software cuarto limpio usa representación estructura cajas que encapsulan sistema ( algún aspecto del mismo) nivel específico abstracción. verifica-ción exactitud aplica cuando está completo diseño estructura caja. una vez verificada exactitud para cada estructura caja, comienza prue- uso estadístico. los métodos formales traducen los requerimientos software una representación más formal aplicar notación heurística conjuntos fin definir invariante datos, estados operaciones para una función sistema. ¿cuál producto final? desarrolla modelo for- mal especializado requerimientos. registran los -sultados las pruebas exactitud uso estadístico. ¿cómo aseguro que hice bien? prueba exactitud formal aplica modelo requerimientos. prueba uso estadístico ejercita los escenarios uso para garantizar que descubren corrigen los errores funcionalidad del usuario. una mirada rápidaa diferencia las revisiones pruebas que comienzan una vez desarrollados los mode- los códigos software, modelado verificación formales incorporan métodos modelado especializados que integran con enfoques verificación prescritos. sin enfoque modelado adecuado, verificación puede lograrse. este capítulo analizan dos métodos modelado verificación formales: método ingeniería del software cuarto limpio los métodos formales. ambos requieren enfoque especificación especializado cada uno aplica método verificación único. los dos son bastante rigurosos comunidad ingeniería del software usa ninguno ellos amplia-mente. pero intenta construir software prueba balas, dichos métodos pueden ayudarle manera inconmensurable. vale pena aprenderlos. ingeniería del software cuarto limpio enfoque que enfatiza necesidad construir con exactitud software conforme éste desarrolla. lugar análisis, diseño, código, prueba ciclo depuración clásicos, enfoque cuarto limpio sugiere punto vista diferente [lin]: filosofía que hay detrás ingeniería del software cuarto limpio consiste evitar depen- dencia costosos procesos remoción defectos, escribir incrementos código justo pri-mera vez verificar exactitud antes examinarlo. modelo proceso incorpora certificación calidad estadística los incrementos código conforme acumulan sistema. (-).indd (-).indd // ::// :: modelado verificación formal muchas formas, enfoque cuarto limpio eleva ingeniería del software otro nivel, enfatizar necesidad probar exactitud. los modelos desarrollados que usan métodos formales describen mediante una sintaxis semántica formales que especifican funcionamiento comportamiento del sistema. especificación consiste matemática forma (por ejemplo, puede usarse cálculo predica-dos como base para lenguaje especificación formal). introducción los métodos formales, anthony hall [hal] hace comentario que aplica igualmente los métodos cuarto limpio: los métodos formales [ ingeniería del software cuarto limpio] son controversiales. sus defensores afirman que pueden revolucionar desarrollo [del software]. sus detractores creen que son imposi-blemente difíciles. mientras tanto, para mayoría gente, los métodos formales [ ingeniería del software cuarto limpio] son tan poco corrientes que difícil juzgar las afirmaciones rivales. este capítulo exploran los métodos modelado verificación formales examina impacto potencial sobre ingeniería del software los años por venir. . strategia cuarto limpio ingeniería del software cuarto limpio usa una versión especializada del modelo soft-ware incremental que introdujo capítulo . pequeños equipos software independien-tes desarrollan “una tubería incrementos software” [lin]. conforme cada incremento certifica, integra todo. por tanto, funcionalidad del sistema crece con tiempo. secuencia las tareas cuarto limpio para cada incremento ilustra figura .. dentro tubería incrementos cuarto limpio, ocurren las siguientes tareas: planeación del incremento. desarrolla plan proyecto que adopte estrategia incremental. crea funcionalidad cada incremento, tamaño proyectado -lendario desarrollo cuarto limpio. debe tenerse especial cuidado para garantizar que los incrementos certificados integrarán forma oportuna. recopilación requerimientos. desarrolla una descripción más detallada los requerimientos del cliente (para cada incremento), con uso técnicas similares las -troducidas capítulo . especificación estructura caja. usa método especificación que utilice las estructuras caja para describir especificación funcional. las estructuras caja “ aíslan, separan definición creativa comportamiento, datos procedimientos cada nivel refinamiento” [hev]. diseño formal. usar enfoque estructura cajas, diseño cuarto limpio una extensión natural sin costuras especificación. aunque posible hacer una dis-tinción clara entre las dos actividades, las especificaciones (llamadas cajas negras) refi- nan iterativamente (dentro incremento) para convertirse análogas los diseños arquitectónicos nivel componente (llamados cajas estado cajas claras, respec- tivamente). verificación exactitud. equipo cuarto limpio realiza una serie rigurosas acti- vidades verificación exactitud sobre diseño , luego, código. verificación (sec-ción ..) comienza con estructura caja (especificación) nivel más alto avanza hacia detalle código diseño. primer nivel verificación exactitud ocurre aplicar conjunto “preguntas exactitud” [lin]. esto demuestra que -pecificación correcta, usan métodos más formales (matemáticos) para verificación.cita: “ única forma que ocurran errores programa que autor los ponga ahí. conocen otros mecanismos [...] práctica correcta dirige evitar inserción errores , fallar esto, removerlos antes probarlo cualquier otra forma poner marcha programa.” harlan mills webref puede encontrarse una excelente fuente información recursos para ingeniería del software cuarto limpio. cita: “ ingeniería del software cuarto limpio logra control calidad estadístico sobre -sarrollo del software separar estrictamente proceso dise- del proceso prueba una tubería desarrollo incre-mental software.” harlan mills (-).indd (-).indd // ::// :: parte tres administración calidad generación, inspección verificación código. las especificaciones estructura caja, representadas lenguaje especializado, traducen lenguaje programa- ción adecuado. las revisiones técnicas (capítulo ) usan entonces para asegurar con-formidad semántica del código las estructuras código, así como exactitud sintáctica del código. luego realiza verificación exactitud para código fuente. planeación prueba estadística. analiza uso proyectado del software pla- nea diseña (sección .) una suite casos prueba que ejercitan una “distribución probabilidad” uso. figura ., esta actividad cuarto limpio realiza para-lelo con especificación, verificación generación código. prueba uso estadístico. recuerda que prueba exhaustiva del software computadora imposible (capítulo ), siempre necesario diseñar número finito casos prueba. las técnicas uso estadístico [poo] ejecutan una serie pruebas -rivadas una muestra estadística ( distribución probabilidad anotada anteriormente) todas las posibles ejecuciones programa efectuadas por todos los usuarios una población objetivo (sección .). certificación. una vez completadas verificación, inspección prueba uso ( todos los errores corregidos), incremento certifica como listo para integración. las primeras cuatro actividades proceso cuarto limpio establecen escenario para las actividades normales verificación que siguen. por esta razón, estudio del enfoque cuarto limpio comienza con las actividades modelado, que son esenciales para verificación formal que aplicar. . specificación funcional enfoque modelado ingeniería del software cuarto limpio usa método llamado especificación estructura caja . una “caja” encapsula sistema ( algún aspecto del mismo) cuarto limpio enfatiza las pruebas que ejercitan manera que software usa realmente. los casos uso proporcionan entrada proceso planeación prueba.consejobss rgincremento sefd tpcg sut bss rgincremento tpcg sut bss rgincremento — ingeniería sistema — recopilación requerimientosbss — especiﬁcación estructura cajafd — diseño formalcv — veriﬁcación exactitudcg — generación códigoci — inspección códigosut — prueba uso estadísticac — certiﬁcacióntp — planeación pruebafd tpcg sut cfigura . modelo proceso cuarto limpio (-).indd (-).indd // ::// :: modelado verificación formal algún nivel detalle. través proceso elaboración refinamiento por pasos, las cajas refinan una jerarquía donde cada caja tiene transparencia referencial. decir: “ información contenida cada especificación caja suficiente para definir refinamiento, sin depender implementación alguna otra caja” [lin]. esto permite analista dividir sistema jerárquicamente avanzar representación esencial parte superior -talle específico implementación fondo. para ello, usan tres tipos cajas: caja negra. caja negra especifica comportamiento sistema una parte sistema. sistema ( parte) responde estímulos específicos (eventos) aplicar conjunto reglas transición que mapean estímulo una respuesta. caja estado. caja estado encapsula los datos servicios (operaciones) - tado una forma análoga los objetos. esta visión especificación, representan las entradas (estímulos) salidas (respuestas) caja estado. caja estado tam-bién representa “historia estímulos” caja negra, decir, los datos encapsulados caja estado que deben conservarse entre las transiciones implicadas. caja clara. las funciones transición que implican mediante caja estado - finen caja clara. dicho manera simple, una caja clara contiene diseño proce-dimientos para caja estado. figura . ilustra enfoque refinamiento, usando especificación estructura cajas. una caja negra ( ) define las respuestas conjunto completo estímulos. puede refinarse conjunto cajas negras, . ., cada una las cuales enfoca una clase comportamiento. refinamiento continúa hasta que identifica una clase cohesi- comportamiento (por ejemplo, ..). entonces define una caja estado (..) para caja negra (..). este caso, .. contiene todos los datos servicios requeridos para implementar comportamiento definido por ... finalmente, .. refina cajas claras (...) especifican los detalles del diseño procedimientos. conforme ocurre cada uno estos pasos refinamiento, también presenta verifica- ción exactitud. las especificaciones caja estado verifican para asegurar que cada una conforma acuerdo con comportamiento definido por especificación caja -gra padre. igual modo, las especificaciones caja clara verifican contra caja estado padre. ... ... ....... .. ... . .nfigura . refinamiento estructura cajascita: “hay algo divertido vida: rechazas aceptar todo menos mejor, con mucha frecuencia conseguirás.” . somerset maugham ¿cómo logra refinamiento como parte una especificación estructura caja?? punto clave refinamiento estructura cajas verificación exactitud ocurren simultáneamente. (-).indd (-).indd // ::// :: parte tres administración calidad .. especificación caja negra una especificación caja negra describe una abstracción, estímulos respuesta, usando notación que muestra figura . [mil]. función aplica una secuencia * entradas (estímulos) las transforma una salida (respuesta) . para componentes soft- ware simples, puede ser una función matemática, pero, general, describe usando len- guaje natural ( lenguaje especificación formal). muchos los conceptos introducidos para los sistemas orientados objetos también son aplicables para caja negra. las abstracciones datos las operaciones que manipulan -chas abstracciones encapsulan mediante caja negra. como una jerarquía clases, -pecificación caja negra puede mostrar jerarquías uso las que las cajas nivel inferior heredan las propiedades las cajas superiores que hay estructura del árbol. .. especificación caja estado caja estado “una simple generalización una máquina estado” [mil]. - cuerda análisis acerca del modelado comportamiento los diagramas estado estu-diados capítulo , estado modo observable comportamiento del sistema. conforme ocurre procesamiento, sistema responde los eventos (estímulos), haciendo una transición desde estado actual hasta algún estado nuevo. conforme realiza transi-ción, puede ocurrir una acción. caja estado usa una abstracción datos para determinar transición siguiente estado acción (respuesta) que ocurrirá como consecuencia transición. figura ., caja estado incorpora una caja negra . estímulo que entrada caja negra llega desde alguna fuente externa desde conjunto estados internos del sistema . mills [mil] proporciona una descripción matemática función caja negra contenida dentro caja estado: : * / * → / : * rfigura . especificación caja negra caja negra, gtestadofigura . una especificación caja estado (-).indd (-).indd // ::// :: modelado verificación formal donde una subfunción que liga estado específico . cuando consideran manera colectiva, los pares subfunción estado (, ) definen función caja negra. .. especificación caja clara especificación caja clara está cercanamente alineada con diseño procedural con programación estructurada. esencia, subfunción dentro caja estado sustituye con los constructos programación estructurada que implementan . como ejemplo, considere caja clara que muestra figura .. caja negra , que muestra figura ., sustituye por constructo secuencia que incorpora condi-cional. éste, vez, puede refinarse las cajas claras nivel inferior conforme avanza refinamiento por pasos. importante observar que puede probarse que especificación descrita jerarquía caja clara correcta. este tema considera sección .. . iseño cuarto limpio ingeniería del software cuarto limpio utiliza mucho filosofía programación estructu-rada (capítulo ). pero, este caso, programación estructurada aplica manera mucho más rigurosa. las funciones procesamiento básico (descritas durante los primeros refinamientos especificación) refinan usando una “expansión pasos funciones matemáticas estruc-turas conectivos lógicos [por ejemplo, -then-else] subfunciones, donde expansión [] realiza hasta que todas las subfunciones identificadas puedan enunciarse directamente lenguaje programación utilizado para implementación” [dye]. enfoque programación estructurada puede usarse manera efectiva para refinar fun- ciones. pero ¿qué hay del diseño? aquí entran juego algunos conceptos diseño fundamen-tales (capítulo ). los datos programa encapsulan como conjunto abstracciones que son atendidas por subfunciones. los conceptos encapsulamiento datos, ocultamiento información escritura datos usan para crear diseño datos. .. refinamiento diseño cada especificación caja clara representa diseño procedimiento (subfunción) reque-rido para lograr una transición caja estado. dentro caja clara usan constructos programación estructurada refinamiento por pasos para representar detalles procedurales. por ejemplo, una función programa refina una secuencia subfunciones . éstas rtestado . una especificación caja clara (-).indd (-).indd // ::// :: parte tres administración calidad vez refinan constructos condicionales (por ejemplo, -then-else -while). mayor refinamiento continúa hasta que hay suficiente detalle procedural para crear componente cuestión. cada nivel refinamiento, equipo cuarto limpio realiza una verificación formal exactitud. para lograr esto, los constructos programación estructurada une conjunto condiciones exactitud genéricas. una función expande una secuencia , condición exactitud para toda entrada • ¿ seguida hace ? cuando una función refina una condicional forma “ // then , else ”, condi- ción exactitud para toda entrada • siempre que condición // verdadera, ¿ hace ?; siempre que // falsa, ¿ hace ? cuando función refina como ciclo, las condiciones exactitud para toda entrada son • ¿está garantizada finalización? • siempre que // verdadera, ¿ seguida por hace ?; siempre que // falsa, ¿saltar ciclo todavía hace ? cada vez que una caja clara refina siguiente nivel detalle, aplican dichas condiciones exactitud. .. verificación diseño debe observar que uso los constructos programación estructurada restringen número pruebas exactitud que deben realizarse. una sola condición verifica para secuencias; dos condiciones prueban para -then-elseo tres condiciones verifican para ciclo. para ilustrar verificación exactitud para diseño procedural, use ejemplo simple, introducido por primera vez por linger, mills witt [lin]. intención diseñar verificar pequeño programa que encuentre parte entera una raíz cuadrada entero dado . diseño procedural representa usando diagrama flujo figura .. para verificar exactitud este diseño, las condiciones entrada salida agregan como muestra figura .. condición entrada observa que debe ser mayor que igual . condición salida requiere que permanezca invariable que satisfaga expresión anotada figura. para probar que diseño correcto, necesario probar que las condi-ciones init, loop, cont, yes exit, que muestran figura ., son verdaderas todos los casos. ocasiones esto conoce como subpruebas. . condición init demanda que [ ≥ = ]. con base los requerimientos del pro- blema, condición entrada supone correcta. por tanto, satisface primera parte condición init, / . diagrama flujo, enunciado inmediatamente anterior condición init establece = . por tanto, segunda parte condición init también satisface. consecuencia, init verdadera. . condición loop puede encontrarse una dos formas: ) directamente init ( este caso, condición loop satisface directamente) por medio del flujo control puesto que todo equipo está involucrado proceso verificación, menos probable que cometa error realizar verificación . figura . adaptó [lin]. utilizada con permiso. este contexto tiene validez valor negativo para raíz cuadrada.¿qué condiciones aplican para probar exactitud los constructos estructurados?? limita sólo constructos estructurados mientras desarrolla diseño procedural, prueba exactitud directa. viola los constructos, las pruebas exactitud son difíciles imposibles.consejo (-).indd (-).indd // ::// :: modelado verificación formal que pasa través condición cont. dado que condición cont idéntica con- dición loop, ésta verdadera sin importar trayectoria flujo que conduce ella. . condición cont encuentra solamente después que valor aumenta . además, ruta flujo control que conduce cont puede vocarse sólo condi- ción yes también verdadera. por tanto, ( / ) / sigue que / . satisface condición cont. . condición yes prueba lógica condicional que muestra. por ende , condi- ción yes debe ser verdadera cuando flujo control mueve largo trayec- toria mostrada. . condición exit demanda primero que permanezca variable. examen del diseño indica que aparece izquierda operador asignación. hay llamadas función que usen . consecuencia, invariable. puesto que prueba condicional ( / ) / debe fallar para alcanzar condición exit, sigue que ( / ) / . ade- más, condición loop debe incluso ser verdadera ( decir, / ). por tanto, ( / ) / / pueden combinarse para satisfacer condición exit. adicionalmente, debe asegurarse que ciclo termina. examen condición loop indica que, dado que incrementa ≥ , ciclo finalmente debe terminar. los cinco pasos recién señalados son una prueba exactitud del diseño del algoritmo anotado figura .. entonces está seguro que diseño, hecho, calculará parte entera una raíz cuadrada. posible enfoque matemático más riguroso para verificar diseño. sin embargo, estudio este tema está más allá del ámbito este libro. tiene interés ello, consulte [lin]. . ruebas cuarto limpio estrategia tácticas las pruebas cuarto limpio son fundamentalmente diferentes las los enfoques prueba convencionales (capítulos del ). los métodos convencionales derivan conjunto casos prueba para descubrir errores diseño codificación. meta punto clave para probar que diseño correcto, primero deben identificarse todas las condiciones luego probar que cada una toma valor booleano adecuado. éstas les llama subpruebas. := + ( + ) ≤ := exit: cambia ≤ ≤ ( + ): ( + ) ≤ xloop: [ ≤ ] cont: [ ≤ ]init: [ ≥ , = ]entry: [ ≥ ]figura . cálculo parte entera una raíz cuadradafuente: [lin]. (-).indd (-).indd // ::// :: parte tres administración calidad prueba cuarto limpio validar los requerimientos software demostrar que una muestra estadística casos uso (capítulo ) ejecuta exitosamente. .. pruebas uso estadístico usuario programa computadora rara vez necesita entender los detalles técnicos del diseño. comportamiento del programa visible usuario activa con entradas eventos que con frecuencia son producidos por usuario. pero los sistemas complejos, posible espec-tro entrada eventos ( decir, los casos uso) puede ser extremadamente amplio. ¿qué subconjunto casos uso verificará manera adecuada comportamiento del programa? ésta primera pregunta que enfoca las pruebas uso estadístico. prueba uso estadístico “equivale examinar software forma que los usua- rios pretenden usarlo” [lin]. para lograr esto, los equipos prueba cuarto limpio (tam-bién llamados equipos certificación ) deben determinar una distribución probabilidad uso para software. especificación (caja negra) para cada incremento del software analiza fin definir conjunto estímulos (entradas eventos) que hacen que software cambie comportamiento. creación escenarios uso una comprensión general del dominio aplicación, cada estímulo asigna una probabilidad uso con base entre-vistas con usuarios potenciales. para cada conjunto estímulos generan casos prueba acuerdo con distribución probabilidad uso. para ilustrar anterior, considere sistema casasegura que estudió anteriormente este libro. ingeniería del software cuarto limpio usó para desarrollar incremento software que gestiona interacción del usuario con teclado del sistema seguridad. para este incremento identificaron cinco estímulos. los análisis indican distri-bución probabilidad porcentual cada estímulo. para seleccionar con facilidad los casos prueba, dichas probabilidades mapean intervalos numerados entre [lin] ilustran siguiente tabla: estímulo del programa probabilidad intervalo armar/desarmar () % – establecer zona () % – consulta () % – prueba () % – alarma pánico % – para generar una secuencia casos prueba uso que ajusten distribución probabilidad uso, generan números aleatorios entre . cada número aleatorio corres- ponde intervalo distribución probabilidad precedente. por tanto, secuencia casos prueba uso define azar, pero corresponde probabilidad adecuada ocu-rrencia del estímulo. por ejemplo, suponga que generan las siguientes secuencias números aleatorios: --------------- seleccionar los estímulos adecuados con base intervalo distribución que muestra tabla, derivan los siguientes casos uso:cita: “ calidad acto, hábito.” aristóteles incluso decide usar enfoque cuarto limpio, vale pena considerar las pruebas uso estadístico como parte integral estrategia pruebas.consejo puede usar herramientas automatizadas para lograr esto. para mayor información, consulte [dye]. (-).indd (-).indd // ::// :: modelado verificación formal ––––– ––––––adad––––– equipo prueba los ejecuta, verifica comportamiento del software contrastándolo con especificación para sistema. temporización las pruebas registra modo que pue-dan determinarse los intervalos tiempo. usar intervalos tiempo, equipo certifica-ción puede calcular tiempo medio hasta fallo (tmhf). una larga secuencia pruebas realiza sin fallas, tmhf bajo confiabilidad del software puede suponerse alta. .. certificación las técnicas verificación prueba analizadas anteriormente este capítulo conducen componentes software ( incrementos completos) que pueden certificarse. dentro del con-texto del enfoque ingeniería del software cuarto limpio, certificación implica que confiabilidad (medida por tmhf) puede especificarse para cada componente. impacto potencial los componentes software certificables más allá solo proyecto cuarto limpio. los componentes software reutilizables pueden almacenarse junto con sus escenarios uso, estímulos programa distribuciones probabilidad. cada componente tendría una confiabilidad certificada bajo escenario uso régimen prue-bas descritos. esta información invaluable para otros que quieran usar los componentes. enfoque certificación involucra cinco pasos [woh]: ) crean escenarios uso, ) especifica perfil uso, ) generan casos prueba partir del perfil, ) las pruebas ejecutan los datos fallo registran analizan, ) calcula confiabilidad certifica. los pasos del analizaron una sección anterior. certificación para ingeniería del software cuarto limpio requiere creación tres modelos [poo]: modelo muestreo. prueba software ejecuta casos prueba aleatorios certifica ocurren fallos número específico ellos. valor deriva mate- máticamente para asegurar que logra confiabilidad requerida. modelo componente. certifica sistema compuesto componentes. - delo componentes permite analista determinar probabilidad que componente fallará antes conclusión. modelo certificación. confiabilidad global del sistema proyecta certifica. completar las pruebas uso estadístico, equipo certificación tiene información - querida para entregar software que tenga tmhf certificado, usando cada uno estos modelos. tiene más interés, vea [cur], [mus] [poo], para detalles adicionales. . onceptos métodos formales the encyclopedia software engineering [mar] define los métodos formales forma - guiente: los métodos formales utilizados para desarrollar sistemas cómputo son técnicas con base mate- mática para describir las propiedades del sistema. tales métodos formales proporcionan marcos conceptuales dentro los cuales las personas pueden especificar, desarrollar verificar los sistemas forma sistemática más que hoc. las propiedades deseadas una especificación formal (consistencia, completitud falta ambigüedad) son los objetivos todos los métodos especificación. sin embargo, lenguaje especificación con base matemática que utiliza para los métodos formales como resul-tado una probabilidad mucho mayor lograr dichas propiedades. sintaxis formal ¿cómo certifica componente software?? (-).indd (-).indd // ::// :: parte tres administración calidad lenguaje especificación (sección .) permite que los requerimientos diseño interpre- ten sólo una forma, que elimina ambigüedad que con frecuencia ocurre cuando lector debe interpretar lenguaje natural (por ejemplo, inglés) una notación gráfica (por ejemplo, uml). las facilidades descriptivas teoría conjuntos notación lógica permiten enunciado claro los requerimientos. para ser consistente, los requerimientos enunciados lugar dentro una especificación deben contradecirse otro lugar. consistencia logra probar matemáticamente que los hechos iniciales pueden mapearse formalmente (usando reglas inferencia) los enunciados ulteriores dentro especificación. para presentar los conceptos los métodos formales básicos, considere algunos ejemplos simples fin ilustrar uso especificación matemática, sin empantanarse demasia-dos detalles matemáticos. ejemplo : una tabla simbólica. programa usa para mantener una tabla simbólica. dicha tabla utiliza frecuentemente muchos tipos diferentes aplicaciones. consiste una colección ítems sin duplicación alguna. figura . muestra ejemplo una tabla simbólica típica. ella representa tabla que utiliza sistema operativo para con-tener los nombres los usuarios del sistema. otros ejemplos tablas incluyen colección nombres del personal sistema nómina, colección nombres las computadoras sistema comunicaciones red colección los destinos sistema para pro-ducir horarios transportes. suponga que tabla que presenta este ejemplo contiene más maxids nombres. esta afirmación, que coloca una restricción sobre tabla, componente una condición conocida como variante datos: una condición que verdadera largo ejecución sistema que contiene una colección datos. invariante datos que sostiene para tabla simbólica recién analizada tiene dos componentes: ) que tabla contendrá más maxids nombres ) que habrá nombres duplicados tabla. caso del programa tabla simbólica, esto significa que cualquier momento que examine tabla sim-bólica durante ejecución del sistema, siempre contendrá más maxids nombres contendrá duplicados. otro concepto importante estado. muchos lenguajes formales, como ocl (sección ..), usan noción estado que estudió capítulo , decir, sistema puede cita: “los métodos formales tienen tremendo potencial para mejorar claridad precisión las especificaciones los requerimientos, para encon-trar errores importantes sutiles.” steve easterbrook . realidad, completitud difícil garantizar, aun cuando usen métodos formales. algunos aspectos sistema pueden quedar indefinidos conforme cree especificación; otras características pueden omitirse propósito fin permitir los diseñadores cierta libertad para escoger enfoque implementación; , -nalmente, imposible considerar todo escenario operativo sistema grande complejo. las cosas pueden omitirse simplemente por equivocación.. ........ .wilsonsimpsonabelfernandez maxids = . una tabla simbólicapunto clave una invariante datos conjunto condiciones que son verdaderas largo ejecución del sistema que contiene una colección datos. (-).indd (-).indd // ::// :: modelado verificación formal estar uno muchos estados cada uno representa modo comportamiento observable manera externa. sin embargo, una definición diferente para término estado usa lenguaje (sección ..). ( lenguajes relacionados), estado sistema -presenta por los datos almacenados del sistema (por ende, sugiere número mucho mayor estados, que representa cada posible configuración los datos). usar última defini-ción ejemplo del programa tabla simbólica, estado tabla simbólica. concepto final operación. ésta una acción que tiene lugar dentro sistema que lee escribe datos. programa tabla simbólica tiene que ver con agregar remover nombres tabla simbólica, entonces asociará con dos operaciones: una operación para add() (agregar) nombre específico tabla simbólica otra para remove() (remover) nombre existente tabla. programa proporciona facilidad para comprobar nombre específico está contenido tabla, entonces habría una operación que regresaría alguna indicación acerca nombre está tabla. pueden asociarse tres tipos condiciones con las operaciones: invariantes, precondiciones poscondiciones. una invariante define que garantiza que cambia. por ejemplo, tabla simbólica tiene una invariante que afirma que número elementos siempre menor que igual maxids. una precondición define las circunstancias las cuales válida una operación particular. por ejemplo, precondición para una operación que agrega nombre una tabla simbólica identificadores personal válida sólo nombre que agrega está con-tenido tabla también hay menos maxids identificadores personal ella. poscondición una operación define que garantiza que verdadero hasta completar una operación. esto define por efecto sobre los datos. para operación add( ), poscondición especificaría matemáticamente que tabla aumentó con nuevo identificador. ejemplo : manipulador bloques. una las partes más importantes sistema operativo simple subsistema que mantiene los archivos creados por los usuarios. parte del subsistema llenado manipulador bloques. almacén archivos está compuesto bloques almacenamiento que mantienen dispositivo almacenamiento archi-vos. durante operación computadora, crearán borrarán archivos, que requiere adquisición liberación bloques almacenamiento. para poder lidiar con esto, subsis-tema llenado mantendrá reservorio bloques utilizados (libres) seguirá pista los bloques que estén uso actual. cuando los bloques liberan archivo borrado, por general agregan una fila bloques que esperan para incorporarse reservorio bloques utilizados. esto muestra figura ., donde presentan algunos componentes: reservorio bloques utilizados, los bloques que actualidad constituyen los archi-vos administrados por sistema operativo los bloques que esperan agregarse reservorio. los bloques que esperan mantienen una fila que cada elemento contiene conjunto bloques archivo borrado. para este subsistema, estado colección bloques libres, colección bloques usados fila bloques regresados. invariante datos, que expresa lenguaje natural, • ningún bloque marcará como utilizado usado mismo tiempo. • todos los conjuntos bloques que conservan fila serán subconjuntos colección los bloques actualmente utilizados. • ningún elemento fila contendrá mismo número bloque. • colección bloques utilizados bloques que usan será colección total bloques que constituyen los archivos.otra forma apreciar noción estado señalar que los datos determinan estado. decir, puede examinar los datos para ver qué estado encuentra sistema.consejo debe observarse que agregar nombre puede ocurrir estado full (lleno) borrar nombre impo- sible estado empty (vacío).las técnicas lluvia ideas pueden funcionar bien cuando debe desarrollar una invariante datos para una función razonablemente compleja. haga que los miembros del equipo software escriban enlaces, restricciones limitaciones para función; luego, combínelas edítelas.consejo (-).indd (-).indd // ::// :: parte tres administración calidad • colección bloques utilizados tendrá números bloque duplicados. • colección bloques utilizados tendrá números bloque duplicados. algunas las operaciones asociadas con estos datos son: add() una colección bloques final fila, remove() una colección bloques usados del frente fila colocarlos colección bloques utilizados, check() (comprobar) fila bloques está vacía. precondición add() que los bloques que van agregar deben estar colección bloques usados. poscondición que colección bloques ahora encuentra - nal fila. precondición remove() que fila debe tener menos ítem. poscon-dición que los bloques deben agregarse colección bloques utilizados. operación check() tiene precondición. esto significa que operación siempre está definida, sin importar qué valor tenga estado. poscondición entrega valor true (verdadero) fila está vacía false (falso) otro modo. los ejemplos anotados esta sección, introducen los conceptos clave especifica- ción formal, pero sin enfatizar las matemáticas que requieren para hacer formal especifi-cación. sección ., considera cómo puede usarse notación matemática para espe-cificar manera formal algún elemento del sistema. . plicación notación matemática para especificación formal para ilustrar uso notación matemática especificación formal componente software, revise ejemplo del manipulador bloques que presentó sección .. fin revisarlos, importante componente del sistema operativo una computadora mantiene los archivos que crearon los usuarios. manipulador bloques mantiene reservorio bloques sin utilizar también seguirá pista los bloques que estén uso momento. cuando los bloques liberan archivo borrado, por general agregan una fila bloques que esperan para agregarse reservorio bloques utilizados. esto muestra manera esquemática figura .. archivo # archivo # archivo # fila bloques que contiene bloques archivos borradosbloques utilizados para entrar los bloques utilizados utilizados bloques liberadosa ﬁla cuandose borran archivosfigura . manipulador bloques esta sección escribió suponiendo que lector está familiarizado con notación matemática asociada con conjuntos secuencias, con notación lógica que usa cálculo predicados. necesita repaso, sitio web . edición este libro presenta una breve revisión como recurso complementario. para información más detallada, vea [jec] [pot]. (-).indd (-).indd // ::// :: modelado verificación formal conjunto llamado blocks (bloques) consistirá todo número bloques. allblocks (- dos los bloques) conjunto bloques que encuentra entre maxblocks (máximo bloques). estado modelará mediante dos conjuntos una secuencia. los dos conjuntos son used (utilizado) free (libre). ambos contienen bloques: conjunto used contiene los que - tualmente usan los archivos conjunto free los que están disponibles para nuevos archivos. secuencia contendrá conjuntos bloques que están listos para ser liberados los archivos que borraron. estado puede describirse como used, free: / blocksblockqueue: seq / blocks esto muy parecido declaración las variables programa. afirma que used free serán conjuntos bloques que blockqueu (fila bloques) será una secuencia, cada elemento cual será conjunto bloques. invariante datos puede escribirse como used / free / ∅ / / free / allblocks // : dom blockqueue • blockqueue / used // , : dom blockqueue • / / blockqueue / blockqueue / ∅ los componentes matemáticos invariante datos coinciden con cuatro las caracterís-ticas los componentes lenguaje natural descritos anteriormente. primera línea variante datos afirma que habrá bloques comunes colección utilizada las colecciones libres bloques. segunda afirma que colección bloques utilizados bloques libres siempre será igual colección completa bloques sistema. tercera línea indica que -ésimo elemento fila bloques siempre será subconjunto los bloques utilizados. línea final afirma que, para cualesquiera dos elementos fila blo-ques que son mismo, habrá bloques comunes dichos elementos. los dos compo-nentes lenguaje natural finales invariante datos implementan virtud del hecho que used free son conjuntos , por tanto, contendrán duplicados. primera operación por definir aquella que remueve elemento cabeza fila bloques. precondición que debe haber menos ítem fila: #blockqueue / , poscondición que cabeza fila debe removerse colocarse colección blo-ques libres fila debe ajustarse para mostrar remoción: used′ / used \ head blockqueue /′ / free / head blockqueue /′ / tail blockqueue una convención que usa muchos métodos formales que valor una variable des-pués una operación prima. consecuencia, primer componente expresión pre-cedente afirma que los nuevos bloques usados ( used’) serán iguales los antiguos bloques usados menos los bloques que removieron. segundo componente señala que los nuevos bloques libres (free’) serán los antiguos bloques libres, con agregado cabeza fila bloques. tercer componente afirma que nueva fila bloques será igual fila del valor antiguo fila bloques, decir, todos los elementos fila menos primero. una segunda operación agrega una colección bloques, ablocks, fila bloques. precondi-ción que ablocks actualidad conjunto bloques utilizados: ablocks / used poscondición que conjunto bloques agrega final fila bloques con-junto bloques usados libres permanece invariable:¿cómo pueden representarse estados invariantes datos usando conjunto operadores lógicos?? ¿cómo representan las precondiciones las poscondiciones??webref amplia información los métodos formales puede encontrar ... (-).indd (-).indd // ::// :: parte tres administración calidad blockqueue′ / blockqueue / ⟨ablocks ⟩ / used′ / used / free′ / free hay duda que especificación matemática fila bloques considerablemente más rigurosa que una narrativa lenguaje natural que modelo gráfico. rigor adicional requiere esfuerzo, pero los beneficios obtenidos consistencia mejorada completitud pueden justificarse para algunos dominios aplicación. . enguajes especificación formal lenguaje especificación formal por general compone tres componentes primarios: ) una sintaxis que define notación específica con que representa especificación, ) semántica para ayudar definir “universo objetos” [win] que usarán para describir sistema ) conjunto relaciones que definen las reglas que indican cuáles objetos -tisfacen adecuadamente especificación. dominio sintáctico lenguaje especificación formal con frecuencia basa una sintaxis que deriva notación estándar teoría conjuntos del cálculo predi-cados. dominio semántico lenguaje especificación indica cómo representa lenguaje los requerimientos del sistema. posible usar diferentes abstracciones semánticas para describir mismo sistema for- mas distintas. los capítulos , hizo esto manera menos formal. representaron información, función comportamiento. para representar mismo sistema, puede usarse una notación modelado diferente. semántica cada representación proporciona visiones complementarias del sistema. para ilustrar este enfoque cuando usan métodos formales, suponga que utiliza lenguaje especificación formal para describir conjunto eventos que hacen que ocurra estado particular sistema. otra relación formal muestra todas las funciones que ocurren dentro estado determinado. intersección estas dos rela-ciones proporciona indicio los eventos que producirán funciones específicas. actualidad usan varios lenguajes especificación formales. ocl [omg], [iso], larch [gut] vdm [jon] son lenguajes especificación formal representativos que muestran las características anotadas anteriormente. este capítulo presenta breve estudio ocl . .. lenguaje restricción objeto (ocl) lenguaje restricción objeto (ocl) una notación formal desarrollada modo que los usuarios uml puedan agregar más precisión sus especificaciones. lenguaje está dis-ponible todo poder lógica matemática discreta. sin embargo, los diseñadores ocl decidieron que, los enunciados ocl, sólo deberían usarse caracteres ascii ( lugar notación matemática tradicional). esto hace que lenguaje sea más amistoso para las personas que tienen menos inclinación matemática que computadora procese más fácil-mente. pero también hace ocl poco farragoso algunos lugares. para usar ocl, comience con uno más diagramas uml: los diagramas clase, estado actividad más comunes (apéndice ). agregan expresiones ocl hechos estado acerca elementos los diagramas. dichas expresiones llaman restricciones; cualquier implementa-ción derivada del modelo debe asegurar que cada una las restricciones siempre sigue siendo verdadera. esta sección aportación del profesor timothy lethbridge, universidad ottawa, presenta aquí con permiso. (-).indd (-).indd // ::// :: modelado verificación formal como lenguaje programación orientado objeto, una expresión ocl involucra opera- dores que operan sobre objetos. sin embargo, resultado una expresión completa siempre debe ser booleana, decir, verdadero falso. los objetos pueden ser instancias clase collection ocl, cual set (conjunto) sequence (secuencia) son dos subclases. objeto self elemento del diagrama uml cuyo contexto evaluará expresión ocl. navegar usando símbolo. (punto) del objeto self pueden obtenerse otros objetos. por ejemplo: • self clase , con atributo , entonces self. evalúa objeto almacenado . • tiene una asociación uno muchos llamada assoc con otra clase , entonces self. assoc evalúa set cuyos elementos son del tipo . • finalmente ( poco más sutilmente), tiene atributo , entonces expresión self.assoc. evalúa conjunto todos los que pertenecen todos los .tabla . resumen notación ocl clave . obtiene propiedad del objeto . una propiedad puede ser atributo, conjunto objetos final una asociación, resultado evaluar una operación otras cosas, dependiendo del tipo diagrama uml. conjunto, entonces aplica cada elemento ; los resultados recopilan nuevo conjunto. //() aplica operación interna ocl colección ( oposición cada uno los objetos ). continuación mencionan ejemplos operaciones internas. and, , /, // and lógica, lógica, igual, igual. implica verdadero verdadero falso. muestra operaciones sobre colecciones (incluidos conjuntos secuencias) //() número elementos colección . //() verdadero tiene elementos, falso otro modo. //() verdadero cada elemento encuentra . //() verdadero ningún elemento encuentra . //(elem | boolexpr) verdadero boolexpr verdadera cuando aplica cada elemento . conforme evalúa elemento, enlaza variable elem, que puede usarse boolexpr. esto implementa cuantificación universal, que estudió anteriormente. //(elem, elem | boolexpr) igual que anterior, excepto que boolexpr evalúa para cada posible par elementos tomados , incluidos casos donde par tiene mismo elemento. //(elem | expr) verdadero expr evalúa valor diferente cuando aplica cada elemento . muestra operaciones específicas para conjuntos //() conjunto aquellos elementos que encuentran también . //() conjunto aquellos elementos que encuentran . //() conjunto con omisión del objeto . muestra operación específica secuenciasseq//() objeto que primer elemento secuencia seq. (-).indd (-).indd // ::// :: parte tres administración calidad ocl proporciona operaciones internas que implementan operadores conjunto lógicos, especificación constructiva matemáticas relacionadas. tabla . presenta una -queña muestra aquéllas. para ilustrar uso ocl especificación, reexamina ejemplo manipulador bloques, que introdujo sección .. primer paso desarrollar modelo uml (figura .). este diagrama clase especifica muchas relaciones entre los objetos involucrados. sin embargo, las expresiones ocl agregan para que los implementadores del sistema puedan conocer con más precisión que debe permanecer verdadero conforme corre sistema. las expresiones ocl que complementan diagrama clase corresponden las seis partes invariante que estudió sección .. ejemplo que sigue, invariante repite castellano luego escribe correspondiente expresión ocl. considera buena práctica proporcionar texto lenguaje natural junto con lógica formal; hacerlo así ayuda entender lógica, también ayuda los revisores descubrir errores, por ejemplo, situaciones donde lenguaje natural lógica corresponden. . ningún bloque mar cará como utilizado usado mismo tiempo. context blockhandler inv: (self.used.intersection(self.free)) .isempty() observe que cada expresión comienza con palabra clave context. esto indica ele- mento del diagrama uml que restringe expresión. manera alternativa, podría -locar restricción directamente diagrama uml, encerrada entre llaves. aquí palabra clave self refiere instancia blockhandler; que sigue, como per- misible ocl, omitirá self. . odos los conjuntos bloques que conservan fila serán subconjuntos colec- ción los bloques actualmente utilizados. context blockhandler inv: blockqueue.forall(ablockset | used.includesall(ablockset )) . ningún elemento fila contendr mismo número bloque. context blockhandler inv: blockqueue.forall(blockset, blockset | blockset ,. blockset impliesblockset.elements.number.excludesall(blockset.number)) blockset blockhandler* ** * * {ordenado} free allblocks {subconjuto}{subconjuto}usedelementos addblock( )removeblock( )bloquefigura . diagrama clase para manipulador bloques (-).indd (-).indd // ::// :: modelado verificación formal expresión antes implies necesaria para garantizar que ignoran los pares donde ambos elementos son mismo bloque. . colección bloques utilizados bloques que utilizan ser colección total bloques que constituyen los archivos. context blockhandler inv: allblocks used.union(free) . colección bloques utilizados tendr números bloque duplicados. context blockhandler inv: free.isunique(ablock | ablock.number) . colección bloques utilizados tendr números bloque duplicados. context blockhandler inv: used.isunique(ablock | ablock.number) ocl también puede usarse para especificar precondiciones poscondiciones operaciones. por ejemplo, siguiente describe operaciones que remueven agregan conjuntos bloques fila. observe que notación @pre indica objeto como existe antes operación; esto opuesto notación matemática estudiada anteriormente, donde está después operación que designa especialmente (como ’). context blockhandler::removeblocks() pre: blockqueue .size() . post: used used @pre-blockqueue @pre.first() and free = free @pre.union(blockqueue @pre.first()) and blockqueue blockqueue @pre.excluding(blockqueue @pre.first) context blockhandler::addblocks(ablockset :blockset) pre: used.includesall(ablockset.elements)post: (blockqueue.elements blockqueue.elements @pre . append (ablockset.elements) andused used @pre and free free @pre ocl lenguaje modelado, pero tiene todos los atributos lenguaje formal. ocl permite expresión varias restricciones, precondiciones poscondiciones, guardias otras características que relacionan con los objetos representados varios modelos uml. .. lenguaje especificación lenguaje especificación que usa ampliamente dentro comunidad métodos formales. lenguaje aplica conjuntos escritos, relaciones funciones dentro del contexto lógica predicados primer orden para construir esquemas, medio para estructurar especificación formal. las especificaciones organizan como conjunto esquemas, una estructura len- guaje que introduce variables que especifica relación entre dichas variables. esquema esencia especificación formal análoga del componente lenguaje programación. los esquemas usan para estructurar una especificación formal misma forma que los componentes usan para estructurar sistema. esquema describe los datos almacenados los que accede que altera sistema. contexto , esto llama “estado”. este uso del término estado ligeramente diferente webref /~susan/abs/.htm, puede encontrarse información detallada acerca del lenguaje . (-).indd (-).indd // ::// :: parte tres administración calidad del uso palabra resto este libro. además, esquema identifica las operaciones que aplican para cambiar estado las relaciones que ocurren dentro del sistema. - tructura genérica esquema toma forma: ——— esquemanombre—————————————— declaraciones——————————————————————— invariante———————————————————————— donde las declaraciones identifican las variables que abarca estado del sistema invariante impone restricciones forma que puede evolucionar estado. tabla . pre-senta resumen notación del lenguaje . siguiente ejemplo esquema describe estado del manipulador bloques inva- riante datos: ——— blockhandler ————————————— ——— —— — — —— —— — used, free : / blocks blockqueue : seq / blocksused / free / / / / free / allblocks //: dom blockqueue • blockqueue / used //, : dom blockqueue • / // blockqueue / blockqueue / /————————————————————————————————como anotó, esquema consiste dos partes. parte que está arriba línea central representa las variables del estado, mientras que parte abajo línea central describe invariante datos. siempre que esquema especifique operaciones que cambian estado, precede con símbolo . siguiente ejemplo esquema describe operación que -mueve elemento fila bloques: ——— removeblocks ——————————————— / blockhandler————————————————————————— —— #blockqueue / ,used′ / used \ head bloc kqueue / free′ / free / head blockqueue /′ / tail blockqueue————————————————————————— —— inclusión blockhandler como resultado todas las variables que constituyen estado disponible para esquema removeblocks garantiza que invariante datos sostendrá antes después ejecutar operación. segunda operación, que agrega una colección bloques final fila, representa como ———addblocks—————————————————— / blockhandlerablocks? : blocks———————————————————————— ——— recuerde que, otros capítulos, estado usó para identificar modo comportamiento observable exterior para sistema. (-).indd (-).indd // ::// :: modelado verificación formal ablocks? / used blockqueue′ / blockqueue / ⟨ablocks? ⟩ / used′ / used /′ / free—————————————————————————— — por convención , una variable entrada que lea, pero que forme parte del estado, termina con signo interrogación. por tanto, ablocks?, que actúa como parámetro entrada, termina con signo interrogación.tabla . resumen notación notación basa teoría conjuntos descrita lógica primer orden. proporciona constructo, llamado esquema, para describir espacio las operaciones estado una especificación. esquema agrupa declaraciones variables con una lista predicados que restringen posible valor una variable. , esquema define mediante forma ––––––––––––––––––––––––––––––––––––––––––– declaraciones –––––––––––––––––––––––––––––––––––––––––––– predicados –––––––––––––––––––––––––––––––––––––––––––– las funciones globales las constantes definen mediante forma declaraciones –––––––––––––––––––––––––––––––––––––––––––– predicados declaración brinda tipo función constante, mientras que predicado proporciona valor. esta tabla sólo presenta conjunto abreviado símbolos . conjuntos: : / declara como conjunto . / miembro . / miembro . / subconjunto : todo miembro también está . / unión : contiene todo miembro ambos. / intersección : contiene todo miembro tanto como . \ diferencia : contiene todo miembro excepto aquellos que también están . / conjunto vacío: contiene miembros. {} conjunto solo elemento: sólo contiene . / conjunto los números naturales , , , .... : / declara como conjunto finito . max () máximo del conjunto vacío números . funciones: : → declara como una inyección parcial . dom dominio : conjunto valores para los cuales define (). ran rango : conjunto valores tomados por () conforme varía sobre dominio . / { → } una función que concuerda con excepto que mapea . {} / – una función como , excepto que remueve dominio. lógica: / : verdadero tanto como son verdaderos. ⇒ implica : verdadero verdadero falso. / ’ / / ningún componente del esquema cambia una operación. (-).indd (-).indd // ::// :: parte tres administración calidad . esumen ingeniería del software cuarto limpio enfoque formal del desarrollo software que puede conducir software con una calidad notablemente alta. usa especificación estruc-tura cajas para análisis modelado del diseño, enfatiza verificación exactitud, lugar las pruebas, como mecanismo primario para encontrar remover errores. prueba uso estadístico aplica para desarrollar información tasa fallos necesaria para certificar confiabilidad del software entregado. enfoque cuarto limpio comienza con los modelos análisis diseño que usan una representación estructura cajas. una “caja” encapsula sistema ( algún aspecto ) nivel específico abstracción. las cajas negras usan para representar comporta-miento externamente observable sistema. las cajas estado encapsulan los datos operaciones estado. una caja clara usa para modelar diseño procedural que implica mediante los datos operaciones una caja estado. verificación exactitud aplica una vez que está completo diseño estructura cajas. diseño procedural para componente software divide una serie subfun-ciones. para probar exactitud las subfunciones, definen condiciones salida para cada subfunción aplica conjunto subpruebas. cada condición salida satisface, diseño debe ser correcto. una vez que está completa verificación exactitud, comienza prueba uso estadís- tico. diferencia las pruebas convencionales, ingeniería del software cuarto limpio enfatiza las pruebas unidad integración. vez ello, software prueba definir conjunto escenarios uso, determinar probabilidad uso para cada escenario luego definir pruebas aleatorias que conformen con las probabilidades. los registros error que resultan combinan con modelos muestreo, componentes certificación para habilitar cálculo matemático confiabilidad proyectada para componente software. los métodos formales usan las facilidades descriptivas teoría conjuntos notación lógica para permitir que ingeniero software cree enunciado claro los hechos (reque-rimientos). los conceptos subyacentes que gobiernan los métodos formales son: ) invariante datos, una condición verdadera largo ejecución del sistema que contiene una -objetivo: objetivo las herramientas métodos for- males auxiliar equipo software verificación especificación exactitud. mecánica: mecánica las herramientas varía. general, las herramientas auxilian probar especificación exactitud automatización, que por general define mediante lenguaje especializado para probar los teoremas. muchas herramientas comercializan desarrollaron con propósitos investigación. herramientas representativas: acl, desarrollada universidad texas ( edu/users/moore/acl/), “tanto lenguaje progra-mación que pueden modelarse sistemas cómputo como una herramienta para ayudarle probar las propiedades dichos modelos”. eves, desarrollado por ora canadá ( html), implementa lenguaje verdi para especificación formal generador prueba automático. http://.fmnet.info/ puede encontrar una extensa lista más herramientas métodos formales.herramientas software métodos formales las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus res- pectivos desarrolladores. (-).indd (-).indd // ::// :: modelado verificación formal lección datos; ) estado, una representación del modo comportamiento observable externamente sistema ( lenguajes relacionados) los datos almacenados los que sistema accede que altera; ) operación, una acción que tiene lugar sistema que lee escribe datos estado. una operación asocia con dos condiciones: una precon-dición una poscondición. ¿alguna vez ingeniería del cuarto limpio los métodos formales usarán ampliamente? respuesta “probablemente ”. son más difíciles aprender que los métodos ingenie-ría del software convencional representan significativo “choque cultural” para algunos profesionales del software. pero siguiente vez que escuche alguien lamentarse: “¿por qué este software puede quedar bien desde primera vez?”, sabrá que hay técnicas que ayu-dan hacer exactamente eso. problemas puntos por evaluar .. tuviera que elegir aspecto ingeniería del software cuarto limpio que haga radicalmente diferente los enfoques ingeniería del software convencional orientada objeto, ¿cuál sería? .. ¿cómo trabajan conjunto modelo proceso incremental certificación para producir soft- ware alta calidad? .. con especificación estructura cajas, desarrolle modelos análisis diseño “primer paso” para sistema casasegura. .. algoritmo ordenamiento burbujas (bubble-sort) define manera siguiente: procedure bubblesort; var , , integer;beginrepeat until [] :[];for : [-] . [] then begin :[-];[-]:[];[]:;end endrepend divida diseño subfunciones defina conjunto condiciones que permitirían probar que este algoritmo correcto. .. documente una prueba verificación exactitud para ordenamiento burbujas estudiado problema .. .. seleccione programa que usted use regularmente (por ejemplo, manejador correo electrónico, procesador palabra, programa hoja cálculo). cree conjunto escenarios uso para pro-grama. defina probabilidad uso para cada escenario luego desarrolle una tabla estímulos del programa distribución probabilidad, similar que muestra sección ... .. para tabla estímulos del programa distribución probabilidad que desarrolló problema ., use generador números aleatorios para desarrollar conjunto casos prueba para usar prueba uso estadístico. .. con sus palabras, describa intención certificación contexto ingeniería del software cuarto limpio. .. lector asignan equipo que desarrolla software para fax módem. labor desarrollar porción “directorio” aplicación. función directorio permite almacenamiento hasta maxnombres personas junto con los nombres compañía asociados, números fax otra información relacionada. use lenguaje natural para definir (-).indd (-).indd // ::// :: parte tres administración calidad ) invariante datos. ) estado. ) las probables operaciones. .. lector asigna equipo software que desarrolla software, llamado memoriaduplicador, que proporciona una mayor memoria aparente que memoria física. esto logra identificar, reco-pilar reasignar bloques memoria que asignaron una aplicación existente, pero que utilizan. los bloques utilizados reasignan aplicaciones que requieren memoria adicional. realice las suposi-ciones adecuadas use lenguaje natural para definir ) invariante datos. ) estado. ) las probables operaciones. .. use notación ocl que presentó las tabla . ., seleccione alguna parte del sis- tema seguridad casasegura descrito anteriormente este libro intente especificarla con ocl con . .. use una más las fuentes información anotadas las referencias lecturas adicionales fuentes información este capítulo, para desarrollar una presentación media hora acerca sintaxis semántica básicas lenguaje especificación formal distinto ocl . lecturas adicionales fuentes información años recientes, han publicado relativamente pocos libros acerca las técnicas especificación verificación avanzadas. sin embargo, vale pena considerar algunas las nuevas adiciones literatura. libro editado por gabbar ( modern formal methods and applications, springer, ) presenta tanto funda- mentos, como nuevos desarrollos aplicaciones avanzadas. jackson (software abstractions, the mit press, ) presenta todos los fundamentos enfoque que llama “métodos formales ligeros”. monin hin-chey (understanding formal methods, springer, ) ofrecen una excelente introducción materia. butler . ( integrated formal methods, springer, ) presentan varios artículos acerca del tema los métodos formales. además los libros indicados este capítulo, prowell . ( cleanroom software engineering: techno- logy and process, addison-wesley, ) proporcionan tratamiento profundidad todos los aspectos importantes del enfoque cuarto limpio. poore trammell ( cleanroom software engineering: reader , blackweel publishing, ) editaron útiles análisis temas cuarto limpio. becker whittaker ( clean- room software engineering practies, idea group publishing, ) presentan excelente panorama para quienes están familiarizados con las prácticas cuarto limpio. cleanroom pamphlet (software technology support center, hill base, abril ) contiene reim- presiones algunos artículos importantes. data and analysis center for software (dacs) ( proporciona muchos ensayos útiles, manuales otras fuentes información acerca ingenie-ría del software cuarto limpio. verificación diseño mediante prueba exactitud encuentra centro del enfoque cuarto limpio. los libros cupillari ( the nuts and bolts proofs , ., academic press, ), solow ( how read and proofs, . ., wiley, ), eccles ( introduction mathematical reasoning, cambridge university press, ), proporcionan excelentes introducciones los principios matemáticos. stavely (toward zero-defect software, addison-wesley, ), baber (error-free software, wiley, ) schulmeyer ( zero defect software, mcgraw-hill, ) estudian prueba exactitud con detalle considerable. dominio los métodos formales, los libros casey ( programming approach formal methods, mcgraw-hill, ), hinchey bowan (industrial strength formal methods, springer-verlag, ), hussmann (formal foundations for software engineering methods, springer-verlag, ) sheppard ( introduction formal specification with and vdm, mcgraw-hill, ) ofrecen guías útiles. además, libros específicos sobre lenguaje, como los rmer kleppe (object constraint language, addison-wesley, ), jacky ( the way : practical programming with formal methods, cambridge university press, ), harry ( formal methods fact file: vdm and , wiley, ) cooper barden ( practice, prentice-hall, ) proporcionan introducciones útiles los métodos formales, así como varios lenguajes modelado. internet está disponible una gran variedad fuentes información acerca ingeniería del software cuarto limpio los métodos formales. una lista actualizada referencias world wide web que son relevantes para modelado formal verificación puede encontrarse sitio del libro: com/engcs/compsci/pressman/professional/olc/ser.htm (-).indd (-).indd // ::// :: configuración del software conceptos clave administración contenido . auditoría configuración . . referencia . . . . . . . cambio . . . . . . . . versión . . . . . . . . . . . . . . . . . . . . configuración software (ics) . . . . . . . . objeto configuración . . . . configuración webapps . . . . . . . . . . . . proceso acs . . . . . . . . . . . . estado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ¿qué ? cuando construye software computadora, ocurren cambios. puesto que ocurren, necesario administrarlos manera efectiva. administración configuración del software (acs), también llamada gestión del cambio, conjunto actividades diseñadas para administrar cambio mediante identificación los productos trabajo que probable que cambien, establecimiento relaciones entre ellos, definición mecanismos para administrar diferentes versiones dichos productos trabajo control los cambios impuestos, así como auditoría reporte los cambios realizados. ¿quién hace? todos los involucrados proceso software relacionan cierta medida con gestión del cambio, pero ocasiones crean posiciones apoyo especializadas para administrar proceso acs. ¿por qué importante? controla cambio, éste controla uno. eso nunca bueno. muy fácil que torrente cambios descontrolados convierta caos proyecto software bien estructurado. como consecuencia, calidad del software reduce entre- demora. por dicha razón, gestión del cambio parte esencial administración calidad. ¿cuáles son los pasos? puesto que muchos productos trabajo realizan cuando software construye, cada uno debe identificarse manera única. una vez logrado, pueden establecerse mecanismos para control versión cambio. para garantizar que calidad mantiene conforme realizan cambios, audite proceso; para asegurarse que quienes deben conocerlos estén informa-dos acerca los cambios, realice reportes. ¿cuál producto final? plan administración configuración del software define estrategia del proyecto para gestión del cambio. además, cuando invoca acs formal, proceso control cambio pro-duce solicitudes cambio software, reportes órdenes cambio ingeniería. ¿cómo aseguro que hice bien? cuando todo producto trabajo pueda explicarse, rastrearse controlarse; cuando todo cambio pueda rastrearse ana-lizarse; cuando todos los que deben saber acerca cambio están informados, entonces gestión del cambio hizo correctamente. una mirada rápidacuando construye software computadoras, cambio inevitable. cambio aumenta nivel confusión cuando los miembros equipo software trabajan proyecto. confusión surge cuando los cambios analizan antes que realicen, cuando registran antes que implanten, reportan quienes tienen necesidad conocerlos controlan forma que mejore calidad reduzca error. babich [bab] analiza esto cuando afirma: arte coordinar desarrollo software para minimizar [...] confusión llama administración configuración, que arte identificar, organizar controlar las modificaciones que hacen software que construirá equipo programación. meta maximizar productividad minimizar los errores. administración configuración del software (acs) una actividad sombrilla que aplica largo del proceso software. puesto que cambio puede ocurrir cualquier - mento, desarrollan actividades acs para ) identificar cambio, ) controlar cambio, ) garantizar que cambio implementó manera adecuada ) reportar los cambios otros que puedan estar interesados. importante hacer una distinción clara entre apoyo software administración configuración del software. apoyo conjunto actividades ingeniería software que ocurren después que éste entregó cliente que puso operación. admi-nistración configuración del software conjunto actividades rastreo control que inicia cuando comienza proyecto ingeniería software sólo termina cuando software retira operación. (-).indd (-).indd // ::// :: parte tres administración calidad una meta principal ingeniería software mejorar facilidad con que los cam- bios pueden acomodarse reducir cantidad esfuerzo empleado cuando deban realizarse cambios. este capítulo estudian las actividades específicas que permiten administrar cambio. . dministración configuración del software salida del proceso software información que puede dividirse tres categorías amplias: ) programas cómputo (tanto nivel fuente como formatos ejecutables), ) produc-tos trabajo que describen los programas cómputo (dirigidos varios participantes) ) datos contenido (incluidos dentro del programa externos ). los ítems que comprenden toda información producida como parte del proceso software llaman colectivamente configuración del software. conforme avanza trabajo ingeniería software, crea una jerarquía ítems con- figuración del software (ics): elemento información nominado que puede ser tan pequeño como solo diagrama uml tan grande como documento diseño completo. cada ics simplemente conduce otros ics, dará como resultado poca confusión. por desgracia, proceso entra otra variable: cambio, que puede ocurrir cualquier momento, por cualquier razón. hecho, primera ley ingeniería sistemas [ber] establece: “sin importar dónde esté ciclo vida del sistema, sistema cambiará, deseo por cambiar per-sistirá largo del ciclo vida.” ¿cuál origen estos cambios? respuesta esta pregunta tan variada como los mismos cambios. sin embargo, existen cuatro fuentes fundamentales cambio: • nuevas condiciones empresariales mercado dictan los cambios los requeri- mientos del producto las reglas empresariales. • nuevas necesidades los accionistas demandan modificación los datos producidos por los sistemas información, funcionalidad que entregan los productos los servicios que ofrece sistema basado computadora. • reorganización crecimiento/reducción empresa produce cambios las prio- ridades proyectadas estructura del equipo ingeniería software. • restricciones presupuestales calendario causan una redefinición del sistema del producto. administración configuración del software conjunto actividades que - sarrollaron para administrar cambio largo del ciclo vida del software computadora. acs puede verse como una actividad que garantiza calidad del software que aplica largo del proceso software. las siguientes secciones describen las principales tareas acs los conceptos importantes que pueden ayudar gestionar cambio. .. escenario acs escenario operativo administración del cambio () típico involucra gerente pro-yecto que está cargo grupo software, gerente configuración responsable los procedimientos políticas , los ingenieros software encargados desarrollar mantener producto software cliente que usa producto. escenario, supone que producto pequeño que involucra alrededor líneas código desarrollado por equipo seis personas. (observe que posible que existan otros escenarios equipos cita: “ hay nada permanente, excepto cambio.” heráclito, .. ¿cuál origen los cambios que solicitan para software?? esta sección extrajo [dar]. permiso especial para reproducir “spectrum functionality system”, susan dart [dar], © carnegie mellon university, obtuvo del software engineering institute. (-).indd (-).indd // ::// :: administración configuración del software más pequeños más grandes, pero, esencia, hay temas genéricos que cada uno estos proyectos enfrenta con respecto ). nivel operativo, escenario involucra varios roles tareas. para gerente proyecto, meta garantizar que producto desarrolla dentro cierto marco temporal. por tanto, monitorea progreso del desarrollo reconoce reacciona ante los problemas. esto hace mediante generación análisis reportes acerca del estado del sistema software realizar revisiones sistema. las metas del gerente configuración son garantizar que sigan los procedimientos políticas para crear, cambiar probar código, así como hacer accesible información acerca del proyecto. para implantar técnicas fin mantener control sobre los cambios código, este gerente introduce mecanismos para: realizar peticiones oficiales cambios, evaluarlos (mediante consejo control cambios que sea responsable aprobar los cambios sistema software) autorizarlos. gerente elabora difunde lista tareas para los inge-nieros básicamente crea contexto del proyecto. además, recopila estadísticas acerca los componentes que hay sistema software, tales como información que determina cuá-les componentes del sistema son problemáticos. para los ingenieros software, meta trabajar eficazmente. esto significa que los inge- nieros deben interferir innecesariamente unos con otros creación prueba del código producción productos operativos apoyo. pero, mismo tiempo, deben intentar comunicarse coordinarse manera eficiente. específicamente, los ingenieros usan herra-mientas que ayudan construir producto software consistente. comunican coordinan notificarse unos con otros las tareas requeridas las tareas completadas. los cambios propagan través del trabajo mutuo mediante fusión archivos. existen mecanismos para garantizar que, para componentes que experimentan cambios simultáneos, hay alguna forma resolver los conflictos fusión cambios. conserva una historia evolución todos los componentes del sistema, una bitácora con las razones los cambios registro que realmente cambió. los ingenieros tienen propio espacio trabajo para crear, cambiar, poner prueba integrar código. cierto punto, código convierte una línea referencia desde cual continúan mayores desarrollos realizan variantes para otras máquinas objetivo. cliente usa producto. puesto que éste encuentra bajo control , cliente sigue pro- cedimientos formales para solicitar cambios para indicar errores producto. manera ideal, sistema utilizado este escenario debe apoyar todos estos roles tareas, decir, los roles determinan funcionalidad requerida sistema . gerente proyecto como mecanismo auditoría; gerente configuración considera mecanismo control, rastreo generación políticas; ingeniero software, como mecanismo control cambio, construcción acceso; cliente como camino para garantizar calidad. .. elementos sistema administración configuración exhaustivo artículo acerca administración configuración del software, susan dart [dar] identifica cuatro elementos importantes que deben existir cuando desarrolla sistema administración configuración: • elementos componentes: conjunto herramientas acopladas dentro sistema administración archivos (por ejemplo, base datos) que permite acceso cada ítem configuración del software, así como gestión. • elementos proceso: colección acciones tareas que definen enfoque efectivo gestión del cambio ( actividades relacionadas) para todos los elementos constitu-yentes involucrados administración, ingeniería uso del software.¿cuáles son las metas las actividades realizadas por cada uno los elementos constituyentes involucrados administración del cambio?? punto clave debe existir mecanismo para asegurar que los cambios simultáneos hechos mismo componente rastreen, gestionen ejecuten manera adecuada. (-).indd (-).indd // ::// :: parte tres administración calidad • elementos construcción: conjunto herramientas que automatizan construcción software asegurarse que ensambló conjunto adecuado componentes validados ( decir, versión correcta). • elementos humanos: conjunto herramientas características proceso (que abarcan otros elementos ) utilizados por equipo software para implementar acs efectiva. estos elementos (que estudiarán con más detalle secciones posteriores) son mutua- mente excluyentes. por ejemplo, los elementos componentes trabajan conjunción con los elementos construcción conforme evoluciona proceso software. los elementos pro-ceso guían muchas actividades humanas que relacionan con acs , por tanto, también pueden considerarse como elementos humanos. .. líneas referencia cambio hecho vida desarrollo software. los clientes quieren modificar los requerimientos. los desarrolladores quieren cambiar enfoque técnico. los gerentes quieren modificar estrategia del proyecto. ¿por qué todas estas modificaciones? respuesta real-mente muy simple. conforme pasa tiempo, todos los elementos constituyentes saben más (acerca que necesitan, sobre qué enfoque sería mejor, cómo realizarlo todavía obtener dinero). este conocimiento adicional fuerza motora que hay detrás mayoría los cambios que conduce enunciado hechos que difícil aceptar para muchos profe-sionales ingeniería software: ¡ mayoría los cambios justifican! una línea referencia concepto administración configuración del software que ayuda controlar cambio sin impedir seriamente cambios justificados. ieee (ieee std. . .-) define una línea referencia como: una especificación producto que revisó formalmente con que estuvo acuerdo, que partir entonces sirve como base para mayor desarrollo que puede cambiar sólo través procedimientos control cambio formal. antes que ítem configuración del software convierta línea referencia, los cambios pueden realizarse rápida informalmente. obstante, una vez establecida línea referencia, pueden realizarse cambios, pero debe aplicarse procedimiento formal específico para evaluar verificar cada uno ellos. contexto ingeniería software, una línea referencia hito desarrollo del software. una línea referencia marca entregar uno más ítems configuración del software que aprobaron como consecuencia una revisión técnica (capítulo ). por ejemplo, los elementos modelo diseño documentaron revisaron. encontraron corrigie-ron errores. una vez que todas las partes del modelo revisaron, corrigieron luego aprobaron, modelo diseño convierte línea referencia. los cambios adicionales arquitectura del programa (documentada modelo diseño) pueden realizarse sólo después que cada uno evalúa aprueba. aunque las líneas referencia pueden definirse cualquier nivel detalle, figura . muestran las líneas referencia software más comunes. figura . también ilustra progresión eventos que conducen una línea referencia. las tareas ingeniería software producen uno más ics. después revisar aprobar los ics, colocan una base datos del proyecto (también llamada librería pro- yecto repositorio software, que estudia sección .). cuando miembro equipo ingeniería software quiere hacer una modificación ics que convertido línea referencia, copia base datos del proyecto espacio trabajo priva- del ingeniero. sin embargo, este ics extraído puede modificarse solamente siguen controles acs (que estudian más adelante este capítulo). las flechas figura . ilustran ruta modificación ics convertido línea referencia. mayoría los cambios software justifican, así que hay razón para quejarse por presencia. lugar, asegúrese que tiene los mecanismos para lidiar con ellos.consejo asegúrese que base datos del proyecto mantenga una ubicación centralizada controlada.consejo (-).indd (-).indd // ::// :: administración configuración del software .. ítems configuración del software definió ítem configuración del software como información que crea como parte del proceso ingeniería software. última instancia, ics podría considerarse como una sola sección una gran especificación como caso prueba una gran suite pruebas. manera más realista, ics todo parte producto trabajo (por ejemplo, -cumento, toda una suite casos prueba componente programa nominado). además los ics que derivan los productos trabajo software, muchas organi- zaciones ingeniería software también colocan las herramientas software bajo control configuración, decir, versiones específicas editores, compiladores, navegadores otras herramientas automatizadas “congelan” como parte configuración del software. puesto que dichas herramientas usaron para producir documentación, código fuente datos, deben estar disponibles cuando tengan que realizarse cambios configuración del software. aunque los problemas son raros, posible que una nueva versión una herramienta (por ejemplo, compilador) pueda producir resultados diferentes que versión original. por esta razón, las herramientas, como software que ayudan producir, pueden convertirse líneas refe-rencia como parte proceso amplio administración configuración. realidad, los ics organizan para formar objetos configuración que puedan catalo- garse con solo nombre base datos del proyecto. objeto configuración tiene nombre atributos, está “conectado” con otros objetos mediante relaciones. figura ., los objetos configuración designspecification (especificación diseño), datamodel (- delo datos), componentn (componente ), sourcecode (código fuente) testspecifica- tion (especificación prueba) definen cada uno por separado. sin embargo, cada uno los objetos relaciona con los demás, como muestra mediante las flechas. una flecha curva indica una relación composicional, decir, datamodel componentn son parte del objeto designspecification. una flecha con doble punta indica una interrelación. realizara cambio objeto sourcecode, las interrelaciones permiten determinar qué otros objetos ( ics) pueden resultar afectados. icsmodiﬁcado tareas ingeniería softwarerevisiones técnicasicsaprobado icsextraído controles acsicsalmacenadobase datos del proyecto especiﬁcación del sistema requerimientos softwareespeciﬁcación diseñocódigo fuenteplanes/procedimientos/datos pruebasistema operativolíneas referencia:figura . ics como línea referencia base datos del proyecto esas relaciones definen dentro base datos. estructura base datos (repositorio) estudia con mayor detalle sección .. (-).indd (-).indd // ::// :: parte tres administración calidad . repositorio acs los primeros días ingeniería software, los ítems configuración del software mantenían como documentos papel (¡ tarjetas perforadas!), colocadas carpetas papel anillos, almacenaban archiveros metálicos. este mecanismo era problemático por muchas razones: ) con frecuencia era difícil encontrar ítem configuración cuando necesitaba, ) era muy desafiante determinar cuáles ítems cambiaban, cuándo por quién, ) construir una nueva versión programa existente consumía mucho tiempo era proclive error ) describir relaciones detalladas complejas entre los ítems configuración era virtualmente imposible. actualidad, los ics mantienen una base datos del proyecto, repositorio. diccionario webster define palabra repositorio como “cualquier cosa persona que consi- dera como centro acumulación almacenamiento”. durante historia temprana inge-niería software, hecho repositorio era una persona: programador que debía recordar ubicación toda información relevante para proyecto software, quien debía recu-perar información que nunca escribió reconstruir información perdida. tristemente, usar una persona como “ centro para acumulación almacenamiento” (aun conforme con definición del webster) funciona muy bien. actualidad, repositorio una “cosa”: una base datos que actúa como centro acumulación almacenamiento infor-mación ingeniería software. papel persona ( ingeniero del software) interac-tuar con repositorio, usando las herramientas que integran con . .. papel del repositorio repositorio acs conjunto mecanismos estructuras datos que permiten equipo software administrar cambio forma efectiva. proporciona las funciones obvias moderno sistema administración base datos, asegurar integridad, posibili-dad compartir integración datos. además, repositorio acs proporciona centro para integración herramientas software, fundamental flujo del proceso software puede reforzar estructura formato uniforme para los productos que son resultado ingeniería software.designspeciﬁcation diseño datos diseño arquitectónicodiseño módulodiseño interfaz componentn descripción interfazdescripción algoritmopdldatamodel testspeciﬁcation plan pruebasprocedimiento pruebascasos pruebas sourcecodefigura . objetos configuración (-).indd (-).indd // ::// :: administración configuración del software para lograr estas capacidades, repositorio define como metamodelo. metamodelo determina cómo almacena información repositorio, cómo pueden acceder las herra- mientas los datos cómo pueden verlas los ingenieros software, cuán bien pueden mante-nerse seguridad integridad los datos cuán fácilmente puede extenderse modelo existente para alojar nuevas necesidades. .. características contenido generales las características contenido del repositorio entienden mejor observarlo desde dos perspectivas: qué debe almacenarse qué servicios específicos proporciona. figura . presenta desglose detallado los tipos representaciones, documentos otros productos trabajo. repositorio robusto proporciona dos clases servicios diferentes: ) los mismos tipos servicios que pueden esperarse cualquier sistema sofisticado administración base datos ) los servicios que son específicos del entorno ingeniería software. repositorio que sirve equipo ingeniería software también debe: ) integrarse con directamente apoyar las funciones administración del proceso, ) apoyar reglas espe-cíficas que gobiernan función acs los datos mantenidos dentro del repositorio, ) propor-cionar una interfaz hacia otras herramientas ingeniería software ) acomodar almace-namiento objetos datos sofisticados (por ejemplo, texto, gráficos, video, audio). .. características acs para apoyar acs, repositorio debe tener conjunto herramientas que proporcionan apoyo las siguientes características: versiones. conforme avanza proyecto, crearán muchas versiones (sección ..) productos resultantes individuales. repositorio debe guardar todas estas versiones para per- mitir administración efectiva los productos liberados , los desarrolladores, regresar versiones anteriores durante las pruebas depuración.webref technology/products/repository/index.html puede obtenerse ejemplo repositorio disponible mercado. reglas empresariales funciones empresarialesestructura organizaciónarquitectura información estimaciones del proyectocalendario del proyectorequerimientos acs peticiones cambio reportes cambiorequerimientos sqareportes proyecto/reportes auditoríamétricas proyectocasos usomodelo análisis diagramas basados escenario diagramas orientados ﬂujo diagramas basados clase diagramas comportamientomodelo diseño diagramas arquitectónicos diagramas interfaz diagramas nivel componentemétrica técnicacódigo fuentecódigo objetoinstrucciones construcción del sistema casos pruebaguiones pruebaresultados pruebamétricas calidad plan del proyectoplan acs/sqaespeciﬁcaciones del sistemaespeciﬁcaciones requerimientosdocumento diseñoplan procedimiento pruebasdocumentos apoyomanual del usuariocontenido gestión del proyecto documentoscontenido modelocontenido construcción contenido vcontenido empresarial figura . contenido del repositoriopunto clave repositorio debe mantener relacionados los ics con muchas diferentes versiones del software. más importante, debe proporcionar los mecanismos para ensamblar dichos ics una configuración específica una versión. (-).indd (-).indd // ::// :: parte tres administración calidad repositorio debe controlar una amplia variedad tipos objeto, incluidos texto, gráficos, mapas bits, documentos complejos objetos únicos, como definiciones pantalla repor- tes, archivos objeto, datos prueba resultados. repositorio maduro rastrea versiones objetos con niveles arbitrarios granularidad; por ejemplo, puede rastrearse una sola defini-ción datos grupo módulos. rastreo dependencia gestión del cambio. repositorio administra una amplia - riedad relaciones entre los elementos datos almacenados . éstos incluyen -laciones entre entidades procesos empresariales, entre las partes diseño aplicación, entre componentes diseño arquitectura información empresa, entre elementos diseño entregables, etcétera. algunas estas relaciones son meras asociaciones, otras son dependencias relaciones obligatorias. capacidad seguir pista todas estas relaciones vital para integridad - formación almacenada repositorio para generación entregables con base , una las aportaciones más importantes del concepto repositorio para mejora del pro-ceso software. por ejemplo, diagrama clase uml modifica, repositorio puede detectar clases relacionadas, descripciones interfaz componentes código también requieren modificación pueden llevar los ics afectados atención del desarrollador . rastreo requerimientos. esta función especial depende administración vínculos ofrece capacidad rastrear todos los componentes diseño construcción, así como entregables que resulten una especificación requerimientos determinada (rastreo hacia adelante). además, proporciona capacidad identificar qué requisito genera algún producto trabajo determinado (rastreo hacia atrás). administración configuración. una instalación administración configuración sigue pista una serie configuraciones que representa hitos proyecto específicos -beraciones producción. ensayos auditoría. ensayo auditoría establece información adicional acerca cuándo, por qué quién realiza los cambios. información acerca fuente los cambios puede ingresarse como atributos objetos específicos repositorio. mecanismo activación repositorio útil para que siempre que modifique elemento diseño, avise desarrollador, herramienta que utilice, inicio entrada informa- ción auditoría (como razón para cambio). . proceso acs proceso administración configuración del software define una serie tareas que tienen cuatro objetivos principales: ) identificar todos los ítems que manera colectiva defi-nen configuración del software, ) administrar los cambios uno más estos ítems, ) facilitar construcción diferentes versiones una aplicación ) garantizar que calidad del software conserva conforme configuración evoluciona con tiempo. proceso que logra dichos objetivos necesita ser burocrático pesado, pero debe - racterizarse forma que permita equipo software desarrollar respuestas conjunto preguntas complejas: • ¿cómo identifica equipo software los elementos discretos una configuración software? • ¿cómo gestiona una organización las muchas versiones existentes programa ( documentación) manera que permita que cambio acomode eficientemente?cita: “cualquier cambio, incluso para mejorar, está acompañado inconvenientes incomodida-des.” arnold bennett ¿qué preguntas debe responder proceso acs?? (-).indd (-).indd // ::// :: administración configuración del software • ¿cómo controla una organización los cambios antes después que software libera cliente? • ¿quién tiene responsabilidad aprobar clasificar los cambios solicitados? • ¿cómo puede garantizarse que los cambios realizaron adecuadamente? • ¿qué mecanismo usa para enterar otros acerca los cambios que realizaron? estas preguntas conducen definición las cinco tareas acs (identificación, control versión, control cambio, auditoría configuración reporte) que ilustran figura .. figura, las tareas acs pueden visualizarse como capas concéntricas. los ics fluyen hacia afuera través estas capas largo vida útil, final cuentas vuelven parte configuración del software una más versiones una aplicación sistema. conforme ics mueve través una capa, las acciones que implica cada tarea acs pueden ser aplicables. por ejemplo, cuando crea nuevo ics, debe identificársele. sin embargo, solicitan cambios para ics, capa control cambio aplica. ics asigna una versión específica del software (entran juego los mecanismos control versión). registro del ics ( nombre, fecha creación, designación versión, etcétera) conserva con propósitos auditoría configuración reporta quienes tienen necesidad -nocerlo. las secciones siguientes examina con más detalle cada una estas capas del proceso acs. .. identificación objetos configuración del software para controlar administrar ítems configuración del software, cada uno debe nombrarse por separado luego organizarse usando enfoque orientado objetos. posible identificar dos tipos objetos [cho]: básicos agregados. objeto básico una unidad información que crea durante análisis, diseño, código prueba. por ejemplo, objeto básico puede ser una sección una especificación requerimientos, parte modelo diseño, código fuente para componente una suite casos prueba que utilice para ejercitar código. objeto agregado una colección objetos básicos otros objetos agregados. software . reporte control versión control cambio identiﬁcaciónauditoría conﬁguración icsfigura . capas del proceso acs concepto objeto agregado [gus] propuesto como mecanismo para representar una versión completa una configuración software. (-).indd (-).indd // ::// :: parte tres administración calidad por ejemplo, designspecification objeto agregado. conceptualmente, puede vérsele como una lista nominada (identificada) punteros que especifican objetos agregados, como architecturalmodel datamodel, objetos básicos, como componentn umlclass- diagramn. cada objeto tiene conjunto características distintivas que identifican manera única: nombre, una descripción, una lista recursos una “realización”. nombre del objeto una cadena caracteres que identifica objeto sin ambigüedades. descripción del objeto una lista ítems datos que identifican tipo ics (por ejemplo, elemento modelo, programa, datos) representado por objeto, identificador proyecto información cambio / versión. los recursos son “entidades que proporcionan, procesan, referencian que algún modo objeto las requiere” [cho]. por ejemplo, los tipos datos, las funcio-nes específicas incluso los nombres variable pueden considerarse como recursos del -jeto. realización puntero hacia “unidad texto” para objeto básico, nulo para objeto agregado. identificación del objeto configuración también puede considerar las relaciones que existen entre los objetos nominados. por ejemplo, usar notación simple diagrama clase <parte modelo requerimientos; modelo requerimientos <parte especificación requerimientos; puede crear una jerarquía ics. muchos casos, los objetos interrelacionan través ramas jerarquía objetos. estas relaciones transestructurales pueden representarse forma siguiente: modelodatos <interrelacionado modeloflujodatosmodelodatos <interrelacionado casopruebaclasem primer caso, interrelación efectúa entre objeto compuesto, mientras que - gunda relación entre objeto agregado (modelodatos) objeto básico ( casoprueba- clasem). esquema identificación para objetos software debe reconocer que los objetos evolu- cionan largo del proceso software. antes que objeto convierta línea refe-rencia, puede cambiar muchas veces; incluso, después establecer una línea referencia, los cambios pueden ser bastante frecuentes. .. control versión control versión combina procedimientos herramientas para administrar diferentes ver-siones objetos configuración que crean durante proceso software. sistema control versión implementa integra directamente con cuatro grandes capacidades: ) una base datos proyecto (repositorio) que almacena todos los objetos configuración relevantes, ) una capacidad administración versión que almacena todas las versiones objeto configuración ( que permite construcción cualquier versión usando diferen-cias las versiones pasadas) ) una facilidad para elaboración que permite recopilar - dos los objetos configuración relevantes construir una versión específica del software. además, los sistemas control versión control cambio con frecuencia implementan una capacidad rastreador conflictos (también llamado rastreador errores) que permite equipo registrar rastrear estado todos los conflictos sobresalientes asociados con cada objeto configuración. algunos sistemas control versión establecen conjunto cambio, una colección todos los cambios ( relación con cierta configuración referencia) que requieren para crear una versión específica del software. dart [dar] observa que conjunto cambio punto clave las interrelaciones establecidas por los objetos configuración permiten valorar impacto del cambio. incluso base datos del proyecto proporciona capacidad para establecer dichas relaciones, éstas consumen mucho tiempo para establecimiento son difíciles mantener actualizadas. aunque son muy útiles para análisis impacto, son esenciales para administración cambio global.consejo (-).indd (-).indd // ::// :: administración configuración del software “captura todos los cambios habidos todos los archivos que hay configuración, junto con razón los cambios detalles quién cuándo hizo los cambios”. algunos conjuntos cambio nominados pueden identificarse para una aplicación sistema. esto permite construir una versión del software especificar los conjuntos cambios (por nombre) que deben aplicarse configuración referencia. para lograr esto, aplica enfoque modelado sistema. modelo del sistema contiene: ) una plantilla que incluye una jerarquía componente “orden construcción” para los componentes que describen cómo debe construirse sistema, ) reglas construcción ) reglas verificación. durante las décadas pasadas propusieron algunos enfoques automatizados diferentes para control versión. diferencia principal los enfoques sofisticación los atri-butos que usan para construir versiones específicas variantes sistema mecánica del proceso para construcción. también posible consultar modelo del sistema para valorar cómo impactará cambio componente otros componentes. uso herramientas para lograr control ver- sión esencial para administración efectiva del cam- bio. sistema versiones concurrentes (svc) una herramienta ampliamente utilizada para control versiones. originalmente diseñada para código fuente, pero útil para cualquier archivo basado texto, svc ) establece repositorio simple, ) mantiene todas las versiones archivo solo archivo nominado almace-nar sólo las diferencias entre versiones progresivas del archivo origi-nal ) protege archivo contra los cambios simultáneos esta-blecer diferentes directorios para cada desarrollador, que, por tanto, aísla uno otros. svc mezcla los cambios cuando cada desarrollador completa trabajo. importante observar que svc sistema “ construc- ción”, decir, construye una versión específica del software. deben integrarse otras herramientas (por ejemplo, makefile) con svc para lograr esto. svc implanta proceso control cambio (por ejemplo, solicitudes cambio, reportes cambio, ras-treo errores). incluso con estas limitaciones, svc “ dominante sistema control versión, red transparente código abierto, [que] útil para todos, desde desarrolladores individuales hasta grandes equipos distribuidos” [cvs]. arquitectura cliente-servidor permite los usuarios acceder los archivos mediante conexiones internet, filosofía código abierto vuelve disponible para mayoría las plataformas más usadas. svc está disponible sin costo alguno para entornos windows, mac , linux unix. vea [cvs] para más detalles.herramientas software sistema versiones concurrentes (svc) .. control cambio realidad del control cambio contexto moderno ingeniería software resume bellamente james bach [bac]: control del cambio vital. pero las fuerzas que hacen necesario también hacen desconcer- tante. nos preocupamos por cambio porque una pequeña perturbación código puede crear una gran falla producto. pero también puede corregir gran fallo permitir maravillosas nuevas capacidades. nos preocupamos por cambio porque solo desarrollador granuja podría hundir proyecto, aunque las mentes dichos granujas originan ideas brillantes abrumador pro-ceso control del cambio podría efectivamente desalentarlos hacer trabajo creativo. bach reconoce que está frente acto equilibrio. mucho control del cambio crearán problemas. muy poco crearán otros problemas. para gran proyecto software, cambio descontrolado conduce rápidamente caos. para tales proyectos, control del cambio combina procedimientos humanos herramientas cita: “ arte avanzar preservar orden medio del cambio preservar cambio medio del orden.” alfred north whitehead (-).indd (-).indd // ::// :: parte tres administración calidad automatizadas fin proporcionar mecanismo para control del cambio. proceso control del cambio ilustra manera esquemática figura .. una petición cambio envía evalúa para valorar mérito técnico, los potenciales efectos colaterales, impacto global sobre otros objetos configuración funciones del sistema, costo proyectado del cambio. los resultados evaluación presentan como reporte cambio, que utiliza una autoridad control del cambio (acc), decir, una persona grupo que toma una decisión final acerca del estatus prioridad del cambio. por cada cambio aprobado genera una orden cambio ingeniería (oci). oci describe cambio que realizar, las restricciones que deben respetarse los criterios para revisar auditar. objeto que cambiar puede colocarse directorio que controlan exclusivamente los ingenieros software que realizan cambio. sistema control versión (vea barra lateral svc) actualiza archivo original una vez que realiza cambio. como alterna-tiva, objeto que cambiar puede “sacarse” base datos del proyecto (repositorio), realizarse cambio aplicarse las actividades adecuadas sqa. luego, objeto “entra” base datos usan mecanismos control versión adecuados (sección ..) para crear siguiente versión del software. reconoce necesidad del cambio petición cambio por parte del usuario desarrollador evalúa genera reporte cambio autoridad control cambio decide petición pone ﬁla para acción, genera oci asigna individuos objetos conﬁguración “salida” objetos (ítems) conﬁguración hace cambio revisión (auditoría) del cambio “entrada” ítems conﬁguración que cambiaron establecimiento línea referencia para prueba realización actividades para garantizar calidad para poner prueba “promover” cambios para inclusión siguiente liberación (revisión) reconstruir versión adecuada del software revisar (auditar) cambio todos los ítems conﬁguración incluir cambios nueva versión distribuir nueva versiónpetición cambio niega informa usuariofigura . proceso control del cambio punto clave cabe señalar que número peticiones cambios pueden combinar para resultar una oci única esas oci típicamente provocan cambios los objetos configuración múltiple. (-).indd (-).indd // ::// :: administración configuración del software dichos mecanismos control versión, integrados dentro del proceso control cam- bio, implementan dos importantes elementos gestión del cambio: control del acceso control sincronización. control del acceso determina qué ingenieros software tienen autoridad para acceder modificar objeto configuración particular. control sin- cronización ayuda garantizar que cambios paralelos, realizados por dos personas diferentes, sobreescriban mutuamente. acaso sienta incómodo con nivel burocracia que implica descripción del proceso control cambio que muestra figura .. este sentimiento raro. sin salva-guardas adecuadas, control del cambio puede retardar progreso crear burocracia innece-saria. mayoría los desarrolladores software que tienen mecanismos control del cambio (por desgracia, muchos los tienen) han creado algunas capas control para auxi-liarse evitar los problemas que mencionan aquí. antes que ics convierta referencia, sólo necesario aplicar control cambio informal. desarrollador del objeto configuración (ics) cuestión puede hacer cualquier cambio que sea justificado por proyecto por los requerimientos técnicos, tanto los cam-bios afecten requerimientos más amplios del sistema que encuentren afuera del ámbito trabajo del desarrollador. una vez que objeto experimenta revisión técnica aprueba, puede crearse una línea referencia. cuando ics convierte referencia, implementa control cambio nivel del proyecto . entonces, para hacer cambio, desarrollador debe obtener aprobación del gerente del proyecto ( cambio “local”) del acc ( cambio afecta otros ics). algunos casos, generación formal peticiones cambio, reportes cambio oci otorgan conjunto. sin embargo, realiza valoración cada cambio todos los cambios rastrean revisan. cuando producto software libera los clientes, instituye control cambio for- mal. procedimiento control cambio formal delineó figura .. autoridad control cambio juega papel activo segunda tercera capas del control. dependiendo del tamaño carácter proyecto software, acc puede compo-nerse una persona ( gerente proyecto) algunas personas (por ejemplo, representan-tes software, hardware, ingeniería base datos, apoyo, mercadotecnia). papel acc adoptar una visión global, decir, valorar impacto del cambio más allá del ics cuestión. ¿cómo afectará cambio hardware? ¿cómo hará desempeño? ¿cómo -dificará percepción los clientes acerca del producto? ¿cómo afectará calidad confiabi-lidad del producto? acc debe abordar éstas muchas otras preguntas. una línea referencia también puede crearse por otras razones. por ejemplo, cuando crean “construcciones diarias”, todos los componentes verificados momento determinado convierten línea referencia para trabajo del día siguiente.opte por poco más control cambio del que crea que necesitará. probable que demasiado sea cantidad correcta.consejo cita: “ cambio inevitable, excep- para las máquinas expendedoras.” letrero parachoques escena: oficina doug miller - mento comenzar proyecto software casasegura. participantes: doug miller (gerente del equipo ingeniería software casasegura), vinod raman, jamie lazar otros miembros del equipo ingeniería software del producto. conversación: doug: que temprano, pero tenemos que hablar acerca gestión del cambio. vinod (ríe): difícilmente. mercadotecnia llamó esta mañana con algunas “segundas opiniones”. nada importante, pero sólo comienzo.casasegura conflictos acs (-).indd (-).indd // ::// :: parte tres administración calidad .. auditoría configuración identificación, control versión control del cambio ayudan conservar orden que otro modo sería una situación caótica fluida. sin embargo, incluso los más exitosos meca-nismos control rastrean cambio sólo hasta que genera una oci. ¿cómo puede equipo software asegurarse que cambio implementó adecuadamente? respuesta doble: ) revisiones técnicas ) auditoría configuración del software. revisión técnica (capítulo ) enfoca exactitud técnica del objeto configuración que modificó. los revisores valoran ics para determinar consistencia con otros ics, así como omisiones potenciales efectos colaterales. una revisión técnica debe realizarse para todos los cambios, salvo los más triviales. una auditoría configuración del software complementa revisión técnica valorar objeto configuración acerca las características que por general consideran -rante revisión. auditoría hace responde las siguientes preguntas: . ¿ realizó cambio especificado oci? ¿ incorporó alguna modificación adicio- nal? . ¿ llevó cabo una revisión técnica para valorar exactitud técnica? . ¿ siguió proceso del software aplicaron adecuadamente los estándares - geniería software? . cambio “resaltó” ics? ¿ especificaron fecha del cambio autor del cambio? ¿los atributos del objeto configuración reflejan cambio? . ¿ siguieron los procedimientos acs para anotar, registrar reportar cambio? . ¿los ics relacionados actualizaron adecuadamente? algunos casos, las preguntas auditoría plantean como parte una revisión técnica. obstante , cuando acs una actividad formal, auditoría configuración realiza por separado grupo aseguramiento calidad. tales auditorías formales configu-ración también garantizan que los ics correctos (por versión) incorporan una construc-ción específica, que toda documentación actualizó consistente con versión que construyó.jamie: proyectos anteriores fuimos bastante informales acerca administración del cambio. doug: , pero éste más grande más visible , según recuerdo... vinod (cabecea): nos matamos con cambios incontrolables proyecto control iluminación casa... recuerdo las demo-ras que... doug (frunce ceño): una pesadilla que prefiero revivir.jamie: así que, ¿qué hacemos?doug: según veo, tres cosas. primero, tenemos que desarrollar, pedir prestado, proceso control cambio. jamie: quieres decir: ¿cómo solicitan las personas los cambios?vinod: , pero también cómo evalúa cambio, cómo deci- cuándo hacerlo ( eso que decide) cómo conservan registros que afecta cambio. doug: segundo, debemos conseguir una herramienta acs real- mente buena para control cambios versión. jamie: podemos construir una base datos para todos los pro- ductos trabajo. vinod: este contexto llaman ics, mayoría las buenas herramientas proporcionan cierto soporte para eso. doug: ése buen comienzo, ahora tenemos que...jamie: , doug, dijiste que había tres cosas...doug (sonríe): tercero: todos debemos comprometernos seguir proceso administración del cambio usar las herra-mientas, sin importar cuáles sean, ¿está claro? ¿cuáles son las preguntas principales que plantean durante una auditoría configuración?? (-).indd (-).indd // ::// :: administración configuración del software .. reporte estado reporte del estado configuración ( ocasiones llamado contabilidad estado) una tarea acs que responde las siguientes preguntas: ) ¿qué ocurrió? ) ¿quién hizo? ) ¿cuándo ocurrió? ) ¿qué más afectará? flujo información para reporte del estado configuración (rec) ilustra figura .. cada vez que asigna ics una nueva identificación que actualiza, hace una entrada rec. cada ocasión que acc aprueba cambio ( decir, emite una oci), hace una entrada rec. cada vez que lleva cabo una auditoría configuración, los resultados reportan como parte tarea rec. salida del rec puede colocarse una base datos línea sitio web, modo que los desarrolladores software per-sonal apoyo puedan acceder información del cambio mediante categorías palabras clave. además, regularmente genera reporte rec tiene intención mantener tanto los cambios importantes los gerentes profesionales.desarrolle una lista “ necesita saber” para cada objeto configuración manténgala actualizada. cuando realice cambio, asegúrese notificar todos través lista.consejo las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus res- pectivos desarrolladores. vea [pre] para una discusión amplia los métodos ingeniería web.objetivo: las herramientas acs proporcionan apoyo una más las actividades del proceso que estudian sección .. mecánica: mayoría las modernas herramientas acs trabajan conjunto con repositorio ( sistema base datos) ofre-cen mecanismos para identificación, control versión cambio, auditoría reportes. herramientas representativas: ccc/harvest, distribuida por computer associates ( com), sistema acs multiplataforma. clearcase, desarrollada por rational, proporciona una familia funciones acs (www-.ibm.com/software/ awdtools/clearcase/index.html). serena changeman zmf, distribuida por serena ( com//products/zmf/index.aspx), proporciona juego completo herramientas acs que son aplicables tanto para software convencional como para webapps. sourceforge, distribuida por software (sourceforge.net), ofre- administración versión, capacidades construcción, ras-treo conflictos/errores muchas otras características admi-nistración. surroundscm, desarrollada por seapine software, proporciona capacidades completas administración del cambio ( vesta, distribuida por compac, sistema acs dominio público que puede soportar tanto proyectos pequeños (< kloc) como grandes ( kloc) ( una gran lista herramientas entornos acs comerciales puede encontrarse software apoyo acs . dministración configuración para webapps anteriormente, este libro, estudió naturaleza especial las webapps los métodos especializados (llamados métodos ingeniería web) que requieren para construirlas. entre las muchas características que diferencian las webapps del software tradicional encuentra naturaleza siempre presente del cambio. los desarrolladores webapps con frecuencia usan modelo proceso iterativo incre- mental que aplica muchos principios derivados del desarrollo software ágil (capítulo ). usar este método, equipo ingeniería con frecuencia desarrolla incremento webapp periodo muy corto, usando enfoque impulsado por cliente. los incrementos poste-riores agregan contenido funcionalidad adicionales, probable que cada uno implemente ¿qué impacto tiene sobre una webapp cambio descontrolado?? (-).indd (-).indd // ::// :: parte tres administración calidad cambios que conduzcan aumento contenido, mejor usabilidad, estética mejorada, mejor navegación, desempeño aumentado seguridad más fuerte. por tanto, mundo ágil las webapps, cambio manera poco diferente. usted miembro equipo webapp, debe abrazar cambio. más aún, equipo ágil típico abstiene todas las cosas que parecen ser pesadas, burocráticas formales. -ministración configuración del software con frecuencia (aunque incorrectamente) como poseedora estas características. esta aparente contradicción remedia rechazar los principios, prácticas herramientas acs, sino, más bien, modelarlos para satisfacer las necesidades especiales los proyectos webapp. .. conflictos dominantes conforme las webapps vuelven cada vez más importantes para supervivencia creci- miento empresarial, crece necesidad administración configuración. ¿por qué? porque sin controles efectivos, los cambios inapropiados para una webapp (recuerde que - mediatez evolución continua son los atributos dominantes muchas webapps) pueden conducir : publicación autorizada información productos nuevos, funcionalidad erró-nea pobremente probada que frustra los visitantes sitio web, huecos seguridad que ponen peligro los sistemas internos compañía otras consecuencias económica-mente desagradables incluso desastrosas. las estrategias generales para administración configuración del software (acs) des- critas este capítulo son aplicables, pero las tácticas las herramientas deben adaptarse para conformarse naturaleza única las webapps. cuando desarrollan tácticas para admi-nistración configuración una webapp, deben considerarse cuatro conflictos [dar]. contenido. una webapp típica contiene arreglo muy amplio contenido: texto, gráficos, applets, guiones, archivos audio/video, elementos página activos, tablas, transmisión datos, muchos otros. reto organizar este mar contenido conjunto racional objetos configuración (sección ..) luego establecer mecanismos control configuración adecuados para dichos objetos. camino modelar contenido webapp usando técnicas modelado datos convencionales (capítulo ), unidas conjunto propiedades especializadas cada objeto. naturaleza estática/dinámica cada objeto longevidad proyectada (objeto temporal, existencia fija permanente) son ejemplos pro-piedades que requieren para establecer enfoque acs efectivo. por ejemplo, ítem contenido cambia cada hora, tiene longevidad temporal. los mecanismos control para este ítem serán diferentes (menos formales) los aplicados para componente formulario, que objeto permanente. personas. puesto que porcentaje significativo desarrollo webapp continúa realizándose una forma hoc, cualquier persona volucrada webapp puede ( con frecuencia hace) crear contenido. muchos creadores contenido tienen antecedentes ingeniería software son completamente ajenos las necesidades administración configura-ción. como consecuencia, aplicación crece cambia forma descontrolada. escalabilidad. las técnicas los controles aplicados una webapp pequeña escalan bien hacia arriba. raro que una webapp simple crezca significativamente conforme imple- mentan interconexiones con sistemas información, bases datos, almacenes datos puertas portales existentes. conforme crecen tamaño complejidad, pequeños cambios pueden tener efectos largo alcance intencionados que pueden ser problemáticos. por tanto, rigor los mecanismos control configuración debe ser directamente propor-cional escala aplicación. (-).indd (-).indd // ::// :: administración configuración del software políticas. ¿quién “posee” webapp ? esta pregunta plantea compañías grandes - queñas, respuesta tiene impacto significativo sobre las actividades administración control. algunas instancias, los desarrolladores web alojan fuera del área -ganización crean potenciales dificultades comunicación. dart [dar] sugiere las siguientes preguntas para ayudar entender las políticas asociadas con ingeniería web: • ¿quién asume responsabilidad por precisión información sitio web? • ¿quién garantiza que los procesos control calidad siguieron antes que información publique sitio? • ¿quién responsable por realización cambios? • ¿quién asume costo del cambio? las respuestas estas preguntas ayudan determinar las personas que dentro una orga-nización deben adoptar proceso administración configuración para webapps. administración configuración para webapps continúa evolucionando (por ejemplo, [ngu]). proceso acs convencional puede ser demasiado engorroso, pero años pasados surgió una nueva generación herramientas administración contenido, específicamente diseñadas para ingeniería web. dichas herramientas establecen proceso que adquiere infor-mación existente ( amplio arreglo objetos webapps), gestiona los cambios los - jetos, los estructura forma tal que posible presentarlos usuario final luego los ofrece entorno del lado cliente para despliegue. .. objetos configuración webapps las webapps abarcan amplio rango objetos configuración: objetos contenido (por ejemplo, texto, gráficos, imágenes, video, audio), componentes funcionales (guiones, applets) objetos interfaz (com corba). los objetos webapp pueden identificarse (con nombres archivo asignados) cualquier forma que sea adecuada para organización. sin embargo, recomiendan las siguientes convenciones para asegurar conservación compatibilidad entre plataformas: los nombres archivo deben limitarse caracteres longitud, deben evitarse nombres con mayúsculas mezcladas todos con mayúsculas, así como subrayar los nombres los archivos. además, las referencias url (vínculos) dentro objeto confi-guración siempre deben usar rutas relativas (por ejemplo,../products/alarmsensors.html). todo contenido webapp tiene formato estructura. los formatos archivo interno los dicta entorno computación que almacena contenido. sin embargo, formato renderizado (con frecuencia llamado formato despliegue ) define mediante estilo estético las reglas diseño establecidas para webapp. estructura del contenido define una arqui- tectura contenido, decir, forma que ensamblan los objetos contenido para presentar información significativa usuario final. boiko [boi] define estructura como “mapas que tienden sobre conjunto trozos contenido [objetos] para organizarlos hacerlos accesibles las personas que los necesitan”. .. administración contenido administración contenido relaciona con administración configuración tanto sistema administración contenido (sac) establece proceso, apoyado por herramien-tas adecuadas, que éstas adquieren contenido existente ( amplio arreglo objetos configuración webapp), que los estructura forma que les permite presentarse usuario final luego ofrecerlo entorno del lado cliente para despliegue. uso más común sistema administración contenido ocurre cuando construye una webapp dinámica. las webapps dinámicas crean páginas web “ vuelo”, decir, usuario ¿cómo determina quién tiene responsabilidad webapp?? cita: “ administración del conteni- antídoto frenesí informativo actualidad.” bob boiko (-).indd (-).indd // ::// :: parte tres administración calidad por general consulta webapp para requerir información específica. webapp consulta una base datos, formatea información concordancia presenta usuario. por ejemplo, una compañía musical ofrece una librería discos compactos para venta. cuando usua-rio solicita disco compacto equivalente música electrónica, consulta una base datos descarga información variada acerca del artista, disco compacto (por ejemplo, portada gráficos), contenido musical audio muestra configura una plantilla contenido estándar. página web resultante construye lado servidor pasa -vegador lado cliente para examen por parte del usuario final. figura . mues-tra una representación genérica esto. sentido más general, sac “configura” contenido para usuario final invocar tres subsistemas integrados: subsistema recopilación, subsistema gestión sis-tema publicación [boi]. subsistema recopilación. contenido deriva datos información que debe crearse adquirirse por desarrollador contenido. subsistema recopilación abarca todas las acciones requeridas para crear / adquirir contenido las funciones técnicas que necesitan para ) con vertir contenido una forma que pueda representarse mediante lenguaje marcaje (por ejemplo, html, xml) ) organizar contenido paquetes que puedan desplegarse efectivamente lado cliente. creación adquisición contenido (con frecuencia llamado autoría) usualmente ocurre paralelo con otras actividades desarrollo webapps con frecuencia realizan -sarrolladores contenido técnicos. esta actividad combina elementos creatividad -vestigación apoya con herramientas que permiten autor del contenido caracterizar éste forma que puede estandarizarse para uso dentro webapp. una vez que existe contenido, debe convertirse para adecuarse los requerimientos sac. esto implica desnudar contenido bruto cualquier información innecesaria (por ejem-plo, representaciones gráficas redundantes), formatear contenido para adecuarse los reque-rimientos del sac mapear los resultados una estructura información que permitirá manejarse publicarse.base datos plantillas lado servidorcódigo html + guionesnavegador lado clienteobjetos conﬁguración sistema administración del contenidofigura . sistema administración del contenido punto clave subsistema recopilación abarca todas las acciones requeridas para crear, adquirir / convertir contenido una forma que pueda presentarse lado cliente. (-).indd (-).indd // ::// :: administración configuración del software subsistema administración. una vez que existe contenido, debe almacenarse repositorio, catalogarse para adquisición uso posterior etiquetarse para definir: ) - tado actual (por ejemplo, ¿ objeto contenido está completo desarrollo?), ) versión adecuada del objeto contenido ) los objetos contenido relacionados. por tanto, sub- sistema administr ación implementa repositorio que abarca los siguientes elementos: • base datos contenido: estructura información que establece para almacenar todos los objetos contenido • capacidades base datos: funciones que permiten sac buscar objetos contenido específicos ( categorías objetos), almacenar recuperar objetos, admi-nistrar estructura archivos que establece para contenido • funciones administración configuración: los elementos funcionales flujo trabajo asociado que apoyan identificación del objeto contenido, control versión, administración del cambio, auditoría del cambio los reportes. además estos elementos, subsistema administración implementa una función admi-nistración que abarca los metadatos las reglas que controlan estructura global del contenido forma que soporta. subsistema publicación. contenido debe extraerse del repositorio, convertirse una forma que sea manejable para publicación formatearse modo que pueda transmitirse navegadores lado cliente. subsistema publicación logra estas tareas usando una serie plantillas. cada plantilla una función que construye una publicación usando uno tres componentes diferentes [boi]: • elementos estáticos: texto, gráficos, medios audiovisuales guiones que requieren más procesamiento transmiten directamente lado cliente. • servicios publicación: función invoca servicios recuperación formateo especí-ficos que personalizan contenido (usando reglas predefinidas), realizan conversión datos construyen vínculos navegación adecuados. • servicios externos: acceso infraestructura información corporativa externa, como datos empresariales aplicaciones “cuarto trasero”. sistema administración del contenido que abarque cada uno estos subsistemas aplicable para grandes proyectos web. sin embargo, filosofía funcionalidad básicas asocia-das con sac son aplicables todas las webapps dinámicas.punto clave subsistema administración implementa repositorio para todo contenido. administración configuración realiza dentro este subsistema. punto clave subsistema publicación extrae contenido del repositorio entrega navegadores lado cliente. las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus res- pectivos desarrolladores.objetivo: auxiliar los ingenieros software - sarrolladores contenido administración del conte- nido que incorpora las webapps. mecánica: las herramientas esta categoría permiten los inge- nieros web proveedores contenido actualizar contenido web-app forma controlada. mayoría establece sistema gestión archivos simple que asigna permisos actualización edición página por página para varios tipos contenido webapp. algunos mantienen sistema versiones, modo que una versión previa contenido pueda archivarse con propósitos históricos. herramientas representativas: vignette content management, desarrollado por vignette (www. vignette.com//products), una suite herramientas administración contenido empresarial.herramientas software administración contenido (-).indd (-).indd // ::// :: parte tres administración calidad .. administración del cambio flujo trabajo asociado con control del cambio para software convencional (sección ..) por general muy pesado para desarrollo webapps. improbable que - cuencia petición cambio, reporte cambio orden cambio ingeniería pueda lograrse forma ágil aceptable para mayoría los proyectos desarrollo web. entonces, ¿cómo gestiona torrente continuo cambios solicitados por contenido funcionalidad webapp? para implementar administración cambio efectiva dentro filosofía “codifica ” que continúa dominando desarrollo web debe modificarse proceso control cambio con-vencional. cada cambio debe categorizarse una cuatro clases: clase : cambio contenido función que corrige error aumenta contenido funcionalidad locales clase : cambio contenido función que tiene impacto sobre otros objetos contenido componentes funcionales clase : cambio contenido función que tiene amplio impacto través una web app (por ejemplo, extensión funcionalidad trascendental, significativo aumento -ducción contenido, grandes cambios requeridos navegación) clase : gran cambio diseño (por ejemplo, cambio diseño interfaz enfoque navegación) que inmediatamente será notable para una más categorías usuario una vez categorizado cambio solicitado, puede procesarse concordancia con algoritmo que muestra figura .. figura, los cambios las clases tratan manera informal manejan forma ágil. para cambio clase , evaluaría impacto del cambio, pero requiere revisión documentación externa. conforme realiza cambio, los procedimientos -trada salida estándar refuerzan mediante herramientas configuración repositorio. para los cambios clase , revisa impacto del cambio sobre objetos relacionados ( pide hacerlo otros desarrolladores responsables dichos objetos). cambio puede -cerse sin requerir cambios significativos otros objetos, modificación ocurre sin revisión documentación adicional. requieren cambios sustantivos, necesario más evaluación planificación. los cambios clases también tratan forma ágil, pero requiere alguna docu- mentación descriptiva más procedimientos revisión formal. para los cambios clase , desarrolla una descripción del cambio que describe cambio proporciona una breve valora-ción del impacto del mismo. descripción distribuye todos los miembros del equipo, quienes revisan cambio para valorar mejor impacto. para los cambios clase , tam-bién desarrolla una descripción del cambio, pero este caso realizan todos los partici-pantes.ektron-cms, desarrollada por ektron ( una suite herramientas que proporciona capacidades admi- nistración contenido herramientas desarrollo web. omniupdate, desarrollada por websiteasp, inc. (www. omniupdate.com), una herramienta que permite provee-dores contenido autorizados desarrollar actualizaciones con-troladas contenido web específico. los siguientes sitios web puede encontrarse información adicional acerca acs herramientas administración contenido para ingeniería web: web developer’ virtual encyclopedia ( com), webdeveloper ( developer shed ( webknowhow.net ( webreference ( (-).indd (-).indd // ::// :: administración configuración del software clasiﬁcar cambio solicitado adquiere objetos relacionados valora impacto cambiodesarrolla breve descripción escrita del cambio transmite todos los miembros del equipo para revisión sacar objeto() para cambiardesarrolla breve descripción escrita del cambio hacer diseño cambios, construir, probar ingresar objeto() que cambió(aron) publicar webapptransmite todos los participantes para revisión cambios requeridosen objetosrelacionados requieremásevaluaciónse requieremásevaluación bien pararealizarbien pararealizarcambio clase cambio clase cambio clase clase . administración cambios para webapps las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus res- pectivos desarrolladores.objetivo: auxiliar los ingenieros web desarrollado- res contenido administrar los cambios objetos configuración webapp conforme estos realizan. mecánica: esta categoría, las herramientas desarrollaron ori- ginalmente para software convencional, pero pueden adaptarse para uso por parte ingenieros web desarrolladores contenido fin realizar cambios controlados webapps. soportan entrada salida automatizadas, control reconstrucción versiones, reporte otras funciones acs. herramientas representativas: changeman wcm, desarrollada por serena ( una suite herramientas administración del cambio que proporcionan capacidades acs completas.clearcase, desarrollada por rational (www-.ibm.com/soft- ware/rational/-atoz/indexc.html), una suite herramientas que proporciona todas las capacidades adminis-tración configuración para webapps. source integrity, desarrollada por mks ( una herramienta acs que puede integrarse con entornos desarrollo seleccionados.herramientas software gestión del cambio (-).indd (-).indd // ::// :: parte tres administración calidad .. control versión conforme una webapp evoluciona través una serie incrementos, pueden existir mismo tiempo algunas versiones diferentes. una versión ( webapp operativa actual) está disponible mediante internet para usuarios finales; otra ( siguiente incremento webapp) puede estar las etapas finales prueba antes implementación; una tercera versión está desa-rrollo representa una gran actualización contenido, estética interfaz funcionalidad. los objetos configuración deben definirse con claridad, modo que cada uno pueda asociarse con versión adecuada. además, deben establecerse mecanismos control. dreilinger [dre] analiza importancia del control versiones ( cambios) cuando escribe: sitio descontrolado, donde múltiples autores tienen acceso para editar contribuir, surge potencial para conflictos problemas, más aún dichos autores trabajan desde diferentes oficinas diferentes momentos del día noche. usted puede pasar día mejorando archivo index.html para cliente. después que usted realiza sus cambios, otro desarrollador que trabaja casa después las horas oficina, otra oficina, puede pasar noche actualizando propia versión recientemente revisada del archivo index.html, ¡ sobreescribir por completo trabajo sin que haya forma recuperarlo! probable que usted haya experimentado una situación similar. para evitarla, requiere proceso control versiones. . debe establecerse repositorio centr para proyecto web , que contendrá las versiones actuales todos los objetos configuración webapp (contenido, componentes funcio- nales otros). . cada ingeniero web crea propia carpeta abajo, que contiene aquellos objetos que crean cambian cualquier momento. . los relojes todas las estaciones abajo los desarrolladores deben estar sincroniza- dos para evitar conflictos sobreescritura cuando dos desarrolladores realizan actuali- zaciones que están muy cercanas tiempo. . conforme desarrollan uevos objetos configuración cambian los objetos existen- tes, deben importarse hacia repositorio central. herramienta control versión (vea discusión svc barra lateral) gestionará todas las funciones entrada salida las carpetas trabajo cada desarrollador web. cuando hagan cambios repositorio, herramienta también proporcionará actualizaciones automáticas por correo electrónico todas las partes interesadas. . conforme los objetos importen exporten del repositorio, elabor mensaje bitácora automático con marca tiempo. esto proporciona información útil para auditar puede volverse parte esquema reporte efectivo. herramienta control versión conserva diferentes versiones webapp puede rever- tir una ellas una versión más antigua requiere. .. auditoría reporte con intención obtener agilidad, las funciones auditoría reporte tienen mucho -fasis trabajo ingeniería web. sin embargo, eliminan por completo. todos los objetos que entran salen del repositorio registran una bitácora que puede revisarse esto empieza cambiar. hay creciente énfasis acs como elemento seguridad webapp [sar]. proporcionar mecanismo para rastrear reportar todo cambio hecho cada objeto web, una - rramienta administración del cambio puede proporcionar valiosa protección contra cambios maliciosos. (-).indd (-).indd // ::// :: administración configuración del software cualquier momento. posible crear reporte bitácora completo modo que todos los miembros del equipo web tengan una cronología los cambios hechos periodo definido. además, puede enviarse una notificación automatizada por correo electrónico (dirigida aque-llos desarrolladores participantes que tengan interés) cada vez que objeto entre salga del repositorio. siguiente lista estándares acs (extraída parte razonablemente exhaustiva: estándares ieee standards.ieee.org/ catalog/olis/ ieee software para planes administración configuración ieee software para administración configuración estándares iso isoonline.frontpage iso - administración calidad, guía para aciso/iec software tecnología información- procesos ciclo vida iso/iec guía para iso/iec /iec ingeniería software-proceso ciclo vida software-orden software para administración configuración estándares eia estándar consenso nacional para administración configuración eia cmb- definiciones administración configuración para programas cómputo digitales eia cmb- identificación configuración para programas cómputo digitales eia cmb- librerías software cómputoeia cmb- control cambio configuración para programas cómputo digitales eia cmb- orden referencias administración configuración datoseia cmb- identificación configuración eia cmb- control configuración eia cmb- libro texto para contabilidad estado configuración eia cmb- intercambio electrónico datos administración configuración estándares información estándares mil: militares eua www-library.itsi.disa.mildod mil std- administración configuraciónmil-hdbk- guía para administración configuración otros estándares:- lineamientos para desarrollo software aviación esa pss-- guía para administración configuración del software aecl --std estándar para ingeniería software crucial rev. para seguridaddoe scm checklist: http://cio.doe.gov/itreform/ sqse/download/cmcklst.doc - british std., administración configuración sistemas basados computadoras best practice— oficina comercio gubernamental: cmii instituto mejores prácticas : configuration management resource guide (guía recursos administración configuración) proporciona información comple-mentaria para los interesados procesos práctica . está dispo-nible estándares acs . esumen administración configuración del software una actividad sombrilla que aplica largo del proceso software. acs identifica, controla, audita reporta las modificaciones que invariablemente ocurren mientras software desarrolla después que libera cliente. todos los productos trabajo creados como fases ingeniería software vuel-ven parte una configuración del software. configuración organiza manera que per-mite control ordenado del cambio. configuración del software compone conjunto objetos interrelacionados, tam- bién llamados ítems configuración del software (ics), que producen como resultado alguna actividad ingeniería software. además documentos, programas datos, - (-).indd (-).indd // ::// :: parte tres administración calidad torno desarrollo que usa para crear software también puede colocarse bajo control configuración. todos los ics almacenan dentro repositorio que implementa con-junto mecanismos estructuras datos para asegurar integridad los datos, proporcio-nar apoyo integración para otras herramientas software (información apoyo que com-parte entre todos los miembros del equipo software) implementar funciones apoyo control versiones cambios. una vez desarrollado revisado objeto configuración, convierte línea referen- cia. los cambios objeto convertido línea referencia dan como resultado creación una nueva versión dicho objeto. evolución programa puede rastrearse exami-nar historia revisión todos los objetos configuración. control versiones conjunto procedimientos herramientas que sirven para administrar uso dichos -jetos. control cambios una actividad procedimental que garantiza calidad consisten- cia conforme realizan cambios objeto configuración. proceso control cam-bios comienza con una petición cambios, conduce una decisión para hacer rechazar petición del cambio culmina con una actualización controlada del ics que debe cambiarse. auditoría configuración una actividad sqa que ayuda garantizar que calidad conserva conforme realizan cambios. reporte estado proporciona información acerca cada cambio quienes necesitan conocerla. administración configuración para webapps similar muchos aspectos acs para software convencional. sin embargo, cada una las tareas núcleo acs debe dinamizarse para hacerla tan magra como sea posible deben implementarse provisiones especiales para administración del contenido. problemas puntos por evaluar .. ¿por qué verdadera primera ley ingeniería sistemas? ofrezca ejemplos específicos para cada una las cuatro razones fundamentales para cambio. .. ¿cuáles son los cuatro elementos que existen cuando implementa sistema acs efectivo? analice cada uno brevemente. .. explique con sus palabras las razones para las líneas referencia... suponga que usted gerente proyecto pequeño. ¿qué líneas referencia definiría para proyecto cómo las controlaría? .. diseñe sistema base datos proyecto (repositorio) que permitiría ingeniero del soft- ware almacenar, poner referencias cruzadas, rastrear, actualizar cambiar todos los ítems configuración software importantes. ¿cómo manejaría base datos diferentes versiones del mismo programa? ¿ código fuente manejaría manera diferente documentación? ¿cómo prohibiría dos desarrolla-dores hacer diferentes cambios mismo tiempo mismo ics? .. investigue una herramienta acs existente describa cómo implementa control para versiones, - riantes objetos configuración general. .. las relaciones <parte <interrelacionado representan relaciones simples entre objetos con- figuración. describa cinco relaciones adicionales que puedan ser útiles contexto repositorio acs. .. investigue acerca una herramienta acs existente describa cómo implementa mecánica control versiones. manera alternativa, lea dos tres ensayos acerca acs describa las diferentes estructuras datos mecanismos referencia que usan para control versiones. .. desarrolle una lista verificación para usar durante las auditorías configuración... ¿cuál diferencia entre una auditoría acs una revisión técnica? ¿ función puede plegarse una revisión? ¿cuáles son los pros los contras? (-).indd (-).indd // ::// :: administración configuración del software .. describa brevemente las diferencias entre acs para software convencional acs para webapps. .. ¿qué administración del contenido? use web para investigar las características una - rramienta administración del contenido ofrezca resumen breve. lecturas adicionales fuentes información entre las propuestas lecturas sobre acs más recientes encuentran leon (software configuration man-agement handbook, . ., artech house publishers, ), maraia (the build master: microsoft’ software configuration management best practices, addison-wesley, ), keyes (software configuration management, auerbach, ) hass ( configuration management principles and practice, addison-wesley, ). cada uno estos libros presenta todo proceso acs con detalle sustancial. maraia ( software configuration manage- ment implementation roadmap, wiley, ) ofrece una guía única “cómo hacer” para quienes deben implementar acs dentro una organización. lyon (practical , raven publishing, , disponible escribió una guía exhaustiva para profesional , que incluye lineamientos pragmáticos para implementar cada aspecto sistema administración configuración ( actua-liza anualmente). white clemm (software configuration management strategies and rational clearcase , addison-wesley, ) presentan acs dentro del contexto una las herramientas acs más populares. berczuk appleton (software configuration management patterns , addison-wesley, ) proponen varios patrones útiles que ayudan comprender acs implementar manera efectiva sistemas acs. brown . ( anti-patterns and patterns software configuration management, wiley, ) estudian las cosas que hacen (antipatrones) cuando implementa proceso acs luego consideran sus remedios. bays ( soft- ware release methodology, prentice hall, ) enfoca mecánica “liberación exitosa producto”, importante complemento acs efectiva. conforme las webapps vuelven más dinámicas, administración del contenido convertido tema esencial para los ingenieros web. los libros white ( the content management handbook, curtin uni- versity books, ), jenkins . (enterprise content management methods, open text corporation, ), boiko [boi], mauthe thomas (professional content management systems, wiley, ), addey . (con- tent management systems, glasshaus, ), rockley ( managing enterprise content, new riders press, ), hackos (content management for dynamic web delivery, wiley, ), nakano (web content management, addison- wesley, ) presentan tratamientos valiosos del tema. además discusiones genéricas del tema, lim . (enhancing microsoft content management server with asp.net ., packt publishing, ), ferguson (creating content management systems java, charles river media, ), ibm redbooks (ibm workplace web content management for portal . and ibm workplace web content management ., vivante, ), fritz . (typo: enterprise content management, packt publis- hing, ) forta (reality coldfusion: intranets and content management, pearson education, ) abordan administración del contenido dentro del contexto herramientas lenguajes específicos. internet está disponible una gran variedad fuentes información acerca ingeniería admi- nistración configuración del software administración del contenido. una lista actualizada refe-rencias world wide web que son relevantes para administración configuración del software puede encontrarse sitio del libro: olc/ser.htm. (-).indd (-).indd // ::// :: producto conceptos clave diseño interfaz usuario . . . . . . . . . . . . . diseño webapp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . /pregunta/ métrica (mpm) . . . . . . . . . . métricas atributos . . . . . . . . . . . código fuente . . . . . . . . . . diseño arquitectónico. . . . . diseño . . . . . . . . . . . . modelo requerimientos . orientado clase. . . . . . . . pruebas . . . . . . . . . . . . . . principios medición . . . . . función () . . . . . ¿qué ? por naturaleza, ingeniería una disciplina cuantitativa. las métricas pro-ducto ayudan los ingenieros software obtener comprensión acerca del diseño construcción del software que elaboran, enfocarse atributos mensurables específicos los productos tra-bajo ingeniería del software. ¿quién hace? los ingenieros software usan métricas proyecto para auxiliarse construcción software mayor calidad. ¿por qué importante? siempre habrá elemento cualitativo creación del software para computadoras. problema que valoración cualitativa tal vez sea suficiente. necesitan criterios objetivos que ayuden guiar diseño datos, arquitectura, interfaces compo-nentes. cuando prueban, necesaria guía cuantita-tiva que ayuda selección los casos prueba sus objetivos. las métricas producto proporcionan una base desde donde análisis, diseño, codificación las pruebas pueden realizarse manera más objetiva valorarse modo más cuantitativo. ¿cuáles son los pasos? primer paso proceso medición derivar las mediciones métricas del software que sean adecuadas para presentación del software que está construyendo. continuación, recolectan los datos requeridos para derivar las métricas formuladas. una vez calculadas, las métricas adecuadas analizan con base lineamientos preestablecidos datos ante-riores. los resultados del análisis interpretan para obte-ner comprensión acerca calidad del software, los resultados interpretación conducen modificación requerimientos modelos diseño, código fuente casos prueba. algunas instancias, también puede conducir modificación del proceso software . ¿cuál producto final? las métricas producto que calculan partir los datos recolectados los modelos requerimientos diseño, código fuente casos prueba. ¿cómo aseguro que hice bien? debe esta- blecer los objetivos medición antes comenzar recolección datos debe definir cada métrica pro-ducto sin ambigüedades. defina sólo algunas métricas luego úselas para obtener comprensión acerca cali-dad producto trabajo ingeniería del soft-ware. una mirada rápidaun elemento clave cualquier proceso ingeniería medición. pueden usarse - didas para entender mejor los atributos los modelos que crean para valorar calidad los productos sistemas sometidos ingeniería que construyen. pero, diferencia otras disciplinas ingeniería, del software está asentada las leyes cuantitativas física. mediciones directas, como voltaje, masa, velocidad temperatura, son raras mundo del software. puesto que las mediciones métricas del software con frecuencia son indirectas, están abiertas debate. fenton [fen] aborda este conflicto cuando afirma: medición proceso mediante cual asignan números símbolos los atributos las entida- des mundo real, manera que les define acuerdo con reglas claramente determinadas [...] ciencias físicas, medicina, economía más recientemente ciencias sociales, ahora posible medir atributos que anteriormente consideraban inmensurables [...] desde luego, tales mediciones son tan refinadas como muchas mediciones las ciencias físicas [...], pero existen [ con base ellas toman decisiones importantes]. sentimos que obligación intentar “medir inmensura-ble” para mejorar comprensión entidades particulares tan poderosa ingeniería del soft-ware como cualquiera otra disciplina. pero algunos miembros comunidad del software continúan argumentando que software “inmensurable” que los intentos por medir deben posponerse hasta comprender mejor software los atributos que deben usarse para describirlo. esto error. (-).indd (-).indd // ::// :: métricas producto aunque las métricas producto para software computadora son imperfectas, pueden proporcionar una forma sistemática valorar calidad con base conjunto reglas claramente definidas. también proporcionan comprensión inmediata, lugar hacerlo des-pués los hechos. esto permite descubrir corregir potenciales problemas antes que conviertan defectos catastróficos. este capítulo presentan las mediciones que pueden usarse para valorar calidad del producto conforme somete ingeniería. estas mediciones atributos internos del producto ofrecen una indicación tiempo real eficacia los modelos requerimientos, diseño código, así como efectividad los casos prueba calidad global del software que construir. . arco conceptual para las métricas producto como anotó introducción, medición asigna números símbolos atributos enti-dades mundo real. para lograr esto, requiere modelo medición que abarque conjunto consistente reglas. aunque teoría medición (por ejemplo, [kyb]) aplicación software computadora (por ejemplo, [zus]) son temas que están más allá del ámbito este libro, vale pena establecer marco conceptual fundamental conjunto principios básicos que guíen definición las métricas producto para software. .. medidas, métricas indicadores aunque los términos medida, medición métrica con frecuencia usan modo intercambia-ble, importante observar las sutiles diferencias entre ellos. contexto ingeniería del software, una medida proporciona indicio cuantitativo extensión, cantidad, dimensión, capacidad tamaño algún atributo producto proceso. medición acto - terminar una medida. ieee standard glosary software engineering terminology [iee] define métrica como “una medida cuantitativa del grado que sistema, componente proceso posee atributo determinado”. cuando recolectado solo punto datos (por ejemplo, número errores descu- biertos dentro solo componente software), establece una medida. medición ocurre como resultado recolección uno más puntos datos (por ejemplo, algunas revisiones componente pruebas unidad investigan para recolectar medidas del -mero errores cada uno). una métrica software relaciona alguna forma las medidas individuales (por ejemplo, número promedio errores que encuentran por revisión número promedio errores que encuentran por unidad prueba). ingeniero software recolecta medidas desarrolla métricas modo que obtengan indicadores. indicador una métrica combinación métricas que proporcionan com-prensión acerca del proceso software, proyecto software producto . indica-dor proporciona comprensión que permite gerente proyecto los ingenieros software ajustar proceso, proyecto producto para hacer mejor las cosas. .. reto métrica producto durante las cuatro décadas pasadas, muchos investigadores intentaron desarrollar una sola métrica que proporcionara una medida abarcadora complejidad del software. fenton [fen] caracteriza esta investigación como una búsqueda del “imposible santo grial”. aunque han propuesto decenas medidas complejidad [zus], cada una toma una visión poco diferente que complejidad qué atributos sistema conducen com-plejidad. por analogía, considere una métrica para evaluar automóvil atractivo. algunos observadores pueden enfatizar diseño carrocería; otros pueden considerar característi-cita: “una ciencia tan madura como sus herramientas medi-ción.” louis pasteur ¿cuál diferencia entre una medida una métrica?? punto clave indicador una varias métricas que proporcionan comprensión acerca del proceso, producto proyecto. (-).indd (-).indd // ::// :: parte tres administración calidad cas mecánicas; otros más pueden destacar costo rendimiento uso combustibles alternativos capacidad para reciclar cuando carro sea chatarra. dado que cualquiera estas características puede estar desacuerdo con otras, difícil derivar solo valor para “atractivo”. mismo problema ocurre con software computadora. aunque existe necesidad medir controlar complejidad del software, bien solo valor esta métrica calidad difícil derivar, posible desarrollar medidas -ferentes atributos internos programa (por ejemplo, modularidad efectiva, independencia funcional otros atributos estudiados capítulo ). estas medidas las métricas derivadas ellas pueden usarse como indicadores independientes calidad los modelos reque-rimientos diseño. pero aquí nuevo surgen problemas. fenton [fen] observa esto cuando afirma: “ peligro intentar encontrar medidas que caracterizan tantos atributos dife-rentes que, inevitablemente, las medidas tienen que satisfacer objetivos conflicto. esto contrario teoría representacional las mediciones”. aunque enunciado fenton correcto, muchas personas argumentan que medición producto realizada durante las primeras etapas del proceso software brinda los ingenieros software mecanismo consistente objetivo para valorar calidad. sin embargo, justo preguntar cuán válidas son las métricas producto, decir, ¿cuán cercanamente alinean las métricas producto con confiabilidad largo plazo con calidad sistema basado computadora? fenton [fen] aborda esta pregunta forma siguiente: pesar las conexiones intuitivas entre estructura interna los productos software [métricas producto] sus atributos externos producto proceso, realidad habido pocos intentos científicos para establecer relaciones específicas. existen algunas razones por las que esto así; más comúnmente citada impráctico que resulta realizar experimentos relevantes. cada uno los “retos” anotados aquí motivo precaución, pero razón para - sechar las métricas producto. medición esencial debe lograrse calidad. .. principios medición antes presentar una serie métricas producto que ) auxilien evaluación los modelos análisis diseño, ) proporcionen indicio complejidad los diseños pro-cedimentales del código fuente ) faciliten diseño pruebas más efectivas, importante comprender los principios medición básicos. roche [roc] sugiere proceso medición que puede caracterizarse mediante cinco actividades: • formulación. derivación medidas métricas software apropiadas para repre-sentación del software que está construyendo. • recolección. mecanismo que usa para acumular datos requeridos para derivar las métricas formuladas. • análisis. cálculo métricas aplicación herramientas matemáticas. • interpretación. evaluación las métricas resultantes para comprender calidad representación. • retroalimentación. recomendaciones derivadas interpretación las métricas del producto, transmitidas equipo software.cita: “así como medición tem- peratura comenzó con dedo índice... creció hasta escalas, herramientas técnicas sofisti-cadas, igual modo madura medición del software.” shari pfleeger webref horst zuse compiló voluminosa información acerca métrica producto irb..-berlin./~zuse/ aunque las críticas métricas específicas son comunes literatura, muchos críticos enfocan conflictos particulares pierden objetivo principal las métricas mundo real: ayudar ingeniero software establecer una vía sistemática objetiva para obtener comprensión trabajo mejorar calidad del pro-ducto resultante.¿cuáles son los pasos proceso medición efectivo?? (-).indd (-).indd // ::// :: métricas producto las métricas software serán útiles sólo caracterizan efectivamente validan manera adecuada. los siguientes principios [let] son representativos muchos que pue-den proponerse para caracterización validación métricas: • una métrica debe tener propiedades matemáticas deseables, decir, valor métrica debe estar rango significativo (por ejemplo, , donde realmente significa ausencia, indica valor máximo . representa “punto medio”). además, una métrica que intente estar una escala racional debe constituirse con componentes que sólo miden una escala ordinal. • cuando una métrica representa una característica software que aumenta cuando ocurren rasgos positivos que disminuye cuando encuentran rasgos indeseables, valor métrica debe aumentar disminuir misma forma. • cada métrica debe validarse manera empírica una gran variedad contextos antes publicarse utilizarse para tomar decisiones. una métrica debe medir factor interés, independientemente otros factores. debe “escalar” sistemas más grandes funcionar varios lenguajes programación dominios sistema. aunque formulación, caracterización validación son cruciales, recolección análisis son las actividades que impulsan proceso medición. roche [roc] sugiere los siguientes principios para dichas actividades: ) siempre que sea posible, recolección análisis datos deben automatizarse; ) deben aplicarse técnicas estadísticas válidas para establecer -laciones entre atributos producto internos características calidad externas (por ejemplo, nivel complejidad arquitectónica correlaciona con número defectos reportados uso producción), ) para cada métrica deben establecerse lineamientos recomenda-ciones interpretativos. .. medición software orientado meta paradigma meta/pregunta/métrica (mpm) fue desarrollado por basili weiss [bas] como una técnica para identificar métricas significativas para cualquier parte del proceso software. mpm enfatiza necesidad : ) establecer una meta medición explícita que sea específica para actividad del proceso para característica del producto que quiera valorar, ) defi-nir conjunto preguntas que deban responderse con finalidad lograr meta ) identificar métricas bien formuladas que ayuden responder dichas preguntas. para definir cada meta medición, puede usarse una plantilla definición meta [bas]. plantilla toma forma: analizar { nombre actividad atributo que medir} con propósito { objetivo global del análisis} con respecto { aspecto actividad atributo que considera} desde punto vista {las personas que tienen interés medición} contexto { entorno que tiene lugar medición}. como ejemplo, considere una plantilla definición meta para casasegura: analizar arquitectura del software casasegura con propósito evaluar los componentes - quitectónicos con respecto capacidad hacer casasegura más extensible desde punto vista los ingenieros software que realizan trabajo contexto mejora del producto durante los próximos tres años. realidad, muchas métricas producto actualmente uso concuerdan con dichos principios tanto como debieran. pero eso significa que tengan valor; sólo tenga cuidado cuando los use entienda que tienen intención proporcionar comprensión, estricta verificación científica.consejo webref goldpractices/practices/gqma.html puede encontrar útil foro discusión sobre mpm. van solingen berghout [sol] sugieren que objeto casi siempre “comprender, controlar mejorar” actividad del proceso atributo del producto. (-).indd (-).indd // ::// :: parte tres administración calidad con una meta medición definida manera explícita, desarrolla conjunto preguntas. las respuestas ayudarán equipo software ( otros participantes) determinar logró meta medición. entre las preguntas que pueden plantearse encuentran: : ¿los componentes arquitectónicos caracterizan forma que compartimentali-zan función los datos relacionados? : ¿ complejidad cada componente dentro las fronteras facilitará modifica-ción extensión? cada una estas preguntas debe responderse manera cuantitativa, usando una más -didas métricas. por ejemplo, una métrica que proporciona indicio cohesión (capítulo ) componente arquitectónico puede ser útil para responder . las métricas que estu- dian más adelante este capítulo pueden proporcionar comprensión para . todo caso, las métricas que eligen ( derivan) deben corresponderse con los principios medición anali-zados sección .. con los atributos medición expuestos sección ... .. atributos las métricas software efectivas han propuesto cientos métricas para software computadora, pero todas brindan apoyo práctico ingeniero software. algunas demandan medición demasiado compleja, otras son tan particulares que pocos profesionales del mundo real tienen alguna esperanza entenderlas otras más violan las nociones intuitivas básicas que realmente software alta calidad. ejiogu [eji] define conjunto atributos que deben abarcar las métricas software efectivas. métrica derivada las medidas que conducen ella deben ser: • simple calculable. debe ser relativamente fácil aprender cómo derivar métrica cálculo debe demandar esfuerzo tiempo excesivo. • empírica intuitivamente convincente. debe satisfacer las nociones intuitivas del ingeniero acerca del atributo producto que elabora (por ejemplo, una métrica que mide cohesión del módulo debe aumentar valor conforme aumenta nivel cohesión). • congruente objetiva. siempre debe producir resultados que tengan ambigüedades. una tercera parte independiente debe poder derivar mismo valor métrica usando misma información acerca del software. • constante uso unidades dimensiones. cálculo matemático métrica debe usar medidas que conduzcan combinaciones extrañas unidades. por ejemplo, multiplicar personas los equipos proyecto por variables lenguaje programa-ción programa como resultado una mezcla sospechosa unidades que son intuitivamente convincentes. • independiente del lenguaje programación. debe basarse modelo requeri- mientos, modelo diseño estructura del programa . debe depender los caprichos sintaxis semántica del lenguaje programación. • mecanismo efectivo para retroalimentación alta calidad. debe proporcionar informa- ción que pueda conducir producto final mayor calidad. aunque mayoría las métricas software satisfacen estos atributos, algunas métricas uso común pueden fracasar para satisfacer uno dos ellos. ejemplo punto función (que estudia sección ..), una medida “funcionalidad” entregada por soft-ware. puede argumentarse que atributo congruente objetiva fracasa porque una tercera ¿cómo valora calidad una métrica software propuesta?? experiencia indica que una métrica producto sólo usará intuitiva fácil calcular. tienen que hacer decenas “conteos” requieren cálculos complejos, improbable que métrica adopte ampliamente.consejo puede plantearse contrargumento igualmente vigoroso. tal naturaleza las métricas del software. (-).indd (-).indd // ::// :: métricas producto parte independiente puede ser capaz derivar mismo valor del punto función que colega que use misma información acerca del software. por tanto, ¿debe rechazarse medida ? respuesta “¡desde luego que !”. proporciona comprensión útil , consecuen-cia, ofrece distinto valor, incluso falla satisfacer atributo perfección. escena: cubículo vinod. participantes: vinod, jamie , miembros del equipo ingeniería del software casasegura, quienes continúan trabajando diseño nivel componentes diseño casos prueba. conversación:vinod: doug [doug miller, gerente ingeniería del software] dijo que todos debemos usar métricas producto, pero fue muy vago. también dijo que presionaría... que usarlas era asunto nuestro. jamie: eso está bien porque hay forma que tenga tiempo para comenzar esa cosa las medidas. estamos peleando por mantener calendario como está. : estoy acuerdo con jamie. estamos contra, aquí... tene- mos tiempo. vinod: , , pero probablemente hay algún mérito usarlas.jamie: discuto, vinod, cuestión tiempo... , que respecta, tengo para perderlo. vinod: pero, ¿ las mediciones ahorran tiempo?: estás mal, requieren tiempo, , como dijo jamie... vinod: , espera... ¿ nos ahorra tiempo?jamie: ¿cómo?vinod: volver trabajar... así cómo. una medida que usemos nos ayuda evitar problema grande incluso moderado, esto evita que tengamos que volver trabajar una parte del sistema, aho-rramos tiempo. ¿ ? : posible, supongo, ¿pero puedes garantizarnos que alguna métrica producto nos ayudará encontrar problema? vinod: ¿puedes garantizarme que hará?jamie: ¿ qué que propones?vinod: creo que debemos seleccionar algunas métricas diseño, probablemente orientadas clase, usarlas como parte nuestro proceso revisión para cada componente que desarrollemos. : estoy familiarizado con las métricas orientadas clase.vinod: pasaré algo tiempo revisándolas haré una recomen- dación... ¿está bien para ustedes? [ jamie asienten sin mucho entusiasmo.]casasegura debate acerca las métricas producto . étricas para modelo requerimientos trabajo técnico ingeniería del software comienza con creación del modelo reque- rimientos. esta etapa derivan los requerimientos establece cimiento para diseño. por tanto, son deseables métricas producto que proporcionen comprensión acerca -lidad del modelo análisis. aunque literatura han aparecido relativamente pocas métricas análisis especifica- ción, posible adaptar las métricas que usan frecuentemente para estimación proyectos aplicarlas este contexto. dichas métricas examinan modelo requerimientos con intención predecir “tamaño” del sistema resultante. ocasiones (mas siempre), tamaño indicador complejidad del diseño casi siempre indicador creciente codificación, integración esfuerzo pruebas. .. métrica basada funciones métrica punto función () puede usarse manera efectiva como medio para medir funcionalidad que entra sistema. usar datos históricos, métrica puede entonces usarse para: ) estimar costo esfuerzo requerido para diseñar, codificar probar software; acerca las métricas han escrito cientos libros, ensayos artículos. [ifp] puede encontrar una valiosa bibliografía. (-).indd (-).indd // ::// :: parte tres administración calidad ) predecir número errores que encontrarán durante las pruebas, ) prever número componentes / líneas fuente proyectadas sistema implementado. los puntos función derivan usando una relación empírica basada medidas contables (directas) del dominio información del software valoraciones cualitativas comple-jidad del software. los valores dominio información definen forma siguiente: número entradas externas (). cada entrada externa origina usuario transmite desde otra aplicación, proporciona distintos datos orientados aplicación -formación control. con frecuencia, las entradas usan para actualizar archivos lógicos internos (ali). las entradas deben distinguirse las consultas, que cuentan por sepa-rado. número salidas externas (). cada salida externa datos derivados dentro aplicación que ofrecen información usuario. este contexto, salida externa refiere reportes, pantallas, mensajes error, etc. los ítems datos individuales dentro -porte cuentan por separado. número consultas externas (). una consulta externa define como una entrada línea que como resultado generación alguna respuesta software inmedia- forma una salida línea (con frecuencia recuperada ali). número archivos lógicos internos (ali). cada archivo lógico interno agrupa- miento lógico datos que reside dentro frontera aplicación mantiene -diante entradas externas. número archivos interfaz externos (aie). cada archivo interfaz externo agrupamiento lógico datos que reside fuera aplicación, pero que proporciona infor-mación que puede usar aplicación. una vez recolectados dichos datos, tabla figura . completa valor comple-jidad asocia con cada conteo. las organizaciones que usan métodos punto función desarrollan criterios para determinar una entrada particular simple, promedio compleja. obstante, determinación complejidad tanto subjetiva. para calcular puntos función (), usa siguiente relación: / conteo total / [. / . / / ( )] (.) donde conteo total suma todas las entradas obtenidas figura .. los ( = ) son factores ajuste valor (fav) con base respuestas las siguientes preguntas [lon]: realidad, definición valores dominio información forma que cuentan son poco más complejos. para más detalles, lector interesado debe consultar [ifp].webref www. functionpoints.com puede obtenerse mucha información útil acerca los puntos función. entradas externas () / salidas externas () / consultas externas () / archivos interfaz externos (aie) / conteo totalarchivos lógicos internos (ali) / = == == dominio informaciónfactor ponderado conteo simple promedio complejo figura . cálculo puntos función (-).indd (-).indd // ::// :: métricas producto . ¿ sistema requiere respaldo recuperación confiables? . ¿ requieren comunicaciones datos especializadas para transferir información - cia desde aplicación? . ¿existen funciones procesamiento distribuidas? . ¿ desempeño crucial? . ¿ sistema correrá entorno operativo existente enormemente utilizado? . ¿ sistema requiere entrada datos línea? . ¿ entrada datos línea requiere que transacción entrada construya sobre múltiples pantallas operaciones? . ¿los ali actualizan línea? . ¿las entradas, salidas, archivos consultas son complejos? . ¿ procesamiento interno complejo? . ¿ código diseña para ser reutilizable? . ¿ conversión instalación incluyen diseño? . ¿ sistema diseña para instalaciones múltiples diferentes organizaciones? . ¿ aplicación diseña para facilitar cambio uso por parte del usuario? cada una estas preguntas responde usando una escala que varía ( importante aplicable) (absolutamente esencial). los valores constantes ecuación (.) los fac-tores ponderados que aplican los conteos dominio información determinan manera empírica. para ilustrar uso métrica este contexto, considere representación simple modelo análisis que ilustra figura .. figura, representa diagrama flujo datos (capítulo ) para una función dentro del software casasegur . función gestiona interacción del usuario, acepta contraseña éste para activar desactivar sistema permite consultas sobre estado las zonas seguridad varios sensores seguridad. función despliega una serie mensajes advertencia envía -ñales control adecuadas varios componentes del sistema seguridad. diagrama flujo datos evalúa para determinar conjunto medidas dominio información clave que son requeridas para calcular métrica punto función. -gura muestran tres entradas externas (contraseña, botón pánico activar/desacti- var), junto con dos consultas externas (consulta zona consulta sensor). muestra ali (archivo configuración sistema) también están presentes dos salidas externas punto clave los factores ajuste valor usan para proporcionar indicio complejidad del problema. webref irb..uni-mogdeburg./ -eng//java// puede encontrar una calculadora línea. usuariofunción interacción con usuario casaseguramensajes subsistema monitoreo respuestacontraseña, sensores . . .estado sensorsensores datos conﬁguración sistemaalerta alarmaactivar/desactivarestablecimiento zonasensor prueba usuarioconsulta sensor botón pánicoactivar/desactivarconsulta zonacontraseñafigura . modelo flujo datos para software casasegura (-).indd (-).indd // ::// :: parte tres administración calidad (mensajes estado sensor) cuatro aie (sensor prueba, establecimiento zona, activar/desactivar alerta alarma). figura . muestran estos datos, junto con complejidad adecuada. conteo total que muestra figura . debe ajustarse usando ecuación (.). para los propósitos este ejemplo, suponga que /() ( producto moderadamente complejo). por tanto, / / [. / (. / )] / con base valor proyectado, derivado del modelo requerimientos, equipo del pro- yecto puede estimar tamaño global implementado función interacción del usuario casasegura. suponga que los datos anteriores indican que traduce líneas -digo ( usará lenguaje orientado objeto) que producen por cada persona-mes esfuerzo. estos datos históricos ofrecen gerente proyecto información importante planificación que basa modelo requerimientos estimaciones preliminares. suponga aún más, que los proyectos pasados encontró promedio tres errores por punto función durante las revisiones requerimientos diseño, cuatro errores por punto función durante las pruebas unidad integración. final cuentas, dichos datos pueden ayudarlo valorar completo sus actividades revisión pruebas. uemura . [uem] sugieren que los puntos función también pueden calcularse par- tir clases uml diagramas secuencia. tiene más interés, consulte detalles [uem]. .. métricas para calidad especificación davis . [dav] proponen una lista características que pueden usarse para valorar calidad del modelo requerimientos correspondiente especificación requerimientos: especificidad (falta ambigüedad), completitud, corrección, comprensibilidad, verificabilidad, consistencia interna externa , factibilidad, concisión, rastreabilidad, modificabilidad, precisión reusabilidad. además, los autores observan que las especificaciones alta calidad almace-nan electrónicamente, son ejecutables menos interpretables, anotan mediante importan-cia relativa, son estables, tienen versión, organizan, cuentan con referencia cruzada especifican nivel correcto detalle. aunque muchas estas características parecen ser cualitativas por naturaleza, davis . [dav] sugieren que cada una puede representarse usando una más métricas. por ejemplo, supone que existen requerimientos una especificación, tales que / / nnf donde número requerimientos funcionales nnf número requerimientos funcionales (por ejemplo, rendimiento).entradas externas () / salidas externas () / consultas externas () / archivos interfaz externos (aie) / conteo totalarchivos lógicos internos (ali) / = == == dominio informaciónfactor ponderado conteo simple promedio complejo . cálculo puntos función cita: “ lugar sólo meditar acerca cuál ‘nueva métrica’ aplicar [...] también debemos plantear-nos pregunta más básica: ¿qué haremos con las métri-cas?” michael mah larry putnam (-).indd (-).indd // ::// :: métricas producto para determinar especificidad (falta ambigüedad) los requerimientos, davis ., sugieren una métrica que basa consistencia interpretación los revisores cada requisito: / nui donde nui número requerimientos para los cuales todos los revisores tienen interpreta- ciones idénticas. mientras más cercano esté valor , menor será ambigüedad especificación. completitud los requerimientos funcionales puede determinarse calcular razón / / donde número requerimientos funcionales únicos, número entradas (- tímulos) definidas implicadas por especificación número estados especificados. razón mide porcentaje funciones necesarias que especificaron para sistema. sin embargo, aborda requerimientos funcionales. para incorporar éstos una métrica global completitud, debe considerar grado que validaron los requerimientos: / + nnv donde número requerimientos que validaron como correctos nnv número requerimientos que han validado. . étricas para modelo diseño inconcebible que diseño una nueva aeronave, nuevo chip computadora nuevo edificio oficinas realizara sin definir medidas diseño, determinar las métricas para varios aspectos calidad del diseño usarlos como indicadores para guiar forma que evoluciona diseño. aún así, con frecuencia diseño los sistemas complejos -sados software procede virtualmente sin medición. ironía esto que están disponibles métricas del diseño para software, pero gran mayoría los ingenieros del software conti-núan sin percatarse existencia. las métricas diseño para software computadora, igual que todas las demás métricas software, son perfectas. debate continúa acerca eficacia sobre forma que deben aplicarse. muchos expertos argumentan que requiere más experimentación antes poder usar las medidas diseño, aunque diseño sin medición una alternativa inaceptable. las siguientes secciones examinan algunas las métricas diseño más comunes para software computadora. cada una puede proporcionarle comprensión mejorada todas pueden ayudar que diseño evolucione hacia mayor nivel calidad. .. métricas del diseño arquitectónico las métricas del diseño arquitectónico enfocan características arquitectura del pro-grama (capítulo ) con énfasis estructura arquitectónica efectividad los módulos componentes dentro arquitectura. dichas métricas son “caja negra” tanto requieren conocimiento alguno del funcionamiento interior componente software particular. card glass [car] definen tres medidas complejidad del diseño software: compleji- dad estructural, complejidad datos complejidad del sistema. para arquitecturas jerárquicas (por ejemplo, arquitecturas petición retorno), compleji- dad estructural módulo define forma siguiente:punto clave medir las características especificación, posible obtener comprensión cuantitativa acerca especificidad completitud. cita: “medir que mensurable que mensurable, hace [] mensurable.” galileo punto clave las métricas pueden proporcionar comprensión acerca los datos estructurales complejidad del sistema asociada con diseño arquitectónico. (-).indd (-).indd // ::// :: parte tres administración calidad () / out() donde fout() fan-out del módulo . complejidad datos ofrece indicio complejidad que hay interfaz interna para módulo define como () / () fout() / donde () número variables entrada salida que pasan hacia desde módulo . finalmente, complejidad del sistema define como suma las complejidades estruc- tural datos especifica como () / ( ) / ( ) conforme aumenta valor cada una estas complejidades, complejidad arquitectónica global del sistema también aumenta. esto conduce una mayor probabilidad que también aumenten esfuerzo integración pruebas. fenton [fen] sugiere algunas métricas simples morfología ( decir, forma) que per- miten comparación diferentes arquitecturas programa usando conjunto dimen-siones directas. con respecto arquitectura llamado retorno figura ., puede definirse siguiente métrica: tamaño / + donde número nodos número arcos. para arquitectura que muestra figura ., tamaño / / / / trayectoria más larga desde nodo raíz (superior) hasta nodo hoja. para arquitectura que muestra figura ., profundidad / . ancho / número máximo nodos cualquier nivel arquitectura. para arquitec-tura que muestra figura ., ancho / . razón arco nodo, = /, mide densidad conectividad arquitectura puede pro-porcionar indicio simple del acoplamiento arquitectura. para arquitectura que muestra figura ., = / = .. comandancia los sistemas fuerza aérea estadounidense [usa] desarrolló algu- nos indicadores calidad del software que basan las características diseño mensura- fan-out (cargabilidad abanico salida) define como número módulos inmediatamente subordinados módulo , decir, número módulos que invoca directamente módulo . rid fca anchoprofundidadnodo arcofigura . métricas morfología (-).indd (-).indd // ::// :: métricas producto bles programa computadora. usar conceptos similares los propuestos ieee std. .- [iee], fuerza aérea usa información obtenida los diseños datos arqui-tectónico para derivar índice calidad estructura del diseño (iced) que varía . necesario averiguar los siguientes valores para calcular iced [cha]: / número total módulos definidos arquitectura del programa / número módulos cuya función correcta depende fuente entrada datos que produce los datos que van utilizar alguna otra parte ( general, los módulos control, entre otros, contarían como parte ) / número módulos cuya función correcta depende del procesamiento previo / número ítems base datos (incluidos objetos datos todos los atributos que definen objetos) / número total ítems base datos únicos / número segmentos base datos (diferentes registros objetos individuales) / número módulos con una sola entrada salida ( procesamiento excepción considera como una salida múltiple) una vez determinados los valores para programa cómputo, pueden calcularse los siguientes valores intermedios: estructura del programa: , donde define del modo siguiente: diseño arquitectó- nico desarrolló usando método distinto (por ejemplo, diseño orientado flujo datos diseño orientado objeto), entonces = , otro modo = . independencia módulo: / / módulos dependientes del procesamiento previo: / / tamaño base datos: / / compartimentalización base datos: / / entrada/salida módulo característico: / / con determinación estos valores intermedios, iced calcula forma siguiente: iced / / widi donde = , peso relativo importancia cada uno los valores intermedios / = ( todos los pesan igual, entonces = .). valor del iced para diseños anteriores puede determinarse compararse con diseño que actualmente esté desarrollo. iced significativamente menor que promedio, indican más trabajo diseño revisión. igual modo, hacen grandes cambios -seño existente puede calcularse efecto dichos cambios iced. .. métricas para diseño orientado objetos hay mucho subjetivo diseño orientado objetos: diseñador experimentado “sabe” cómo caracterizar sistema modo que implemente manera efectiva los requerimien-tos del cliente. pero, conforme modelo diseño crece tamaño complejidad, una visión más objetiva las características del diseño puede beneficiar tanto diseñador experi-mentado (quien adquiere comprensión adicional) como novato (quien obtiene indicio calidad que otro modo tendría disponible). tratamiento detallado las métricas software para sistemas , whitmire [whi] describe nueve características distintas mensurables diseño :cita: “ medición puede verse como una desviación. ésta necesa-ria porque los humanos básicamente son capaces tomar decisiones claras objeti-vas [sin apoyo cuantitativo]”. horst zuse (-).indd (-).indd // ::// :: parte tres administración calidad tamaño. tamaño define función cuatro visiones: población, volumen, longitud funcionalidad. población mide realizar conteo estático entidades , tales como clases operaciones. las medidas volumen son idénticas las medidas pobla-ción, pero recolectan manera dinámica: instante tiempo determinado. longitud una medida una cadena elementos diseño interconectados (por ejem-plo, profundidad árbol herencia una medida longitud). las métricas funcionalidad proporcionan indicio indirecto del valor entregado cliente por una apli-cación . complejidad. como tamaño, existen muchas visiones diferentes complejidad del software [zus]. whitmire complejidad términos características estructurales examinar cómo relacionan mutuamente las clases diseño . acoplamiento. las conexiones físicas entre elementos del diseño (por ejemplo, - mero colaboraciones entre clases mensajes que pasan entre los objetos) repre-sentan acoplamiento dentro sistema . suficiencia. whitmire define suficiencia como “ grado que una abstracción posee las características requeridas que componente diseño posee característi-cas abstracción, desde punto vista aplicación actual”. dicho otra forma, pregunta: “¿qué propiedades debe poseer esta abstracción (clase) para serme útil?” [whi]. esencia, componente diseño (por ejemplo, una clase) suficiente - fleja por completo todas las propiedades del objeto dominio aplicación que -dela, decir, abstracción (clase) posee sus características requeridas. completitud. única diferencia entre completitud suficiencia “ conjunto carac- terísticas contra las cuales compara abstracción componente diseño” [whi]. suficiencia compara abstracción desde punto vista aplicación actual. completitud considera múltiples puntos vista, plantea pregunta: “¿qué propiedades requieren para representar por completo objeto dominio problema?”. puesto que criterio para completitud considera diferentes puntos vista, tiene una implicación indi-recta grado que puede reutilizarse abstracción componente diseño. cohesión. como contraparte software convencional, componente debe dise- ñarse manera que tenga todas las operaciones funcionando conjunto para lograr solo propósito bien definido. cohesividad una clase determina examinar grado que “ conjunto propiedades que posee parte del problema dominio diseño” [whi]. primitivismo. una característica que similar simplicidad, primitivismo (aplicado tanto operaciones como clases), grado que una operación atómica, -cir, operación puede construirse partir una secuencia otras operaciones con-tenidas dentro una clase. una clase que muestra alto grado primitivismo encap-sula sólo operaciones primitivas. similitud. grado que dos más clases son similares términos estructura, función, comportamiento propósito indica mediante esta medida. volatilidad. como menciona muchas veces este libro, los cambios diseño pue- den ocurrir cuando modifican los requerimientos cuando ocurren modificaciones otras partes una aplicación, que como resultado adaptación obligatoria del com-ponente diseño cuestión. volatilidad componente diseño mide pro-babilidad que ocurrirá cambio. realidad, las métricas producto para sistemas pueden aplicarse sólo modelo diseño, sino también requerimientos. las siguientes secciones estudian las métricas ¿qué características pueden medirse cuando valora diseño ?? cita: “muchas las decisiones las cuales tuve que confiar folclore mito, ahora pue-den resolver haciendo uso datos cuantitativos.” scott whitmire (-).indd (-).indd // ::// :: métricas producto que proporcionan indicio calidad nivel clase operación. además, también exploran las métricas aplicables administración del proyecto las pruebas. .. métricas orientadas clase: suite métricas clase unidad fundamental sistema . por tanto, las medidas métricas para una clase individual, jerarquía clase las colaboraciones clase serán invaluables cuando requiera valorar calidad del diseño . una clase encapsula datos función que los mani-pula. con frecuencia “padre” las subclases ( ocasiones llamadas hijos) que heredan sus atributos operaciones. usualmente colabora con otras clases. cada una estas caracte-rísticas puede usarse como base para medición. chidamber kemerer propusieron uno los conjuntos métricas software - yor referencia [chi]. ocasiones llamada suite métricas , los autores proponen seis métricas diseño basadas clase para sistemas . métodos ponderados por clase (mpc). suponga que métodos complejidad , , …, definen para una clase . métrica complejidad específica que elige (por ejemplo, complejidad ciclomática) debe normalizarse modo que complejidad nominal para -todo tome valor .. mpc / / para = hasta . número métodos complejidad son indicadores razonables cantidad esfuerzo requerido para implementar probar una clase. además, mientras más grande sea número métodos, más complejo será árbol herencia (todas las subclases heredan los métodos sus padres). finalmente, conforme número métodos crece para una clase determinada, probable que vuelva cada vez más específica aplicación , por tanto, limite potencial reutilización. por todas estas razones, mpc debe mantenerse tan bajo como sea razonable. aunque parecería relativamente directo desarrollar conteo para número métodos una clase, problema realidad más complejo que parece. debe desarrollarse enfoque conteo consistente [chu]. profundidad del árbol herencia (pah). esta métrica “ máxima longitud desde nodo hasta raíz del árbol” [chi]. figura ., valor para jerarquía clase que muestra . conforme crece pah, probable que las clases nivel inferior hereden muchos métodos. esto conduce potenciales dificultades cuando intenta predecir comportamiento una clase. una jerarquía clase profunda (pah grande) también con-duce mayor complejidad diseño. lado positivo, grandes valores pah implican que muchos métodos pueden reutilizarse. número hijos (ndh). las subclases que son inmediatamente subordinadas una clase jerarquía clase denominan hijos. figura ., clase tiene tres hijos: sub- clases , . conforme crece número hijos, reuso aumenta, pero también, como ndh aumenta, abstracción representada por clase padre puede diluirse algunos los hijos son miembros adecuados clase padre. conforme ndh aumenta, cantidad pruebas (requeridas para ejercitar cada hijo contexto operativo) también aumentará. debe observarse que, literatura técnica, actualmente está debate validez algunas las métricas estudiadas este capítulo. quienes defienden teoría mediciones demandan grado formalismo que algunas métricas proporcionan. sin embargo, razonable afirmar que las métricas mencionadas ofrecen comprensión útil para ingeniero software. chidamber, darcy kemerer usan término métodos lugar operaciones. uso este término refleja esta sección. (-).indd (-).indd // ::// :: parte tres administración calidad acoplamiento entre clases objetos (aco). modelo crc (capítulo ) puede usarse para determinar valor para . esencia, aco número colaboraciones cita- das para una clase tarjeta índice crc. conforme aco aumenta, probable que reusabilidad una clase disminuya. valores altos aco también complican las modificacio- nes las pruebas que sobrevienen cuando realizan modificaciones. general, los valores aco para cada clase deben mantenerse tan bajos como sea razonable. esto consistente con lineamiento general para reducir acoplamiento software convencional. respuesta para una clase (rpc). respuesta para una clase “ conjunto métodos que potencialmente pueden ejecutarse respuesta mensaje recibido por objeto dicha clase” [chi]. rpc número métodos conjunto respuesta. conforme aumenta rpc, también hace esfuerzo requerido para probar , pues secuencia pruebas (capítulo ) crece. igualmente, sigue que, conforme rpc aumenta, complejidad diseño global clase aumenta. falta cohesión métodos (fcom). cada método dentro una clase accede uno más atributos (también llamados variables instancia). fcom número métodos que acceden uno más los mismos atributos. ningún método accede los mismos atribu- tos, entonces fcom = . para ilustrar caso donde fcom ≠ , considere una clase con seis métodos. cuatro ellos tienen uno más atributos común ( decir, acceden atributos comunes). por tanto, fcom = . fcom alta, los métodos pueden acoplarse unos con otros mediante atributos. esto aumenta complejidad del diseño clase. aunque hay casos los que valor alto fcom justificable, deseable mantener alta cohesión, decir, mantener baja fcom. . una jerarquía clase las tarjetas índice crc desarrollan manualmente, completitud consistencia deben valorarse antes que aco pueda determinarse manera confiable. definición formal poco más compleja. vea [chi] para detalles. métrica fcom proporciona útil comprensión algunas situaciones, pero puede confundir otras. por ejem- plo, mantener acoplamiento encapsulado dentro una clase aumenta cohesión del sistema como todo. por tanto, menos sentido importante, fcom más alta realidad sugiere que una clase puede tener mayor cohesión, menor.los conceptos acoplamiento cohesión aplican tanto software convencional como . mantenga acoplamiento clase bajo cohesión clase operación alta.consejo (-).indd (-).indd // ::// :: métricas producto .. métricas orientadas clase: suite métricas mood harrison, counsell nithi [har] proponen conjunto métricas para diseño orientado objeto que proporciona indicadores cuantitativos para características diseño . continua-ción presenta muestreo métricas mood. factor herencia método (fhm). grado que arquitectura clase sistema utiliza herencia tanto para métodos (operaciones) como para atributos define como fhm / / ( ) / ( ) donde suma ocurre sobre = hasta . define como número total clases arquitectura, una clase dentro arquitectura () / () + () donde () / número métodos que pueden invocarse asociación con () / número métodos declarados clase () / número métodos heredados ( invalidados) valor fhm [ factor herencia atributo (fha) define forma análoga] ofrece indicio del impacto herencia sobre software . factor acoplamiento (). anteriormente, este capítulo, dijo que acoplamiento indicio las conexiones entre elementos del diseño . suite métricas mood define acoplamiento forma siguiente: / ∑ ∑ is_client (, ) / tcla escena: cubículo vinod. participantes: vinod, jamie, shakira , miembros del equipo ingeniería del software casasegura, quie- nes continúan trabajando diseño nivel componentes diseño casos prueba. conversación:vinod: ¿alguno ustedes tuvo oportunidad leer descripción suite métricas que envié miércoles hizo las medicio-nes? shakira: fue muy complicado. regresé clase uml diagramas secuencia, como sugeriste, obtuve conteos burdos para pah, rpc fcom. pude encontrar modelo crc, así que conté aco. jamie (sonríe): pudiste encontrar modelo crc porque tengo. shakira: por eso adoro este equipo: comunicación soberbia.vinod: hice mis conteos... ¿ustedes desarrollaron números para las métricas ? [jamie asienten.]jamie: dado que tenía las tarjetas crc, eché vistazo aco parecía bastante uniforme través mayoría las clases. hubo una excepción, cual anoté. : hay algunas clases donde rpc muy alta, comparación con los promedios... tal vez debamos echar vistazo para simplifi-carlos. jamie: quizá , quizá . todavía estoy preocupado por tiem- , quiero componer cosas que realidad están rotas. vinod: estoy acuerdo. tal vez debas buscar clases que tengan malos números menos dos más las métricas . cuestión dos strikes estás modificado. shakira [observa lista clases con alta rpc]: mira, estas clases, tienen alta fcom así como alta rpc. ¿dos strikes? vinod: , eso creo... será difícil implementar debido compleji- dad dificultad para probar por misma razón. probablemente valdría pena diseñar dos clases separadas para lograr mismo comportamiento. jamie: ¿crees que modificarlo nos ahorrará tiempo?vinod: largo plazo, .casasegura aplicación métricas cita: “analizar software para evaluar calidad vuelto cada vez más importante con-forme paradigma [] continúa aumentando popu-laridad.” rachel harrison . (-).indd (-).indd // ::// :: parte tres administración calidad donde las sumas ocurren sobre = hasta = hasta . función is_client ( cliente) / , sólo existe una relación entre clase cliente clase servidor , / / , otro modo aunque muchos factores afectan complejidad, comprensibilidad mantenimiento del soft- ware, razonable concluir que, conforme valor aumenta, complejidad del software también aumentará, como resultado pueden sufrir comprensibilidad, mantenimiento potencial reuso. harrison . [har] presentan análisis detallado fhm junto con otras métricas, examinan validez para usarlas valoración calidad del diseño. .. métricas propuestas por lorenz kidd libro acerca métricas , lorenz kidd [lor] dividen las métricas basadas clase cuatro amplias categorías; cada una tiene una relación diseño nivel componen-tes: tamaño, herencia, internos externos. las métricas orientadas tamaño para una clase diseño enfocan conteos atributos operaciones para una clase individual -lores promedio para sistema como todo. las métricas basadas herencia enfocan forma que las operaciones reutilizan largo jerarquía clases. las -tricas para interiores clase fijan cohesión (sección ..) los conflictos orienta-dos código. las métricas externas examinan acoplamiento reuso. ejemplo las métricas propuestas por lorenz kidd : tamaño clase (tdc). tamaño global una clase puede determinarse usando las - guientes medidas: • número total operaciones (tanto heredadas como operaciones instancia privada) que encapsulan dentro clase. • número atributos (tanto heredados como instancia privada) que encapsula clase. métrica mpc propuesta por chidamber kemerer (sección ..) también una medida ponderada del tamaño clase. como indicó anteriormente, grandes valores para tdc indi-can que una clase puede tener demasiada responsabilidad. esto reducirá reutilización clase complicará implementación las pruebas. general, las operaciones atributos heredados públicos deben ponderarse más para determinar tamaño clase [lor]. las operaciones atributos privados permiten especialización están más localizadas -seño. también pueden calcularse promedios para número atributos operaciones clase. mientras más bajos sean los valores promedio para tamaño, hay más probabilidad que las clases dentro del sistema puedan reutilizarse ampliamente. .. métricas diseño nivel componente las métricas diseño nivel componente para componentes software convencional enfocan las características internas componente software incluyen medidas cohesión módulo, acoplamiento complejidad. dichas medidas pueden ayudarlo juzgar calidad diseño nivel componente. las métricas diseño nivel componente pueden aplicarse una vez desarrollado diseño procedural son “cajas cristal” tanto requieren conocimiento del funcionamiento interior del módulo que está trabajando. alternativamente, pueden demorarse hasta que código fuente esté disponible.durante revisión del modelo análisis, las tarjetas índice crc proporcionarán indicio razonable los valores esperados para tdc. encuentra una clase con gran número responsabilidades, considere dividirla.consejo (-).indd (-).indd // ::// :: métricas producto métricas cohesión. bieman ott [bie] definen una colección métricas que propor- cionan indicio cohesión (capítulo ) módulo. las métricas definen mediante cinco conceptos medidas: rebanada datos (data slice). dicho manera simple , una rebanada datos una mar- cha hacia atrás través módulo que busca valores datos que afecten ubicación del módulo donde comenzó marcha. debe observarse que posible definir tanto las -banadas programa (que enfocan enunciados condiciones) como las rebanadas datos. símbolos datos (data tokens). las variables definidas por módulo pueden definirse como tokens datos para módulo. símbolos pegamento ( glue tokens ). este conjunto tokens datos encuentra una más rebanadas datos.símbolos superpegamento (superglue tokens). estos tokens datos son comunes cada - banada datos módulo.pegajosidad (stickiness). pegajosidad relativa token pegamento directamente proporcional número rebanadas datos que enlaza. bieman ott desarrollan métricas para cohesión funcional fuerte (cff), cohesión funcional débil (cfd) adhesividad ( grado relativo que los tokens pegamento enlazan rebanadas datos). análisis detallado las métricas bieman ott, deja los autores [bie]. métricas acoplamiento. acoplamiento módulo proporciona indicio cuán “conectado” está módulo con otros módulos, con datos globales con entorno exterior . capítulo estudió acoplamiento términos cualitativos. dhama [dha] propuso una métrica para acoplamiento módulo que abarca acopla- miento datos flujo control, acoplamiento global acoplamiento ambiental. las medidas requeridas para calcular acoplamiento módulo definen función cada uno los tres tipos acoplamiento anotados anteriormente.para acoplamiento datos flujo control, / número parámetros datos entrada / número parámetros control entrada / número parámetros datos salida / número parámetros control salida para acoplamiento global, / número variables globales usadas como datos / número variables globales usadas como control para acoplamiento entorno, / número módulos llamados ( fan-out ) / número módulos que llaman módulo bajo consideración ( fan- ) usar estas medidas, indicador acoplamiento módulo define forma - guiente: / donde una constante proporcionalidad / / ( / ) / / ( / ) / / ( / ) / / los valores para , , deben derivarse manera empírica.punto clave posible calcular medidas independencia funcional (acoplamiento cohesión) componente usarlas para valorar calidad diseño. (-).indd (-).indd // ::// :: parte tres administración calidad conforme valor crece, acoplamiento módulo global disminuye. con finalidad que métrica acoplamiento mueva hacia arriba conforme grado acoplamiento aumenta, una métrica acoplamiento revisada puede definirse como / / donde grado acoplamiento aumenta conforme valor aumenta. métricas complejidad. para determinar complejidad del flujo control programa, pueden calcularse varias métricas software. muchas éstas basan gráfico flujo. gráfico (capítulo ) una representación compuesta nodos ligas (también llamadas aristas). cuando las ligas (aristas) dirigen, gráfico flujo gráfico dirigido. mccabe atson [mcc] identifican algunos usos importantes para las métricas com- plejidad: las métricas complejidad pueden usarse para predecir información crucial acerca confiabili- dad mantenimiento los sistemas software partir análisis automáticos código fuente [ información diseño procedimental]. las métricas complejidad también proporcionan retro-alimentación durante proyecto software para ayudar controlar [actividad diseño]. durante las pruebas mantenimiento, proporcionan información detallada acerca los módulos soft-ware para ayudar destacar áreas potencial inestabilidad. métrica complejidad para software computadora más ampliamente usada com- plejidad ciclomática, originalmente desarrollada por thomas mccabe [mcc] que estudió detalle capítulo . zuse ([zus], [zus]) presenta una discusión enciclopédica menos diferentes categorías métricas complejidad software. autor expone las definiciones básicas para las métricas cada categoría (por ejemplo, existen algunas variaciones métrica com-plejidad ciclomática) luego analiza critica cada una. trabajo zuse más exhaustivo publicado fecha. .. métricas orientadas operación puesto que clase unidad dominante los sistemas , han propuesto menos métri-cas para operaciones que residen dentro una clase. churcher shepperd [chu] analizan esto cuando afirman: “los resultados estudios recientes indican que los métodos tienden ser pequeños, tanto términos número enunciados como complejidad lógica [wil], que sugiere que estructura conectividad sistema puede ser más importante que contenido los módulos individuales.” sin embargo, puede obtenerse algo comprensión examinar las características promedio para los métodos (operaciones). tres métricas simples, propuestas por lorenz kidd [lor], son apropiadas: tamaño promedio operación ( prom). tamaño puede determinarse contar número líneas código mensajes enviados por operación. conforme -menta número mensajes enviados por una sola operación, probable que las res-ponsabilidades hayan asignado bien dentro una clase. complejidad operación (). complejidad una operación puede calcularse usando cualquiera las métricas complejidad propuestas para software convencional [zus]. puesto que las operaciones deben limitarse una responsabilidad específica, -señador debe luchar por mantener tan baja como sea posible. número promedio parámetros por operación ( prom). mientras más grande sea número parámetros operación, más compleja colaboración entre objetos. general, npprom debe mantenerse tan bajo como sea posible.punto clave complejidad ciclomática sólo una entre gran número métricas complejidad. (-).indd (-).indd // ::// :: métricas producto .. métricas diseño interfaz usuario aunque hay considerable literatura acerca del diseño interfaces hombre/computadora (- pítulo ), publicado relativamente poca información acerca las métricas que propor-cionarían comprensión calidad usabilidad interfaz. sears [sea] sugiere que corrección plantilla () una métrica diseño valioso para las interfaces hombre/computadora. una gui típica usa entidades plantilla (íconos grá-ficos, texto, menús, ventanas similares) para auxiliar usuario completar tareas. para lograr una tarea dada usando una gui, usuario debe moverse una entidad plantilla -guiente. posición absoluta relativa cada entidad plantilla, frecuencia con que usa “costo” transición desde una entidad plantilla siguiente contribuirán corrección interfaz. estudio métricas página web [ivo] indica que las características simples los elementos plantilla también pueden tener impacto significativo sobre calidad perci-bida del diseño gui. número palabras, vínculos, gráficos, colores fuentes (entre otras características) contenidas una página web afectan complejidad percibida calidad dicha página. importante observar que selección diseño gui puede guiarse con métricas como , pero árbitro final debe ser entrada del usuario con base los prototipos gui. nielsen levy [nie] reportan que “uno tiene una oportunidad razonablemente grande triunfar elige entre [diseños ] interfaz basadas exclusivamente opiniones los usuarios. rendimiento tarea promedio los usuarios satisfacción subjetiva con una gui están enormemente correlacionados”. . étricas diseño para webapps útil conjunto medidas métricas para webapps proporciona respuestas cuantitativas las siguientes preguntas: • ¿ interfaz usuario promueve usabilidad? • ¿ estética webapp apropiada para dominio aplicación agrada usuario? • ¿ contenido diseñó tal forma que imparte más información con menos esfuerzo? • ¿ navegación eficiente directa? • ¿ arquitectura webapp diseñó para alojar las metas objetivos especiales los usuarios webapp, estructura contenido funcionalidad, flujo nave-gación requerido para usar sistema manera efectiva? • ¿los componentes diseñaron manera que reduce complejidad procedimental mejora exactitud, confiabilidad desempeño? actualidad, cada una estas preguntas puede abordarse sólo manera cualitativa, por-que todavía existe una suite validada métricas que proporcionen respuestas cuantitati-vas. los siguientes párrafos presenta una muestra representativa métricas diseño webapp que han propuesto literatura. importante observar que muchas ellas -davía validan, por que deben usarse juiciosamente. métricas interfaz. para webapps pueden considerarse las siguientes medidas:cita: “ posible aprender menos principio del diseño inter-faz usuario cargar una lavadora platos. apila muchos ella, nada quedará muy limpio.” autor desconocido muchas estas métricas son aplicables todas las interfaces usuario deben considerarse conjunto con las que presentaron sección ...consejo (-).indd (-).indd // ::// :: parte tres administración calidad métrica sugerida descripción corrección plantilla ver sección .. complejidad plantilla número regiones distintas definidas por una interfaz complejidad región plantilla número promedio distintos vínculos por región complejidad reconocimiento número promedio distintos ítems que usuario debe buscar antes realizar una navegación decidir entrada datos tiempo reconocimiento tiempo promedio ( segundos) que tarda usuario seleccionar acción adecuada para una tarea determinada esfuerzo escritura número promedio golpes tecla requeridos para una función específicaesfuerzo toma ratón número promedio tomas ratón por funcióncomplejidad selección número promedio vínculos que pueden seleccionarse por páginatiempo adquisición contenido número promedio palabras texto por página webcarga memoria número promedio distintos ítems datos que usuario debe recordar para lograr objetivo específico métricas estéticas (diseño gráfico). por naturaleza, diseño estético apoya juicio cualitativo por general sensible medición las métricas. sin embargo, ivory . [ivo] proponen conjunto medidas que pueden ser útiles para valorar - pacto del diseño estético: métrica sugerida descripción conteo palabra número total palabras que aparecen una página porcentaje texto cuerpo porcentaje palabras que son cuerpo frente texto despliegue ( decir, títulos) % texto cuerpo enfatizado porción texto cuerpo que enfatiza (por ejemplo, negrillas, mayúsculas) conteo posicionamiento texto cambios posición texto desde alineado izquierdaconteo grupo texto áreas texto resaltadas con color, regiones con bordes, reglas listasconteo vínculos vínculos totales una páginatamaño página bytes totales para página, así como elementos, gráficos hojas estiloporcentaje gráfico porcentaje bytes página que son usados para gráficosconteo gráfico gráficos totales una página ( incluye gráficos especificados guiones, applets objetos) conteo color total colores empleadosconteo fuente total fuentes empleadas ( decir, tipo + tamaño + negrilla + itálica) métricas contenido. las métricas esta categoría enfocan complejidad del contenido los grupos objetos contenido que organizan páginas [men]. métrica sugerida descripción espera página tiempo promedio requerido para que una página descargue diferentes velocidades conexión complejidad página número promedio tipos diferentes medios usados página, incluido texto una región distinta área dentro plantilla despliegue que logra cierto conjunto específico funcio- nes relacionadas (por ejemplo, una barra menú, despliegue gráfico estático, área contenido, despliegue animado). (-).indd (-).indd // ::// :: métricas producto complejidad gráfica número promedio medios gráficos por página complejidad audio número promedio medios audio por página complejidad video número promedio medios video por página complejidad animación número promedio animaciones por página complejidad imagen escaneada número promedio imágenes escaneadas por página métricas navegación. las métricas esta categoría abordan complejidad del flujo navegación [men]. general, son útiles sólo para aplicaciones web estáticas, que inclu- yen vínculos páginas generados manera dinámica. métrica sugerida descripción complejidad vinculación página número vínculos por página conectividad número total vínculos internos, incluidos vínculos generados manera dinámica densidad conectividad conectividad dividida por conteo página usar subconjunto las métricas sugeridas puede servir para derivar relaciones empíricas que permiten equipo desarrollo webapp valorar calidad técnica predecir esfuerzo con base las estimaciones complejidad estimadas. esta área todavía queda mucho trabajo por hacer. objetivo: auxiliar los ingenieros web desarrollar métricas webapp significativas que proporcionen compren- sión acerca calidad global una aplicación. mecánica: mecánica las herramientas varía.herramientas representativas: netmechanic tools, desarrollada por netmechanic ( chanic.com), una colección herramientas que ayudan mejo-rar desempeño sitios web que enfocan conflictos especí-ficos implementación.nist web metrics testbed, desarrollada por the national institute standards and technology (zing.ncsl.nist.gov/webtools/), abarca siguiente colección útiles herramientas que están dispo-nibles para descarga:web static analyzer tool (websat): comprueba html pági- web contra lineamientos usabilidad típicos. web category analysis tool (webcat): permite que ingeniero usabilidad construya realice análisis categoría web. web variable instrumenter program (webvip): instrumenta sitio web para capturar una bitácora interacción con usuario. framework for logging usability data (flud): implementa forma- teador archivo analizador gramatical para representación las bitácoras interacción del usuario. visvip tool: produce una visualización las rutas navegación del usuario través sitio web. treedec: agrega auxiliares navegación las páginas sitio web.herramientas software métricas técnicas para webapps las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas esta categoría. debe observarse que las “leyes” halstead generaron gran controversia, muchos creen que teoría subya- cente tiene fallas. sin embargo, realizado verificación experimental para lenguajes programación selec- cionados (por ejemplo, [fel]). . étricas para código fuente teoría halstead “ciencia del software” [hal] propuso las primeras “leyes” analíticas para software computadora. halstead asignó leyes cuantitativas desarrollo software (-).indd (-).indd // ::// :: parte tres administración calidad computadora, usando conjunto medidas primitivas que pueden derivarse después generar código que diseño esté completo. las medidas son: / número operadores distintos que aparecen programa / número operandos distintos que aparecen programa / número total ocurrencias operador / número total ocurrencias operando halstead usa estas medidas primitivas para desarrollar: expresiones para longitud pro-grama global, volumen mínimo potencial para algoritmo, volumen real (número bits -queridos para especificar programa), nivel del programa (una medida complejidad del software), nivel del lenguaje (una constante para lenguaje determinado) otras característi-cas, como esfuerzo desarrollo, tiempo desarrollo incluso número proyectado fallas software. halstead muestra que longitud puede estimarse / log / log volumen del programa puede definirse / log ( / ) debe observarse que variará con lenguaje programación representa volumen información ( bits) requerido para especificar programa. teóricamente, debe existir volumen mínimo para algoritmo particular. halstead define una razón volumen como razón del volumen forma más compacta programa volumen del programa real. realidad, siempre debe ser menor que . términos medidas primitivas, razón volumen puede expresarse como / / trabajo halstead sensible verificación experimental llevado cabo gran trabajo para investigar ciencia del software. análisis este trabajo está más allá del -bito este libro. para mayor información, vea [zus], [fen] [zus]. . étricas para pruebas aunque escrito mucho acerca las métricas software para pruebas (por ejemplo, [het]), mayoría las métricas proponen enfocarse proceso las pruebas, las características técnicas las pruebas . general, los examinadores deben apoyarse las métricas análisis, diseño código para guiarlos diseño ejecución los casos prueba. las métricas del diseño arquitectónico proporcionan información acerca facilidad dificultad asociada con las pruebas integración (sección .) necesidad software pruebas especializado (por ejemplo, resguardos controladores). complejidad ciclomática (una métrica diseño nivel componente) yace centro prueba ruta base, método diseño casos prueba que presentó capítulo . además, comple-jidad ciclomática puede usarse para dirigirse módulos como candidatos para prueba unidad extensa. los módulos con alta complejidad ciclomática tienen más probabilidad ser proclives error que los módulos donde complejidad ciclomática menor. por esta razón, debe -plear esfuerzo por arriba del promedio para descubrir errores tales módulos antes que integren sistema.cita: “ cerebro humano sigue conjunto reglas más rígido [para desarrollo algoritmos] del que tiene conocimiento.” maurice halstead los operadores incluyen todo flujo constructos control, condicionales operaciones matemáticas. los operandos abarcan todas las variables constantes programa.consejo punto clave las métricas prueba ubican dos amplias categorías: ) métricas que intentan predecir número probable pruebas requeridas varios niveles prueba ) métricas que enfocan cobertura pruebas para componente determinado. (-).indd (-).indd // ::// :: métricas producto .. métricas halstead aplicadas para probar esfuerzo prueba puede estimarse usando métricas derivadas las medidas halstead (sección .). usar las definiciones para volumen programa nivel programa , esfuerzo halstead puede calcularse como / (/) / (/) (.) / (.) porcentaje esfuerzo prueba global que asignar módulo puede estimarse usando siguiente relación: porcentaje esfuerzo prueba () / () /() (.) donde () calcula para módulo usando las ecuaciones (.), suma denomina- dor ecuación (.) suma del esfuerzo halstead través todos los módulos del sistema. .. métricas para pruebas orientadas objetos las métricas del diseño anotadas sección . proporcionan indicio calidad del diseño. también ofrecen indicio general cantidad esfuerzo prueba requerido para ejercitar sistema . binder [bin] sugiere amplio arreglo métricas diseño que tienen influencia directa sobre “comprobabilidad” sistema . las métricas consi-deran aspectos encapsulación herencia. falta cohesión métodos (fcom). mientras más alto sea valor fcom, más estados deben ponerse prueba para garantizar que los métodos generan efectos colaterales. porcentaje público protegido (ppp). los atributos públicos heredan otras clases , por tanto, son visibles para dichas clases. los atributos protegidos son accesibles los métodos las subclases. esta métrica indica porcentaje los atributos clase que son públicos protegidos. valores altos ppp aumentan probabilidad efectos colate-rales entre las clases porque los atributos públicos protegidos conducen alto potencial para acoplamiento. las pruebas deben diseñarse para garantizar descubrimiento - les efectos colaterales. acceso público miembros datos (apd). esta métrica indica número clases ( métodos) que pueden acceder otros atributos clase, una violación encapsula- ción. valores altos apd conducen potencial efectos colaterales entre clases. las pruebas deben diseñarse para garantizar descubrimiento tales efectos colaterales. número clases raíz (ncr). esta métrica conteo las distintas jerarquías clase que describen modelo diseño. deben desarrollarse las suites prueba para cada clase raíz correspondiente jerarquía clase. conforme ncr aumenta, también aumenta esfuerzo prueba. fan- (fin). cuando usa contexto , fan- (abanico entrada) jerar- quía herencia indicio herencia múltiple. fin indica que una clase hereda sus atributos operaciones más una clase raíz. fin debe evitarse cuando sea posible. vea sección .. para una descripción fcom. algunas personas promueven diseños sin que alguno los atributos sea público privado, decir, ppp = . esto implica que todos los atributos deben valorarse otras clases mediante métodos.las pruebas pueden ser bastante complejas. las métricas pueden ayudarle dirigir los recursos prueba hebras, escenarios paquetes clases que son “sospechosas” con base las características medidas. úselas.consejo (-).indd (-).indd // ::// :: parte tres administración calidad número hijos (ndh) profundidad del árbol herencia (pah). como men- cionó capítulo , los métodos superclase tendrán que volverse probar para cada subclase. . étricas para mantenimiento todas las métricas software presentadas este capítulo pueden usarse para desarrollo nuevo software para mantenimiento del software existente. sin embargo, han propuesto métricas diseñadas explícitamente para actividades mantenimiento. ieee std. .- [iee] sugiere índice madurez software (ims) que proporcione indicio estabilidad producto software (con base cambios que ocurran para cada liberación del producto). para ello, determina siguiente información: / número módulos liberación actual / número módulos liberación actual que cambiaron / número módulos liberación actual que agregaron / número módulos liberación anterior que borraron liberación - tual índice madurez del software calcula forma siguiente: ims / – ( / / ) conforme ims tiende ., producto comienza estabilizarse. ims también puede usarse como una métrica para planificar actividades mantenimiento software. tiempo medio para producir una liberación producto software puede correlacionarse con ims, posible desarrollar modelos empíricos para esfuerzo mantenimiento. vea sección .. para una descripción del ndh pah. las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus res-pectivos desarrolladores.objetivo: auxiliar los ingenieros del software desa- rrollar métricas significativas que valoren los productos operativos producidos durante modelado análisis diseño, generación código fuente las pruebas. mecánica: las herramientas esta categoría abarcan amplio abanico métricas implementan como una aplicación indepen-diente (más comúnmente) como funcionalidad que existe dentro las herramientas para análisis diseño, codificación pruebas. mayoría los casos, las herramientas métricas analizan una representación del software (por ejemplo, modelo uml código fuente) desarrollan como resultado una más métricas. herramientas representativas: krakatau metrics, desarrollada por power software ( software.com/products), calcula métricas complejidad, halstead otras relacionadas para /++ java.metrics, desarrollada por + software engineering ( one.com/metrics.html), calcula una variedad métricas arquitectónicas, diseño orientadas código, así como métricas orientadas proyecto. rational rose, distribuida por ibm ( jct/software/awdtools/developer/rose/ ), amplio conjunto herramientas para modelado uml que incor-pora algunas características análisis métricas. rsm, desarrollada por -squared technologies (msquaredtech- nologies.com//index.html), calcula una amplia variedad métricas orientadas código para , ++ java. understand, desarrollada por scientific toolworks, inc. ( tools.com), calcula métricas orientadas código para varios lenguajes programación.herramientas software métricas producto (-).indd (-).indd // ::// :: métricas producto . esumen las métricas software proporcionan una forma cuantitativa para valorar calidad los atributos internos producto , por tanto, permiten valorar calidad antes construir producto. las métricas proporcionan comprensión necesaria para crear modelos efectivos requerimientos diseño, código sólido pruebas amplias. para ser útil contexto mundo real, una métrica software debe ser simple calcu- lable, convincente, congruente objetiva. debe ser independiente del lenguaje programación ofrecer retroalimentación efectiva. las métricas para modelo requerimientos enfocan los tres componentes del - delo: función, los datos comportamiento. las métricas para diseño consideran arquitec-tura, diseño nivel componentes conflictos diseño interfaz. las métricas diseño arquitectónico consideran los aspectos estructurales del modelo diseño. las métricas diseño nivel componente proporcionan indicio calidad del módulo esta-blecer medidas indirectas para cohesión, acoplamiento complejidad. las métricas diseño interfaz usuario ofrecen indicio facilidad con que puede usarse una gui. las métricas webapp consideran aspectos interfaz usuario, así como estética, contenido navegación webapp. las métricas para los sistemas enfocan mediciones que pueden aplicarse las - racterísticas clase diseño (localización, encapsulación, ocultamiento información, herencia técnicas abstracción objeto) que hacen única clase. suite métricas define seis métricas software orientado clase que enfocan clase jerarquía clase. suite métricas también desarrolla métricas para valorar las colaboraciones entre clases cohesión métodos que residen dentro una clase. nivel orientado clase, suite métricas puede aumentarse con las métricas propuestas por lorenz kidd con suite métricas mood. halstead proporciona interesante conjunto métricas nivel del código fuente. usar número operadores operandos presentes código, ciencia del software pro-porciona una variedad métricas que pueden usarse para valorar calidad del programa. pocas métricas producto han propuesto para uso directo las pruebas software mantenimiento. sin embargo, muchas otras métricas producto pueden usarse para guiar proceso pruebas como mecanismo para valorar capacidad mantenimiento programa cómputo. para valorar comprobabilidad sistema , propuesto una gran variedad métricas . problemas puntos por evaluar .. teoría medición tema avanzado que tiene fuerte engranaje con las métricas soft- ware. con [zus], [fen], [zus] fuentes web, escriba breve ensayo que resalte las tesis prin-cipales teoría medición. proyecto individual: desarrolle una presentación acerca del tema pre-séntela clase. .. ¿por qué posible desarrollar una sola métrica exhaustiva para complejidad programa calidad programa? intente encontrar una medida métrica vida diaria que viole los atributos las métricas software efectivos definidos sección ... .. sistema tiene entradas externas, salidas externas, presenta diferentes consultas externas, gestiona archivos lógicos internos tiene interfaz con diferentes sistemas legados ( aie). todos estos datos son complejidad promedio sistema global relativamente simple. calcule para sistema. .. software para system tiene requerimientos funcionales individuales requerimientos funcionales. ¿cuál especificidad los requerimientos cuál completitud? (-).indd (-).indd // ::// :: parte tres administración calidad .. gran sistema información tiene módulos. existen módulos que realizan funciones control coordinación módulos cuya función depende del procesamiento previo. sistema procesa aproximadamente objetos datos, cada uno los cuales tiene promedio tres atributos. existen ítems base datos únicos diferentes segmentos base datos. finalmente, módulos tienen puntos entrada salida únicos. calcule iced para este sistema. .. una clase tiene operaciones. complejidad ciclomática calcula para todas las operaciones sistema valor promedio complejidad módulo . para clase , complejidad para las operaciones , , , , , , , , , , , , respectivamente. calcule los métodos ponde- rados por clase. .. desarrolle una herramienta software que calcule complejidad ciclomática para módulo lenguaje programación. puede elegir lenguaje. .. desarrolle una pequeña herramienta software que realice análisis halstead sobre código fuente del lenguaje programación elección. .. sistema legado tiene módulos. última liberación requirió cambio dichos módu- los. además, agregaron nuevos módulos removieron módulos antiguos. calcule índice madurez software para sistema. lecturas fuentes información adicionales existe número sorprendentemente grande libros que dedican las métricas software, aunque mayoría enfocan las métricas proceso proyecto, con exclusión métricas producto. lanza . (object-oriented metrics practice , springer, ) analizan métricas uso para valorar calidad diseño. genero (metrics for software conceptual models , imperial college press, ) ejiogu (software metrics, booksurge publishing, ) presentan una amplia variedad métricas técnicas para casos uso, modelos uml otras representaciones modelado. hutcheson (software testing fundamentals: methods and metrics, wiley, ) presenta conjunto métricas para prueba. kan ( metrics and models software qual- ity engineering, addison-wesley, . ., ), fenton pfleeger (software metrics: rigorous and practical approach, brooks-cole publishing, ), zuse [zus] escribieron tratamientos profundos las métricas producto. los libros card glass [car], zuse [zus], fenton [fen], ejiogu [eji], moeller paulish ( software metrics, chapman hall, ), hetzel [het] abordan métricas producto con cierto detalle. oman pfleeger ( applying software metrics, ieee computer society press, ) editaron una antología importan- tes ensayos acerca las métricas software. ebert . ( best practices software measurement , springer, ) consideran los métodos para estable- cer programa métricas los principios subyacentes para medición del software. shepperd ( founda- tions software measurement, prentice-hall, ) también aborda teoría medición con cierto detalle. investigación actual presenta los proceedings the symposium software metrics (ieee, publica- ción anual). [iee] presenta amplio resumen decenas métricas software útiles. general, análisis cada métrica separado las “primitivas” (medidas) esenciales requeridas para calcular métrica las relaciones apropiadas para efectuar cálculo. proporciona análisis muchas referencias apéndice. whitmire [whi] presenta tratamiento amplio matemáticamente sofisticado las métricas . lorenz kidd [lor] hendersen-sellers ( object-oriented metrics: measures complexity, prentice-hall, ) proporcionan tratamientos que dedican las métricas . internet, está disponible una gran variedad fuentes información acerca las métricas del soft- ware. una lista actualizada referencias world wide web que son relevantes para métrica del software puede encontrarse sitio del libro: (-).indd (-).indd // ::// :: proyectos softwareparte cuatro esta parte ingeniería del software. enfoque práctico, apren- derá sobre las técnicas administración requeridas para planificar, organizar, monitorear controlar proyectos software. los - pítulos que siguen abordan preguntas como las siguientes: • ¿cómo debe administrarse personal, proceso problema -rante proyecto software? • ¿cómo pueden usarse las métricas del software para administrar proyecto proceso software? • ¿cómo genera equipo software estimaciones confiables esfuerzo, costo duración del proyecto? • ¿qué técnicas pueden usarse para valorar los riesgos que pueden tener impacto sobre éxito del proyecto? • ¿cómo selecciona gerente proyecto software conjunto tareas laborales para los ingenieros del software? • ¿cómo crea calendario proyecto? • ¿por qué mantenimiento reingeniería son importantes para los gerentes ingeniería software para los profesionales? una vez respondidas estas preguntas, estará mejor preparado para admi-nistrar proyectos software una forma que conducirá entrega oportuna producto alta calidad. (-).indd (-).indd // ::// :: administración proyecto conceptos clave ámbito del software . . . . . . coordinación comunicación. . . . . . . . . . . . descomposición problema . . . . . . . . . . . . equipo software . . . . . . . ágiles. . . . . . . . . . . equipo. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . cruciales . . . . . . . . . . . . . . . . . . producto. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ¿qué ? aunque muchas personas ( sus momentos más oscuros) toman visión dil- bert “administración”, ésta sigue siendo una actividad muy necesaria cuando cons- truyen sistemas productos basados computadora. administración del proyecto involucra planificación, moni-toreo control del personal, procesos acciones que ocurren conforme software evoluciona desde concep- preliminar hasta despliegue operativo completo. ¿quién hace? todo mundo “administra” cierta medi- , pero ámbito las actividades administrativas varía entre las personas involucradas proyecto soft-ware. ingeniero del software administra sus actividades cotidianas, planifica, monitorea controla las tareas téc-nicas. los gerentes proyecto planifican, monitorean controlan trabajo equipo ingenieros soft-ware. los gerentes ejecutivos coordinan interfaz entre empresa los profesionales del software. ¿por qué importante? construir software compu- tadora una labor compleja, particularmente involucra muchas personas que trabajan durante tiempo relati-vamente largo. por eso necesario administrar los pro-yectos software. ¿cuáles son los pasos? comprender las cuatro : perso- nal, producto, proceso proyecto. personal debe orga-nizarse para realizar trabajo software manera efectiva. comunicación con cliente con otros partici-pantes debe ocurrir modo que ámbito del producto los requerimientos sean comprensibles. debe seleccionarse proceso que sea adecuado para personal pro-ducto. proyecto debe planificarse, estimándose esfuer- cronograma necesarios para concluir las tareas: definición los productos operativos, establecimiento los puntos verificación calidad, identificación -canismos para monitorear control del trabajo definido por plan. ¿cuál producto final? cuanto inician las activi- dades administración, produce plan proyecto que define proceso las tareas que van realizar, personal que hará trabajo los mecanismos que emplearán para valorar riesgos, controlar cambio evaluar calidad. ¿cómo aseguro que hice bien? nunca está completamente seguro que plan del proyecto correcto, hasta que entrega producto alta calidad tiempo dentro del presupuesto. sin embargo, geren- proyecto hace bien cuando alienta personal del software trabajar conjunto, como equipo efectivo, cuando enfoca atención las necesidades del clien- calidad del producto. una mirada rápidaen prefacio libro acerca administración proyectos software, meiler page-jones [pág. ] hace una afirmación que pueden compartir muchos consultores ingeniería software: visitado decenas tiendas comerciales, tanto buenas como malas, observado tableros datos que procesan los administradores, nuevo, buenos malos. con mucha frecuencia, observé con horror cómo estos administradores luchan infructuosamente través proyectos pesadilla, retuercen bajo fechas límite imposibles sistemas entregados que contrarían sus usuarios que dedican devorar enormes trozos tiempo mantenimiento. que page-jones describe son síntomas extraídos una selección problemas adminis- trativos técnicos. sin embargo, los proyectos les realizara análisis postmortem, muy probable que encuentre tema común: administración del proyecto era débil. éste los siguientes capítulos, presentan los conceptos clave que conducen administración efectiva del proyecto software. este capítulo considera los conceptos prin-cipios básicos administración proyectos software. capítulo presenta las métri-cas proceso proyecto, base para toma decisiones administrativas efectivas. las téc-nicas que usan para estimar costo analizan capítulo . capítulo ayuda definir calendario proyecto realista. las actividades administrativas que conducen - (-).indd (-).indd // ::// :: conceptos administración proyecto nitoreo, mitigación administración efectiva del riesgo presentan capítulo . final- mente, capítulo considera mantenimiento reingeniería, estudia los conflictos -ministrativos que encontrarán cuando lidie con sistemas heredados. . espectro administrativo administración efectiva proyecto software enfoca las cuatro : personal, pro-ducto, proceso proyecto. orden arbitrario. gerente que olvida que trabajo ingeniería del software una empresa intensamente humana nunca triunfará adminis-tración del proyecto. gerente que fracase alentar una comunicación comprensiva con los participantes durante las primeras etapas evolución producto arriesga construir una solución elegante para problema equivocado. gerente que ponga poca atención proceso corre riesgo insertar métodos herramientas técnicos competentes pero vacío. aquel que embarque sin plan sólido pone peligro éxito del proyecto. .. personal desde década estudia formación personal software motivado enorme-mente calificado. hecho, “factor humano” tan importante que software engineering institute desarrolló modelo madurez capacidades del personal (people-cmm, por sus siglas inglés), reconocimiento hecho que “toda organización requiere mejorar con-tinuamente habilidad para atraer, desarrollar, motivar, organizar conservar fuerza trabajo necesaria fin lograr sus objetivos empresariales estratégicos” [cur]. people-cmm define las siguientes áreas prácticas clave para personal software: plan- tilla, comunicación coordinación, ambiente trabajo, desempeño administrativo, capacita-ción, compensación, análisis desarrollo competencias, desarrollo profesional, desarrollo grupo trabajo desarrollo equipo/cultura, entre otros. las organizaciones que conforme este modelo logran altos niveles madurez capacidades personal tienen una probabi-lidad muy elevada alcanzar implementación prácticas administrativas efectivas los proyectos software. people-cmm compañero integración del modelo madurez capacidades del software (capítulo ), que guía las organizaciones creación proceso software maduro. los conflictos asociados con administración del personal con estructura para los proyectos software consideran más adelante, este capítulo. .. producto antes poder planear proyecto, deben establecerse los objetivos ámbito del producto, considerarse soluciones alternativas identificar las restricciones técnicas administrativas. sin esta información, imposible definir estimaciones razonables ( precisas) del costo, una valoración efectiva del riesgo, una descomposición realista las tareas del proyecto -lendario proyecto manejable que proporcione cada momento indicio significativo del progreso. como desarrolladores software, todos los participantes deben reunirse para definir los objetivos ámbito del producto. muchos casos, esta actividad comienza como parte ingeniería del sistema ingeniería del proceso empresarial continúa como primer paso ingeniería requerimientos del software (capítulo ). los objetivos identifican las metas globales para producto (desde punto vista los participantes) sin considerar cómo lograrán estas metas. ámbito identifica los datos, funciones comportamientos principales que caracterizan producto , más importante, intenta ligar dichas características forma cuantitativa. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software una vez comprendidos los objetivos ámbito del producto, consideran soluciones - ternativas. aunque analizan muy pocos detalles, las alternativas permiten los gerentes profesionales seleccionar “mejor” enfoque, dadas las restricciones impuestas por fechas entrega, restricciones presupuestales, disponibilidad personal, interfaces técnicas muchos otros factores. .. proceso proceso software (capítulos ) proporciona marco conceptual desde cual puede establecerse plan completo para desarrollo software. pequeño número activida-des marco conceptual aplica todos los proyectos software, sin importar tamaño complejidad. algunos conjuntos diferentes tareas (tareas, hitos, productos operativos pun-tos aseguramiento calidad) permiten que las actividades del marco conceptual adapten las características del proyecto software los requerimientos del equipo del proyecto. finalmente, las actividades sombrilla (como aseguramiento calidad del software, -ministración configuración del software las mediciones) recubren modelo proceso. las actividades sombrilla son independientes cualquier actividad del marco conceptual ocurren largo del proceso. .. proyecto los proyectos software planean controlan debido una razón principal: única forma conocida para manejar complejidad. incluso así, los equipos software todavía batallan. estudio grandes proyectos software desarrollados entre , capers jones [jon] encontró que “alrededor consideraron exitosos por haber logrado sus objetivos calendario, costo calidad. aproximadamente tuvieron demoras excesos por abajo por ciento, mientras que más menos experimentaron grandes demoras -cesos, dieron por concluidos sin completarse”. aunque actualmente tasa éxito para los proyectos software puede haber mejorado poco, tasa falla proyecto sigue siendo mucho más alta que debiera. para evitar fracaso del proyecto, gerente proyecto software los ingenieros software que construyan producto deben evitar conjunto señales advertencia comu-nes, entender los factores éxito cruciales que conducen una buena administración del pro-yecto desarrollar enfoque sentido común para planificar, monitorear controlar proyecto. cada uno estos temas estudia sección . los capítulos que siguen. . personal estudio publicado por ieee [cur], preguntó los vicepresidentes ingeniería tres grandes compañías tecnológicas cuál era elemento más importante para éxito proyecto software. ellos respondieron siguiente manera: : supongo que, tienes que elegir una cosa que sea más importante nuestro ambiente, diría que son las herramientas que usamos, personal. : ingrediente más importante que fue exitoso este proyecto fue tener gente inte- ligente [...] opinión, muy pocas cosas más importan [...] cosa más importante que quienes adhieren filosofía proceso ágil (capítulo ) argumentan que proceso más esbelto que otros. esto puede ser cierto, pero todavía tienen proceso, ingeniería software ágil todavía requiere disciplina.consejo con estas estadísticas, razonable preguntar cómo sigue creciendo exponencialmente impacto las computadoras. parte respuesta que número sustancial estos proyectos “fallidos” estuvieron mal concebidos desde inicio. los clientes pierden interés rápidamente (porque que pidieron realidad era tan importante como pensaron primera vez) los proyectos cancelan. (-).indd (-).indd // ::// :: conceptos administración proyecto haces para proyecto seleccionar personal [...] éxito organización desa- rrollo software está muy, muy asociada con habilidad para reclutar buen personal. : única regla que tengo administración asegurarme que tengo buen per- sonal, gente realmente buena, que hago crecer gente buena que proporciono -biente que gente buena puede producir. hecho, éste testimonio convincente acerca importancia del personal proceso ingeniería software. aún así, para mayoría las personas, desde los vicepresidentes ejecutivos ingeniería hasta profesional nivel más bajo, con frecuencia dan por hecho personal. los administradores argumentan (como hizo grupo anterior) que las personas son importante, pero sus acciones ocasiones contradicen sus palabras. esta sección examina las personas que participan proceso software forma que orga-nizan para realizar ingeniería software efectiva. .. los participantes proceso software ( todo proyecto software) está poblado participantes, quienes pueden organizarse alguna las siguientes áreas: . gerentes ejecutivos, quienes definen los temas empresariales que con frecuencia tienen una influencia significativa sobre proyecto. . gerentes pro yecto (técnicos), quienes deben planificar, motivar, organizar controlar los profesionales que hacen trabajo software. . profesionales que aportan las habilidades técnicas que necesitan para someter inge-niería producto aplicación. . clientes que especifican los requerimientos para software que fabricar , así como otros participantes que tienen interés periférico resultado. . usuarios finales, quienes interactúan con software una vez que libera para uso productivo. odo proyecto software está poblado con personas que están dentro esta taxonomía. para ser efectivo, equipo software debe organizarse manera que maximice las habilidades capacidades cada persona. ésta labor del líder del equipo. .. líderes equipo administración del proyecto una actividad que implica mucho trato con gente; por esta razón, los profesionales competentes tienen con frecuencia pobre desempeño como líderes equipo. simplemente, tienen mezcla justa habilidades personales. aún así, como edgemon afirma: “por desgracia, por muy frecuente que parezca, los individuos simplemente topan con papel gerente proyecto convierten gerentes accidentales pro-yecto” [edg]. excelente libro acerca del liderazgo técnico, jerry weinberg [wei] sugiere modelo moi liderazgo: motivación. habilidad para alentar (mediante “empuje jalón”) personal técnico pro-ducir máxima capacidad. organización. habilidad para moldear los procesos existentes ( inventar nuevos) que permitirán que concepto inicial traduzca producto final. cuando desarrollan webapps, personal técnico puede involucrarse creación contenido.¿qué busca cuando elige alguien como líder proyecto software?? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software ideas innovación. habilidad para alentar las personas crear sentirse creativas, aun cuando deban trabajar dentro fronteras establecidas para producto aplicación software particular. weinberg sugiere que los líderes proyecto exitosos aplican estilo administrativo reso-lución problemas. decir, gerente proyecto software debe concentrarse com-prender problema que resolver, administrar flujo ideas , mismo tiempo, dejar que todos equipo sepan (por medio palabras , mucho más importante, con accio-nes) que calidad cuenta que comprometerá. otra visión [edg] las características que definen gerente proyecto eficaz enfatiza cuatro rasgos clave: resolución problemas. gerente proyecto software eficaz puede diagnosticar los conflictos técnicos organizativos que son más relevantes, estructura sistemáticamente una solución motiva adecuadamente otros profesionales para desarrollarla, aplica lec-ciones aprendidas proyectos pasados situaciones nuevas sigue siendo suficiente-mente flexible para cambiar dirección los intentos por resolver problema son infruc-tuosos. identidad administrativa. buen gerente proyecto debe hacerse cargo del mismo. debe tener confianza para asumir control cuando sea necesario asegurarse per- mitir que buen personal técnico siga sus instintos. logro. gerente competente debe recompensar iniciativa logro para optimizar productividad equipo proyecto. debe demostrar mediante sus acciones que castigará del correr riesgos manera controlada. influencia construcción del equipo. gerente proyecto eficaz debe poder “leer” gente; debe poder comprender las señales verbales verbales, reaccionar ante las necesidades las personas que envían estas señales. gerente debe permanecer bajo control situaciones alto estrés. .. equipo software existen casi tantas estructuras organizativas humanas para desarrollo del software como organizaciones que desarrollan. para bien para mal, estructura organizativa puede modificarse fácilmente. preocupación por las consecuencias prácticas por las políticas del cambio organizativo está dentro del ámbito responsabilidad del gerente del proyecto software. sin embargo, organización las personas directamente involucradas nuevo proyecto software está dentro del campo acción del gerente del proyecto. “mejor” estructura equipo depende del estilo administrativo organización, del número personas que formarán equipo sus niveles habilidad, así como difi-cultad global del problema. mantei [man] describe siete factores proyecto que deben con-siderarse cuando planee estructura los equipos ingeniería software: • dificultad del problema que resolver. • “tamaño” del programa resultante líneas código puntos función. • tiempo que equipo permanecerá unido (vida del equipo). • grado que puede dividirse módulos problema. • calidad confiabilidad requeridas por sistema que construir. • rigidez fecha entrega. • grado sociabilidad (comunicación) requerido para proyecto.cita: “ términos más simples, líder aquel que sabe dónde quiere , levanta mar-cha.” john erskine cita: “ todo grupo equipo todo equipo eficaz.” glenn parker ¿qué factores deben considerarse cuando elige estructura equipo software?? (-).indd (-).indd // ::// :: conceptos administración proyecto constantine [con] sugiere cuatro “paradigmas organizacionales” para los equipos inge- niería software: . par adigma cerrado estructura equipo conforme una jerarquía autoridad tradi- cional. tales equipos pueden trabajar bien cuando producen software muy similar esfuerzos anteriores, pero será menos probable que sean innovadores cuando trabajen dentro este paradigma. . par adigma aleatorio estructura equipo manera holgada depende inicia- tiva individual los miembros del equipo. cuando requiere innovación avance tecnológico, destacarán los equipos que siguen este paradigma, pero pueden batallar cuando requiera “desempeño ordenado”. . par adigma abierto intenta estructurar equipo manera que logre algunos los controles asociados con paradigma cerrado, pero también mucha innova- ción que ocurre cuando usa paradigma aleatorio. trabajo realiza manera colaboradora; gran comunicación toma decisiones consensuadas constituyen las características los equipos paradigma abierto. las estructuras equipo este paradigma son muy adecuadas para solución problemas complejos, pero pue- den desempeñarse tan eficazmente como otros equipos. . par adigma síncrono apoya compartimentalización natural problema organiza los miembros del equipo para trabajar trozos del problema con poca -municación activa entre ellos. como acotación histórica, cabe decir que una las primeras organizaciones equipo software fue una estructura paradigma cerrado originalmente llamado equipo programador jefe. esta estructura propuso por primera ocasión harlan mills describió baker [bak]. núcleo del equipo estaba compuesto : ingeniero ejecutivo ( programador jefe), quien pla- neaba, coordinaba revisaba todas las actividades técnicas del equipo; personal técnico (por general dos cinco personas), quienes realizaban análisis desarrollaban actividades; ingeniero respaldo, quien apoyaba ingeniero ejecutivo sus actividades podía sustituirlo con mínima pérdida continuidad del proyecto. programador jefe puede auxiliarse con uno más especialistas (por ejemplo, experto telecomunicaciones, diseñador bases datos), personal apoyo (por ejemplo, escritores técnicos, oficinistas) bibliotecario software. como contrapunto estructura del equipo del programador jefe, paradigma aleatorio constantine [con] sugiere equipo software con independencia creativa cuyo enfoque para trabajar pueda denominarse mejor manera como anarquía innovadora. aunque enfo-que espíritu libre trabajo software atractivo, canalizar energía creativa hacia equipo alto rendimiento debe ser una meta central una organización ingeniería software. para lograr equipo alto rendimiento: • los miembros del equipo deben tenerse confianza entre . • distribución habilidades debe ser adecuada para problema. • posible que tenga que excluirse del equipo los inconformes debe mantenerse cohesión del equipo. sin importar tipo organización del equipo, objetivo para todo gerente proyecto ayudar crear equipo que muestre cohesión. libro peopleware, demarco lister [dem] analizan este tema: tendemos usar palabra equipo con mucha holgura mundo empresarial, llamamos así cualquier grupo personas asignadas para trabajar juntas. pero muchos estos grupos simple-¿qué opciones tienen cuando define estructura equipo software?? cita: “ quieres ser incrementalmen- mejor: competitivo. quieres ser exponencialmente mejor: cooperativo.” autor desconocido (-).indd (-).indd // ::// :: parte cuatro administración proyectos software mente parecen equipos. tienen una definición común éxito algún espíritu equipo iden- tificable. que falta fenómeno que llamamos cuajar. equipo cuajado grupo personas tan fuertemente unido que todo mayor que suma las partes [...]. una vez que equipo comienza cuajarse, probabilidad éxito hacia arriba. equipo puede volverse imparable, una fuerza arrasadora para éxito [...] necesita ser administrado forma tradicional , ciertamente, necesita ser motivado. adquiere cantidad movimiento. demarco lister sostienen que los miembros los equipos cuajados son significativamente más productivos más motivados que promedio. comparten una meta común, una cultura común muchos casos “sentido élite” que los hace únicos. pero todos los equipos cuajan. hecho, muchos equipos sufren que jackman [jac] llama “toxicidad equipo”. ella define cinco factores que “fomentan ambiente equipo potencialmente tóxico”: ) una atmósfera trabajo frenético, ) alta frustración que causa fricción entre los miembros del equipo, ) proceso software “fragmentado pobre-mente coordinado”, ) una definición poco clara los roles equipo software ) “con-tinua repetida exposición fracaso”. para evitar ambiente trabajo frenético, gerente del proyecto debe estar seguro que equipo tiene acceso toda información requerida para hacer trabajo que las metas objetivos principales, una vez definidos, deben modificarse menos que sea absolutamente necesario. equipo software puede evitar frustración tanta responsabilidad para toma decisiones como sea posible. proceso inadecuado (por ejemplo, tareas -necesarias abrumadoras productos operativos pobremente elegidos) puede evitarse -tender producto que construir las personas que hacen trabajo, así como permitir equipo seleccionar modelo proceso. equipo mismo debe establecer sus pro-pios mecanismos responsabilidad (las revisiones técnicas son una excelente forma lograr esto) definir una serie enfoques correctos cuando miembro del equipo tiene fallos desempeño. finalmente, clave para evitar una atmósfera fracaso radica establecer téc-nicas basadas equipo para retroalimentarse resolver problemas. además las cinco toxinas descritas por jackman, equipo software con frecuencia batalla con los diferentes rasgos humanos sus miembros. algunos son extrovertidos; otros, introvertidos. algunas personas reúnen información manera intuitiva separan los concep-tos abarcadores los hechos dispares. otras procesan información manera lineal, reú-nen organizan detalles minúsculos los datos proporcionados. ciertos miembros del equipo sienten cómodos tomar decisiones sólo cuando presenta argumento lógico orde-nado. otros son intuitivos quieren tomar decisiones con base “corazonadas”. algunos profesionales quieren calendarios detallados poblados tareas organizadas que les permitan lograr cierre para algún elemento proyecto. otros prefieren ambiente más espontá-neo que los temas abiertos sean bien vistos. algunos trabajan duro para hacer que las cosas estén listas mucho antes una fecha final , por tanto, evitan estrés conforme fecha aproxima, mientras que otros sienten energizados por adrenalina que produce una -trega último minuto. una discusión detallada psicología estos rasgos las formas las que líder del equipo habilidoso puede ayudar las personas con rasgos opuestos para trabajar conjunto está más allá del ámbito este libro. sin embargo, importante observar que reconocimiento las diferencias humanas primer paso hacia creación equi-pos que cuajen.¿qué equipo “cuajado”?? ¿por qué fallan los equipos cuando deben cuajar?? cita: “hacer hacer. hay intento.” yoda, guerra las galaxias las revisiones técnicas estudian con detalle capítulo . una excelente introducción estos temas, relación con los equipos proyecto software, puede encon- trarse [fer]. (-).indd (-).indd // ::// :: conceptos administración proyecto .. equipos ágiles durante las décadas pasadas, desarrollo software ágil (capítulo ) sugerido como antídoto muchos los problemas que plagan trabajo proyecto software. cabe recordar que filosofía ágil alienta satisfacción del cliente entrega incremental temprana del software, así como pequeños equipos proyecto enormemente motivados, métodos infor-males, mínimos productos operativos ingeniería software simplicidad desarrollo global. pequeño equipo trabajo enormemente motivado, también llamado equipo ágil, adopta mayoría las características los equipos proyecto software exitosos que estudia-ron sección anterior evita muchas las toxinas que crean problemas. obstante, filosofía ágil subraya competencia individual (miembro equipo), acoplada con colabora-ción grupal como factores éxito vitales para equipo. cockburn highsmith [coc] -servan esto cuando escriben: personal del proyecto suficientemente bueno, puede usar casi cualquier proceso lograr esta asignación. , ningún proceso reparará inadecuación: “personal mata proceso” una forma decirlo. sin embargo, falta apoyo usuarios ejecutivos puede matar proyecto: “política mata personal”. apoyo inadecuado puede impedir que incluso personal bueno logre esta tarea. para hacer uso efectivo las competencias cada miembro del equipo fomentar colabo- ración efectiva través proyecto software, los equipos ágiles son autoorganizados. equipo autoorganizado necesariamente mantiene una sola estructura equipo, sino que usa elementos los paradigmas aleatorio, abierto síncrono constantine, estudiados sección ... muchos modelos proceso ágil (por ejemplo, scrum) dan equipo ágil significativa auto- nomía para tomar las decisiones administrativas técnicas del proyecto necesarias para hacer que trabajo cumpla. planificación mantiene mínimo equipo permite -leccionar propio enfoque (por ejemplo, proceso, métodos, herramientas), restringido única-mente por los requerimientos empresariales los estándares organización. conforme avanza proyecto, equipo autoorganiza para enfocarse competencia individual, manera que ésta sea más benéfica para proyecto momento determinado. para lograr esto, equipo ágil puede realizar reuniones grupales diarias para coordinar sincronizar trabajo que debe realizarse ese día. con base información obtenida durante dichas reuniones, equipo adapta enfoque para lograr incremento trabajo. conforme transcurre cada día, autoorganización colaboración continuas mueven equipo hacia incremento software completo. .. conflictos coordinación comunicación existen muchas razones por las que los proyectos software tienen problemas. escala muchos esfuerzos desarrollo grande, que conduce complejidad, confusión dificulta-des significativas coordinación los miembros del equipo. incertidumbre común, que como resultado torrente continuo cambios que detienen equipo proyecto. interoperabilidad convertido una característica clave muchos sistemas. soft-ware nuevo debe comunicarse con software existente ajustarse las restricciones predefi-nidas impuestas por sistema por producto. tales características del software moderno (escala, incertidumbre interoperabilidad) son hechos vida. para lidiar con ellos manera efectiva, deben implantarse métodos efectivos fin coordinar personal que hace trabajo. esto logra estableciendo mecanismos para comunicación formal informal entre los miembros del equipo entre los distintos equipos. comunicación formal consigue mediante “comunicación escrita, reuniones estructuradas otros canales comunicación relativamente interactivos impersonales” [kra]. -punto clave equipo ágil equipo autoorganizado que tiene autonomía para planificar tomar decisiones técnicas. cita: “ propiedad colectiva más que una ilustración idea que los productos deben atribuirse equipo [ágil], los individuos que constituyen equipo.” jim highsmith (-).indd (-).indd // ::// :: parte cuatro administración proyectos software municación informal más personal. los miembros equipo software comparten ideas sobre una base hoc, piden ayuda cuando surgen problemas interactúan unos con otros diariamente. escena: oficina doug miller antes ini- ciar proyecto software casasegura. personajes: doug miller (gerente del equipo ingeniería soft-ware casasegura) vinod raman, jamie lazar otros miembros del equipo ingeniería software del producto. conversación: doug: ¿han tenido oportunidad consultar información preli- minar que preparó mercadotecnia acerca casasegura? vinod (asiente observa sus compañeros equipo): . pero tenemos muchas preguntas. doug: dejemos eso por momento. gustaría hablar acerca cómo vamos estructurar equipo, quién responsable qué... jamie: estoy totalmente favor filosofía ágil, doug. creo que debemos ser equipo autoorganizado. vinod: estoy acuerdo. dada apretada línea tiempo algo incertidumbre, así como hecho que todos somos realmen- competentes [risas], ésta parece ser forma correcta avanzar.doug: está bien por , pero ustedes conocen las instrucciones. jamie (sonríe habla como recitara algo): “tomamos decisiones tácticas acerca quién hace qué cuándo, pero nuestra responsabilidad sacar producto tiempo.” vinod: con calidad.doug: exactamente. pero recuerden que hay restricciones. merca- dotecnia define los incrementos del software que producir... consultándonos, desde luego. jamie: ¿?doug: vamos usar uml como nuestro enfoque modelado.vinod: pero mantendremos documentación extraña míni- absoluto. doug: ¿quién enlace conmigo?jamie: decidimos que vinod sea líder técnico; tiene más expe- riencia, así que vinod enlace, pero siéntete libertad hablar con cualquiera nosotros. doug (ríe): preocupen. haré.casasegura estructura del equipo . producto gerente proyecto software enfrenta con dilema comienzo mismo proyecto software. requieren estimaciones cuantitativas plan organizado, pero hay información sólida disponible. análisis detallado los requerimientos del software propor-cionaría información necesaria para las estimaciones, pero análisis usualmente tarda sema-nas incluso meses completarse. peor aún, los requerimientos pueden ser fluidos cambiar con regularidad conforme avanza proyecto. , sin embargo, ¡ necesita plan “ahora”! guste gerente proyecto, debe examinar producto; pretende que problema resuelva desde principio mismo del proyecto; cuando menos, debe establecer acotar ámbito del producto. .. ámbito del software primera actividad administración del proyecto software determinar ámbito del software, que define responder las siguientes preguntas: contexto. ¿cómo encaja sistema, producto contexto empresarial más grande software que construir qué restricciones imponen como resultado del contexto? objetivos información. ¿qué objetos datos visibles para cliente producen como salida del software? ¿qué objetos datos requieren como entrada? función desempeño. ¿qué función realiza software para transformar los datos entrada salida? ¿existe alguna característica desempeño especial que deba abor-darse? puede acotar una característica del software que intenta construir, mencione característica como riesgo del proyecto (capítulo ).consejo (-).indd (-).indd // ::// :: conceptos administración proyecto ámbito del proyecto software debe tener ambigüedades ser incomprensible los niveles administrativo técnico. debe acotar enunciado del ámbito del software; decir, los datos cuantitativos (por ejemplo, número usuarios simultáneos, entorno objetivo, máxi- tiempo respuesta permisible) enuncian manera explícita, anotan las restricciones / limitaciones (por ejemplo, costo del producto restringe tamaño memoria) describen los factores mitigantes (por ejemplo, los algoritmos deseados están bien entendidos disponibles java). .. descomposición del problema descomposición del problema, ocasiones llamada división elaboración del problema , una actividad que asienta centro del análisis requerimientos del software (capítulos ). durante actividad determinación del ámbito, hacen intentos por descomponer completamente problema. vez ello, descomposición aplica dos áreas principa-les: ) funcionalidad contenido (información) que deben entregarse ) proceso que usará para entregarlo. los seres humanos tienden aplicar una estrategia “divide vencerás” cuando enfren- tan problema complejo. dicho manera simple, problema complejo divide pro-blemas más pequeños que son más manejables. ésta estrategia que aplica conforme comienza planeación del proyecto. las funciones del software, descritas enunciado del ámbito, evalúan refinan para proporcionar más detalle antes comenzar estimación (capítulo ). puesto que tanto las estimaciones costo como las calendario orientan funcionalmente, con frecuencia útil cierto grado descomposición. igual modo, los prin-cipales objetos contenido datos descomponen sus partes constituyentes, que pro-porciona una comprensión razonable información que producir con software. tome como ejemplo proyecto que construirá nuevo producto procesamiento palabras. entre las características únicas del producto, están entrada continua voz, así como teclado virtual través una pantalla táctil, características extremadamente sofisti-cadas “edición copia automática”, capacidad plantilla página, indexado automático tabla contenidos automática. gerente del proyecto debe establecer primero enunciado del ámbito que acote dichas características ( otras funciones más comunes, tales como edición, gestión archivos producción documentos). por ejemplo, ¿ entrada continua voz requiere que usuario “entrene” producto? específicamente: ¿qué capacidades ofrecerá editor copia? ¿cuán sofisticadas serán las capacidades plantilla página?, ¿éstas abar-carán las capacidades que requiere una pantalla táctil? conforme avanza determinación ámbito, ocurre manera natural primer nivel división. equipo proyecto aprende que departamento mercadotecnia habló con los clientes potenciales descubrió que las siguientes funciones deben ser parte edición -tomática copia: ) corrector vocabulario, ) corrector gramatical, ) comprobación referencias para documentos grandes (por ejemplo, ¿una referencia una entrada bibliográfica encuentra lista entrada bibliografía?), ) implementación una característica hoja estilo que imponga consistencia través documento ) validación refe-rencias sección capítulo para documentos grandes. cada una estas características -presenta una subfunción por implementar software. cada una puede refinarse aún más descomposición hace más sencilla planificación. . proceso las actividades del marco conceptual (capítulo ) que caracterizan proceso software son aplicables todos los proyectos software. problema seleccionar modelo proceso que sea adecuado para software que equipo del proyecto someterá ingeniería.para desarrollar plan proyecto razonable, debe descomponer problema. esto puede lograrse usando una lista funciones con casos uso.consejo (-).indd (-).indd // ::// :: parte cuatro administración proyectos software equipo debe decidir qué modelo proceso más adecuado: ) para los clientes que solicitaron producto personal que hará trabajo, ) para las características del producto ) para entorno proyecto donde trabaja equipo software. cuando selecciona modelo proceso, equipo define entonces plan proyecto preliminar con base conjunto actividades del marco conceptual del proceso. una vez establecido plan prelimi-nar, comienza descomposición del proceso, decir, debe crearse plan completo que -fleje las tareas laborales requeridas para poblar las actividades del marco conceptual. estas actividades exploran brevemente las secciones que siguen; capítulo presenta una visión más detallada. .. fusión producto proceso planificación del proyecto comienza con fusión producto proceso. cada función que someter ingeniería por parte del equipo debe pasar través del conjunto actividades marco conceptual que defina organización software. suponga que organización adoptó las actividades genéricas del marco conceptual que estudiaron capítulo : comunicación, planificación, modelado, construcción des- pliegue. los miembros del equipo que trabajen una función del producto aplicarán ella cada una las actividades del marco conceptual. esencia, crea una matriz similar que muestra figura .. cada función producto principal (las funciones anotadas con números para software procesamiento palabra estudiadas anteriormente) menciona columna izquierda. las actividades marco conceptual mencionan fila superior. las tareas del trabajo ingeniería software (para cada actividad del marco conceptual) ingresarán fila siguiente. labor del gerente proyecto ( otros miembros del equipo) estimar los requerimientos recurso para cada celda matriz, fechas inicio término las tareas asociadas con cada celda, los productos operativos que van producir como consecuencia cada tarea. dichas actividades consideran capítulo . .. descomposición del proceso equipo software debe tener grado significativo flexibilidad elegir modelo proceso software que mejor para proyecto las tareas ingeniería software que actividades comunes del marco conceptual del proceso tareas ingeniería software funciones del producto entrada texto edición formato edición automática copia capacidad plantilla página indexado automático automática gestión archivo producción documentocomunicaciónplaniﬁcaciónmodeladoconstrucción desplieguefigura . fusión problema proceso obsérvese que las tareas deben adaptarse las necesidades específicas del proyecto, con base algunos crite- rios adaptación. (-).indd (-).indd // ::// :: conceptos administración proyecto pueblen modelo proceso una vez elegido. proyecto relativamente pequeño que sea - milar esfuerzos anteriores puede lograrse mejor usar enfoque secuencial lineal. fecha límite tan apretada como para que toda funcionalidad pueda entregarse razonable-mente, puede ser mejor una estrategia incremental. igual modo, los proyectos con otras -racterísticas (por ejemplo, requerimientos incertidumbre, tecnología innovadora, clientes -fíciles, significativo potencial reuso) conducirán selección otros modelos proceso. una vez elegido modelo proceso, marco conceptual del proceso adapta . todo caso, puede usarse marco conceptual genérico proceso que estudió anteriormente. funcionará para los modelos lineales, para modelos iterativos incrementales, para modelos evolutivos incluso para modelos concurrentes ensamble componentes. marco con-ceptual del proceso invariante sirve como base para todo trabajo que realiza una -ganización software. pero las tareas del trabajo real varían. descomposición del proceso comienza cuando gerente proyecto pregunta: ¿cómo logramos esta actividad del marco conceptual? por ejem-plo, proyecto simple relativamente pequeño puede requerir las siguientes tareas para actividad comunicación: . desarrollar lista clarificación conflictos. . reunirse con los participantes para abordar clarificación conflictos. . desarrollar conjunto enunciado del ámbito. . revisar enunciado del ámbito con todos los interesados. . modificar enunciado del ámbito según requiera. estos eventos pueden ocurrir durante periodo menos horas. representan una des-composición proceso que adecuada para pequeño proyecto relativamente simple. ahora, considere proyecto más complejo, que tenga ámbito más amplio impacto empresarial más significativo. proyecto puede requerir las siguientes tareas para comu- nicación: . revisar solicitud del cliente. . planificar calendarizar una reunión formal facilitada con todos los participantes. . realizar investigación para especificar solución propuesta los enfoques existentes. . preparar “documento trabajo” una agenda para reunión formal. . realizar reunión. . desarrollar conjuntamente miniespecificaciones que reflejen las características - tos, funcionales comportamiento del software. manera alternativa, desarrollar casos uso que describan software desde punto vista del usuario. . revisar cada miniespecificación usar casos uso para ver exactitud, consistencia falta ambigüedad. . ensamblar las miniespecificaciones documento ámbito. . revisar documento ámbito colección casos uso con todos los interesados. . modificar documento ámbito casos uso según requiera. ambos proyectos realizan actividad marco conceptual que llama comunicación, pero primer equipo proyecto realiza mitad tareas trabajo ingeniería software que segundo. recuerde que las características del proyecto también tienen mucho apoyo estructura del equipo soft- ware (sección ..).punto clave marco conceptual del proceso establece esqueleto para planificación del proyecto adapta para abarcar conjunto tareas que son adecuadas para proyecto. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . proyecto para administrar proyecto software exitoso, debe comprender qué puede salir mal, modo que los problemas puedan evitarse. excelente ensayo acerca los proyectos software, john reel [ree] define señales que indican que proyecto sistemas información está peligro: . personal del software entiende las necesidades del cliente. . ámbito del producto está pobremente definido. . los cambios gestionan pobremente. . cambia tecnología elegida. . las necesidades empresariales cambian [ están mal definidas]. . las fechas límite son irreales. . los usuarios son resistentes. . pérdida patrocinio [ nunca obtenido adecuadamente]. . equipo del proyecto carece personal con habilidades adecuadas. . los gerentes [ profesionales] evitan mejores prácticas lecciones aprendidas. los profesionales industria, hastiados, con frecuencia refieren regla - cuando estudian proyectos software particularmente difíciles: primer por ciento sistema absorbe por ciento del esfuerzo tiempo asignados. último por ciento toma otro por ciento del esfuerzo tiempo asignados [zah]. las semillas que conducen regla - están contenidas las señales anotadas lista anterior . pero, ¡basta negatividad! ¿cómo actúa gerente para evitar los problemas recién anota- dos? reel [ree] sugiere enfoque sentido común cinco partes los proyectos software: . comenzar con pie derec . esto logra trabajar duro (muy duro) para entender problema que debe resolverse luego establecer objetivos expectativas realistas para todos aquellos que estarán involucrados proyecto. anterior refuerza cons-truir equipo correcto (sección ..) darle autonomía, autoridad tecnología nece-sarias para realizar trabajo. . mantener cantidad vimiento. muchos proyectos parten hacia buen comienzo luego lentamente desintegran. fin mantener cantidad movimiento, -rente proyecto debe proporcionar incentivos para mantener rotación personal mínimo absoluto, equipo debe enfatizar calidad cada tarea que realice administrador ejecutivo debe hacer todo posible para permanecer fuera del camino del equipo. . siga pista progreso. para proyecto software , progreso rastrea conforme los productos operativos (por ejemplo, modelos, código fuente, conjuntos casos prueba) producen aprueban (usando revisiones técnicas) como parte una activi-dad que asegure calidad. además, pueden recopilarse medidas proceso soft-ware proyecto (capítulo ) usarse para valorar progreso contra promedios desa- rrollados para organización desarrollo del software.¿cuáles son las señales que proyecto software está peligro?? cita: “ tenemos tiempo para dete-nernos por combustible, vamos retrasados.” . cleron implicación esta afirmación que burocracia reduce mínimo, las reuniones extrañas eliminan quita énfasis adhesión dogmática las reglas proceso proyecto. equipo debe ser autoorgani- zado autónomo.cita: “ proyecto como viaje carretera. algunos son sim-ples rutinarios, como conducir hacia tienda plena luz del día. pero mayoría los pro-yectos que vale pena realizar son más parecidos conducir una camioneta / las montañas noche.” cem kaner, james bach bret pettichord (-).indd (-).indd // ::// :: conceptos administración proyecto . ome decisiones inteligentes. esencia, las decisiones del gerente del proyecto del equipo software deben “mantenerse simples”. siempre que sea posible, decida usar software comercial anaquel, componentes patrones software existentes, así como evitar interfaces medida cuando estén disponibles enfoques estándar; decida también identificar luego evitar los riesgos obvios, asignar más tiempo del que considere necesario para tareas complejas riesgosas (necesitará cada minuto). . realice análisis postmortem. establezca mecanismo consistente para extraer lec- ciones aprendidas por cada proyecto. evalúe los calendarios planeado real, recopile analice métricas proyecto software , consiga retroalimentación los miembros del equipo los clientes, registre los hallazgos forma escrita. . principio excelente ensayo acerca del proceso software los proyectos, barry boehm [boe] afirma: “necesita principio organización que reduzca escala fin proporcionar pla-nes [ proyecto] simples para proyectos simples”. boehm sugiere enfoque que aborda los objetivos del proyecto, hitos calendarios, responsabilidades, enfoques administrativos técni-cos, recursos requeridos. llama principio , por una serie preguntas que conducen una definición las características clave del proyecto plan proyecto resultante: ¿por qué (why) desarrollará sistema? todos los participantes deben valorar validez las razones empresariales para trabajo software. ¿ propósito empresa justifica gasto personal, tiempo dinero? ¿qué (what) hará? defina conjunto tareas requeridas para proyecto. ¿cuándo (when) hará? equipo establece calendario proyecto identificar cuándo realizarán las tareas del proyecto cuándo alcanzarán los hitos. ¿quién (who) responsable cada función? defina papel responsabilidad cada miembro del equipo software. ¿dónde (where) ubicarán organización? todos los roles responsabilidades resi- den dentro los profesionales del software. clientes, usuarios otros participantes tam-bién tienen responsabilidades. ¿cómo (how) hará trabajo, técnica organizativamente? una vez establecido ámbito del producto, debe definirse una estrategia técnica para proyecto. ¿cuánto (how much) necesita cada recurso? respuesta esta pregunta deriva desarrollar estimaciones (capítulo ) con base las respuestas las preguntas anteriores. principio boehm aplicable sin importar tamaño complejidad proyecto software. las preguntas anotadas ofrecen excelente esbozo planificación. . rácticas cruciales airlie council desarrolló una lista “prácticas software cruciales para administración basada desempeño”. dichas prácticas “las usan consistentemente, las consideran cruciales, ¿cómo definen las características clave del proyecto?? airlie council incluyó equipo expertos ingeniería software contratados por departamento defensa estadounidense para ayudar desarrollar lineamientos para mejores prácticas administración proyectos software ingeniería software. para conocer más acerca mejores prácticas, vea (-).indd (-).indd // ::// :: parte cuatro administración proyectos software proyectos organizaciones enormemente exitosas cuya ‘línea base’ para desempeño con- sistentemente mucho mejor que promedio industrial” [air]. las prácticas cruciales incluyen: administración del proyecto basada métrica (capítulo ), estimación empírica costo calendario (capítulos ), rastreo del valor ganado (-pítulo ), rastreo defecto contra metas calidad (capítulos del ) administración consciente del personal (sección .). cada una estas prácticas cruciales aborda largo las partes este libro. aquí sólo mencionan aquellas prácticas cruciales asociadas con “integridad del proyecto”. las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus res-pectivos desarrolladores. . resumen administración proyectos software una actividad sombrilla dentro ingeniería software. comienza antes iniciar cualquier actividad técnica continúa largo del modelado, construcción despliegue del software cómputo. cuatro tienen influencia sustancial sobre administración del proyecto software: per- sonal, producto, proceso proyecto. personal debe organizarse equipos eficaces, motiva-dos para hacer trabajo software alta calidad, coordinarse para lograr comunicación efectiva. los requerimientos del producto deben comunicarse cliente desarrollador, divi-dirse (descomponerse) sus partes constitutivas ubicarse para trabajo por parte del equipo software. proceso debe adaptarse personal producto. selecciona marco con-ceptual común proceso, aplica paradigma ingeniería software adecuado elige conjunto tareas trabajo para realizar trabajo. finalmente, proyecto debe organi-zarse forma que permita triunfar equipo software. elemento esencial todos los proyectos software personal. los ingenieros del software pueden organizarse diferentes estructuras equipo que van desde las jerarquías tradicionales control hasta los equipos “paradigma abierto”. para apoyar trabajo del equipo, pueden aplicarse varias técnicas coordinación comunicación. general, las revi-siones técnicas comunicación informal persona persona tienen más valor para los profe-sionales. actividad administración del proyecto abarca medición métricas, estimación calen- darización, análisis riesgos, rastreo control. cada uno estos temas considera los capítulos siguientes.las “herramientas” citadas aquí son genéricas aplican amplio rango actividades realizadas por los gerentes proyecto. capítulos finales consideran las herra-mientas específicas administración proyecto (por ejemplo, herramientas calendarización, estimación, análisis deriesgo). herramientas representativas: software program manager’ network ( desa- rrolló una herramienta simple llamada project control panel, que brinda los gerentes proyecto indicio directo del estado del proyecto. herramienta tiene “calibradores” muy parecidos tablero implementa con microsoft excel. está disponible para descarga gantthead.com ( desarrolló conjunto útiles listas comprobación para gerentes proyecto. ittoolkit.com ( proporciona “una colección guías planificación, plantillas proceso hojas trabajo inteligentes” disponible -rom.herramientas software herramientas software para gerentes proyecto (-).indd (-).indd // ::// :: conceptos administración proyecto problemas puntos por evaluar .. con base información contenida este capítulo propia experiencia, desarrolle “diez mandamientos” para empoderar los ingenieros del software, decir, elabore una lista lineamientos que conducirán personal software que trabaje toda potencia. .. modelo madurez capacidades del personal (people-cmm) the software engineering ins- titute, people-cmm echa vistazo organizado “áreas prácticas clave” que cultivan buen personal software. instructor asignará una apc para análisis resumen. .. describa tres situaciones vida real las que cliente usuario final sean mismo. describa tres situaciones las que sean diferentes. .. las decisiones tomadas por los administradores ejecutivos pueden tener impacto significativo sobre efectividad equipo ingeniería del software. proporcione cinco ejemplos para ilustrar que esto cierto. .. revise libro weinberg [wei] escriba resumen, con una extensión dos tres páginas, los temas que deben considerarse aplicar modelo moi. .. lector asigna una gerencia proyecto dentro una organización sistemas informa- ción. labor será construir una aplicación que sea muy similar otras que equipo construyó, aunque ésta será más grande más compleja. los requerimientos documentaron ampliamente por parte del cliente. ¿qué estructura equipo elegiría por qué? ¿qué modelo proceso software elegiría por qué? .. lector asigna una gerencia proyecto para una pequeña compañía productos software. labor será construir producto innovador que combine hardware realidad virtual con software última generación. puesto que competencia para mismo mercado entretenimiento intensa, existe una presión significativa para tener listo trabajo. ¿qué estructura equipo elegiría por qué? ¿qué -delo proceso software elegiría por qué? .. lector asigna una gerencia proyecto para una gran compañía productos software. labor será administrar desarrollo versión siguiente generación software procesamiento palabras ampliamente usado. puesto que competencia intensa, establecieron anunciaron apre-tadas fechas límite. ¿qué estructura equipo elegiría por qué? ¿qué modelo proceso software ele-giría por qué? .. lector asigna una gerencia proyecto software para una compañía que atiende mundo ingeniería genética. labor será administrar desarrollo nuevo producto software que ace-lerará ritmo tipificación genética. trabajo está orientado investigación desarrollo, pero meta elaborar producto dentro del próximo año. ¿qué estructura equipo elegiría por qué? ¿qué modelo proceso software elegiría por qué? .. lector pedido desarrollar una pequeña aplicación que analice cada curso ofrecido universidad reporte las calificaciones promedio obtenidas curso (por determinado periodo). -ponga alcance las limitaciones este trabajo. .. haga una descomposición funcional primer nivel función plantilla página que - tudió brevemente sección ... lecturas fuentes información adicionales project management institute (guide the project management body knowledge, pmi, ) abarca todos los aspectos importantes administración proyectos. bechtold (essentials software project manage- ment, . ., management concepts, ), wysocki (effective software project management, wiley, ), stellman greene ( applied software project management, ’reilly, ), berkun ( the art project manage- ment, ’reilly, ) enseñan habilidades básicas ofrecen lineamientos detallados para todas las tareas administración proyectos software. mcconnell ( professional software development, addison-wesley, ) ofrece consejo pragmático para lograr “calendarios más cortos, productos mayor calidad proyec-tos más exitosos”. henry (software project management, addison-wesley, ) ofrece consejo del mundo real que útil para todos los gerentes proyecto. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software tom demarco . ( adrenaline junkies and template zombies, dorset house, ) escribieron trata- miento comprensivo los patrones humanos que encuentran todo proyecto software. una exce- lente serie cuatro volúmenes, escrito por weinberg (quality software management , dorset house, , , , ), presenta conceptos sistemas básicos pensamiento administración, explica cómo usar efectivamente las mediciones aborda “acción congruente”, habilidad para establecer “ajuste” entre las necesidades del gerente, las necesidades del personal técnico las necesidades empresa. ello proporcionará información útil los gerentes novatos los expertos. futrell . (quality software project management, prentice-hall, ) presentan voluminoso tratamiento administración proyectos. brown . ( antipatterns project management, wiley, ) plantean qué hacer durante administra- ción proyecto software. brooks (the mythical man-month , anniversary edition, addison-wesley, ) actualizó libro clásico para ofrecer nueva comprensión los temas proyecto administración software. mcconnell ( software project survival guide, microsoft press, ) presenta excelente lineamiento pragmático para quienes deben administrar proyectos software. purba shah (how manage successful software project , . ., wiley, ) presentan diversos estudios caso que indican por qué algunos proyectos triunfan otros fracasan. bennatan ( time within budget, . ., wiley, ) presenta consejos útiles lineamientos para gerentes proyecto software. weigers ( practical project initiation, microsoft press, ) proporciona lineamientos prácticos para poner marcha exitosamente proyecto software. puede argumentarse que aspecto más importante administración del proyecto software administración personas. cockburn (agile software development, addison-wesley, ) presenta uno los mejores análisis del personal software escrito fecha. demarco lister [dem] escribieron libro definitivo acerca del personal software los proyectos del software. además, años recientes publi-caron los siguientes libros acerca materia vale pena examinarlos: cantor, ., software leadership: guide successful software development, addison- wesley, . carmel, ., global software teams: collaborating across borders and time zones, prentice hall, . constantine, ., peopleware papers: notes the human side software, prentice hall, . garton, ., . wegryn, managing without walls, mcpress, . humphrey, . ., managing technical people: innovation, teamwork, and the software process, addison- wesley, . humphrey, . ., tsp-coaching development teams, addison-wesley, . jones, . ., handbook team design: practitioner’ guide team systems development, mcgraw-hill, . karolak, . ., global software development: managing virtual teams and environments, ieee computer society, . peters, ., getting results from software development teams, microsoft press, .whitehead, ., leading software development team, addison-wesley, . aun cuando relacionan específicamente con mundo del software, ocasiones adolecen sobresimplificación gran generalización, los muy vendidos libros “administración” kanter (confi- dence, three rivers press, ), covy (the habit, free press, ), bossidy (execution: the discipline getting things done, crown publishing, ), drucker ( management challenges for the century, harper business, ), buckingham coffman (first, break all the rules: what the world’ greatest managers differently, simon and schuster, ), christensen (the innovator’ dilemma, harvard business school press, ) enfatizan “nuevas reglas” definidas por una economía rápidamente cambiante. los títulos más antiguos, como who moved cheese? the one-min ute manager search excellence, siguen ofreciendo valiosos elementos que pueden ayudar administrar personal proyectos manera más efectiva. internet está disponible una gran variedad fuentes información acerca las métricas administración proyectos software. una lista actualizada referencias existentes world wide web que son relevantes para administración proyectos software puede encontrarse sitio del libro: (-).indd (-).indd // ::// :: proceso proyecto conceptos clave eficiencia remoción del defecto (dre) . . . . . . . . medición. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . argumentos para. . . . . . . . basada loc . . . . . . . . . calidad del software . . . . . establecimiento programa. . . . . . . . . línea referencia. . . . . . . orientada función . . . . . . orientada objeto. . . . . . . orientadas caso uso . . orientadas tamaño . . . . . proceso . . . . . . . . . . . . . . productividad . . . . . . . . . . proyecto. . . . . . . . . . . . . . público privado. . . . . . . . webapp . . . . . . . . . . . . . . punto función . . . . . . . . . ¿qué ? las métricas proceso proyecto software son medidas cuantitativas que per-miten obtener comprensión acerca efica-cia del proceso del software los proyectos que realizan, usando proceso como marco concep-tual. recopilan datos básicos calidad productivi-dad. luego, analizan, comparan con promedios anteriores valoran para determinar han ocurrido mejoras calidad productividad. las métricas también usan para puntualizar áreas problemáticas, modo que puedan desarrollarse remedios proceso soft-ware pueda mejorarse. ¿quién hace? las métricas del software analizan valoran por parte los gerentes del software. con frecuen-cia, los ingenieros del software recopilan las medidas. ¿por qué importante? mide, juicio puede basarse solamente evaluación subjetiva. con medi-ción, pueden marcarse las tendencias (buenas malas), hacerse mejores estimaciones , con tiempo, lograrse verdadera mejoría. ¿cuáles son los pasos? define conjunto limitado medidas proceso, proyecto producto, que son fáciles recopilar. dichas medidas con frecuencia normalizan usando métricas tamaño función. resultado analiza compara con promedios anteriores para proyec-tos similares realizados dentro organización. las tendencias valoran generan conclusiones. ¿cuál producto final? conjunto métricas software que proporcionan comprensión acerca del proce- del proyecto. ¿cómo aseguro que hice bien? aplicar esquema medición consistente, aunque simple, que nunca debe usarse para valorar, recompensar castigar desempeño individual.una mirada rápidala medición permite ganar comprensión acerca del proceso del proyecto, proporcionar mecanismo evaluación objetiva. lord kelvin dijo alguna vez: cuando puedes medir aquello que hablas expresarlo números, sabes algo acerca ello; pero cuando puedes medir, cuando puedes expresarlo números, conocimiento exiguo insatisfactorio: puede ser comienzo del conocimiento; sin embargo, apenas habrás avanzado, tus pensamientos, hacia etapa una ciencia. comunidad ingeniería del software tomó pecho las palabras lord kelvin. ¡mas sin frustración con poca controversia! medición puede aplicarse proceso software con intención mejorarlo manera continua. puede usarse través proyecto software para auxiliar estimación, control calidad, valoración productividad control proyecto. finalmente, medición pueden usarla los ingenieros del software para ayudar valoración calidad los productos trabajo auxiliar toma decisiones tácticas conforme avanza proyecto (capítulo ). dentro del contexto del proceso software los proyectos que realizan usando aquél, equipo software está preocupado principalmente por productividad por las métricas calidad: medidas “salidas” desarrollo software como función del esfuerzo tiempo aplicado medidas “aptitud para uso” los productos operativos que producen. con propósitos planificación estimación, interés histórico. ¿cuál fue pro-ductividad desarrollo software proyectos anteriores? ¿cuál calidad del software que produjo? ¿cómo pueden extrapolarse presente los datos productividad calidad anteriores? ¿cómo pueden las mediciones ayudar planificar estimar con más precisión? manual acerca medición del software, park, goethert florac [par] anotan las razones por las que mide: ) para caracterizar esfuerzo obtener comprensión “ los (-).indd (-).indd // ::// :: parte cuatro administración proyectos software procesos, productos, recursos entornos, establecer líneas referencia para comparar con valoraciones futuras”; ) para evaluar “determinar estado avance con respecto los pla- nes”; ) para predecir “obtener comprensión las relaciones entre procesos productos, construir modelos dichas relaciones”, ) para mejorar “identificar barricadas, causas raíz, ineficiencias otras oportunidades para mejorar calidad del producto desempeño del proceso”. medición una herramienta administrativa. realiza adecuadamente, ofrece enten- dimiento gerente proyecto. , como resultado, auxilia equipo software para tomar decisiones que conducirán hacia proyecto exitoso. . étricas los dominios proceso proyecto las métricas proceso recopilan través todos los proyectos durante largos espacios tiempo. intención proporcionar conjunto indicadores proceso que conduzca mejorar proceso software largo plazo. las métricas proyecto permiten gerente proyecto software: ) valorar estado proyecto marcha, ) rastrear riesgos -tenciales, ) descubrir áreas problema antes que vuelvan “críticas”, ) ajustar flujo trabajo las tareas ) evaluar habilidad del equipo del proyecto para controlar calidad los productos operativos del software. las medidas que recopila equipo proyecto que convierte métricas para uso durante proyecto también pueden transmitirse quienes tienen responsabilidad mejora del proceso software (capítulo ). por esta razón, muchas las métricas usan tanto los dominios del proceso como los del proyecto. .. las métricas del proceso mejora del proceso software única forma racional para mejorar cualquier proceso medir atributos específicos del mismo, desarrollar conjunto métricas significativas con base dichos atributos luego usarlas para proporcionar indicadores que conducirán una estrategia para mejorar (capítulo ). pero antes estudiar las métricas del software impacto sobre mejoramiento del proceso software, importante observar que proceso sólo uno varios “factores controlables mejoramiento calidad del software del desempeño organizativo” [pau]. figura ., proceso asienta centro triángulo que conecta tres factores que tienen profunda influencia sobre calidad del software desempeño organiza-ción. habilidad motivación del personal demostrado [boe] ser factor individual más influyente calidad desempeño. complejidad del producto puede tener impacto sustancial sobre calidad desempeño del equipo. tecnología ( decir, los métodos herramientas ingeniería del software) que puebla proceso también tiene impacto. además, existe triángulo proceso dentro círculo condiciones ambientales que incluyen entorno desarrollo (por ejemplo, herramientas software integradas), condiciones empresariales (fechas límite, reglas empresariales) características del cliente (facilidad -municación colaboración). eficacia proceso software sólo puede medirse manera indirecta. esto significa que posible derivar conjunto métricas con base los resultados que pueden derivarse del proceso. los resultados incluyen medidas los errores descubiertos antes liberar software, defectos entregados reportados por usuarios finales, productos operativos entre-gados (productividad), esfuerzo humano empleado, tiempo calendario consumido, conformidad con agenda otras medidas. también pueden derivarse métricas proceso medir las características tareas ingeniería software específicas. por ejemplo, puede medirse punto clave métrica proceso tiene impacto largo plazo. intención mejorar proceso . métrica proyecto usualmente contribuye desarrollo primera. punto clave habilidad motivación del personal del software que hace trabajo son los factores más importantes que influyen calidad del software. cita: “las métricas software permiten saber cuándo reír cuándo llorar.” tom gilb (-).indd (-).indd // ::// :: métricas proceso proyecto esfuerzo tiempo empleados realizar las actividades sombrilla las actividades genéricas ingeniería del software descritas capítulo . grady [gra] argumenta que existen usos “privados públicos” para diferentes tipos datos proceso. puesto que natural que los ingenieros software individual puedan ser sensibles uso las métricas recopiladas manera individual, dichos datos deben ser priva-dos para individuo funcionar sólo como indicio para . los ejemplos métricas privadas incluyen tasas defecto (por individuo), tasas defecto (por componente) errores que encuentran durante desarrollo. filosofía “datos proceso privados” conforma bien con enfoque proceso software personal (capítulo ) propuesto por humphrey [hum], quien reconoce que mejo-ramiento proceso del software puede debe comenzar nivel individual. los datos proceso privado pueden funcionar como importante motor conforme trabaja para mejorar enfoque ingeniería del software. algunas métricas proceso son privadas para equipo proyecto del software, pero - blicas para todos los miembros del equipo. los ejemplos incluyen defectos reportados por gran-des funciones software (que desarrollaron por parte algún número profesionales), errores encontrados durante las revisiones técnicas líneas código puntos función por componente función. equipo revisa dichos datos para descubrir indicios que puedan - jorar desempeño del equipo. las métricas públicas por general asimilan información que originalmente era privada para los individuos equipo. las tasas defecto nivel proyecto (absolutamente atribuidas individuo), esfuerzo, tiempos calendario datos relacionados recopilan evalúan con intención descubrir indicios que puedan mejorar desempeño del proceso organizativo. las métricas proceso software pueden proporcionar beneficios significativos conforme una organización trabaja para mejorar nivel global madurez proceso. sin embargo, como todas las métricas, éstas pueden tener mal uso, que crea más problemas los que resuelven. grady [gra] sugiere una “etiqueta métrica software” que sea adecuada tanto para geren-tes como para profesionales, conforme instauran programa métricas proceso:procesoproducto tecnología personalentorno desarrollocaracterísticas del clientecondiciones empresarialesfigura . determinantes para calidad del software efectividad organizativa.fuente: adaptado [pau]. las líneas código las métricas punto función estudian las secciones .. ...¿cuál diferencia entre usos privado público para las métricas del software?? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software • usar sentido común sensibilidad organizacional cuando interpreten datos métricas. • proporcionar retroalimentación regular los individuos equipos que recopilan medidas métricas. • usar métricas para valorar los individuos. • trabajar con los profesionales con los equipos para establecer metas métricas claras que usarán para lograr las primeras. • nunca usar métricas para amenazar los individuos los equipos. • considerar “negativos” los datos métricas que indiquen área problemática. dichos datos simplemente son indicio para mejorar proceso. • obsesionarse con una sola métrica excluir otras métricas importantes. conforme una organización siente más cómoda con recolección uso métricas proceso, derivación los indicadores simples lugar enfoque más riguroso llamado mejora estadística proceso software (meps). esencia, meps usa análisis falla del soft-ware para recopilar información acerca todos los errores defectos que encuentren conforme desarrolle use una aplicación, sistema producto. .. métricas proyecto diferencia las métricas proceso software que usaron con propósitos estratégicos, las medidas proyecto software son tácticas. decir, gerente proyecto equipo software usan las métricas proyecto los indicadores derivados ellas para adaptar flujo trabajo del proyecto las actividades técnicas. primera aplicación las métricas proyecto sobre mayoría los proyectos soft- ware ocurre durante estimación. las métricas recopiladas proyectos anteriores usan como base desde cual hacen estimaciones esfuerzo tiempo para trabajo soft-ware nuevo. conforme avanza proyecto, las medidas esfuerzo tiempo calendario utili-zadas comparan con las estimaciones originales ( con agenda del proyecto). gerente del proyecto usa dichos datos para monitorear controlar progreso. mientras comienza trabajo técnico, otras métricas del proyecto empiezan tener signifi- cado. miden las tasas producción representadas términos modelos creados, horas revisión, puntos función líneas fuente entregadas. además, rastrean los erro-res descubiertos durante cada tarea ingeniería del software. conforme software evolu-ciona desde los requerimientos hasta diseño, recopilan métricas técnicas (capítulo ) fin valorar calidad del diseño proporcionar indicios que influirán enfoque tomado para generación prueba código. intención las métricas proyecto doble. primero, usan para minimizar calen- dario desarrollo hacer los ajustes necesarios para evitar demoras mitigar potenciales problemas riesgos. segundo, usan para valorar calidad del producto sobre una base marcha , cuando necesario, modificar enfoque técnico para mejorar calidad. conforme calidad mejora, los defectos minimizan, conforme conteo defectos baja, cantidad reelaboración requerida durante proyecto también reduce. esto con-duce una reducción costo global del proyecto. este libro, error define como fallo producto operativo ingeniería del software que descubre antes que software entregue usuario final. defecto fallo que descubre después entregar software usuario final. debe destacarse que otros hacen esta distinción.¿qué lineamientos deben aplicarse cuando recopilan métricas software?? ¿cómo deben usarse las métricas durante proyecto ?? (-).indd (-).indd // ::// :: métricas proceso proyecto . edición del software capítulo indicó que las mediciones mundo físico pueden clasificarse dos formas: medidas directas (por ejemplo, longitud tornillo) medidas indirectas (por ejemplo, “calidad” los tornillos producidos, medidos por conteo rechazos). las métricas software pueden clasificarse igual modo. las medidas directas del proceso software incluyen costo esfuerzo aplicado. las medidas directas del producto incluyen líneas código (loc) producidas, rapidez ejecución, tamaño memoria defectos reportados sobre cierto espacio tiempo. las medidas indirectas del producto incluyen funcionalidad, calidad, complejidad, eficiencia, confiabilidad, capacidad mantenimiento muchas otras “habilidades” que estudiaron capítulo . costo esfuerzo requeridos para construir software, número líneas código pro- ducidas otras medidas directas son relativamente sencillos recolectar, tanto establez-can por adelantado convenciones específicas para medición. sin embargo, calidad fun-cionalidad del software eficiencia capacidad mantenimiento son más difíciles valorar pueden medirse sólo manera indirecta. dominio métrica del software dividió métricas proceso, proyecto producto, dijo que las métricas producto que son privadas para individuo con frecuencia combinan para desarrollar métricas proyecto que son públicas para equipo software. luego las métricas proyecto consolidan para crear métricas proceso que son públicas para organización del software como todo. pero, ¿cómo combina una organización las métricas que vienen diferentes individuos proyectos? escena: oficina doug miller cuando proyecto software casasegura está punto comenzar. participantes: doug miller (gerente del equipo ingeniería del software casasegura) vinod raman jamie lazar, miembros del equipo ingeniería software del producto. conversación:doug: antes empezar trabajar este proyecto, gustaría que definieran recopilaran conjunto métricas simples. para comenzar, tendrán que definir sus metas. vinod (frunce ceño): nunca hemos hecho esto antes ...jamie (interrumpe): con base administración línea tiempo que hablaste, nunca tendremos tiempo. cual-quier forma, ¿qué bien hacen las métricas? doug (levanta mano para detener embate): cál- mense respiren, chicos. hecho que nunca hayamos hecho antes principal razón para comenzar ahora, trabajo las métricas del que hablo ninguna manera debe tardar mucho tiem-... hecho, sólo puede ahorrarnos tiempo. vinod: ¿cómo?doug: miren, vamos hacer mucho más trabajo interno inge- niería del software conforme nuestros productos vuelvan más inte-ligentes, habiliten web, todo eso... necesitamos entender proceso que usamos para construir software... mejorarlo modo que podamos construir software mejor manera. única forma hacer esto medir. jamie: pero estamos bajo presión tiempo, doug. estoy favor más papeleo... necesitamos tiempo para hacer nuestro trabajo, para recolectar datos. doug (con calma): jamie, trabajo ingeniero involucra recopilar datos, evaluarlos usar los resultados para mejorar pro-ducto proceso. ¿ equivoco? jamie: , pero...doug: ¿ mantenemos número medidas que recopilemos más cinco seis nos enfocamos calidad? vinod: nadie puede estar contra alta calidad...jamie: cierto... pero, . todavía creo que necesario.doug: voy pedirte que complazcas esto. ¿cuánto saben acerca las métricas del software? jamie (mira vinod): mucho.doug: aquí hay algunas referencias red... pasé algunas horas recuperándolas para avanzar. jamie (sonríe): creo que dijiste que esto tomaría tiempo.doug: tiempo que emplea aprendiendo nunca desperdi- cia... háganlo luego establezcan algunas metas, planteen algunas preguntas definan métrica que necesitamos recopilar.casasegura establecimiento enfoque métricas cita: “ todo que puede contarse cuenta todo que cuenta puede contarse.” albert einstein puesto que muchos factores afectan trabajo software, use métricas para comparar individuos equipos.consejo (-).indd (-).indd // ::// :: parte cuatro administración proyectos software para ilustrar, considere ejemplo simple. los individuos que trabajan dos equipos proyecto diferentes registran categorizan todos los errores que encuentran durante proceso software. las medidas individuales luego combinan para desarrollar medidas equipo. equipo encuentra errores durante proceso software antes liberación. equipo encuentra errores. todas las demás cosas permanecen iguales, ¿cuál equipo más efectivo para descubrir errores largo del proceso? dado que conoce tamaño complejidad los proyectos, puede responderse esta pregunta. sin embargo, las medidas normalizan, posible crear métricas software que permitan comparación con prome-dios organizacionales más amplios. .. métricas orientadas tamaño las métricas software orientadas tamaño derivan normalizar las medidas calidad / productividad para considerar tamaño del software que produjo. una organización software mantiene registros simples, puede crearse una tabla medidas orientadas -maño, como que muestra figura .. tabla menciona cada proyecto desarrollo software que completó durante los años anteriores que corresponden medidas para dicho proyecto. entrada tabla (figura .) para proyecto alfa: líneas código desarrollaron con persona-meses esfuerzo costo $ . debe observarse que los registros esfuerzo código que aparecen tabla representan todas las actividades ingeniería del software (análisis, diseño, código prueba), sólo codificación. más información para proyecto alfa indica que: desarrollaron páginas documenta-ción, registraron errores antes liberar software encontraron defectos después liberarlo cliente, dentro del primer año operación. tres personas trabajaron desa-rrollo del software para proyecto alfa. con finalidad desarrollar métricas que puedan asimilarse con métricas similares otros proyectos, pueden elegirse líneas códigos como valor normalización. partir los rudimentarios datos contenidos tabla, pueden desarrollarse métricas simples orien-tadas tamaño para cada proyecto: • errores por kloc (miles líneas código). • defectos por kloc. • $ por kloc. • páginas documentación por kloc.figura . métricas orientadas tamañoproyecto loc esfuerzo $() . doc. errores defectos personal alfa betagamma ••• ••• ••• ••• •• • •• • (-).indd (-).indd // ::// :: métricas proceso proyecto además, posible calcular otras métricas interesantes: • errores por persona-mes. • kloc por persona-mes. • $ por página documentación. las métricas orientadas tamaño aceptan universalmente como mejor forma medir proceso software. mayor parte controversia gira torno del uso líneas código como medida clave. quienes proponen medida loc afirman que las loc son “-tefacto” todos los proyectos desarrollo software que pueden contarse fácilmente; que muchos modelos existentes estimación software usan loc kloc como entrada clave que existe gran cuerpo literatura predicado datos acerca loc. por otra parte, los opositores argumentan que las medidas loc dependen del lenguaje programación; que cuando considera productividad, castigan los programas bien diseñados pero cortos; que pueden acomodarse con facilidad lenguajes procedurales que uso esti-mación requiere nivel detalle que puede ser difícil lograr ( decir, planificador debe estimar las loc que van producir mucho antes completar análisis diseño). .. métricas orientadas función las métricas software orientadas función usan una medida funcionalidad entregada por aplicación como valor normalización. métrica orientada función mayor uso punto función (). cálculo del punto función basa características del domi-nio complejidad información del software. mecánica del cálculo del estudió capítulo . punto función, como medida loc, controvertido. quienes proponen afirman que independiente del lenguaje programación, que hace ideal para aplicaciones que usan lenguajes convencionales procedurales, que basa datos que más pro-bable que conozcan tempranamente evolución proyecto, que hace más atractivo como enfoque estimación. sus opositores afirman que método requiere cierta “maña”, pues dicho cálculo basa datos subjetivos más que objetivos, que conteo del dominio información ( otras dimensiones) puede ser difícil recopilar después del hecho que tiene significado físico directo: sólo número. .. reconciliación métricas loc relación entre líneas código puntos función depende del lenguaje programación que use para implementar software calidad del diseño. algunos estudios intentan -lacionar las medidas loc. tabla [qsm], que presenta página siguiente, ofrece estimaciones burdas del número promedio líneas código requeridas para construir punto función varios lenguajes programación. una revisión estos datos indica que loc ++ proporciona aproximadamente . veces “funcionalidad” (como promedio) que loc . más aún, loc smalltalk pro-porciona menos cuatro veces funcionalidad loc para lenguaje programación convencional, como ada, cobol . usar información contenida tabla, posible “retroactivar” [jon] software existente para estimar número puntos función, una vez conocido número total enunciados del lenguaje programación.punto clave las métricas orientadas tamaño usan ampliamente, pero continúa debate acerca validez aplicabilidad. vea sección .. para análisis detallado del cálculo . usado con permiso quantitative software management ( copyright . (-).indd (-).indd // ::// :: parte cuatro administración proyectos software las medidas loc usan frecuentemente para calcular métricas productividad. esto invariablemente conduce debate acerca del uso tales datos. ¿ loc/persona-mes ( /persona-mes) grupo debe compararse con datos similares otro? ¿los gerentes -ben valorar desempeño individual usando dichas métricas? respuesta estas preguntas enfático ¡! razón para esta respuesta que muchos factores influyen producti- loc por punto función lenguaje ogramación promedio mediana bajo alto access ada — — ++ :gen/ief — — —dbase — — —easytrieve+ — — — — —foxpro /cool:gen —javascript — — —lotus notes — — —/ — — —rpg /iii —visual basic (-).indd (-).indd // ::// :: métricas proceso proyecto vidad, que hace que las comparaciones entre “manzanas naranjas” malinterpreten con facilidad. cierto que los puntos función las métricas basadas loc son predictores relativa- mente precisos del esfuerzo del costo desarrollo del software. sin embargo, van usar loc para estimación (capítulo ), debe establecerse una línea referencia -formación. dentro del contexto las métricas proceso proyecto, preocupación debe estar cen- trada principalmente productividad calidad, medidas “salida” del desarrollo del software como función del esfuerzo tiempo aplicados medidas “aptitud para uso” los productos operativos que producen. con propósitos mejorar proceso planifica-ción del proyecto, interés histórico. ¿cuál fue productividad desarrollo del software proyectos anteriores? ¿cuál fue calidad del software que produjo? ¿cómo pueden extra-polarse presente los datos productividad calidad anteriores? ¿cómo puede ayudar mejorar proceso planificación nuevos proyectos con más precisión? .. métricas orientadas objeto las métricas proyecto software convencional (loc ) pueden usarse para estimar pro-yectos software orientados objeto. sin embargo, dichas métricas proporcionan sufi-ciente granularidad para los ajustes calendario esfuerzo que requieren conforme -pite través proceso evolutivo incremental. lorenz kidd [lor] sugieren siguiente conjunto métricas para proyectos : número guiones escenario. guión escenario (análogo los casos uso estu- diados través parte este libro) una secuencia detallada pasos que describen interacción entre usuario aplicación. cada guión organiza tripletas forma {iniciador , acción, participante} donde iniciador objeto que solicita cierto servicio (que inicia mensaje), acción resultado solicitud participante objeto servidor que satisface solicitud. número guiones escenario relaciona directamente con tamaño aplicación con -mero casos prueba que deben desarrollarse para ejercitar sistema una vez construido. número clases clave. las clases clave son los “componentes enormemente independien- tes” [lor] que definen tempranamente análisis orientado objeto (capítulo ). puesto que las clases clave son centrales dominio del problema, número tales clases indicio cantidad esfuerzo requerido para desarrollar software también cantidad potencial reuso por aplicar durante desarrollo del sistema. número clases apoyo. las clases apo requieren para implementar sistema, pero relacionan inmediato con dominio del problema. los ejemplos pueden ser clases interfaz usuario (gui), clases acceso manipulación base datos clases cálcu . además, posible desarrollar clases apoyo para cada una las clases clave. las clases apoyo definen manera iterativa largo proceso evolutivo. número clases apoyo indicio cantidad esfuerzo requerido para desarrollar software tam-bién potencial cantidad reuso que aplicar durante desarrollo del sistema. número promedio clases apoyo por clase clave. general, las clases clave conocen tempranamente proyecto. las clases apoyo definen todo largo del mismo. número promedio clases apoyo por clase clave conoce para dominio problema determinado, estimación (con base número total clases) simplificará parte este libro, hace referencia clases clave como clases análisis. raro para guiones escenario múltiple mencionar misma funcionalidad objetos datos. por tanto, tenga cuidado cuando use conteo guión. muchos guiones ocasiones pueden reducirse una sola clase conjunto código.consejo las clases pueden variar tamaño complejidad. por tanto, vale pena considerar clasificación del conteo clase por tamaño complejidad.consejo (-).indd (-).indd // ::// :: parte cuatro administración proyectos software enormemente. lorenz kidd sugieren que las aplicaciones con una gui tienen entre dos tres veces más clases apoyo que clases clave. las aplicaciones gui tienen entre una dos -ces más clases apoyo que clases clave. número subsistemas. subsistema agregado clases que apoyan una función que visible para usuario final sistema. una vez identificados los subsistemas, más fácil plantear calendario razonable cual trabajo sobre los subsistemas divide entre personal del proyecto. para usarse manera efectiva entorno ingeniería del software orientado objeto, necesario recopilar métricas similares las anotadas anteriormente , junto con medidas del proyecto, tales como esfuerzo empleado, errores defectos descubiertos, modelos páginas documentación producidos. conforme crece base datos (después haber completado algunos proyectos), las relaciones entre las medidas orientadas objeto las medidas del pro-yecto proporcionarán métricas que pueden auxiliar estimación del proyecto. .. métricas orientadas caso uso los casos uso utilizan ampliamente como método para describir los requerimientos dominio nivel del cliente empresarial, que implican características funciones del software. parecería razonable usar caso uso como una medida normalización similar loc . como los , caso uso define principio del proceso del software, que permite emplearlo para estimación antes iniciar actividades significativas modelado construcción. los casos uso describen ( manera indirecta, menos) las funciones carac-terísticas visibles para usuario que son requisitos básicos para sistema. caso uso independiente del lenguaje programación. además, número casos uso directa-mente proporcional tamaño aplicación loc número casos prueba que tendrán que designarse para ejercitar por completo aplicación. puesto que los casos uso pueden crearse niveles abstracción enormemente diferen- tes, hay “tamaño” estándar para caso uso. sin una medida estándar que caso uso, aplicación como medida normalización (por ejemplo, esfuerzo empleado por caso uso) causa suspicacia. los investigadores sugieren puntos caso uso (pcu) como mecanismo para estimar esfuerzo del proyecto otras características. los pcu son una función del número actores transacciones implicados por los modelos caso uso análogo algunas formas. tiene más interés este tema, véase [cle]. .. métricas proyecto webapp objetivo todos los proyectos webapp entregar usuario final una combinación con-tenido funcionalidad. las medidas métricas usadas para proyectos tradicionales ingenie-ría del software son difíciles traducir directamente webapps. sin embargo, posible desa- rrollar una base datos que permita acceso medidas productivas calidad internas derivadas algunos proyectos. entre las medidas que pueden recopilarse están: número páginas web estáticas. las páginas web con contenido estático ( decir, usuario final tiene control sobre contenido que despliega página) son las más comunes todas las características webapp. dichas páginas representan complejidad rela-tivamente baja por general requieren menos esfuerzo para construirlas que las páginas dinámicas. esta medida proporciona indicio del tamaño global aplicación del -fuerzo requerido para desarrollarla. los casos uso introdujeron los capítulos . (-).indd (-).indd // ::// :: métricas proceso proyecto número páginas web dinámicas. las páginas web con contenido dinámico ( decir, acciones del usuario final otros factores externos dan como resultado contenido persona-lizado que despliega página) son esenciales toda aplicación comercio elec-trónico, motores búsqueda, aplicaciones financieras muchas otras categorías webapp. dichas páginas representan complejidad relativa más alta requieren más esfuerzo para construirlas que las páginas estáticas. esta medida proporciona indicio del tamaño glo-bal aplicación del esfuerzo requerido para desarrollarla. número vínculos página internos. los vínculos página internos son punteros que proporcionan hipervínculo hacia alguna otra página web dentro webapp. esta medida proporciona indicio del grado acoplamiento arquitectónico dentro web- app. conforme número vínculos página aumenta, esfuerzo empleado -seño construcción navegación también aumenta. número objetos datos persistentes. una webapp puede tener acceso uno más objetos datos persistentes (por ejemplo, una base datos archivo datos). conforme crece número objetos datos persistentes, complejidad webapp también crece esfuerzo para implementarla hace manera proporcional. número sistemas externos puestos interfaz. con frecuencia, las webapps - ben tener interfaces con aplicaciones empresariales “ puerta trasera”. conforme crecen los requerimientos para interfaces, también crecen complejidad desarrollo del sis-tema. número objetos contenido estáticos. los objetos contenido estáticos abarcan información basada texto, gráfica, video, animación audioestática, que incorporan dentro webapp. múltiples objetos contenido pueden aparecer una sola página web. número objetos contenido dinámicos. los objetos contenido dinámicos generan con base las acciones del usuario final abarcan información basada texto, gráfica, video, animación audio, generada internamente, que incorpora dentro webapp. múltiples objetos contenido pueden aparecer una sola página web. número funciones ejecutables. una función ejecutable (por ejemplo, guión applet) proporciona cierto servicio computacional usuario final. conforme número funciones ejecutables aumenta, también crece esfuerzo modelado construcción. cada una las medidas anteriores puede determinarse una etapa relativamente temprana. por ejemplo, puede definirse una métrica que refleje grado personalización del usuario final que requiere para webapp correlacionarla con esfuerzo empleado proyecto / los errores descubiertos conforme realizan revisiones aplican pruebas. para lograr esto, define / número páginas web estáticas npd / número páginas web dinámicas entonces, índice personalización, / npd npd / npe valor varía . conforme hace más grande, nivel personalización webapp convierte problema técnico considerable. similares métricas webapp pueden calcularse correlacionarse con medidas del proyecto, como esfuerzo empleado, errores defectos descubiertos modelos páginas documenta- (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . étricas para calidad software meta dominante ingeniería del software producir sistema, aplicación producto alta calidad dentro marco temporal que satisfaga una necesidad mercado. para -grar esta meta, deben aplicarse métodos efectivos acoplados con herramientas modernas den-tro del contexto proceso software maduro. además, buen ingeniero software ( los buenos gerentes ingeniería del software) deben medir alta calidad realizable. calidad sistema, aplicación producto sólo tan buena como los requerimientos que describen problema, diseño que modela solución, código que conduce pro-grama ejecutable las pruebas que ejercitan software para descubrir errores. conforme software somete ingeniería, pueden usarse mediciones para valorar calidad los -delos requerimientos diseño, código fuente los casos prueba que crearon. para lograr esta valoración tiempo real, las métricas producto (capítulo ) aplican fin evaluar calidad los productos operativos ingeniería del software forma objetiva, lugar subjetiva. gerente proyecto también debe evaluar calidad conforme avanza proyecto. las métricas privadas recopiladas individualmente por los ingenieros del software combinan para proporcionar resultados nivel del proyecto. aunque muchas medidas calidad pue-den recopilarse, empuje primario nivel del proyecto medir los errores defectos. las métricas derivadas estas medidas proporcionan indicio efectividad las activida-des, individuales grupales, aseguramiento control calidad del software. métricas como errores producto operativo por punto función, errores descubiertos por hora revisión errores descubiertos por prueba por hora proporcionan comprensión eficacia cada una las actividades implicadas por métrica. los datos error también las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas existentes esta categoría. mayoría los casos, los nombres las herramientas son marcas registra- das por sus respectivos desarrolladores.ción producidos. conforme crece base datos (después completar algunos proyectos), las relaciones entre las medidas webapp las medidas del proyecto proporcionarán indi-cadores que pueden auxiliar estimación del proyecto. objetivo: auxiliar definición, recolección, evalua- ción reporte medidas métricas software. mecánica: cada herramienta varía aplicación, pero todas ofrecen mecanismos para recolectar evaluar datos que conducen cálculo métricas software. herramientas representativas: function point workbench, desarrollada por charismatek (www. charismatek.com.), ofrece amplio arreglo métricas orientadas . metriccenter, desarrollada por distributive software ( butive.com), respalda procesos automatización para reco-lección datos, análisis, formateo gráficos, generación reportes otras tareas medición.psm insight, desarrollada por practical software and systems measu- rement ( auxilia creación análi-sis posterior una base datos medición proyecto. slim tool set, desarrollada por qsm ( proporcio- conjunto exhaustivo métricas herramientas estima-ción. spr tool set, desarrollada por software productivity research (www. spr.com), ofrece una colección exhaustiva herramientas orientadas . tychometrics, desarrollada por predicate logic, inc. ( cate.com), una suite herramientas que sirven para recopi-lar reportar métricas administración.herramientas software métricas del proyecto del proceso software una entidad compleja. por tanto, deben esperarse errores conforme desarrollen productos operativos. las métricas proceso tienen intención mejorar proceso del software, modo que los errores descubran forma más efectiva.consejo (-).indd (-).indd // ::// :: métricas proceso proyecto pueden usarse para calcular eficiencia remoción defecto (erd) para cada actividad marco conceptual del proceso. erd estudia sección ... .. medición calidad aunque existen muchas medidas calidad del software, exactitud, capacidad manteni- miento, integridad usabilidad proporcionan útiles indicadores para equipo del proyecto. gilb [gil] sugiere definiciones medidas para cada una. exactitud. programa debe operar correctamente proporcionará poco valor sus usuarios. exactitud grado cual software realiza función requerida. -dida más común exactitud son los defectos por kloc, donde defecto define como una falta verificada acuerdo con los requerimientos. cuando considera cali-dad global producto software, los defectos son aquellos problemas reportados por usuario del programa después que programa liberó para uso general. con propósitos valoración calidad, los defectos cuentan sobre periodo estándar, por general año. capacidad mantenimiento. mantenimiento soporte del software representan más esfuerzo que cualquiera otra actividad ingeniería del software. capacidad manteni- miento facilidad con que programa puede corregirse encuentra error, facilidad con que adapta entorno cambia mejorar cliente quiere cambio requerimientos. hay forma medir directamente capacidad mantenimiento; por tanto, deben usarse medidas indirectas. una métrica simple orientada tiempo tiempo medio cambio (tmc), tiempo que tarda analizarse petición cambio, -señar una modificación adecuada, implementar cambio, probarlo distribuirlo todos los usuarios. promedio, los programas con capacidad mantenimiento tendrán tmc más bajo (para tipos cambios equivalentes) que los que tienen dicha capacidad. integridad. integridad del software vuelto cada vez más importante era los ciberterroristas hackers. este atributo mide habilidad sistema para resistir ataques (tanto accidentales como intencionales) seguridad. los ataques pueden -cerse los tres componentes software: programas, datos documentación. para medir integridad, deben definirse dos atributos adicionales: amenaza seguri- dad. amenaza probabilidad (que puede estimarse derivarse evidencia empírica) que ataque tipo específico ocurrirá dentro tiempo dado. seguridad probabilidad (que puede estimarse derivarse evidencia empírica) que ataque tipo específico repelerá. integridad sistema puede definirse entonces como: integridad / /[ / (amenaza / ( / seguridad))]por ejemplo, amenaza ( probabilidad que ataque ocurrirá) . segu- ridad ( probabilidad repeler ataque) ., integridad del sistema . (muy alta). , por otra parte, probabilidad amenaza . probabilidad repe-ler ataque solamente ., integridad del sistema . (inaceptablemente baja). usabilidad. programa fácil usar, con frecuencia está condenado fracaso, incluso las funciones que realiza son valiosas. usabilidad intento por cuantificar facilidad uso puede medirse términos las características que presentaron capítulo . capítulo presentó análisis detallado los factores que influyen calidad las métricas del software que pueden usarse para valorar calidad del software.webref una excelente fuente información acerca calidad del software sobre temas relacionados (incluidas métricas) puede encontrarse (-).indd (-).indd // ::// :: parte cuatro administración proyectos software los cuatro factores recién descritos sólo son una muestra los que han propuesto como - didas para calidad del software. capítulo considera este tema con detalles adicionales. .. eficiencia remoción del defecto una métrica calidad que proporciona beneficio tanto nivel del proyecto como del proceso eficiencia remoción del defecto (erd). esencia, erd una medida habilidad filtrado las acciones aseguramiento control calidad según aplican largo todas las actividades del marco conceptual del proceso. cuando considera para proyecto como todo, erd define forma - guiente: erd / / donde número errores que encontraron antes entregar software usuario final número defectos que encontraron después entrega. valor ideal para erd . decir, encuentran defectos software. realidad, será mayor que , pero valor erd todavía puede tender conforme aumenta para valor dado . hecho, conforme aumenta, probable que valor final dismi- nuirá (los errores filtran antes convertirse defectos). usa como una métrica que proporciona indicio capacidad filtrado las actividades control aseguramiento calidad, erd alienta equipo software instituir técnicas para encontrar tantos errores como sea posible antes entregar. erd también puede usarse dentro del proyecto fin valorar habilidad equipo para encontrar errores antes que pasen siguiente actividad marco conceptual acción ingeniería del software. por ejemplo, análisis requerimientos produce modelo requerimientos que puede revisarse para encontrar corregir errores. aquellos que -cuentran durante revisión del modelo requerimientos pasan diseño (donde pueden encontrarse). cuando usan este contexto, erd redefine como erd / / / donde número errores encontrados durante acción ingeniería del software + número errores encontrados durante acción + ingeniería del software que son rastreables por errores que descubrieron acción ingeniería del software. objetivo calidad para equipo software ( ingeniero software individual) lograr que erdi tienda . decir, los errores deben filtrarse antes que pasen - guiente actividad acción. erd baja conforme avanza través del análisis diseño, emplee algo tiempo para mejorar forma que realiza las revisiones técnicas.consejo escena: oficina doug miller dos días des- pués reunión inicial acerca las métricas software. participantes: doug miller (gerente del equipo ingeniería del software casasegura), vinod raman jamie lazar, miembros del equipo ingeniería del software producto. conversación: doug: ¿los dos tuvieron oportunidad aprender poco acerca las métricas proceso proyecto? vinod jamie: [ambos afirman con cabeza.]doug: siempre buena idea establecer metas cuando adopta alguna métrica. ¿cuáles son las suyas?casasegura establecimiento enfoque métricas (-).indd (-).indd // ::// :: métricas proceso proyecto . ntegración métricas dentro del proceso software mayoría los desarrolladores software todavía miden , tristemente, mayor parte tiene poco deseo comenzar. como apuntó anteriormente este capítulo, problema cultural. intentar recopilar medidas donde nadie las recopiló pasado con frecuencia preci-pita resistencia. “¿por qué necesitamos hacer esto?”, pregunta gerente proyecto ase-diado. “ veo caso”, queja profesional saturado trabajo. esta sección consideran algunos argumentos para fomentar uso las métricas del software presenta enfoque para instituir programa recopilación métricas dentro una organización ingeniería del software. pero antes comenzar, algunas palabras sabiduría (ahora con más dos décadas antigüedad) sugeridas por grady caswell [gra]: algunas las cosas que describen aquí sonarán muy sencillas. sin embargo, realidad, estable- cer programa métricas software exitoso que abarque toda compañía trabajo duro. cuando dice que necesario esperar menos tres años antes que tendencias organizacionales amplias estén disponibles, tiene alguna idea del ámbito tal esfuerzo. vale pena hacer caso advertencia que sugieren los autores, pero los beneficios - dición son tan atractivos que trabajo duro bien vale. .. argumentos para métricas software ¿por qué tan importante medir proceso ingeniería del software del producto (software) que como resultado? respuesta relativamente obvia. mide, hay forma real determinar está mejorando. mejora, está perdido. solicitar evaluar las medidas productividad calidad, equipo software ( administración) puede establecer metas significativas para mejorar proceso software. -teriormente, este libro, indicó que software tema empresarial estratégico para muchas compañías. puede mejorarse proceso través del cual desarrolla, puede tenerse como resultado impacto directo sobre línea referencia. pero para establecer metas fin mejorar, debe entenderse estado actual del desarrollo del software. por tanto, medición utiliza para establecer una línea referencia del proceso desde cual puedan valorarse las mejoras. los rigores diarios del trabajo del proyecto del software dejan poco tiempo para pensa- miento estratégico. los gerentes proyecto software preocupan por conflictos más vinod: nuestras métricas deben enfocarse calidad. hecho, nuestra meta global mantener mínimo absoluto número errores que pasamos una actividad ingeniería del software siguiente. doug: estar muy seguros mantener número defectos libe- rados con producto tan cerca cero como sea posible. vinod (afirma con cabeza): desde luego.jamie: gusta erd como métrica, creo que podemos usarla para todo proyecto, pero también conforme nos movemos una actividad marco conceptual siguiente. nos alentará descu-brir errores cada paso. vinod: también quiero recopilar número horas que pasamos las revisiones.jamie: esfuerzo global que usamos cada tarea ingenie-ría del software. doug: puedes calcular una razón entre revisión desarrollo... puede ser interesante. jamie: también gustaría rastrear algunos datos caso uso. como cantidad esfuerzo requerido para desarrollar caso uso, cantidad esfuerzo requerido para construir software para implementar caso uso ... doug (sonríe): creí que íbamos mantener esto simple.vinod: deberíamos, pero una vez que entras este asunto las métricas, hay muchas cosas interesantes que observar. doug: estoy acuerdo, pero caminemos antes correr ape- guémonos meta. limiten los datos recopilar cinco seis ítems, estamos listos para arrancar. cita: “mediante números, administra- mos las cosas muchos aspectos nuestras vidas... dichos números nos dan com-prensión nos ayudan guiar nuestras acciones.” michael mah larry putnam (-).indd (-).indd // ::// :: parte cuatro administración proyectos software mundanos (pero igualmente importantes): desarrollar estimaciones proyecto significativas, producir sistemas alta calidad, sacar producto tiempo. usar medición para estable-cer una línea referencia del proyecto, cada uno estos conflictos vuelve más manejable. mencionó que línea referencia sirve como base para estimación. adicionalmente, colección métricas calidad permite una organización “afinar” proceso software para remover las causas defectos “menos vitales” que tienen mayor impacto sobre desa-rrollo del software. .. establecimiento una línea referencia establecer una línea referencia para métricas, pueden obtenerse beneficios proceso, proyecto producto (técnico). aunque información que recopila necesita ser fun-damentalmente diferente. las mismas métricas pueden servir muchos dominios. línea referencia métricas consiste los datos recopilados partir los proyectos desarrollo software puede ser tan simple como presenta tabla figura . tan compleja como una base datos exhaustiva que contiene decenas medidas proyecto las métricas derivadas ellas. para ser auxiliar efectivo mejoramiento del proceso / estimación costo - fuerzo, los datos línea referencia deben tener los siguientes atributos: ) deben ser -zonablemente precisos deben evitarse “suposiciones” acerca los proyectos anteriores, ) deben recopilarse para tantos proyectos como sea posible, ) deben ser consistentes (por ejem-plo, una línea código debe interpretarse consistentemente través todos los proyectos para los cuales recopilan datos), ) las aplicaciones deben ser similares trabajo que debe estimarse: tiene poco sentido usar una línea referencia para trabajo sistemas infor-mación lote fin estimar una aplicación incrustada tiempo real. .. recolección, cálculo evaluación métricas figura . ilustra proceso que sigue para establecer una línea referencia métricas. manera ideal, los datos necesarios para establecer una línea referencia reco-lectaron una forma continua. tristemente, éste rara vez caso. por tanto, recopilación datos requiere una investigación histórica los proyectos anteriores fin reconstruir los datos requeridos. una vez recopiladas las medidas (sin duda, paso más difícil), posible estas ideas formalizaron enfoque llamado aseguramiento estadístico calidad del software.¿qué una línea referencia métricas qué beneficio proporciona ingeniero del software?? proceso ingeniería del software proyecto software producto softwarerecopilación datos cálculo métricas evaluación métricasmedidas métricas indicadoresfigura . proceso recopilación métricas del software (-).indd (-).indd // ::// :: métricas proceso proyecto cálculo métricas. dependiendo envergadura las medidas recopiladas, las métricas pueden abarcar amplio rango métricas orientadas aplicaciones (por ejemplo, loc, , orientada objeto, webapp), así como otras orientadas calidad proyecto. finalmente, las métricas deben evaluarse aplicarse durante estimación, trabajo técnico, control del proyecto mejora del proceso. evaluación métricas enfoca las razones subyacen-tes para los resultados obtenidos produce conjunto indicadores que guían proyecto proceso. . étricas para organizaciones pequeñas gran mayoría las organizaciones desarrollo software tienen menos personas sus departamentos software. razonable, mayoría los casos irreal, -perar que tales organizaciones desarrollen programas métricas software exhaustivos. sin embargo, razonable sugerir que las organizaciones software todos los tamaños -dan luego usen las métricas resultantes para ayudar mejorar proceso software local calidad temporalidad sus productos. enfoque sentido común para implementación cualquier actividad software relacionada con software : mantenerlo simple, personalizar para satisfacer las necesidades locales asegurarse que agrega valor. los siguientes párrafos examina manera como relacionan dichos lineamientos con las métricas para tiendas pequeñas. “mantenerlo simple” lineamiento que funciona razonablemente bien muchas acti- vidades. pero, ¿cómo debe derivarse conjunto métricas software “simples” que aun así proporcionen valor cómo puede asegurarse que dichas métricas simples satisfarán las -cesidades específicas organización software? puede comenzarse con enfoque los resultados, medición. consulta grupo software para definir solo objetivo que requiera mejora. por ejemplo, “reducir tiempo para evaluar implementar las peticiones cambio”. una organización pequeña puede seleccionar siguiente conjunto medidas fácil recolección: • tiempo transcurrido (horas días) desde momento que hace una petición hasta que evaluación está completa, tcola. • esfuerzo (persona-horas) para realizar evaluación, weval. • tiempo transcurrido (horas días) desde conclusión evaluación hasta asigna- ción orden cambio personal, teval. • esfuerzo requerido (persona-horas) para hacer cambio, wcambio. • tiempo requerido (horas días) para hacer cambio, tcambio. • errores descubiertos durante trabajo para hacer cambio, ecambio. • defectos descubiertos después liberar cambio cliente base, dcambio. una vez recopiladas dichas medidas para algunas peticiones cambio, posible calcular tiempo transcurrido total desde petición cambio hasta implementación del mismo porcentaje del tiempo transcurrido absorbido por cola inicial, evaluación asignación cambio implementación. igual modo, puede determinarse porcentaje esfuerzo requerido para evaluación implementación. dichas métricas pueden valorarse contexto datos calidad, cambio dcambio. los porcentajes brindan comprensión acerca dónde frena proceso petición cambio pueden conducir definir medidas mejora del pro-punto clave los datos métricas línea referencia deben recopilarse partir gran muestreo representativo proyectos software anteriores. este análisis igualmente relevante para los equipos software que adoptan proceso desarrollo software ágil (capítulo ). apenas comienza recopilar datos métricas, recuerde mantenerlas simples. entierra debajo datos, sus esfuerzos métricas fallarán.consejo ¿cómo debe derivarse conjunto métricas software “simples”?? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software ceso para reducir tcola, weval, teval, wcambio / ecambio. además, eficiencia remoción defecto puede calcularse como erd / ecambio ecambio / dcambio erd puede compararse con tiempo transcurrido con esfuerzo total para determinar impacto las actividades aseguramiento calidad sobre tiempo esfuerzo reque-rido para hacer cambio. para grupos pequeños, costo que representa recopilar medidas calcular métricas varía por ciento del presupuesto del proyecto durante fase aprendizaje, luego disminuye menos por ciento del presupuesto del proyecto después que los ingenieros del software los gerentes del proyecto familiarizan con programa métricas [gra]. dichos costos pueden mostrar rendimiento sustancial sobre inversión comprensión los datos las métricas conducen una mejora proceso significativa para organización del soft-ware. . stablecimiento programa métricas del software software engineering institute (sei) desarrolló manual muy completo [par] para esta-blecer programa métrica software “dirigido hacia meta”. manual sugiere los -guientes pasos: . identificar las metas empresariales. . identificar que quiere conocer aprender. . identificar las submetas. . identificar las entidades atributos relacionados con las submetas. . formalizar las metas medición. . identificar preguntas cuantificables los indicadores relacionados que usarán para ayudar lograr las metas medición. . identificar los elementos datos que recopilarán para construir los indicadores que ayuden responder las preguntas. . definir las medidas que van usar hacer operativas estas definiciones. . identificar las acciones que tomarán para implementar las medidas. . preparar plan para implantación las medidas. estudio detallado estos pasos aprecia mejor manual del sei. sin embargo, vale pena breve panorama los puntos clave. puesto que software apoya las funciones empresariales, diferencia los sistemas produc- tos basados computadora actúa como producto mismo, las metas definidas por empresa casi siempre pueden rastrearse las metas específicas ingeniería del software. por ejemplo, considere producto casasegur . trabajar como equipo, los gerentes ingeniería del software empresa desarrollan una lista metas empresariales prioritarias: . mejorar satisfacción los clientes con los productos. . hacer los productos más fáciles usar. . reducir tiempo que tarda salir nuevo producto mercado. . facilitar apoyo los productos. . mejorar rentabilidad global.webref puede descargarse cmu.edu manual para medición software dirigido hacia las metas. punto clave las métricas del software que elija deben activarse mediante las metas empresariales técnicas que quiera lograr. (-).indd (-).indd // ::// :: métricas proceso proyecto organización software examina cada meta empresarial pregunta: ¿qué actividades manejamos, ejecutamos apoyamos qué hacemos para mejorar dichas actividades? para responder estas preguntas, sei recomienda creación una “lista entidad-pregunta” que anotan todas las cosas (entidades) existentes dentro del proceso software que gestionan que influyen organización software. los ejemplos entidades incluyen recursos desarrollo, productos operativos, código fuente, casos prueba, peticiones cambio, tareas ingeniería del software calendarios. para cada entidad mencionada, per-sonal software desarrolla conjunto preguntas que valoran las características cuantita-tivas entidad (por ejemplo, tamaño, costo, tiempo para desarrollar). las preguntas deriva-das como consecuencia creación una lista entidad-pregunta conducen derivación conjunto submetas que relacionan directamente con las entidades creadas con las actividades realizadas como parte del proceso software. considere cuarta meta: “facilitar apoyo los productos”. siguiente lista preguntas puede derivarse esta meta [par]: • ¿las peticiones cambio los clientes contienen información que requiere para evaluar adecuadamente cambio luego implementarlo una forma oportuna? • ¿cuán grande acumulación trabajo debida petición cambio? • ¿ tiempo respuesta para corregir errores aceptable con base las necesidades del cliente? • ¿ sigue proceso control cambio (capítulo )? • ¿los cambios alta prioridad implementan forma oportuna? partir estas preguntas, organización software puede derivar siguiente submeta: mejorar rendimiento del proceso gestión del cambio . entonces, identifican las entidades atributos del proceso software que son relevantes para submeta delinean las metas medición asociadas con ellas. sei [par] proporciona lineamientos detallados para los pasos del enfoque medición dirigido metas. esencia, las metas medición refinan preguntas que desglosan aún más entidades atributos que entonces refinan métricas. software productivity center ( sugiere enfoque ocho pasos para establecer programa métricas dentro una organización software, que puedan usarse como alternativa enfoque sei descrito sección .. enfoque resume este recuadro. . comprender proceso software existente. identificar actividades marco conceptual (capítulo ). describir información entrada para cada actividad. definir las tareas asociadas con cada actividad. anotar las funciones aseguramiento calidad. mencionar los productos operativos que producen. . definir las metas por lograr mediante establecimiento programa métricas. ejemplos: mejorar precisión estimación, mejorar calidad del producto. . identificar las métricas requeridas para lograr las metas. definir preguntas, por ejemplo, ¿cuántos errores encontrados una actividad marco conceptual pueden rastrearse actividad marco conceptual precedente? crear medidas métricas que ayudarán responder dichas preguntas. . identificar las medidas métricas que van recopilar calcular. . establecer proceso recolección medición responder estas preguntas: ¿cuál fuente las mediciones? ¿pueden usarse herramientas para recopilar los datos? ¿quién responsable recopilar los datos? ¿cuándo recopilan registran datos? ¿cómo almacenan los datos?información establecimiento programa métricas (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . esumen medición permite gerentes profesionales mejorar proceso software; auxiliar planificación, rastreo control proyectos software valorar calidad del producto (soft-ware) que elabora. las medidas atributos específicos del proceso, proyecto producto usan para calcular las métricas software. dichas métricas pueden analizarse para proporcio-nar indicadores que guíen las acciones administrativas técnicas. las métricas proceso permiten que una organización adopte una visión estratégica proporcionar comprensión acerca efectividad proceso software. las métricas proyecto son tácticas. permiten que gerente proyecto adapte flujo trabajo del proyecto enfoque técnico tiempo real. las métricas orientadas tamaño función usan largo industria. las primeras usan línea código como factor normalización para otras medidas, como persona-meses defectos. punto función deriva las medidas del dominio información una valoración subjetiva complejidad del problema. además, pueden usarse métricas orientadas objeto webapp. las métricas calidad del software, como las métricas productividad, enfocan proceso, proyecto producto. desarrollar analizar una línea referencia métricas para calidad, una organización puede corregir aquellas áreas del proceso software que sean causa los defectos software. medición como resultado cambio cultural. recopilación datos, cálculo - tricas análisis métricas son los tres pasos que deben implementarse para comenzar programa métricas. general, enfoque dirigido metas ayuda una organización enfocarse las métricas correctas para empresa. crear una línea referencia métri-cas, una base datos que contenga mediciones proceso producto, los ingenieros soft-ware sus gerentes pueden obtener mejor comprensión del trabajo que hacen del producto que elaboran. problemas puntos por evaluar .. describa con sus palabras diferencia entre métricas proceso proyecto. .. ¿por qué algunas métricas software deben mantenerse “privadas”? ofrezca cinco ejemplos tres métricas que deban ser privadas. brinde ejemplos tres métricas que deban ser públicas. .. ¿qué una media indirecta por qué tales mediciones son comunes trabajo con métricas software? .. grady sugiere una etiqueta para las métricas software. ¿puede agregar tres reglas más las anotadas sección ..? ¿qué mecanismos validación usan para garantizar que los datos son correctos? . adquirir herramientas adecuadas para auxiliar recopila- ción valoración. . establecer una base datos métricas. establecer sofisticación relativa base datos. explorar uso herramientas relacionadas (por ejemplo, repositorio scm, capítulo ). evaluar los productos base datos existentes. . definir mecanismos retroalimentación adecuados. ¿quién requiere información métricas actuales? ¿cómo entregará información? ¿cuál formato información? una descripción considerablemente más detallada estos ocho pasos puede descargarse (-).indd (-).indd // ::// :: métricas proceso proyecto .. equipo encontró errores durante proceso ingeniería del software antes liberación. equipo encontró errores. ¿qué medidas adicionales tendrían que realizarse los proyectos para determinar cuál los equipos eliminó errores manera más eficiente? ¿qué métricas propondría para ayudar realizar esta determinación? ¿qué datos históricos pueden ser útiles? .. presente argumento contra las líneas código como medida para productividad del software. ¿ caso sostendría cuando consideren decenas cientos proyectos? .. calcule valor punto función para proyecto con las siguientes características dominio información: número entradas usuario: salidas usuario: consultas usuario: archivos: interfaces externas: suponga que todos los valores ajuste complejidad son promedios. use algoritmo mencionado capítulo . .. con tabla que presenta sección .., plantee argumento contra uso lenguaje ensamblador con base funcionalidad que entrega por enunciado código. nuevamente con tabla, analice por qué ++ representaría una mejor alternativa que . .. software que usa para controlar una fotocopiadora requiere líneas líneas smalltalk. estime número puntos función para software dentro fotocopiadora. .. equipo ingeniería web construye una webapp comercio electrónico que contiene pági- nas individuales. éstas, son dinámicas, decir, generan internamente con base entrada del usuario final. ¿cuál índice personalización para esta aplicación? .. una webapp entorno apoyo están completamente fortificados contra ataques. los inge- nieros web estiman que probabilidad repeler ataque sólo por ciento. sistema contiene información sensible controvertida, modo que probabilidad amenaza por ciento. ¿cuál integridad webapp? .. conclusión proyecto, determinó que encontraron errores durante actividad modelado durante actividad construcción, que fueron rastreables errores que descubrie-ron actividad modelado. ¿cuál erd para actividad modelado? .. equipo software entrega incremento software los usuarios finales. éstos descubren ocho defectos durante primer mes uso. antes liberación, equipo software encontró errores durante las revisiones técnicas formales todas las tareas prueba. ¿cuál erd global para proyecto después mes uso? lecturas fuentes información adicionales mejoramiento del proceso software (mps) recibió una cantidad significativa atención durante las dos décadas pasadas. dado que medición las métricas software son clave para mejoramiento exitoso del proceso software, muchos libros acerca mps también estudian métricas. rico ( roi software process improvement, . ross publishing, ) ofrece análisis profundidad del mps las métricas que pueden ayudar una organización lograrlo. ebert . ( best practices software measurement, springer, ) abordan uso medición dentro del contexto estándares iso cmmi. kan (metrics and models software quality engineering, . ., addison-wesley, ) presenta una colección métricas relevantes. ebert dumke (software measurement, springer, ) proporcionan tratamiento útil medición métrica para proyectos . mcgarry . ( practical software measurement, addison-wesley, ) presentan consejos profundos para valorar proceso software. una valiosa colección ensayos fueron editados por haug colegas (software process improvement: metrics, measurement, and process modeling, springer- verlag, ). florac carlton ( measuring the software process, addison-wesley, ) fenton pfleeger (software metrics: rigorous and practical approach, revised, brooks/cole publishers, ) estudian cómo pueden usarse las métricas del software para proporcionar los indicadores necesarios fin mejorar proceso software. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software laird brennan (software measurement and estimation, wiley-ieee computer society press, ) - odman (software metrics: best practices for successful management, rothstein associates, inc., ), ana- lizan uso métricas software para administración estimación proyectos. putnam myers (five core metrics, dorset house, ) recurren una base datos más proyectos software para demostrar cómo pueden usarse cinco métricas centrales (tiempo, esfuerzo, tamaño, confiabilidad produc-tividad proceso) para controlar los proyectos software. maxwell ( applied statistics for software mana- gers, prentice-hall, ), presenta técnicas para analizar datos proyecto software. munson ( software engineering measurement , auerbach, ) estudia una amplia matriz conflictos medición ingenie- ría del software. jones (software assessments, benchmarks and best practices, addison-wesley, ) describe tanto medición cuantitativa como los factores cualitativos que ayudan una organización valorar sus procesos prácticas software. medición del punto función convertido una técnica ampliamente usada muchas áreas del trabajo ingeniería del software. parthasarathy ( practical software estimation: function point methods for insourced and outsourced projects , addison-wesley, ) ofrece una guía exhaustiva. garmus herron (function point analysis: measurement practices for successful software projects, addison-wesley, ) anali- zan las métricas proceso con énfasis análisis punto función. relativamente poco publicado acerca las métricas para trabajo ingeniería web. sin embargo, kaushik (web analytics: hour day, sybex, ), stern ( web metrics: proven methods for measuring web site success, wiley, ), inan kean (measuring the success your website, longman, ), nobles grady (web site analysis and reporting, premier press, ) abordan las métricas web desde una perspectiva empresarial mercadotecnia. ieee (symposium software metrics, publicación anual) resume las investigaciones más recientes área métricas. internet, está disponible una gran variedad fuentes información acerca las métricas procesos proyectos. una lista actualizada referencias world wide web que son relevantes para las métricas procesos proyectos puede encontrarse sitio del libro: com/engcs/compsci/pressman/professional/olc/ser.htm (-).indd (-).indd // ::// :: para proyectos software conceptos clave ámbito del software . . . . . . ecuación del software . . . . . . . . . . . . . . . . . . ágil . . . . . . . . . . . . . . . . . basada . . . . . . . . . . basada problema . . . . . basada proceso. . . . . . . casos uso . . . . . . . . . . . modelos empíricos. . . . . . . proyectos orientados objetos . . . . . . . . . . . . . reconciliación . . . . . . . . . . webapps . . . . . . . . . . . . . factibilidad . . . . . . . . . . . . . del proyecto. . . ¿qué ? establece una necesidad real para software; los participantes están bordo, los ingenieros software están listos para comenzar proyecto está punto iniciar. pero, ¿cómo procede? planificación pro-yectos software abarca cinco grandes actividades: estimación, calendarización, análisis riesgos, planifica-ción gestión calidad planificación gestión del cambio. contexto este capítulo, sólo considera estimación, intento por determinar cuánto dinero, esfuerzo, recursos tiempo tomará construir sistema producto específico basado software. ¿quién hace? los gerentes proyecto software, con información solicitada los participantes del proyecto datos métricas software recopiladas proyectos anteriores. ¿por qué importante? ¿construiría una casa sin saber más menos cuánto gastará, las tareas que necesita realizar cronograma para trabajo que rea-lizar? desde luego que , dado que mayoría los sistemas productos basados computadora cuestan considerablemente más que construir una gran casa, pare- razonable realizar una estimación antes comenzar crear software. ¿cuáles son los pasos? estimación comienza con una descripción del ámbito del problema. luego éste des-compone conjunto problemas más pequeños cada uno éstos estima, usando como guías datos históricos experiencia. complejidad riesgo del problema consideran antes realizar una estimación final. ¿cuál producto final? generación una tabla simple que delinea las tareas que van realizar, las funciones por implementar costo, esfuerzo tiempo involucrados para cada tarea. ¿cómo aseguro que hice bien? eso difí- cil, porque realidad sabe hasta que proyecto completa. sin embargo, tiene experiencia sigue enfoque sistemático, genera estimaciones usando datos históricos sólidos, crea puntos datos estima-ción con menos dos métodos diferentes, establece calendario realista continuamente adapta conforme proyecto avanza, puede estar seguro que está haciendo mejor esfuerzo. una mirada rápidala administración los proyectos software comienza con conjunto actividades que manera colectiva llaman planificación proyecto. antes que proyecto pueda comenzar, equipo software debe estimar trabajo que realizar, los recursos que requerirán tiempo que transcurrirá principio fin. una vez completadas dichas actividades, equipo software debe establecer calendario del proyecto que defina las tareas hitos ingeniería software, que identifique quién responsable realizar cada tarea especifique las dependencias entre tareas que puedan imponer una fuerte demora sobre avance. una excelente guía para “sobrevivir proyecto software”, steve mcconnell [mcc] presenta una visión del mundo real planificación del proyecto: muchos trabajadores técnicos preferirían realizar trabajo técnico lugar pasar tiempo planifi- cando. muchos gerentes técnicos tienen suficiente capacitación administración técnica como para sentirse seguros que planificación mejorará resultado proyecto. dado que ninguna parte quiere hacer planes, con frecuencia nunca hacen. pero fallar planificación uno los errores más cruciales que proyecto puede tener... planificación efectiva necesaria para resolver problemas corriente arriba [tempranamente proyecto] bajo costo, lugar corriente abajo [tardíamente proyecto] alto costo. pro-yecto promedio emplea por ciento tiempo “poner día”: corregir errores que cometieron anteriormente proyecto. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software mcconnell argumenta que todo equipo puede encontrar tiempo para planificar ( adaptar plan largo del proyecto), tomando simplemente pequeño porcentaje del tiempo que hubiera empleado rehacer que ocurre porque llevó cabo planificación. . bservaciones acerca las estimaciones planificación requiere adoptar compromiso inicial, aun cuando probable que este “compromiso” resulte erróneo. siempre que hacen estimaciones mira hacia futuro acepta cierto grado incertidumbre habitual. palabras frederick brooks [bro]: ... nuestras técnicas estimación están pobremente desarrolladas. más seriamente, reflejan una suposición expresada que muy falsa: que todo irá bien [...] puesto que tiene incertidumbre acerca las estimaciones, los gerentes software con frecuencia carecen tenacidad cortés para hacer que gente espera buen producto. aunque las estimaciones son tanto arte como una ciencia, esta importante acción nece- sita realizarse forma azarosa. existen técnicas útiles para estimación tiempo esfuerzo. las métricas proceso proyecto pueden proporcionar perspectiva histórica poderosa -trada para generación estimaciones cuantitativas. las experiencias pasadas ( todas las personas involucradas) pueden auxiliar sin medida conforme desarrollen revisen las esti-maciones. puesto que éstas tienden los cimientos todas las acciones planificación del proyecto, planificación del proyecto ofrece mapa caminos para ingeniería soft-ware exitosa, estaríamos mal aconsejados nos embarcáramos sin ella. estimación recursos, costo calendario para esfuerzo ingeniería software requiere experiencia, acceso buena información histórica (métricas) coraje para comprome-terse con las predicciones cuantitativas cuando todo que existe información cualitativa. estimación porta riesgo inherente, éste conduce incertidumbre. complejidad del proyecto tiene fuerte efecto sobre incertidumbre inherente plani- ficación. sin embargo, complejidad una medida relativa que afectada por familiaridad con esfuerzo pasado. profesional que por primera vez desarrolla una sofisticada aplicación comercio electrónico puede considerarla excesivamente compleja. sin embargo, equi- ingeniería web que desarrolla décima webapp comercio electrónico considerará tal trabajo común corriente. han propuesto [zus] algunas medidas cuantitativas comple-jidad software. éstas aplican nivel diseño código , por tanto, son difíciles usar durante planificación del software (antes una salida diseño código). obstante, posible establecer otras valoraciones complejidad más subjetivas (por ejemplo, los facto-res ajuste complejidad punto función descritos capítulo ) las primeras etapas del proceso planificación. tamaño del proyecto otro factor importante que puede afectar precisión eficacia las estimaciones. conforme aumenta tamaño, interdependencia entre varios elementos del software crece rápidamente. descomposición del problema, importante enfoque estimación, vuelve más difícil porque refinamiento los elementos del problema toda-vía puede ser formidable. para parafrasear ley murphy: “ que puede salir mal, saldrá mal”, hay más cosas que pueden fallar, más cosas fallarán. grado incertidumbre estructural también tiene efecto sobre riesgo estimación. este contexto, estructura refiere grado cual solidificaron los requisitos, faci-cita: “los buenos enfoques esti- mación los datos históricos sólidos ofrecen mejor espe-ranza que realmente triunfará sobre demandasimposibles.” caper jones capítulo presentan técnicas sistemáticas para análisis riesgos. con frecuencia, tamaño aumenta debido “lento avance del ámbito”, que ocurre cuando cambian los requi- sitos del problema. aumento tamaño del proyecto puede tener impacto geométrico sobre costo calendario del proyecto (michael mah, comunicación personal).punto clave complejidad del proyecto, tamaño del proyecto grado incertidumbre estructural afectan confiabilidad las estimaciones. (-).indd (-).indd // ::// :: estimación para proyectos software lidad con que dividieron las funciones naturaleza jerárquica información que debe procesarse. disponibilidad información histórica tiene fuerte influencia sobre riesgo estima- ción. mirar hacia atrás, puede emular las cosas que funcionaron mejorar las áreas donde surgieron problemas. cuando hay disponibles métricas software exhaustivas (capítulo ) para proyectos anteriores, pueden hacerse estimaciones con mayor precisión, así como estable-cerse calendarios para evitar las dificultades pasadas riesgo global reduce. riesgo estimación mide por grado incertidumbre las estimaciones cuantita- tivas establecidas para recursos, costo calendario. ámbito del proyecto comprende pobremente los requisitos del proyecto están sujetos cambio, incertidumbre riesgo estimación vuelven peligrosamente altos. como planificador, usted cliente deben reconocer que variabilidad los requisitos del software significa inestabilidad costo calendario. sin embargo, debe volverse obsesivo acerca estimación. los modernos enfoques ingeniería software (por ejemplo, modelos proceso evolutivos) toman una visión iterativa del desarrollo. tales enfoques posible, aunque siempre políticamente aceptable, revisi-tar estimación (conforme conoce más información) revisarla cuando cliente hace cambios los requisitos. . proceso planificación del proyecto objetivo planificación del proyecto software proporcionar marco conceptual que permita gerente hacer estimaciones razonables recursos, costo calendario. además, las estimaciones deben intentar definir los escenarios mejor caso peor caso, modo que los resultados del proyecto puedan acotarse. aunque hay grado inherente incertidumbre, equipo software embarca plan que haya establecido como consecuencia dichas tareas. por tanto, plan debe adaptarse actualizarse conforme avanza proyecto. las siguientes secciones estudia cada una las acciones asociadas con planificación del proyecto software.cita: “ distintivo una mente ins- truida descansar satisfecha con grado precisión que naturaleza del sujeto admite, buscar exactitud cuando sólo posible una aproximación verdad.” aristóteles mientas más conozca, mejor estimará. consecuencia, actualice sus estimaciones conforme avance proyecto.consejo . mbito factibilidad del software ámbito del software describe las funciones características que entregan los usuarios - nales; los datos que son entrada salida; “contenido” que presenta los usuarios como consecuencia usar software desempeño, las restricciones, las interfaces confiabi-lidad que ligan sistema. ámbito define usando una dos técnicas:. establecer ámbito del proyecto. . determinar factibilidad.. analizar los riesgos (capítulo ). . definir recursos requeridos. ) determinar recursos humanos requeridos. ) definir recursos software reutilizables. ) identificar recursos ambientales. . estimar costo esfuerzo. ) descomponer problema. ) desarrollar dos más estimaciones usando tamaño, puntos función, tareas proceso casos uso. ) reconciliar las estimaciones. . desarrollar calendario del proyecto (capítulo ). ) establecer conjunto tareas significativas. ) definir una red tareas. ) usar herramientas calendarización para desarrollar cro-nograma. ) definir mecanismos seguimiento calendario.conjunto tareas conjunto tareas para planificación proyectos (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . una descripción narrativa del ámbito del software desarrolla después comuni- cación con todos los participantes. . los usuarios finales desarrollan conjunto casos uso. las funciones descritas enunciado del ámbito ( dentro los casos uso) evalúan algunos casos desglosan para proporcionar más detalle, previamente comienzo estimación. puesto que las estimaciones costo calendario están funcionalmente orientadas, con frecuencia útil cierto grado descomposición. las consideraciones rendimiento abarcan los requisitos procesamiento tiempo respuesta. las restricciones identifican los límites colocados software por parte hardware externo, memoria disponible otros sistemas existentes. una vez identificado ámbito (con concurrencia del cliente), razonable preguntar: ¿puede construirse software para satisfacer este ámbito? ¿ proyecto factible? con mucha frecuencia, los ingenieros software rápidamente desechan estas preguntas ( son presiona-dos para desecharlas por gerentes impacientes otros participantes), sólo para encontrarse enlodados proyecto que está condenado desde principio. putnam myers [put] abordan este conflicto cuando escriben: [] todo imaginable factible, siquiera software, tan evanescente como pueda aparecer los profanos. por contrario, factibilidad del software tiene cuatro dimensiones sólidas: tecnología: ¿ proyecto técnicamente factible? ¿está dentro del estado del arte? ¿pueden reducirse los defec-tos nivel que coincida con las necesidades aplicación? finanzas: ¿ financieramente factible? ¿ desarrollo puede completarse costo que organización software, cliente mercado puede pagar? tiempo: ¿ tiempo del proyecto para llegar mercado vencerá competen-cia? recursos: ¿ organización tiene los recursos necesarios para triunfar? putnam myers sugieren manera correcta que establecer ámbito suficiente. una vez comprendido éste, debe trabajarse para determinar puede hacerse dentro las dimen- siones recién anotadas. ésta una parte vital, aunque con frecuencia pasada por alto, del proceso estimación. . ecursos segunda tarea planificación estimación los recursos requeridos para lograr esfuerzo desarrollo del software. figura . muestra las tres principales categorías los recursos ingeniería software: personal, componentes software reutilizables -torno desarrollo (herramientas hardware software). cada recurso especifica con cuatro características: descripción del recurso, enunciado disponibilidad, momento que requerirá recurso duración del tiempo que aplicará recurso. las últimas dos características pueden verse como una ventana temporal. disponibilidad del recurso para una ventana específica debe establecerse tiempo práctico más temprano. .. recursos humanos planificador comienza por evaluar ámbito del software seleccionando las habilidades requeridas para completar desarrollo. especifican tanto posición organizacional (por ejemplo, gerente, ingeniero software ejecutivo) como especialidad (por ejemplo, telecomu-nicaciones, base datos, cliente-servidor). para proyectos relativamente pequeños (algunos persona-meses), solo individuo puede realizar todas las tareas ingeniería software los casos uso estudiaron con detalle largo parte este libro. caso uso una descripción basada escenario interacción del usuario con software desde punto vista del usuario. factibilidad del proyecto importante, pero una consideración necesidad empresarial incluso más. bueno construir sistema producto alta tecnología que nadie quiere.consejo (-).indd (-).indd // ::// :: estimación para proyectos software consultar especialistas según requiera. para proyectos más grandes, equipo software puede dispersarse geográficamente través algunas ubicaciones diferentes. por tanto, debe especificar ubicación cada recurso humano. número personas requeridas para proyecto software puede determinarse sólo después hacer una estimación del esfuerzo desarrollo (por ejemplo, persona-meses). más adelante, este capítulo, estudian técnicas para estimar esfuerzo. .. recursos software reutilizables ingeniería software basada componentes (isbc) pone énfasis reusabilidad; decir, creación reutilización bloques constructores software. tales bloques cons-tructores, con frecuencia llamados componentes, deben catalogarse para facilitar referencia, estandarizarse para facilitar aplicación validarse para facilitar integración. bennatan [ben] sugiere cuatro categorías recursos software que deben considerarse conforme avanza planificación: componentes comerciales. software existente que puede adquirirse una tercera parte proyecto anterior. los componentes cots (por las siglas inglés “anaque-les comerciales”) compran una tercera parte, están listos para uso proyecto -tual están completamente validados. componentes experiencia completa. son especificaciones, diseños, código datos prueba existentes, desarrollados para proyectos anteriores que son similares software que construir para proyecto cuestión. los miembros del equipo software tienen mucha experiencia área aplicación representada por dichos componentes. por tanto, las modificaciones requeridas para los componentes experiencia completa tendrán riesgo relativamente bajo.proyectopersonal entorno software reutilizablenúmero habili- dades ubicaciónrecursos redhardwareherra- mientas software componentes cotscomponentes nuevos componentes experiencia completacomponentes experiencia parcialfigura . recursos del proyecto isbc consideró capítulo .nunca olvide que integrar varios componentes reutilizables puede ser reto considerable. peor aún, problema integración sale superficie conforme varios componentes actualizan.consejo (-).indd (-).indd // ::// :: parte cuatro administración proyectos software componentes experiencia parcial. son especificaciones, diseños, código datos prueba existentes, desarrollados para proyectos anteriores que relacionan con software que construir para proyecto cuestión, pero que requerirán modificación sustancial. los miembros del equipo software sólo tienen experiencia limitada área aplicación -pecificada por dichos componentes. por tanto, las modificaciones requeridas por los compo-nentes experiencia parcial entrañan buen grado riesgo. componentes nuevos. son componentes software que equipo software debe cons- truir específicamente para las necesidades del proyecto cuestión. irónicamente, los componentes software reutilizables con frecuencia desprecian durante planificación, sólo para convertirse una preocupación suprema más tarde, durante avance del software. mejor especificar tempranamente los requisitos recurso del software. esta forma puede realizarse una evaluación técnica las alternativas, así como adquisi-ción oportuna. .. recursos ambientales entorno que soporta proyecto software, con frecuencia llamado entorno ingeniería software (eis), incorpora hardware software. hardware proporciona una plataforma que soporta las herramientas (software) requeridas para producir los productos operativos que son resultado buena práctica ingeniería software. puesto que mayoría las orga- nizaciones software tienen múltiples circunscripciones que requieren acceso eis, debe prescribirse ventana temporal requerida para hardware software verificar que dichos -cursos estarán disponibles. cuando sistema basado computadora (que incorpore hardware software especializa- dos) debe someterse ingeniería, equipo software puede requerir acceso elementos hardware que desarrollar por otros equipos ingeniería. por ejemplo, software para dispositivo robótico utilizado dentro una célula fabricación puede requerir robot específico (por ejemplo, soldador robótico) como parte del paso prueba validación; proyecto software para plantilla página avanzada acaso necesite sistema impresión digital alta velocidad algún momento durante desarrollo. cada elemento hardware debe especificarse como parte planificación. . stimación proyectos software estimación costo esfuerzo del software nunca será una ciencia exacta. demasiadas variables (humanas, técnicas, ambientales, políticas) pueden afectar costo final del software esfuerzo aplicado para desarrollo. sin embargo, estimación del proyecto soft-ware puede transformarse arte oscuro una serie pasos sistemáticos que proporcionen estimaciones con riesgo aceptable. para lograr estimaciones confiables costo esfuerzo, surgen algunas opciones: . retrase estimación hasta avanzado proyecto (obviamente, ¡puede lograr estima- ciones por ciento precisas después que proyecto esté completo!). . base las estimaciones proyectos similares que estén completos. . use técnicas descomposición relativamente simples para generar estimaciones costo esfuerzo proyecto. . use uno más modelos empíricos para estimación costo esfuerzo software. otro hardware, entorno meta, computadora sobre cual ejecutará software cuando éste haya liberado usuario final.cita: “ una época outsourcing creciente competencia, capa-cidad para estimar con mayor precisión... surgido como factor crítico éxito para muchos grupos .” rob thomsett (-).indd (-).indd // ::// :: estimación para proyectos software desafortunadamente, primera opción, aunque atractiva, práctica. las estimaciones costo deben proporcionarse por anticipado. obstante, debe reconocer que mientras más espere, más conocerá, mientras más conozca, menos probabilidades tendrá cometer erro-res serios sus estimaciones. segunda opción puede funcionar razonablemente bien proyecto actual muy similar esfuerzos anteriores otros factores que influyen proyecto (por ejemplo, cliente, con-diciones del negocio, entorno ingeniería software, fechas límite) son aproximadamente equivalentes. desafortunadamente, experiencia pasada siempre buen indicador -sultados futuros. las opciones restantes son enfoques viables para estimación del proyecto software. manera ideal, las técnicas anotadas para cada opción deben aplicarse cascada cada una una comprobación cruzada para las demás. las técnicas descomposición tienen enfoque “divide vencerás” para estimación del proyecto. descomponer proyecto funcio-nes principales actividades ingeniería software relacionadas, estimación costo esfuerzo puede realizarse forma escalonada. los modelos estimación empírica pueden usarse para complementar las técnicas descomposición ofrecer enfoque estimación potencialmente valioso por derecho propio. modelo basa experiencia (datos histó-ricos) toma forma / ( ) donde uno los valores estimados (por ejemplo, esfuerzo, costo, duración del proyecto) son parámetros independientes seleccionados (por ejemplo, loc estimadas). las herramientas estimación automatizadas implementan una más técnicas descom- posición modelos empíricos proporcionan una atractiva opción para estimar. tales siste-mas describen las características organización desarrollo (por ejemplo, experiencia, entorno) software que desarrollar. las estimaciones costo esfuerzo infieren dichos datos. cada una las opciones estimación costo del software viables sólo tan buena como los datos históricos usados para generar estimación. existen datos históricos, cálculo descansa sobre cimiento muy inseguro. capítulo examinan las características algunas las métricas software que proporcionan base para los datos estimación históricos. . écnicas descomposición estimación del proyecto software una forma resolución problemas , mayo-ría los casos, problema por resolver; decir, desarrollar una estimación costo -fuerzo para proyecto software muy complejo como para considerarse una sola pieza. por esta razón, debe descomponerse problema volver caracterizarlo como con-junto problemas más pequeños (, esperanzadoramente, más manejables). capítulo , enfoque descomposición analizó desde dos puntos vista dife- rentes: descomposición del problema descomposición del proceso. estimación usa una ambas formas división. pero antes hacer una estimación, debe entenderse ámbito del software que construir generar una estimación “tamaño”. .. dimensionamiento del software precisión una estimación proyecto software basa algunas cosas: ) grado que estimó adecuadamente tamaño del producto que construir, ) habilidad para traducir estimación tamaño esfuerzo humano, tiempo calendario dinero (una cita: “ muy difícil hacer una defen- vigorosa, plausible arriesgada una estimación que infiera sin método cuan-titativo, apoyada por pocos datos certificada principalmen- por las corazonadas los gerentes.” fred brooks punto clave “tamaño” del software que construir puede estimarse usando una medida directa, loc, indirecta, . (-).indd (-).indd // ::// :: parte cuatro administración proyectos software función disponibilidad métricas software confiables proyectos anteriores), ) grado que plan del proyecto refleja las habilidades del equipo software ) estabi-lidad los requisitos del producto entorno que soporta esfuerzo ingeniería soft-ware. esta sección considera problema del dimensionamiento del software. puesto que una estimación proyecto sólo tan buena como estimación del tamaño del trabajo que realizar, dimensionamiento representa primer gran desafío como planificador. con-texto planificación del software, tamaño refiere resultado cuantificable del pro-yecto software. toma enfoque directo, tamaño puede medirse líneas código (loc). elige enfoque indirecto, tamaño representa como puntos función (). putnam myers [put] sugieren cuatro enfoques diferentes para problema dimensio- namiento: • dimensionamiento “lógica difusa”. este enfoque usa las técnicas razonamiento aproximadas que son piedra angular lógica difusa. para aplicar este enfoque, planificador debe identificar tipo aplicación, establecer magnitud una escala cualitativa luego refinar magnitud dentro del rango original. • dimensionamiento del punto función. planificador desarrolla estimaciones las características del dominio información que estudiaron capítulo . • dimensionamiento componente estándar. software está compuesto algunos “componentes estándares” diferentes que son genéricos área aplicación parti-cular. por ejemplo, los componentes estándares para sistema información son subsistemas, módulos, pantallas, reportes, programas interactivos, programas lote, archivos, loc instrucciones nivel objeto. planificador del proyecto estima número ocurrencias cada componente estándar luego usa datos proyecto históricos para estimar tamaño entregado por componente estándar. • dimensionamiento del cambio. este enfoque usa cuando proyecto abarca uso software existente que debe modificarse alguna forma como parte proyecto. planificador estima número tipo (por ejemplo, reuso, código agregado, cambio código, código borrado) las modificaciones que deben lograrse. putnam myers sugieren que los resultados cada uno estos enfoques dimensiona-miento combinen estadísticamente para crear una estimación tres puntos valor esperado . esto logra desarrollar valores para tamaño optimistas (bajos), más probables pesimistas (altos), combinarlos usando ecuación ., descrita sección ... .. estimación basada problema capítulo describieron las líneas código los puntos función como medidas partir las cuales pueden calcularse métricas productividad. los datos loc usan dos formas durante estimación del proyecto software: ) como variables estimación para “dimensionar” cada elemento del software ) como métricas referencia recopiladas proyectos pasados utilizadas conjunto con variables estimación para desarrollar proyec-ciones costo esfuerzo. las estimaciones loc son técnicas estimación distintas, aunque ambas tienen algu- nas características común. comience con enunciado acotado del ámbito del software partir este enunciado intente descomponer enunciado ámbito funciones problema que puedan estimarse cada una manera individual. modo alternativo, puede elegir otro componente para dimensionamiento, como clases objetos, cambios procesos empresariales afectados.¿cómo dimensiona software que planea construir?? ¿que tienen común las estimaciones basadas loc ?? (-).indd (-).indd // ::// :: estimación para proyectos software las métricas productividad referencia (por ejemplo, loc/ /) aplican entonces variable estimación adecuada infiere costo esfuerzo para función. las estimaciones función combinan para producir una estimación global para todo proyecto. sin embargo, importante observar que con frecuencia existe una sustancial dispersión las métricas productividad para una organización, que hace sospechoso uso una sola métrica referencia para productividad. general, los promedios loc/ / deben calcularse por dominio proyecto. decir, los proyectos deben agruparse por tamaño equipo, área aplicación, complejidad otros parámetros relevantes. luego calculan los promedios dominio local. cuando estime nuevo proyecto, primero debe asignarlo dominio después debe usar promedio dominio adecuado para productividad anterior generación estimación. las técnicas estimación loc difieren nivel detalle requerido para descompo- sición meta partición. cuando usa loc como variable estimación, des-composición absolutamente esencial con frecuencia lleva considerables niveles deta-lle. mientras mayor sea grado partición, más probable que puedan desarrollarse estimaciones loc razonablemente precisas. para estimaciones , descomposición funciona modo diferente. lugar enfocarse función, estima cada una las características del dominio información (entradas, salidas, archivos datos, consultas interfaces externas), así como los valores ajuste complejidad que estudiaron capítulo . entonces las estimaciones resultantes pueden usarse para inferir valor que pueda ligarse datos pasados usarse para generar una estimación. sin importar variable estimación que utilice, debe comenzar por estimar rango valores para cada función valor dominio información. con uso datos históricos (cuando todo demás falle) intuición, estime valor tamaño optimista, más probable pesimista para cada función conteo para cada valor dominio información. cuando especifica rango valores, proporciona indicio implícito del grado incertidumbre. entonces puede calcularse valor tres puntos esperado. valor esperado para - riable estimación (tamaño) puede calcularse como promedio ponderado las estima- ciones optimista ( opt), más probable () pesimista (spes). por ejemplo, / sopt / / spes (.) más crédito estimación “más probable” sigue una distribución probabilidad beta. supone que hay una probabilidad muy pequeña que resultado tamaño real ubicará afuera los valores optimista pesimista. una vez determinado valor esperado para variable estimación aplican datos productividad históricos loc . ¿las estimaciones son correctas? única respuesta razona-ble esta pregunta “ puede estar seguro”. cualquier técnica estimación, sin importar sofisticación, debe verificarse con otro enfoque. incluso así, deben prevalecer sentido común experiencia. .. ejemplo estimación basada loc como ejemplo técnicas estimación loc basadas problema, considere paquete software que desarrollar para una aplicación diseño asistido por computadora para componentes mecánicos. software debe ejecutarse una estación trabajo ingeniería tener interfaz con varios periféricos gráficos computadora, incluido ratón, digitaliza- acrónimo significa persona-mes esfuerzo.cuando recopile métricas productividad para proyectos, asegúrese establecer una taxonomía tipos proyecto. esto permitirá calcular promedios específicos dominio hacer estimaciones más precisas.consejo ¿cómo calcula “valor esperado” para tamaño del software?? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software dora, pantalla color alta resolución impresora láser. posible desarrollar enunciado preliminar del ámbito del software: software cad mecánico aceptará datos geométricos bidimensionales tridimensionales - geniero. ingeniero interactuará controlará sistema cad través una interfaz usuario que mostrará características buen diseño interfaz hombre/máquina. todos los datos geométricos otra información apoyo mantendrán una base datos cad. los módulos análisis -seño desarrollarán para producir salida requerida, que desplegará varios dispositivos grá-ficos. software diseñará para controlar interactuar con dispositivos periféricos que incluyen ratón, digitalizadora, impresora láser plotter. este enunciado ámbito preliminar, está acotado. cada oración tendría que expandirse para proporcionar detalle concreto acotamiento cuantitativo. por ejemplo, antes comenzar estimación, planificador debe determinar qué significa “características buen diseño interfaz hombre/máquina” cuáles serán tamaño sofisticación “base datos cad”. para los propósitos señalados, suponga que ocurrió mayor refinamiento que identifican las principales funciones del software mencionadas figura .. después técnica descomposición para loc elabora una tabla estimación (figura .). para cada función desarrollan estimaciones para rango loc. por ejemplo, rango estimaciones loc para función análisis geométrico optimista, loc; más probablemente, loc, pesimista, loc. aplicar ecuación ., valor esperado para función análisis geométrico loc. otras estimaciones infieren forma similar. sumar verticalmente columna loc estimada, para sistema cad establece estimado líneas código. una revisión los datos históricos indica que productividad organizacional promedio para los sistemas este tipo loc/. con base una tarifa mano obra sobre-cargada $ por mes, costo por línea código aproximadamente $. con base estimación loc los datos productividad históricos, costo proyecto total estimado $ esfuerzo estimado persona-meses. .. ejemplo estimación basada descomposición para estimación basada enfoca valores dominio informa-ción lugar funciones del software. con base tabla que presentó figura . estimarían entradas, salidas, consultas, archivos interfaces externas para software cad. muchas aplicaciones modernas residen una red son parte una arquitectura cliente-servidor. por tanto, asegúrese que sus estimaciones incluyen esfuerzo requerido para desarrollar “infraestructura” software.consejo función interfaz usuario facilidades control (iufc) análisis geométrico bidimensional ()análisis geométrico tridimensional ()gestión base datos (gbd)facilidades despliegue gráﬁcos computadora (fdgc)función control periférico (fcp)módulos análisis diseño (mad) líneas código estimadasloc estimadas . tabla estimación para los métodos locno sucumba tentación usar este resultado como estimación proyecto. debe inferir otro resultado usando enfoque diferente.consejo las estimaciones redondean $ persona-mes más cercanos. mayor precisión innecesaria irreal, dadas las limitaciones precisión estimación. (-).indd (-).indd // ::// :: estimación para proyectos software valor calcula usando técnica analizada capítulo . para los propósitos esta estimación supone que factor ponderación complejidad promedio. figura . presenta los resultados esta estimación. cada uno los factores ponderación complejidad estima factor ajuste valor calcula como describe capítulo : factor valor respaldo recuperación comunicaciones datos procesamiento distribuido rendimiento crítico existencia entorno operativo entrada datos línea escena: oficina doug miller mientras comienza planificación del proyecto. participantes: doug miller (gerente del equipo ingeniería software casasegura) vinod raman, jamie lazar otros miembros del equipo ingeniería software del producto. conversación:doug: necesitamos desarrollar una estimación del esfuerzo para proyecto luego debemos definir microcalendario para primer incremento macrocalendario para los incrementos restantes. vinod (afirma con cabeza): muy bien, pero todavía hemos definido algún incremento. doug: cierto, pero por eso por que necesitamos estimar.jamie (frunce ceño): ¿quieres saber cuánto tiempo nos toma- ? doug: esto que necesito. primero, necesitamos descomponer funcionalmente software casasegura... nivel superior... luego tenemos que determinar número líneas código que tomará cada función... luego...jamie: ¡vaya! ¿cómo supone que haremos eso? vinod: hice proyectos anteriores. comienzas con casos uso, determinas funcionalidad requerida para implementar cada uno, estimas conteo loc para cada pieza función. mejor enfoque hacer que todos estimen manera independiente luego comparar los resultados. doug: puedes hacer una descomposición funcional todo proyecto. jamie: pero eso llevará mucho tiempo teníamos que empezar.vinod: ... puede hacerse pocas horas... esta mañana, hecho. doug: estoy acuerdo... podemos esperar exactitud, sólo una idea aproximada cuál será tamaño casasegura. jamie: creo que sólo debemos estimar esfuerzo... todo.doug: también haremos eso. luego usen ambas estimaciones como comprobación cruzada. vinod: vamos hacerlo...casasegura estimación valor dominio información número entradas externas número salidas externasnúmero consultas externasnúmero archivos lógicos internosnúmero archivos interfaz externos conteo totalconteo . . est. . estimación información valores dominio (-).indd (-).indd // ::// :: parte cuatro administración proyectos software transacción entrada sobre múltiples pantallas archivos maestros actualizados línea valores dominio información procesamiento interno diseñado para reuso /instalación diseño múltiples diseñada para cambio ajuste valor . finalmente, infiere número estimado : fpestimado / conteo total / [. / . / /()] / productividad organizacional promedio para sistemas este tipo . /. con base una tarifa mano obra sobrecargada $ por mes, costo por aproxima-damente $ . con base estimado los datos productividad históricos, costo proyecto estimado total $ esfuerzo estimado personas-meses. .. estimación basada proceso técnica más común para estimar proyecto basar estimación sobre proceso que usará. decir, proceso descompone conjunto relativamente pequeño tareas estima esfuerzo requerido para lograr cada tarea. como las técnicas basadas problemas, estimación basada proceso comienza con delineado las funciones software obtenidas del ámbito del proyecto. para cada función debe realizarse una serie actividades marco conceptual. las funciones actividades marco conceptual relacionadas pueden representarse como parte una tabla similar que presentó figura .. una vez fusionadas las funciones del problema las actividades proceso, estima esfuerzo (por ejemplo, persona-mes) que requerirá para lograr cada actividad proceso las actividades marco conceptual elegidas para este proyecto difieren poco las actividades genéricas estudiadas capítulo . son: comunicación con cliente (), planificación, análisis riesgos, ingeniería construcción/liberación.actividad tarea función uicf dbm pcfcgdf dam totales % esfuerzoccplaniﬁ- caciónanálisis riesgoingenieríaconstrucción/ liberacióntotalesce análisis diseño código prueba . . . . . . . . % % % % % % % = comunicación cliente = evaluación cliente. . .. . .. . .. . .. . .. . .. . .. . .. . .. . . . . . . ./ / // / / /afigura . tabla estimación basada proceso (-).indd (-).indd // ::// :: estimación para proyectos software software para cada función del software. dichos datos constituyen matriz central tabla figura .. las tarifas mano obra promedio ( decir, esfuerzo costo/unidad) aplican entonces esfuerzo estimado para cada actividad del proceso. muy probable que tarifa mano obra varíe para cada tarea. personal ejecutivo está enormemente involu-crado las primeras actividades marco conceptual por general son más costosos que personal ejecutivo involucrado construcción liberación. los costos esfuerzos para cada función actividad marco conceptual calculan igual que último paso. estimación basada proceso realiza independientemente estimación loc , entonces tienen dos tres estimaciones para costo esfuerzo que pueden compararse reconciliarse. ambos conjuntos estimaciones muestran concordan-cia razonable, hay buenas razones para creer que las estimaciones son confiables. , por otra parte, los resultados dichas técnicas descomposición muestran poca concordancia, debe realizarse mayor investigación análisis. .. ejemplo estimación basada proceso para ilustrar uso estimación basada proceso, considere software cad que pre-sentó sección ... configuración del sistema todas las funciones software per-manecen sin cambios indican por ámbito proyecto. tabla completa basada proceso que muestra figura ., las estimaciones esfuerzo ( persona-meses) para cada actividad ingeniería software proporcionan para cada función del software cad (abreviada por conveniencia). las actividades ingeniería construcción/liberación subdividen las principales tareas ingeniería software que muestran. para comunicación con cliente, planificación análisis riesgo proporcio-nan estimaciones burdas esfuerzo. las mismas anotan hilera total fondo tabla. los totales horizontal vertical proporcionan indicio del esfuerzo estimado requerido para análisis, diseño, código prueba. debe observarse que por ciento todo esfuerzo emplea tareas ingeniería frontales (análisis requisitos diseño), que indica relativa importancia este trabajo. con base una tarifa promedio mano obra sobrecargada $ por mes, costo total estimado promedio $ , esfuerzo estimado persona-mes. desea, las tarifas mano obra podrían asociarse con cada actividad marco conceptual tarea ingeniería software calcularse por separado. .. estimación con casos uso como señaló largo parte este libro, los casos uso brindan equipo software comprensión acerca del ámbito los requisitos del software. sin embargo, desarrollar enfoque estimación con casos uso problemático por las siguientes razones [smi]: • los casos uso describen usando muchos formatos estilos diferentes; existe una forma estándar. • los casos uso representan una visión externa ( visión del usuario) del software , por tanto, pueden escribirse muchos niveles abstracción diferentes. • los casos uso abordan complejidad las funciones las características que describen. • los casos uso pueden describir comportamiento complejo (por ejemplo, interac- ciones) que involucran muchas funciones características. diferencia una loc punto función, “caso uso” una persona puede -querir meses esfuerzo, mientras que otra puede implementarse día dos. tiempo permite, use granularidad más fina cuando especifique las tareas figura .. por ejemplo, descomponga análisis sus principales tareas estime cada una por separado.consejo cita: “ mejor comprender fondo una estimación antes usarla.” barry boehm richard fairley ¿por qué difícil desarrollar una técnica estimación usando casos uso?? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software aunque algunos investigadores consideran los casos uso como una entrada estima- ción, fecha ningún método estimación probado surgido. smith [smi] sugiere que los casos uso pueden usarse para estimación, pero sólo consideran dentro del contexto “jerarquía estructural” donde usan para describir. smith argumenta que cualquier nivel esta jerarquía estructural puede describirse mediante más casos uso. cada uno éstos abarcaría más escenarios distintos. obviamente, los casos uso que describen sistema grande escriben nivel abs-tracción mucho más alto ( representan considerablemente más esfuerzo desarrollo) que los que describen solo subsistema. consecuencia, antes poder usar los casos uso para estimación, establece nivel dentro jerarquía estructural, determina longitud promedio ( páginas) cada caso uso, define tipo software (por ejemplo, tiempo real, empresarial, ingeniería/científico, webapp, incrustado) considera una arquitectura burda para sistema. una vez establecidas dichas características pueden usarse datos empíri-cos para establecer número estimado loc por caso uso (por cada nivel jerar-quía). entonces usan datos históricos fin calcular esfuerzo requerido para desarrollar sistema. para ilustrar cómo puede realizarse este cálculo, considere siguiente relación: loc estimadas / / locprom / [(/ – ) / (/ / )] / locajuste (.) donde / número real casos uso locprom / loc promedio históricas por caso uso para este tipo subsistema locajuste / representa ajuste con base por ciento locprom, donde define localmente representa diferencia entre este proyecto los proyectos “pro-medio” / escenarios reales por caso uso / escenarios promedio por caso uso para este tipo subsistema / páginas reales por caso uso / páginas promedio por caso uso para este tipo subsistema expresión . podría usarse para desarrollar una estimación burda del número loc con base número real casos uso ajustados por número escenarios longitud página los casos uso. ajuste representa hasta por ciento las loc promedio histó- ricas por caso uso. .. ejemplo estimación basada caso uso software cad introducido sección .. compone tres grupos subsistemas: subsistema interfaz usuario (incluye uicf), grupo subsistemas ingeniería (incluye los subsistemas , dam) grupo subsistemas infraestructura (incluye los subsistemas cgdf pcf). seis casos uso describen subsistema interfaz usuario. cada uno describe mediante más escenarios tiene una longitud promedio seis pági-nas. grupo subsistemas ingeniería describe mediante casos uso ( considera que están nivel superior jerarquía estructural). cada uno estos casos uso tiene más escenarios asociados con una longitud promedio ocho páginas. finalmente, trabajo reciente inferencia puntos casos uso [cle] final cuentas puede conducir enfoque estimación utilizable, usando casos uso. importante observar que expresión . usa exclusivamente con propósitos ilustrativos. como todos los modelos estimación, debe validarse localmente antes que pueda usarse con confianza. (-).indd (-).indd // ::// :: estimación para proyectos software grupo subsistemas infraestructura describe mediante cinco casos uso con promedio sólo seis escenarios una longitud promedio cinco páginas. usando relación anotada expresión ., con = por ciento, elaboró tabla que muestra figura .. observe primera hilera tabla; los datos históricos indi-can que software requiere promedio loc por caso uso cuando caso uso tiene más escenarios describe menos cinco páginas. dichos datos ajustan razonablemente bien para sistema cad. por tanto, estimación loc para subsistema interfaz usuario calcula con expresión .. usando mismo enfoque hacen estima-ciones para los grupos subsistemas ingeniería infraestructura. figura . resume las estimaciones indica que tamaño global del cad estima loc. con loc/ como productividad promedio para sistemas este tipo una tarifa mano obra sobrecargada $ por mes, costo por línea código aproximadamen- $. con base estimación caso uso los datos productividad históricos, costo total estimado del proyecto $ esfuerzo estimado persona-meses. .. reconciliación estimaciones las técnicas estimación estudiadas las secciones anteriores dan como resultado estima-ciones múltiples que deben reconciliarse para producir una sola estimación esfuerzo, dura-ción proyecto costo. para ilustrar este procedimiento reconciliación, considere nuevo software cad introducido sección ... esfuerzo total estimado para software cad varía uno bajo persona-meses (- ferido con enfoque estimación basado proceso) uno alto persona-meses (infe-rido con estimación caso uso). estimación promedio (usando los cuatro enfoques) persona-meses. variación estimación promedio aproximadamente por ciento lado bajo por ciento alto. ¿qué ocurre cuando pobre concordancia entre las estimaciones? respuesta esta pregunta requiere una reevaluación información usada para hacer las estimaciones. las estimaciones ampliamente divergentes con frecuencia pueden tener una dos causas: ) ámbito del proyecto entiende adecuadamente planificador malinterpretó ) los datos productividad usados por las técnicas estimación basadas problema son inade-cuadas para aplicación, obsoletos ( reflejan con precisión organización ingeniería software) aplicaron mal. debe determinar causa divergencia luego reconciliar las estimaciones.subsistema interfaz usuario grupo subsistemas ingenieríagrupo subsistemas infraestructura total loc estimadascasos uso estimadas . estimación caso uso cita: “los métodos complicados pue- den producir una estimación más precisa, particular cuan- los desarrolladores pueden incorporar propia intuición estimación.” philip johnson . las herramientas estimación automatizadas permiten planificador estimar costo esfuerzo, realizar análi-sis “... ” para variables proyecto importantes, como fecha entrega personal. aunque existen muchas herramientas automatizadas (vea barra lateral más adelante este capítulo), todas muestran las mismas características generales todas realizan las siguientes seis funciones genéricas [jon]: . dimensionamiento entregas proyecto. estimación del “tamaño” uno más productos operativos software. los información técnicas estimación automatizada para proyectos software (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . odelos estimación empíricos modelo estimación para software computadora usa fórmulas empíricamente inferidas para predecir esfuerzo como una función loc . los valores para loc estiman usando enfoque descrito las secciones .. ... pero lugar usar las tablas descritas dichas secciones, los valores resultantes loc alimentan con modelo estimación. los datos empíricos que soportan mayoría los modelos estimación infieren una muestra limitada proyectos. por esta razón, ningún modelo estimación adecuado para todas las clases software todos los entornos desarrollo. por tanto, deben usar juiciosamente los resultados obtenidos tales modelos. modelo estimación debe calibrarse para que refleje las condiciones locales. modelo debe probarse aplicando los datos recopilados los proyectos completados, alimentando los datos modelo luego comparando los resultados reales con los predichos. con-cordancia pobre, modelo debe afinarse volverse probar antes poder usarse. .. estructura los modelos estimación modelo estimación típico infiere usando análisis regresión sobre los datos recopi-lados proyectos software anteriores. estructura global tales modelos toma forma [mat] / / / ( ) (.) donde , son constantes derivadas empíricamente, esfuerzo persona-meses variable estimación (loc ). además relación anotada ecuación ., mayoría los modelos estimación tienen alguna forma componente ajuste pro-yecto que permite que ajuste mediante otras características del proyecto (por ejemplo, productos operativos incluyen representación externa del soft- ware (por ejemplo, pantalla, reportes), software (por ejemplo, kloc), funcionalidad entregada (por ejemplo, pun-tos función) información descriptiva (por ejemplo, docu-mentos). . selección actividades proyecto. selección del marco con-ceptual proceso adecuado especificación del conjunto tareas ingeniería software. . predicción niveles personal. especificación del número personas que estarán disponibles para hacer trabajo. puesto que relación entre personal disponible trabajo (esfuerzo predicho) enormemente lineal, ésta una entrada impor-tante. . predicción esfuerzo software. las herramientas estima-ción usan uno más modelos (sección .) que relacionan tamaño las entregas del proyecto con esfuerzo requerido para producirlos. . predicción del costo software. dados los resultados del paso , los costos pueden calcularse asignando tarifas mano obra las actividades proyecto anotadas paso . . predicción calendarios software. cuando conocen esfuerzo, nivel personal las actividades del proyecto, puede producirse calendario tentativo para asignar mano obra través las actividades ingeniería software con base modelos recomendados para distribución esfuerzo, que estudia más adelante este capítulo. cuando diferentes herramientas estimación aplican los mis-mos datos proyecto, puede encontrarse una variación relativamen- grande los resultados estimados. más importante, ocasiones, los valores predichos son significativamente diferentes los valores reales. esto refuerza noción que salida las herramientas estimación debe usarse como “punto datos” los cuales derivan estimaciones, como única fuente para una estimación. sección .. sugiere modelo empírico que use casos uso como variable independiente. sin embargo, fecha, literatura han aparecido relativamente pocos.punto clave modelo estimación refleja población proyectos los cuales derivó. por tanto, modelo sensible dominio. (-).indd (-).indd // ::// :: estimación para proyectos software complejidad del problema, experiencia del personal, entorno desarrollo). entre los muchos modelos estimación orientados loc propuestos literatura, están: / . / (kloc). modelo walston-felix / . / . / (kloc). modelo bailey-basili / . / (kloc). modelo boehm simple / . / (kloc). modelo doty para kloc / también han propuesto modelos orientados . ellos incluyen: / /. / . modelo albrecht gaffneye / / / . modelo kemerer / /. / . pequeño modelo regresión proyecto examen rápido dichos modelos indica que cada uno producirá resultado diferente para los mismos valores loc . implicación clara. ¡los modelos estimación deben calibrarse para las necesidades locales! .. modelo cocomo libro clásico acerca “economía ingeniería software”, barry boehm [boe] introdujo una jerarquía modelos estimación software que llevan nombre cocomo, por constructive cost model: modelo constructivo costos. modelo cocomo original convirtió uno los modelos estimación costo más ampliamente utilizados estudia-dos industria. evolucionó hacia modelo estimación más exhaustivo, llamado -como [boe]. como predecesor, cocomo realidad una jerarquía modelos estimación que aborda las áreas siguientes: • modelo composición aplicación. usa durante las primeras etapas ingeniería software, cuando son primordiales elaboración prototipos las interfaces usuario, consideración interacción del software sistema, valoración del rendimiento evaluación madurez tecnología. • modelo etapa temprana diseño. usa una vez estabilizados los requisitos esta-blecida arquitectura básica del software. • modelo etapa postarquitectónica. usa durante construcción del software. como todos los modelos estimación para software, los modelos cocomo requieren información sobre dimensionamiento. como parte jerarquía del modelo, están disponibles tres diferentes opciones dimensionamiento: puntos objeto, puntos función líneas código fuente. modelo composición aplicación cocomo usa puntos objeto ilustra los siguientes párrafos. debe observarse que otros modelos estimación, más sofisticados (que usan kloc), también están disponibles como parte cocomo . como los puntos función, punto objeto una medida software indirecta que calcula usando conteos del número ) pantallas ( interfaz usuario), ) reportes ) ninguno estos modelos debe usarse sin calibración cuidadosa entorno.consejo webref sunset.usc.edu/research/ cocomoii/cocomo_main.html, puede obtenerse información detallada acerca cocomo , incluido software descargable. tipo objeto pantalla reporte componente complejidad simple medio difícil . ponderación complejidad para tipos objeto.fuente: [boe]¿qué punto objeto?? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software componentes que probablemente requieran para construir aplicación. cada instancia objeto (por ejemplo, una pantalla reporte) clasifica uno tres niveles complejidad (simple, medio difícil), usando criterios sugeridos por boehm [boe]. esencia, comple-jidad una función del número fuente las tablas datos cliente servidor que requieren para generar pantalla reporte número vistas secciones que pre-sentan como parte pantalla del reporte. una vez determinada complejidad, número pantallas, reportes componentes ponderan acuerdo con tabla que ilustra figura .. entonces determina con-teo puntos objeto multiplicando número original instancias objeto por factor ponderación que hay figura suman para obtener conteo total puntos objeto. cuando debe aplicarse desarrollo basado componente reuso software general, estima porcentaje reuso (%reuso) conteo puntos objeto ajusta: nop / (puntos objeto) / [( / %reuso)/] donde nop define como nuevos puntos objeto. para derivar una estimación del esfuerzo con base valor nop calculado, debe derivarse una “tasa productividad”. figura . presenta tasa productividad prod / nop persona-mes para diferentes niveles experiencia del desarrollador madurez del entorno desa-rrollo. una vez determinada tasa productividad calcula una estimación del esfuerzo del proyecto usando esfuerzo estimado / nop prod modelos cocomo más avanzados, requieren varios factores escala, controla- dores costo procedimientos ajuste. una discusión completa éstos está más allá del ámbito este libro. tiene más interés, vea [boe] visite sitio web cocomo . .. ecuación del software ecuación del software [put] modelo dinámico multivariable que supone una distribu- ción esfuerzo específica durante vida proyecto desarrollo software. modelo como señaló anteriormente, estos modelos usan conteos kloc para variable tamaño.experiencia/capacidad del desarrollador madurez/capacidad del entorno prodmuy baja muy baja baja nominal alta alta muy alta . tasa productividad para puntos objeto. fuente: [boe]. (-).indd (-).indd // ::// :: estimación para proyectos software infirió partir datos productividad recopilados por más proyectos software contemporáneos. con base dichos datos, infiere modelo estimación forma / loc / . / (.) donde / esfuerzo persona-meses persona-años / duración del proyecto meses años / “factor habilidades especiales” / “parámetro productividad” que refleja: madurez global del proceso prácticas -ministrativas, medida que usan buenas prácticas ingeniería software, nivel lenguajes programación utilizado, estado del entorno software, las habilidades experiencia del equipo software complejidad aplicación. valores típicos pueden ser = para desarrollo software incrustado tiempo real, = para software telecomunicaciones sistemas = para aplicaciones sistemas empresariales. parámetro productividad puede inferirse para condiciones locales, usando datos históricos recopilados esfuerzos desarrollo anteriores. debe observarse que ecuación software tiene dos parámetros independientes: ) una estimación del tamaño ) una indicación duración del proyecto meses años calen-dario. para simplificar proceso estimación usar una forma más común para sus modelos estimación, putnam myers [put] sugieren conjunto ecuaciones derivadas ecua-ción software. tiempo mínimo desarrollo define como mín / . loc . meses para tmín / meses (.) / persona-meses para / persona-meses (.) observe que ecuación . representa años. con ecuación ., para = ( valor recomendado para software científico) para software cad que estudió anteriormente este capítulo, tmín / . / . / . meses calendario / / . / (.) / persona-meses los resultados ecuación software corresponden favorablemente con las estimaciones desarrolladas sección .. como modelo cocomo anotado sección .., ecuación software sigue evolucionando. análisis más fondo una versión extendida este enfoque estimación puede encontrarse [put]. . stimación para proyectos orientados objetos vale pena complementar los métodos estimación costo software convencional con una técnica que diseñó explícitamente para software . lorenz kidd [lor] sugieren siguiente enfoque: aumenta lentamente conforme “crecen necesidad para integración, pruebas, aseguramiento calidad, documentación habilidades administrativas” [put]. para programas pequeños (kloc = ), = .. para programas mayores kloc, = ..webref puede encontrarse información acerca herramientas estimación costo software que evolucionaron partir ecuación software. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . desarrollar estimaciones usando descomposición esfuerzo, análisis cualquier otro método que sea aplicable para aplicaciones con vencionales. . usar modelo requisitos (capítulo ), desarrollar casos uso determinar con- teo. reconocer que número casos uso puede cambiar conforme avance pro- yecto. . partir del modelo requisitos, determinar número clases clave (llamadas cla- ses análisis capítulo ). . categorizar tipo interfaz para aplicación desarrollar multiplicador para cla- ses apoyo: tipo interfaz multiplicador gui . interfaz usuario basada texto . gui . compleja . multiplique número clases clave (paso ) por multiplicador fin obtener una estimación para número clases apoyo. . multiplicar número total clases (clave + apoyo) por número promedio unida- des trabajo por clase. lorenz kidd sugieren persona-días por clase. . comprobación cruzada estimación basada clase, multiplicando número pro- medio unidades trabajo por caso uso. . écnicas estimación especializadas las técnicas estimación estudiadas las secciones . . pueden usarse para cualquier proyecto software. sin embargo, cuando equipo software encuentra una duración proyecto extremadamente corta (semanas lugar meses) que probable tener torrente continuo cambios, planificación del proyecto general estimación par-ticular deben abreviarse. las siguientes secciones examinan dos técnicas estimación especializadas. .. estimación para desarrollo ágil puesto que los requisitos para proyecto ágil (capítulo ) definen mediante conjunto escenarios usuario (por ejemplo, “historias” programación extrema), posible desarrollar enfoque estimación que sea informal, razonablemente disciplinado significativo dentro del contexto planificación del proyecto para cada incremento software. estimación para proyectos ágiles usa enfoque descomposición que abarca los siguientes pasos: . cada escenario usuario ( equivalente minicaso uso creado comienzo mismo proyecto por los usuarios finales otros participantes) considera por separado con propósitos estimación. . escenario descompone conjunto tareas ingeniería software que será necesario desarrollar . “abreviar” significa eliminar. incluso los proyectos corta duración deben planificarse, estimación cimiento planificación sólida.¿cómo desarrollan las estimaciones cuando aplica proceso ágil?? (-).indd (-).indd // ::// :: estimación para proyectos software . esfuerzo requerido por cada tarea estima por separado. nota: estimación puede basarse datos históricos, modelo empírico “experiencia”. . manera alternativa, “volumen” del escenario puede estimarse loc, alguna otra medida orientada volumen (por ejemplo, conteo casos uso). . las estimaciones para cada tarea suman fin crear una estimación para esce- nario. . manera alternativa, estimación volumen para escenario traduce - fuerzo, usando datos históricos. . las estimaciones esfuerzo para todos los escenarios que implementan para - cremento software determinado suman fin desarrollar estimación del - fuerzo para incremento. puesto que duración del proyecto requerido para desarrollo incremento software muy corta (por general tres seis semanas), este enfoque estimación tiene dos pro-pósitos: ) asegurarse que número escenarios que van incluir incremento ajusta los recursos disponibles ) establecer una base para asignar esfuerzo conforme desarrolla incremento. .. estimación para webapp los webapps adoptan con frecuencia modelo proceso ágil. puede usarse una medida punto función modificada, junto con los pasos que destacan sección .., fin desarrollar una estimación para webapp. roetzheim [roe] sugiere siguiente enfoque cuando adapta puntos función para estimación webapps: • entradas son cada pantalla formulario entrada (por ejemplo, cgi java), cada pantalla man- tenimiento , usa una metáfora etiquetas libreta, cualquier etiqueta. • salidas son cada página web estática, cada guión página web dinámica (por ejemplo, asp, isapi otro guión dhtml) cada reporte ( sea basado web administrativo por naturaleza). • tablas son cada tabla lógica base datos más, usa xml para almacenar datos archivo, cada objeto xml ( colección atributos xml). • las interfaces conservan definición como archivos lógicos (por ejemplo, formatos registro único) dentro las fronteras del sistema. • consultas son cada una las publicaciones externas uso una interfaz orientada mensaje. ejemplo usual son las referencias externas dcom com. los puntos función (interpretados forma señalada) son indicador razonable - lumen para una webapp. mendes . [men] sugieren que volumen una webapp determina mejor reco- lectar medidas (llamadas “variables predictoras”) asociadas con aplicación (por ejemplo, conteo página, conteo medios, conteo función), características página web (por ejemplo, complejidad página, complejidad vinculación, complejidad gráfica), característi-cas medios (por ejemplo, duración los medios) características funcionales (por ejemplo, longitud código, longitud código reutilizado). dichas medidas pueden usarse para desa-rrollar modelos estimación empíricos para esfuerzo proyecto total, esfuerzo autoría página, esfuerzo autoría medios esfuerzo guiones. sin embargo, todavía falta trabajo por hacer antes que tales modelos puedan usarse con confianza.punto clave contexto estimación para proyectos ágiles, “volumen” una estimación del tamaño global escenario usuario loc . (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . decisión hacer /comprar muchas áreas aplicación, con frecuencia más efectivo costo adquirir, lugar desarrollar, software computadora. los gerentes ingeniería software enfrentan decisión hacer/comprar que puede complicarse todavía más por algunas opciones adquisi-ción: ) software puede comprarse ( licenciarse) manera comercial, ) los componentes software “experiencia completa” “experiencia parcial” (vea sección ..) pueden adquirirse luego modificarse integrarse para satisfacer necesidades específicas ) soft-ware puede construirse medida por parte contratista externo para satisfacer las espe-cificaciones del comprador. los pasos involucrados adquisición del software definen por crucial del software que comprar por costo final. algunos casos (por ejemplo, software bajo costo), menos costoso comprar experimentar que realizar una larga evaluación poten-ciales paquetes software. análisis final, decisión hacer/comprar toma con base las siguientes condiciones: ) ¿ fecha entrega del producto software será más próxima que del software que desarrolle internamente? ) ¿ costo adquisición más costo personalización será menor que costo que implica desarrollar software internamente? ) ¿ costo del apoyo exterior (por ejemplo, contrato mantenimiento) será menor que costo del apoyo interno? estas condiciones aplican para cada una las opciones adqui-sición. las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus res- pectivos desarrolladores.objetivo: objetivo las herramientas estimación esfuerzo costo brindar equipo proyecto estimaciones del esfuerzo requerido, duración del proyecto costo, manera que aborde las características específicas del proyecto mano entorno donde construirá proyecto. mecánica: general, las herramientas estimación costo usan una base datos histórica inferida proyectos locales datos recopilados través industria, modelo empírico (por ejem-plo, cocomo ) que utiliza para derivar estimaciones esfuer-, duración costo. las características del proyecto entorno desarrollo son entradas herramienta proporciona rango salidas estimación. herramientas representativas: costar, desarrollada por softstar systems ( com), usa modelo cocomo para desarrollar estimaciones software. costxpert, desarrollada por cost xpert group, inc. ( pert.com) integra múltiples modelos estimación una base datos histórica proyectos.estimate professional, desarrollada por software productivity cen- tre, inc. ( basa cocomo modelo slim. knowledge plan, desarrollado por software productivity research ( usa entrada puntos función como principal controlador para paquete estimación completo. price , desarrollada por price systems ( com), una las herramientas estimación más antiguas más uso para proyectos desarrollo software gran escala. seer/sem, desarrollada por galorath, inc. ( com), proporciona una amplia capacidad estimación, análisis sensibilidad, valoración riesgo otras características. slim-estimate, desarrollada por qsm ( apoya una exhaustiva “base conocimiento industrial” para propor-cionar una “comprobación sanidad” para estimaciones que infieren usando datos locales.herramientas software estimaciones esfuerzo costo (-).indd (-).indd // ::// :: estimación para proyectos software .. creación árbol decisión los pasos recién descritos pueden aumentar usando técnicas estadísticas como análisis árbol decisión. por ejemplo, figura . muestra árbol decisión para sistema basado software. este caso, organización ingeniería software puede: ) construir sistema desde cero, ) reusar componentes experiencia parcial existentes para cons-truir sistema, ) comprar producto software disponible modificarlo para satisfacer las necesidades locales ) contratar desarrollo del software proveedor externo. sistema construirá desde cero, hay una probabilidad por ciento que trabajo será difícil. usar las técnicas estimación estudiadas este capítulo, planificador proyecto estima que esfuerzo desarrollo difícil costará $ . esfuerzo desa-rrollo “simple” estima que cuesta $ . valor esperado por costo, calculado largo cualquier rama del árbol decisión, costo esperado / / (probabilidad ruta) / (costo ruta estimado) donde ruta del árbol decisión. para ruta construcción, costo esperadoconstruir / . ($) / . ($) / $ siguiendo otras rutas del árbol decisión, también muestran los costos proyectos para reúso, compra contrato, bajo varias circunstancias. los costos esperados para dichas rutas son costo esperado reuso / . ($) / . [. ($) / . ($)] / $ costo esperadocomprar / . ($) / . ($) / $ costo esperadocontratar / . ($) / . ($) / $ con base probabilidad los costos proyectados que anotaron figura ., costo esperado más bajo opción “comprar”. sin embargo, importante observar que deben considerarse muchos criterios, sólo costo, durante proceso toma decisión. disponibilidad, experiencia del desarrollador/¿existe alguna manera sistemática recorrer las opciones asociadas con decisión hacer/comprar??$ $ (.) $ $ $ $ $ menores (.) cambios mayores (.) $ $ cambios (.) con cambios (.)complejo (.)simple (.) cambios mayores (.)cambios menores (.)difícil (.) construir reusar comprar contratarsistema xfigura . árbol decisiones para apoyar decisión hacer/comprar una valiosa introducción análisis del árbol decisiones puede encontrarse http://.wikipedia.org/ wiki/decision_tree (-).indd (-).indd // ::// :: parte cuatro administración proyectos software proveedor/contratista, conformidad con los requisitos, “políticas” locales probabilidad cambiar son sólo algunos los criterios que pueden afectar decisión final construir, -usar, comprar contratar. .. outsourcing tarde temprano, toda compañía que desarrolla software computadora plantea una pre-gunta fundamental: ¿hay alguna forma que puedan conseguirse software los sistemas necesarios precio más bajo? respuesta esta pregunta simple las discusiones emocionales que ocurren respuesta pregunta siempre conducen una sola palabra: outsourcing. como concepto, outsourcing ( subcontratación) extremadamente simple. las activida- des ingeniería software contratan una tercera parte, que hace trabajo costo más bajo , con poco suerte, con mayor calidad. trabajo software realizado dentro una compañía reduce una actividad administración contrato. decisión por outsourcing puede ser estratégica táctica. nivel estratégico, los - rentes empresariales consideran una porción significativa todo trabajo software puede contratarse otros. nivel táctico, gerente proyecto determina parte todo proyecto puede lograrse mejor subcontratar trabajo software. sin importar amplitud del enfoque, decisión outsourcing con frecuencia financiera. estudio detallado del análisis financiero para outsourcing está más allá del ámbito este libro mejor deja otros (por ejemplo, [min]). sin embargo, vale pena una breve revisión los pros los contras decisión. lado positivo, ahorro costo usualmente puede lograrse reduciendo número personal software las instalaciones (por ejemplo, computadoras, infraestructura) que apoyan. lado negativo, una compañía pierde cierto control sobre software que necesita. dado que software una tecnología que diferencia sus sistemas, servicios productos, una compañía corre riesgo poner competitividad las manos una tercera per-sona. tendencia hacia outsourcing indudablemente continuará. única forma detenerla reconocer que trabajo software extremadamente competitivo todos los niveles. única manera sobrevivir volverse tan competitivo como los mismos proveedores outsourcing. outsourcing puede verse manera más general como cualquier actividad que conduce adquisición del software los componentes software desde una fuente externa organización ingeniería soft- ware.cita: “como regla, outsourcing requiere una administración incluso más habilidosa que desarrollo casa.” steve mcconnell escena: sala juntas cpi corporation, cuando proyecto comienza. participantes: mal golden, gerente ejecutivo, desarrollo pro-ducto; lee warren, gerente ingeniería; joe camalleri, ejecuti-, desarrollo empresarial; doug miller, gerente proyecto, inge-niería software. conversación: joe: estamos considerando subcontratación porción ingeniería software del producto casasegura. doug (consternado): ¿cuándo pasó esto?lee: conseguimos una cotización desarrollador exter- . viene con por ciento por abajo que grupo pare-casasegura outsourcing (-).indd (-).indd // ::// :: estimación para proyectos software . esumen planificador proyecto software debe estimar tres cosas antes comenzar proyecto: cuánto tardará, cuánto esfuerzo requerirá cuántas personas involucrarán. además, planificador debe predecir los recursos (hardware software) que requerirán riesgo -volucrado. enunciado del ámbito ayuda planificador desarrollar estimaciones usando una más técnicas que clasifican dos amplias categorías: descomposición modelado empírico. las técnicas descomposición requieren una delineación las principales funciones del soft-ware, seguidas por estimaciones : ) número loc, ) valores seleccionados dentro del dominio información, ) número casos uso, ) número persona-meses reque-ridos para implementar cada función ) número persona-meses requeridos para cada actividad ingeniería software. las técnicas empíricas usan expresiones derivadas empíri-camente para esfuerzo tiempo fin predecir dichas cantidades proyecto. las herramien-tas automatizadas pueden usarse para implementar modelo empírico específico. las estimaciones proyecto precisas por general usan menos dos las tres técnicas recién anotadas. comparar reconciliar las estimaciones desarrolladas usando diferentes técnicas, planificador tiene más probabilidad derivar una estimación precisa. estima-ción proyecto software nunca puede ser una ciencia exacta, pero una combinación buenos datos históricos técnicas sistemáticas pueden mejorar precisión estimación. problemas puntos por evaluar .. suponga que usted gerente proyecto una compañía que construye software para robots caseros. contrata fin construir software para robot que pode césped para propietario cree que costará. vélo. [extiende cotización doug, quien lee.] mal: como sabes, doug, intentamos mantener bajos los costos por ciento por ciento. además, estas personas vienen muy recomendadas. doug (toma respiro intenta permanecer tranquilo): tomaron por sorpresa, pero antes que tomen una decisión final, ¿puedo comentar algo? joe (afirma con cabeza): claro, adelante.doug: hemos trabajado con esta compañía outsourcing, ¿cierto? mal: , pero...doug: señalan que cualquier cambio las especificaciones facturará con una tarifa adicional, ¿cierto? joe (frunce ceño): cierto, pero esperamos que las cosas serán razonablemente estables. doug: mala suposición, joe.joe: bueno...doug: probable que liberemos nuevas versiones este producto dentro algunos años. razonable suponer que software pro-porcionará muchas las nuevas características, ¿cierto? [todos afirman con cabeza.]doug: ¿alguna vez hemos coordinado proyecto internacional? lee (observa preocupado): , pero dijeron...doug (intenta contener enojo): así que que están diciendo : ) estamos punto trabajar con proveedor desco- nocido, ) los costos por hacer esto son tan bajos como parecen, ) nos comprometemos facto para trabajar con ellos durante muchas liberaciones producto, sin importar que hagan pri- mera vez ) vamos aprender sobre marcha relativo proyecto internacional. [todos permanecen silencio.]doug: chicos... creo que éste error, gustaría que reconsideraran durante día. tenemos mucho más control hace- mos trabajo casa. tenemos experiencia puedo garantizar-les que quiero que nos cueste mucho más... riesgo será más bajo que ustedes tienen aversión riesgo, como . joe (frunce ceño): hiciste buenas observaciones, pero tienes interés personal para mantener este proyecto casa. doug: verdad, pero eso cambia los hechos. joe (suspira): está bien, consideremos esto durante día dos; pensaremos poco más nos reuniremos nuevo para una decisión final. doug, ¿puedo hablar contigo privado? doug: seguro... realmente quiero estar seguro que hacemos correcto. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software una casa. escriba enunciado para ámbito que describa software. asegúrese que enunciado ámbito esté acotado. está familiarizado con los robots, haga poco investigación antes comen-zar escribirlo. además, establezca sus suposiciones acerca del hardware que requerirá. alternativa: sustituya robot podadora con otro problema que sea interés. .. complejidad del proyecto software analiza brevemente sección .. elabore una lista características software (por ejemplo, operación concurrente, salida gráfica) que afecten compleji-dad proyecto. priorice lista. .. rendimiento una importante consideración durante planificación. analice cómo puede inter- pretarse manera diferente rendimiento, dependiendo del área aplicación del software. .. haga una descomposición funcional del software robot que describió problema .. estime tamaño cada función loc. supone que organización produce loc/ con una tarifa mano obra sobrecargada $ por persona-mes, estime esfuerzo costo requeridos para construir software, usando técnica estimación basada loc descrita este capítulo. .. use modelo cocomo para estimar esfuerzo requerido para construir software para simple atm que produce pantallas, reportes que requerirá aproximadamente componentes software. suponga complejidad promedio madurez desarrollador/entorno promedio. use modelo composición aplicación con puntos objeto. .. use ecuación software para estimar software del robot podadora. suponga que ecuación . aplicable que = . .. compare las estimaciones esfuerzo inferidas los problemas . .. ¿cuál desviación estándar cómo afecta esto grado certidumbre acerca estimación? .. usando los resultados obtenidos problema ., determine razonable esperar que soft- ware pueda construirse dentro los siguientes seis meses cuántas personas tendrían que emplearse para realizar trabajo. .. desarrolle modelo hoja cálculo que implemente una más las técnicas estimación descritas este capítulo. manera alternativa, adquiera uno más modelos línea para estimación fuentes web. .. para equipo proyecto: desarrolle una herramienta software que implemente cada una las técnicas estimación desarrolladas este capítulo. .. parece extraño que las estimaciones costo calendario desarrollen durante planificación del proyecto software, antes del análisis detallado los requisitos software realizar diseño. ¿por qué cree que haga esto? ¿existen circunstancias para hacerlo? .. vuelva calcular los valores esperados que anotaron para árbol decisión figura . suponga que cada rama tiene una probabilidad -. ¿esto cambiaría decisión final? lecturas fuentes información adicionales mayoría los libros administración proyectos software contienen análisis acerca estima-ción del proyecto. the project management institute (pmbok guide, pmi, ), wysoki . (effective project management, wiley, ), lewis (project planning scheduling and control, . ., mcgraw-hill, ), ben- natan ( time, within budget: software project management practices and techniques, . ., wiley, ) phillips [phi] proporcionan útiles lineamientos estimación. mcconnell (software estimation: demystifying the black art, microsoft press, ) escribió una guía prag- mática que proporciona valiosos lineamientos para todos aquellos que deban estimar costo del software. parthasarathy ( practical software estimation, addison-wesley, ) enfatiza los puntos función como una métrica estimación. laird brennan (software measurement and estimation: practical approach , wiley- ieee computer society press, ) aborda las mediciones uso estimación del software. pfleeger (software cost estimation and sizing methods, issues, and guidelines , rand corporation, ) desarrolló manual abreviado que aborda muchos fundamentos estimación. jones ( estimating software costs, . ., mcgraw-hill, ) escribió uno los tratamientos más exhaustivos los modelos los datos que son aplicables estimación del software todo dominio aplicación. coombs ( project estimation, cam-bridge university press, ) roetzheim beasley (software project cost and schedule estimating: best (-).indd (-).indd // ::// :: estimación para proyectos software practices, prentice-hall, ) presentan muchos modelos útiles sugieren lineamientos, paso paso, para generar las mejores estimaciones posibles. internet, está disponible una gran variedad fuentes información acerca estimación del software. una lista actualizada referencias world wide web que son relevantes para estimación del software puede encontrarse sitio del libro: fessional/olc/ser.htm (-).indd (-).indd // ::// :: del proyecto conceptos clave cronogramas. . . . . . . . . . . . distribución esfuerzo. . . . del trabajo . . . . esfuerzo. . . . . . . calendarización para webapps. . . . . . . . . . . red tareas . . . . . . . . . . . crítica . . . . . . . . . . . . . . . . . . . . . . . . . -boxing . . . . . . . . . . . . ganado . . . . . . . . . . . ¿qué ? seleccionó modelo proce- adecuado, identificó las tareas ingeniería software que deben realizarse, estimó cantidad trabajo número personas, conoce fecha límite incluso consideró los riesgos. ahora momento unir los puntos. decir, tiene que crear una red tareas ingeniería software que permitirán concluir trabajo tiempo. una vez creada red, tiene que asignar responsables para cada tarea, ase-gurarse que realizan todas ellas adaptar red conforme los riesgos que habrá cuando convierta realidad. pocas palabras, eso calendarización seguimiento del proyecto software. ¿quién hace? nivel del proyecto, los gerentes proyecto software que usan información solicitada los ingenieros software. individual, los mismos ingenieros software. ¿por qué importante? para construir sistema com- plejo, muchas tareas ingeniería software ocurren paralelo, resultado del trabajo realizado durante una tarea puede tener profundo efecto sobre trabajo que realizar otra tarea. estas interdependencias son muy difíciles comprender sin calendario. también virtualmente imposible valorar avance proyecto software regular grande sin calendario detallado. ¿cuáles son los pasos? las tareas ingeniería soft- ware dictadas por modelo proceso del software refinan función funcionalidad que cons-truir. asigna esfuerzo duración determinados cada tarea crea una red tareas (también llamada “red actividad”) manera que permita equipo soft-ware alcanzar fecha entrega establecida. ¿cuál producto final? produce calendario del proyecto información relacionada. ¿cómo aseguro que hice bien? calenda- rización adecuada requiere que: ) todas las tareas apa-rezcan red, ) esfuerzo calendarización asignen manera inteligente cada tarea, ) las interde-pendencias entre tareas indiquen manera adecuada, ) asignen los recursos para trabajo que realizar ) proporcionen hitos cercanamente espacia-dos modo que pueda darse seguimiento progreso. una mirada rápidaafinales los años sesenta del siglo pasado, eligió entusiasta joven ingeniero para que “escribiera” programa computadora para una aplicación fabricación automatizada. razón para selección fue simple. era única persona grupo técnico que asistió seminario programación computadoras. sabía los pros los contras del lenguaje ensamblador fortran, pero nada conocía acerca ingeniería software incluso menos acerca calendarización seguimiento proyectos. jefe dio los manuales apropiados una descripción verbal que tenía que hacer. informó que proyecto debía estar terminado dos meses. leyó los manuales, consideró enfoque comenzó escribir código. después dos semanas, jefe llamó oficina preguntó sobre cómo iban las cosas. “realmente grandiosas”, dijo ingeniero con entusiasmo juvenil. “esto fue mucho más sim- ple que pensé. probablemente tenga avance por ciento”. jefe sonrió alentó joven ingeniero seguir con buen trabajo. planearon reunirse nuevo una semana. una semana después, jefe llamó ingeniero oficina preguntó: “¿dónde esta- mos?” “todo está bien”, dijo joven, “pero encontré algunos tropiezos. los allanaré pronto estaré vuelta camino”. “¿qué parece fecha límite?”, preguntó jefe.“ hay problema”, dijo ingeniero. “tengo avance cerca por ciento”. (-).indd (-).indd // ::// :: calendarización del proyecto lector trabajado mundo del software durante algunos años, puede terminar historia. sorprender que joven ingeniero quedara por ciento avance durante todo proyecto terminara (con ayuda otros) sólo mes más tarde. esta historia repetido decenas miles veces entre los desarrolladores software durante las pasadas cinco décadas. gran pregunta por qué. . onceptos básicos aunque existen muchas razones por las que software entrega tardíamente, mayoría pueden rastrearse una más las siguientes causas fundamentales: • una fecha límite irreal establecida por alguien externo equipo software que fuerza los gerentes profesionales. • requerimientos del cliente variables que reflejan cambios del calendario. • una honesta subestimación cantidad esfuerzo / número recursos que requerirán para hacer trabajo. • riesgos predecibles / impredecibles que consideraron cuando comenzó proyecto. • dificultades humanas que podían preverse por anticipado. • falta comunicación entre personal del proyecto que como resultado demoras. • falta comunicación entre equipo trabajo que traduce retrasos. • una falla por parte administración del proyecto para reconocer que proyecto tiene retrasos calendario una falta acción para corregir problema. las fechas límite agresivas (léase “irreales”) son hecho vida negocio del soft- ware. ocasiones, tales fechas límite demandan por razones legítimas, desde punto vista persona que las establece. pero sentido común dice que legitimidad también debe percibirla personal que hace trabajo. napoleón dijo una vez: “cualquier comandante que comprometa llevar cabo plan que considere defectuoso está equivocado; debe plantear sus razones, insistir que cambie plan finalmente ofrecer formalmente renuncia lugar ser instrumento derrota ejército”. éstas son duras palabras que muchos gerentes proyecto software deberían ponderar. las actividades estimación estudiadas capítulo las técnicas calendarización descritas este capítulo con frecuencia implementan bajo restricción una fecha límite definida. las mejores estimaciones indican que fecha límite irreal, gerente proyecto competente debe “proteger equipo contra presión excesiva [calendario]... [] devolver presión quienes originaron” [pag]. para ilustrar anterior, suponga que equipo software pide construir contro- lador tiempo real para instrumento diagnóstico médico que debe introducirse mercado nueve meses. después realizar estimación análisis riesgo cuidado-samente (capítulo ), llega conclusión que software, como solicitó, requerirá meses para creación con personal que tiene disponible. ¿cómo procedería? irreal marchar hacia oficina del cliente ( este caso probable cliente mercadotec- nia/ventas) demandar que cambie fecha entrega. las presiones del mercado externo dictaron fecha producto debe liberarse. igualmente temerario rechazar compromiso realizar trabajo (desde punto vista profesional). modo que, ¿qué hacer? ante esta situación, los autores recomiendan los siguientes pasos: caso que lector pregunte, esta historia autobiográfica.cita: “los calendarios excesivos irracionales son probablemente influencia más destructiva todo software.” capers jones cita: “ encantan las fechas límite. gusta zumbido que produ-cen cuando pasan volando.” douglas adams (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . realice una estimación detallada, usando datos históricos proyectos anteriores. - termine esfuerzo duración estimados para proyecto. . con modelo proceso incremental (capítulo ), desarrolle una estrategia ingenie- ría software que entregue funcionalidad crucial hacia fecha límite impuesta, pero desarrolle otra estrategia para otra entrega software con funcionalidad hasta más tarde. documente plan. . reúnase con cliente (con estimación detallada) explique por qué fecha límite irreal. asegúrese señalar que todas las estimaciones basan rendimiento proyectos anteriores. ambién asegúrese indicar porcentaje mejora que requeriría para lograr cumplir fecha límite, como plantea originalmente. - guiente comentario puede ser apropiado como respuesta: creo que podemos tener problemas con fecha entrega para software controlador xyz. cada uno ustedes entrego una distribución abreviada las tasas desarrollo para proyec-tos software anteriores una estimación que hizo maneras distintas. observarán que supuse una mejora por ciento tasas desarrollo anteriores, pero todavía tenemos una fecha entrega que meses lugar nueve. . ofrezca estrategia desarrollo incremental como una alternativa: tenemos algunas opciones, gustaría que tomaran una decisión con base ellas. primero, podemos aumentar presupuesto conseguir recursos adicionales, modo que podremos tener listo este trabajo nueve meses. pero entiendo que esto aumentará riesgo empobrecer calidad debido las fechas tan apretadas. segundo, podemos remover algunas funciones capa- cidades del software que solicitan. esto hará que versión preliminar del producto sea poco menos funcional, pero puede anunciarse toda funcionalidad entregarla durante periodo meses. tercero, podemos prescindir realidad querer que proyecto esté completo nueve meses. acabaremos sin tener algo que pueda entregarse cliente. tercera opción, creo que estarán acuerdo, inaceptable. historia pasada nuestras mejores estimaciones -cen que irreal que representa una receta para desastre. habrá algunos gruñidos, pero presenta una estimación sólida con base buenos datos históricos, probable que elijan las versiones negociadas las opciones . fecha límite irreal evapora. . alendarización del proyecto alguna vez preguntó fred brooks cómo que los proyectos software atrasan calendario. respuesta fue tan simple como profunda: “ día vez”. realidad proyecto técnico ( sea que implique construir una hidroeléctrica desa- rrollar sistema operativo) que cientos pequeñas tareas deben ocurrir para lograr una meta más grande. algunas esas tareas yacen fuera corriente principal pueden com-pletarse sin preocuparse acerca impacto sobre fecha conclusión del proyecto. otras encuentran “ruta crítica”. las tareas “críticas” retrasan calendario, fecha conclusión todo proyecto pone riesgo. como gerente proyecto, objetivo definir todas las tareas del proyecto, construir una red que muestre sus interdependencias, identificar las que son cruciales dentro red luego monitorear progreso para asegurar que demora reconoce “ momento”. para lograr mejora requerida por ciento, realidad puede tener listo trabajo. pero, muy probablemente, mejora requerida rendimiento del equipo será mayor por ciento. ésta una expectativa irreal. también puede argumentar que aumentar número personas reduce tiempo manera proporcional.¿qué debe hacer cuando los gerentes demandan una fecha límite que imposible cumplir?? las tareas requeridas para lograr objetivo gerente proyecto deben realizarse manualmente. existen muchas excelentes herramientas calendarización. úselas.consejo (-).indd (-).indd // ::// :: calendarización del proyecto esto, debe tener calendario que haya definido grado resolución que permita - nitorear progreso controlar proyecto. calendarización del proyecto software una acción que distribuye esfuerzo estimado través duración planificada del proyecto, asignando esfuerzo tareas específicas ingeniería del software. sin embargo, importante observar que calendario evoluciona con tiempo. durante las primeras etapas planificación del proyecto desarrolla calen-dario macroscópico. este tipo calendario identifica las principales actividades marco conceptual proceso las funciones producto las cuales aplican. conforme proyecto avanza, cada entrada calendario macroscópico desglosa calendario detallado. aquí, acciones tareas software específicas (requeridas para lograr una actividad) identi-fican calendarizan. calendarización para proyectos ingeniería software puede verse desde dos perspec- tivas más bien diferentes. primera, estableció una fecha final ( irrevocable) para liberar sistema basado computadora. organización software restringe para dis-tribuir esfuerzo dentro del marco temporal prescrito. segunda visión calendarización del software supone que han discutido límites cronológicos burdos, pero que fecha final establece organización ingeniería del software. esfuerzo distribuye para hacer mejor uso los recursos define una fecha final después cuidadoso análisis del software. por desgracia, primera situación encuentra con mucha más frecuencia que segunda. .. principios básicos como otras áreas ingeniería software, algunos principios básicos guían calendariza-ción del proyecto software: compartimentalización. proyecto debe compartimentalizarse algunas actividades - reas manejables. para lograr compartimentalización desglosan tanto producto como proceso. interdependencia. debe determinarse interdependencia cada actividad tarea com- partimentalizada. algunas tareas deben sucederse secuencia, mientras que otras pueden ocurrir paralelo. algunas actividades pueden comenzar hasta que esté disponible producto operativo producido por otra. otras pueden realizarse manera independiente. asignación tiempo. cada tarea por calendarizar debe asignársele cierto número unidades trabajo (por ejemplo, persona-días esfuerzo). además, cada tarea debe asignársele una fecha comienzo una conclusión, función las interdependencias trabajo realizará sobre una base tiempo completo parcial. validación esfuerzo. todo proyecto tiene número definido personas equipo software. conforme ocurre asignación tiempo, debe asegurarse que, momento determinado, calendarizado más que número personal asignado. por ejemplo, considere proyecto que tiene tres ingenieros software asignados (tres personas-días -tán disponibles por día esfuerzo asignado ). día determinado deben lograrse siete - reas concurrentes. cada tarea requiere . persona-días esfuerzo. hay más esfuerzo por asignar que personas disponibles para hacer trabajo. responsabilidades definidas. cada tarea por calendarizar debe asignarse miembro equipo específico.cita: “ calendarización demasiado optimista como resultado calendarios reales más cortos; como resultado unos más largos.” steve mcconnell punto clave cuando desarrolle calendario, divida trabajo, anote las interdependencias entre tareas, asigne esfuerzo tiempo cada tarea, defina responsabilidades, resultados hitos. realidad, están disponibles menos tres personas-días esfuerzo debido juntas relacionadas, enfer- medad, vacaciones varias otras razones. sin embargo, para nuestros propósitos, supone por ciento disponibilidad. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software resultados definidos. cada tarea que calendarice debe tener resultado definido. para proyectos software, resultado usualmente producto operativo (por ejemplo, - seño componente) una parte producto operativo. los productos operativos con frecuencia combinan con productos operativos entregables. hitos definidos. cada tarea grupo tareas debe asociarse con hito del proyecto. hito logra cuando uno más productos operativos revisan calidad (capítulo ) aprueban. cada uno estos principios aplica conforme evoluciona calendario del proyecto. .. relación entre personal esfuerzo pequeño proyecto desarrollo software, una sola persona puede analizar requeri- mientos, elaborar diseño, generar código realizar pruebas. conforme tamaño proyecto aumenta, más personas deben involucrarse. (¡rara vez uno puede darse lujo abordar esfuerzo persona-años con una persona que trabaje durante años!). existe mito común que todavía creen muchos gerentes responsables proyectos - sarrollo software: “ nos atrasamos calendario, siempre podemos agregar más progra-madores ponernos corriente proyecto más adelante”. por desgracia, agregar personal tardíamente proyecto con frecuencia tiene efectos perturbadores sobre proyecto, que hace que calendario deteriore todavía más. las personas que agregan deben aprender sistema las que les enseñan son las mismas personas que hacían trabajo. mientras ense-ñan trabajan proyecto atrasa aún más. además del tiempo que tardan aprender sistema, más personas aumentan número rutas comunicación complejidad comunicación largo proyecto. aun-que comunicación absolutamente esencial para desarrollo software exitoso, toda nueva ruta comunicación requiere esfuerzo adicional , por tanto, tiempo adicional. con los años, los datos empíricos análisis teórico han demostrado que los calendarios proyecto son elásticos. decir: posible comprimir cierta medida fecha conclusión proyecto deseado ( agregar recursos adicionales). también extender una fecha conclusión ( reducir número recursos). curva putnam-norden-rayleigh (pnr) proporciona indicio relación entre esfuerzo aplicado tiempo entrega para proyecto software. figura . muestra una costo del esfuerzo edea = (/) tiempo desarrollo tmín = . imposibleea = esfuerzo persona-meses = tiempo entrega nominal para calendario = tiempo desarrollo óptimo ( términos costo) = tiempo entrega real deseadofigura . relación entre esfuerzo tiempo entregasi debe agregar personal proyecto retrasado, asegúrese que les asigna trabajo que esté muy compartimentalizado.consejo investigación original puede encontrarse [nor] [put]. (-).indd (-).indd // ::// :: calendarización del proyecto versión curva, que representa esfuerzo del proyecto como función del tiempo entrega. curva indica valor mínimo que señala costo mínimo para entrega ( decir, tiempo entrega que resultará menor esfuerzo empleado). conforme avanza hacia izquierda ( decir, conforme intenta acelerar entrega), curva eleva manera lineal. como ejemplo, suponga que equipo proyecto estimó que requerirá nivel - fuerzo para lograr tiempo entrega nominal que óptimo términos calendario recursos disponibles. aunque posible acelerar entrega, curva eleva manera muy pronunciada hacia izquierda . hecho, curva pnr indica que tiempo entrega del proyecto puede comprimirse mucho más allá .. intenta mayor compresión, proyecto mueve hacia “región imposible” riesgo fracaso vuelve muy alto. curva pnr también indica opción entrega costo más bajo, = . que observa aquí que entrega demorada del proyecto puede reducir los costos significativamente. desde luego, esto debe ponderarse contra costo empresarial asociado con demora. ecuación software [put] que introdujo capítulo infirió partir curva pnr demuestra relación enormemente lineal entre tiempo cronológico para completar proyecto esfuerzo humano que aplica mismo. número líneas código entre-gadas (enunciados fuente), , relaciona con esfuerzo tiempo desarrollo mediante ecuación: / / // donde esfuerzo desarrollo persona-meses, parámetro productividad que refleja varios factores que conducen trabajo ingeniería software alta calidad (por general valores que varían entre ) duración del proyecto meses calendario. reordenar esta ecuación software puede llegarse una expresión para esfuerzo desarrollo : / (.) donde esfuerzo empleado ( persona-años) durante todo ciclo vida para desa- rrollo mantenimiento del software tiempo desarrollo años. ecuación para esfuerzo desarrollo puede relacionarse con costo desarrollo mediante inclusión factor tarifa mano obra sobrecargada ($/persona-año). esto conduce algunos resultados interesantes. considere complejo proyecto software tiempo real estimado loc, persona-años esfuerzo. ocho personas asig-nan equipo del proyecto, éste puede completarse aproximadamente . años. sin -bargo, fecha final extiende . años; naturaleza enormemente lineal del modelo descrito ecuación . produce: / ~ . persona-años esto implica que, extender fecha final por seis meses, ¡ posible reducir número personas ocho cuatro! validez tales resultados está abierta debate, pero implica-ción clara: pueden obtenerse beneficios usando menos personal durante lapso poco más largo para lograr mismo objetivo. .. distribución esfuerzo cada una las técnicas estimación del proyecto software que estudian capítulo conducen estimaciones unidades trabajo (por ejemplo, persona-meses) requeridas para completar desarrollo software. una distribución esfuerzo recomendada través punto clave entrega puede retrasarse, curva pnr indica que los costos del proyecto pueden reducirse sustancialmente. conforme fecha límite del proyecto acerca, llega punto donde trabajo puede completarse calendario, sin importar número personas que hagan trabajo. enfrente realidad defina una nueva fecha entrega.consejo (-).indd (-).indd // ::// :: parte cuatro administración proyectos software del proceso software con frecuencia conoce como regla --. cuarenta por cien- todo esfuerzo asigna análisis frontal diseño. porcentaje similar aplica pruebas traseras. ahí infiere correctamente que codificación pierde énfasis ( por ciento esfuerzo). esta distribución esfuerzo debe usarse solamente como guía. las características cada proyecto dictan distribución del esfuerzo. trabajo empleado planificación del proyecto rara vez representa más por ciento esfuerzo, menos que plan comprometa una organización realizar más gastos con alto riesgo. comunicación con cliente análisis requerimientos pueden comprender por ciento del esfuerzo del proyecto. -fuerzo que emplea análisis creación prototipos debe aumentar proporción directa con tamaño complejidad del proyecto. por general, diseño software aplica rango por ciento del esfuerzo. también debe considerarse tiempo que emplea para revisión del diseño posterior iteración. debido esfuerzo aplicado diseño software, código debe seguir relativamente con poca dificultad. posible lograr esfuerzo global por ciento. las pruebas pos-terior depuración pueden representar por ciento del esfuerzo desarrollo del soft-ware. crucial del software con frecuencia dicta cantidad pruebas que requieren. software clasifica humanamente ( decir, errores software pueden resultar pér-dida vida), incluso son usuales porcentajes más altos. . efinición conjunto tareas para proyecto software sin importar modelo proceso que elija, trabajo que realiza equipo software logra través conjunto tareas que permiten definir, desarrollar , final cuentas, apoyar software computadora. ningún conjunto tareas adecuado para todos los proyectos. conjunto tareas adecuado para sistema grande complejo probablemente percibirá como excesivo para producto software pequeño relativamente simple. consecuencia, proceso software efectivo debe definir una colección conjuntos -reas, cada una diseñada para satisfacer las necesidades diferentes tipos proyectos. como anotó capítulo , conjunto tareas una colección tareas trabajo ingeniería del software, hitos, productos operativos filtros aseguramiento calidad que deben lograrse para completar proyecto particular. conjunto tareas debe propor-cionar suficiente disciplina fin lograr software alta calidad. pero, mismo tiempo, debe abrumar equipo del proyecto con trabajo innecesario. con finalidad desarrollar calendario del proyecto, línea tiempo del proyecto debe distribuirse conjunto tareas. conjunto tareas variará dependiendo del tipo proyecto grado rigor con que equipo software decide hacer trabajo. aunque difícil desarrollar una taxonomía exhaustiva los tipos proyecto software, mayoría las organizaciones software encuentran los siguientes proyectos: . pro yectos desarrollo concepto que inician para explorar algún concepto empresa- rial nuevo aplicación alguna nueva tecnología. . los pro yectos desarrollo nueva aplicación que realizan como consecuencia solicitud cliente específico. actualidad, regla -- está bajo ataque. algunos creen que más por ciento esfuerzo global debe emplearse durante análisis diseño. por otro lado, quienes proponen desarrollo ágil (capítulo ) argu- mentan que debe emplearse menos tiempo “frontal” que equipo debe avanzar rápidamente hacia cons-trucción.¿cómo debe distribuirse esfuerzo través del flujo trabajo del proceso software?? webref para auxiliar definición los conjuntos tareas para varios proyectos software, desarrolló modelo proceso adaptable (apm, por sus siglas inglés). puede encontrar una descripción completa del mpa inglés. (-).indd (-).indd // ::// :: calendarización del proyecto . pro yectos mejora aplicación que ocurren cuando software existente experi- menta grandes modificaciones funciones, rendimiento interfaces que son observa- bles por usuario final. . pro yectos mantenimiento aplicación que corrigen, adaptan extienden software existente maneras que pueden ser inmediatamente obvias para usuario final. . pro yectos reingeniería que llevan cabo con intención reconstruir sistema existente (heredado) todo parte. incluso dentro solo tipo proyecto, muchos factores influyen conjunto tareas por elegir. los factores incluyen [pre]: tamaño del proyecto, número usuarios potenciales, vitalidad misión, longevidad aplicación, estabilidad requerimientos, facilidad comunicación cliente/desarrollador, madurez tecnología aplicable, restricciones rendi-miento, características incrustadas incrustadas, personal del proyecto factores reinge-niería. cuando combinan, dichos factores proporcionan indicio del grado rigor con que debe aplicarse proceso software. .. ejemplo conjunto tareas los proyectos desarrollo concepto inician cuando debe explorarse potencial para -guna nueva tecnología. hay certeza que tecnología será aplicable, pero cliente (por ejemplo, mercadotecnia) cree que existen beneficios potenciales. los proyectos desarrollo concepto abordan aplicar las siguientes acciones: . ámbito del concepto determina ámbito global del proyecto. . planificación eliminar del concepto establece habilidad organización para llevar cabo trabajo implicado por ámbito del proyecto. . aloración del riesgo tecnológico evalúa riesgo asociado con tecnología que implementar como parte del ámbito del proyecto. . prueba del concepto demuestra viabilidad una nueva tecnología con- texto del software. . implementación del concepto constituye representación del concepto - nera que pueda revisarse por parte cliente usa con propósitos “mercado- tecnia” cuando debe venderse concepto otros clientes gerentes. . eacción del cliente concepto solicita retroalimentación acerca nuevo concepto tecnológico dirige aplicaciones cliente específicas. una rápida exploración dichas acciones debe producir pocas sorpresas. hecho, flujo ingeniería software para proyectos desarrollo concepto ( también para todos los otros tipos proyectos) mucho más que sentido común. .. refinamiento acciones ingeniería del software las acciones ingeniería software descritas sección anterior pueden usarse para -finir calendario macroscópico para proyecto. obstante, éste debe refinarse para crear calendario proyecto detallado. refinamiento comienza tomando cada acción descom-poniéndola conjunto tareas (con productos operativos hitos relacionados). como ejemplo descomposición tarea, considere acción ., ámbito del concepto. refinamiento las tareas puede lograrse usando formato bosquejo, pero este libro usará enfoque lenguaje diseño proceso para ilustrar flujo acción deter-minación del ámbito del concepto: (-).indd (-).indd // ::// :: parte cuatro administración proyectos software task definition: acción . ámbito del concepto .. identificar necesidad, beneficios clientes potenciales;.. definir salida/control deseado eventos entrada que impulsen aplicación; begin task .. ... : revisar descripción escrita necesidad ... inferir una lista salidas/entradas visibles para cliente ... : revisar salidas/entradas con cliente revisar según requiera; endtask task .. .. definir funcionalidad/comportamiento para cada función principal; begin task .. ... : revisar salida entrada objetos datos inferidos tarea ..; ... inferir modelo funciones/comportamientos; ... : revisar funciones/comportamientos con cliente revisar según requiera; endtask task .. .. aislar aquellos elementos tecnología que implementar software;.. investigar disponibilidad software existente;.. definir factibilidad técnica;.. hacer estimación rápida tamaño;.. crear una definición ámbito; endtask definition: acción . las tareas subtareas anotadas refinamiento del lenguaje diseño proceso forman base calendario detallado para determinación del ámbito del concepto. . efinición una red tareas las tareas subtareas individuales tienen interdependencias función secuencia. ade- más, cuando más una persona está involucrada proyecto ingeniería del software, probable que las actividades tareas desarrollo realicen paralelo. cuando esto ocu-rre, las tareas concurrentes deben coordinarse modo que completen momento que las tareas posteriores requieran sus productos operativos. una red tareas, también llamada red actividad, una representación gráfica del flujo tareas para proyecto. ocasiones usa como mecanismo mediante cual secuencia las dependencias tareas integran una herramienta automatizada calendarización proyecto. forma más simple (usada cuando crea calendario macroscópico), red tareas muestra las principales acciones ingeniería del software. figura . pre-senta una red tareas esquemática para proyecto desarrollo concepto. naturaleza concurrente las acciones ingeniería software conduce algunos - portantes requerimientos calendarización. puesto que las tareas paralelas ocurren -nera asíncrona, debe determinar las dependencias intertarea para asegurar progreso conti-nuo hacia conclusión. además, debe estar tanto aquellas tareas que encuentren ruta crítica, decir, aquellas que deben concluirse conforme calendario proyecto como todo debe completarse acuerdo con ese calendario. estos temas estudian con más detalle más adelante, este capítulo. importante observar que red tareas que muestra figura . macroscópica. una red tareas detallada ( precursor calendario detallado), cada acción que muestra figura expandirá. por ejemplo, tarea . expandirá para mostrar todas las tareas detalladas refinamiento las acciones . que muestran sección ... indica que debe realizarse una revisión técnica (capítulo ).punto clave red tareas mecanismo útil para mostrar las dependencias intertarea determinar ruta crítica. (-).indd (-).indd // ::// :: calendarización del proyecto . alendarización calendarización proyecto software difiere enormemente cualquier - fuerzo ingeniería multitarea. por tanto, las herramientas técnicas generalizadas calen-darización proyecto pueden aplicarse con pocas modificaciones para proyectos soft-ware. evaluación del programa técnica revisión (pert, por sus siglas inglés) método ruta crítica (cpm, por sus siglas inglés) son dos métodos calendarización proyecto que pueden aplicarse desarrollo software. ambas técnicas impulsan mediante informa-ción desarrollada actividades planificación proyectos anteriores: estimaciones esfuerzo, una descomposición función del producto, selección del modelo proceso conjunto tareas adecuadas, así como descomposición las tareas que seleccionan. las interdependencias entre tareas pueden definirse usando una red tareas. las tareas, ocasiones llamadas estructura distribución del trabajo del proyecto (edt), definen para producto como todo para funciones individuales. tanto pert como cpm proporcionan herramientas cuantitativas que permiten: ) deter- minar ruta crítica ( cadena tareas que determina duración del proyecto), ) establecer estimaciones tiempo “más probables” para tareas individuales aplicando modelos estadísti-cos ) calcular “tiempos frontera” que definen una “ventana” tiempo para una tarea par-ticular. .. cronogramas cuando crea calendario proyecto software, comienza con conjunto tareas ( estructura distribución del trabajo). usan herramientas automatizadas, distri-bución del trabajo ingresa como una red esbozo tareas. luego ingresan esfuerzo, duración fecha inicio para cada tarea. además, las tareas pueden asignarse individuos específicos. como consecuencia esta entrada genera cronograma, también llamado gráfico gantt. posible desarrollar cronograma para todo proyecto. alternativamente, pueden generarse gráficos separados para cada función del proyecto para cada individuo que trabaje proyecto. figura . ilustra formato cronograma. muestra una parte calendario proyecto software que enfatiza tarea formación del ámbito del concepto para pro-ducto software procesador palabras (). todas las tareas del proyecto (para ámbito del . ámbito del concepto . planiﬁcación conceptoi. valoración riesgo tec.. prueba conceptoi. implementación conceptointegrar , , . reacción clientei. valoración riesgo tec.. implementación concepto . valoración riesgo tec.. implementación conceptotres tareas . aplican paraleloa funciones deconcepto diferentesfigura . red tareas para desarrollo concepto cita: “todo que debemos decidir qué hacer con tiempo que nos dan.” gandalf señor los anillos: comunidad del anillo punto clave cronograma permite determinar qué tareas realizarán momento determinado. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software concepto) mencionan columna izquierda. las barras horizontales indican - ración cada tarea. cuando muchas barras ocurren mismo tiempo calendario, implican concurrencia tareas. los diamantes indican hitos. las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas que hay esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores.objetivo: objetivo las herramientas calendariza- ción del proyecto permitir gerente proyecto definir las tareas del trabajo, establecer sus dependencias, asignar recursos humanos las tareas desarrollar varios gráficos, cuadros tablas que ayuden monitorear controlar proyecto software. mecánica: general, las herramientas calendarización pro- yecto requieren especificación una estructura distribución trabajo tareas generación una red tareas. una vez defi-nida distribución red tareas ( esbozo), cada una confieren fechas inicio término, recursos humanos, fechas límite otros datos. entonces herramienta genera una variedad cronogramas otras tablas que permiten gerente valorar flujo tareas proyecto. dichos datos pueden actualizarse mane- continua conforme proyecto avance.herramientas representativas: ams realtime, desarrollada por advanced management systems ( proporciona capacidades calendari-zación para proyectos todos los tamaños tipos. microsoft project, desarrollada por microsoft ( com), herramienta calendarización proyecto basada más ampliamente usada. , desarrollada por systems ( soporta todos los aspectos planificación proyecto, incluida calen-darización. una lista exhaustiva proveedores productos software ges- tión proyectos puede encontrarse software calendarización del proyecto identiﬁcar necesidades beneﬁcios reunión con clientesidentiﬁcar necesidades restricciones del proyectoestablecer enunciado del productohito: deﬁnición enunciado del productodeﬁnir salida/control/entrada (sce) deseadosámbito funciones del tecladoámbito funciones entrada vozámbito modos interacciónámbito diagnóstico documentoámbito otras funciones ppdocumento sceftr: revisar sce con clienterevisar sce según requiera hito: deﬁnición scedeﬁnir función/comportamientodeﬁnir funciones tecladodeﬁnir funciones entrada vozdescribir modos interaccióndescribir corrector vocabulario/gramáticadescribir otras funciones ppftr: revisar deﬁnición sce con clienterevisar según requierahito: deﬁnición sce completaaislar elementos softwarehito: deﬁnición elementos softwareinvestigar disponibilidad software existenteinvestigar componentes edición textoinvestigar componentes entrada vozinvestigar componentes manejo archivosinvestigar componentes corrector vocabulario/gramáticahito: identiﬁcación componentes reutilizablesdeﬁnir factibilidad técnicaevaluar entrada vozevaluar corrector gramaticalhito: valoración factibilidad técnicahacer estimaciones rápidas tamañocrear una deﬁnición ámbitorevisar documento ámbito con clienterevisar documento según requierahito: documento ámbito completoi.. .. .. .. .. .. .. .. semana semana semana semana semana . ejemplo cronograma (-).indd (-).indd // ::// :: calendarización del proyecto una vez ingresada información necesaria para generación del cronograma, mayoría las herramientas calendarización proyecto software producen tablas proyecto, listado tabular todas las tareas del proyecto, sus fechas inicio término, planeadas rea- les, otra información relacionada (figura .). utilizadas conjunto con cronograma, las tablas proyecto permiten monitorear progreso. .. seguimiento del calendario desarrolló manera adecuada, calendario del proyecto convierte mapa caminos que define las tareas hitos que van monitorear controlar conforme proyecto avance. seguimiento puede lograrse varias formas diferentes: • realizar reuniones periódicas del estado del proyecto, las que cada miembro del equipo reporte avances problemas • evaluar los resultados todas las revisiones realizadas través del proceso inge- niería del software • determinar los hitos formales del proyecto (los diamantes que muestran figura .) lograron fecha prevista • comparar fecha inicio real con fecha inicio planeada para cada tarea proyecto mencionada tabla recursos (figura .) • reunirse informalmente con los profesionales para obtener valoración subjetiva del avance fecha los problemas horizonte • usar análisis valor ganado (sección .) para valorar cuantitativamente avance realidad, todas estas técnicas seguimiento las usan los gerentes proyecto experi- mentados. control emplea gerente proyecto software para administrar los recursos del proyecto, enfrentar los problemas dirigir personal del proyecto. las cosas van bien ( decir, proyecto avanza conforme calendario dentro presupuesto, las revisiones -dican que realiza progreso real que alcanzan los hitos), control ligero. pero cuando ocurren problemas, debe ejercerse control para reconciliar los elementos discordantes tan rápidamente como sea posible. después diagnosticar problema pueden enfocarse recur-inicio planeadoinicio realconclusión planeadaconclusión realpersona asignadaesfuerzo asignado notas sem, sem, , , sem, sem, , , , , , , , , , , , sem, sem, sem, , sem, , , sem, sem, , , , , , , , , , , , /jpp bls jppmllblsjppmllallall - - - . - - -. - - - - -ddeﬁnir ámbitorequerirá másesfuerzo/tiempo tareas identiﬁcar necesidades beneﬁciosreunión con clientesidentiﬁcar necesidades restricciones del proyectoestablecer enunciado del productohito: deﬁnición enunciado del productodeﬁnir salida/control/entrada (sce) deseadosámbito funciones del tecladoámbito funciones entrada vozámbito modos interacciónámbito diagnóstico documentoámbito otras funciones ppdocumento sceftr: revisar sce con clienterevisar sce según requierahito: deﬁnición scedeﬁnir función/comportamientoi.. .. .. . ejemplo tabla proyecto cita: “ regla básica del reporte estado del software puede resu-mirse una sola frase: ‘sin sorpresas’.” capers jones mejor indicio avance conclusión revisión exitosa producto operativo software definido.consejo (-).indd (-).indd // ::// :: parte cuatro administración proyectos software sos adicionales sobre área problemática: puede reasignarse personal redefinirse calen- dario del proyecto. cuando enfrentan severa presión debido fecha límite, los gerentes experimentados ocasiones usan calendario proyecto técnica control llamado time-boxing (encuadre temporal) [jal]. estrategia time-boxing reconoce que producto completo puede entre- garse fecha límite preestablecida. por tanto, elige paradigma software incremen-tal (capítulo ) establece calendario para cada entrega incremental. las tareas asociadas con cada incremento encuadran tiempo. esto significa que calendario para cada tarea ajusta trabajando reversa desde fecha entrega hasta momento del incremento. alrededor cada tarea pone “recuadro”. cuando una tarea llega frontera encuadre temporal (más menos por ciento), trabajo detiene comienza siguiente tarea. con frecuencia, reacción inicial ante enfoque time-boxing negativa: “ trabajo termina, ¿cómo puedo avanzar?”. respuesta encuentra forma que logra trabajo. para cuando llega frontera del encuadre temporal, probable que por ciento tarea esté completa. restante por ciento, aunque importante, puede ) demorarse hasta siguiente incremento ) completarse más tarde requiere. lugar quedarse “atascado” una tarea, proyecto avanza hacia fecha entrega. .. seguimiento del progreso para proyecto aunque modelo iterativo mejor marco conceptual para proyecto , paralelismo tareas hace difícil seguimiento del proyecto. acaso tengan dificultades establecer hitos significativos para proyecto , debido que algunas cosas diferentes ocurren vez. general, los siguientes hitos importantes pueden considerarse “completos” cuando satis-facen los criterios anotados. hitos técnicos: análisis completo • definición revisión todas las clases jerarquía clases. • definición revisión los atributos clase las operaciones asociadas. • establecimiento revisión las relaciones clase (capítulo ). • creación revisión modelo comportamiento (capítulo ). • anotación las clases reutilizables. hitos técnicos: diseño completo • definición revisión del conjunto subsistemas. • asignación clases subsistemas revisión. • establecimiento revisión asignación tareas. • identificación responsabilidades colaboraciones. • diseño revisión atributos operaciones. • creación revisión del modelo comunicación. hitos técnicos: programación completa • implementación código cada nueva clase, partir del modelo diseño. • implementación las clases extraídas ( partir librería reutilización). • construcción prototipo incremento.punto clave cuando alcanza fecha conclusión definida una tarea encuadrada tiempo, trabajo cesa para dicha tarea comienza siguiente. cínico puede recordar dicho: “ primer por ciento del sistema requiere por ciento del tiempo; res- tante por ciento del sistema requiere por ciento del tiempo”. (-).indd (-).indd // ::// :: calendarización del proyecto hitos técnicos: prueba • revisión exactitud completitud los modelos análisis diseño . • desarrollo revisión una red clase-responsabilidad-colaboración (capítulo ). • diseño casos prueba realización pruebas nivel clase (capítulo ) para cada clase. • diseño casos prueba, conclusión pruebas grupo (capítulo ) integración clases. • conclusión pruebas nivel sistema. recuerde que modelo proceso iterativo: cada uno estos hitos puede revisarse nuevamente conforme diferentes incrementos entreguen cliente. .. calendarización para proyectos webapp calendarización proyectos webapp distribuye esfuerzo estimado través línea tem- poral planeada (duración) para construir cada incremento webapp. esto logra asignando esfuerzo tareas específicas. sin embargo, importante observar que calendario webapp global evoluciona con tiempo. durante primera iteración desarrolla calendario -croscópico. este tipo calendario identifica todos los incrementos webapp proyecta las fechas las que desplegará cada una. conforme desarrollo incremento está marcha, entrada para incremento calendario macroscópico refina calendario detallado. aquí identifican calendarizan tareas desarrollo específicas (requeridas para lograr una actividad). como ejemplo calendarización macroscópica, considere webapp casaseguraasegu- rada.com. recuerda las discusiones anteriores acerca casaseguraasegurada.com, posible identificar siete incrementos para componente del proyecto basado web: incremento : información básica compañía producto incremento : información detallada producto descargasincremento : citas producto procesamiento pedidos productoincremento : plantilla espacial diseño sistema seguridadincremento : servicios información solicitud monitoreoincremento : control línea del equipo monitoreoincremento : acceso información cuenta equipo consulta negocia con los participantes desarrolla calendario despliegue preliminar para los siete incrementos. figura . muestra cronograma para este calendario. importante observar que las fechas despliegue (representadas mediante diamantes cronograma) son preliminares pueden cambiar conforme ocurran calendarizaciones más detalladas los incrementos. obstante, este calendario macroscópico brinda adminis-tración indicio acerca cuándo estará disponible contenido funcionalidad, así como cuándo estará completo todo proyecto. como estimación preliminar, equipo trabajará para desplegar todos los incrementos con cronograma semanas. también vale pena -servar que algunos los incrementos desarrollarán paralelo (por ejemplo, los incremen-tos , , ). esto supone que equipo tendrá suficiente personal para hacer este trabajo paralelo. una vez desarrollado calendario macroscópico, equipo está listo para calendarizar las tareas del trabajo para incremento específico. para lograr esto, puede usar marco concep-tual proceso genérico que sea aplicable todos los incrementos webapp. con las tareas depuración pruebas ocurren concierto mutuo. estado depuración frecuentemente valora considerando tipo número errores “abiertos” (bugs).consejo (-).indd (-).indd // ::// :: parte cuatro administración proyectos software genéricas inferidas como parte del marco conceptual, crea una lista tareas como punto partida luego adapta considerando contenido las funciones que van inferir para incremento específico webapp. cada acción marco conceptual ( sus tareas relacionadas) pueden adaptarse una cuatro formas: ) una tarea aplica como , ) una tarea elimina porque necesaria para incremento, ) agrega una nueva tarea ( medida) ) una tarea refina (elabora) algunas subtareas nominales cada una vuelve parte del calendario. para ilustrar, considere una acción modelado diseño genérica para webapps que puede lograrse aplicar alguna todas las tareas siguientes: • diseño estética para webapp. • diseño interfaz. • diseño del esquema navegación. • diseño arquitectura webapp. • diseño del contenido estructura que soporta. • diseño componentes funcionales. • diseño mecanismos seguridad privacidad adecuados. • revisión del diseño. como ejemplo, considere tarea genérica diseño interfaz como aplica cuarto - cremento casaseguraasegurada.com. recuerde que cuarto incremento implementa contenido función para describir espacio habitable empresarial que asegurar con sistema seguridad casasegura. figura ., cuarto incremento comienza princi- pio quinta semana termina final novena. hay duda que tarea diseño interfaz debe realizarse. equipo reconoce que diseño interfaz crucial para éxito del incremento decide refinar (elaborar) tarea. las siguientes subtareas infieren para tarea diseño interfaz para cuarto incre- mento: • desarrollo bosquejo plantilla página para página diseño del espacio.#. información básica compañía productosemanas incrementos #.información detallada producto descargas #. citas producto procesamiento pedidos producto #. plantilla espacial diseño sistema seguridad #. servicios información solicitud monitoreo #. control línea del equipo monitoreo #. acceso información cuentafigura . cronograma para calendario proyecto macroscópico (-).indd (-).indd // ::// :: calendarización del proyecto • revisión plantilla con participantes. • diseño mecanismos navegación plantilla espacial. • diseño plantilla “tablero dibujo”. • desarrollo detalles procedimiento para función plantilla pared gráfica. • desarrollo detalles procedimiento para cálculo longitud pared función despliegue. • desarrollo detalles procedimiento para función plantilla ventana gráfica. • desarrollo detalles procedimiento para función plantilla puerta gráfica. • diseño mecanismos para seleccionar componentes del sistema seguridad (sensores, cámaras, micrófonos, etc.). • desarrollo detalles procedimiento para plantilla gráfica los componentes del sistema seguridad. • realización par recorridos según requiera. estas tareas vuelven parte del calendario incrementos para cuarto incremento aplicación web asignan calendario desarrollo incrementos. pueden ingresarse software calendarización usarse para seguimiento control. esta etapa, equipo vislumbra creación del espacio literalmente dibujar las paredes, ventanas puertas usando funciones gráficas. las líneas pared “encajarán” puntos agarre. las dimensiones pared desplegarán manera automática. ventanas puertas colocarán gráficamente. usuario final también podrá seleccionar sensores, cámaras otros elementos específicos, colocarlos una vez definido espacio. escena: oficina doug miller antes ini- ciar proyecto software casasegura. participantes: doug miller (gerente del equipo ingeniería software casasegura) vinod raman, jamie lazar otros miembros del equipo ingeniería software del producto. conversación:doug (observa una diapositiva powerpoint): calendario para primer incremento casasegura parece razonable, pero vamos tener problemas para monitorear progreso. vinod (con una mirada preocupada): ¿por qué? tenemos tareas calendarizadas diariamente, llenas productos operativos, nos aseguramos asignar demasiados recursos. doug: todo está bien, ¿pero cómo sabemos cuándo está completo modelo requerimientos para primer incremento?jamie: las cosas son iterativas, así que difícil. doug: entiendo, pero... bueno, por ejemplo, considera “defi- nición clases análisis”. indicaste esto como hito. vinod: .doug: ¿quién determina eso? jamie (agravado): hace cuando esté lista.doug: eso suficientemente bueno, jamie. tenemos que calen- darizar las [revisiones técnicas, capítulo ] has hecho. conclusión exitosa una revisión modelo análisis, por ejemplo, hito razonable. ¿entendido? jamie (frunce ceño): está bien, vuelta tablero dibujo.doug: debería tomar más una hora hacer las correcciones... todos los demás pueden comenzar ahora.casasegura seguimiento calendario . nálisis valor ganado sección . estudiaron algunos enfoques cualitativos sobre seguimiento del pro- yecto. cada uno proporciona gerente del proyecto indicio del progreso, pero una valora-ción información proporcionada poco subjetiva. razonable preguntar existe una técnica cuantitativa para valorar progreso conforme equipo software avanza través punto clave valor ganado proporciona indicio cuantitativo del progreso. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software las tareas asignadas calendario del proyecto. hecho, existe una técnica para realizar análisis cuantitativo del progreso. llama análisis valor ganado (avg). humphrey [hum] analiza valor ganado los siguientes términos: sistema valor ganado ofrece una escala valor común para toda tarea [ proyecto soft- ware], sin importar tipo trabajo que realizar. estiman las horas totales para hacer todo proyecto cada tarea valor ganado con base porcentaje estimado del total. dicho forma todavía más simple, valor ganado una medida progreso. permite valorar “porcentaje completitud” proyecto usando análisis cuantitativo lugar apoyarse una corazonada. hecho, fleming koppleman [fle] argumentan que aná-lisis valor ganado “proporciona lecturas precisas confiables del rendimiento tan temprana-mente como con por ciento del proyecto”. para determinar valor ganado realizan los siguientes pasos: . costo presupuestado del abajo calendarizado (cptc) determina para cada tarea - presentada calendario. durante estimación planifica trabajo ( persona-horas persona-días) cada tarea ingeniería del software. por tanto, cptc esfuerzo planificado para tarea . para determinar progreso punto determi-nado largo del calendario del proyecto, valor cptc suma los valores cptc para todas las tareas que deben estar completas dicho punto tiempo - ñalado calendario del proyecto. . los valores cptc para todas las tareas suman para inferir presupuesto concluir ( ). por tanto, / / (cptck) para todas las tareas . continuación, calcula costo presupuestado del abajo realizado (cptr). valor cptr suma los valores cptc para todas las tareas que realmente conclu- yeron punto tiempo sobre calendario del proyecto. wilkens [wil] observa que “ distinción entre cptc cptr que primero repre- senta presupuesto las actividades que planea completar último representa presu- puesto las actividades que realmente completaron”. determinados los valores para cptc, pac cptr, posible calcular importantes indicadores del progreso: índice rendimiento calendario, irs / cptr cptc variación calendario, / cptr / cptc irs indicio eficiencia con que proyecto utiliza los recursos calendarizados. valor irs cercano . indica ejecución eficiente del calendario del proyecto. simple- mente indicio absoluto variación con respecto calendario planeado. porcentaje calendarizado para conclusión / cptc pac proporciona indicio del porcentaje trabajo que debe concluirse hacia tiempo . porcentaje completo / cptc pac proporciona indicio cuantitativo del porcentaje completitud del proyecto punto dado tiempo . también posible calcular costo real del trabajo realizado (crtr). valor para crtr suma del esfuerzo realmente utilizado las tareas que completaron punto tiempo calendario del proyecto. entonces posible calcular¿cómo calcula valor ganado cómo usa para valorar progreso?? webref puede encontrarse una amplia variedad recursos para análisis valor ganado. (-).indd (-).indd // ::// :: calendarización del proyecto índice rendimiento costo, irc / cptr crtr variación costo, / cptr / crtr valor irc cercano . proporciona fuerte indicio que proyecto está dentro presupuesto definido. indicio absoluto ahorros costo (contra los costos pla- nificados) déficits una etapa particular proyecto. como otros radares horizonte, análisis valor ganado ilumina las dificultades calendarización antes que puedan ser aparentes otro modo. esto permite tomar acciones correctivas antes que desarrolle una crisis proyecto. . esumen calendarización culminación una actividad planificación que componente principal administración proyectos software. cuando combina con los métodos estimación análisis riesgos, establece mapa caminos para gerente del pro-yecto. calendarización comienza con descomposición del proceso. las características del proyecto usan para adaptar conjunto tareas adecuado para trabajo que rea-lizar. una red tareas muestra cada tarea ingeniería, dependencia otras tareas duración proyectada. red tareas usa para calcular ruta crítica, cronograma otra información del proyecto. usar calendario como guía, puede monitorearse controlar cada paso proceso software. problemas puntos por evaluar .. las fechas límite “irracionales” son hecho vida negocio del software. ¿cómo debe pro- ceder enfrenta con una? .. ¿cuál diferencia entre calendario macroscópico uno detallado? ¿ posible administrar proyecto sólo desarrolla calendario macroscópico? explique respuesta. .. ¿puede existir caso donde hito proyecto software ligue una revisión? así, ofrezca uno más ejemplos. .. “gasto comunicación” puede ocurrir cuando múltiples personas trabajan proyecto soft- ware. tiempo que emplea para comunicarse con los demás reduce productividad individual (loc/mes) resultado puede ser menos productividad para equipo. ilustre (cuantitativamente) cómo usan los ingenieros versados las buenas prácticas ingeniería software revisiones técnicas que pueden -mentar tasa producción equipo (cuando compara con suma las tasas producción -dividuales) qué tipo revisiones técnicas usan. sugerencia: puede suponer que las revisiones reducen reproceso que reproceso puede representar por ciento del tiempo una persona. .. aunque agregar personas proyecto software retrasado puede hacer que retrase aún más, existen circunstancias las que esto cierto. descríbalas. .. relación entre personal tiempo enormemente lineal. con ecuación software putnam (descrita sección ..), desarrolle una tabla que relacione número personas con duración del proyecto para proyecto software que requiere loc personas-años esfuerzo ( paráme-tro productividad = .). suponga que software debe entregarse más menos meses con una posibilidad prórroga meses. .. suponga lector que una universidad contrata para desarrollar sistema para registrarse línea los cursos (olcrs, según sus siglas inglés). primero, actúe como cliente ( estudiante, ¡debe resul-tarle sencillo!) especifique las características buen sistema. ( manera alternativa, instructor proporcionará conjunto requerimientos preliminares para sistema.) con los métodos estimación estudiados capítulo desarrolle una estimación esfuerzo duración para olcrs. sugiera cómo: (-).indd (-).indd // ::// :: parte cuatro administración proyectos software ) definiría actividades trabajo paralelas durante proyecto olcrs. ) distribuiría esfuerzo través del proyecto.) establecería hitos para proyecto... seleccione conjunto tareas adecuado para proyecto olcrs... defina una red tareas para olcrs descrito problema . , alternativamente, para otro proyecto software que sea interés. asegúrese mostrar tareas hitos unir estimaciones esfuerzo duración cada tarea. posible, use una herramienta calendarización automatizada para realizar este trabajo. .. está disponible una herramienta calendarización automatizada determine ruta crítica para red definida problema .. .. con herramienta calendarización ( está disponible), con papel lápiz ( necesario), desarrolle cronograma para proyecto olcrs. .. suponga que usted gerente proyecto software que pide calcular estadísticas valor ganado para pequeño proyecto software. proyecto tiene tareas planeadas que estima que requieren personas-días para completarlas. momento que pide hacer análisis valor ganado, han completado tareas. sin embargo, calendario del proyecto indica que deberían estar completas . están disponibles los siguientes datos calendarización ( persona-días): tarea esfuerzo planeado esfuerzo real . . . . . . . . . . . . . . . . . . . . . . . . . — . — . — calcule irs, variación calendario, porcentaje calendarizado para conclusión, porcentaje completo, irc variación costo para proyecto. lecturas fuentes información adicionales virtualmente, todo libro escrito acerca administración proyectos software contiene análisis calendarización. wysoki (effective project management, wiley, ), lewis (project planning scheduling and control, . ., mcgraw-hill, ), luckey phillips (software project management for dummies, for dum- mies, ), kerzner (project management: systems approach planning, scheduling, and controlling, . ., wiley, ), hughes (software project management, mcgraw-hill, ), the project management insti- tute (pmbok guide, . ., pmi, ), lewin ( better software project management, wiley, ) bennatan ( time, within budget: software project management practices and techniques, . ., wiley, ) contie- nen valiosos análisis sobre materia. aunque específico para aplicación, harris ( planning and scheduling using microsoft office project , eastwood harris pty ltd., ) proporciona útil estudio sobre cómo pueden usarse las herramientas calendarización para seguimiento control exitosos proyecto software. fleming koppelman (earned value project management, ., project management institute publica- tions, ), budd ( practical guide earned value project management, management concepts, ) (-).indd (-).indd // ::// :: calendarización del proyecto webb wake (using earned value: project manager’ guide, ashgate publishing, ) analizan con detalle considerable uso las técnicas valor ganado para planificación, seguimiento control proyectos. internet está disponible una gran variedad fuentes información acerca calendarización proyectos software. una lista actualizada referencias world wide web que son relevantes para calendarización proyectos software puede encontrarse sitio del libro: compsci/pressman/professional/olc/ser.htm (-).indd (-).indd // ::// :: del riesgo conceptos clave categorías riesgo . . . . . . estrategias . . . . . . . . . . . . . proactiva . . . . . . . . . . . . . reactiva . . . . . . . . . . . . . . exposición riesgo. . . . . . . . . . . . . . . . . . . verificación ítem riesgo . . . . . . . . . . . . . . mmmr. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . riesgos . . . . . . . riesgo . . . . . . . . . . . . . . . . . . . . . . . . ¿qué ? análisis administración del riesgo son acciones que ayudan equipo software entender manejar incertidum-bre. muchos problemas pueden plagar pro- yecto software. riesgo problema potencial: puede ocurrir, puede ocurrir. pero, sin importar resul-tado, realmente una buena idea identificarlo, valorar probabilidad ocurrencia, estimar impacto estable-cer plan contingencia para caso que proble- realmente ocurra. ¿quién hace? todos los involucrados proceso software (gerentes, ingenieros software otros inte-resados) participan análisis administración del riesgo. ¿por qué importante? piense consigna los boy scouts: “estar preparados”. software una empre- difícil. muchas cosas pueden salir mal , francamente, muchas con frecuencia hacen. por esta razón que estar preparado, comprender los riesgos tomar medidas proactivas para evitarlos manejarlos son elementos clave una buena administración proyecto software.¿cuáles son los pasos? reconocer qué puede salir mal primer paso, llamado “identificación riesgos”. continuación, cada riesgo analiza para determinar probabilidad que ocurra daño que causará ocu-rre. una vez establecida esta información clasifican los riesgos, por probabilidad impacto. finalmente, desa-rrolla plan para manejar aquellos que tengan alta probabilidad alto impacto. ¿cuál producto final? produce plan para mitigar, monitorear manejar riesgo (mmmr) conjunto hojas información riesgo. ¿cómo aseguro que hice bien? los riesgos que analizan manejan deben inferirse partir estudio del personal, producto, proceso proyecto. mmmr debe revisarse conforme avance proyecto para asegurarse que los riesgos mantienen actuali-zados. los planes contingencia para administración del riesgo deben ser realistas. una mirada rápidaen libro acerca administración análisis riesgos, robert charette [cha] presenta una definición conceptual riesgo: primero, riesgo preocupa por los acontecimientos futuros. ayer hoy están más allá pre- ocupación activa, pues cosechamos que previamente sembró por nuestras acciones pasadas. cuestión tiene que ver, por tanto, con podemos, cambiar nuestras acciones hoy, crear una oportunidad para una situación diferente esperanzadoramente mejor para nosotros mañana. esto significa, segundo, que riesgo involucra cambio, como los cambios mentalidad, opi-nión, acciones lugares [...] [tercero,] riesgo involucra elección incertidumbre que ella conlleva. consecuencia, paradójicamente, riesgo, como muerte los impuestos, una las pocas certezas vida. cuando considera riesgo contexto ingeniería del software, los tres fundamentos conceptuales charette siempre están presentes. futuro preocupación: ¿qué riesgos pueden hacer que proyecto software salga defectuoso? cambio que preocupa: ¿cómo afectan los cronogramas éxito global los cambios que puede haber los -quisitos del cliente, las tecnologías desarrollo, los entornos meta todas las otras entidades conectadas con proyecto? por último, debe lidiar con las opciones: ¿qué métodos herramientas deben usarse, cuántas personas deben involucrarse, cuánto énfasis “sufi-ciente” poner calidad? peter drucker [dru] dijo alguna vez: “aunque sea fútil intentar eliminar riesgo, cuestio- nable intentar minimizarlo, esencial que los riesgos tomados sean los riesgos correctos”. (-).indd (-).indd // ::// :: administración del riesgo antes poder identificar los “riesgos correctos” que van tomar durante proyecto software, importante identificar todos los que son obvios para gerentes profesionales. . strategias reactivas riesgo frente estrategias proactivas riesgo las estrategias reactivas riesgo han llamado irrisoriamente “escuela gestión riesgo indiana jones” [tho]. las películas que llevan nombre, indiana jones, cuando -frenta una dificultad abrumadora, invariablemente dice: “ preocupes, ¡pensaré algo!”. nunca preocuparse por los problemas hasta que suceden, indy reaccionará alguna forma heroica. tristemente, gerente promedio proyectos software indiana jones los miem- bros del equipo del proyecto software son sus fieles ayudantes. sin embargo, mayoría los equipos software apoyan exclusivamente estrategias reactivas riesgo. cuando mucho, una estrategia reactiva monitorea proyecto para riesgos probables. los recursos hacen lado para lidiar con los riesgos, hasta que convierten problemas reales. manera más común, equipo software hace nada acerca los riesgos hasta que algo sale mal. entonces equipo apresura entrar acción con intención corregir pro-blema rápidamente. con frecuencia esto llama modo bombero. cuando falla, “administra-ción crisis” [cha] toma control proyecto está peligro real. una estrategia considerablemente más inteligente para administración del riesgo ser proactivo. una estrategia proactiva comienza mucho antes iniciar trabajo técnico. los riesgos potenciales identifican, probabilidad impacto valoran clasifican por -portancia. luego, equipo software establece plan para gestionar riesgo. objetivo principal evitarlo, pero, dado que todos los riesgos son evitables, equipo trabaja para desarrollar plan contingencia que permitirá responder forma controlada efectiva. largo del resto este capítulo estudia una estrategia proactiva gestión del riesgo. . iesgos software aunque hay considerable debate acerca definición adecuada riesgo software, existe acuerdo general que los riesgos siempre involucran dos características: incertidum-bre ( riesgo puede ocurrir; decir, hay riesgos por ciento probables ) pérdida ( riesgo vuelve una realidad, ocurrirán consecuencias pérdidas deseadas [hig]). cuando analizan los riesgos importante cuantificar nivel incertidumbre grado pérdidas asociados con cada riesgo. para lograr esto, consideran diferentes categorías riesgos. los riesgos del proyecto amenazan plan del proyecto, decir, los riesgos del proyecto vuelven reales, probable que calendario del proyecto deslice que los costos aumenten. los riesgos del proyecto identifican potenciales problemas presupuesto, calendario, personal (tanto técnico como organización), recursos, participantes requisitos, así como -pacto sobre proyecto software. capítulo , complejidad, tamaño grado incertidumbre estructural del proyecto también definieron como factores riesgos para proyecto ( estimación). los riesgos técnicos amenazan calidad temporalidad del software que producir. riesgo técnico vuelve una realidad, implementación puede volverse difícil imposible. los riesgos técnicos identifican potenciales problemas diseño, implementación, interfaz, cita: “ atacas manera activa los riesgos, ellos atacarán manera activa.” tom gilb riesgo que por ciento probable una restricción sobre proyecto software.¿qué tipos riesgos probable encontrar conforme construye software?? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software verificación mantenimiento. además, ambigüedad especificación, incertidumbre técnica, obsolescencia técnica tecnología “ punta” también son factores riesgo. los riesgos técnicos ocurren porque problema más difícil resolver que creía. los riesgos empresariales amenazan viabilidad del software que construir con frecuencia ponen peligro proyecto producto. los candidatos para los cinco principales riesgos empresariales son: ) construir producto sistema excelente que realmente quiere (riesgo mercado), ) construir producto que encaje estrategia -presarial global compañía (riesgo estratégico), ) construir producto que equipo ventas sabe cómo vender (riesgo ventas), ) perder apoyo los administradores debido cambio enfoque personal (riesgo administrativo) ) perder apoyo presupues-tal personal (riesgos presupuestales). extremadamente importante observar que categorización simple riesgos siempre funciona. algunos ellos son simplemente impredecibles por adelantado. otra categorización general los riesgos propuesta por charette [cha]. los riesgos conocidos son aquellos que pueden descubrirse después una evaluación cuidadosa del plan del proyecto, del entorno empresarial técnico donde desarrolla proyecto otras fuen-tes información confiables (por ejemplo, fecha entrega irreal, falta requisitos documen-tados ámbito software, pobre entorno desarrollo). los riesgos predecibles extrapolan experiencia proyectos anteriores (por ejemplo, rotación personal, pobre comunica-ción con cliente, disolución del esfuerzo del personal conforme atienden las solicitudes mantenimiento). los riesgos impredecibles son comodín baraja. pueden ocurrir - cen, pero son extremadamente difíciles identificar por adelantado. cita: “los proyectos sin riesgos reales son perdedores. casi siempre están desprovistos beneficio; por esto por que hicieron años atrás.” tom demarco tim lister software engineering institute (sei) ( edu) identifica siete principios que “ofrecen marco con- ceptual para lograr una administración riesgo efectiva”. éstos son: mantener una perspectiva global: ver los riesgos del software dentro del contexto sistema donde riesgo compo- nente problema empresarial que pretende resolver. tomar una visión previsión: pensar los riesgos que pue- den surgir futuro (por ejemplo, debido cambios soft-ware); establecer planes contingencia modo que los eventos futuros sean manejables. alentar comunicación abierta: alguien enuncia riesgo potencial, ignore. riesgo propone manera infor-mal, considérelo. aliente todos los participantes usuarios sugerir riesgos cualquier momento.integrar: una consideración riesgo debe integrarse proceso del software. enfatizar proceso continuo: equipo debe vigilar largo del proceso software, modificar los riesgos identifica-dos conforme conozca más información agregar unos nuevos conforme logre mejor comprensión. desarrollar una visión producto compartida: todos los participantes comparten misma visión del software, pro-bable que haya mejor identificación valoración del riesgo. alentar trabajo equipo: los talentos, habilidades cono- cimientos todos los participantes deben reunirse cuando rea-licen actividades administración riesgos.información siete principios administración riesgos . dentificación riesgos identificación riesgos intento sistemático por especificar amenazas plan del pro- yecto (estimaciones, calendario, carga recursos, etc.). identificar los riesgos conocidos predecibles, gerente proyecto primer paso para evitarlos cuando posible para controlarlos cuando necesario. existen dos tipos distintos riesgos para cada una las categorías que presentaron sección .: riesgos genéricos riesgos específicos del producto. los riesgos genéricos son una amenaza potencial todo proyecto software. los riesgos específicos del producto pueden (-).indd (-).indd // ::// :: administración del riesgo identificarse solamente por quienes tienen clara comprensión tecnología, personal entorno específico del software que construye. para identificar los riesgos específicos del producto, examine plan del proyecto enunciado ámbito del software, desarrolle una respuesta siguiente pregunta: ¿qué características especiales este producto pueden ame-nazar plan del proyecto? método para identificar riesgos crear una lista verificación ítem riesgo. lista verificación puede usarse para identificación del riesgo así enfocarse sobre algún subcon-junto riesgos conocidos predecibles las siguientes subcategorías genéricas: • tamaño del producto: riesgos asociados con tamaño global del software que construir modificar. • impacto empresarial: riesgos asociados con restricciones impuestas por administración por mercado. • características los participantes: riesgos asociados con sofisticación los partici-pantes con habilidad los desarrolladores para comunicarse con los participantes forma oportuna. • definición del proceso: riesgos asociados con grado que definió proceso software manera como sigue por parte organización desarrolladora. • entorno desarrollo: riesgos asociados con disponibilidad calidad las herra-mientas por usar para construir producto. • tecnología por construir: riesgos asociados con complejidad del sistema que construir con “novedoso” tecnología que incluye sistema. • tamaño experiencia del personal: riesgos asociados con experiencia técnica proyecto global los ingenieros software que harán trabajo. lista verificación ítem riesgo puede organizarse diferentes formas. las preguntas relevantes cada uno los temas pueden responderse para cada proyecto software. las respuestas dichas preguntas permiten estimar impacto del riesgo. formato diferente lista verificación ítem riesgo simplemente menciona las características que son -levantes cada subcategoría genérica. finalmente, menciona conjunto “componentes promotores riesgo” [afc] junto con sus probabilidades ocurrencia. los promotores desempeño, apoyo, costo calendario analizan respuesta las preguntas anteriores. algunas listas verificación exhaustivas para riesgo proyecto software están disponi- bles red (por ejemplo, [baa], [nas], [wor]). puede usar dichas listas verificación para comprender los riesgos genéricos para proyectos software. .. valoración del riesgo proyecto global las siguientes preguntas infirieron los datos riesgo obtenidos entrevistar diferen-tes partes del mundo gerentes proyectos software experimentados [kei]. las pregun-tas ordenan por importancia relativa para éxito del proyecto. . ¿los gerentes software cliente reunieron formalmente para apoyar pro- yecto? . ¿los usuarios finales comprometen manera entusiasta con proyecto con sistema/producto que construir? . ¿ equipo ingeniería del software sus clientes entienden por completo los requi- sitos? . ¿los clientes involucraron plenamente definición los requisitos? . ¿los usuarios finales tienen expectativas realistas?aunque importante considerar los riesgos genéricos, son los riesgos específicos del producto los que provocan más dolores cabeza. asegúrese emplear tiempo para identificar tantos riesgos específicos del producto como sea posible.consejo ¿ proyecto software que trabaja está serio peligro?? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . ¿ ámbito del proyecto estable? . ¿ equipo ingeniería del software tiene mezcla correcta habilidades? . ¿los requisitos del proyecto son estables? . ¿ equipo proyecto tiene experiencia con tecnología que implementar? . ¿ número personas que hay equipo del proyecto adecuado para hacer trabajo? . ¿todas las divisiones cliente/usuario están acuerdo importancia del pro- yecto los requisitos para sistema/producto que construir? alguna estas preguntas responde manera negativa deben establecerse sin falta pasos mitigación, monitoreo gestión. grado que proyecto está riesgo directamente proporcional número respuestas negativas dichas preguntas. .. componentes promotores riesgo fuerza aérea estadounidense [afc] publicó escrito que contiene excelentes lineamien-tos para identificación reducción los riesgos software. enfoque fuerza aérea requiere que gerente del proyecto identifique los promotores riesgo que afectan los com-ponentes riesgo software: rendimiento, costo, apoyo calendario. contexto este análisis, los componentes riesgo definen forma siguiente: • riesgo rendimiento: grado incertidumbre que producto satisfará sus requisitos ajustará uso pretendido. • riesgo costo: grado incertidumbre que presupuesto del proyecto mantendrá. • riesgo apoyo: grado incertidumbre que software resultante será fácil corregir, adaptar mejorar. • riesgo calendario: grado incertidumbre que calendario del proyecto mantendrá que producto entregará tiempo. impacto cada promotor riesgo sobre componente riesgo divide una cua-tro categorías impacto: despreciable, marginal, crítico catastrófico. figura . [boe] describe una caracterización las potenciales consecuencias errores (hileras con etiqueta ) fallo para lograr resultado deseado (hileras con etiqueta ). cate-goría impacto elige con base caracterización que ajusta mejor descripción tabla. . royección del riesgo proyección del riesgo, también llamada estimación del riesgo, intenta calificar cada riesgo dos formas: ) posibilidad probabilidad que riesgo sea real ) las consecuencias los problemas asociados con riesgo, caso que ocurra. usted trabaja junto con otros gerentes personal técnico para realizar cuatro pasos proyección riesgo: . establecer una escala que refleje probabilidad percibida riesgo. . delinear las consecuencias del riesgo. . estimar impacto del riesgo sobre proyecto producto. . valorar precisión global proyección del riesgo modo que habrá malos - tendidos.webref risk radar una base datos herramientas que ayudan los gerentes identificar, clasificar comunicar riesgos proyecto. puede encontrarse cita: “ administración del riesgo administración proyecto para adultos.” tim lister (-).indd (-).indd // ::// :: administración del riesgo intención estos pasos considerar los riesgos manera que conduzcan una prioriza- ción. ningún equipo software tiene los recursos para abordar todo riesgo posible con mismo grado rigor. priorizar los riesgos posible asignar recursos donde tendrán más impacto. .. elaboración una tabla riesgos una tabla riesgos proporciona una técnica simple para proyección riesgos. una tabla muestra riesgo ilustra figura .. comience por elaborar una lista todos los riesgos (sin importar cuán remotos sean) primera columna tabla. esto puede lograrse con ayuda las listas verificación ítem riesgo mencionadas sección .. cada riesgo clasifica segunda columna (por ejemplo, implica riesgo tamaño proyecto, emp implica riesgo empresarial). probabilidad ocurrencia cada riesgo ingresa siguiente columna tabla. valor probabilidad para cada riesgo puede estimarse individualmente por los miembros del equipo. una forma lograr esto encuestar todos los miembros del equipo hasta que valoración colectiva probabilidad del riesgo comience convergir. continuación, valora impacto cada riesgo. cada componente riesgo valora usando caracterización que presenta figura . determina una categoría componentes categoría catastróﬁco crítico marginal despreciablerendimiento apoyo costo calendario falla para satisfacer requisito resultaría fallo misión degradación signiﬁcativa parano lograr elrendimientotécnicosoftware queno responde nopuede tener apoyosigniﬁcativosrecortes ﬁnancieros,probableagotamientode presupuestoioc inalcanzablela falla como resultado aumento decostos demoras calendario, convalores esperados exceso $ falla para satisfacer requisitodegradaría rendimiento del sistemahasta punto donde éxito lamisión sería cuestionable cierta reducción rendimientotécnicodemoras menoresen modiﬁcacionesde softwarecierto recorte derecursos ﬁnancieros,posible agotamientoposibledeterioroen iocla falla como resultado demorasoperativas / aumento costoscon valor esperado $ $ falla para satisfacer los requisitos resultaría degradación misiónsecundaria reducción mínima pequeña enrendimientotécnicoapoyo desoftwarereceptivosuﬁcientes recursosﬁnancieroscalendariorealista,alcanzablecostos, impactos / calendariorecuperable deterioran con valoresperado $ $ falla para satisfacer requisitos crearía inconvenientes impacto operativo reducción rendimientotécnicosoftwarefácilmentesoportableposible subejerciciode presupuestoioc alcanzablecon facilidaderror como resultado costo menory/ impacto calendario con valoresperado menos $ nota: ) consecuencia potencial errores fallos software detectados. ) consecuencia potencial resultado deseado alcanza.figura . valoración impacto.fuente: [boe]. piense duro acerca del software que está punto construir pregúntese: ¿qué puede salir mal? cree propia lista pida otros miembros del equipo que hagan mismo.consejo tabla riesgos puede implementarse como modelo hoja cálculo. esto permite fácil manipulación ordenamiento las entradas. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software impacto. las categorías para cada uno los cuatro componentes riesgo (rendimiento, apoyo, costo calendario) promedian para determinar valor impacto global. una vez completadas las primeras cuatro columnas tabla riesgos, tabla ordena por probabilidad por impacto. los riesgos alta probabilidad alto impacto ubican parte superior tabla los riesgos baja probabilidad ubican fondo. esto logra una priorización riesgo primer orden. posible estudiar tabla ordenada resultante definir una línea corte. línea corte (dibujada horizontalmente algún punto tabla) implica que sólo los riesgos que -cuentran por arriba línea recibirán mayor atención. los riesgos que caen por abajo línea vuelven valorar para lograr una priorización segundo orden. figura ., impacto probabilidad del riesgo tienen una influencia distinta sobre preocupación administración. factor riesgo que tenga alto impacto pero una muy baja probabilidad ocurrencia debe absorber una cantidad significativa tiempo administrativo. sin -bargo, los riesgos alto impacto con probabilidad moderada alta los riesgos bajo impacto con alta probabilidad deben someterse los siguientes pasos del análisis riesgos. todos los riesgos que encuentran por arriba línea corte deben manejarse. - lumna marcada mmmr contiene apuntador plan mitigación, monitoreo manejo riesgo , alternativamente, una colección hojas información riesgo desarrolladas para todos los riesgos que encuentran arriba del corte. plan mmmr las hojas informa-ción riesgo estudian las secciones . .. probabilidad del riesgo puede determinarse hacer estimaciones individuales luego desarrollar solo valor consenso. aunque dicho enfoque factible, han desarrollado técnicas más sofisticadas para determinar probabilidad del riesgo [afc]. los promotores riesgo pueden valorarse sobre una escala probabilidad cualitativa que tenga los siguien-tes valores: imposible, improbable, probable frecuente. entonces puede asociarse probabilidad riesgos estimación tamaño puede ser signiﬁcativamente baja mayor número usuarios que planiﬁcadomenos reuso que planiﬁcadousuarios ﬁnales que resisten sistemafecha entrega será apretadapérdida fondoscliente cambiará requisitostecnología satisfará las expectativasfalta capacitación herramientaspersonal inexpertoalta rotación personalpspsps bubu stst%%%%%%%%%%% valores impacto: —catastróﬁco—crítico—marginal—despreciable impacto rmmm categoría ∑ ∑∑figura . ejemplo tabla riesgo previo ordenamiento puede usar promedio ponderado componente riesgo tiene más significado para proyecto.punto clave una tabla riesgos ordena por probabilidad impacto para clasificar riesgos. cita: “[hoy] nadie tiene lujo poder conocer una tarea tan bien como para que conten- sorpresas, las sorpresas significan riesgo.” stephen grey (-).indd (-).indd // ::// :: administración del riesgo matemática con cada valor cualitativo (por ejemplo, una probabilidad . . implica riesgo enormemente probable). .. valoración impacto riesgo tres factores afectan las probables consecuencias ocurre riesgo: naturaleza, ámbito temporización. naturaleza del riesgo indica los problemas probables ocurre. por ejem-plo, una interfaz externa pobremente definida hardware cliente ( riesgo técnico) impe-dirá diseño las pruebas tempranas, probablemente conducirá más tarde problemas integración sistema proyecto. ámbito riesgo combina severidad (¿cuán serio ?) con distribución global (¿cuánto del proyecto afectará cuántos participantes -ñarán?). finalmente, temporización riesgo considera cuándo por cuánto tiempo sentirá impacto. mayoría los casos quiere que las “malas noticias” ocurran tan pronto como sea posible, pero algunos, mientras más demoren, mejor. regrese una vez más enfoque análisis riesgos que propuso fuerza aérea estado- unidense [afc]; puede aplicar los siguientes pasos para determinar las consecuencias globa-les riesgo: ) determine probabilidad promedio del valor ocurrencia para cada com-ponente riesgo; ) con figura ., determine impacto para cada componente con base los criterios mostrados, ) complete tabla riesgos analice los resultados como describe las secciones anteriores. exposición riesgo global, , determina usando siguiente relación [hal]: / / donde probabilidad ocurrencia para riesgo costo para proyecto ocurre riesgo. por ejemplo, suponga que equipo software define riesgo proyecto forma siguiente: identificación riesgo. hecho, sólo por ciento los componentes software calendarizados para reuso integrarán aplicación. funcionalidad restante tendrá que desarrollarse medida.. bajamuy alta impacto preocupación administraciónaltadesdeñar factor riesgo probabilidad ocurrenciafigura . riesgo preocupación administración ¿cómo valoran las consecuencias riesgo?? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software probabilidad del riesgo. por ciento (probable). impacto del riesgo. planificaron componentes software reutilizables. sólo puede usarse por ciento, tendrán que desarrollarse componentes desde cero (además otro software medida que calendarizó para desarrollo). dado que componente promedio loc que los datos locales indican que costo ingeniería del software para cada loc $., costo global (impacto) para desarrollar los compo-nentes sería / / / $ . exposición riesgo. / . / / $ . exposición riesgo puede calcularse para cada riesgo tabla riesgo, una vez hecha estimación del costo del riesgo. exposición riesgo total para todos los riesgos (arriba del corte tabla riesgos) puede proporcionar los medios para ajustar estimación del costo final para proyecto. también puede usarse para predecir aumento probable recursos personal requeridos varios puntos durante calendario del proyecto. proyección del riesgo las técnicas análisis descritas las secciones .. .. aplican manera iterativa conforme avanza proyecto software. equipo del proyecto debe revisar tabla riesgos intervalos regulares, reevaluar cada riesgo para determinar cuándo nuevas circunstancias cambian probabilidad impacto. como consecuencia esta actividad, acaso sea necesario agregar nuevos riesgos tabla, eliminar algunos riesgos que son relevantes incluso cambiar las posiciones relativas otros. compare para todos los riesgos con estimación costo para proyecto. mayor por ciento del costo del proyecto, debe evaluarse viabilidad éste.consejo escena: oficina doug miller antes comenzar proyecto software casasegura. participantes: doug miller (gerente del equipo ingeniería del software casasegura) vinod raman, jamie lazar otros miembros del equipo ingeniería software del producto. conversación:doug: gustaría usar algo tiempo una lluvia ideas para proyecto casasegura. jamie: ¿acerca que puede salir mal?doug: sip. aquí hay algunas categorías donde las cosas pueden salir mal. [muestra todos las categorías anotadas introduc-ción sección ..] vinod: hmmm... quieres que sólo las mencionemos ...doug: . esto que creo que debemos hacer. todo mundo haga una lista riesgos... ahora... [transcurren diez minutos, todos escriben]. doug: muy bien, deténganse. jamie: ¡pero terminado!doug: está bien. revisaremos lista nuevo. ahora, para cada ítem lista, asignen porcentaje probabilidad que ocu-rrirá riesgo. luego, asignen impacto proyecto sobre una escala (menor) (catastrófico).vinod: creo que riesgo volado, especifico una probabili-dad por ciento , creo que tendrá impacto proyecto moderado, especifico , ¿cierto? doug: exactamente. [transcurren cinco minutos, todos escriben]. doug: muy bien, deténganse. ahora haremos una lista grupal pizarrón. escribiré; cada uno ustedes dirá una entrada lista. [transcurren quince minutos; crean lista]. jamie (apunta hacia pizarrón ríe): vinod, ese riesgo (apunta hacia una entrada pizarrón) ridículo. hay una mayor probabilidad que todos nos caiga rayo. debemos removerlo. doug: , dejémoslo por ahora. consideremos todos los riesgos, sin importar cuán locos parezcan. más tarde filtraremos lista. jamie: pero tenemos más riesgos... ¿cómo vamos manejarlos todos? doug: podemos. por eso por que definiremos corte después ordenarlos. haré ese corte nos reuniremos nuevo mañana. por ahora, regresen trabajar... tiempo libre pien-sen cualquier riesgo que hayan olvidado.casasegura análisis riesgos (-).indd (-).indd // ::// :: administración del riesgo . efinamiento del riesgo durante las primeras etapas planificación del proyecto, riesgo puede enunciarse manera muy general. conforme pasa tiempo aprende más acerca del proyecto los riesgos, posible refinar riesgo conjunto riesgos más detallados, cada uno poco más sencillo mitigar, monitorear manejar. una forma hacer esto representar riesgo formato condición-transición-consecuen- cia (ctc) [glu]. decir, riesgo enuncia forma siguiente: dado que <condición entonces hay preocupación porque (posiblemente) <consecuencia. usar formato ctc para riesgo reutilización anotado sección .., podría -cribir: dado que todos los componentes software reutilizables deben apegarse estándares diseño específicos dado que algunos apegan, entonces existe preocupación que (posiblemente) sólo por ciento los módulos reutilizables planeados puedan realmente integrarse sistema que construir, que como resultado necesidad ingeniería medida del restante por ciento los componentes. esta condición general puede refinarse forma siguiente: subcondición . ciertos componentes reutilizables los desarrolló una tercera persona sin conoci-miento los estándares diseño internos. subcondición . estándar diseño para interfaces componente todavía consolida puede apegarse ciertos componentes reutilizables existentes. subcondición . ciertos componentes reutilizables implementaron lenguaje que - porta entorno blanco. las consecuencias asociadas con estas subcondiciones refinadas permanecen iguales ( decir, por ciento componentes software deben someterse ingeniería medida), pero refinamiento ayuda aislar los riesgos subyacentes puede conducir análisis respuestas más sencillos. . itigación , monitoreo manejo riesgo todas las actividades análisis riesgos presentadas hasta momento tienen una sola meta: auxiliar equipo del proyecto desarrollar una estrategia para lidiar con riesgo. una estra-tegia efectiva debe considerar tres temas: ) evitar riesgo, ) monitorear riesgo ) manejar riesgo planificar contingencia. equipo software adopta enfoque proactivo ante riesgo, evitarlo siempre mejor estrategia. esto logra desarrollando plan para mitigación del riesgo. por ejemplo, suponga que una alta rotación personal observa como riesgo proyecto . con base historia intuición administrativa, probabilidad alta rotación estima . ( por ciento, más bien alta) impacto proyecta como crítico, decir, alta rotación tendrá impacto crítico sobre costo calendario del proyecto. para mitigar este riesgo desarrollará una estrategia fin reducir rotación. entre los posibles pasos por tomar están: • reunirse con personal actual para determinar las causas rotación (por ejemplo, pobres condiciones laborales, salario bajo, mercado laboral competitivo). • mitigar aquellas causas que están bajo control antes comenzar proyecto.¿cuál una buena forma describir riesgo?? cita: “ tomo muchas precauciones, porque dejo nada azar.” napoleón ¿qué puede hacerse para mitigar riesgo?? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software • una vez iniciado proyecto, suponer que rotación ocurrirá desarrollar técnicas para asegurar continuidad cuando personal vaya. • organizar equipos trabajo modo que información acerca cada actividad desarrollo disperse ampliamente. • definir estándares producto operativo establecer mecanismos para asegurar que todos los modelos documentos desarrollen forma oportuna. • realizar revisiones pares todo trabajo ( modo que más una persona “ ponga día”). • asignar miembro personal respaldo para cada técnico crítico. conforme avanza proyecto, comienzan las actividades monitoreo riesgos. gerente proyecto monitorea factores que pueden proporcionar indicio riesgo vuelve más menos probable. caso alta rotación personal monitorean: actitud general los miembros del equipo con base presiones del proyecto, grado que equipo cuaja, relaciones interpersonales entre miembros del equipo, potenciales problemas con compen-sación beneficios, disponibilidad empleos dentro compañía fuera ella. además monitorear dichos factores, gerente proyecto debe dar seguimiento efectividad los pasos mitigación del riesgo. por ejemplo, paso mitigación del riesgo anotado aquí requiere definición estándares producto operativo mecanismos para asegurarse que los productos operativos desarrollan forma oportuna. éste meca-nismo para asegurar continuidad caso que individuo crucial deje proyecto. gerente proyecto debe monitorear los productos operativos cuidadosamente para asegurarse que cada uno puede sostenerse por cuenta propia que imparte información que sería necesaria recién llegado fuese forzado unirse equipo software alguna parte medio del proyecto. manejo del riesgo planificación contingencia suponen que los esfuerzos mitigación fracasaron que riesgo convirtió realidad. continuando con ejemplo, proyecto está marcha algunas personas anuncian que renunciarán mismo. siguió estrate-gia mitigación, está disponible respaldo, información documentó conocimiento dispersó través del equipo. además, puede cambiar temporalmente foco los recursos ( reajustar calendario del proyecto) hacia aquellas funciones que tengan personal completo, que permitirá “ponerse día” los recién llegados que deban agregarse equipo. los -dividuos que retiran les pide detener todo trabajo pasar sus últimas semanas “modo transferencia conocimiento”. esto puede incluir captura conocimiento video, desa-rrollo “documentos comentados wikis” / reuniones con otros miembros del equipo que permanecerán proyecto. importante anotar que los pasos mitigación, monitoreo manejo del riesgo (mmmr) incurren costos adicionales para proyecto. por ejemplo, emplear tiempo respaldar cada técnico crucial cuesta dinero. por tanto, parte del manejo riesgos evaluar cuándo los beneficios acumulativos por los pasos mmmr sobrepasan los costos asociados con imple-mentación. esencia, realiza análisis clásico costo-beneficio. los pasos para evitar riesgo debido alta rotación aumentarán tanto costo del proyecto como duración del mismo por estimado por ciento, pero factor costo predominante “respaldo”, administración puede decidir implementar este paso. por otra parte, los pasos para evitar riesgo proyectan para aumentar los costos por ciento duración sólo por ciento, administración probablemente pondrá todo lugar. para proyecto grande pueden identificarse riesgos. para cada uno identifican entre tres siete pasos manejo riesgo, ¡ manejo del riesgo puede convertirse pro-yecto por mismo! por esta razón, debe adaptar riesgo software regla pareto -. experiencia indica que por ciento del riesgo proyecto global ( decir, por para riesgo específico menor que costo mitigación riesgo, intente mitigar riesgo, sino continuar para monitorearlo.consejo (-).indd (-).indd // ::// :: administración del riesgo ciento del potencial para falla del proyecto) puede explicarse por sólo por ciento los riesgos identificados. trabajo realizado durante los primeros pasos del análisis riesgos ayudará determinar cuáles ellos residen ese por ciento (por ejemplo, riesgos que conducen exposición más alta riesgo). por esta razón, algunos los riesgos identificados, valorados proyectados pueden llegar plan mmmr, ubican crucial por ciento (los riesgos con prioridad proyecto más alta). riesgo está limitado proyecto software . pueden ocurrir después que software desarrolló exitosamente que entregó cliente. dichos riesgos por general asocian con las consecuencias falla del software campo. seguridad del software análisis riesgos (por ejemplo, [dun], [her], [lev]) son las actividades aseguramiento calidad del software (capítulo ) que enfocan identificación valoración los riesgos potenciales que pueden afectar software negativa-mente hacer que falle todo sistema. los riesgos pueden identificarse tempranamente proceso ingeniería del software, pueden especificarse características diseño del soft-ware que eliminarán controlarán los riesgos potenciales. . plan mmmr plan proyecto del software puede incluirse una estrategia administración del riesgo, los pasos administración del riesgo pueden organizarse plan mitigación, monitoreo manejo riesgo (mmmr) por separado. plan mmmr documenta todo trabajo realizado como parte del análisis riesgos gerente del proyecto usa como parte del plan pro-yecto global. algunos equipos software desarrollan documento mmmr formal. vez ello, cada riesgo documenta individualmente usando una hoja información riesgo (hir) [wil]. mayoría los casos, hir mantiene con sistema base datos modo las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas que hay esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores.objetivo: objetivo las herramientas manejo riesgo auxiliar equipo proyecto para definir riesgos, valorar impacto probabilidad, monitorear los riesgos largo proyecto software. mecánica: general, las herramientas manejo riesgo auxi- lian identificación riesgos genéricos proporcionar una lista riesgos empresariales proyecto usuales, proporcionar listas verificación otras técnicas “entrevista” que auxilien identifi-cación riesgos específicos del proyecto, asignar probabilidad impacto cada riesgo, apoyar las estrategias mitigación riesgo generar muchos reportes diferentes relacionados con riesgo. herramientas representativas: @risk, desarrollada por palisade corporation ( com), una herramienta análisis riesgo genérico que usa simulación monte carlo para impulsar motor analítico.riskman, distribuida por abs consulting ( com/riskmansoftware/index.html), sistema experto evaluación riesgos que identifica riesgos relacio-nados con proyectos. risk radar, desarrollada por spmn ( ayuda los gerentes proyecto identificar manejar riesgos pro-yecto. risk+, desarrollada por deltek ( integra con microsoft project para cuantificar incertidumbres costo calendario. :primer, desarrollada por grafp technologies ( com), una herramienta genérica web que predice qué puede salir mal proyecto identifica las causas raíz para poten-ciales fallos contramedidas efectivas.herramientas software manejo riesgo (-).indd (-).indd // ::// :: parte cuatro administración proyectos software que entrada creación información, orden prioridad, las búsquedas otros análisis pueden realizarse con facilidad. formato hir ilustra figura .. una vez documentada mmmr comenzado proyecto, inician los pasos mitigación monitoreo del riesgo. como estudió, mitigación del riesgo una actividad que busca evitar problema. monitoreo del riesgo una actividad seguimiento del proyecto con tres objetivos principales: ) valorar los riesgos predichos efecto ocurren, ) asegurar que los pasos para evitar riesgo definidos para riesgo determinado aplican manera -rrecta ) recopilar información que pueda usarse para futuros análisis riesgos. muchos casos, problema que ocurre durante proyecto puede monitorearse más riesgo. otra actividad del monitoreo riesgos intentar asignar orígenes (cuál riesgo causó cuál problema largo del proyecto). . esumen siempre que colectivo cabalga proyecto software, sentido común dicta análisis riesgos. incluso así, mayoría los gerentes proyectos software hacen manera informal superficial, acaso hacen. tiempo que emplea identificar, analizar -nejar riesgo rinde sus frutos muchas formas: menos agitación durante proyecto, una mayor capacidad para monitorear controlar proyecto, confianza que conlleva plani-ficación los problemas antes que presenten.hoja información riesgo fecha: // prob: % impacto: alto riesgo : -- descripción: hecho, sólo por ciento los componentes software calendarizados para reuso integrarán aplicación. funcionalidad restante tendrá que desarrollarse medida. reﬁnamiento/contexto: subcondición : ciertos componentes reutilizables desarrollaron por una tercera persona sin conocimiento los estándares diseño internos.subcondición : estándar diseño para interfaces componente consolidó puede ser que apegue ciertos componentes reutilizables existentes.subcondición : ciertos componentes reutilizables implementaron lenguaje que soportado entorno meta. mitigación/monitoreo: . contactar tercera persona para determinar conformidad con los estándares diseño.. presionar por terminación estándares interfaz; considerar estructura componente cuando decida acerca protocolo interfaz.. comprobar para determinar número componentes categoría subcondición ; comprobar para determinar puede adquirir soporte lenguaje. manejo/plan contingencia/disparador: calculada $ . asignar esta cantidad dentro los costos contingencia del proyecto.desarrollar revisión calendario suponer que componentes adicionales tendrán que construirse medida; asignar personal concordancia.disparador: pasos mitigación improductivos //. estado actual: //: pasos mitigación iniciados. originador: . gagne asignado: . lasterfigura . hoja información riesgo.fuente: [wil]. (-).indd (-).indd // ::// :: administración del riesgo análisis riesgos puede absorber una cantidad significativa del esfuerzo planificación del proyecto. identificación, proyección, valoración, manejo monitoreo, todos requieren tiempo. pero esfuerzo vale pena. para citar sun tzu, general chino que vivió hace años: “ conoces enemigo conoces mismo, necesitas temer resultado cien batallas”. para gerente proyecto software, enemigo riesgo. problemas puntos por evaluar .. proporcione cinco ejemplos otros campos que ilustren los problemas asociados con una estrategia riesgo reactiva. .. describa diferencia entre “riesgos conocidos” “riesgos predecibles”... agregue tres preguntas temas adicionales cada una las listas comprobación ítem riesgo que presentan sitio web esta obra. .. pide construir software para apoyar sistema edición video bajo costo. sistema acepta video digital como entrada, almacena video disco luego permite usuario aplicar una amplia variedad ediciones video digitalizado. después, resultado puede exhibirse mediante dvd otros medios. haga una pequeña cantidad investigación acerca sistemas este tipo luego elabore una lista riesgos tecnológicos que enfrentaría mientras comienza proyecto este tipo. .. usted gerente proyecto una gran compañía software. pide dirigir equipo que desarrolle software procesamiento palabra “próxima generación”. cree una tabla riesgo para proyecto. .. describa diferencia entre componentes riesgo promotores riesgo... desarrolle una estrategia mitigación riesgo actividades específicas mitigación riesgo para tres los riesgos anotados figura .. .. desarrolle una estrategia monitoreo riesgo actividades específicas monitoreo riesgo para tres los riesgos anotados figura .. asegúrese identificar los factores que monitoreará para determinar riesgo vuelve más menos probable. .. desarrolle una estrategia manejo riesgo actividades específicas manejo riesgo para tres los riesgos anotados figura .. .. intente refinar tres los riesgos anotados figura . luego cree hojas información riesgo para cada uno. .. represente tres los riesgos anotados figura . usando formato ctc... vuelva calcular exposición riesgo que estudió sección .. cuando costo/loc $ probabilidad por ciento. .. ¿puede pensar una situación que riesgo con alta probabilidad alto impacto con- siderará como parte plan mmmr? .. describa las cinco áreas aplicación software las que seguridad del software análisis riesgos serían una preocupación principal. lecturas fuentes información adicionales literatura gestión del riesgo software expandió significativamente las décadas anteriores. vun (modeling risk , wiley, ) presenta tratamiento matemático detallado del análisis riesgos que puede aplicarse proyectos software. crohy . (the essentials risk management, mcgraw-hill, ), mul- cahy (risk management, tricks the trade for project managers, rmc publications, inc., ), kendrick (identifying and managing project risk, american management association, ), marrison (the funda- mentals risk measurement, mcgraw-hill, ) presentan métodos herramientas útiles que puede usar todo gerente proyecto. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software demarco lister (dancing with bears, dorste house, ) escribieron entretenido inteligente libro que guía los gerentes profesionales del software través gestión riesgos. moynihan ( coping with / risk management, springer-verlag, ) presenta consejos pragmáticos gerentes proyecto que lidian con riesgo continuamente. royer ( project risk management , management concepts, ) smith merrit ( proactive risk management, productivity press, ) sugieren proceso proactivo para gestión del riesgo. karolak (software engineering risk management, wiley, ) escribió manual que introduce modelo análisis riesgo fácil usar, con valiosas listas comprobación cuestionarios apoyados por paquete software. capers jones (assesment and control software risks , prentice hall, ) presenta detallado análisis los riesgos software, que incluye datos recopilados cientos proyectos software. jones define factores riesgo que pueden afectar resultado los proyectos software. boehm [boe] sugiere excelentes cuestionarios formatos lista verificación que pueden resultar invaluables identifica-ción del riesgo. charette [cha] presenta tratamiento detallado mecánica del análisis riesgos, apoya teoría probabilidad técnicas estadísticas para analizar los riesgos. otro volumen, charette (application strategies for risk analysis , mcgraw-hill, ) analiza riesgo contexto ingeniería sistemas software, sugiere estrategias pragmáticas para gestión del riesgo. gilb ( principles software engineering management, addison-wesley, ) presenta conjunto “principios” (que con frecuencia son entretenidos ocasiones profundos) que pueden servir como una valiosa guía para gestión del riesgo. ewusi-mensah (software development failures: anatomy abandoned projects , mit press, ) your- don (death march, prentice hall, ) estudian que ocurre cuando los riesgos abruman equipo proyecto software. bernstein ( against the gods, wiley, ) presenta una entretenida historia del riesgo, que remonta tiempos antiguos. software engineering institute publicó muchos reportes detallados manuales acerca del análisis gestión del riesgo. panfleto afscp - del air force systems command [afc] describe identifica-ción del riesgo técnicas para reducción. cada tema del acm software engineering notes tiene una sección titulada “riesgos para público” (editor, . . neumann). quiere las más recientes mejores historias horror del software, éste lugar que debe . internet está disponible una gran variedad fuentes información acerca gestión del riesgo software. una lista actualizada referencias world wide web que son relevantes para gestión del riesgo puede encontrarse sitio del libro: sional/olc/ser.htm (-).indd (-).indd // ::// :: reingeniería conceptos clave análisis inventarios. . . . . ingeniería hacia adelante . . . inversa . . . . . . . . datos . . . . . . . . . . . . . . . . procesamiento . . . . . . . . . interfaces usuario . . . . . mantenibilidad . . . . . . . . . . software . . . . . . . . . . código . . . . . . . . . . . . . . . datos . . . . . . . . . . . . . . . . reestructuración documentos . . . . . . . . . . reingeniería procesos empresa (rpe) . . . . . . . . reingeniería software . . . . . . . . . . . . . . ¿qué ? considere cualquier producto tec- nológico que haya funcionado bien. usa con regularidad, pero está envejeciendo. descompone con frecuencia, tarda más tiem- reparar del que quisiera representa más reciente tecnología. ¿qué hacer? durante algún tiempo intenta repararlo, parcharlo, incluso extiende funciona-lidad. esto llama mantenimiento. pero éste vuel- cada vez más difícil conforme pasan los años. llega momento que necesitará reconstruirlo. creará producto con funcionalidad agregada, mejor desempeño confiabilidad, así como mantenibilidad mejorada. eso llama reingeniería. ¿quién hace? nivel organización, mante- nimiento realiza personal apoyo que parte organización ingeniería software. reingenie-ría realizan especialistas negocios (con frecuencia compañías consultoras). nivel software, reinge-niería realizan ingenieros software. ¿por qué importante? vivir mundo que cam- bia rápidamente, las demandas sobre las funciones empre-sariales tecnología información que las apoyan cambian paso que pone enorme presión competitiva sobre toda organización comercial. por esto, software debe mantenerse continuamente , momento adecua-, someterse reingeniería para sostener paso.¿cuáles son los pasos? mantenimiento corrige los defectos, adapta software para satisfacer entorno cambiante mejorar funcionalidad fin cubrir las necesidades evolutivas los clientes. estratégicamente, reingeniería procesos empresa (rpe) define las metas empresariales, identifica evalúa los procesos empresariales existentes crea procesos empresariales -visados que satisfacen mejor las metas del momento. reingeniería software abarca análisis inventarios, res-tructuración documentos, ingeniería inversa, reestructu-ración programas datos ingeniería hacia adelante. intención dichas actividades crear versiones los programas existentes que muestren mayor calidad mejor mantenibilidad. ¿cuál producto final? producen varios produc- tos operativos mantenimiento reingeniería (por ejem-plo, casos uso, modelos análisis diseño, procedi-mientos prueba). resultado final actualización software. ¿cómo aseguro que hice bien? con uso las mismas prácticas sqa que aplican todo pro-ceso ingeniería software: revisiones técnicas para valorar los modelos análisis diseño; revisiones espe-cializadas para considerar aplicabilidad compatibilidad empresarial; aplicación pruebas para descubrir erro-res contenido, funcionalidad interoperabilidad. una mirada rápidasin importar dominio aplicación, tamaño complejidad, software compu- tadora evolucionará con tiempo. cambio impulsa este proceso. para software computadora, cambio ocurre cuando corrigen los errores, cuando software adapta nuevo entorno, cuando cliente solicita nuevas características funciones cuando aplicación somete reingeniería para ofrecer beneficio contexto moderno. durante los pasados años, manny lehman [por ejemplo, leh] sus colaboradores reali-zaron análisis detallados software grado industrial sistemas con intención -sarrollar una teoría unificada para evolución del software . los detalles este trabajo están más allá del ámbito este libro, pero vale pena destacar las leyes subyacentes derivadas ella [leh]: ley cambio continuo (): software que implementó contexto cómputo del mundo real que, por tanto, evolucionará con tiempo (llamados sistemas tipo ) debe adaptarse continuamente otro modo volverá progresivamente menos satisfactorio. ley complejidad creciente (): conforme sistema tipo evoluciona, complejidad aumenta, menos que haga trabajo para mantenerlo reducirlo. ley autorregulación (): proceso evolución del sistema tipo autorregulable con medidas distribución producto proceso cercanas normal. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software ley conservación estabilidad organizativa (): tasa actividad global efectiva promedio sistema tipo evolución varía durante tiempo vida del producto. ley conservación familiaridad (): conforme sistema tipo evoluciona, todo asociado con : desarrolladores, personal ventas, usuarios, etc., deben mantener dominio contenido comportamiento para lograr evolución satisfactoria. crecimiento excesivo disminuye dicho dominio. por tanto, crecimiento incremental promedio permanece sin variación conforme sistema evoluciona. ley crecimiento continuo (): contenido funcional los sistemas tipo debe aumen- tar continuamente para mantener satisfacción del usuario durante tiempo vida. ley declive calidad (): calidad los sistemas tipo declinará, menos que mantengan adapten rigurosamente los cambios del entorno operativo. ley realimentación del sistema (): los procesos evolutivos tipo constituyen sistemas realimentación multinivel, multibucle multiagente, deben tratarse como tales para lograr mejora significativa sobre cualquier base razonable. las leyes que definieron lehman sus colegas son parte inherente una realidad inge- niería software. este capítulo estudia reto del mantenimiento del software las -tividades reingeniería que requieren para extender vida efectiva los sistemas here-dados. . antenimiento software éste comienza casi inmediato. software libera los usuarios finales , cuestión días, los reportes errores filtran vuelta hacia organización ingeniería software. semanas, una clase usuarios indica que software debe cambiarse modo que pueda ajustarse las necesidades especiales entorno. meses, otro grupo corporativo, que quería saber nada del software cuando liberó, ahora reconoce que puede ofrecerle bene-ficios inesperados. necesitará algunas mejoras para hacer que funcione mundo. reto del mantenimiento del software comienza. uno enfrenta con una creciente lista corrección errores, peticiones adaptación mejoras categóricas que deben planearse, calendarizarse , final cuentas, lograrse. mucho antes, fila creció bastante trabajo que implica amenaza con abrumar los recursos disponibles. conforme pasa tiempo, orga-nización descubre que emplea más dinero tiempo mantener los programas existentes que someter ingeniería nuevas aplicaciones. hecho, raro que una organización software emplee entre por ciento todos sus recursos mantenimiento del soft-ware. acaso lector pregunte por qué requiere tanto mantenimiento por qué emplea tanto esfuerzo. osborne chikofsky [osb] proporcionan una respuesta parcial: mucho del software del que dependemos actualidad tiene promedio una antigüedad años. aun cuando dichos programas crearon usando las mejores técnicas diseño codifica-ción conocidas época [ muchas fueron], produjeron cuando tamaño del programa espacio almacenamiento eran las preocupaciones principales. luego migraron nuevas plata-formas, ajustaron para cambios máquina tecnología sistema operativo, aumentaron para satisfacer las necesidades los nuevos usuarios, todo sin suficiente preocupación por arquitectura global. resultado estructuras pobremente diseñadas, pobre codificación, pobre lógica pobre documentación los sistemas software que ahora debemos seguir usando... otra razón del problema del mantenimiento del software movilidad del personal. pro- bable que equipo ( persona) software que hizo trabajo original esté más por ahí. peor aún, otras generaciones personal software modificaron sistema mudaron. ¿cómo evolucionan los sistemas heredados conforme pasa tiempo?? (-).indd (-).indd // ::// :: mantenimiento reingeniería puede ser que quede alguien que tenga algún conocimiento directo del sistema here- dado. como anotó capítulo , naturaleza ubicua del cambio subyace todo trabajo del software. cambio inevitable cuando construyen sistemas basados computadoras; por tanto, deben desarrollarse mecanismos para evaluar, controlar realizar modificaciones. largo este libro enfatiza importancia entender problema (análisis) desarrollar una solución bien estructurada (diseño). hecho, parte del libro dedica mecánica tales acciones ingeniería software enfoca las técnicas requeridas para asegurarse que hicieron correctamente. análisis diseño conducen una importante característica del software que llamará mantenibilidad. esencia, mantenibilidad indicio cualitativo facilidad con que software existente puede corregirse, adaptarse aumentarse. gran parte que trata ingeniería software acerca construcción sistemas que muestren alta mantenibilidad. ¿pero qué mantenibilidad? software mantenible muestra modularidad efectiva (capítulo ). usa patrones diseño (capítulo ) que permiten facilidad comprensión. construyó con estándares convenciones codificación bien definidos, que conducen código fuente autodocumentable comprensible. experimentó varias técnicas aseguramiento calidad (parte este libro) que descubrieron potenciales problemas mantenimiento antes que software liberara. fue creado por ingenieros software que reconocen que acaso estén presentes cuando deban realizarse cambios. consecuencia, diseño implementa-ción del software debe “auxiliar” persona que realice cambio. . oportabilidad del software con finalidad dar soporte efectivo software grado industrial, organización ( encargado) deben poder realizar las correcciones, adaptaciones mejoras que son parte actividad mantenimiento. pero, además, organización debe proporcionar otras importan-tes actividades soporte que incluyen soporte operativo marcha, soporte usuario final actividades reingeniería durante ciclo vida completo del software. una definición razo-nable soportabilidad del software … capacidad dar soporte sistema software durante toda vida del producto. esto implica satisfacer cualquier necesidad requisito, pero también provisión equipo, infraestructura -porte, software adicional, instalaciones, mano obra cualquier otro recurso requerido para man-tener software operativo capaz satisfacer función [sso]. esencia, soportabilidad uno los muchos factores calidad que deben conside- rarse durante las acciones análisis diseño que son parte del proceso software. deben abordarse como parte del modelo ( especificación) requisitos considerarse conforme diseño evoluciona comienza construcción. por ejemplo, necesidad software “antierrores” nivel componente código estudió anteriormente este libro. software debe contener facilidades para auxiliar per-sonal apoyo cuando encuentre defecto entorno operativo ( cometer equí-vocos, encontrarán los defectos). además, personal apoyo debe tener acceso una base datos que contenga registros todos los defectos que encontraron: sus características, causas cura. esto permitirá personal apoyo examinar defectos “similares” poder brindar medio para diagnóstico corrección más rápidos. existen algunas medidas cuantitativas que proporcionan indicio indirecto mantenibilidad (ver, por ejem- plo, [sch], [sei]).cita: “mantenibilidad comprensión programa son conceptos paralelos: mientras más difícil sea entender programa, más difícil será darle mantenimien-.” gerald berns webref supportability.org/downloads.html, puede encontrar una amplia variedad documentos descargables acerca soportabilidad del software. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software aunque los defectos encontrados una aplicación son tema soporte crucial, sopor- tabilidad también demanda que proporcionen recursos para dar soporte diario los conflictos del usuario final. labor del personal soporte usuario final responder las consultas del usuario acerca instalación, operación uso aplicación. . eingenería artículo fundamental escrito para harvard business review, michael hammer [ham] sienta las bases para una revolución pensamiento administrativo acerca los procesos empresariales computación: momento dejar pavimentar camino las vacas. lugar incrustar procesos caducos silicio software, debemos eliminarlos comenzar nuevo. debemos “reingeniar” nuestras -presas: usar poder moderna tecnología información para rediseñar radicalmente nuestros procesos empresariales con finalidad lograr mejoras dramáticas rendimiento. toda compañía opera acuerdo con gran número reglas desarticuladas [...] reingeniería lucha por liberarse las antiguas reglas acerca cómo organizarnos dirigir nuestros negocios. como toda revolución, llamado las armas hammer resultó cambios tanto positivos como negativos. durante los años , algunas compañías hicieron esfuerzo legítimo por someterse reingeniería los resultados condujeron mejora competitiva. otros apoya-ron exclusivamente reducción subcontratación ( lugar reingeniería) para mejorar línea referencia. con frecuencia resultaron organizaciones “medias” con poco potencial para crecimiento futuro [dem]. hacia finales primera década del siglo xxi, publicidad relacionada con reingeniería disminuyó, pero proceso continúa las compañías grandes pequeñas. nexo entre reingeniería empresarial ingeniería software yace una “visión sistema”. con frecuencia, software realización las reglas empresariales que hammer analiza. actualidad, las principales compañías tienen decenas miles programas cómputo que soportan las “antiguas reglas empresariales”. conforme los administradores trabajan para modificar las reglas fin lograr mayor efectividad competitividad, software debe seguir-les paso. algunos casos, esto significa creación grandes novedosos sistemas basa-dos cómputo. pero muchos otros, significa modificación reconstrucción las apli- caciones existentes. las secciones que siguen, examina reingeniería una forma descendente, comen- zando con breve panorama reingeniería los procesos empresas avanzando hacia análisis más detallado las actividades técnicas que ocurren cuando software somete reingeniería. . eingeniería procesos empresa reingeniería procesos empresa (rpe) extiende más allá del ámbito las tecnologías información ingeniería software. entre las muchas definiciones ( mayoría tanto abstractas) que han sugerido para rpe, está una publicada fortune magazine [ste]: “ búsqueda, implementación, cambios radicales los procesos las empresas para lograr resultados innovadores”. ¿pero cómo realiza búsqueda cómo logra -plementación? más importante, ¿cómo puede asegurarse que “cambio radical” sugerido con-ducirá realmente “resultados innovadores” lugar caos organizacional?cita: “enfrentar mañana con pensamiento puesto usar los métodos ayer vislumbrar vida paralizado.” james bell explosión las aplicaciones sistemas basados web indicativo esta tendencia.punto clave rpe con frecuencia como resultado nueva funcionalidad software, mientras que reingeniería software trabaja para sustituir funcionalidad software existente con software mejor más mantenible. (-).indd (-).indd // ::// :: mantenimiento reingeniería .. procesos empresariales proceso empresarial “ conjunto tareas lógicamente relacionadas, que realizan para lograr resultado empresarial definido” [dav]. dentro del proceso empresarial, perso-nal, equipo, recursos materiales procedimientos empresariales combinan para producir resultado específico. los ejemplos procesos empresariales incluyen diseñar nuevo pro-ducto, comprar servicios suministros, contratar nuevo empleado pagar proveedores. cada uno demanda conjunto tareas usa diversos recursos dentro empresa. todo proceso empresarial tiene cliente definido: una persona grupo que recibe resul- tado (por ejemplo, una idea, reporte, diseño, servicio, producto). además, los pro-cesos empresariales atraviesan las fronteras organización. requieren que diferentes gru-pos organizativos participen las “tareas lógicamente relacionadas” que definen proceso. todo sistema realidad una jerarquía subsistemas. una empresa excepción. toda empresa está segmentada forma siguiente: empresa → sistemas empresariales → procesos empresariales → subprocesos empresariales cada sistema empresarial (también llamado función empresarial) está compuesto uno más procesos empresariales, cada proceso empresarial define mediante conjunto subpro-cesos. rpe puede aplicarse cualquier nivel jerarquía, pero conforme ensancha ámbito ( decir, conforme avanza hacia arriba jerarquía), los riesgos asociados con rpe crecen manera dramática. por esta razón, mayoría los esfuerzos rpe enfocan procesos subprocesos individuales. .. modelo rpe como mayoría las actividades ingeniería, reingeniería procesos empresa iterativa. las metas empresa los procesos que los logran deben adaptarse entorno empresarial cambiante. por esta razón, hay inicio fin rpe: proceso evolutivo. figura . muestra modelo para reingeniería proceso empresa. modelo define seis actividades:como ingeniero software, trabajo realiza fondo esta jerarquía. sin embargo, asegúrese que alguien considera seriamente los niveles superiores. esto hecho, trabajo está riesgo.consejo deﬁnición empresa reﬁnamiento ejempliﬁcación prototipo especiﬁcación diseño procesosidentiﬁcación procesos evaluación procesosfigura . modelo rpe (-).indd (-).indd // ::// :: parte cuatro administración proyectos software definición empresa. las metas empresa identifican dentro del contexto cuatro motores clave: reducción costo, reducción tiempo, mejora calidad -sarrollo fortalecimiento del personal. las metas pueden definirse para toda empresa para componente específico ella. identificación procesos. identifican los procesos que son cruciales para lograr las metas definidas definición empresa. luego pueden clasificarse por importancia, por necesidad para cambiar cualquier otra forma que sea adecuada para actividad reingeniería. evaluación procesos. los procesos existentes analizan miden ampliamente. identifican las tareas proceso, anotan los costos tiempo consumido por ellas aíslan los problemas calidad/desempeño. especificación diseño procesos. con base información obtenida durante las primeras tres actividades rpe, preparan casos uso (capítulos ) para cada proceso que deba someterse reingeniería. dentro del contexto rpe, los casos uso identifi-can escenario que entrega algún resultado cliente. con caso uso como -pecificación del proceso, diseña nuevo conjunto tareas para proceso. prototipo. proceso empresarial rediseñado debe convertirse prototipo antes que integre plenamente empresa. esta actividad “pone prueba” proceso, modo que puedan hacerse refinamientos. refinamiento ejemplificación. con base realimentación del prototipo, proceso empresarial refina luego ejemplifica dentro sistema empresarial. ocasiones, dichas actividades rpe usan conjunto con herramientas análisis flujo trabajo. intención dichas herramientas construir modelo del flujo trabajo exis-tente con intención analizar mejor los procesos actuales. cita: “tan pronto como algo viejo nos muestra forma novedo-, nos pacificamos.” . . nietzsche las herramientas que mencionan aquí representan respaldo, sino que son una muestra las herra- mientas que hay esta categoría. mayoría los casos, los nombres las herramientas son marcas - gistradas por sus respectivos desarrolladores.objetivo: objetivo las herramientas rpe dar soporte análisis valoración los procesos empresa- riales existentes, especificación diseño nuevos. mecánica: mecánica las herramientas varía. general, las herramientas rpe permiten analista empresarial modelar los pro-cesos empresariales existentes con intención valorar las inefi-ciencias del flujo trabajo problemas funcionales. una vez identi-ficados los problemas existentes, las herramientas permiten análisis para crear prototipos / simular procesos empresariales revisados. herramientas representativas: extend, desarrollada por imaginethat, inc. ( tinc.com), una herramienta simulación para modelar pro- cesos existentes explorar nuevos. extend proporciona abundante capacidad “ …”, que permite analista empresarial explo-rar diferentes escenarios proceso.-work, desarrollada por metastorm ( proporciona soporte gestión procesos empresariales para procesos tanto manuales como automatizados. icetools, desarrollada por blue ice ( una colección plantillas rpe para microsoft office microsoft pro-ject. speedev, desarrollada por speedev inc. ( una muchas herramientas que permiten una organización modelar flujo trabajo procesos ( este caso, flujo traba- ). workflow tool suite, desarrollada por metasoftware ( software.com), incorpora una suite herramientas para modelado, simulación calendarización flujo trabajo.una útil lista ligas herramientas rpe puede encontrarse software reingeniería procesos empresa (rpe) (-).indd (-).indd // ::// :: mantenimiento reingeniería . eingeniería software escenario demasiado común: una aplicación que atendió las necesidades empresariales una compañía durante años. durante ese tiempo corrigió, adaptó mejoró muchas veces. las personas realizaban esta tarea con las mejores intenciones, pero las buenas prácti-cas ingeniería siempre hicieron lado (debido presión otros asuntos). ahora aplicación inestable. todavía funciona, pero cada vez que intenta cambio, ocurren -esperados serios efectos colaterales. aun así, aplicación debe seguir evolucionando. ¿qué hacer? software sin mantenimiento problema nuevo. hecho, énfasis ampliado acerca reingeniería software produjo por los problemas mantenimiento soft-ware que acumularon durante más cuatro décadas. .. modelo proceso reingeniería software reingeniería toma tiempo, cuesta cantidades significativas dinero absorbe recursos que otro modo pueden ocuparse preocupaciones inmediatas. por todas estas razones, rein-geniería logra pocos meses incluso algunos años. reingeniería los sistemas información una actividad que absorberá recursos tecnología información durante muchos años. por esto, toda organización necesita una estrategia pragmática para reingenie-ría software. una estrategia factible contempla modelo proceso reingeniería. más tarde, esta sección, estudiará modelo, pero primero presentan algunos principios básicos. reingeniería una actividad reconstrucción. para entenderla mejor, piense una actividad análoga: reconstrucción una casa. considere siguiente situación. usted com-pra una casa otro estado. realidad nunca visto propiedad, pero adquirió precio sorprendentemente bajo, con advertencia que posible que deba reconstruirla por completo. ¿cómo procedería? • antes comenzar reconstruir, parecería razonable inspeccionar casa. para deter- minar necesita reconstruirse, usted ( inspector profesional) crea una lista criterios, modo que inspección sea sistemática. • antes demoler reconstruir toda casa, asegúrese que estructura débil. casa estructuralmente sólida, acaso sea posible “remodelar” sin reconstruir ( costo mucho más bajo mucho menos tiempo). • antes comenzar reconstruir, asegúrese entender cómo construyó original. eche vistazo detrás las paredes. entienda cómo están alambrado, plomería estructura interna. incluso tira todo basura, comprensión que obtenga servirá cuando comience construcción. • comienza reconstruir, use solamente los materiales más modernos más duraderos. esto puede costar poco más ahora, pero ayudará evitar costos tardados mantenimientos posteriores. • decide reconstruir, sea disciplinado ello. use prácticas que resultarán alta calidad, hoy futuro. aunque estos principios enfocan reconstrucción una casa aplican igualmente bien reingeniería los sistemas aplicaciones basados cómputo. para implementar estos principios puede usar modelo proceso reingeniería soft- ware que defina seis actividades, como muestra figura .. algunos casos, dichas actividades ocurren secuencia lineal, aunque siempre. por ejemplo, posible que tenga que recurrir ingeniería inversa (comprender funcionamiento interno pro-grama) antes que pueda comenzar reestructuración documentos.webref una excelente fuente información acerca reingeniería software puede encontrarse reengineer.org (-).indd (-).indd // ::// :: parte cuatro administración proyectos software .. actividades reingeniería software paradigma reingeniería que muestra figura . modelo cíclico. esto significa que cada una las actividades presentadas como parte del paradigma puede revisarse. para algún ciclo particular, proceso puede terminar después cualquiera estas actividades. análisis inventarios. toda organización software debe tener inventario todas las aplicaciones. ventario puede ser nada más que modelo hojas cálculo que contenga información que ofrezca una descripción detallada (por ejemplo, tamaño, edad, importan- cia empresarial) cada aplicación activa. ordenar esta información acuerdo con impor-tancia empresarial, longevidad, mantenibilidad actual, soportabilidad otros importantes crite-rios locales, aparecen los candidatos para reingeniería. entonces pueden asignarse recursos esas aplicaciones. importante observar que inventario debe revisarse con regularidad. estado las aplicaciones (por ejemplo, importancia empresarial) puede cambiar con tiempo , como -sultado, cambiarán las prioridades para aplicar reingeniería. reestructuración documentos. documentación débil distintivo muchos siste-mas heredados. pero, ¿qué puede hacer con ella? ¿cuáles son sus opciones? . creación documentación consume demasiado tiempo . sistema funciona puede elegir vivir con que tiene. algunos casos, éste enfoque correcto. posi-ble volver crear documentación para cientos programas cómputo. pro-grama relativamente estático, aproxima final vida útil improbable que experimente cambio significativo, ¡déjelo así! . documentación debe actualizarse, pero organización tiene recursos limitados. use enfoque “documente cuando toque”. acaso sea necesario volver documentar por completo una aplicación. vez ello, aquellas porciones del sistema que -mento experimenten cambio documentan por completo. con tiempo, evolucionará una colección documentación útil relevante. . sistema tiene importancia empresarial debe volver documentarse por completo. incluso este caso, enfoque inteligente recortar documentación mínimo esencial.ingeniería hacia adelante reestructuración documentos ingeniería inversaanálisis inventarios reestructuración datos reestructuración códigofigura . modelo proceso reingeniería software tiempo los recursos son escasos, puede considerar aplicación del principio pareto software que someterá reingeniería. aplique proceso reingeniería por ciento del software que represente por ciento los problemas.consejo cree sólo tanta documentación como necesite para entender software, una página más.consejo (-).indd (-).indd // ::// :: mantenimiento reingeniería cada una estas opciones viable. organización software debe elegir aquella que sea más adecuada para cada caso. ingeniería inversa. término ingeniería versa tiene origen mundo del hardware. una compañía desensambla producto hardware otra empresa con intención entender los “secretos” diseño fabricación competidor. dichos secretos podrían entenderse fácilmente obtuvieran las especificaciones diseño fabricación. pero esos documentos son propiedad empresa competidora están disponibles para compañía que hace ingeniería inversa. esencia, ingeniería inversa exitosa deriva una más especificacio-nes diseño fabricación para producto examinar especímenes reales del mismo. ingeniería inversa para software muy similar. obstante, mayoría los casos, programa que someter ingeniería inversa competidor: propio tra-bajo compañía (con frecuencia, elaborado muchos años atrás). los “secretos” por entender son oscuros porque jamás desarrollaron especificaciones. por tanto, ingeniería inversa para software proceso analizar programa con intención crear una representa-ción del mismo nivel superior abstracción que código fuente. ingeniería inversa proceso recuperación diseño. las herramientas ingeniería inversa extraen infor- mación diseño datos, arquitectónico procedimental programa existente. reestructuración código. tipo más común reingeniería ( realidad, este caso cuestionable uso del término reingeniería) reestructur ación código. algunos siste- mas heredados tienen una arquitectura programa relativamente sólida, pero los módulos individuales fueron codificados una forma que los hace difíciles entender, poner prueba mantener. tales casos, código dentro los módulos sospechosos puede reestructu-rarse. para realizar esta actividad analiza código fuente con una herramienta reestructura- ción. las violaciones los constructos programación estructurada anotan luego -digo reestructura (esto puede hacerse automáticamente) incluso reescribe len-guaje programación más moderno. código reestructurado resultante revisa pone prueba para garantizar que introdujeron anomalías. documentación código interna actualiza. reestructuración datos. programa con arquitectura datos débil será difícil adap- tar mejorar . hecho, para muchas aplicaciones, arquitectura información tiene más que ver con viabilidad largo plazo programa que con código fuente . diferencia reestructuración código, que ocurre nivel abstracción relativa- mente bajo, reestructuración datos una actividad reingeniería gran escala. mayoría los casos, reestructuración los datos comienza con una actividad ingeniería inversa. arquitectura datos existente diseca definen modelos datos necesarios (capítulos ). identifican los objetos atributos datos, revisa calidad las -tructuras datos existentes. cuando estructura datos débil (por ejemplo, implementan archivos planos, cuando enfoque relacional simplificaría enormemente procesamiento), los datos some-ten reingeniería. puesto que arquitectura datos tiene una fuerte influencia sobre arquitectura del pro- grama sobre los algoritmos que los pueblan, los cambios los datos invariablemente resulta-rán cambios arquitectónicos nivel código.webref projects/renaissanceweb/, puede encontrar varios recursos para comunidad reingeniería. reestructuración código tiene algunos los elementos “refactorización”, concepto rediseño introducido capítulo estudiado otras partes este libro. (-).indd (-).indd // ::// :: parte cuatro administración proyectos software ingeniería hacia adelante. mundo ideal, las aplicaciones reconstruirían usando “motor reingeniería” automático. programa antiguo alimentaría motor , anali- zaría, reestructuraría luego regeneraría manera que mostrara los mejores aspectos calidad del software. corto plazo improbable que tal “motor” aparezca, pero los pro-veedores introdujeron herramientas que proporcionan subconjunto limitado dichas capa-cidades que abordan dominios aplicación específicos (por ejemplo, aplicaciones que implementan usando sistema base datos específico). más importante, dichas herra-mientas reingeniería vuelven cada vez más sofisticadas. ingeniería hacia adelante sólo recupera información diseño del software existente, sino que también usa esta información para alterar reconstituir sistema existente con intención mejorar calidad global. mayoría los casos, software sometido rein-geniería vuelve implementar función del sistema existente también añade nuevas funcio-nes / mejora rendimiento global. . ngeniería inversa ingeniería inversa conjura una imagen “rendija mágica”. usted alimenta rendija archivo fuente sin documentar, diseñado manera fortuita, del otro lado sale una descrip-ción documentación completas del diseño para programa cómputo. por desgracia, rendija mágica existe. ingeniería inversa puede extraer información diseño partir del código fuente, pero nivel abstracción, completitud documentación, grado que las herramientas analista humano trabajan conjunto, direccionalidad del pro-ceso son enormemente variables. nivel abstracción proceso ingeniería inversa las herramientas usadas para efectuarla tienen que ver con sofisticación información diseño que puede extraerse del código fuente. manera ideal, nivel abstracción debe ser tan alto como sea posible, decir, proceso ingeniería inversa debe ser capaz inferir representaciones diseño procedimental (una abstracción bajo nivel), información estructura programa datos ( nivel abstracción poco más alto), modelos objeto, modelos datos / flujo control ( nivel abstracción relativamente alto) modelos relación entidad ( nivel abstracción alto). conforme aumenta nivel abstracción proporciona información que permitirá facilitar comprensión del programa. completitud proceso ingeniería inversa refiere nivel detalle que pro- porciona nivel abstracción. mayoría los casos, completitud disminuye con-forme aumenta nivel abstracción. por ejemplo, dada una lista código fuente, relati-vamente sencillo desarrollar una representación diseño procedimental completa. también pueden inferirse representaciones diseño arquitectónico simples, pero mucho más difícil desarrollar conjunto completo diagramas modelos uml. completitud mejora proporción directa cantidad análisis realizado por per- sona que efectúa ingeniería inversa. interactividad tiene que ver con grado que ser humano “integra” con las herramientas automatizadas para crear proceso ingenie-ría inversa efectivo. mayoría los casos, conforme aumenta nivel abstracción, interactividad debe aumentar decaerá completitud. direccionalidad del proceso ingeniería inversa una vía, toda información - traída del código fuente proporciona ingeniero software que luego puede usarla, durante cualquier actividad mantenimiento. direccionalidad dos vías, información alimenta una herramienta reingeniería que intenta reestructurar regenerar programa antiguo. (-).indd (-).indd // ::// :: mantenimiento reingeniería proceso ingeniería inversa representa figura .. antes poder comenzar las actividades ingeniería inversa, código fuente estructurado (“sucio”) reestructura (sección ..) modo que sólo contenga los constructos programación estructurados. esto hace que código fuente sea más fácil leer que proporcione base para todas las actividades ingeniería inversa posteriores. núcleo ingeniería inversa radica una actividad llamada extracción abstracciones. debe evaluar programa antiguo , partir del código fuente (con frecuencia documentado), desarrollar una especificación significativa del procesamiento que realiza, interfaz usuario que aplica las estructuras datos del programa base datos que usa. .. ingeniería inversa para comprender datos ingeniería inversa datos ocurre diferentes niveles abstracción con frecuencia primera tarea reingeniería. nivel del programa, las estructuras datos internas del programa con frecuencia deben someterse ingeniería inversa como parte esfuerzo reingeniería global. nivel del sistema, las estructuras datos globales (por ejemplo, -chivos, bases datos) con frecuencia someten reingeniería para acomodar nuevos para-digmas administración base datos (por ejemplo, moverse archivo plano siste-mas bases datos relacionales orientadas objetos). ingeniería inversa las estructuras datos globales actuales monta escenario para introducción una nueva base datos todo sistema. estructuras datos internas. las técnicas ingeniería inversa para datos internos del programa enfocan definición clases objetos. esto logra examinar código del programa con intención agrupar variables del programa relacionadas. muchos -figura . proceso ingeniería inversa webref útiles recursos para “recuperación diseño comprensión programa” pueden encontrarse wwwsel.iit.nrc./projects//.html código puede reestructurarse usando motor reestructuración, una herramienta que reestructura código fuente. algunos casos, primera actividad reingeniería intenta construir diagrama clase uml.consejo enfoque ingeniería inversa para datos para software convencional sigue una ruta análoga: ) construir modelo datos, ) identificar atributos objetos datos ) definir relaciones.consejoreﬁnamiento simpliﬁcación especiﬁcación ﬁnalextracción abstracciones especiﬁcación inicialreestructuración código código fuente limpiocódigo fuente sucio base datosinterfazproce- samiento (-).indd (-).indd // ::// :: parte cuatro administración proyectos software sos, organización datos dentro del código identifica tipos datos abstractos. por ejemplo, registro estructuras, archivos, listas otras estructuras datos con frecuencia propor-ciona indicador inicial clases. estructura base datos. sin importar organización lógica estructura física, una base datos permite definición objetos datos soporta algún método para esta- blecer relaciones entre los objetos. por tanto, reingeniería esquema base datos otro nuevo requiere comprender los objetos existentes sus relaciones. puede usar los siguientes pasos [pre] para definir modelo extracción datos como precursor reingeniería nuevo modelo base datos: ) construir modelo objeto inicial, ) determinar claves candidatas (los atributos examinan para determinar usan para apuntar hacia otro registro tabla; los que funcionan como punteros con vierten clases candidatas), ) refinar las clases tentativas, ) definir generalizaciones ) descubrir asociaciones usando técnicas que sean análogas enfoque crc. una vez que conoce información definida los pasos anteriores, puede aplicarse una serie transformaciones [pre] para mapear antigua estructura base datos una nueva estructura. .. ingeniería inversa para entender procesamiento ingeniería inversa para entender procesamiento comienza con intento por compren-der luego extraer abstracciones procedimentales representadas mediante código fuente. para comprender las abstracciones procedimentales analiza código varios niveles abstracción: sistema, programa, componente, patrón enunciado. funcionalidad global todo sistema aplicación debe entenderse antes que ocurra trabajo ingeniería inversa más detallado. esto establece contexto para mayor análisis proporciona comprensión acerca los conflictos interoperabilidad entre aplicaciones dentro del sistema. cada uno los programas que constituyen sistema aplicación repre-senta una abstracción funcional nivel alto detalle. crea diagrama bloques, que representa interacción entre dichas abstracciones funcionales. cada componente realiza alguna subfunción representa una abstracción procedimental definida. desarrolla una -rrativa procesamiento para cada componente. algunas situaciones, existen especifica-ciones sistema, programa componente. cuando éste caso, las especificaciones revisan para conformarse con código existente. las cosas vuelven más complejas cuando considera código dentro compo- nente. debe buscar secciones código que representen patrones procedimentales genéricos. casi todo componente, una sección código prepara los datos para procesamiento (dentro del módulo), una sección diferente del código realiza procesamiento otra prepara los resul-tados del procesamiento para exportarlos desde componente. dentro cada una esas secciones, pueden encontrarse patrones más pequeños; por ejemplo, validación datos comprobación enlaces que con frecuencia ocurren dentro sección código que pre-para los datos para procesamiento. para sistemas grandes, ingeniería inversa por general logra usando enfoque semiautomatizado. posible usar herramientas automatizadas para auxiliarse compren- sión semántica del código existente. salida este proceso pasa entonces reestruc-turación herramientas ingeniería hacia adelante fin completar proceso reinge-niería. con frecuencia, las especificaciones escritas anteriormente, historia vida del programa, nunca actua- lizan. conforme realizan cambios, código congruente con especificación.cita: “existe una pasión por com- prensión, así como existe una pasión por música. dicha pasión más bien común los niños, pero pierde mayoría gente tiempo des-pués.” albert einstein (-).indd (-).indd // ::// :: mantenimiento reingeniería .. ingeniería inversa interfaces usuario las gui (interfaces usuario gráficas) sofisticadas han vuelto obligatorias para productos sistemas basados computadora todo tipo. por tanto, redesarrollo las interfaces usuario convertido uno los tipos más comunes actividad reingeniería. pero antes poder reconstruir una interfaz usuario, debe realizarse ingeniería inversa. para comprender completamente una interfaz usuario existente, deben especificarse estructura comportamiento interfaz. merlo . [mer] sugieren tres preguntas bási- cas que deben responderse conforme comienza ingeniería inversa . • ¿cuáles son las acciones básicas (por ejemplo, golpes tecla clics ratón) que debe procesar interfaz? • ¿cuál descripción compacta respuesta comportamiento del sistema dichas acciones? • ¿qué entiende por “reemplazo” , más precisamente, qué concepto equivalencia interfaces relevante aquí? notación modelado comportamiento (capítulo ) puede proporcionar medio para desarrollar respuestas las primeras dos preguntas. mucha información necesaria - crear modelo comportamiento puede obtenerse observar manifestación externa interfaz existente. pero información adicional necesaria para crear modelo compor-tamiento debe extraerse del código. importante observar que reemplazo gui puede reflejar con exactitud antigua interfaz ( hecho, puede ser radicalmente diferente). con frecuencia, vale pena desarrollar una nueva metáfora interacción. por ejemplo, una antigua solicita que usuario propor-cione factor escala (que ) para encoger ampliar una imagen gráfica. una gui sometida reingeniería puede usar una barra desplazamiento ratón para lograr misma función.¿cómo comprender funcionamiento una interfaz usuario existente?? las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas que hay esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores.objetivo: auxiliar los ingenieros software com- prender estructura interna diseño programas com- plejos. mecánica: mayoría los casos, las herramientas ingenie- ría inversa aceptan código fuente como entrada producen varias representaciones diseño estructural, procedimental, datos comportamiento. herramientas representativas: imagix , desarrollada por imagix ( “ayuda los desarrolladores software comprender software ++ complejo heredado” mediante ingeniería inversa documenta- ción código fuente. understand, desarrollado por scientific toolworks, inc. ( tools.com), analiza gramaticalmente ada, fortran, , ++ java “para ingeniería inversa, documenta automáticamente, cal-cula métricas código ayuda comprender, navegar man-tener código fuente”. una lista exhaustiva herramientas ingeniería puede encontrarse http://scgwiki.iam.unibe.:/scg/ software ingeniería inversa (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . eestructuración reestructuración software modifica código fuente / los datos con intención - cerlos sensibles cambios futuros. general, reestructuración modifica arquitectura global del programa. tiende enfocarse sobre detalles diseño módulos individuales sobre estructuras datos locales definidas dentro módulos. esfuerzo reestructura-ción extiende más allá las fronteras del módulo abarca arquitectura del software, reestructuración convierte ingeniería hacia adelante (sección .). reestructuración ocurre cuando arquitectura básica una aplicación sólida, aun cuando interior técnico necesite trabajarse. inicia cuando grandes partes del software son aprovechables sólo subconjunto todos los módulos datos necesitan modificación -tensa. .. reestructuración código reestructuración código realiza para producir diseño que produzca misma función pero con mayor calidad que programa original. general, las técnicas reestructuración código (por ejemplo, las técnicas simplificación lógica warnier [war]) modelan lógica del programa usando álgebra booleana luego aplican una serie reglas transformación que producen lógica reestructurada. objetivo tomar una “ensalada” código derivar diseño procedimental que conforme con filosofía programación estructurada (capí-tulo ). también han propuesto otras técnicas reestructuración para uso con herramientas reingeniería. diagrama intercambio recursos mapea cada módulo programa los recursos (tipos datos, procedimientos variables) que intercambiarán entre otros módulos. crear representaciones flujo recursos, arquitectura del programa puede reestructurarse para lograr mínimo acoplamiento entre módulos. .. reestructuración datos antes que pueda comenzar reestructuración datos debe realizarse una actividad ingeniería inversa llamada análisis código fuente . evalúan todos los enunciados lenguaje programación que contienen definiciones datos, descripciones archivo / descrip-ciones interfaz. intención extraer ítems datos objetos, obtener información acerca del flujo datos entender las estructuras datos existentes que implementaron. esta actividad ocasiones llama análisis datos. una vez completado análisis datos, comienza rediseño datos . forma más simple, paso estandarización registro datos clarifica las definiciones los datos para lograr consistencia entre nombres ítem datos formatos registro físico dentro una estructura datos existente dentro formato archivo. otra forma rediseño, lla-mada racionalización nombre datos, garantiza que todas las convenciones nomencla- tura datos establezcan acuerdo con estándares locales que los sobrenombres eli-minen conforme los datos fluyen través del sistema. cuando reestructuración avanza más allá estandarización racionalización, realizan modificaciones físicas las estructuras datos existentes para hacer que diseño datos sea más efectivo. esto puede significar una traducción formato archivo otro , algunos casos, traducción tipo base datos otra. ocasiones difícil hacer una distinción entre reestructuración extensa redesarrollo. ambos son reinge- niería.aunque reestructuración código puede aliviar los problemas inmediatos asociados con depuración con pequeños cambios, reingeniería. beneficio real logra sólo cuando reestructuran los datos arquitectura.consejo (-).indd (-).indd // ::// :: mantenimiento reingeniería . ngeniería hacia adelante programa con flujo control que sea equivalente gráfico una olla espagueti, con “módulos” que tienen enunciados largo, con pocas líneas comentarios significativos enunciados fuente sin otra documentación, debe modificarse para alojar los cam-biantes requisitos usuario. tienen las siguientes opciones: . para implementar los cambios necesarios puede luchar través modificación tras modificación, combatir diseño hoc código fuente enredado. . puede intentar comprender los funcionamientos interiores más amplios del programa con intención hacer modificaciones manera más efectiva. . puede rediseñar, recodificar poner prueba aquellas porciones del software que - quieran modificación aplicar enfoque ingeniería software todos los seg- mentos revisados. . puede rediseñar, recodificar poner prueba completamente programa, usar herra- mientas reingeniería para ayudar comprender diseño actual. hay una sola opción “correcta”. las circunstancias pueden dictar primera opción incluso las otras son más deseables. lugar esperar hasta recibir una solicitud mantenimiento, organización desa- rrollo soporte usa los resultados análisis ventario para seleccionar programa: ) que permanecerá uso durante número preseleccionado años, ) que momento use con éxito ) que tenga probabilidad experimentar grandes modificaciones aumentos futuro cercano. entonces aplican las opciones , . primera vista, sugerencia que redesarrolle programa grande cuando existe una versión operativa puede parecer muy extravagante. antes juzgar, considere los siguientes puntos: las herramientas que mencionan aquí representan respaldo, sino una muestra las herramientas que hay esta categoría. mayoría los casos, los nombres las herramientas son marcas registradas por sus respectivos desarrolladores.objetivo: objetivo las herramientas reestructura- ción transformar software computadora estruc- turado más antiguo lenguajes programación estructuras diseño modernos. mecánica: general, ingresa código fuente transforma programa mejor estructurado. algunos casos, transforma-ción ocurre dentro del mismo lenguaje programación. otros, lenguaje programación más antiguo transforma lenguaje más moderno. herramientas representativas: dms software reengineering toolkit, desarrollada por semantic design ( proporciona varias capaci- dades reestructuración para cobol, /++, java, fortran vhdl.clone doctor, desarrollada por semantic designs, inc. (www. semdesigns.com), analiza transforma programas escritos , ++, java cobol cualquier otro lenguaje compu-tadora basado texto. plusfort, desarrollada por polyheddron ( com), una suite herramientas fortran que contiene capa-cidades para reestructurar programas fortran pobremente diseñados estándar moderno fortran . indicadores hacia varias herramientas reingeniería ingeniería inversa pueden encontrarse berta./~kenw/toolsdir/all.htmlherramientas software reestructuración software ¿qué opciones existen cuando uno enfrenta con programa dise-ñado implementado pobremente?? reingeniería poco como limpiar sus dientes. puede pensar miles razones para demorarla, evitará con desidia durante rato. pero finalmente, sus tácticas demora regresarán para causarle dolor.consejo (-).indd (-).indd // ::// :: parte cuatro administración proyectos software . costo mantener una línea código fuente puede ser veces costo del desarrollo inicial dicha línea. . rediseño arquitectura del software (programa / estructura datos), con uso modernos conceptos diseño, puede facilitar enormemente mantenimiento futuro. . puesto que existe prototipo del software, productividad desarrollo debe ser mucho más alta que promedio. . ahora usuario experimenta con software. por tanto, pueden averiguarse con mayor facilidad los nuevos requisitos dirección del cambio. . las herramientas automatizadas para reingeniería facilitarán algunas partes labor. . existirá una configuración software completa (documentos, programas datos) completar mantenimiento preventivo. gran desarrollador interno software (por ejemplo, grupo desarrollo sistemas software empresarial para una gran compañía productos consumidor) puede tener una producción programas dentro dominio responsabilidad. dichos progra-mas pueden clasificarse por importancia luego revisarse como candidatos para ingeniería hacia adelante. proceso ingeniería hacia adelante aplica los principios, conceptos métodos inge- niería software para volver crear una aplicación existente. mayoría los casos, -geniería hacia adelante crea simplemente equivalente moderno programa más anti- guo. vez ello, esfuerzo reingeniería integran nuevos requisitos usuario tecnología. programa redesarrollado extiende las capacidades aplicación más antigua. .. ingeniería hacia adelante para arquitecturas cliente-servidor durante las décadas pasadas, muchas aplicaciones mainframe sometieron reingeniería para alojar arquitecturas cliente-servidor (incluidas las webapps). esencia, los recursos cómputo centralizados (incluido software) distribuyen entre muchas plataformas cliente. aunque pueden diseñarse varios entornos distribuidos, aplicación mainframe típica que somete reingeniería una arquitectura cliente-servidor tiene las siguientes características: • funcionalidad aplicación migra cada computadora cliente. • implementan nuevas interfaces gui los sitios cliente. • las funciones base datos ubican servidor. • funcionalidad especializada (por ejemplo, análisis con uso intenso computadora) puede permanecer sitio servidor. • deben establecerse nuevos requisitos comunicaciones, seguridad, archivado control los sitios cliente servidor. importante observar que migración mainframe cómputo cliente-servidor requiere reingeniería tanto empresa como del software. además, debe establecerse una “infraes-tructura red empresarial” [jay]. reingeniería para aplicaciones cliente-servidor comienza con profundo análisis del entorno empresarial que abarca mainframe existente. pueden identificarse tres capas abs-tracción. base datos que asienta los cimientos una arquitectura cliente-servidor gestiona las transacciones consultas aplicaciones del servidor. aunque dichas transaccio-nes consultas deben controlarse dentro del contexto conjunto reglas empresariales (definidas por proceso empresarial existente reingeniería), las aplicaciones cliente pro-porcionan funcionalidad dirigida comunidad usuaria. algunos casos, migración una arquitectura cliente-servidor debe abordarse como reingeniería, sino como nuevo esfuerzo desarrollo. reingeniería entra cuadro solamente cuando deba integrarse funcionalidad específica del sistema antiguo nueva arquitectura.consejo (-).indd (-).indd // ::// :: mantenimiento reingeniería las funciones del sistema gestión base datos existente arquitectura datos base datos existente deben someterse ingeniería inversa como precursor del rediseño capa cimiento base datos. algunos casos, crea nuevo modelo datos (capítulo ). todo caso, base datos cliente-servidor somete reingeniería para -rantizar que las transacciones ejecutan forma consistente, que todas las actualizaciones realizan sólo por usuarios autorizados, que las reglas empresariales núcleo refuerzan (por ejemplo, antes borrar registro vendedor, servidor asegura que existan cuentas por pagar, contratos comunicaciones para dicho proveedor), que las consultas pue-dan acomodarse manera eficiente que establece capacidad completa archivado. las capas reglas empresariales representan software residente tanto cliente como servidor. este software realiza tareas control coordinación para garantizar que las transacciones consultas entre aplicación cliente base datos conforman con proceso empresarial establecido. las capas aplicaciones cliente implementan funciones empresariales que requieren gru- pos específicos usuarios finales. muchas instancias, una aplicación mainframe seg-menta algunas aplicaciones escritorio más pequeñas sometidas reingeniería. comu-nicación entre aplicaciones escritorio (cuando sea necesario) controla mediante capa reglas empresariales. análisis profundo del diseño reingeniería software cliente-servidor deja para libros dedicados materia. tiene más interés, consulte [van], [cou] [orf]. .. ingeniería hacia adelante para arquitecturas orientadas objetos ingeniería software orientada objetos convertido paradigma desarrollo elegido por muchas organizaciones software. pero, ¿qué hay las aplicaciones existentes que desarrollaron usando métodos convencionales? algunos casos, respuesta dejar tales aplicaciones “como están”. otras, las aplicaciones antiguas deben someterse reinge-niería, modo que puedan integrarse con facilidad sistemas grandes orientados objetos. reingeniería software convencional una implementación orientada objeto usa muchas las mismas técnicas estudiadas parte este libro. primero, software exis-tente somete ingeniería inversa para que puedan crearse modelos adecuados datos, funciones comportamientos. sistema sometido reingeniería extiende funcionalidad comportamiento aplicación original, crean casos uso (capítulos ). los modelos datos creados durante ingeniería inversa usan entonces conjunción con modelado crc (capítulo ) para establecer base para definición clases. definen entonces las jerarquías clase, modelos objeto-relacional, modelos objeto- comportamiento subsistemas, comienza diseño orientado objetos. conforme avanza ingeniería hacia adelante orientada objetos desde análisis hacia diseño, puede invocarse modelo proceso isbc (capítulo ). aplicación existente reside dentro dominio que está poblado con muchas aplicaciones orientadas objetos, probable que exista una robusta librería componentes que pueda usarse durante -geniería hacia adelante. para aquellas clases que deban someterse ingeniería desde cero, posible reutilizar algo- ritmos estructuras datos aplicación convencional existente. obstante, las mismas deben rediseñarse para estar acuerdo con arquitectura orientada objetos. . conomía reingeniería mundo perfecto, todo programa mantenible retiraría inmediato para sustituirlo con aplicaciones sometidas reingeniería alta calidad desarrolladas mediante modernas (-).indd (-).indd // ::// :: parte cuatro administración proyectos software prácticas ingeniería software. pero vive mundo recursos limitados. reinge- niería gasta recursos que pueden usarse para otros propósitos empresariales. por tanto, antes que una organización intente someter reingeniería una aplicación existente, debe realizar análisis costo-beneficio. sneed [sne] propone modelo análisis costo-beneficio para reingeniería, definiendo nueve parámetros: / costo mantenimiento anual actual para una aplicación / costo operaciones anuales actuales para una aplicación / valor empresarial anual actual una aplicación / costo mantenimiento anual predicho después reingeniería / costo operaciones anuales predichas después reingeniería / valor empresarial anual predicho después reingeniería / costo reingeniería estimado / tiempo calendario reingeniería estimado / factor riesgo reingeniería ( / . nominal) / vida esperada del sistema costo asociado con mantenimiento continuo una aplicación candidata ( decir, rein-geniería realiza) puede definirse como mant / [ / ( / )] / (.) costo asociado con reingeniería define usando siguiente relación: creing / / ( / ) / ( / ) / ( / ) (.) con los costos presentados las ecuaciones . ., beneficio global reingeniería puede calcularse como beneficio costo / reing / cmant (.) análisis costo-beneficio que presenta estas ecuaciones puede realizarse para todas las aplicaciones alta prioridad identificadas durante análisis inventario (sección ..). aquellas aplicaciones que muestren mayor costo-beneficio pueden marcarse para reinge-niería, mientras que trabajo sobre otras puede posponerse hasta que haya recursos disponi-bles. . esumen mantenimiento soporte del software son actividades marcha que ocurren largo todo ciclo vida una aplicación. durante dichas actividades corrigen defectos, adaptan aplicaciones entorno operativo empresarial cambiante, implementan mejoras petición los participantes soporte los usuarios conforme integran una aplicación flujo trabajo personal empresarial. reingeniería ocurre dos niveles abstracción diferentes. nivel empresarial, reingeniería enfoca proceso empresarial con intención realizar cambios para -jorar competitividad alguna área empresa. nivel software, reingeniería examina los sistemas aplicaciones información con intención reestructurar recons-truirlos modo que muestren mayor calidad. reingeniería procesos empresarial define las metas empresa, identifica evalúa los procesos empresariales existentes ( contexto metas definidas), especifica diseña procesos revisados crea prototipos, los refina ejemplifica dentro una empresa. rpe representa enfoque que extiende más allá del software. resultado rpe con frecuen-cita: “puede pagar poco ahora puede pagar mucho tiempo después.” anuncio una empresa venta autos que sugiere una afinación. (-).indd (-).indd // ::// :: mantenimiento reingeniería cia definición formas las que las tecnologías información pueden apoyar mejor empresa. reingeniería software abarca una serie actividades que incluyen análisis inven- tario, reestructuración documentos, ingeniería inversa, reestructuración programa datos ingeniería hacia adelante. intención dichas actividades crear versiones progra-mas existentes que muestren mayor calidad mejor mantenibilidad, mismos que serán viables bien entrado siglo xxi. costo-beneficio reingeniería puede determinarse manera cuantitativa. costo del status quo , decir, costo asociado con soporte mantenimiento actuales una aplicación existente, compara con los costos proyectos reingeniería con reducción resul-tante costos mantenimiento soporte. casi todos los casos los que programa tenga una vida larga momento muestre pobre mantenibilidad soportabilidad, rein-geniería representa una estrategia empresarial efectiva costo. problemas puntos por evaluar .. considere cualquier trabajo que lector haya tenido durante los cinco años anteriores. describa proceso empresarial que participó. use modelo rpe descrito sección .. para recomendar cambios proceso con intención hacerlo más eficiente. .. realice algo investigación acerca eficacia reingeniería procesos empresa. presente argumentos favor contra para este enfoque. .. instructor seleccionará uno los programas que hayan desarrollado clase durante este curso. intercambie programa azar con alguien más clase. explique repase programa. ahora, implemente una mejora (especificada por instructor) programa que haya recibido. ) realice todas las tareas ingeniería software, incluida una breve explicación (mas con autor del programa). ) siga cuidadosamente pista todos los errores que encuentre durante las pruebas. ) analice clase sus experiencias. .. explore lista verificación del análisis inventario que presenta sitio web del libro, intente desarrollar sistema calificación software cuantitativo que pueda aplicar programas exis-tentes con intención elegir programas candidato para reingeniería. sistema debe extenderse más allá del análisis económico que presentó sección .. .. sugiera alternativas documentación impresa electrónica convencional que puedan servir como base para reestructuración documentos. (sugerencia: piense nuevas tecnologías descriptivas que puedan usarse para comunicar intención del software.) .. algunas personas creen que tecnología inteligencia artificial aumentará nivel abstracción del proceso ingeniería inverso. realice investigación acerca este tema ( decir, uso para -geniería inversa) escriba breve ensayo que adopte una postura acerca este punto. .. ¿por qué difícil lograr completitud conforme aumenta nivel abstracción?.. ¿por qué debe aumentar interactividad aumenta completitud?.. con información obtenida web, presente clase las características tres herramientas ingeniería inversa. .. existe una sutil diferencia entre reestructuración ingeniería hacia adelante. ¿cuál ?.. investigue literatura / fuentes internet para encontrar uno más artículos que analizan - tudios caso reingeniería mainframe cliente-servidor. presente resumen. .. ¿cómo determinaría modelo costo-beneficio que presentó sección .? (-).indd (-).indd // ::// :: parte cuatro administración proyectos software lecturas fuentes información adicionales irónico que mantenimiento soporte software representen las actividades más costosas vida una aplicación , sin embargo, hayan escrito menos libros acerca mantenimiento soporte que cualquier otro tema importante ingeniería software. entre las adiciones recientes literatura están los libros jarzabek (effective software maintenance and evolution, auerbach, ), grubb takang (soft- ware maintenance: concepts and practice, world scientific publishing ., . ., ), pigoski ( practical software maintenance, wiley, ). éstos cubren las prácticas básicas mantenimiento soporte, presen- tan una guía administrativa útil. las técnicas mantenimiento que enfocan entornos cliente-servidor estudian schneberger ( client/server software maintenance , mcgraw-hill, ). investigación actual “evolución del software” presenta una antología editada por mens demeyer ( software evolution, springer, ). como muchos temas calientes comunidad empresarial, alboroto que rodea reingeniería procesos empresa dio lugar una visión más pragmática materia. hammer champy ( reengineering the corporation, harperbusiness, edición revisada, ) precipitaron interés temprano con libro tan solicitado. otros libros smith fingar [ business process management (bpm): the third wave, meghan-kiffer press, ], jacka keller (business process mapping: improving customer satisfaction, wiley, ), sharp mcdermott (workflow modeling, artech house, ), andersen (business process improvement toolbox, american society for quality, ), harrington . (business process improvement workbook, mcgraw- hill, ) presentan estudios caso lineamientos detallados para rpe. fong (information systems reengineering and integration , springer, ) describe técnicas conversión bases datos, ingeniería inversa ingeniería hacia adelante para grandes sistemas información. demeyer . ( object oriented reengineering patterns, morgan kaufmann, ) ofrecen una visión basada patrones sobre cómo refactorizar / someter reingeniería sistemas . secord . ( modernizing legacy systems, addison-wesley, ), ulrich (legacy systems: transformation strategies, prentice hall, ), valenti (successful software reengineering, irm press, ), rada ( reengineering software: how reuse programming build new, state--the-art software, fitzroy dearborn publishers, ) enfocan estrategias prácticas para reingeniería nivel técnico. miller (reengineering legacy software systems , digital press, ) “ofrece marco conceptual para mantener los sistemas aplicación sincronía con las estrategias empresariales los cambios tecnológicos”. cameron (reengineering business for success the internet age, computer technology research, ) umar [application ()engineering: building web-based applications and dealing with legacies, prentice hall, ] proporcionan valiosos lineamientos para organizaciones que quieren transformar sistemas heredados entorno basado web. cook (building enterprise information architectures: reengineering information systems, prentice hall, ) analiza puente entre rpe tecnología información. aiken ( data reverse engineering, mcgraw-hill, ) analiza cómo recuperar, reorganizar reutilizar datos organizacionales. arnold (software reengineering , ieee computer society press, ) reunió una excelente antología los primeros ensayos que enfocan las tecnologías reingeniería software. internet, está disponible una gran variedad fuentes información acerca reingeniería software. una lista actualizada referencias world wide web que son relevantes para manteni-miento reingeniería software puede encontrarse sitio del libro: (-).indd (-).indd // ::// :: avanzadosparte cinco esta parte ingeniería del software. enfoque práctico, consi- derarán algunos temas avanzados que extenderán comprensión ingeniería del software. los siguientes capítulos abordan las siguientes preguntas: • ¿qué mejoramiento del proceso software cómo puede usarse para optimizar estado práctica ingeniería del software? • ¿qué tendencias emergentes posible que tengan una influencia significativa sobre práctica ingeniería del software -guiente década? • ¿cuál camino por venir para los ingenieros del software? una vez respondidas dichas preguntas, comprenderá los temas que pueden tener profundo impacto sobre ingeniería del software los años por venir . (-).indd (-).indd // ::// :: del proceso software conceptos clave cmm personal . . . . . . . . cmmi. . . . . . . . . . . . . . . . . capacitación . . . . . . . . . . . . . . . . éxito cruciales . . del riesgo . . . . . . . . /migración . . . . . . . . . . . . . . . . . . del proceso software (mps) . . . . . . . aplicabilidad . . . . . . . . . . . marcos conceptuales . . . . . proceso . . . . . . . . . . . . . . modelos madurez . . . . . . sobre inversión. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ¿qué ? mejoramiento del proceso software abarca conjunto actividades que conducirán mejor proceso software , consecuencia, software mayor calidad entrega forma más oportuna. ¿quién hace? personal que impulsa mps (mejora- miento proceso software) proviene tres grupos: gerentes técnicos, ingenieros software individuos que tienen responsabilidad aseguramiento calidad. ¿por qué importante? algunas organizaciones software tienen poco más que proceso software hoc. conforme trabajan para mejorar sus prácticas ingeniería del software, deben abordar las debilidades sus procesos existentes intentar mejorar enfoque para trabajo software. ¿cuáles son los pasos? enfoque del mps iterativo continuo, pero puede verse cinco pasos: ) valoración del proceso software actual, ) educación capaci-tación profesionales gerentes, ) selección justifica-ción elementos proceso, métodos ingeniería del software herramientas, ) implementación del plan mps ) evaluación afinación con base los resultados del plan. ¿cuál producto final? aunque existen muchos productos operativos mps intermedios, resultado final proceso software mejorado que conduce software mayor calidad. ¿cómo aseguro que hice bien? software que produce organización entregará con menos defectos, reducirá repetición del trabajo cada etapa del proceso software entrega oportuna será mucho más probable. una mirada rápidamucho antes que usara ampliamente frase “mejoramiento del proceso soft- ware”, autor trabajó con grandes corporaciones con intención mejorar -tado sus prácticas ingeniería del software. como consecuencia sus experien- cias, autor escribió libro titulado making software engineering happen [pre]. prefacio dicho libro hizo siguiente comentario: durante los pasados diez años, tenido oportunidad ayudar algunas compañías grandes implementar prácticas ingeniería del software. tarea difícil rara vez pasa tan suavemente como uno quisiera; pero cuando triunfa, los resultados son profundos: los proyectos software tie-nen más probabilidad completarse con tiempo, mejora comunicación entre todos los consti-tuyentes involucrados desarrollo software, nivel confusión caos que con frecuencia prevalece para grandes proyectos software reduce manera sustancial, número errores que encuentra cliente disminuye sustancialmente, credibilidad organización software aumenta administración tiene problema menos por cual preocuparse. pero todo dulzura luz. muchas compañías intentan implementar prácticas ingeniería del software caen frustración. otras llegan medio camino nunca ven los beneficios anotados anteriormente. otras más hacen forma tan ruda que como resultado rebelión abierta entre personal técnico los administradores, con posterior pérdida moral. aunque tales palabras escribieron hace más años, siguen siendo igualmente ciertas día hoy. conforme avanza hacia segunda década del siglo xxi, mayoría las principales - ganizaciones ingeniería del software intentaron “hacer posible ingeniería del software”. algunas implementaron prácticas individuales que ayudaron mejorar calidad del producto que construían oportunidad entrega. otras establecieron proceso software “-duro” que guía las actividades técnicas administrativas del proyecto. pero otras continúan luchando. sus prácticas son acierto error, proceso hoc. ocasionalmente, trabajo (-).indd (-).indd // ::// :: mejoramiento del proceso software espectacular, pero, promedio, cada proyecto una aventura, nadie sabe terminará mal bien. así que, ¿cuál estas cohortes necesita mejoramiento del proceso software? res- puesta (que puede sorprenderle) ambas. las que triunfaron hacer posible ingeniería del software pueden volverse complacientes. deben trabajar manera continua para mejorar enfoque ingeniería del software. las que luchan deben comenzar viaje por -mino hacia mejoramiento. . ¿ mps? término mejoramiento del proceso software (mps) implica muchas cosas. primero, que los elementos proceso software efectivo pueden definirse forma efectiva; segundo, que enfoque organizacional existente sobre desarrollo del software puede valorarse con-traste con dichos elementos; tercero, que posible definir una estrategia mejoramiento significativa. estrategia mps transforma enfoque existente sobre desarrollo del software algo que más enfocado, más repetible más confiable ( términos calidad del pro-ducto producido oportunidad entrega). puesto que mps gratuito, debe entregar rendimiento sobre inversión. - fuerzo tiempo que requieren para implementar una estrategia mps deben pagar por mismos alguna forma mensurable. para hacer esto, los resultados del proceso práctica mejorados deben conducir una reducción los “problemas” del software que cuestan tiempo dinero. debe reducir número defectos que entregan los usuarios finales, cantidad repetición proceso debida problemas calidad, los costos asociados con manteni-miento soporte del software (capítulo ) los costos indirectos que ocurren cuando software entrega tarde. .. enfoques del mps aunque una organización puede elegir enfoque relativamente informal del mps, gran -yoría elige uno los marcos conceptuales mps. marco conceptual mps define: ) conjunto características que deben presentarse quiere lograrse proceso software efectivo, ) método para valorar dichas características están presentes, ) mecanismo para resumir los resultados cualquier valoración ) una estrategia para auxiliar una organización soft-ware implementar aquellas características del proceso que sean débiles que hagan falta. marco conceptual mps valora “madurez” del proceso una organización propor- ciona indicio cualitativo nivel madurez. hecho, con frecuencia aplica tér-mino “modelo madurez” (sección ..). esencia, marco conceptual mps abarca modelo madurez que vez incorpora conjunto indicadores calidad proceso que ofrecen una medida global calidad del proceso que llevará calidad del producto. figura . proporciona panorama marco conceptual mps típico. muestran los elementos clave del marco conceptual relación mutua. debe observarse que existe marco conceptual mps universal. hecho, marco con- ceptual mps que elige una organización refleja las áreas que impulsan esfuerzo mps. conradi [con] define seis diferentes grupos apoyo mps: certificadores calidad. los esfuerzos mejoramiento proceso que impulsa este grupo enfocan siguiente relación: calidad (proceso) ⇒ calidad (producto) enfoque consiste enfatizar los métodos valoración examinar conjunto bien definido características que permiten determinar proceso muestra calidad. punto clave mps implica proceso software definido, enfoque organizacional una estrategia para mejoramiento. cita: “mucha crisis del software autoinfligida, como cuando presidente del área infor-mática ejercicio dice: ‘prefiero que salga mal antes que entregarlo tarde. siempre podremos repararlo después’.” mark paulk ¿qué grupos impulsan esfuerzo mps?? (-).indd (-).indd // ::// :: parte cinco temas avanzados más probable que adopten marco conceptual proceso, como cmm, spice, tickit bootstrap. formalistas. este grupo quiere entender ( cuando posible, optimizar) flujo tra-bajo del proceso. para lograrlo, usa lenguajes modelado proceso (pml) fin crear modelo del proceso existente luego diseñar extensiones modificaciones que harán más efectivo proceso. defensores las herramientas. este grupo insiste enfoque del mps asistido por herramientas que modelan flujo trabajo otras características del proceso manera que pueda analizarse para mejoramiento. profesionales. este grupo usa enfoque pragmático, “que enfatiza administración tradicional proyecto, calidad producto, aplica planificación métricas nivel proyecto, pero con poco modelado proceso formal pronunciamiento apoyo” [con]. reformadores. meta este grupo cambio organizacional que pueda conducir mejor proceso software. tienden enfocarse más los temas humanos (sección .) enfatizan medidas capacidad humana estructura. ideólogos. este grupo enfoca adecuado modelo proceso particular para dominio aplicación específico estructura organizativa. lugar los modelos proceso software típicos (por ejemplo, modelos iterativos), los ideólogos tendrían mayor interés proceso que, por ejemplo, apoyara reuso reingeniería. conforme aplica marco conceptual mps, grupo impulsor (sin importar enfoque glo-bal) debe establecer mecanismos para: ) apoyar transición tecnológica, ) determinar grado que una organización está lista para absorber los cambios proceso que pro-pongan ) medir grado que adoptaron los cambios.proceso software valoración está basada paraconduce conduce alo examinaidentiﬁca capacidades, fortalezas debilidades identiﬁca madurez deidentiﬁca cambios sugiere enfoque mejoramiento para determinación capacidadestrategia mejoramientofigura . elementos marco conceptual mpsfuente: adaptado [rou]. cada uno estos marcos conceptuales mps estudia más adelante, este capítulo.¿cuáles son los diferentes grupos que apoyan mps?? (-).indd (-).indd // ::// :: mejoramiento del proceso software .. modelos madurez modelo madurez aplica dentro del contexto marco conceptual mps. intención del modelo madurez proporcionar indicio global “madurez del proceso” que muestra una organización software, decir, indicio calidad del proceso software, grado que los profesionales entienden aplican proceso, estado general práctica ingeniería del software. esto logra usando algún tipo escala ordinal. por ejemplo, modelo madurez capacidad (sección .) del software engineering institute sugiere cinco niveles madurez [sch]: nivel , optimizado. organización tiene sistemas realimentación cuantitativa lugar para identificar las debilidades del proceso fortalecer esos puntos manera proactiva. los equipos proyecto analizan defectos para determinar sus causas; los procesos software evalúan actua-lizan para evitar que recurran tipos conocidos defectos. nivel , gestionado. métricas proceso software calidad producto detalladas estable- cen cimiento evaluación cuantitativa. las variaciones significativas desempeño del proceso pueden distinguirse del ruido aleatorio, pueden predecirse las tendencias las cualidades del pro-ceso producto. nivel , definido. los procesos para administración ingeniería documentan, estandarizan integran proceso software estándar para organización. todos los proyectos usan una ver-sión aprobada medida del proceso software estándar organización para desarrollo software. nivel , repetible. establecen procesos administración proyecto básicos para rastrear costo, calendario funcionalidad. planificación administración nuevos productos basa experiencia con proyectos similares. nivel , inicial. pocos procesos definidos, éxito depende más del esfuerzo heroico individual que seguir proceso usar esfuerzo sinérgico equipo. escala madurez cmm más allá, pero experiencia indica que muchas organizaciones muestran niveles “inmadurez proceso” [sch] que minan cualquier intento racional por mejorar las prácticas ingeniería software. schorsch [sch] sugiere cuatro niveles inmadurez que encuentran frecuentemente mundo real las organizaciones desa-rrollo del software: nivel , negligente. fracaso para permitir que tenga éxito proceso desarrollo exitoso. todos los problemas perciben como problemas técnicos. las actividades administrativas aseguramiento calidad están condenadas situarse por encima ser superfluas relación con las tareas del proceso desarrollo del software. confía las balas plata. nivel , obstructivo . imponen procesos contraproducentes. los procesos definen rígidamente adhieren forma que subrayan. abundan las ceremonias rituales. administración colectiva impide asignación responsabilidad. status quo über alles (sobre todo). nivel , despreciador. preocupa por buena ingeniería software institucionalizada. hay desunión completa entre actividades desarrollo software actividades mejoramiento del proceso software falta completa programas capacitación. nivel , socavación. desprecio total por propia organización, descrédito consciente los esfuer- zos mejoramiento del proceso software los pares organización. recompensa fracaso pobre desempeño. los niveles inmadurez schorsch son tóxicos para cualquier organización software. usted encuentra alguno ellos, los intentos por mps están condenados fracaso. pregunta decisiva las escalas madurez, como las que proponen como parte del cmm, proporcionan algún beneficio real. autor cree que tienen. una escala madurez punto clave modelo madurez define niveles competencia implementación proceso software. ¿cómo reconoce una organización que resistirá los esfuerzos mps? ? (-).indd (-).indd // ::// :: parte cinco temas avanzados proporciona una instantánea fácilmente comprensible calidad del proceso que pueden emplear los profesionales administradores como hito desde cual puedan planificar estrate-gias mejoramiento. .. ¿ mps para todos? durante muchos años, mps vio como una actividad “corporativa”, eufemismo para algo que sólo realizan las grandes compañías. pero hoy, porcentaje significativo todo desa-rrollo software realizan compañías que emplean menos personas. ¿una compañía pequeña puede iniciar actividades mps realizarlas con éxito? existen sustanciales diferencias culturales entre grandes pequeñas organizaciones - sarrollo software. debe sorprender que las organizaciones pequeñas sean más informa-les, apliquen menos prácticas estándar tiendan autoorganización. también tienden enorgullecerse por “creatividad” los miembros individuales organización software, inicialmente ven marco conceptual mps como excesivamente burocrático pesado. sin embargo, mejoramiento los procesos tan importante para una organización pequeña como para una grande. dentro las organizaciones pequeñas, implementación marco conceptual mps requiere recursos que pueden tener suministro reducido. los administradores deben asignar personal dinero para lograr que ocurra ingeniería del software. por tanto, sin importar tamaño organización del software, razonable considerar motivación empresarial para mps. éste aprobará implementará sólo después que sus proponentes demuestren apalan- camiento financiero [bir], que demuestra examinar los beneficios técnicos (por ejemplo, menos defectos entregados campo, reelaboración reducida, menores costos manteni-miento tiempo llegada mercado más rápido) traducirlos dinero. esencia, deben demostrar rendimiento realista sobre inversión (sección .) para los costos mps. . proceso mps parte dura del mps establecer las características que definen proceso software alta calidad creación modelo madurez proceso. ésas son relativamente sen-cillas. parte dura establecer consenso para iniciar mps definir una estrategia continua fin implementarla través una organización software. software engineering institute desarrolló ideal, “ modelo mejoramiento organiza- cional que funciona como mapa caminos para iniciar, planificar implementar acciones mejoramiento” [sei]. ideal representativo muchos modelos proceso para mps define cinco actividades distintas: inicio, diagnóstico, establecimiento, acción aprendizaje, que guían una organización través las actividades mps. este libro presenta mapa caminos tanto diferente para mps, con base modelo proceso para mps originalmente propuesto [pre]. aplica una filosofía sentido común que requiere que una organización ) observe espejo, ) vuelva más astuta para tomar elecciones inteligentes, ) seleccione modelo proceso ( los elementos tecno-lógicos relacionados) que satisfagan mejor sus necesidades, ) ejemplifique modelo entorno operativo cultura ) evalúe que hizo. estas cinco actividades (analizadas las subsecciones que siguen) aplican forma iterativa (cíclica) con intención fomentar mejoramiento proceso continuo. modelo proceso específico enfoque mps percibe como excesivo organización, probablemente .consejo algunos los contenidos estas secciones han sido adaptados [pre] con autorización. (-).indd (-).indd // ::// :: mejoramiento del proceso software .. valoración análisis desviación cualquier intento por mejorar proceso software existente sin primero valorar eficacia las actividades del marco conceptual las prácticas ingeniería del software asociadas sería como iniciar largo viaje hacia una nueva localidad sin idea dónde comienza. parte con gran movimiento vaga por ahí intentando conseguir rumbo, emplea mucha energía padece grandes dosis frustración , probablemente, decide que realidad quiere viajar cualquier forma. dicho manera simple, antes comenzar cualquier viaje, buena idea saber precisamente dónde está. primera actividad del mapa caminos, llamada valoración, permite adquirir rumbo. intención valoración descubrir las fortalezas las debilidades forma que organización aplica proceso software existente las prácticas ingeniería del software que pueblan proceso. valoración examina amplio rango acciones tareas que conducirán proceso alta calidad. por ejemplo, sin importar modelo proceso que elija, organización software debe establecer mecanismos genéricos como: enfoques definidos para comunicación con cliente; establecimiento métodos para representar requisitos usuarios; definición marco conceptual gestión del proyecto que incluya definición del ámbito, estimación, calendarización rastreo del proyecto; métodos análisis riesgos; cambio procedimien-tos administrativos; actividades aseguramiento control calidad que incluyan revisio-nes muchas otras. cada una considera dentro del contexto del marco conceptual las -tividades sombrilla (capítulo ) que establecieron valoraron para determinar responden las siguientes preguntas: • ¿ objetivo acción está claramente definido? • ¿los productos operativos requeridos como entrada producidos como salida identi-fican describen? • ¿las tareas trabajo por realizar describen claramente? • ¿las personas que deben realizar acción identifican por rol? • ¿ establecieron criterios entrada salida? • ¿ establecieron métricas para acción? • ¿hay herramientas disponibles para apoyar acción? • ¿existe algún programa capacitación explícito que aborde acción? • ¿ acción realiza manera uniforme para todos los proyectos? aunque las preguntas anotadas implican una respuesta , papel valoración mirar detrás respuesta para determinar acción cuestión realiza con las mejores prácticas. conforme realiza proceso valoración, usted ( quienes contraten para realizar valoración) también deben enfocarse los siguientes atributos: consistencia. ¿las actividades, acciones tareas importantes aplican manera consis-tente través todos los proyectos software por todos los equipos software? sofisticación. ¿las acciones administrativas técnicas realizan con nivel sofistica- ción que implica una comprensión profunda las mejores prácticas? aceptación. ¿ proceso software práctica ingeniería del software aceptan - pliamente por parte del personal administrativo técnico? compromiso. ¿ administración comprometió los recursos requeridos para lograr consis- tencia, sofisticación aceptación?asegúrese entender sus fortalezas así como sus debilidades. inteligente, construirá sobre base las fortalezas.consejo ¿qué atributos genéricos observan durante valoración?? (-).indd (-).indd // ::// :: parte cinco temas avanzados diferencia entre aplicación local mejores prácticas representa una “brecha” que ofrece oportunidades para mejoramiento. grado cual logren consistencia, sofisticación, aceptación compromiso indica cantidad cambio cultural que requerirá para lograr mejoría significativa. .. educación capacitación aunque pocas personas software cuestionan los beneficios proceso software orga-nizado ágil las prácticas sólidas ingeniería del software, muchos profesionales adminis-tradores conocen suficiente acerca alguno los temas. como consecuencia, percep- ciones imprecisas los procesos las prácticas conducen decisiones inadecuadas cuando introduce marco conceptual mps. concluye entonces que elemento clave cual-quier estrategia mps educación capacitación los profesionales, gerentes técnicos gerentes ejecutivos que tengan contacto directo con organización software. con ese fin, deben realizarse tres tipos educación capacitación: conceptos métodos genéricos. dirigida tanto gerentes como profesionales, esta categoría subraya tanto procesos como práctica. intención proporcionar los profe-sionales las herramientas intelectuales necesarias para aplicar proceso software manera efectiva toma decisiones racionales acerca las mejorías del proceso. tecnología herramientas específicas. dirigida principalmente profesionales, esta categoría subraya las tecnologías herramientas que adoptaron para uso local. por ejemplo, eligió uml para modelado análisis diseño, establece programa estudios capacitación para ingeniería del software usando uml. comunicación empresarial temas relacionados con calidad. dirigida todos los participantes, esta categoría enfoca los temas “blandos” que ayudan una mejor -municación entre los participantes fomentan mayor foco calidad. contexto moderno, educación capacitación pueden entregarse varias formas dis- tintas. todo puede ofrecerse como parte una estrategia mps, desde podcast hasta capacita- ción basada internet (por ejemplo, [qai]), pasando por dvd cursos aulas. .. selección justificación una vez completada actividad valoración inicial iniciada educación, una organización software debe comenzar elegir, que ocurre durante una actividad selección justifica-ción que eligen características del proceso especifican métodos ingeniería del software determinados para poblar proceso software. primero, debe elegir modelo proceso (capítulos ) que ajuste mejor organi- zación, sus participantes software que construirán. debe decidir cuáles las actividades del conjunto del marco conceptual aplicarán, los principales productos operativos que producirán los puntos verificación aseguramiento calidad que permitirán equipo valorar progreso. actividad valoración mps indica debilidades específicas (por ejemplo, hay funciones sqa formales), debe enfocar atención las características del proceso que abordarán directamente dichas debilidades. continuación, desarrolle trabajo innovador para cada actividad marco conceptual (por ejemplo, modelado) defina conjunto tareas que aplicarán para proyecto típico. también debe considerar los métodos ingeniería del software que pueden aplicarse para invertido tiempo lectura este libro, ¡ será uno ellos! realidad, valoración una actividad continua. realiza manera periódica con intención deter- minar estrategia mps logró sus metas inmediatas establece escenario para una futura mejoría.intente proporcionar capacitación “justo tiempo” dirigida las necesidades reales equipo software.consejo conforme elija, asegúrese considerar cultura organización nivel aceptación que cada elección probablemente provocará.consejo (-).indd (-).indd // ::// :: mejoramiento del proceso software lograr dichas tareas. conforme hagan estas elecciones, educación capacitación deben coordinarse para garantizar reforzamiento comprensión. manera ideal, todos trabajan conjunto para seleccionar varios procesos elementos tecnológicos para moverse suavemente hacia actividad instalación migración (sección ..). realidad, selección puede ser camino empedrado. con frecuencia difícil -grar consenso entre diferentes grupos. comité establece los criterios para selección, las personas pueden discutir sin fin acerca los criterios son adecuados una elección real-mente satisface los criterios que establecieron. cierto que una mala elección puede hacer más daño que bien, pero “parálisis por análisis” significa que ocurre poco progreso, tal vez, que persisten los problemas del proceso. tanto las características del proceso los elementos tecnológicos tengan buena posibilidad satis-facer las necesidades una organización, veces mejor jalar gatillo hacer selección, lugar esperar solución óptima. una vez hecha elección, deben emplearse tiempo dinero para demostrarla dentro una organización, dichos gastos recursos deben justificarse. sección . presenta análisis acerca justificación del costo rendimiento sobre inversión para mps. .. instalación/migración instalación primer punto donde una organización software siente los efectos los cambios implementados como consecuencia del mapa caminos mps. algunos casos, recomienda proceso completamente nuevo para una organización. las actividades marco conceptual, acciones ingeniería del software tareas trabajo individuales deben definirse instalarse como parte una nueva cultura ingeniería del software. tales cambios repre-sentan una transición organizativa tecnológica sustancial, deben administrarse con mucho cuidado. otros casos, los cambios asociados con mps son relativamente menores, que repre- senta pequeñas modificaciones, pero significativas, modelo proceso existente. tales cambios con frecuencia les conoce como migración proceso . actualidad, muchas organizaciones software tienen “proceso” lugar. problema que funciona forma efectiva. por tanto, una estrategia más efectiva una migración incremental pro- ceso (que funciona tan bien como desea) otro proceso. instalación migración realidad son actividades rediseño proceso software (rps). scacchi [sca] afirma que “ rps preocupa por identificación, aplicación refinamiento nuevas formas mejorar dramáticamente transformar los procesos software”. cuando inicia proceso formal rps consideran tres modelos proceso diferentes: ) proceso existente (“como ”), ) proceso transicional (“ aquí allá”) ) proceso meta (“por ser”). este último significativamente diferente del proceso existente, único enfoque racional instalación una estrategia incremental que proceso transicio-nal implemente pasos. proceso transicional ofrece una serie puntos que permiten que cultura organización software adapte pequeños cambios largo periodo. .. evaluación aunque menciona como última actividad mapa caminos mps, evaluación ocurre largo del mps. actividad evaluación valora grado cual los cambios demos-traron adoptaron, grado que tales cambios dan como resultado mejor calidad soft-ware otros beneficios tangibles proceso estado global del proceso cultura organización conforme avanzan las actividades mps. durante actividad evaluación consideran tanto factores cualitativos como métricas cuantitativas. desde punto vista cualitativo, las actitudes anteriores administradores (-).indd (-).indd // ::// :: parte cinco temas avanzados profesionales acerca del proceso software pueden compararse con las que tienen después instalación los cambios del proceso. las métricas cuantitativas (capítulo ) recopilan proyectos que usaron proceso transicional del proceso “por ser” comparan con -tricas similares que recopilan para proyectos que realizaron bajo proceso “como ”. .. gestión del riesgo para mps mps una empresa riesgosa. hecho, más mitad todos los esfuerzos mps terminan fracaso. las razones del fracaso varían enormemente son específicas organización. entre los riesgos más comunes están: falta apoyo administrativo, resistencia cultural por parte del personal técnico, una estrategia mps pobremente planeada, enfoque excesivamente for-mal del mps, selección proceso inadecuado, falta “adquisición” por parte participan-tes clave, presupuesto inadecuado, falta capacitación personal, inestabilidad -ganización, entre muchos otros factores. papel quienes tienen responsabilidad del mps analizar los riesgos probables desarrollar una estrategia interna para mitigarlos. una organización software debe gestionar riesgo tres puntos clave proceso mps [sta]: antes del inicio del mapa caminos mps, durante ejecución las activida-des mps (valoración, educación, selección, instalación) durante actividad evaluación que sigue ejemplificación algunas características del proceso. general, pueden iden-tificarse las siguientes categorías [sta] para factores riesgo mps: presupuesto costo, contenido entregables, cultura, mantenimiento entregables mps, misión metas, adminis-tración organización, estabilidad organización, participantes proceso, calenda-rio desarrollo mps, entorno desarrollo mps, proceso desarrollo mps, administración del proyecto mps personal mps. dentro cada categoría pueden identificarse algunos factores riesgo genéricos. por ejemplo, cultura organizacional tiene fuerte vínculo con riesgo. para categoría cultura, pueden definirse los siguientes factores riesgo genéricos [sta]: • actitud hacia cambio, con base esfuerzos previos por cambiar • experiencia con programas calidad, nivel éxito • orientación acción para resolver problemas frente luchas políticas • uso hechos para gestionar organización los negocios • paciencia con cambio; habilidad para pasar tiempo socializando • orientación las herramientas: esperanza que las herramientas puedan resolver los problemas • nivel “planificación”: habilidad organización para planificar • habilidad los miembros organización para participar abiertamente las reuniones con varios niveles organización • habilidad los miembros organización para administrar las reuniones manera eficaz • nivel experiencia organización con procesos definidos usar los factores riesgo los atributos genéricos como guía, posible calcular exposi-ción riesgo forma siguiente: exposición / (probabilidad riesgo) / (pérdida estimada) puede desarrollar una tabla riesgo (capítulo ) para aislar aquellos riesgos que garanticen mayor atención administración.punto clave mps con frecuencia fracasa porque los riesgos consideraron adecuadamente tuvo plan contingencia. factores riesgo para cada una las categorías riesgo anotadas esta sección pueden encontrarse [sta]. (-).indd (-).indd // ::// :: mejoramiento del proceso software .. factores éxito cruciales sección .. observó que mps una empresa riesgosa que tasa fracaso para las compañías que intentan mejorar proceso angustiosamente elevada. los riesgos organización, del personal administración proyecto presentan retos para quienes dirigen cualquier esfuerzo mps. aunque gestión del riesgo importante, igualmente reconocer aquellos factores cruciales que conducen éxito. después examinar organizaciones software sus esfuerzos mps, stelzer mellis [ste] identifican conjunto factores éxito cruciales (fec) que deben presentarse triunfar mps. esta sección presentan los cinco principales fec. compromiso apoyo administración. como mayoría las actividades que precipitan cambio organizativo cultural, mps triunfará sólo administración involucra manera activa. los gerentes ejecutivos deben reconocer importancia del software para sus compañías ser patrocinadores activos del esfuerzo mps. los gerentes técnicos deben involucrarse enormemente desarrollo estrategia mps local. como anotan los autores del estudio: “ mejoramiento del proceso software facti-ble sin investigar tiempo, dinero esfuerzo” [ste]. compromiso apoyo administra-tivo son esenciales para sostener dicha inversión. involucramiento del personal. mps puede imponerse manera descendente desde exterior. los esfuerzos mps han triunfar, mejoramiento debe ser -gánico, patrocinado por gerentes técnicos técnicos ejecutivos, adoptado por profesio-nales locales. integración comprensión del proceso. proceso software existe vacío organizativo. debe integrarse con otros procesos requisitos empresariales. para lograr esto, los responsables del esfuerzo mps deben tener conocimiento íntimo los otros procesos empresariales. además, deben entender proceso software “como ” valo-rar cuánto cambio transicional tolerable dentro cultura local. una estrategia mps medida. hay una receta para estrategia mps. como anotó anteriormente, este capítulo, mapa caminos mps debe adaptarse entorno local: deben considerarse cultura equipo, mezcla producto, fortalezas debilidades locales. administración sólida del proyecto mps. mps proyecto como cualquier otro. involucra coordinación, calendarización, tareas paralelas, productos entregables, adapta- ción (cuando riesgo convierte realidad), políticas, control presupuestal mucho más. sin administración activa efectiva, proyecto mps está condenado fracaso. . cmmi cmm original desarrolló actualizó por parte del software engineering institute largo los años como marco conceptual mps completo. más adelante, evolucionó integración del modelo madurez capacidades (cmmi) [cmm], metamodelo proceso exhaustivo que impulsa conjunto sistemas capacidades ingeniería del software que deben presentarse conforme las organizaciones alcanzan diferentes niveles capacidad madurez del proceso. cmmi representa metamodelo proceso dos formas diferentes: ) como modelo “continuo” ) como modelo “ etapas”. metamodelo cmmi continuo describe pro-ceso dos dimensiones, como ilustra figura .. cada área proceso (por ejemplo, planificación proyecto gestión requisitos) valora formalmente contra metas prácti-cas específicas clasifica acuerdo con los siguientes niveles capacidad:¿qué factores éxito cruciales son vitales para éxito del mps?? webref para obtener información más completa acerca del cmmi, dirigirse (-).indd (-).indd // ::// :: parte cinco temas avanzados nivel : incompleto: área del proceso (por ejemplo, gestión requisitos) realiza logra todas las metas objetivos definidos por cmmi para capacidad nivel del área proceso. nivel : realizado: todas las metas específicas del área proceso (como define - diante cmmi) están satisfechas. realizan las tareas trabajo requeridas para produ-cir productos operativos definidos. nivel : administrado: satisfacen todos los criterios del nivel capacidad. además, todo trabajo asociado con área proceso encuentra acorde con una política defi- nida manera organizacional; todo personal que realiza trabajo tiene acceso recur-sos adecuados para tener listo trabajo; los participantes involucran manera activa área proceso según requiera; todas las tareas del trabajo los productos opera-tivos “monitorean, controlan revisan, evalúan para adhesión descripción del proceso” [cmm]. nivel : definido: logran todos los criterios del nivel capacidad. además, proceso “hace medida, partir del conjunto procesos estándar acuerdo con los linea-mientos producción organización; contribuye con productos operativos, medidas otra información para mejorar los procesos activos del proceso organizacional” [cmm]. nivel : administrado cuantitativamente: logran todos los criterios del nivel capaci- dad. además, área proceso controla mejora, usando medición valoración cuan-titativa. “los objetivos cuantitativos para rendimiento cualitativo proceso estable-cen usan como criterios para gestionar proceso” [cmm]. nivel : optimizado: logran todos los criterios del nivel capacidad. además, área proceso adapta optimiza, usando medios cuantitativos (estadísticos) para satisfacer las necesidades cambiantes del cliente para mejorar continuamente eficacia del área proceso bajo consideración. cmmi define cada área proceso términos “metas específicas”, “prácticas espe-cíficas” requeridas para lograr dichas metas. las metas específicas establecen las característi-cas que deben existir las actividades implicadas por área proceso han ser efectivas. las prácticas específicas desglosan una meta conjunto actividades relacionadas con proceso. capacidad área procesoreqm ppqa otrospp planiﬁcación proyecto reqm gestión requisitosma medición análisiscm gestión conﬁguraciónppqa proceso producto qafigura . perfil capacidad área proceso cmmifuente: [phi]. cada organización debe esforzarse por lograr objetivo cmmi. sin embargo, aplicación todos los aspectos del modelo puede ser exagerado.consejo (-).indd (-).indd // ::// :: mejoramiento del proceso software por ejemplo, planificación del proyecto una las ocho áreas proceso definidas por cmmi para categoría “gestión proyecto”. las metas específicas () las prácti- cas específicas () asociadas definidas para planificación proyecto son [cmm]: establecimiento estimaciones .- estimación del ámbito del proyecto .- establecimiento estimaciones producto operativo atributos tareape .- definición ciclo vida del proyectope .- determinación estimaciones esfuerzo costo desarrollo plan proyecto .- establecimiento del presupuesto calendariope .- identificación riesgos del proyectope .- plan para gestión datospe .- plan para recursos del proyectope .- plan para conocimiento habilidades necesariaspe .- plan involucramiento participantespe .- establecimiento del plan del proyecto obtención compromiso del plan .- revisión planes que afectan proyectope .- reconciliación niveles trabajo recursospe .- obtención compromiso del plan además las metas prácticas específicas, cmmi también define conjunto cinco metas genéricas prácticas relacionadas para cada área proceso. cada una las cinco - tas genéricas corresponde uno los cinco niveles capacidad. por tanto, para lograr nivel capacidad particular deben lograrse meta genérica para dicho nivel las prácticas genéricas que correspondan dicha meta. para ilustrar, las metas genéricas () las prácti-cas genéricas () para área proceso planificación del proyecto son [cmm]: logro metas específicas . realización prácticas base institucionalización proceso administrado . establecimiento una política organizacional . plan del procesopg . provisión recursospg . asignación responsabilidadpg . capacitación personalpg . gestión configuracionespg . identificación involucramiento participantes relevantespg . monitoreo control del procesopg . evaluación objetiva adhesiónpg . revisión estatus con administración nivel superior otras áreas proceso definidas para “gestión proyecto” incluyen: monitoreo control del proyecto, adminis- tración acuerdo con proveedores, administración proyecto integrado para ippd, gestión del riesgo, forma- ción equipo integrado, gestión proveedor integrado gestión proyecto cuantitativo.webref puede obtenerse información completa además una versión descargable cmmi (-).indd (-).indd // ::// :: parte cinco temas avanzados institucionalización proceso definido . establecimiento proceso definido . recopilación información mejoría institucionalización proceso administrado cuantitativamente . establecimiento objetivos cuantitativos para procesopg . estabilización desempeño subprocesos institucionalización proceso optimización . aseguramiento del mejoramiento proceso continuopg . corrección causas originales problemas modelo cmmi por etapas define las mismas áreas proceso, metas prácticas que modelo continuo. diferencia principal que modelo por etapas define cinco niveles madurez, lugar cinco niveles capacidad. para lograr nivel madurez deben -grarse las metas prácticas específicas asociadas con conjunto áreas proceso. -lación entre niveles madurez áreas proceso muestra figura .. cmmi metamodelo proceso. define ( más páginas) las características proceso que deben existir una organización quiere establecer proceso software que sea completo. pregunta que debatido durante más una década : ¿ excesiva cmmi? como mayoría las cosas vida ( software), respuesta simple “” “”. espíritu cmmi siempre debe adoptarse. con riesgo sobresimplifiación, argumenta que desarrollo del software debe tomarse con seriedad: planificarse profundidad, controlarse manera uniforme, rastrearse con precisión llevarse cabo con pro-fesionalismo. debe enfocarse las necesidades los participantes proyecto, las habilidades los ingenieros del software calidad del producto final. nadie estaría desacuerdo con estas ideas. los requisitos detallados cmmi deben considerarse seria- mente una organización construye grandes sistemas complejos que involucran decenas cientos personas largo varios meses años. puede ser que cmmi sea “correcta” tales situaciones cultura organización sensible modelos proceso están-dar administración compromete para convertirlo éxito. sin embargo, otras situaciones, cmmi simplemente puede ser demasiado para que una organización asimile con éxito. ¿esto sig-nifica que cmmi “mala” “excesivamente burocrática” “anti-cuada”? ..., . simplemente significa que que correcto para una cultura organizacional puede serlo para otra. cmmi logro significativo ingeniería del software. proporciona análisis amplio las actividades acciones que deben presentarse cuando una organización construye software computadora. incluso una organización software elige adop-tar sus detalles, todo equipo software debe abrazar espíritu ganar comprensión análisis del proceso práctica ingeniería del software. información cmmi: ¿ debe debe? . cmm personal proceso software, sin importar cuán bien conciba, triunfará sin personal software talentoso motivado. modelo madurez capacidad personal “ mapa caminos para implementar prácticas que mejoran manera continua capacidad fuerza tra-bajo una organización” [cur]. desarrollado mediado los años refinado -rante los años siguientes, meta del cmm personal alentar mejoramiento continuo del conocimiento fuerza laboral genérica (llamadas “competencias centrales”), las habili-dades específicas los ingenieros del software administración del proyecto (llamadas “competencias fuerza laboral”) las habilidades relacionadas con proceso. como cmm, cmmi los marcos conceptuales mps relacionados, cmm personal define conjunto cinco niveles madurez organizativa que proporcionan indicio sofisticación relativa las prácticas procesos fuerza laboral. dichos niveles madurez punto clave cmm personal sugiere prácticas que mejoran competencia cultura fuerza laboral. (-).indd (-).indd // ::// :: mejoramiento del proceso software [cmm] ligan existencia (dentro una organización) conjunto áreas pro- ceso clave (apc). figura . muestra panorama los niveles organizativos las apc relacionadas. cmm personal complementa cualquier marco conceptual mps alentar una organi- zación nutrir mejorar activo más importante: personal. tan importante, que establece una atmósfera fuerza trabajo que permite una organización software “atraer, desa-rrollar conservar talento sobresaliente” [cmm]. . tros marcos conceptuales mps aunque los cmm cmmi del sei son los marcos conceptuales mps mayor aplicación, han propuesto algunas alternativas que están uso. entre las más ampliamente utilizadas - cuentran: • spice: una iniciativa internacional para dar apoyo valoración proceso iso estándares proceso ciclo vida [spi] • iso/iec para valoración proceso ( software) [iso] • bootstrap: marco conceptual mps para organizaciones pequeñas medianas que adecua spice [boo]innovación despliegue organizacional análisis causal resoluciónmejora proceso continua administración cuantitativa estandarización proceso administración básica proyectodesempeño proceso organizacionaladministración proyecto cuantitativa desarrollo requisitos solución técnicaintegración productoveriﬁcaciónvalidaciónenfoque proceso organizacionaldeﬁnición proceso organizacionalcapacitación organizacionaladministración proyecto integradaadministración proveedor integradagestión del riesgoanálisis decisión resoluciónentorno organizacional para integraciónformación equipo integrado gestión requisitos planiﬁcación proyectomonitoreo control del proyectoadministración acuerdo con proveedormedición análisisaseguramiento calidad proceso productoadministración conﬁguraciónoptimización administrado cuantitativamente deﬁnido administrado realizadoáreas proceso nivel enfoquefigura . áreas proceso requeridas para lograr nivel madurezfuente: [phi]. razonable argumentar que algunos estos marcos conceptuales son tanto “alternativas” como enfoques complementarios del mps. una tabla exhaustiva muchos más marcos conceptuales mps puede encontrarse (-).indd (-).indd // ::// :: parte cinco temas avanzados • psp tsp: marcos conceptuales mps individuales específicos equipo ([hum], [hum]) que enfocan procesos micro, enfoque más riguroso del desarrollo software acoplado con medición • tickit: método auditoría [tic] que valora cumplimiento una organización estándar iso : los siguientes párrafos presenta breve panorama cada uno estos marcos concep-tuales mps. tiene más interés está disponible una gran variedad recursos tanto impresos como web. spice. modelo spice (software process impro vement and capability determination: determi- nación mejoramiento capacidad del proceso software) proporciona marco conceptual valoración mps que cumple con iso : iso . suite documentos spice [sds] presenta marco conceptual mps completo, que incluye modelo para gestión proceso, lineamientos para realizar una valoración clasificación del proceso bajo considera-ción, construcción, selección uso instrumentos herramientas valoración capacitación para asesores. bootstrap. marco conceptual mps bootstr “ desarrolló para asegurar conformidad con estándar iso emergente para valoración mejoramiento del proceso software (spice) para alinear metodología con iso ” [boo]. objetivo bootstrap evaluar proceso software, usando conjunto mejores prácticas ingeniería del software como base para valoración. como cmmi, bootstrap proporciona nivel madurez proceso, empleando los resultados cuestionarios que recopilan información acerca del proceso innovación continua fuerza laboral alineación del desempeño organizativomejoramiento capacidad continuomejoramiento continuo identiﬁca desarrolla conocimiento, capacidades habilidades prácticas administración personal básicas, repetiblestutelajeadministración capacidad organizativaadministración desempeño cuantitativoactivos basados competenciagrupos trabajo fortalecidosintegración competencia cultura participación desarrollo grupos trabajoprácticas basadas competenciadesarrollo profesionaldesarrollo competenciasplaniﬁcación fuerza trabajoanálisis competencia compensación capacitación desarrolloadministración del desempeñoentorno laboralcomunicación coordinacióndotación personaloptimizado cuantiﬁca gestiona conocimiento, capacidades habilidadespredecible deﬁnido administrado inicialprácticas inconsistentesáreas proceso nivel enfoquefigura . áreas proceso para cmm personal además del cmm, ¿existen otros marcos conceptuales mps que puedan considerarse?? (-).indd (-).indd // ::// :: mejoramiento del proceso software software “como ” proyectos software. los lineamientos mps basan nivel madu- rez metas organizativas. psp tsp. aunque mps generalmente caracteriza como una actividad organizativa, hay razón por que mejoramiento del proceso pueda realizarse nivel individual equipo. anto psp como tsp (capítulo ) enfatizan necesidad recopilar datos continua- mente acerca del trabajo que realiza usar dichos datos para desarrollar estrategias para mejoramiento. watts humphrey [hum], desarrollador ambos métodos, comenta: psp [ tsp] mostrará cómo planificar rastrear trabajo cómo producir software alta cali- dad manera consistente. usar psp [ tsp], contará con los datos que muestran efectividad trabajo que identifican sus fortalezas debilidades [...] para tener una carrera exitosa gratifi-cante, necesita conocer sus capacidades habilidades, luchar por mejorarlas capitalizar sus talentos únicos trabajo que realice. tickit. método auditoría ticket garantiza cumplimiento con iso : para software: estándar genérico que aplica cualquier organización que quiera mejorar calidad global los productos, sistemas servicios que ofrece. por tanto, estándar directamente aplica-ble organizaciones compañías software. estrategia subyacente sugerida por iso : describe forma siguiente [iso]: iso : subraya importancia para una organización identificar, implementar, gestionar mejorar continuamente efectividad los procesos que son necesarios para sistema gestión calidad, administrar las interacciones dichos procesos con finalidad lograr los -jetivos organización [...] efectividad eficiencia del proceso pueden valorarse través procesos revisión interna externa evaluarse sobre una escala madurez. iso : adoptó ciclo “planificar-hacer-verificar-actuar” que aplica los elemen- tos gestión calidad proyecto software. dentro contexto software, “planificar” establece los objetivos, actividades tareas del proceso, necesarios para lograr soft-ware alta calidad resultante satisfacción del cliente. “hacer” implementa proceso software (incluidas tanto actividades marco conceptual como sombrilla). “verificación” monitorea mide proceso para asegurar que lograron todos los requisitos establecidos para gestión calidad. “actuar”, inician las actividades mejoramiento del proceso software que trabajan continuamente para mejorar proceso. tickit puede usarse través del ciclo “planificar-hacer-verificar-actuar” fin garantizar que proceso mps avanza. los auditores tickit valoran aplicación del ciclo como precursor certificación iso :. para análisis detallado iso : tickit debe examinar [ant], [tri] [sch]. . endimiento sobre inversión mps mps representa trabajo duro requiere inversión sustancial dinero personal. los administradores que aprueben presupuesto los recursos para mps invariablemente plantea-rán pregunta: ¿cómo que lograremos rendimiento razonable por dinero que gaste-mos? cualitativamente, quienes impulsan mps arguyen que proceso software mejorado conducirá calidad software mejorada. afirman que proceso mejorado dará como resul-tado implementación mejores filtros calidad ( que arrojará menos defectos propaga-dos), mejor control cambio (que como resultado menos caos proyecto) menos reela-boración técnica ( que desemboca menor costo mejor tiempo llegada mercado). cita: “las organizaciones software muestran limitaciones significa-tivas habilidad para capitalizar las experiencias obtenidas los proyectos com-pletados.” nasa webref excelente resumen iso : puede encontrarse http://praxiom.com/iso-.htm (-).indd (-).indd // ::// :: parte cinco temas avanzados ¿pero estos beneficios cualitativos pueden traducirse resultados cuantitativos? ecuación clásica rendimiento sobre inversión (rsi) : rsi / //(beneficios) / /(costos) /(costos) / / % donde los beneficios incluyen los ahorros costo asociados con productos mayor calidad (menos defectos), menos reelaboración, esfuerzo reducido asociado con cambios ingreso que acumula por menor tiempo llegada mercado. los costos incluyen tanto costos mps directos (por ejemplo, capacitación, medición) como costos indirectos asociados con mayor énfasis control calidad las activida-des gestión del cambio, así como por aplicación más rigurosa los métodos ingenie-ría del software (por ejemplo, creación modelo diseño). mundo real, dichas cantidades beneficios costos ocasiones son difíciles medir con precisión están abiertos interpretación. pero ello significa que una organización software debe realizar programa mps sin análisis cuidadoso los costos beneficios que acumula. tratamiento amplio rsi para mps puede encontrarse libro inigualable david rico [ric]. . endencias mps durante las dos décadas pasadas, muchas compañías intentaron mejorar sus prácticas inge-niería del software aplicar marco conceptual mps para efectuar cambio organizacional transición tecnológica. como observó anteriormente, este capítulo, más mitad fra-casan esta labor. sin importar éxito fracaso, todos gastan una cantidad significativa dinero. david rico [ric] reporta que una aplicación típica marco conceptual mps como cmm sei, ¡puede costar entre $ $ por persona tardar años comple-tarse! debe sorprenderle que futuro mps deba enfatizar enfoque menos costoso consumidor tiempo. para ser efectivo mundo desarrollo del software del siglo xxi, los futuros marcos conceptuales mps deben volverse significativamente más ágiles. lugar enfoque cen-trado organización (que puede tardar años completarse exitosamente), los esfuerzos mps contemporáneos deben enfocarse nivel del proyecto trabajar para mejorar pro-ceso equipo semanas, meses años. para lograr resultados significativos (incluso nivel del proyecto) tiempo corto, los modelos marco conceptual complejos pue-den dar lugar modelos más simples. lugar decenas prácticas clave cientos prác-ticas complementarias, marco conceptual mps ágil enfatiza solamente algunas prácticas esenciales (por ejemplo, análogas las actividades marco conceptual estudiadas largo este libro). cualquier intento mps demanda una fuerza laboral conocedora, pero los gastos edu- cación capacitación pueden ser onerosos deben minimizarse ( simplificarse). lugar cursos aulas (costosos consumidores tiempo), los esfuerzos mps futuros deben apoyarse capacitación basada web que dirija prácticas esenciales. lugar intentos largo plazo por cambiar cultura organización (con todos los peligros políticos que conllevan), cambio cultural debe ocurrir como hace mundo real: pequeño grupo vez hasta alcanzar punto inflexión. trabajo mps las dos décadas anteriores tiene mérito significativo. los marcos concep- tuales los modelos que desarrollaron representan activos intelectuales sustanciales para (-).indd (-).indd // ::// :: mejoramiento del proceso software comunidad ingeniería del software. pero, como todas las cosas, dichos activos guían los intentos futuros mps convertirse dogma recurrente, sino funcionar como base para modelos mps mejores, más simples más ágiles. . esumen marco conceptual mejoramiento del proceso software define las características que debe presentar debe lograrse proceso software efectivo, método valoración que ayuda determinar dichas características están presentes una estrategia para auxiliar una organización software implementar dichas características proceso que encuen-tren debilitadas que falten. sin importar los grupos que defienden mps, meta mejorar calidad del proceso , consecuencia, calidad puntualidad entrega del soft-ware. modelo madurez proceso proporciona indicio global “madurez del proceso” que muestra una organización del software. asimismo, proporciona sentimiento cualitativo sobre efectividad relativa del proceso software que usa actualmente. mapa caminos mps comienza con valoración, una serie actividades evaluación que descubren tanto fortalezas como debilidades forma que organización aplica proceso software existente las prácticas ingeniería del software que pueblan proceso. como consecuencia valoración, una organización software puede desarrollar plan mps global. unos los elementos clave cualquier plan mps son educación capacitación, acti- vidades que enfocan mejorar nivel conocimiento administradores profesionales. una vez que personal está versado las tecnologías software actuales, comienza -lección justificación. dichas tareas conducen elegir arquitectura del proceso soft-ware, los métodos que pueblan las herramientas que soporta. instalación evaluación son actividades mps que ejemplifican los cambios del proceso que valoran eficacia impacto. para mejorar exitosamente proceso software, una organización debe mostrar las - guientes características: compromiso apoyo los administradores para mps, involucra-miento del personal largo del proceso mps, integración del proceso cultura organi-zacional global, una estrategia mps que haya hecho medida las necesidades locales administración sólida del proyecto mps. actualidad usan algunos marcos conceptuales mps. los cmm cmmi sei usan ampliamente. cmm personal particulariza para valorar calidad cultura organización del personal que puebla. spice, bootstrap, psp, tsp tickit son marcos con-ceptuales adicionales que pueden conducir mps efectivo. mps representa trabajo duro que requiere inversión sustancial dinero personal. para garantizar que logre rendimiento razonable sobre inversión, una organización debe medir los costos asociados con mps los beneficios que pueden atribuírsele manera directa. problemas puntos por evaluar .. ¿por qué las organizaciones software con frecuencia luchan cuando embarcan esfuerzo por mejorar proceso software local? .. con sus palabras, describa concepto “madurez proceso”... realice una investigación (verifique sitio web sei) determine distribución madurez pro- ceso para organizaciones software estados unidos mundo. (-).indd (-).indd // ::// :: parte cinco temas avanzados .. usted trabaja para una organización software muy pequeña: sólo personas involucran desarrollo del software. ¿mps para usted? explique respuesta. .. valoración análoga examen médico anual. con examen médico como metáfora, des- criba actividad valoración mps. .. ¿cuál diferencia entre proceso “como ”, proceso “ aquí allá” proceso “por ser”? .. ¿cómo aplica gestión del riesgo dentro del contexto mps?.. seleccione uno los factores cruciales éxito anotados sección ... realice investigación escriba breve ensayo acerca cómo puede lograrse. .. realice investigación explique cómo difiere cmmi predecesor, cmm... seleccione uno los marcos conceptuales mps que estudió sección . escriba breve ensayo que describa con más detalle. lecturas fuentes información adicionales uno los recursos información más exhaustivo más fácil acceso acerca mps desarrolló software engineering institute está disponible sitio web sei contiene cientos artículos, estudios descripciones detalladas acerca marco conceptual mps. durante los años recientes han agregado algunos libros valiosos una amplia literatura desarrollada durante las dos décadas anteriores. land ( jumpstart cmm/cmmi software process improvements, wiley-ieee computer society, ) fusiona los requisitos definidos como parte los cmm cmmi sei con los -tándares ingeniería software del ieee, con énfasis intersección proceso práctica. mutafelija stromberg (systematic process improvement using iso : and cmmi, artech house publishers, ) estudian los marcos conceptuales mps iso : cmmi, “sinergia”. conradi . ( software process improvement: results and experiencia from the field , springer, ) presentan los resultados una serie estudios caso experimentos relacionados con mps. van loon ( process assessment and improve- ment: practical guide for managers, quality professionals and assessors, springer, ) estudia mps dentro del contexto iso/iec . watts humphrey ( psp, addison-wesley, , tsp, addison-wesley, ) aborda marco conceptual mps proceso personal equipo marco conceptual mps proceso equipo software dos libros separados. fantina ( practical software process improvement, artech house publishers, ) brinda lineamiento pragmático con énfasis cmmi/cmm. internet, está disponible una gran variedad fuentes información acerca del mejoramiento del proceso software. una lista actualizada referencias existentes world wide web que son relevan-tes para mps puede encontrarse sitio del libro: (-).indd (-).indd // ::// :: emergentes ingeniería del software conceptos clave bloques constructores . . . . . ciclo promoción excesiva. . . . . . . . . . . . . . . ciclo vida innovación . . . . . . . . . . . complejidad. . . . . . . . . . . . . colaborativo . . . . impulsado por modelo . . . . . . . . . . . . . desarrollo impulsado por pruebas . . . . . . . . . . . . direcciones tecnología. . . . . . . . . . . . . . diseño posmoderno . . . . . . . tecnológica. . . . . . abierta. . . . . . . . . . . . . . . . . . . . . . requerimientos . . . . . . . . . . requerimientos emergentes. . . . . . . . . . . . . software mundo abierto . . . . . . . . . . . . . . . . tendencias blandas . . . . . . . ¿qué ? nadie puede predecir futuro con absoluta certeza. pero posible valorar las tendencias área ingeniería del soft-ware , dichas tendencias, sugerir posibles direcciones para tecnología. eso que intenta hacer este capítulo. ¿quién hace? quienquiera que desee emplear tiem- para situarse frente los conflictos ingeniería del software puede intentar predecir futura dirección tecnología. ¿por qué importante? ¿por qué los antiguos reyes contrataban adivinos? ¿por qué las grandes corporaciones multinacionales contratan firmas consultoras expertos para preparar pronósticos? ¿por qué sustancial porcen-taje del público lee horóscopos? todos ellos quieren cono-cer que está por venir para estar preparados.¿cuáles son los pasos? hay una fórmula para prede- cir futuro. intenta hacer esto recopilar datos, orga-nizarlos para proporcionar información útil, examinar asociaciones sutiles para extraer conocimiento , partir este conocimiento, sugerir probables tendencias que predigan cómo serán las cosas algún tiempo por venir. ¿cuál producto final? una visión del futuro cerca- , que puede ser correcta. ¿cómo aseguro que hice bien? predecir camino que está adelante arte, una ciencia. hecho, muy raro cuando una predicción seria acerca del futuro absolutamente correcta inequívocamente errónea (con excepción, afortunadamente, las predic-ciones del fin del mundo). observan las tendencias intenta extrapolarlas. acertado extrapolación sólo puede valorarse conforme pasa tiempo. una mirada rápidaalo largo relativamente breve historia ingeniería del software, los profesiona- les investigadores desarrollaron una colección modelos proceso, métodos técnicos herramientas automatizadas con intención fomentar cambio funda- mental forma construir software computadoras. aunque las experiencias anterio-res indican otra cosa, existe deseo tácito por encontrar panacea: proceso mágico tecnología trascendente que permitirá construir con facilidad grandes complejos sistemas basados software, sin confusión, sin errores, sin demora, sin los muchos problemas que -davía plagan trabajo software. pero historia indica que búsqueda panacea parece condenada fracaso. las nue- vas tecnologías introducen regularmente, publicitadas con exceso como una “solución” muchos los problemas que enfrentan los ingenieros del software incorporan los pro-yectos, grandes pequeños. los expertos industria resaltan importancia estas “nue-vas” tecnologías software, los conocedores comunidad del software las adoptan con entusiasmo , final cuentas, tienen papel mundo ingeniería del software. pero tienden cumplir promesa , como consecuencia, búsqueda continúa. mili cowan [mil] comentan acerca los retos que afrontan cuando intenta aislar tendencias tecnológicas significativas: ¿qué factores determinan éxito una tendencia? ¿qué caracteriza éxito las tenden- cias tecnológicas? ¿ mérito técnico? ¿ habilidad para abrir nuevos mercados? ¿ pericia para alterar economía los mercados existentes? ¿qué ciclo vida sigue una tendencia? mientras que visión tradicional que las tendencias evolucionan largo ciclo vida predecible bien definido, que avanza una idea inves-tigación producto terminado través proceso transferencia, descubre que muchas tendencias actuales provocaron corto circuito este ciclo siguieron otro. ¿con cuánta anticipación puede identificarse una tendencia exitosa? sabe cómo iden- tificar los factores éxito / entiende ciclo vida una tendencia, entonces busca (-).indd (-).indd // ::// :: parte cinco temas avanzados identificar signos tempranos del éxito una tendencia. manera retórica busca habilidad reconocer siguiente tendencia antes que todos los demás. ¿qué aspectos evolución son controlables? ¿las corporaciones pueden usar influencia mercado para imponer tendencias? ¿qué papel juegan los estándares definición tenden-cias? análisis cuidadoso ada contra java, por ejemplo, debe ser iluminador este respecto. existen respuestas sencillas estas preguntas, puede haber discusión acerca que intentos anteriores por identificar tecnologías significativas fueron mediocres, cuando mucho. ediciones anteriores este libro (durante los años anteriores) analizaron las tec- nologías emergentes impacto proyectado sobre ingeniería del software. algunas han adoptado ampliamente, pero otras nunca alcanzaron potencial. conclusión del autor que las tecnologías vienen van; las tendencias reales que exploran son las más blandas. por esto entiende que progreso ingeniería del software guiará por las tendencias -presariales, organizativas, mercado culturales. dichas tendencias conducen innovación tecnológica. este capítulo observarán algunas tendencias tecnológicas ingeniería del software, pero énfasis principal colocará algunas tendencias empresariales, organizativas, mercado culturales que pueden tener una importante influencia sobre tecnología -geniería del software durante los próximos años. . volución tecnológica libro fascinante que ofrece una atractiva mirada sobre evolución las tecnologías computación ( otras relacionadas), ray kurzweil [kur] argumenta que evolución tecnoló-gica similar evolución biológica, pero que ocurre ritmo más rápido. evolución (biológica tecnológica) ocurre como resultado realimentación positiva: “los métodos más capaces que resultan una etapa del avance evolutivo usan para crear siguiente etapa” [kur]. las grandes preguntas para siglo xxi son: ) ¿cuán rápidamente evoluciona tecnología? ) ¿cuán significativos son los efectos realimentación positiva? ) ¿cuán profundos serán los cambios resultantes? cuando introduce una nueva tecnología exitosa, concepto inicial mueve través “ciclo vida innovación” [gai] razonablemente predecible, que ilustra figura .. fase innovación reconoce problema realizan intentos repetidos para encontrar una solución viable. algún punto, una solución muestra como prometedora. trabajo innovación inicial reproduce fase replicador obtiene uso más amplio. empirismo conduce creación reglas empíricas que gobiernan uso tecnología éxito repetido conduce una teoría más amplia que paso creación herramientas ¿cuáles son las “grandes preguntas” cuando considera evolución tecnológica?? porcentajede adopción innovación replicador empirismo teoría automatización madurezfigura . ciclo vida una innovación tecnológica (-).indd (-).indd // ::// :: tendencias emergentes ingeniería del software automatizadas durante fase automatización. finalmente, tecnología madura usa ampliamente. lector observará que muchas tendencias investigación tecnológicas nunca llegan madurez. hecho, gran mayoría las tecnologías “prometedoras” dominio -geniería del software reciben amplio interés durante algunos años luego caen nicho uso por parte grupo fiel adherentes. esto quiere decir que dichas tecnologías care-cen mérito, sino más bien busca enfatizar que viaje través del ciclo vida innova-ción largo duro. kurzweil [kur] está acuerdo que las tecnologías computación evolucionan tra- vés una “curva ” que muestra crecimiento relativamente lento durante los años formativos tecnología, rápida aceleración durante periodo crecimiento luego periodo nivelación conforme tecnología llega sus límites. pero computación otras tecnologías relacionadas muestran crecimiento explosivo (exponencial) durante las etapas centrales que muestran figura . continuarán haciéndolo. además, conforme una curva termina, otra sustituye con crecimiento incluso más explosivo durante periodo crecimiento. actualidad, estamos rodilla curva para las modernas tecnologías computación, transición entre crecimiento temprano crecimiento explosivo que sigue. implica-ción que, durante los próximos años, verán cambios dramáticos (incluso enloque-cedores) capacidad computación. las décadas por venir darán como resultado cambios rapidez, tamaño, capacidad consumo energía cómputo (por mencionar sólo algu-nas características). kurzweil [kur] sugiere que, dentro años, evolución tecnológica acelerará ritmo cada vez más rápido, que final cuentas conducirá una era inteligencia biológica que fusionará con extenderá inteligencia humana formas que son fascinan-tes imaginar. todo esto, sin importar cómo evolucione, requerirá software sistemas que harán que, comparación, los esfuerzos actuales parezcan infantiles. hacia año , una combinación computación extrema, nanotecnología, redes ubicuas con ancho banda masivamente elevado, robótica conducirán mundo diferente. software, posiblemente formas que todavía pueden comprenderse, continuará residiendo centro este nuevo mundo. ingeniería del software irá. . bservación las tendencias ingeniería del software sección . consideró brevemente las fascinantes posibilidades que pueden acumularse partir tendencias largo plazo computación tecnologías relacionadas. pero ¿ corto plazo? barry boehm [boe] sugiere que “los ingenieros del software enfrentarán los, con frecuen- cia, formidables desafíos lidiar con rápidos cambios, incertidumbre emergencia, depen-dencia, diversidad interdependencia, pero que también tendrán oportunidades realizar significativas aportaciones que harán diferencia fin mejorar”. pero, ¿cuáles son las ten-dencias que permitirán enfrentar dichos desafíos los años por venir?cita: “las predicciones son muy difíci- les hacer, especial cuando tratan acerca del futuro.” mark twain punto clave tecnología computación evoluciona una tasa exponencial crecimiento pronto puede volverse explosivo. por ejemplo, los límites los circuitos integrados pueden alcanzarse dentro siguiente década, pero dicha tecnología puede sustituirse por tecnologías cómputo molecular vendrá otra curva acelerada. kurzweil [kur] presenta argumento técnico razonado que predice una fuerte inteligencia artificial (que pasará prueba turing) hacia sugiere que evolución los humanos las máquinas comenzará fusionarse hacia . gran mayoría los lectores este libro vivirán para ver esto, realidad, llega suceder.cita: “creo que hay mercado mundial para acaso cinco computadoras.” thomas watson, ejecutivo ibm, (-).indd (-).indd // ::// :: parte cinco temas avanzados introducción este capítulo señaló que las “tendencias blandas” tienen impacto significativo sobre dirección global ingeniería del software. pero otras tendencias (“más duras”) orientadas investigación tecnología siguen siendo importantes. las tenden-cias investigación “están impulsadas por las percepciones generales del estado del arte práctica, por percepciones del investigador acerca las necesidades los profesionales, por programas financiamiento nacional que apresuran las metas estratégicas específicas por mero interés técnico” [mil]. las tendencias tecnológicas ocurren cuando las tenden-cias investigación extrapolan para satisfacer necesidades industriales cuando les forma acuerdo con las demandas que impulsa mercado. sección . estudia modelo curva para evolución tecnológica. curva adecuada para considerar los efectos largo plazo las tecnologías centrales conforme evo-lucionan. ¿pero qué hay acerca las innovaciones, herramientas métodos más modestos para corto plazo? gartner group [gar], grupo consultor que estudia las tendencias tecnológicas través muchas industrias, desarrolló ciclo promoción excesiva para tec- nologías emergentes, que representa figura .. ciclo del gartner group muestra cinco fases: • disparador tecnológico: hallazgo investigación lanzamiento nuevo producto innovador que conduce cobertura los medios entusiasmo del público. • pico expectativas infladas: entusiasmo exagerado proyecciones demasiado optimistas del impacto con base éxitos limitados, pero bien publicitados. • desilusión: las proyecciones impacto demasiado optimistas satisfacen los críticos comienzan presionar; tecnología pasa moda entre los conocedores. • pendiente iluminación: uso creciente mediante una amplia variedad compañías conduce una mejor comprensión del verdadero potencial tecnología; surgen métodos herramientas comerciales para apoyar tecnología. • planicie productividad: los beneficios mundo real ahora son obvios uso penetra significativo porcentaje del mercado potencial. toda tecnología ingeniería del software logra pasar través del ciclo promoción excesiva. algunos casos, desilusión justifica tecnología relega oscuridad.punto clave “ciclo promoción excesiva” presenta una visión realista integración tecnológica corto plazo. sin embargo, tendencia largo plazo exponencial. visibilidad disparador tecnológicopico expectativas inﬂadasvalle desilusiónpendiente iluminaciónplanicie productividadfigura . ciclo promoción excesiva del gartner group para tecnologías emergentesfuente: [gar]. (-).indd (-).indd // ::// :: tendencias emergentes ingeniería del software . dentificación “tendencias blandas ” cada nación con una sustancial industria tiene conjunto características únicas que definen forma que dirigen los negocios, dinámica organizacional que surge den-tro una compañía, los distintos conflictos mercadeo que aplica los clientes locales decisiva cultura que dicta toda interacción humana. sin embargo, algunas tendencias cada una dichas áreas son universales tienen mucho que ver con sociología, antropología psi-cología grupos (que con frecuencia conocen como “ciencias blandas”), como tienen que ver con investigación académica industrial. conectividad colaboración (habilitadas por comunicación con alto ancho banda) con- dujeron equipos software que ocupan mismo espacio físico (trabajo distancia empleo tiempo parcial contexto local). equipo colabora con otros equipos que están separados por zonas horarias, lenguaje nativo cultura. ingeniería del software debe respon-der con modelo proceso que abarque “equipos distribuidos” que sea suficientemente ágil para satisfacer las demandas inmediatez, pero suficientemente disciplinado para coor-dinar grupos dispares. globalización conduce una fuerza trabajo diversa ( idioma, cultura, resolución problemas, filosofía administrativa, prioridades comunicación interacción persona per-sona). esto, vez, demanda una estructura organizativa flexible. diferentes equipos ( distintos países) deben responder los problemas ingeniería manera que acomode mejor sus necesidades únicas , mismo tiempo, fomentar nivel uniformidad que per-mita avance proyecto global. este tipo organización sugiere menos niveles admi-nistración mayor énfasis toma decisiones por parte cada equipo. puede condu-cir mayor agilidad, pero sólo los mecanismos comunicación establecen modo que todo equipo pueda entender proyecto estado técnico (vía groupware red) cualquier momento. los métodos herramientas ingeniería del software pueden ayudar lograr cierto nivel uniformidad (equipos que hablan mismo “idioma”, implementado través méto-dos herramientas específicos). proceso software puede proporcionar marco conceptual para ejemplificación estos métodos herramientas. algunas regiones del planeta (estados unidos europa son ejemplos), población está envejeciendo. esta demografía innegable ( tendencia cultural) implica que muchos ingenieros gerentes software experimentados dejarán campo trabajo próxima década. comunidad ingeniería del software debe responder con mecanismos viables que capturen conocimiento estos gerentes técnicos que envejecen [por ejemplo, uso patrones (capítulo ) paso dirección correcta], modo que quede disponible para genera-ciones futuras trabajadores del software. otras regiones del mundo multiplica -mero jóvenes disponibles para industria del software. esto proporciona una oportunidad para moldear una cultura ingeniería del software sin carga años prejuicios “ vieja escuela”. estima que más mil millones nuevos consumidores entrarán mercado laboral mundial próxima década. los consumidores que gastan “economías emergentes supe-rarán por mucho los $ billones” [pet]. hay poca duda que porcentaje trivial este gasto aplicará productos servicios que tengan componente digital, que basen software impulsen mediante . implicación: una creciente demanda para nuevo software. entonces pregunta : ¿pueden desarrollarse nuevas tecnologías ingeniería del software para satisfacer esta demanda mundial? las modernas tendencias mercado con frecuencia impulsan mediante lado suministro. otros casos, los requerimientos del lado cita: “ deben ser suficientes para cualquiera.” bill gates, presidente microsoft, ¿qué tendencias blandas impactarán las tecnologías relacionadas con ingeniería del software?? lado suministro adopta enfoque mercado “construye ellos vendrán”. crean tecnologías únicas los consumidores van masa para adoptarlas... ¡ veces! (-).indd (-).indd // ::// :: parte cinco temas avanzados demanda impulsan mercado. cualquier caso, ¡ ciclo innovación demanda avanza manera que ocasiones hace difícil determinar cuál viene primero! finalmente, cultura humana impacta dirección ingeniería del software. toda generación establece propia huella sobre cultura las próximas serán diferentes. faith popcorn [pop], consultor bien conocido que especializa tendencias culturales, las caracteriza forma siguiente: “nuestras tendencias son fruslerías. ellas perduran, evolu-cionan. representan fuerzas subyacentes, causas primeras, necesidades humanas básicas, -titudes, aspiraciones. nos ayudan navegar por mundo, comprender que sucede por qué, nos preparan para que está por venir”. análisis detallado manera que las modernas tendencias culturales tendrán impacto sobre ingeniería del software deja para quienes especializan las “ciencias blandas”. .. administración complejidad cuando escribió primera edición este libro (), existían los productos digitales consumidor como conocen actualidad, los sistemas basados mainframe que con-tenían millón líneas código fuente (loc) consideraban muy grandes. hoy raro que pequeños dispositivos digitales abarquen entre líneas software medida, acoplado con algunos millones loc para características sistema operativo. los modernos sistemas basados computadora que contienen millones líneas código son raros. futuro relativamente cercano, comenzarán surgir sistemas que requieran más mil millones loc. ¡piense ello por momento!considere las interfaces para sistema mil millones loc, tanto mundo exterior como otros sistemas interoperables, para internet ( sucesor) para los millones componentes internos que deben trabajar conjunto para hacer que opere exitosamente este monstruo computación. ¿existe alguna forma confiable garantizar que todas estas -nexiones permitirán que información fluya manera adecuada? considere proyecto . ¿cómo administra flujo trabajo rastrea progreso? ¿los enfoques convencionales escalarán hacia arriba órdenes magnitud? considere número personas ( sus ubicaciones) que harán trabajo, coordinación del personal tecnología, imparable flujo cambios, probabilidad una multiplata-forma, torno sistema multioperativo. ¿existe alguna forma administrar coordinar personal que trabaje proyecto monstruoso? considere desafío ingeniería. ¿cómo pueden analizarse decenas miles requeri- mientos, limitaciones restricciones manera que garantice que inconsistencia ambigüe-dad, omisiones errores categóricos descubran corrijan? ¿cómo puede crearse una arqui-tectura diseño que sea suficientemente robusta para manejar sistema este tamaño? ¿cómo pueden los ingenieros del software establecer sistema gestión del cambio que tendrá que manipular cientos miles cambios? considere reto asegurar calidad. ¿cómo puede realizarse verificación valida- ción forma significativa? ¿cómo pone prueba sistema mil millones loc? los primeros días, los ingenieros software intentaban administrar complejidad que sólo puede describirse como una forma hoc. actualidad, usan procesos, métodos por ejemplo, los modernos sistemas operativos (como linux, macos windows) tienen entre millones loc. software sistema operativo para dispositivos móviles puede superar millones loc. realidad, este “sistema” será sistema sistemas: cientos aplicaciones interoperativas que trabajen conjunto para lograr algún objetivo global. todos los sistemas complejos son grandes. una aplicación relativamente pequeña (por ejemplo, menos loc) todavía puede ser excesivamente compleja.cita: “ hay razón por que alguien quiera una computado- casa.” ken olson, presidente fundador digital equipment corp., (-).indd (-).indd // ::// :: tendencias emergentes ingeniería del software herramientas para mantener bajo control complejidad. ¿pero mañana? ¿ enfoque actual depende tarea? .. software mundo abierto conceptos tales como inteligencia ambiental, aplicaciones conscientes del contexto com- putación dominante/ubicua enfocan todos integrar sistemas basados software entorno mucho más amplio que una , dispositivo computación móvil cualquier otro dispositivo digital. estas versiones separadas del futuro cercano computación sugieren manera colectiva “software mundo abierto”, que diseña para adaptarse entorno cambio continuo “ autorganizar estructura autoadaptar comportamiento” [bar]. para ayudar ilustrar los desafíos que enfrentarán los ingenieros software futuro previsible, considere noción inteligencia ambiental (ami). ducatel [duc] define ami forma siguiente: “las personas están rodeadas por interfaces intuitivas inteligentes que incrustan todo tipo objetos. entorno inteligencia ambiental capaz reconocer responder presencia diferentes individuos [mientras trabajan] sin obstrucciones manera continua”. examine una visión del futuro cercano que ami vuelto ubicua. usted acaba comprar comunicador personal (llamado -com, dispositivo móvil bolsillo) pasó las semanas anteriores creando “imagen”: todo, desde calendario diario, lista actividades por hacer, libreta direcciones, registros médicos, información relacionada con negocios, documentos viaje, lista deseos (cosas que busca, por ejemplo, libro específico, una botella vino difícil conseguir, curso local soplado vidrio) “-digital” (-), que describe con nivel detalle que permite una presentación digital otros (una especie myspace facebook que mueve con usted). -com contiene identificador personal llamado “clave claves”, identificador personal multifuncional que proporciona acceso permite consultas desde amplio rango dispositivos ami sistemas. debe ser obvio que los temas significativos privacidad seguridad entran juego. “sistema gestión confianza” [duc] será parte integral ami gestionará los privilegios que permitan comunicación con los sistemas redes, salud, entretenimiento, finanzas, -pleo personal. los nuevos sistemas con capacidad ami agregarán red constantemente, cada uno ofrecerá capacidades útiles demandará acceso -com. por tanto, software -com debe diseñarse modo que pueda adaptarse los requerimientos que surgen cuando algún nuevo sistema ami entra línea. existen muchas formas lograr esto, pero línea referencia siguiente: software -com debe ser flexible robusto formas que software convencio-nal puede relacionar. .. requerimientos emergentes comienzo proyecto software, existe una verdad obvia que aplica por igual todo participante involucrado: “ sabes que sabes”. esto significa que los clientes rara vez definen requerimientos “estables”. también significa que los ingenieros del software siempre pueden prever dónde yacen las ambigüedades inconsistencias. los requerimientos cambian, pero eso algo nuevo. una valiosa muy detallada introducción inteligencia ambiental puede encontrarse communication.com/volume.html. puede obtener más información toda interacción con -com ocurre mediante continuos comandos enunciados reconocimiento voz, que evolucionaron para volverse por ciento precisos.punto clave software mundo abierto abarca inteligencia ambiental, aplicaciones conscientes del contexto computación dominante. (-).indd (-).indd // ::// :: parte cinco temas avanzados conforme los sistemas vuelven más complejos, incluso intento rudimentario por esta- blecer requerimientos amplios está condenado fracaso. puede intentarse enunciado las metas globales, lograrse delineado los objetivos intermedios, pero los requerimientos -tables, ¡ por casualidad! los requerimientos emergerán conforme todos los involucrados ingeniería construcción sistema complejo aprendan más acerca , del entorno donde reside los usuarios con los que interactuará. esta realidad implica algunas tendencias ingeniería del software. primero, deben dise- ñarse modelos proceso para abarcar cambio adoptar los preceptos básicos filosofía ágil (capítulo ). continuación, deben usarse juiciosamente los métodos que producen mode-los ingeniería (por ejemplo, modelos requerimientos diseño) porque dichos modelos cambiarán repetidamente conforme adquiera más conocimiento acerca del sistema. final-mente, las herramientas que den apoyo tanto proceso como los métodos deben facilitar adaptación cambio. pero existe otro aspecto los requerimientos emergentes. gran mayoría del software desarrollado fecha supone que frontera entre sistema basado software entorno externo estable. frontera puede cambiar, pero hará forma controlada, que permi-tirá software adaptarse como parte ciclo mantenimiento software regular. esta suposición comienza cambiar. software mundo abierto (sección ..) demanda que los sistemas basados computadora “ adapten reaccionen los cambios manera dinámica, incluso anticipan” [bar]. por naturaleza, los requerimientos emergentes conducen cambio. ¿cómo controla evolución, durante ciclo vida, una aplicación sistema que usa ampliamente qué efecto tiene esto sobre forma que diseña software? conforme crece número cambios, probabilidad efectos colaterales intenciona- dos también hace. esto debe ser una causa preocupación conforme los sistemas complejos con requerimientos emergentes vuelven norma. comunidad ingeniería del software debe desarrollar métodos que ayuden los equipos software predecir impacto los cambios través todo sistema, que, por tanto, mitiga los efectos colaterales inten-cionales. actualidad, capacidad para lograr esto está severamente limitada. .. mezcla talento medida que los sistemas basados software vuelven más complejos, conforme -municación colaboración entre equipos locales vuelven lugar común los requeri-mientos emergentes (con flujo cambios resultante) vuelven norma, propia natura-leza equipo ingeniería del software puede cambiar. cada equipo software debe devolver una variedad talento creativo habilidades técnicas parte sistema com-plejo, proceso global debe permitir que salida dichas islas talento las fusione manera efectiva. alexandra weber morales [mor] sugiere mezcla talento “equipo ensueño software”. cerebro arquitecto jefe que puede navegar entre las demandas los partici-pantes mapearlas marco conceptual tecnológico que puede extenderse implemen-tarse. chica datos una base datos gurú estructuras datos que “descompone filas columnas con profunda comprensión lógica predicados teoría conjuntos, como pertenecen modelo relacional”. bloqueador líder técnico (gerente) que permite equipo trabajar libre interferencia otros miembros del equipo mientras garantiza que ocurra colaboración. hacker programador consumado que está casa con - trones lenguajes puede usarlos manera efectiva. recopilador “descubre hábilmente - querimientos sistema con [...] comprensión antropológica” los expresa con precisión claridad.puesto que los requerimientos emergentes son una realidad, organización debe considerar adoptar modelo proceso incremental.consejo (-).indd (-).indd // ::// :: tendencias emergentes ingeniería del software .. bloques constructores software quienes fomentan una filosofía ingeniería del software enfatizan necesidad reutili- zación código fuente, clases orientadas objeto, componentes, patrones software cots. aunque comunidad ingeniería del software hecho progresos conforme intenta capturar conocimiento pasado reutilizar las soluciones probadas, significativo porcentaje del software que construye actualidad continúa construyéndose “desde cero”. parte razón esto deseo continuo ( los participantes profesionales ingeniería del soft-ware) “soluciones únicas”. mundo del hardware, los fabricantes equipo original (feo) dispositivos digitales usan productos estándar específicos aplicación (peea) producidos por proveedores silicio manera casi exclusiva. estos “hardware mercantiles” proporcionan los bloques constructores necesarios para implementar todo, desde teléfono celular hasta reproductor -dvd. cada vez más, los mismos feo usan “software mercantil”, bloques constructores software diseñados específicamente para dominio aplicación único [por ejemplo, dispositivos voip]. michael ward [war] comenta: una ventaja del uso componentes software que feo puede apalancar funcionalidad proporcionada por software sin tener que desarrollar experiencia doméstica las funciones espe-cíficas invertir tiempo desarrollador esfuerzo por implementar validar los componentes. otras ventajas incluyen habilidad para adquirir desplegar sólo conjunto funcionalidades específicas que son necesarias para sistema, así como habilidad para integrar dichos componen-tes una arquitectura existente. sin embargo, enfoque componente software tiene una desventaja porque existe nivel dado esfuerzo requerido para integrar los componentes individuales producto global. este reto integración puede complicarse aún más los componentes consiguen varios provee-dores, cada uno con propia metodología interfaz. conforme usen fuentes adicionales componentes, esfuerzo requerido para gestionar varios proveedores aumenta hay mayor riesgo encontrar problemas relacionados con interacción través los componentes diferentes fuentes. además las componentes empacadas como software mercantil, existe una creciente tenden- cia adoptar soluciones plataforma software que “incorporan colecciones funcionalida-des relacionadas, por general proporcionados dentro marco conceptual software integrado” [war]. una plataforma software libera feo del trabajo asociado con desarrollo funcionalidad base lugar permite que dedique esfuerzo software aquellas características que diferencian producto. .. cambio percepciones “valor” durante último cuarto del siglo , pregunta operativa que planteaban los empresarios cuando analizaban software era: ¿por qué cuesta tanto? esta pregunta rara vez plantea actualidad sustituyó por: ¿por qué podemos tenerlo ( software / producto -sado software) más pronto? cuando considera software computadora, percepción moderna del valor cambia del valor empresarial (costo rentabilidad) valores cliente que incluyen: rapidez entrega, riqueza funcionalidad calidad global del producto. .. fuente abierta ¿quién posee software que usted organización usa? cada vez más, respuesta “todo mundo”. movimiento “fuente abierta” descrito forma siguiente [oso]: “fuente abierta método desarrollo para software que aprovecha poder revisión pares cita: “ respuesta artística adecuada tecnología digital abra-zarla como una nueva ventana todo que eternamente humano, usarla con pasión, sabiduría, valor alegría.” ralph lombreglia (-).indd (-).indd // ::// :: parte cinco temas avanzados distribuida transparencia procesos. promesa fuente abierta mejor calidad, mayor confiabilidad, más flexibilidad, costo más bajo terminar con candado del proveedor depredador”. término fuente abierta, cuando aplica software computadora, implica que los productos finales ingeniería del software (modelos, código fuente, suites pruebas) están abiertos público pueden revisarse extenderse (con controles) por cualquiera que tenga interés cuente con permiso. “equipo” fuente abierta puede tener algunos miembros del “equipo ensueño” tiempo completo (sección ..), pero número personas que trabajan software expande contrae conforme interés aplicación fortalece debilita. poder del equipo fuente abierta deriva constante revisión pares refactorización diseño/código que como resultado avance lento hacia una solución óptima. lector tiene más interés, weber [web] proporciona una valiosa introducción feller . [fel] editaron una antología exhaustiva objetiva que considera los beneficios proble- mas asociados con fuente abierta. probable que muchas tecnologías emergentes tengan impacto significativo sobre los tipos sistemas basa- dos computadora que evolucionan. dichas tecnologías agregan los retos que enfrentan los ingenieros del software. vale pena anotar las siguientes tecnologías: computación malla (grid computing): esta tecnología (dispo- nible actualidad) crea una red que emplea los miles millones ciclos cpu que estén sin usar cualquier máquina red permite completar tareas cómputo excesivamente com-plejas sin una supercomputadora dedicada ello. para ejem-plo vida real que abarca más . millones compu-tadoras, visite http://setiathome.berkeley.edu/ computación mundo abierto: “ ambiental, implícita, invi- sible adaptativa. consiste que los dispositivos red incrusta-dos entorno proporcionan conectividad servicios todo momento sin obstrucciones” [mcc]. microcomercio: una nueva rama del comercio electrónico que cobra cantidades muy pequeñas por acceder / comprar varios productos con propiedad intelectual. apple itunes ejemplo ampliamente usado. máquinas cognitivas: “santo grial” campo robótica desarrollo máquinas que estén conscientes entorno, que puedan “recoger pistas, responder situaciones siempre cam-biantes interactuar con personas manera natural” [pcm]. las máquinas cognitivas todavía están las primeras etapas desarrollo, pero potencial enorme. pantallas oled: una oled “utiliza una molécula diseñador basada carbono que emite luz cuando una corriente eléctrica pasa través ella. coloque muchas moléculas juntas obten-drá una pantalla superdelgada sorprendente calidad; requiere iluminación trasera que extraiga energía” [pcm]. resultado: pantallas ultradelgadas que pueden enrollarse doblar-, extenderse sobre superficies curvas adaptarse otro modo entorno específico. rfid: identificación por radiofrecuencia lleva computación mundo abierto una base industrial industria productos consumidor. todo, desde tubos dentífrico hasta motores automóviles, identificará conforme muevan través cadena suministro hasta destino final. web .: uno varios servicios web que conducirá una integra- ción todavía mayor web tanto comercio como compu-tación personal. para mayor análisis las tecnologías por llegar, presentadas una combinación única video impreso, visite sitio web consumer electronics association tecnologías por llegar . irecciones tecnología gente siempre parece creer que ingeniería del software cambiará más rápidamente que hace. introduce una nueva “promoción excesiva” tecnología ( nuevo proceso, método único una herramienta excitante) los expertos sugieren que “todo” cambiará. pero ingeniería del software tiene que ver menos con tecnología más con las personas habilidad para comunicar sus necesidades para convertir dichas necesidades realidad. siempre que involucran personas, ocurren cambios lentamente irrupción repetida. sólo (-).indd (-).indd // ::// :: tendencias emergentes ingeniería del software cuando alcanza “punto retorno” [gla], tecnología cae cascada través comunidad ingeniería del software ocurre verdaderamente cambio muy amplio. esta sección examinarán algunas tendencias sobre proceso, métodos herramientas que probable que tengan alguna influencia ingeniería del software durante próxima década. ¿ello conducirá punto retorno? sólo cuestión esperar ver. .. tendencias proceso puede argumentarse que todas las tendencias empresariales, organizativas culturales estudia-das sección . refuerzan necesidad del proceso. ¿pero los marcos conceptuales ana-lizados capítulo proporcionan mapa caminos hacia futuro? ¿los marcos con-ceptuales proceso evolucionarán para encontrar mejor equilibrio entre disciplina creatividad? ¿ proceso software adaptará las diferentes necesidades los participan-tes que procuran software, los que construyen quienes usan? ¿puede haber medio para reducir riesgo para los tres grupos mismo tiempo? estas muchas otras preguntas siguen abiertas. sin embargo, algunas tendencias comienzan surgir. conradi fuggetta [con] sugieren seis “tesis acerca cómo aumentar aplicar mejor los marcos conceptuales mps”. ellos comienzan análisis con siguiente enunciado: una meta quien procura software seleccionar mejor contratista objetiva racionalmente. objetivo una compañía software sobrevivir crecer mercado competitivo. usuario final adquirir producto software que pueda resolver problema correcto, -mento correcto, precio aceptable. podemos esperar mismo enfoque mps esfuerzo consecuente para alojar todos estos puntos vista. los siguientes párrafos adaptan las tesis propuestas por conradi fuggetta [con] para sugerir posibles tendencias proceso durante próxima década. . conforme evolucionan los mar cos conceptuales mps, enfatizarán “estrategias que enfo- can orientación metas innovación del producto” [con]. mundo ace- lerado del desarrollo software, las estrategias mps largo plazo rara vez sobreviven entorno empresarial dinámico. demasiados cambios muy rápidamente. esto sig-nifica que posible que mapa estable caminos paso paso deba sustituirse con marco conceptual que enfatice las metas corto plazo que tenga una orientación producto. los requerimientos para una nueva línea productos basados soft-ware surgirá durante una serie liberaciones producto incrementales (para entrega usuarios finales mediante web), organización software puede reconocer -cesidad mejorar capacidad para gestionar cambio. mejoramiento proceso asociado con gestión del cambio debe coordinarse con los ciclos liberación del producto, manera que mejorará gestión del cambio mientras mismo tiempo perturbe. . puesto que los ingenieros del software tienen buen sentido dónde está débil pro-ceso, los cambios proceso por gener deben impulsarse por sus necesidades - ben comenzar forma ascendente. conradi fuggetta [con] sugieren que las futuras actividades mps deben “usar una tarjeta calificaciones simple enfocada con cual comenzar, con una gran valoración”. enfocar los esfuerzos mps estrechamente trabajar manera ascendente, los profesionales comenzarán ver cambios sustanti-vos más pronto, cambios que hacen una diferencia real forma como realiza trabajo ingeniería del software. . tecnología procesos software automatizados (psa) alejar gestión pro- ceso global (amplio apoyo todo proceso software) enfocará aquellos aspectos del proceso software que puedan beneficiarse mejor automatización. nadie está cita: “¿pero para qué sirve?” comentario ingenie- división sistemas cómputo vanzados ibm, , acerca del microchip ¿qué tendencias proceso son probables durante próxima década?? (-).indd (-).indd // ::// :: parte cinco temas avanzados contra las herramientas automatización, pero, muchas instancias, psa cumple promesa (vea sección .). para ser más efectiva, debe enfocarse actividades sombrilla (capítulo ), los elementos más estables del proceso software. . colocar mayor énfasis rendimiento sobre inversión las actividades mps . capítulo aprendió que rendimiento sobre inversión (rsi) puede definirse como: rsi / /(beneficios) / /(costos) /(costos) / % fecha, las organizaciones software han luchado por delinear con claridad los “beneficios” forma cuantitativa. puede argumentarse [con] que “por tanto, necesi- tamos modelo estandarizado con valor mercado, como que utiliza - como (vea capítulo ) para explicar las iniciativas mejoramiento del software”. . conforme pasa tiempo, com unidad del software puede llegar entender que expe- riencia sociología antropología puede tener tanto más que ver con éxito mps que otras disciplinas más técnicas. sobre todo, mps cambia cultura organización, cambio cultural involucra individuos grupos personas. conradi fuggetta [con] anotan correctamente que “los desarrolladores software son trabajadores del conocimiento. tienden responder negativamente los dictados esferas supe-riores acerca cómo trabajar cambiar los procesos”. posible aprender mucho examinar sociología los grupos para entender mejor las formas efectivas intro- ducir cambio. . nuevos modos aprendizaje pueden facilitar ansición hacia proceso software más efectivo. este contexto, “aprendizaje” implica aprendizaje éxitos errores. una organización software que recopila métricas (capítulos ) permite - tender cómo los elementos proceso afectan calidad del producto final. .. gran desafío existe una tendencia que innegable: los sistemas basados software sin duda volverán más andes más complejos conforme pase tiempo. ingeniería estos grandes sistemas complejos, sin importar plataforma entrega dominio aplicación, que impone “gran desafío” [bro] los ingenieros del software. manfred broy [bro] sugiere que los inge-nieros del software pueden enfrentar “intimidante reto desarrollar sistemas software complejos” crear nuevos enfoques para entender los modelos sistema usar dichos -delos como base para construcción software próxima generación alta calidad. conforme comunidad ingeniería del software desarrolla nuevos enfoques impulsados por modelo (que estudian más adelante esta sección) para representación los reque-rimientos del sistema diseño, pueden abordarse las siguientes características [bro]: • multifuncionalidad: conforme los dispositivos digitales evolucionan hacia segunda tercera generaciones, comienzan entregar rico conjunto , ocasiones, funciones relacionadas. teléfono celular, alguna vez considerado dispositivo comunicación, ahora utiliza para tomar fotografías, conservar calendario, navegar por diario como reproductor música. las interfaces mundo abierto llegan trascender, estos dispositivos móviles usarán para mucho más durante los próximos años. como anota broy [bro], “los ingenieros deben describir contexto detallado que entregarán las funciones , más importante, deben identificar las interacciones potencialmente dañinas entre las diferentes características del sistema”. • reactividad oportunidad: los dispositivos digitales interactúan cada vez más con mundo real deben reaccionar estímulos externos forma oportuna. deben poner ¿qué características del sistema deben considerar analistas diseñadores para futuras aplicaciones?? (-).indd (-).indd // ::// :: tendencias emergentes ingeniería del software interfaz con una amplia serie sensores responder marco temporal que sea adecuado tarea que busca realizar. deben desarrollarse nuevos métodos que ) ayuden los ingenieros software predecir temporalidad varias características reactivas ) implementen dichas características manera que las haga menos depen-dientes máquina más portátiles. • nuevos modos interacción con usuario: teclado ratón funcionan bien entorno , pero las tendencias mundo abierto para software señalan que deben modelarse implementarse nuevos modos interacción. sea que dichos nuevos enfoques usen interfaces toque múltiple, reconocimiento voz interfaces mente directa, las nuevas generaciones software para dispositivos digitales deben modelar estas nuevas interfaces humano-computadora. • arquitecturas complejas: automóvil lujoso tiene más funciones controladas mediante software que residen dentro una compleja arquitectura hardware que incluye múltiples cpu, una sofisticada estructura bus, actuadores, sensores, una interfaz humana cada vez más sofisticada, muchos componentes con clasificación seguridad. sistemas incluso más complejos están horizonte inmediato, que presenta retos significativos para los diseñadores software. • sistemas heterogéneos distribuidos: los componentes tiempo real para cualquier moderno sistema incrustado pueden conectarse mediante bus interno, una red inalámbrica través internet ( todo junto). • crucialidad: software convertido componente pivote virtualmente todos los sistemas cruciales para los negocios mayoría los sistemas importantes para seguridad. sin embargo, comunidad ingeniería del software apenas comienza aplicar incluso los principios más básicos seguridad software. • variabilidad mantenimiento: vida del software dentro dispositivo digital rara vez dura más allá años, pero los complejos sistemas aviónica dentro una aeronave tienen una vida útil menos años. software los automóviles falla alguna parte intermedia. ¿esto tendrá algún impacto sobre diseño? broy [bro] argumenta que éstas otras características del software pueden gestionarse sola-mente comunidad ingeniería del software desarrolla una filosofía ingeniería del soft-ware distribuida manera más efectiva colaborativa, mejores enfoques ingeniería -querimientos, enfoque más robusto desarrollo impulsado por modelo mejores herramientas software. las secciones que siguen explorará brevemente cada una estas áreas. .. desarrollo colaborativo parece casi demasiado obvio afirmar, pero hará cualquier forma: ingeniería del soft- ware una tecnología información. desde inicio cualquier proyecto software, cada participante debe compartir información: acerca las metas objetivos empresariales básicos, los requerimientos sistema específicos, conflictos diseño arquitectónico, casi todo aspecto del software que construir. actualidad, los ingenieros software colaboran través zonas horarias fronteras internacionales, cada uno ellos debe compartir información. mismo cierto para los proyectos fuente abierta los que trabajan cientos miles desarrolladores software breve estudio acerca las interfaces mente directa puede encontrarse http://.wikipedia.org/ wiki/brain-computer_interface, ejemplo comercial describe http://.gamespot.com/ news/.htmlpunto clave colaboración involucra diseminación oportuna información proceso efectivo para comunicarse tomar decisiones. (-).indd (-).indd // ::// :: parte cinco temas avanzados para construir una aplicación fuente abierta. nuevo, información debe diseminarse modo que pueda ocurrir colaboración abierta. reto durante próxima década desarrollar métodos herramientas que faciliten dicha colaboración. hoy día, continúa lucha por facilitar colaboración. eugene kim [kim] -menta: considere una tarea colaboración básica: compartir documentos. algunas aplicaciones (tanto - merciales como fuente abierta) afirman resolver problema compartir documentos , sin -bargo, método predominante para compartir archivos enviarlos por correo electrónico ida vuelta. éste equivalente computacional sneakernet. las herramientas que tienen pro- pósito resolver este problema son buenas, ¿por qué utilizan? otras áreas básicas ven problemas similares. puedo una reunión cualquier parte del mundo con trozo papel mano, puedo estar seguro que gente querrá leerlo, marcarlo, darle vueltas archivarlo. puedo decir mismo los documentos electrónicos. puedo anotar una página web usar mismo sistema llenado para correo electrónico para los documen-tos word, menos una forma que garantice interoperabilidad con las aplicaciones propia máquina otras. ¿por qué ? …con finalidad tener impacto real espacio colaborador, las herramientas sólo deben ser buenas, deben ser interoperables. pero falta herramientas colaborativas amplias sólo una parte del reto que enfrentan quienes deben desarrollar software manera colaborativa. actualidad, porcentaje significativo los proyectos subcontratan nivel - ternacional, número crecerá sustancialmente durante siguiente década. sorpren-der que bhat . [bha] aseveren que ingeniería requerimientos actividad crucial proyecto subcontratado. los autores identifican algunos factores éxito que conducen esfuerzos colaboración exitosos: • metas compartidas: las metas del proyecto deben enunciarse con claridad, todos los participantes deben comprenderlas estar acuerdo con intención. • cultura compartida: las diferencias culturales deben definirse con claridad; debe desarro-llarse enfoque educativo (que ayudará mitigar dichas diferencias) enfoque comunicación (que facilitará transferencia conocimiento). • proceso compartido: algunas formas, proceso funciona como esqueleto proyecto colaborativo, que proporciona medio uniforme para valorar progreso dirección, para introducir “lenguaje” técnico común para todos los miembros del equipo. • responsabilidad compartida: todo miembro del equipo debe reconocer importancia ingeniería requerimientos trabajar para ofrecer mejor definición posible del sistema. cuando combinan, dichos factores éxito conducen “confianza”: equipo global que puede apoyarse grupos dispares para lograr trabajo que les asignó. .. ingeniería requerimientos los capítulos del presentaron las acciones básicas ingeniería requerimientos: adquisición, elaboración, negociación, especificación validación. éxito fracaso dichas actualmente, alrededor por ciento presupuesto típico las compañías grandes dedica sub- contratación (outsourcing) porcentaje crece cada año. (fuente: (-).indd (-).indd // ::// :: tendencias emergentes ingeniería del software acciones tiene una influencia muy fuerte sobre éxito fracaso todo proceso inge- niería del software. , sin embargo, ingeniería requerimientos () compara con “inten-tar poner una abrazadera sujeción alrededor una gelatina” [gon]. como señala muchos lugares largo este libro, los requerimientos software tienen tendencia seguir cambiando, con llegada los sistemas mundo abierto, los requerimientos emer-gentes ( cambio casi continuo) pueden volverse norma. actualidad, mayoría los enfoques ingeniería requerimientos “informales” comienzan con creación escenarios usuario (por ejemplo, casos uso). los enfoques más formales crean uno más modelos requerimientos uso los mismos como base para diseño. los métodos formales permiten que ingeniero software represente los requerimientos, usando una notación matemática verificable. todo puede funcionar razonable-mente bien cuando los requerimientos son estables, pero resuelve fácilmente problema los requerimientos dinámicos emergentes. existen algunas direcciones distintas investigación ingeniería requerimientos, incluidos procesamiento lenguaje natural partir descripciones textuales traducidas representaciones más estructuradas (por ejemplo, clases análisis), mayor apoyo sobre bases datos para estructurar comprender los requerimientos software, uso patrones para describir problemas soluciones usuales cuando realizan las tareas ingeniería requerimientos ingeniería requerimientos orientada metas. sin embargo, industrial-mente, las acciones siguen siendo más menos informales sorprendentemente básicas. para mejorar forma que definen los requerimientos, comunidad ingeniería del software probablemente implementará tres subprocesos distintos conforme lleve cabo [gli]: ) adquisición conocimiento mejorado compartición conocimiento que per-mita comprensión más completa las restricciones del dominio aplicación las necesida-des los participantes, ) mayor énfasis iteración conforme definen los requerimientos ) herramientas comunicación coordinación más efectivas que permitan todos los par-ticipantes colaborar manera efectiva. los subprocesos señalados párrafo anterior solamente triunfarán integran manera adecuada enfoque evolutivo ingeniería del software. conforme resolución problemas basada patrones las soluciones basadas componentes comiencen -minar muchos dominios aplicación, debe acomodar deseo agilidad (rápida entrega incremental) los requerimientos emergentes inherentes que resulten. naturaleza concu-rrente muchos modelos proceso ingeniería del software significa que integrará con actividades diseño construcción. consecuencia, noción una “especificación software” estática comienza desaparecer, para ser sustituida por “requerimientos impulsados por valores” [som] derivada conforme los participantes responden las características fun-ciones entregadas los incrementos software anteriores. .. desarrollo software impulsado por modelo los ingenieros software aferran abstracción virtualmente cada paso del proceso ingeniería del software. conforme comienza diseño, las abstracciones arquitectónicas nivel componente representan valoran. luego deben traducirse una representación lenguaje programación que transforme diseño ( nivel abstracción relativamente alto) sistema operativo con entorno computación específico ( nivel abstracción bajo). desarrollo software impulsado por modelo acopla lenguajes modelado específicos dominio con motores generadores transformación, manera que facilita represen-tación abstracción niveles altos luego los transforma niveles más bajos [sch].punto clave “los nuevos subprocesos incluyen: ) adquisición conocimiento mejorado, ) incluso más iteración ) herramientas comunicación coordinación más efectivas”. punto clave enfoque impulsado por modelo enfrenta desafío permanente para todos los desarrolladores software: cómo representar software nivel mas alto abstracción que código. también usa término ingeniería impulsada por modelo (iim). (-).indd (-).indd // ::// :: parte cinco temas avanzados los lenguajes modelado específicos dominio (lmed) representan “ estructura, compor- tamiento requerimientos aplicación dentro dominios aplicación particulares” describen con metamodelos que “definen las relaciones entre conceptos domino especi-fican con precisión semántica restricciones clave asociadas con dichos conceptos domi-nio” [sch]. diferencia principal entre lmed lenguaje modelado propósito general como uml (apéndice ) que primero sintoniza con los conceptos diseño -herentes dominio aplicación , por tanto, puede representar relaciones restricciones entre elementos diseño forma eficiente. .. diseño posmoderno interesante artículo acerca del diseño software “era posmoderna”, philippe kru-chten [kru] hace siguiente observación: ciencia computación logrado gran narrativa que explique todo, gran cuadro : hemos encontrado las leyes fundamentales del software que jugarían papel que las leyes fundamen- tales física juegan otras disciplinas ingeniería. todavía vivimos con resabio amargo explosión burbujas internet día del juicio final . modo que, esta era posmo-derna, donde parece que todo importa poco, aunque realmente importa mucho, ¿cuáles son las siguientes direcciones para diseño software? parte cualquier intento por comprender las tendencias diseño del software establecer fronteras diseño. ¿dónde detiene ingeniería requerimientos comienza diseño? ¿dónde detiene diseño comienza generación código? las respuestas estas pre-guntas son sencillas como podrían parecer principio. aun cuando modelo requeri-mientos deba enfocarse “qué”, “cómo”, todo analista hace poco diseño casi todos los diseñadores hacen poco análisis. igual modo, conforme diseño compo-nentes software acerca poco más detalle algorítmico, diseñador comienza -presentar componente nivel abstracción que está cerca del código. diseño posmoderno continuará enfatizando importancia arquitectura del software (capítulo ). diseñador debe enunciar conflicto arquitectónico, tomar una decisión que aborde conflicto luego definir con claridad las suposiciones, restricciones implicaciones que decisión impone sobre software como todo. pero, ¿existe marco conceptual donde los conflictos pueden describirse arquitectura puede definirse? desarrollo soft-ware orientado aspecto (capítulo ) desarrollo software impulsado por modelo (sección ..) pueden convertirse importantes enfoques diseño los años por venir, pero toda-vía muy pronto para decirlo. puede ser que innovación desarrollo basado compo-nentes (capítulo ) pueda conducir una filosofía diseño que enfatice ensamblado los componentes existentes. pasado prólogo, enormemente probable que surjan muchos “nuevos” métodos diseño, pero pocos remontarán curva promoción excesiva (figura .) mucho más allá del “valle desilusión”. .. desarrollo impulsado por pruebas los requerimientos impulsan diseño éste establece cimiento para construcción. esta simple realidad ingeniería del software funciona razonablemente bien esencial confor- crea una arquitectura software. sin embargo, cambio sutil puede proporcionar -neficios significativos cuando consideran diseño nivel componentes construc-ción. desarrollo impulsado por pruebas (dip), los requerimientos para componente soft- ware funcionan como base para creación una serie casos prueba que ejerciten interfaz que intenten encontrar errores las estructuras datos funcionalidad que punto clave “dip una tendencia que enfatiza diseño casos prueba antes creación código fuente”. (-).indd (-).indd // ::// :: tendencias emergentes ingeniería del software entrega componente. dip realmente una nueva tecnología, sino más bien una ten- dencia que enfatiza diseño casos prueba antes creación código fuente. proceso dip sigue simple flujo procedural que ilustra figura .. antes crear primer pequeño segmento código, ingeniero software crea una prueba para ejerci-tar código (intentar que fracase código). entonces código escribe para satisfacer prueba. pasa, crea una nueva prueba para siguiente segmento código que desarrollar. proceso continúa hasta que componente está completamente codificado -das las pruebas ejecutan sin error. sin embargo, alguna prueba triunfa encontrar error, código existente refactoriza (corrige) todas las pruebas creadas para dicho punto vuelven ejecutar. este flujo iterativo continúa hasta que hay pruebas pendientes crear, que implica que los componentes satisfacen todos los requerimientos definidos para . durante dip, código desarrolla incrementos muy pequeños (una subfunción vez) escribe código hasta que exista una prueba que ejercite. debe observar que cada iteración resulta una más pruebas nuevas que agregan una suite pruebas regre-sión que corren con cada cambio. esto hace para garantizar que nuevo código generó efectos colaterales que causen errores código anterior. dip, las pruebas impulsan diseño componentes detallados código fuente resul- tante. los resultados dichas pruebas causan modificaciones inmediatas diseño compo-nentes (vía código) , más importante, componente resultante (cuando completa) verificó forma independiente. tiene más interés dip, consulte [bec] [ast]. . endencias relacionadas con herramientas cada año introducen cientos herramientas ingeniería del software grado industrial. mayoría las aportan los proveedores herramientas, quienes afirman que herramienta recuerde que programación extrema (capítulo ) enfatiza este enfoque como parte modelo proceso ágil.faltan pruebas por crearcreación caso prueba escribir nuevo segmento código correr () prueba()refactorizar (corregir) segmento códigono quedan pruebas por crear encuentra error encuentra errorfigura . flujo proceso desarrollo impulsado por pruebas (-).indd (-).indd // ::// :: parte cinco temas avanzados mejorará administración del proyecto, análisis requerimientos, modelado diseño, generación código, las pruebas, gestión del cambio cualquiera las muchas activi-dades, acciones tareas ingeniería del software que estudian largo este libro. otras herramientas desarrollaron como ofrecimientos fuente abierta. mayoría las herramientas fuente abierta enfocan las actividades “programación” con énfasis específico actividad construcción (particularmente generación código). incluso otras herramientas derivan esfuerzos investigación universidades laboratorios gubernamentales. aunque tienen atractivo aplicaciones muy limitadas, mayoría está lista para aplicación industrial amplia. nivel industrial, los paquetes herramientas más amplios forman entornos ingenie- ría del software (eis) que integran una colección herramientas individuales torno una base datos central (repositorio). cuando considera como todo, eis integra informa-ción través del proceso software auxilia colaboración que requiere para sistemas basados computadora muy grandes complejos. pero los entornos actuales son fácil-mente extensibles ( difícil integrar una herramienta cots que sea parte del paquete) tienden ser propósito general ( decir, son específicas dominio aplicación). tam-bién existe una considerable demora temporal entre introducción las nuevas soluciones tecnológicas (por ejemplo, desarrollo software impulsado por modelo) disponibilidad eis viables que den soporte nueva tecnología. las futuras tendencias las herramientas software seguirán dos rutas distintas: una ruta enfocada humano que responda algunas las “tendencias blandas” estudiadas sec-ción . una ruta centrada tecnología que aborde las nuevas tecnologías (sección .) conforme introduzcan adopten. las siguientes secciones examinará brevemente cada ruta. .. herramientas que responden tendencias blandas las tendencias blandas analizadas sección . ( necesidad administrar compleji-dad, acomodar requerimientos emergentes, establecer modelos proceso que aborden cambio, coordinar equipos globales con una mezcla talento cambiante, entre otros) sugiere una nueva era que las herramientas que apoyen colaboración los participantes volverán tan importantes como las herramientas que apoyan tecnología. ¿pero qué tipo conjunto herramientas soportan dichas tendencias blandas? ejemplo investigación esta área genesis, entorno generalizado fuente abierta diseñado para soportar trabajo colaborativo ingeniería del software [ave]. -torno genesis puede volverse uso amplio, pero sus elementos básicos son representa-tivos dirección eis colaboradores que evolucionarán para dar apoyo las tendencia blandas anotadas este capítulo. eis colaborativo “soporta cooperación comunicación entre ingenieros software que pertenecen equipos desarrollo distribuidos, involucrados modelar, controlar medir desarrollo del software los procesos mantenimiento. más aún, incluye una función administración artefacto que almacena gestiona artefactos software (productos opera-tivos) producidos por diferentes equipos curso “trabajo” [bol]. figura . ilustra una arquitectura para eis colaborativo. arquitectura, basada entorno genesis [ave], construye con subsistemas que integran dentro cliente web común que complementa mediante componentes basados servidor que proporcio-nan apoyo todos los clientes. cada organización desarrollo tiene sus propios subsistemas lado cliente que comunican con otros clientes. figura ., subsistema gestión también usa término entorno desarrollo integrado (edi). (-).indd (-).indd // ::// :: tendencias emergentes ingeniería del software recursos administra asignación recursos humanos diferentes proyectos subproyec- tos; sistema administración producto trabajo “responsable creación, modifi- cación, borrado”, indexado, búsqueda almacenamiento todos los productos operativos ingeniería del software [ave]; subsistema gestión flujo trabajo coordina defi- nición, ejemplificación implementación las actividades, acciones tareas del proceso software; motor evento “recopila eventos” que ocurren durante proceso software (por ejemplo, una revisión exitosa producto operativo, conclusión pruebas unidad componente) notifica otros; sistema comunicación soporta comunicación sincró-nica asíncrona entre los equipos distribuidos. lado servidor, cuatro componentes comparten una base datos apoyo flujo trabajo. los componentes implementan las siguientes funciones: • definición proceso: conjunto herramientas que permiten equipo definir nuevas actividades, acciones tareas proceso que define las reglas que gobiernan manera que interactúan dichos elementos unos con otros los productos opera-tivos que producen. • administración proyecto: conjunto herramientas que permiten equipo construir plan proyecto coordinar plan con otros equipos proyectos. • motor flujo trabajo: “interactúa con motor eventos para propagar eventos que son relevantes para ejecución procesos cooperativos que ejecutan otros sitios” [ave]. • manipulador lista trabajo: interactúa con base datos del lado servidor para brindar ingeniero software información acerca tarea que actualmente desarrolla cualquier tarea futura que derive del trabajo que actualmente realiza.sistema gestión ﬂujo trabajocapa coordinación lado cliente sistema comunicación sistema gestión recursos sistema administración producto operativomanipulador lista trabajolado servidor motor ﬂujo trabajo herramienta deﬁnición procesos base datos apoyo ﬂujo trabajoherramienta administración proyectootros sitios equipos motor eventosfigura . arquitectura eis colaborativafuente: adaptado [ave]. (-).indd (-).indd // ::// :: parte cinco temas avanzados aunque arquitectura eis colaborativo puede variar considerablemente del que estudió esta sección, los elementos funcionales básicos (sistemas componentes admi- nistración) parecerán lograr nivel coordinación que requiere para proyecto inge-niería del software distribuida. .. herramientas que abordan tendencias tecnológicas agilidad ingeniería del software (capítulo ) logra cuando los participantes trabajan como equipo. por tanto, tendencia hacia los eis colaborativos (sección ..) brindará beneficios aun cuando software desarrolle manera local. pero, ¿qué hay acerca las herramientas tecnológicas que complementan sistema los componentes que fortalecen una mejor colaboración? una las tendencias dominantes las herramientas tecnológicas creación conjunto herramientas que apoyo desarrollo impulsado por modelo (sección ..) con énfasis diseño impulsado por arquitectura. oren novotny [nov] sugiere que modelo, más que código fuente, convierte foco central ingeniería del software: uml crean modelos independientes plataforma luego experimentan varios niveles transformación para eventualmente devanarse como código fuente para una plataforma específica. entonces, lógico que modelo, archivo, deba convertirse nueva unidad salida. modelo tiene muchas visiones diferentes diferentes niveles abstracción. más alto, los componentes independientes plataforma pueden especificarse análisis; más bajo, existe una implementación específica plataforma que reduce conjunto clases código. novotny argumenta que una nueva generación herramientas funcionará conjunción con repositorio para: crear modelos todos los niveles necesarios abstracción, establecer relaciones entre varios modelos, traducir los modelos nivel abstracción otro (por ejemplo, traducir modelo diseño código fuente), gestionar cambios versiones, coordinar las acciones control aseguramiento calidad contraste con los modelos software. además completar los entornos ingeniería del software, las herramientas solución puntual que abordan todo, desde recopilación requerimientos hasta refactorización -seño/código pruebas, continuarán evolucionando volverán más funcionalmente capaces. algunas instancias, las herramientas modelado pruebas dominio aplicación específico proporcionarán beneficios aumentados cuando comparen con sus equivalentes genéricos. . esumen las tendencias que tienen efecto sobre tecnología ingeniería del software con frecuencia provienen las áreas negocios, organizacional, mercado cultural. dichas “tendencias blandas” pueden guiar dirección investigación tecnología que deriva como con-secuencia investigación. conforme introduce nueva tecnología, avanza través ciclo vida que siem- pre conduce una adopción extensa, aun cuando las expectativas originales sean altas. grado que cualquier tecnología ingeniería del software gana adopción extensa está ligado habilidad para abordar los problemas impuestos por las tendencias blandas duras. las tendencias blandas ( creciente necesidad conectividad colaboración, proyectos globales, transferencia conocimiento, impacto las economías emergentes influencia cultura humana ) conducen conjunto retos que abarcan complejidad admi-nistrativa los requerimientos emergentes, hasta hacer malabares con una mezcla talentos siempre cambiante entre equipos software dispersos geográficamente. (-).indd (-).indd // ::// :: tendencias emergentes ingeniería del software las tendencias duras ( ritmo siempre acelerado del cambio tecnológico) fluyen desde las tendencias blandas afectan estructura del software ámbito del proceso forma que caracteriza marco conceptual proceso. desarrollo colaborativo, nuevas formas ingeniería requerimientos, desarrollo basado modelo impulsado por pruebas diseño posmoderno cambiarán panorama los métodos. los entornos herramientas responderán una necesidad creciente comunicación colaboración mismo tiempo integrarán soluciones puntuales específicas dominio que pueden cambiar naturaleza las actuales tareas ingeniería del software. problemas puntos por evaluar .. obtenga una copia del libro the tipping point, malcolm gladwell (disponible mediante google book search) analice cómo aplican sus teorías adopción nuevas tecnologías ingeniería del soft-ware. .. ¿por qué software mundo abierto presenta desafío los enfoques convencionales inge- niería del software? .. revise ciclo promoción excesiva para tecnologías emergentes del gartner group. seleccione producto tecnológico muy conocido presente una breve historia que ilustre cómo viajó largo curva. seleccione otro producto tecnológico muy conocido que siguió ruta sugerida por curva. .. ¿qué una “tendencia blanda”?.. usted enfrenta con problema extremadamente complejo que requerirá una solución extensa. ¿cómo abordaría complejidad crearía una respuesta? .. ¿cuáles son los “requerimientos emergentes” por qué presentan reto para los ingenieros soft- ware? .. seleccione esfuerzo desarrollo fuente abierta (distinto linux) presente una breve historia evolución éxito relativo. .. describa cómo cree que cambiará proceso software durante próxima década... usted está ubicado los ángeles trabaja equipo ingeniería software global. usted sus colegas londres, mumbai, hong kong sidney deben editar una especificación requerimientos páginas para sistema grande. primera edición debe completarse tres días. describa conjunto ideal herramientas línea que permitirían colaborar manera efectiva. .. describa desarrollo software impulsado por modelo con sus propias palabras. haga mismo para desarrollo impulsado por pruebas. lecturas fuentes información adicionales los libros que estudian camino por venir para software computación abarcan una gran variedad temas técnicos, científicos, económicos, políticos sociales. kurweil ( the singularity near , penguin books, ) presenta una mirada persuasiva mundo que cambiará formas realmente profundas hacia mediados este siglo. sterling ( tomorrow now, random house, ) recuerda que progreso real rara vez ordenado eficiente. teich ( technology and the future, wadworth, ) presenta ensayos concien- zudos acerca del impacto social tecnología cómo cultura cambiante forma tecnología. naisbitt, phillips naisbitt (high tech/high touch, nicholas brealey, ) observan que muchas personas han “intoxicado” con alta tecnología que “ gran ironía era alta tecnología que nos estamos volviendo esclavos los dispositivos que suponía que nos darían libertad”. zey ( the future factor, mcgraw-hill, ) estudia cinco fuerzas que darán forma destino humano durante este siglo. -groponte (being digital, alfred . knopf, ) fue best seller mediados los años continúa ofreciendo una visión comprensiva computación impacto global. conforme software vuelve parte del tejido virtualmente cada faceta vida, “cibernética” evolucionó como importante tema estudio. los libros spinello (cyberethics: morality and law cyberspace, jones & bartlett publishers, ), halbert ingulli (cyberethics, south-western college publish- (-).indd (-).indd // ::// :: parte cinco temas avanzados ers, ), baird . (cyberethics: social and moral issues the computer age , prometheus books, ) consideran tema con detalle. gobierno estadounidense publicó voluminoso reporte -rom ( century guide cybercrime, progressive management, ) que considera todos los aspectos del crimen computacional, los temas propiedad intelectual national infraestrutura protection center (nipc, centro nacional protección infraestructura). internet, está disponible una gran variedad fuentes información acerca las direcciones futuras las tecnologías relacionadas con software ingeniería del software. una lista actualizada referen-cias world wide web que son relevantes para las futuras tendencias ingeniería del software puede encontrarse sitio del libro: htm (-).indd (-).indd // ::// :: finales conceptos clave conocimiento. . . . . . . . . . . . ética. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . visita software . . . . . . . . . . . . . . . . . . información . . ¿qué ? conforme aproxima final viaje relativamente largo través inge-niería del software, momento poner las cosas perspectiva hacer algunos comenta- rios finales. ¿quién hace? autores como actual. cuando llega final largo desafiante libro bueno cerrar las cosas forma significativa. ¿por qué importante? siempre vale pena recordar dónde estuvo considerar hacia dónde .¿cuáles son los pasos? considerará dónde estuvo abordarán algunos temas centrales orientaciones para futuro. ¿cuál producto final? análisis que ayudará entender gran cuadro. ¿cómo aseguro que hice bien? difícil lograr tiempo real. sólo después algunos años podrá decirse los conceptos, principios, métodos técnicas ingeniería del software que estudiaron este libro ayudaron convertirse mejor ingeniero del software.una mirada rápidaen los capítulos que precedieron actual, exploró proceso ingeniería del soft- ware que abarca procedimientos administrativos métodos técnicos, conceptos princi-pios básicos, técnicas especializadas, actividades orientadas personal tareas que son sensibles automatización, notación papel lápiz, herramientas software. argu-mentó que medición, disciplina enfoque centrado sobre todo agilidad calidad darán como resultado software que satisfaga las necesidades del cliente, que sea confiable, mantenible mejor. sin embargo, nunca prometió que ingeniería del software fuese una panacea. conforme avanza segunda década este nuevo siglo, las tecnologías software sistemas siguen siendo desafío para todo profesional software para toda compañía que construya sistemas basados computadora. aunque las siguientes palabras escribieron con una perspectiva del siglo , max hopper [hop] describe con precisión estado actual las cosas: puesto que los cambios tecnología información vuelven tan rápidos implacables, que las consecuencias retrasarse son tan irreversibles, las compañías dominarán tecnología mori-rán... piense ello como una caminadora tecnología. las compañías tendrán que correr cada vez más rápido sólo para mantener paso. los cambios tecnología ingeniería del software son hecho “rápidos implacables”, pero, mismo tiempo, progreso con frecuencia muy lento. para cuando toma una -cisión fin adoptar nuevo proceso, método herramienta; realizar capacitación nece-saria para comprender aplicación introducir tecnología cultura desarrollo software, llega algo más nuevo ( incluso mejor) proceso comienza nuevo. una cosa que autor aprendido través sus años este campo que los profesio- nales ingeniería del software están “conscientes moda”. camino por venir estará lleno cascarones excitantes nuevas tecnologías ( última moda) que realmente nunca -graron serlo ( pesar promoción excesiva). ese camino formará con tecnologías más modestas que alguna manera modificarán orientación ámbito vía pública. capítulo estudiaron algunas ellas. este capítulo conclusiones tomará una visión más amplia considerará dónde estado dónde desde una perspectiva más filosófica. (-).indd (-).indd // ::// :: parte cinco temas avanzados . importancia del software -revisión importancia del software computadora puede establecerse muchas maneras. capítulo caracterizó como diferenciador. función que entrega software diferencia productos, sistemas servicios, ofrece ventaja competitiva mercado. pero software más que diferenciador. cuando toma como todo, los productos operativos ingeniería del software generan artículo más importante que cualquier individuo, negocio gobierno puede adquirir: información. capítulo analizó brevemente computación mundo abierto (inteligencia - biental, aplicaciones atentas contexto computación predominante/ubicua), una dirección que cambiará modo fundamental percepción las computadoras, las cosas que uno hace con ellas ( las que ellas hacen para uno) percepción información como guía, producto necesidad. también señaló que software requerido para dar soporte computación mundo abierto presentará nuevos desafíos dramáticos para los ingenieros del software. pero, mucho más importante, penetración venidera del software computadora presentará retos más dramáticos para sociedad como todo. siempre que una tecnología tiene amplio -pacto ( impacto que puede salvar vidas ponerlas peligro, construir empresas destruir-las, informar malinformar los líderes del gobierno), debe “manejarse con cuidado”. . personas forma que construyen sistemas software requerido para sistemas alta tecnología vuelve más complejo con cada año que transcurre tamaño los programas resultantes aumenta manera proporcional. rápido crecimiento tamaño del programa “promedio” presentaría algunos problemas fuese por simple hecho: conforme aumenta tamaño del programa, número personas que deben trabajar programa también debe aumentar. experiencia indica que, conforme aumenta número personas equipo pro- yecto software, productividad global del grupo puede disminuir. una forma resolver este problema crear algunos equipos ingeniería del software, que, por tanto, divide perso-nal grupos trabajo menores. sin embargo, conforme crece número equipos inge-niería del software, comunicación entre ellos vuelve tan difícil consumidora tiempo como comunicación entre individuos. peor aún, comunicación (entre individuos equipos) tiende ser ineficiente, decir, emplea mucho tiempo transfiriendo muy poco contenido información también, con mucha frecuencia, información importante “cae las grietas”. comunidad ingeniería del software lidiar manera efectiva con dilema comunicación, camino por delante para los ingenieros del software debe incluir cambios radicales forma que los individuos los equipos comunican entre ellos. -pítulo estudiaron los entornos colaboradores que pueden proporcionar mejorías dramáti-cas las formas las que comunican los equipos. última instancia, comunicación transferencia conocimiento, adquisición ( transferencia) conocimiento representa cambiar profundamente. conforme los motores búsqueda vuelven cada vez más sofisticados las aplicaciones web . ofrecen mejor siner-gia, biblioteca más grande del mundo artículos reportes, tutoriales, comentarios refe-rencias investigación vuelve más accesible utilizable. historia pasada indicio, justo decir que las personas cambiarán. sin embargo, las formas las que comunican, entorno que trabajan, forma que adquieren conocimiento, los métodos herramientas que usan, disciplina que aplican , consecuen-cia, cultura global para desarrollo del software cambiará significativa , incluso, profunda-mente.cita: “ shock del futuro [] aplastante tensión desorienta-ción que inducimos los individuos sujetarlos dema-siado cambio periodo muy corto.” alvin toffler (-).indd (-).indd // ::// :: comentarios finales . uevos modos para representar información través historia computación, ocurrido una transición sutil terminología que usa para describir trabajo desarrollo del software que realiza comunidad empresarial. hace años, término procesamiento datos era frase operativa que describía uso las computadoras contexto empresarial. actualidad, procesamiento datos ori-ginó otra frase, tecnología información , que implica mismo pero con cambio sutil enfoque. énfasis simplemente procesar grandes cantidades datos, sino, más bien, extraer información significativa estos datos. obviamente, ésta siempre fue intención, pero cambio terminología refleja una modificación mucho más importante filosofía administrativa. cuando hoy estudian aplicaciones software, las palabras datos, información contenido ocurren repetidamente. palabra conocimiento encuentra algunas aplicaciones inte- ligencia artificial, pero uso relativamente raro. virtualmente, nadie discute sabiduría contexto aplicaciones software. los datos son información bruta: colecciones hechos que deben procesarse para ser sig- nificativas. información entrega asociar hechos dentro contexto determinado. conocimiento asocia información obtenida contexto con otra información obtenida contexto diferente. finalmente, sabiduría ocurre cuando derivan principios generalizados partir conocimiento dispar. cada una estas cuatro visiones “información” repre-senta manera esquemática figura .. fecha, gran mayoría del software construyó para procesar datos información. los ingenieros software ahora están igualmente preocupados con los sistemas que procesan conocimiento. conocimiento bidimensional. información recopilada acerca varios temas relacionados relacionados conecta para formar cuerpo hechos que llama conocimiento. clave habilidad para asociar información una variedad fuentes -ferentes, que pueden tener alguna conexión obvia, para combinarla manera que ofrezca algún beneficio diferente. para ilustrar progresión que conduce desde datos hasta conocimiento, considere los datos censales que indican que tasa natalidad estados unidos fue . millones. cita: “ mejor preparación para buen trabajo mañana hacer buen trabajo hoy.” elbert hubbard datos: sin asociatividadinformación:asociatividad dentrode contexto conocimiento:asociatividad dentrode múltiples contextossabiduría:creación principios generalizadoscon base conocimiento existentede diferentes fuentesfigura . espectro “información” rápido crecimiento tecnologías minado data warehouses refleja esta tendencia creciente. semántica web (web .) permite creación “purés” que pueden proporcionar mecanismo sencillo para lograr esto.cita: “ sabiduría poder que nos permite usar conocimien- para beneficio nosotros mismos los demás.” thomas . watson (-).indd (-).indd // ::// :: parte cinco temas avanzados este número representa valor datos. relacionar este trozo datos con las tasas natalidad los años anteriores, puede inferir una pieza información útil: los baby boo- mers los años cincuenta principios los sesenta del siglo pasado, que hoy envejecen, -cieron último esfuerzo para tener hijos antes del final sus años crianza infantil. ade-más, los generación comenzaron sus años crianza infantil. los datos censales pueden conectarse entonces otras piezas información aparentemente relacionadas. por ejem-plo, número actual profesores enseñanza básica que retirarán durante próxima década, número estudiantes universitarios que gradúan educación primaria secun-daria, presión sobre los políticos para mantener bajos los impuestos , por tanto, limitar los aumentos sueldo para los profesores. todas estas piezas información pueden combinarse para formular una representación conocimiento: habrá una presión significativa sobre sistema educativo estados unidos principios del siglo xxi continuará durante algunas décadas. usar este conocimiento puede surgir una oportunidad negocios. puede haber una significativa oportunidad para desarrollar nuevos modos aprendizaje que sean más efectivos menos costosos que los enfoques actuales. camino futuro para software conduce sistemas que procesan conocimiento. durante más años han procesado datos usando computadoras, durante más tres décadas extraído información. uno los retos más significativos que enfrenta comunidad ingeniería del software construir sistemas que den siguiente paso espectro: sistemas que extraigan conocimiento partir datos información, manera práctica benéfica. . vista larga sección . sugirió que camino por venir conduce sistemas que “procesen cono-cimiento”. pero futuro computación general los sistemas basados software particular puede conducir eventos que sean considerablemente más profundos. libro fascinante que debe leer toda persona involucrada las tecnologías compu- tación, ray kurzweil [kur] sugiere que llegado momento que “ ritmo del cambio tecnológico será tan rápido, impacto tan profundo, que vida humana será trans-formada manera irreversible”. kurzweil plantea argumento peso: humanidad - tualmente está “rodilla” una curva crecimiento exponencial que conducirá enorme incremento capacidad computación durante las siguientes dos décadas. cuando acople con avances equivalentes nanotecnología, genética robótica, será posi-ble aproximarse momento, mediados este siglo, donde distinción entre humanos (como les conoce hoy día) máquinas comience empañarse: momento que evolución humana acelere formas que son tanto atemorizantes (para algunos) como -pectaculares (para otros). kurzweil argumenta que, algún momento década , capacidad compu- tación software requerido serán suficientes para modelar cada aspecto del cerebro humano: todo, desde conexiones físicas, procesos analógicos recubrimientos químicos. cuando esto ocurra, los seres humanos habrán logrado “una elevada ” (inteligencia artificial) , como con-secuencia, máquinas que realmente piensen (dentro del uso convencional actual palabra). pero habrá una diferencia fundamental. los procesos del cerebro humano son excesivamente complejos sólo conectan manera holgada con las fuentes información externas. tam-bién son computacionalmente lentos, incluso comparación con tecnología compu- importante notar que kurzweil escritor ciencia ficción ordinario, futurólogo sin cartera. tecnólogo serio que (según wikipedia) “fue pionero los campos reconocimiento óptico caracteres (ocr), síntesis texto habla, tecnología reconocimiento voz instrumentos teclado electrónico”. (-).indd (-).indd // ::// :: comentarios finales tación actual. cuando ocurra simulación completa del cerebro humano, “pensamiento” ocurrirá con rapideces miles veces mayores que contraparte humana, con íntimas -nexiones mar información (piense web actualidad como ejemplo primi-tivo). resultado ... bueno... tan fantástico que mejor dejar kurzweil describirlo. importante notar que nadie cree que futuro que kurzweil describe sea algo bueno. ensayo ahora famoso, titulado “the future doesn’ need ” ( futuro nos necesita), bill joy [joy], uno los fundadores sun microsystems, argumenta que “robótica, ingeniería genética nanotecnología amenazan con hacer los humanos una especie peligro extin-ción”. sus argumentos, que predicen una distopia tecnológica, representan contrapunto futuro utópico predicho por kurzweil. ambos deben considerarse seriamente como ingenieros software que juegan uno los papeles principales definición visión larga especie humana. . responsabilidad del ingeniero software ingeniería del software evolucionado una profesión mundial respetada. como profe-sionales, los ingenieros software deben acatar código ética que guíe trabajo que realizan los productos que elaboran. una fuerza trabajo conjunta acm/ieee- produjo código ética práctica profesional ingeniería del software (versión .). código [acm] afirma: los ingenieros software deben comprometerse con hacer del análisis, especificación, diseño, desarrollo, prueba mantenimiento del software una profesión benéfica respetada. con-cordancia con compromiso con salud, seguridad bienestar del público, los ingenieros software deben adherirse los siguientes ocho principios: . público: los ingenieros del software deben actuar consistentemente con interés del público.. cliente empleador: los ingenieros software deben actuar función del mejor interés sus clientes empleadores, coincidente con interés del público. . producto: los ingenieros software deben garantizar que sus productos modificaciones -lacionadas satisfagan los más altos estándares profesionales posibles. . juicio: los ingenieros software deben mantener integridad independencia juicio profe-sional. . administración: los administradores líderes ingeniería del software deben suscribirse promover enfoque ético acerca administración del desarrollo del mantenimiento del software. . profesión: los ingenieros software deben promover integridad reputación profesión, consistente con interés del público. . colegas: los ingenieros software deben ser justos con sus colegas darles apoyo. . uno mismo: los ingenieros software deben aprender toda práctica profesión deben promover enfoque ético acerca ella. aunque cada uno estos ocho principios igualmente importante, aparece tema sensible: ingeniero software necesita trabajar función del interés del público. nivel personal, ingeniero software debe conducirse acuerdo con las siguientes reglas: • nunca robar datos para ganancia personal. • nunca distribuir vender información con derechos autor obtenida como parte trabajo proyecto software. • nunca destruir modificar maliciosamente los programas, archivos datos otra persona.webref análisis completo del código ética acm/ieee puede encontrarse seeri.etsu.edu/codes/default.shtm (-).indd (-).indd // ::// :: parte cinco temas avanzados • nunca violar privacidad individuo, grupo organización. • nunca hackear sistema por deporte beneficio. • nunca crear propagar virus gusano. • nunca usar tecnología computación para facilitar discriminación hostiga- miento. durante década pasada, ciertos miembros industria del software acudieron las autoridades busca legislación protectora que [see]: ) permita las compañías liberar software sin revelar defectos conocidos, ) exentar los desarrolladores responsabilidad por cualquier daño que resulte dichos defectos conocidos, ) restringir otros revelar defectos sin permiso del desarrollador original, ) permitir incorporación software “autoayuda” dentro producto que pueda deshabilitar (mediante comando remoto) operación del producto ) exentar los desarrolladores software con “autoayuda” daños caso que software sea deshabilitado por una tercera persona. como toda legislación, debate frecuentemente centra temas que son políticos, tecnológicos. sin embargo, muchas personas (incluido autor) creen que legislación protec-tora, emite manera inadecuada, entra conflicto con código ética ingeniería del software exentar manera indirecta los ingenieros software responsabilidad producir software alta calidad. . comentario final hace años comenzó trabajo primera edición este libro. autor todavía recuerda sentado escritorio como joven profesor, escribiendo manuscrito para libro acerca una materia por que pocas personas preocupaban incluso aún menos entendían real-mente. recuerda las cartas rechazo los editores, quienes argumentaban (cortés, pero firmemente) que nunca habría mercado para libro acerca “ingeniería del software”. por fortuna, mcgraw-hill decidió darle una oportunidad, resto, como dicen, historia. durante los pasados años, este libro cambió dramáticamente: visión, tamaño, estilo contenido. como ingeniería del software, creció (con fortuna) maduró con los años. enfoque ingeniería centrado desarrollo del software computadora ahora sabiduría convencional. aunque debate continúa acerca del “paradigma correcto”, impor-tancia agilidad, grado automatización los métodos más efectivos, los principios subyacentes ingeniería del software, ahora aceptan toda industria. ¿por qué, -tonces, visto adopción amplia sólo recientemente? respuesta, acaso, encuentra dificultad transición tecnológica cambio cultural que acompaña. aun cuando mayoría las personas aprecian necesidad una disciplina ingeniería para software, lucha contra inercia práctica pasada enfrentan nuevos dominios aplicación ( los desarrolladores que los trabajan) que parecen listos repetir los errores del pasado. para facilitar transición necesitan muchas cosas: proceso software ágil, adaptable sensible; métodos más efectivos; herramientas más pode-rosas; mejor aceptación por parte los profesionales apoyo los administradores; pequeñas dosis educación. acaso lector esté acuerdo con todos los enfoques descritos este libro. algunas las técnicas opiniones son controvertidas; otras deben afinarse para trabajar bien diferentes realidad, crédito debe para peter freeman eric munson, quienes convencieron mcgraw-hill que valía pena probar. más millón copias después, justo decir que tomaron una buena decisión. (-).indd (-).indd // ::// :: comentarios finales entornos desarrollo software. sin embargo, autor desea sinceramente que ingeniería del software. enfoque práctico haya delineado problema que enfrenta, demostrado fuerza los conceptos ingeniería del software ofrecido marco conceptual métodos herramientas. conforme avanza aún más siglo xxi, software sigue siendo producto indus- tria más importantes escena mundial. impacto importancia han recorrido largo camino. , sin embargo, una nueva generación desarrolladores software debe satisfacer muchos los mismos desafíos que enfrentaron las generaciones anteriores. con esperan- que las personas que enfrenten reto, ingenieros del software, tendrán sabiduría para desarrollar sistemas que mejoren condición humana. (-).indd (-).indd // ::// ::(-).indd (-).indd // ::// :: uml conceptos clave canales. . . . . . . . . . . . . . . . diagramas actividad . . . . clase . . . . . . . comunicación. . . . . . . . . . . . diagramas estado . . . . . . implementación . . . . . . . . . . diagramas secuencia . . . . uso caso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . restricción objeto . . . . . . . . . . . . . . marcos interacción . . . . . . . . . . . . . . . . . lenguaje modelado unificado (uml) “ lenguaje estándar para escribir diseños software. uml puede usarse para visualizar, especificar, construir documentar los artefactos sistema software intensivo” [boo]. otras palabras, tal como los arquitectos edificios crean planos para que los use una compañía constructora, los arqui-tectos software crean diagramas uml para ayudar los desarrolladores software construir software. usted entiende vocabulario del uml (los elementos pictóricos los diagramas significado) puede comprender especificar con mucha más facilidad sis-tema, explicar diseño otros. grady booch, jim rumbaugh ivar jacobson desarrollaron uml mediados los años noventa del siglo pasado con mucha realimentación comunidad desarrollo software. uml fusionó algunas notaciones modelado que competían entre que usaban industria del software época. , uml . envió object management group, consorcio sin fines lucro involucrado especificaciones mantenimiento para empleo industria computación. uml . revisó dio como resultado adopción del uml . ese mismo año. estándar actual uml . ahora estándar iso. puesto que este estándar tan nuevo, muchas antiguas referencias, como [gam], usan notación uml. uml . proporciona diferentes diagramas para uso modelado software. este apéndice analizarán solamente diagramas clase, implementación, caso uso, secuencia, comunicación, actividad estado, diagramas que usan esta edición ingeniería del soft-ware. enfoque práctico. debe observar que existen muchas características opcionales diagramas uml. uml ofrece dichas opciones ( ocasiones complejas) modo que pueda expresar todos los aspec-tos importantes sistema. mismo tiempo, tiene flexibilidad para suprimir aquellas partes del diagrama que son relevantes para aspecto que modelar, con finalidad evitar confundir diagrama con detalles irrelevantes. por tanto, omisión una caracte-rística particular significa que ésta encuentre ausente; puede significar que caracterís-tica suprimió. este apéndice, presenta cobertura exhaustiva todas las caracte- rísticas los diagramas uml. apéndice enfocará las opciones estándar, especial aquellas que usaron este libro. este apéndice fue una aportación dale skrien adaptó libro introduction object-oriented design and design patterns java (mcgraw-hill, ). todo contenido usa con permiso. lector está familiarizado con los conceptos orientados objeto, apéndice presenta una breve introducción. diagramas clase para modelar clases, incluidos sus atributos, operaciones, relaciones asociaciones con otras clases, uml proporciona diagrama clase, que aporta una visión estática estructura sistema, sin mostrar naturaleza dinámica las comunicaciones entre los objetos las clases. (-)app.indd (-)app.indd // ::// :: apéndice introducción uml los elementos principales diagrama clase son cajas, que son los íconos utilizados para representar clases interfaces. cada caja divide partes horizontales. parte superior contiene nombre clase. sección media menciona sus atributos. atributo algo que objeto dicha clase conoce puede proporcionar todo tiempo. por general, los atributos implementan como campos clase, pero necesitan serlo. podrían ser valores que clase puede calcular partir sus variables valores instancia que puede obtener otros objetos los cuales está compuesto. por ejemplo, objeto puede conocer siempre hora actual regresarla siempre que solicite. por tanto, sería adecuado mencionar hora actual como atributo dicha clase objetos. sin embargo, objeto muy probablemente tendría dicha hora almacenada una sus variables instancia, porque necesitaría actua-lizar manera continua ese campo. vez ello, objeto probablemente calcularía hora actual (por ejemplo, través consulta con objetos otras clases) momento que solicite hora. tercera sección del diagrama clase contiene las operaciones com-portamientos clase. una operación que pueden hacer los objetos clase. por general, implementa como método clase. figura . presenta ejemplo simple una clase thoroughbred (pura sangre) que modela caballos pura sangre. muestra tres atributos: mother (madre), father (padre) birthyear (año nacimiento). diagrama también muestra tres operaciones: getcurrentage() (obtener edad actual), getfather() (obtener padre) getmother() (obtener madre); puede haber otros atri- butos operaciones suprimidos que muestren diagrama. cada atributo puede tener nombre, tipo nivel visibilidad. tipo visibilidad son opcionales. tipo sigue nombre separa mediante dos puntos. visibilidad indica mediante –, #, ~ + precedente, que indica, respectivamente, visibilidad privada, pro- tegida, paquete pública. figura ., todos los atributos tienen visibilidad privada, como indica mediante signo menos que los antecede (–). también posible especificar que atributo estático clase, subrayándolo. cada operación puede desplegarse con nivel visibilidad, parámetros con nombres tipos, tipo retorno. una clase abstracta método abstracto indica con uso cursivas nombre del diagrama clase. vea, por ejemplo, clase horse (caballo) figura .. una interfaz indica con frase “<<interface” (llamada estereotipo) arriba del nombre. vea interfaz -nedobject (objeto posesión) figura .. una interfaz también puede representarse grá-ficamente mediante círculo hueco. vale pena mencionar que ícono que representa una clase puede tener otras partes - cionales. por ejemplo, puede usarse una cuarta sección fondo caja clase para mencionar las responsabilidades clase. esta sección particularmente útil cuando realiza transición tarjetas crc (capítulo ) diagramas clase, donde las responsabilida-des mencionadas las tarjetas crc pueden agregarse esta cuarta sección caja clase diagrama uml antes crear los atributos operaciones que llevan cabo dichas respon-sabilidades. esta cuarta sección muestra ninguna las figuras este apéndice. thoroughbred -father: thoroughbred -mother: thoroughbred-birthyear: int +getfather(): thoroughbred +getmother(): thoroughbred+getcurrentage(currentyear:date): intfigura . diagrama clase para una clase thoroughbred (-)app.indd (-)app.indd // ::// :: introducción uml los diagramas clase también pueden mostrar relaciones entre clases. una clase que sea una subclase otra clase conecta con ella mediante una flecha con una línea sólida con una punta triangular hueca. flecha apunta subclase superclase. uml, tal relación llama generalización. por ejemplo, figura ., las clases thoroughbred quarterhorse (caballo cuarto milla) muestran como subclases clase abstracta horse. una flecha con una línea punteada indica implementación una interfaz. uml, tal relación llama realización. por ejemplo, figura ., clase horse implementa realiza interfaz ownedobject. una asociación entre dos clases significa que existe una relación estructural entre ellas. las asociaciones representan mediante líneas sólidas. una asociación tiene muchas partes -cionales. puede etiquetarse, así como cada una sus terminaciones, para indicar papel cada clase asociación. por ejemplo, figura ., existe una asociación entre owned- object person, que person juega papel owner (propietario). las flechas cual- quiera ambos lados una línea asociación indican navegabilidad. además, cada -tremo línea asociación puede tener valor multiplicidad desplegado. navegabilidad multiplicidad explican con más detalle más adelante, esta sección. una asociación tam-bién puede conectar una clase consigo misma, mediante bucle. tal asociación indica -nexión objeto clase con otros objetos misma clase. una asociación con una flecha extremo indica navegabilidad sentido. flecha significa que, desde una clase, posible acceder con facilidad segunda clase asociada -cia que apunta asociación; sin embargo, desde segunda clase, necesariamente puede accederse con facilidad primera clase. otra forma pensar esto que primera clase está tanto segunda, pero segundo objeto clase necesariamente está directa-mente tanto primera clase. una asociación sin flechas por general indica una asocia-ción dos vías, que que pretende figura .; pero también simplemente podría significar que navegabilidad importante , por tanto, que queda fuera. debe observarse que atributo una clase muy parecido una asociación clase con tipo clase del atributo. decir, para indicar que una clase tiene una propiedad llamada “name” (nombre) tipo string, podría desplegarse dicha propiedad como atributo, como clase horse figura .. manera alternativa, podría crearse una asociación una vía desde clase horse hasta clase string donde papel clase string “name”. enfoque atributo mejor para tipos datos primitivos, mientras que enfoque asocia-ción con frecuencia mejor clase propietaria juega papel principal diseño, cuyo caso valioso tener una caja clase para dicho tipo.horse -name:string +getname():string+getowner().person<< interface ownedobject thoroughbred quarterhorseperson* pro- pietario dateusafigura . diagrama clase concerniente caballos (-)app.indd (-)app.indd // ::// :: apéndice introducción uml una relación dependencia representa otra conexión entre clases indica mediante una línea punteada (con flechas opcionales los extremos con etiquetas opcionales). una clase depende otra los cambios segunda clase pueden requerir cambios primera. una asociación una clase con otra automáticamente indica una dependencia. necesitan líneas punteadas entre clases existe una asociación entre ellas. sin embargo, para una relación transitoria ( decir, una clase que mantiene alguna conexión largo plazo con otra, sino que usa dicha clase manera ocasional), debe dibujarse una línea punteada desde primera clase hasta segunda. por ejemplo, figura ., clase thoroughbred usa clase date (fecha) siempre que invoca método getcurrentage(); por eso dependencia etiqueta “usa”. multiplicidad extremo una asociación significa número objetos dicha clase que asocia con otra clase. una multiplicidad especifica mediante entero negativo mediante rango enteros. una multiplicidad especificada por “..” significa que existen objetos dicho extremo asociación. por ejemplo, cada persona mundo tiene número seguridad social tiene (especialmente son ciudadanos estado-unidenses); por tanto, una multiplicidad .. podría usarse una asociación entre una clase person una clase socialsecuritynumber (número seguridad social) diagrama clase. una multiplicidad que especifica como “...*” significa uno más, una multiplicidad especificada como “...*” sólo “*” significa cero más. * usa como multiplicidad extremo ownedobject asociación con clase person figura ., porque una person puede poseer cero más objetos. extremo una asociación tiene multiplicidad mayor que , entonces los objetos clase que refiere dicho extremo asociación probablemente almacenan una colección, como conjunto lista ordenada. también podría incluirse dicha clase colección misma diagrama uml, pero tal clase por general queda fuera supone, -nera implícita, que está ahí debido multiplicidad asociación. una agregación tipo especial asociación que indica mediante diamante hueco extremo del ícono. ello indica una relación “entero/parte”, que clase que apunta flecha considera como una “parte” clase extremo diamante asocia-ción. una composición una agregación que indica fuerte propiedad las partes. una composición, las partes viven mueren con propietario porque tienen papel sistema software independiente del propietario. vea figura . para ejemplos agregación composición. una universidad tiene una agregación objetos edificio, que representan los edificios que constituyen campus. universidad también tiene una colección cursos. universidad quebrara, los edificios todavía existirían ( supone que universidad destruye física-mente) podría usar otras cosas, pero objeto curso tiene uso fuera universidad cual ofrece. universidad deja existir como una entidad empresarial, objeto curso sería útil , por tanto, también dejaría existir. otro elemento común diagrama clase una nota, que representa mediante una caja con una esquina doblada conecta otros íconos mediante una línea punteada. puede {debe tener lugar ediﬁcio}curso universidad ediﬁcio* *figura . relación entre universidades, cursos edificios (-)app.indd (-)app.indd // ::// :: introducción uml tener contenido arbitrario (texto gráficos) similar comentarios lenguajes progra- mación. puede contener comentarios acerca del papel una clase restricciones que todos los objetos dicha clase deban satisfacer. los contenidos son una restricción, encierran entre llaves. observe restricción unida clase curso figura .. diagramas implementación diagrama implementación uml enfoca estructura sistema software útil para mostrar distribución física sistema software entre plataformas hardware entornos ejecución. suponga, por ejemplo, que desarrolla paquete renderizado gráficos basado web. los usuarios paquete usarán navegador web para sitio web ingresar información que renderizar. sitio web renderizaría una imagen gráfica acuerdo con especificación del usuario enviaría vuelta usuario. puesto que las gráficas renderizadas pueden ser computacionalmente costosas, usted decide mover renderizado afuera del servidor web hacia una plataforma separada. por tanto, habrá tres dispositivos hardware involucrados sistema: cliente web ( computadora que corre navegador del usuario), computadora que alberga servidor web computadora que alberga motor renderizado. figura . muestra diagrama implementación para tal paquete. ese diagrama, los componentes hardware dibujan cajas marcadas con “<<dispositivo”. las rutas comunicación entre componentes hardware dibujan con líneas con etiquetas opcionales. figura ., las rutas etiquetan con protocolo comunicación con tipo red utilizado para conectar los dispositivos. cada nodo que hay diagrama implementación también puede anotarse con detalles del dispositivo. por ejemplo, figura . ilustra navegador cliente para mostrar que contiene artefacto que consiste software del navegador web. artefacto por gene-ral archivo que contiene software que corre dispositivo. también puede especificar valores etiquetados, como muestra figura . nodo del servidor web. dichos -lores definen proveedor del servidor web sistema operativo que usa servidor. los diagramas implementación también pueden mostrar nodos entorno ejecución, que dibujan como cajas que contienen etiqueta “<<entorno ejecución”. dichos nodos representan sistemas, como sistemas operativos, que pueden albergar otro software. {servidor web = apache} { = linux}<<dispositivo servidor web http/lanhttp/internet <<dispositivo motor renderizado<<artefacto navegador web<<dispositivo navegador clientefigura . diagrama implementación (-)app.indd (-)app.indd // ::// :: apéndice introducción uml diagramas uso caso los casos uso (capítulos ) diagrama uso caso uml ayudan determinar fun- cionalidad características del software desde perspectiva del usuario. para proporcionarle una aproximación manera que funcionan los casos uso los diagramas uso caso, crearán algunos para una aplicación software que gestiona archivos música -gital, similar software itunes apple. algunas las cosas que puede incluir software son funciones para: • descargar archivo música almacenarlo biblioteca aplicación. • capturar música streaming (transmisión continua) almacenarla biblioteca aplicación. • gestionar biblioteca aplicación (por ejemplo, borrar canciones organizarlas listas reproducción). • quemar una lista las canciones biblioteca. • cargar una lista las canciones biblioteca ipod reproductor . • convertir una canción formato formato aac viceversa. ésta una lista exhaustiva, pero suficiente para entender papel los casos uso los diagramas uso caso. caso uso describe manera que usuario interactúa con sistema, definiendo los pasos requeridos para lograr una meta específica (por ejemplo, quemar una lista cancio-nes ). las variaciones secuencia pasos describen varios escenarios (por ejem-plo, ¿ todas las canciones lista caben ?). diagrama uml uso caso panorama todos los casos uso sus relaciones. mismo proporciona gran cuadro funcionalidad del sistema. figura . mues-tra diagrama uso caso para aplicación música digital. este diagrama, figura palitos representa actor (capítulo ) que asocia con una categoría usuario ( otro elemento interacción). por general, los sistemas complejos tienen más actor. por ejemplo, una aplicación máquina expendedora puede tener tres actores que representan clientes, personal reparación proveedores que rellenan -quina. diagrama uso caso, los casos uso muestran como óvalos. los actores conectan mediante líneas los casos uso que realizan. observe que ninguno los detalles los casos uso incluye diagrama , vez ello, necesita almacenarse por sepa-rado. observe también que los casos uso colocan rectángulo, pero los actores . este rectángulo recordatorio visual las fronteras del sistema que los actores están afuera del sistema. algunos casos uso sistema pueden relacionarse mutuamente. por ejemplo, existen pasos similares quemar una lista canciones cargar una lista canciones ipod. ambos casos, usuario crea primero una lista vacía luego agrega las cancio-nes biblioteca lista. para evitar duplicación casos uso, por general mejor crear nuevo caso uso que represente actividad duplicada luego dejar que los otros casos uso incluyan este nuevo caso uso como uno sus pasos. tal inclusión indica los diagramas uso caso, como figura ., mediante una flecha punteada etiquetada como “incluye”, que conecta caso uso con caso uso incluido. dado que despliega todos los casos uso, diagrama uso caso auxiliar útil para asegurar que cubrió toda funcionalidad del sistema. organizador música digital, seguramente querría más casos uso, tal como uno para reproducir una canción biblio-teca. pero tenga mente que contribución más valiosa casos uso proceso desa- (-)app.indd (-)app.indd // ::// :: introducción uml usuariodescargar archivo música guardar biblioteca captura música streaming guardar biblioteca quemar una lista canciones cargar una lista canciones ipodconvertir archivo música nuevo formato organizar bibliotecafigura . diagrama caso uso para sistema música usuarioconvertir archivo música nuevo formato descargar archivos música guardar biblioteca capturar música streaming guardar biblioteca organizar biblioteca << incluye << incluye << incluye editar lista cancionesquemar una lista canciones cargar una lista canciones ipodfigura . diagrama caso uso con casos uso incluidos (-)app.indd (-)app.indd // ::// :: apéndice introducción uml rrollo software descripción textual cada caso uso, diagrama uso caso global [fow]. través las descripciones que usted puede tener una comprensión clara las metas del sistema que desarrolla. diagramas secuencia contraste con los diagramas clase con los diagramas implementación, que muestran estructura estática componente software, diagrama secuencia usa para mostrar las comunicaciones dinámicas entre objetos durante ejecución una tarea. este tipo diagrama muestra orden temporal que los mensajes envían entre los objetos para lograr dicha tarea. puede usarse diagrama secuencia para mostrar las interacciones caso uso escenario sistema software. figura . diagrama secuencia para programa dibujo. diagrama muestra los pasos involucrados, resaltando una figura dibujo cuando clic. por general, cada caja fila que hay parte superior del diagrama corresponde objeto, aunque posible hacer que las cajas modelen otras cosas, como clases. caja representa objeto (como caso todos los ejemplos), entonces dentro caja puede establecerse manera opcional tipo del objeto, precedido por dos puntos. también puede escribir nombre del objeto antes los dos puntos, como muestra tercera caja figura .. abajo cada caja hay una línea punteada llamada línea vida del objeto. eje vertical que hay diagrama secuencia corresponde tiempo, donde tiempo aumenta conforme avanza hacia abajo. diagrama secuencia muestra llamadas método usando flechas horizontales desde llamador hasta llamado, etiquetado con nombre del método que opcionalmente incluye sus parámetros, sus tipos tipo retorno. por ejemplo, figura ., mouselistener (escucha ratón) llama método getfigureat() (obtener figura ) drawing (dibujo). cuando objeto ejecuta método ( decir, cuando tiene marco activación pila), opcionalmente puede mostrar una barra blanca, llamada barra activación, abajo línea vida del objeto. figura ., las barras activación dibujan para todas las llama-das método. diagrama también puede mostrar opcionalmente retorno una llamada método con una flecha punteada una etiqueta opcional. figura ., retorno llamada método getfigureat() muestra con una etiqueta del nombre del objeto que regresa. :mouselistener :drawing :graphics afigure:figure .setcolor(rojo).highlight(gráﬁco).getfigureat(punto).mouseclicked(punto) afigure .drawrect (,,,) .drawstring()figura . ejemplo diagrama secuencia (-)app.indd (-)app.indd // ::// :: introducción uml una práctica común, como hizo figura ., dejar fuera flecha retorno cuando llama método nulo, pues desordena diagrama vez que proporciona poca informa-ción importancia. círculo negro con una flecha que sale indica mensaje encontrado cuya fuente desconoce irrelevante. ahora debe poder entenderse tarea que implementa figura .. una fuente desconocida llama método mouseclicked() (clic del ratón) mouselistener, que pasa como argu-mento punto donde ocurrió clic. vez, mouselistener llama método getfigureat() drawing, que regresa una figure. luego mouselistener llama método resalta- figure pasa como argumento objeto graphics. respuesta, figure llama tres métodos del objeto graphics para dibujar figura rojo. diagrama figura . muy directo contiene condicionales bucles. - quieren estructuras control lógico, probablemente sea mejor dibujar diagrama secuen-cia separado para cada caso, decir, flujo del mensaje puede tomar dos rutas diferentes dependiendo una condición, entonces dibuje dos diagramas secuencia separados, uno para cada posibilidad. insiste incluir bucles, condicionales otras estructuras control diagrama secuencia, pueden usar marcos interacción, que son rectángulos que rodean partes del diagrama que etiquetan con tipo estructuras control que representan. figura . ilustra anterior, muestra proceso involucrado, resaltando todas las figuras dentro rectángulo determinado. mouselistener envía mensaje rectdragged (arrastre recta). entonces mouselistener dice dibujo que resalte todas las figuras rectángulo, lla-mando método highlightfigures() (resaltar figuras) pasando rectángulo como argumento. método hace bucles través todos los objetos figure objeto drawing , figure intersecta rectángulo, pide figure que resalte mismo. las frases entre corchetes llaman guardias, que son condiciones booleanas que deben ser verdaderas debe continuar acción dentro del marco interacción. existen muchas otras características especiales que pueden incluirse diagrama - cuencia. por ejemplo: . puede distinguir entre mensajes sincrónicos asíncronos. los primeros muestran con puntas flecha sólidas mientras que los asíncronos hacen con puntas flecha huecas. . puede mostrar objeto que envía mismo mensaje con una flecha que parte del objeto, gira hacia abajo luego apunta vuelta hacia mismo objeto. :mouselistener :figure :drawing .highlightfiguresin(rect).rectdragged(rect) .highlight() [ ﬁgura intersecta recta ][ para todas las ﬁguras drawing ] optloop ( )figura . diagrama secuencia con dos marcos interacción (-)app.indd (-)app.indd // ::// :: apéndice introducción uml . puede mostrar creación objeto dibujando una flecha etiquetada manera ade- cuada (por ejemplo, con una etiqueta <<crear) hacia una caja objeto. este caso, caja aparecerá diagrama más abajo que las cajas correspondientes objetos que existen cuando comienza acción. . puede mostrar destrucción objeto mediante una gran final línea vida del objeto. otros objetos pueden destruir objeto, cuyo caso una flecha apunta desde otro objeto hacia . una también útil para indicar que objeto usa que , por tanto, está listo para colección basura. las últimas tres características muestran diagrama secuencia figura .. diagramas comunicación diagrama comunicación uml (llamado “diagrama colaboración” uml .) propor- ciona otro indicio del orden temporal las comunicaciones, pero enfatiza las relaciones entre los objetos clases lugar del orden temporal. diagrama comunicación que ilustra figura . despliega las mismas acciones que muestran diagrama secuencia figura ..:cosa :cosa.cosa() .destruir() .foo()<< crear figura . creación, destrucción bucles diagramas secuencia .: getfigureat(punto): mouseclicked(punto) .: highlight(graphics) ..: drawrect(,,,)..: setcolor(rojo) ..: drawstring()mouselistener graphicsfigure drawingfigura . diagrama comunicación uml (-)app.indd (-)app.indd // ::// :: introducción uml diagrama comunicación, los objetos interactuantes representan mediante rec- tángulos. las asociaciones entre objetos hacen mediante líneas que conectan los rectángulos. por general, diagrama existe una flecha entrante hacia objeto que comienza -cuencia pase mensaje. esa flecha etiqueta con número nombre mensaje. mensaje entrante etiqueta con número hace que objeto receptor invoque otros mensajes otros objetos, entonces los mencionados mensajes representan mediante fle-chas desde emisor hacia receptor largo una línea asociación reciben números ., ., etc., orden que llaman. tales mensajes vez invocan otros mensajes, agrega otro punto decimal otro número número que etiqueta dichos mensajes para indi-car anidado posterior del pase mensaje. figura . que mensaje mouseclicked invoca los métodos getfigureat() luego highlight(). mensaje highligh () invoca otros tres mensajes: setcolor() (establecer color), drawrect() (dibujar recta) drawstring() (dibujar cadena). numeración cada etiqueta mues- tra anidado naturaleza secuencial cada mensaje. existen muchas características opcionales que pueden agregarse las etiquetas flecha. por ejemplo, puede preceder número con una letra. una flecha entrante podría etiquetarse : mouseclicked(point), que indica una hebra ejecución, . otros mensajes ejecutan otras hebras, etiqueta estaría precedida por una letra diferente. por ejemplo, método mouseclicked() ejecuta hebra , pero crea una nueva hebra invoca highlight() dicha hebra, entonces flecha desde mouselistener hacia figure etiquetaría .: highlight(graphics). lector está interesado mostrar las relaciones entre los objetos, además los men- sajes que envíen entre ellos, probablemente diagrama comunicación una mejor -ción que diagrama secuencia. está más interesado orden temporal del paso mensajes, entonces diagrama secuencia probablemente mejor. diagramas actividad diagrama actividad uml muestra comportamiento dinámico sistema parte sistema través del flujo control entre acciones que realiza sistema. similar diagrama flujo, excepto porque diagrama actividad puede mostrar flujos concurrentes. componente principal diagrama actividad nodo acción, representado - diante rectángulo redondeado, que corresponde una tarea realizada por sistema software. las flechas desde nodo acción hasta otro indican flujo control; decir, una flecha entre dos nodos acción significa que, después completar primera acción, comienza segunda acción. punto negro sólido forma nodo inicial que indica punto inicio actividad. punto negro rodeado por círculo negro nodo final que indica fin actividad. tenedor ( fork) representa separación actividades dos más actividades concu- rrentes. dibuja como una barra negra horizontal con una flecha apuntando hacia ella dos más flechas apuntando sentido opuesto. cada flecha continua representa flujo con-trol que puede ejecutarse manera concurrente con los flujos correspondientes las otras flechas continuas. dichas actividades concurrentes pueden realizarse una computadora, usando diferentes hebras incluso diferentes computadoras. figura . muestra ejemplo diagrama actividad que involucra hornear pas- tel. primer paso encontrar receta. una vez encontrada pueden medirse los ingredientes secos líquidos, mezclarse precalentar horno. mezcla los ingredientes secos puede hacerse paralelo con mezcla los ingredientes líquidos precalentado del horno. una unión ( join) una forma sincronizar flujos control concurrentes. representa mediante una barra negra horizontal con dos más flechas entrantes una flecha saliente. (-)app.indd (-)app.indd // ::// :: apéndice introducción uml flujo control representado por flecha saliente puede comenzar ejecución hasta que todos los flujos representados por las flechas entrantes hayan completado. figura . tiene una unión antes acción mezclar conjunto los ingredientes líquidos secos. esta unión indica que todos los ingredientes secos deben mezclarse que debe hacerse mismo con todos los ingredientes líquidos antes poder combinar las dos mezclas. segunda unión figura indica que, antes comenzar hornear pastel, todos los ingredientes deben mezclarse juntos horno debe estar temperatura correcta. nodo decisión corresponde una rama flujo control con base una condición. tal nodo despliega como triángulo blanco con una flecha entrante dos más flechas salientes. cada flecha saliente etiqueta con una guardia (una condición dentro corchetes). flujo control sigue flecha saliente cuya guardia verdadera. recomendable asegu-rarse que las condiciones cubran todas las posibilidades, modo que exactamente una ellas sea verdadera cada vez que llegue nodo decisión. figura . muestra nodo decisión que sigue horneado del pastel. pastel está hecho, entonces saca del horno. otro modo, hornea poco más. una las cosas que dice diagrama actividad figura . quién qué hace cada una las acciones. con frecuencia, importa división exacta mano obra. pero quiere indicar cómo dividen las acciones entre los participantes, puede decorar diagrama actividad con “canales”, como muestra figura .. los canales, como nombre encontrar receta mezclar ingredientes secosmezclar ingredientes líquidos calentar horno hornear sacar del hornomezclar juntos ( hecho) (hecho)figura . diagrama actividad uml que muestra cómo hornear pastel (-)app.indd (-)app.indd // ::// :: introducción uml implica, forman dividiendo diagrama tiras “carriles” (como fuera una alberca con carriles natación), cada uno los cuales corresponde uno los participantes. todas las acciones carril las realiza participante correspondiente. figura ., evan responsable mezcla los ingredientes secos , luego, mezclar juntos los ingredientes secos los líquidos; helen responsable calentar horno sacar pastel; mary res-ponsable todo demás. diagramas estado comportamiento objeto punto particular tiempo con frecuencia depende del estado del objeto; decir, los valores sus variables dicho momento. como ejemplo trivial, considere objeto con una variable instancia booleana. cuando pide realizar una operación, objeto puede hacer una cosa dicha variable verdadera hacer algo más falsa. diagrama estado uml modela los estados objeto, las acciones que realizan dependiendo dichos estados las transiciones entre los estados del objeto. como ejemplo, considere diagrama estado para una parte compilador java. entrada compilador archivo texto, que puede considerarse como una larga cadena caracteres. compilador lee caracteres uno uno partir ellos determina estructura del programa. una pequeña parte este proceso lectura caracteres involucra ignorar encontrar receta mezclar ingredientes secosmezclar ingredientes líquidos calentar horno hornearmezclar juntos ( hecho)evan mary helen (hecho)sacar del hornofigura . diagrama actividad horneado pastel con “carriles natación” agregados (-)app.indd (-)app.indd // ::// :: apéndice introducción uml caracteres “espacio blanco” (por ejemplo, los caracteres espacio, tabulador, línea nueva - torno) caracteres dentro comentario. suponga que compilador delega eliminadorespacioblancoycomentario labor avanzar sobre los caracteres espacio blanco sobre los caracteres dentro comen- tario, decir, labor dicho objeto leer los caracteres entrada hasta que todos los caracteres espacio blanco comentario leyeron, punto donde regresa control compi-lador para leer procesar caracteres blanco comentario. piense manera que objeto eliminadorespacioblancoycomentario lee los caracteres determina siguiente carácter espacio blanco parte comentario. objeto puede verificar los espacios blancos, probando los siguientes caracteres contra “ ”, “\”, “\” “\”. ¿pero cómo determina siguiente carácter parte comentario? por ejemplo, cuando “/” por primera vez, todavía sabe dicho carácter representa operador división, parte del ope-rador /= comienzo una línea bloque comentario. para hacer esta determinación, eliminadorespacioblancoycomentario necesita anotar hecho que vio una “/” luego moverse hacia siguiente carácter. carácter siguiente “/” otra “/” “*”, entonces eliminadorespacioblancoycomentario sabe que ahora lee comentario puede avanzar final del comentario sin procesar guardar algún carácter. carácter siguiente primer “/” distinto “/” “*”, entonces eliminadorespacioblancoycomentario sabe que “/” representa operador división parte del operador /= , por tanto, avanza través los -racteres. resumen, conforme eliminadorespacioblancoycomentario lee los caracteres, nece- sita seguir pista muchas cosas, incluido carácter actual espacio blanco, carác-ter previo que lee fue “/”, actualmente lee caracteres comentario, llegó final del comentario, etc. todos éstos corresponden diferentes estados del objeto eliminadorespacio- blancoycomentario. cada uno estos estados, eliminadorespacioblancoycomenta- rio comporta manera diferente con respecto siguiente carácter que lee. para ayudarlo visualizar todos los estados este objeto manera que cambia estado, puede usar diagrama estado uml, como muestra figura .. diagrama estado muestra los estados mediante rectángulos redondeados, cada uno los cuales tiene nombre mitad superior. también existe círculo llamado “pseudoestado inicial”, que realidad estado vez ello sólo apunta estado inicial. figura ., estado start estado inicial. las flechas estado otro estado indican transiciones cambios estado del objeto. cada transición etiqueta con evento disparador, una diagonal (/) una actividad. todas las partes las etiquetas transición son opcionales los diagramas estado. objeto está estado evento disparador ocurre para una sus transiciones, entonces realiza dicha actividad transición objeto toma nuevo estado, indicado por transición. por ejemplo, figura ., objeto eliminadores- pacioblancoycomentario está estado start siguiente carácter “/”, entonces eli- minadorespacioblancoycomentario avanza desde dicho carácter cambia estado vio ‘/’ . carácter después “/” otra “/”, entonces objeto avanza estado línea comentario permanece ahí hasta que lee carácter fin línea. vez ello siguiente carácter después “/” “*”, entonces objeto avanza estado bloque comentario permanece ahí hasta que otro “*” seguido por “/”, que indica final del bloque comentario. estudie diagrama para asegurarse que entiende. observe que, después avanzar por espacio blanco por comentario, eliminadorespacioblancoycomentario regresa estado start comienza nuevo. dicho comportamiento necesario, pues puede haber varios -mentarios sucesivos caracteres espacio blanco antes cualquier otro carácter código fuente java. objeto puede transitar estado final, que indica mediante círculo negro con círculo blanco alrededor , que indica que hay más transiciones. figura (-)app.indd (-)app.indd // ::// :: introducción uml ., objeto eliminadorespacioblancoycomentario termina cuando siguiente carác- ter espacio blanco parte comentario. observe que todas las transiciones, - cepto las dos que conducen estado final, tienen actividades que consisten avanzar -guiente carácter. las dos transiciones hacia estado final avanzan sobre siguiente carácter porque siguiente carácter parte una palabra símbolo interés para com-pilador. observe que, objeto está estado vio ‘/’ , pero siguiente carácter “/” “*”, entonces “/” operador división parte del operador /= , por tanto, quiere avan-zar. hecho, quiere regresar carácter para hacer “/” siguiente carácter, modo que “/” pueda usarse por parte del compilador. figura ., esta actividad etiqueta como retroceder ‘/’. diagrama estado ayudará descubrir situaciones perdidas inesperadas, decir, con diagrama estado, relativamente sencillo garantizar que todos los posibles eventos dis-paradores para todos los estados posibles representaron. por ejemplo, figura ., puede verificar fácilmente que cada estado incluyó transiciones para todos los posibles caracteres. los diagramas estado uml pueden contener muchas otras características incluidas figura .. por ejemplo, cuando objeto está estado, por general hace más que sentarse esperar que ocurra evento disparador. sin embargo, existe tipo especial estado, llamado estado actividad, donde objeto realiza alguna actividad, llamada hacer actividad, mientras está dicho estado. para indicar que estado estado actividad diagrama estado, incluye, mitad inferior del rectángulo redondeado del estado, frase “/” seguida por actividad que debe realizar mientras está dicho estado. “hacer actividad” puede terminar antes que ocurra cualquier transición estado, después cual estado actividad comporta como estado normal espera. una transición del -tado actividad ocurre antes terminar “hacer actividad”, entonces interrumpe “hacer actividad”.próximo car != eoln/avanzarpróximo car = eoln/avanzar próximo car = ‘*’/avanzarpróximo car = ‘/’/avanzarpróximo car = ‘/’/avanzar próximo car = ‘*’/avanzar próximo car = ‘*’/avanzar próximo car = ‘*’/avanzar próximo car = ‘/’/avanzar próximo car = todo demáspróximo car = ‘ ‘, ‘\’, ‘\’, ‘\’/avanzar espacio blancopróximo car != ‘/’ ‘*’/retroceder’/’vio’*’ bloque comentario startlínea comentario vio ‘/’figura . diagrama estado para avanzar sobre espacio blanco comentarios java (-)app.indd (-)app.indd // ::// :: apéndice introducción uml puesto que evento disparador opcional cuando ocurre una transición, posible que ningún evento disparador pueda mencionarse como parte una etiqueta transición. tales casos, para estados espera normales, objeto inmediatamente transitará dicho estado nuevo estado. para estados actividad, tal transición realiza tan pronto como termina “hacer actividad”. figura . ilustra esta situación, usando los estados para operación teléfono. cuando llamador coloca espera, llamada pasa estado retener con música ( música reconfortante suena durante segundos). después segundos, “hacer actividad” del estado completa estado comporta como estado normal actividad. llamador presiona tecla # cuando llamada está estado retener con música, lla-mada transita hacia estado cancelado inmediatamente estado tono llamada. tecla # presiona antes completar los segundos música reconfortante, “hacer acti-vidad” interrumpe música cesa inmediatamente. lenguaje restricción objeto (panorama ) gran variedad diagramas disponibles como parte uml brindan rico conjunto formas representativas para modelo diseño. sin embargo, con frecuencia son suficientes las representaciones gráficas. acaso necesite mecanismo para representar información manera explícita formal que restrinja algún elemento del modelo diseño. desde luego, posible describir las restricciones lenguaje natural como inglés, pero este enfoque invaria-blemente conduce inconsistencia ambigüedad. por esta razón, parece apropiado lenguaje más formal, extraído teoría conjuntos los lenguajes especificación formales (vea capítulo ), pero que tenga sintaxis tanto menos matemática lenguaje progra-mación. lenguaje restricción objeto (lro) complementa uml, permitiéndole usar una gra- mática sintaxis formales para construir enunciados sin ambigüedades acerca varios ele-mentos del modelo diseño (por ejemplo, clases objetos, eventos, mensajes, interfaces). los enunciados lro más simples construyen cuatro partes: ) contexto que define situa- ción limitada que válido enunciado, ) una propiedad que representa algunas carac- terísticas del contexto (por ejemplo, una propiedad puede ser atributo contexto una clase), ) una operación (por ejemplo, aritmética, orientada conjunto) que manipule califique retener con música hacer/tocar música reconfortante durante segundosponer espera cancelada hablartecla # presionada salir espera colgar tono llamadafigura . diagrama estado con estado actividad una transición sin disparador (-)app.indd (-)app.indd // ::// :: introducción uml una propiedad ) palabras clave (por ejemplo, , then, else, and, , not, implies) que usan para especificar expresiones condicionales. como ejemplo simple una expresión lro, considere sistema impresión que estu- dió capítulo . condición guardia coloca evento jobcostaccepted que causa una transición entre los estados computingjobcost formingjob dentro del diagrama estado para objeto printjob (figura .). diagrama (figura .), condición guardia expresa lenguaje natural implica que autorización sólo puede ocurrir cliente está autorizado para aprobar costo del trabajo. lro, expresión puede tomar forma: customer self.authorizationauthority / ‘yes’ donde atributo booleano, authorizationauthority, clase ( realidad una instancia especí- fica clase) llamada customer debe establecerse “” para que satisfaga condición guardia. conforme crea modelo diseño, con frecuencia existen instancias las que deben satisfacerse pre poscondiciones antes completar alguna acción especificada por diseño. lro proporciona una poderosa herramienta para especificar pre poscondiciones manera formal. como ejemplo, considere una extensión sistema local impresión (que estudió como ejemplo capítulo ) donde cliente proporcione límite costo superior (upper cost bound) para trabajo impresión una fecha entrega “fatal”, mismo tiempo que especifican otras características del trabajo impresión. las estimaciones costo entrega superan dichos límites, trabajo presenta debe notificársele cliente. lro, con-junto pre poscondiciones puede especificarse forma siguiente: context printjob::validate(uppercostbound : integer, custdeliveryreq : integer) pre: uppercostbound and custdeliveryreq and self.jobauthorization / ‘’ post: self.totaljobcost </ uppercostbound and self.deliverydate </ custdeliveryreq then self.jobauthorization = ‘yes’ endif este enunciado lro define una invariante ( inv): condiciones que deben existir antes (pre) después (pos) algún comportamiento. inicialmente, una precondición establece que límite costo fecha entrega deben especificarse por parte del cliente, autorización debe establecerse “”. después determinar costos entrega, aplica poscondición espe-cificada. también debe observarse que expresión: self.jobauthorization = ‘yes’ asigna valor “”, sino que declara que jobauthorization debe establecerse “” para cuando operación termine. una descripción completa del lro está más allá del ámbito este apéndice. especificación lro completa puede obtenerse logy/documents/formal/ocl.htm lecturas fuentes información adicionales decenas libros estudian uml. los que abordan versión más reciente incluyen: miles hamilton (learn- ing uml ., ’reilly media, inc., ); booch, rumbaugh, jacobson (unified modeling language user (-)app.indd (-)app.indd // ::// :: apéndice introducción uml guide, . ., addison-wesley, ), ambler (the elements uml . style, cambridge university press, ), pilone pitman (uml . nutshell, ’reilly media, inc., ). internet está disponible una gran variedad fuentes información acerca del uml modelado ingeniería del software. una lista actualizada referencias world wide web puede encontrarse bajo “análisis” “diseño” sitio del libro: (-)app.indd (-)app.indd // ::// :: orientados objeto conceptos clave atributos . . . . . . . . . . . . . . clases. . . . . . . . . . . . . . . . . características. . . . . . . . . . frontera . . . . . . . . . . . . . . controlador. . . . . . . . . . . . definición . . . . . . . . . . . . . diseño . . . . . . . . . . . . . . . entidad. . . . . . . . . . . . . . . encapsulación . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ¿qué punto vista orientado objeto ()? ¿por qué método considera orien- tado objeto? ¿qué objeto? conforme los conceptos ganaron muchos adheren-tes durante las décadas , había muchas opiniones diferentes acerca las respuestas correctas dichas preguntas, pero actualidad surgió una visión coherente los conceptos . este apéndice diseñó para ofrecer breve panorama este importante tema introducir los conceptos terminología básicos. para entender punto vista orientado objeto, considere ejemplo objeto del mundo real: objeto sobre cual sienta este momento, una silla. silla una subclase una clase mucho más grande que puede llamar piezademobiliario. las sillas individua- les son miembros (por general llamadas instancias) clase silla. conjunto atributos genéricos pueden asociarse con cada objeto clase piezademobiliario. por ejemplo, - dos los muebles tienen costo, dimensiones, peso, ubicación color, entre muchos posibles atributos. mismo aplica habla una mesa, una silla, sofá armario. puesto que silla miembro piezademobiliario, silla hereda todos los atributos definidos para clase. busca una definición anecdótica una clase describir sus atributos, pero algo falta. todo objeto clase piezademobiliario puede manipularse varias formas. puede com- prarse venderse, modificarse físicamente (por ejemplo, puede serruchar una pata pintar objeto morado) moverlo lugar otro. cada una estas operaciones (otros términos son servicios métodos) modificarán uno más atributos del objeto. por ejemplo, atributo ubicación ítem datos compuesto definido como ubicación / edificio / piso / habitación entonces una operación denominada mover() modificaría uno más los ítems datos ( edi- ficio, piso habitación) que forman atributo ubicación. para hacer esto, mover() debe tener “cono- cimiento” dichos ítems datos. operación mover() podría usarse para una silla una mesa, tanto ambos sean instancias clase piezademobiliario. las operaciones válidas para clase piezademobiliario [ comprar(), vender(), peso()] son especificadas como parte definición clase son heredadas por todas las instancias clase. clase silla ( todos los objetos general) encapsulan datos (los valores atributo que definen silla), operaciones (las acciones que aplican para cambiar los atributos silla), otros objetos, constantes (valores conjunto) otra información relacionada. encapsulación significa que toda esta información empaca bajo nombre puede reutilizarse como componente especificación programa. ahora que introdujeron algunos conceptos básicos, una definición más formal orien- tado objeto resultará más significativa. coad yourdon [coa] definen término esta forma: orientado objeto / objetos / clasificación / herencia / comunicación tres los conceptos introdujeron. comunicación estudia más tarde, este apén-dice. (-)app.indd (-)app.indd // ::// :: apéndice conceptos orientados objeto clases objetos una clase concepto que encapsula los datos abstracciones procedurales requeridos para describir contenido comportamiento alguna entidad del mundo real. las abstrac-ciones datos que describen clase encierran mediante una “pared” abstracciones procedurales [tay] (representadas figura .) que son capaces manipular los datos alguna forma. una clase bien diseñada, única forma llegar los atributos ( operar sobre ellas) través uno los métodos que forman “pared” que ilustra figura. por tanto, clase encapsula datos (dentro pared) procesamiento que los manipula (los métodos que constituyen pared). esto logra que información oculte (capítulo ) que reduzca impacto los efectos colaterales asociados con cambio. dado que los métodos tienden manipular número limitado atributos, cohesión mejora, puesto que -municación ocurre solamente través los métodos que constituyen “pared”, clase tiende estar menos fuertemente acoplada otros elementos sistema. dicho otra forma, una clase una descripción generalizada (por ejemplo, una plantilla plano) una colección objetos similares. por definición, los objetos son instancias una clase específica heredan sus atributos las operaciones que están disponibles para manipular esos atributos. una superclase (con frecuencia llamada clase base) una generalización conjunto clases que relacionan con ella. una subclase una especialización super-clase. por ejemplo, superclase vehículodemotor una generalización las clases - mión, suv, automóvil van . subclase automóvil hereda todos los atributos vehícu- lodemotor, pero además incorpora atributos adicionales que son específicos solamente automóviles. estas definiciones implican existencia una jerarquía clase que los atributos operaciones superclase heredan por parte subclase, que puede agregar atributos métodos “privados” adicionales. por ejemplo, las operaciones sentaren() voltear() pueden ser privativas subclase silla. sin embargo, debe observar que acoplamiento puede convertirse serio problema los sistemas , cuando las clases varias partes del sistema usan como los tipos atributos datos los argumentos como métodos. aun cuando acceso los objetos sólo puede ser través llamados procedimiento, esto significa que acoplamiento necesariamente bajo, sólo más bajo que permitiera acceso directo interior los objetos.atributosmétodo() método() método()métodon() método()figura . representación esquemática una clase (-)app.indd (-)app.indd // ::// :: conceptos orientados objeto atributos usted aprendió que los atributos vinculan las clases que describen clase alguna forma. atributo puede tomar valor definido por dominio enumerado. mayoría los casos, dominio simplemente conjunto valores específicos. por ejemplo, suponga que una clase automóvil tiene atributo color. dominio valores para color { blanco, negro, plata, gris, azul, rojo, amarillo, verde }. situaciones más complejas, dominio puede ser una clase. continuando con ejemplo, clase automóvil también tiene atributo trenpotencia que mismo una clase. clase trenpotencia contendría atributos que des- criben motor transmisión específicos del vehículo. las características (valores del dominio) pueden aumentar asignar valor por defecto (característica) atributo. por ejemplo, atributo color por defecto blanco. también puede ser útil asociar una probabilidad con una característica particular asignar pares {valor, proba-bilidad}. considere atributo color para automóvil. algunas aplicaciones (por ejemplo, pla- nificar fabricación) puede ser necesario asignar una probabilidad cada uno los colores (por ejemplo, blanco negro son enormemente probables como colores automóvil). operaciones , métodos servicios objeto encapsula datos (representados como una colección atributos) los algoritmos que los procesan. dichos algoritmos llaman operaciones, métodos servicios pueden verse como componentes procesamiento. cada una las operaciones que encapsula mediante objeto proporciona una repre- sentación uno los comportamientos del objeto. por ejemplo, operación obtenercolor() para objeto automóvil extraerá color almacenado atributo color. implicación existencia estas operaciones que clase automóvil diseñó para recibir estímulo ( los estímulos les llama mensajes) que solicitan color instancia particular una clase. siempre que objeto recibe estímulo, inicia cierto comportamiento. esto puede ser tan simple como recuperar color del automóvil tan complejo como inicio una cadena estímulos que pasan entre varios objetos diferentes. último caso, considere ejemplo donde estímulo inicial recibido por objeto como resultado generación otros dos estímulos que envían objeto objeto . las operaciones encapsuladas por - gundo tercer objetos actúan sobre los estímulos, regresan información necesaria primer objeto. entonces objeto usa información devuelta para satisfacer comportamiento demandado por estímulo inicial. conceptos análisis diseño orientado objeto modelado requerimientos (también llamado modelado análisis) enfoca principal-mente clases que extraen directamente del enunciado del problema. dichas clases -tidad por general representan cosas que deben almacenarse una base datos que persisten largo duración aplicación ( menos que borren manera especí-fica). diseño refina extiende conjunto clases entidad. las clases frontera controlador desarrollan / refinan durante diseño. las clases frontera crean interfaz (por ejemplo, pantalla interactiva reportes impresos) que usuario con cual interactúa conforme contexto esta discusión usa término operaciones, pero los términos métodos servicios son igual- mente populares. (-)app.indd (-)app.indd // ::// :: apéndice conceptos orientados objeto usa software. las clases frontera diseñan con responsabilidad gestionar forma que los objetos entidad presentan los usuarios. las clases controlador diseñan para gestionar: ) creación actualización objetos entidad, ) instanciación objetos frontera conforme obtienen información objetos enti-dad, ) comunicación compleja entre conjuntos objetos ) validación datos comunicados entre objetos entre usuario aplicación. los conceptos analizados los párrafos que siguen pueden ser útiles trabajos análisis diseño. herencia. herencia uno los diferenciadores clave entre sistemas convencionales orientados objeto. una subclase hereda todos los atributos operaciones asociadas con superclase . esto significa que todas las estructuras datos algoritmos originalmente dise- ñados implementados para están disponibles inmediato para ; necesita hacer más trabajo. reutilización logra directamente. cualquier cambio los atributos operaciones contenidos dentro una superclase - reda inmediatamente para todas las subclases. por tanto, jerarquía clase con vierte mecanismo mediante cual los cambios ( niveles superiores) pueden propagarse inme-diatamente través sistema. importante observar que cada nivel jerarquía clase pueden agregarse nuevos atributos operaciones las que heredaron niveles superiores jerarquía. hecho, siempre que crea una nueva clase, tendrá algunas opciones: • clase puede diseñarse construirse desde cero, decir, usa herencia. • jerarquía clase puede revisarse para determinar una clase superior jerarquía contiene más los atributos operaciones requeridos. nueva clase hereda clase superior entonces pueden agregarse adiciones, según requiera. • jerarquía clase puede reestructurarse modo que los atributos operaciones requeridos pueden heredarse nueva clase. • las características una clase existente pueden ser excesivas, diferentes versiones atributos operaciones implementan para nueva clase. como todo concepto diseño fundamental, herencia puede proporcionar beneficios signifi-cativos para diseño, pero usa manera inadecuada, puede complicar diseño manera innecesaria conducir software proclive errores, que difícil mantener. mensajes. las clases deben interactuar unas con otras para lograr las metas del diseño. mensaje estimula ocurrencia algunos comportamientos objeto receptor . compor- tamiento logra cuando una operación ejecuta. interacción entre los objetos ilustra manera esquemática figura .. una ope- ración dentro objetoemisor genera mensaje forma mensaje (<parámetros) donde los parámetros identifican objetoreceptor con objeto que estimular mediante mensaje; operación dentro objetoreceptor consiste recibir mensaje los ítems datos que proporcionan información requerida para que operación sea exitosa. colabora-ción definida entre clases como parte del modelo requerimientos proporciona lineamientos útiles diseño mensajes. cox [cox] describe intercambio entre clases forma siguiente: objeto [clase] solicita para realizar una sus operaciones enviarle mensaje que diga qué hacer objeto. receptor [objeto] responde mensaje elegir primero operación que imple- por ejemplo, diseñar una subclase que herede atributos operaciones más una superclase ( ocasiones llamada “herencia múltiple”) mal vista por mayoría los diseñadores. (-)app.indd (-)app.indd // ::// :: conceptos orientados objeto menta nombre del mensaje, ejecutar esta operación luego regresar control solicitante. los mensajes ligan sistema orientado objeto. los mensajes proporcionan comprensión acerca del comportamiento objetos individuales del sistema como todo. polimorfismo. polimorfismo una característica que reduce enormemente esfuerzo - querido para extender diseño sistema orientado objeto existente. para entender polimorfismo, considere una aplicación con vencional que debe dibujar cuatro tipos diferentes gráficas: gráficas línea, gráficas pastel, histogramas diagramas kiviat. manera ideal, una vez recopilados los datos para tipo particular gráfica, ésta debe dibujarse misma. para lograrlo una aplicación convencional ( mantener cohesión módulo) sería necesario desarrollar módulos dibujo para cada tipo gráfica. entonces, dentro del diseño, debería incrustarse lógica control similar siguiente: caso gráficatipo: gráficatipo = graficalinea then dibujargráficalinea (datos); gráficatipo = graficapie then dibujargráficapie (datos); gráficatipo = histograma then dibujarhisto (datos); gráficatipo = kiviat then dibujarkiviat (datos); termina caso; aunque este diseño razonablemente directo, agregar nuevos tipos gráfica podría ser tru- culento. tendría que crearse nuevo módulo dibujo para cada tipo gráfica luego lógica control tendría que actualizarse para reflejar nuevo tipo gráfica. para resolver este problema sistema orientado objeto, todas las gráficas convierten subclases una clase general llamada gráfica. usando concepto llamado sobrecargar [tay], cada subclase define una operación llamada dibujar. objeto puede enviar men-saje dibujar cualquiera los objetos instanciados cualquiera las subclases. objeto que recibe mensaje invocará propia operación dibujo para crear gráfica adecuada. por tanto, diseño reduce dibujar <gráficatipo cuando nuevo tipo gráfica agrega sistema, crea una subclase con propia ope-ración dibujar. pero requieren cambios dentro algún objeto que quiera una gráfica - bujada porque mensaje dibujar <gráficatipo sigue invariable. para resumir, polimorfismo permite que algunas operaciones diferentes tengan mismo nombre. esto vez desacopla objetos uno otro, que los hace más independientes. clase diseño. modelo requerimientos define conjunto completo clases aná-lisis. cada una describe algún elemento del dominio problema, enfoca aspectos del :objetoemisor mensaje (<parámetros) :objetoreceptorfigura . mensaje que pasa entre objetos (-)app.indd (-)app.indd // ::// :: apéndice conceptos orientados objeto problema que son visibles usuario cliente. nivel abstracción cualquier clase análisis relativamente alto. conforme evoluciona modelo diseño, equipo software debe definir conjunto clase diseño que ) refinen las clases análisis, proporcionando detalle diseño que per- mitirá implementación las clases ) crear nuevo conjunto clases diseño que -plementen una infraestructura software que apoyo solución empresarial. sugieren cinco tipos diferentes clases diseño, cada una como representación una capa diferente arquitectura diseño [amb]: • clases interfaz usuario: definen todas las abstracciones que necesitan para interacción humano-computadora (ihc). • clases dominio empresarial: con frecuencia son refinamientos las clases análisis definidas anteriormente. las clases identifican los atributos operaciones (métodos) que requieren para implementar algún elemento del dominio empresarial. • clases proceso: implementan abstracciones empresariales nivel inferior requeridas para gestionar por completo las clases dominio empresarial. • clases persistentes: representan almacenes datos (por ejemplo, una base datos) que persistirá más allá ejecución del software. • clases sistema: implementan gestión software funciones control que permiten sistema operar comunicarse dentro entorno computación con mundo exterior. conforme evoluciona diseño arquitectónico, equipo software debe desarrollar con-junto completo atributos operaciones para cada clase diseño. nivel abstracción reduce conforme cada clase análisis transforma una representación diseño. decir, las clases análisis representan objetos ( métodos asociados que les aplican), usando jerga del dominio empresarial. las clases diseño presentan detalle significativamente más técnico como una guía para implementación. arlow neustadt [arl] sugieren que cada clase diseño revise para garantizar que está “bien formada”. definen cuatro características una clase diseño bien formada: completa suficiente. una clase diseño debe ser encapsulamiento completo -dos los atributos métodos que razonablemente pueda esperarse que existan para clase (con base una interpretación enterada del nombre clase). por ejemplo, clase - cena definida para software edición video completa sólo contiene todos los atri-butos métodos que razonablemente puedan asociarse con creación una escena video. suficiencia garantiza que clase diseño contiene solamente aquellos métodos que son suficientes para lograr intención clase, más menos. primitividad. los métodos asociados con una clase diseño deben enfocarse lograr una función específica para clase. una vez implementada función con método, clase debe proporcionar otra vía para lograr mismo. por ejemplo, clase videoclip del software edición puede tener atributos punto-inicial punto-final para indicar los puntos inicio finalización del clip (observe que video bruto cargado sistema puede ser más largo que clip que usa). los métodos, setstartpoint() setendpoint() proporcio- nan único medio para establecer puntos inicio finalización para clip. alta cohesión. una clase diseño cohesiva tiene solo propósito: tiene pequeño conjunto enfocado responsabilidades aplica atributos métodos decisivos para imple-mentar dichas responsabilidades. por ejemplo, clase videoclip del software edición video puede contener conjunto métodos para editar clip video. tanto cada (-)app.indd (-)app.indd // ::// :: conceptos orientados objeto método enfoque exclusivamente atributos asociados con videoclip, cohesión mantiene. low coupling. dentro del modelo diseño necesario que las clases diseño colabo- ren unas con otras. obstante, colaboración debe mantenerse mínimo aceptable. modelo diseño está enormemente acoplado (todas las clases diseño colaboran con todas las otras clases diseño), sistema difícil implementar, probar mante-ner con tiempo. general, las clases diseño dentro subsistema deben tener solamente conocimiento limitado otras clases. esta restricción, llamada ley démeter [lie], sugiere que método sólo debe enviar mensajes métodos clases vecinas. lecturas fuentes información adicionales durantes las tres décadas pasadas escribieron cientos libros acerca programación, análisis diseño orientado objeto. weisfeld (the object-oriented thought process, . ., sams publishing, ) presenta valioso tratamiento los conceptos principios generales . mclaughlin . ( head first object-orien- ted analysis and design: brain friendly guide ooa&, ’reilly media, inc., ) proporcionan trata-miento accesible disfrutable del análisis los enfoques diseño. tratamiento más profundo del análisis diseño presenta booch . (objetct-oriented analysis and design with applications, . ., addison-wesley, ). ( introduction object-oriented programming with java , mcgraw-hill, ) escribió libro exhaustivo acerca programación que clásico decenas escritos para muchos diferentes lenguajes programación. internet está disponible una gran variedad fuentes información acerca tecnologías orientadas objeto. una lista actualizada referencias world wide web puede encontrarse bajo “análisis” “-seño” sitio del libro: una manera menos formal plantear ley démeter , “cada unidad sólo debe hablar con sus amigos; hablar con extraños”. (-)app.indd (-)app.indd // ::// ::(-)app.indd (-)app.indd // ::// :: [abb] abbott, ., “program design informal english descriptions“, cacm, vol. , núm. , noviembre , . -. [acm] acm/ieee- joint task force, software engineering code ethics and professional practice, , disponible [ada] adams, ., mostly harmless, macmillan, . [afc] software risk abatement, afcs/aflc pamphlet -, .. air force, septiembre , .[agi] the agile alliance home page, airlie council, “performance based management: the program manager’ guide based the - point plan and related metrics”, draft report, marzo , . [aka] akao, ., quality function deployment, productivity press, . [ale] alexander, ., pattern language, oxford university press, .[ale] alexander, ., the timeless way building, oxford university press, .[amb] ambler, ., “using use-cases”, software development, julio , . -. [amb] ambler, ., process patterns: building large-scale systems using object technology , cambridge uni- versity press/sigs books, . [amb] ambler, ., the object primer, . ., cambridge university press, .[amb] ambler, ., “what agile modeling ()?” , ambler, . . jeffries, agile modeling, wiley, .[amb] ambler, ., “uml component diagramming guidelines”, disponible www. modelingstyle.info/, . [amb] ambler, ., “examining the cost change curve”, the object primer, . ., cambridge university press, . [amb] ambler, ., “the agile unified process (aup)”, , disponible cess/agileup.html. [and] andrews, . . whittaker, how break web software: functional and security testing web appli- cations and web services, addison-wesley, . [ans] ansi/asqc -, quality systems terminology, .[ant] anton, . . anton, iso survival guide, . ., aem consulting group, .[aos] aosd.net (aspect-oriented software development), glosario, disponible http://aosd.net/wiki/ index.php?title=glossary. [app] appleton, ., “patterns and software: essential concepts and terminology”, febrero , disponible [app] apple computer, accessibility, , disponible arlow, . . neustadt, uml and the unified process, addison-wesley, . [arn] arnold, . ., “software restructuring”, proc. ieee, vol. , núm. , abril , . -. [art] arthur, . ., “quantum improvements software system quality”, cacm, vol. , núm. , junio , . -. [ast] astels, ., test driven development: practical guide, prentice hall, . [ave] aversan, ., ., “managing coordination and cooperation distributed software processes: the genesis environment”, software process improvement and practice, vol. , wiley interscience, , . -. [baa] baar, ., “project risk checklist”, , disponible project_riskma- nagement_starting.htm. [bab] babich, . ., software configuration management, addison-wesley, . [bac] bach, ., “good enough quality: beyond the buzzword”, ieee computer, vol. , núm. , agosto , . -. [bac] bach, ., “the highs and lows change control”, computer , vol. , núm. , agosto , . - . [bae] baetjer , ., ., software capital, ieee computer society press, , . . [bak] baker, . ., “chief programmer team management production programming”, ibm systems jour- nal., vol. , núm. , , . -. [ban] baniassad, ., ., “discovering early aspects”, ieee software, vol. , núm. , enero-febrero, , . -. [bar] baresi, ., . dinitto . ghezzi, “toward open-world software: issues and challenges”, ieee computer, vol. , núm. , octubre , . -. [bas] basili, . . . . weiss, “ methodology for collecting valid software engineering data”, ieee trans. software engineering, vol. -, , . -.referencias (-)refer.indd (-)refer.indd // ::// :: referencias [bas] bass, ., . clements . kazman, software architecture practice, . ., addison-wesley, . [bec] beck, ., extreme programming explained: embrace change, addison-wesley, . [bec] beck, ., ., “manifesto for agile software development”, [bec] beck, ., extreme programming explained: embrace change, . ., addison-wesley, .[bec] beck, ., test-driven development: example, . ., addison-wesley, . [bee] beedle, ., ., “scrum: extension pattern language for hyperproductive software develop- ment”, incluido : pattern languages program design , addison-wesley longman, reading , , descargable http:/ /jeffsutherland.com/scrum/ scrum_plop.pdf. [bei] beizer, ., software system testing and quality assurance, van nostrand-reinhold, . [bei] beizer, ., software testing techniques, . ., van nostrand-reinhold, .[bei] beizer, ., black-box testing, wiley, .[bel] belady, ., prólogo software design: methods and techniques (. . peters, autor), yourdon press, . [bel] bellinzona ., . . gugini . pernici, “reusing specifications applications”, ieee software, marzo , . -. [ben] bentley, ., programming pearls, . ., addison-wesley, .[ben] bennatan, . ., software project management: practitioner’ approach , . ., mcgraw-hill, . [ben] bennett, ., . mcrobb . farmer, object-oriented analysis and design , . ., mcgraw-hill, . [ber] bersoff, . ., . . henderson . . siegel, software configuration management, prentice hall, . [ber] berard, ., essays object-oriented software engineering, vol. , addison-wesley, .[bes] bessin, ., “the business value quality”, ibm developerworks, junio , , disponible www- .ibm.com/developerworks/rational/library/.html. [bha] bhat, ., . gupta . murthy, “lessons from offshore outsourcing”, ieee software, vol. , núm. , septiembre-octubre . [bie] bieman, . . . . ott, “measuring functional cohesion”, ieee trans. software engineering, vol. -, núm. , agosto , . -. [bin] binder, ., “design for reuse for real”, american programmer , vol. , núm. , agosto , . - . [bin] binder, ., “testing object-oriented systems: status report”, american programmer, vol. , núm. , abril , . -. [bin] binder, . ., “object-oriented software testing”, communications the acm, vol. , núm. , sep- tiembre , . . [bin] binder, ., testing object-oriented systems: models, patterns, and tools, addison-wesley, . [bir] biró, . . remzsö, “business motivations for software process improvement”, ercim news, núm. , enero , disponible [boe] boehm, ., software engineering economics, prentice hall, . [boe] boehm, ., “ spiral model for software development and enhancement”, computer, vol. , núm. , mayo , . -. [boe] boehm, . ., software risk management, ieee computer society press, .[boe] boehm, ., “anchoring the software process”, ieee software, vol. , núm. , julio , . -. [boe] boehm, ., “using the winwin spiral model: case study”, computer, vol. , núm. , julio , . -. [boe] boehm, ., ., software cost estimation cocomo , prentice hall, .[boe] boehm, ., “the spiral model ool for evolutionary software acquisition”, crosstalk, mayo , disponible [boe] boehm, . . basili, “software defect reduction top list”, ieee computer , vol. , núm. , enero , . -. [boe] boehm, ., “making difference the software century”, ieee computer, vol. , núm. , marzo , . -. [boh] bohm, . . jacopini, “flow diagrams, turing machines and languages with only two formation rules”, cacm, vol. , núm. , mayo , . -. [boh] bohl, . . rynn, tools for structured design: introduction programming logic , . ., prentice hall, . [boi] boiko, ., content management bible, . ., wiley, .[bol] boldyreff, ., . , “environments support collaborative software engineering”, , descargable [boo] booch, ., object-oriented analysis and design, . ., benjamin cummings, .[boo] booch, ., . rumbaugh . jacobsen, the unified modeling language user guide. . ., addison- wesley, . [boo] bootstrap-institute.com, , booch, ., handbook software architecture , , disponible systems.jsp. (-)refer.indd (-)refer.indd // ::// :: [bor] borchers, ., pattern approach interaction design, wiley, . [bos] bosch, ., design & use software architectures, addison-wesley, . [bra] bradley, . ., “the science and art debugging”, computerworld, agosto , , . -. [bra] bradac, ., . perry . votta, “prototyping process monitoring experiment”, ieee trans. software engineering, vol. , núm. , octubre , . -. [bre] breen, ., “exposing the fallacy ’good enough’ software”, informit.com, febrero , , disponible [bro] brooks, ., the mythical man-month, silver anniversary edition, addison-wesley, . [bro] brown, . . . . wallnau, “engineering component based systems”, component-based soft- ware engineering, ieee computer society press, , . -. [bro] brown, ., oracle web development, . ., mcgraw-hill, .[bro] brooks, , “three great challenges for half-century-old computer science”, jacm, vol. , núm. , enero , . -. [bro] broy, ., “the ‘grand challenge’ informatics: engineering software intensive systems”, ieee com- puter, vol. , núm. , octubre , . -. [buc] bucanac, ., “the -model”, university karlskrona/ronneby, enero , descargable www. bucanac.com/documents/the_v-model.pdf. [bud] budd, ., introduction object-oriented programming, . ., addison-wesley, . [bus] buschmann, ., ., pattern-oriented software architecture, wiley, . [bus] buschmann, ., ., pattern-oriented software architecture, system patterns, wiley, . [cac] cachero, ., ., “conceptual navigation analysis: device and platform independent navigation specification”, proc. intl. workshop web-oriented technology, junio , descargable www. dsic.upv./~west/iwwost/papers/cachero.pdf. [cai] caine, frarber gordon, inc., pdl/, , disponible card, . . . . glass, measuring software design quality, prentice hall, .[cas] cashman, ., “object oriented domain analysis”, acm software engineering notes, vol. , núm. , octubre , . . [cav] cavano, . . . . mccall, “ framework for the measurement software quality”, proc. acm soft- ware quality assurance workshop, noviembre , . -. [ccs] consulting services, , cechich, ., ., “trends cots component identification”, proc. fifth intl. conf. cots-based software systems, ieee, . [cha] charette, . ., software engineering risk analysis and management, mcgraw-hill/ intertext, . [cha] charette, . ., “building bridges over intelligent rivers”, american programmer, vol. , núm. , sep- tiembre , . -. [cha] champeaux, ., . lea . faure, object-oriented system development, addison-wesley, . [cha] chakravarti, ., “online software design pattern links”, , disponible oopfm.shtml. [che] chen, ., the entity-relationship approach logical database design, qed information systems, . [chi] chidamber, . . . . kemerer, “ metrics suite for object-oriented design”, ieee trans. software engineering, vol. -, núm. , junio , . -. [cho] choi, . . . scacchi, “assuring the correctness configured software description”, proc. intl. workshop software configuration management , acm, princeton, , octubre , . -. [chu] churcher, . . . . shepperd, “towards conceptual framework for object- oriented metrics”, acm software engineering notes, vol. , núm. , abril , . -. [cig] cigital, inc., “case study: finding defects earlier yields enormous savings”, , disponible www. cigital.com/solutions/roi-.php. [cla] clark, . . baniasaad, aspect-oriented analysis and design, addison-wesley, . [cle] clements, ., “from subroutines subsystems: component based software development”, american programmer, vol. , núm. , noviembre . [cle] clements, ., . kazman . klein, evaluating software architectures: methods and case studies , addi- son-wesley, . [cle] clemmons, ., “project estimation with use case points”, crosstalk, febrero , . -, descar- gable [cmm] capability maturity model integration (cmmi) , software engineering institute, , disponible [cmm] people capability maturity model integration (people cmm) , software engineering institute, , disponible [coa] coad, . . yourdon, object-oriented analysis, . ., prentice hall, .[coa] coad, ., . lefebvre . deluca, java modeling color with uml, prentice hall, . [coc] cockburn, . . highsmith, “agile software development: the people factor”, ieee computer, vol. , núm. , noviembre , . -. [coc] cockburn, ., writing effective use-cases, addison-wesley, .[coc] cockburn, ., agile software development, addison-wesley, . (-)refer.indd (-)refer.indd // ::// :: referencias [coc] cockburn, ., “what the agile toolbox contains”, crosstalk, noviembre , disponible www. stsc.hill..mil/crosstalk///.html. [coc] cockburn, ., crystal clear, addison-wesley, . [con] conradi, ., “software process improvement: why need spiq”, ntnu, octubre , descargable [con] conradi, . . fuggetta, “improving software process improvement”, ieee software, julio-agosto , . -, descargable http:/ /citeseer.ist.psu.edu/conradi.html. [con] constantine, ., “work organization: paradigms for project management and organization”, cacm, vol. , núm. , octubre , . -. [con] constantine, , “what users want? engineering usability software”, windows tech journal, diciembre , disponible [con] constantine, . . lockwood, software for use, addison-wesley, ; vea también com/. [cop] coplien, ., “software patterns”, , disponible http:/ /hillside.net/patterns/definition.html.[cor] corfman, ., “ overview patterns”, the patterns handbook, sigs books, . [cou] coulouris, ., . dollimore . kindberg, distributed systems: concepts and design, . ., addison- wesley, . [cox] cox, brad, object-oriented programming, addison-wesley, .[cri] christel, . . . . kang, “issues requirements elicitation”, software engineering institute, cmu/sei--- , septiembre . [cro] crosby, ., quality free, mcgraw-hill, .[cro] cross, . . fisher, developer’ guide web application security, syngress publishing, . [cur] curritt, . ., . dyer . . mills, “certifying the reliability software”, ieee trans, software engi- neering, vol. -, núm. , enero . [cur] curtis, ., ., “ field study the software design process for large systems”, ieee trans. software engineering, vol. -, núm. , noviembre , . -. [cur] curtis, ., . hefley . miller, people capability maturity model, addison-wesley, . [cvs] concurrent versions system, ximbiot, http:/ /ximbiot.com/cvs/wiki/index.php?title= main_page, . [dac} “ overview model-based testing for software”, data and analysis center for software, / , junio , descargable practice/pdf/model_based_testing.pdf. [dah] dahl, ., . dijkstra . hoare, structured programming, academic press, . [dar] dart, ., “concepts configuration management systems”, proc. third international workshop software configuration management, acm sigsoft, , descargable [dar] dart, ., “change management: containing the web crisis”, proc. software configuration management symposium, toulouse, francia, , disponible conf/dart.html. [dar] dart, ., spectrum functionality configuration management systems , software engineering insti- tute, , disponible toc_tr.html. [das] dasari, ., “lean software development”, white paper, descargable www .projectperfect.com. /downloads/info/info_lean_development.pdf, . [dav] davenport, . . . . young, “the new industrial engineering: information technology and busi- ness process redesign”, sloan management review, verano , . -. [dav] davis, ., ., “identifying and measuring quality software requirements specification”, proc. first intl. software metrics symposium, ieee, baltimore, , mayo , . -. [dav] davis, ., “process and product: dichotomy duality”, software engineering notes, acm press, vol. , núm. , abril, , . -. [dav] davis, ., principles software development , mcgraw-hill, . [day] dayani-fard, ., ., “legacy software systems: issues, progress, and challenges”, ibm echnical report: -.-, abril , disponible publications/-.//legacy.html. [dem] deming, . ., out the crisis, mit press, .[dem] demarco, ., structured analysis and system specification, prentice hall, . [dem] demarco, ., why does software cost much? dorset house, .[dem] demarco, ., “lean and mean”, ieee software, noviembre , . -. [dem] demarco, . . lister, peopleware, . ., dorset house, .[dem] demarco, . . boehm, “the agile methods fray”, ieee computer, vol. , núm. , junio , . -. [den] dennis, ., “modularity”, advanced course software engineering (. . bauer, .), springer-ver- lag, , . -. [dev] devedzik, ., “software patterns”, handbook software engineering and knowledge engineering , world scientific publishing ., . [dha] dhama, ., “quantitative metrics for cohesion and coupling software”, journal systems and software, vol. , núm. , abril . (-)refer.indd (-)refer.indd // ::// :: [dij] dijkstra, ., “programming considered human activity”, proc. ifip congress, north-- lland publishing ., . [dij] dijkstra, ., “the humble programmer”, acm turing award lecture, cacm, vol. , núm. , octubre , . -. [dij] dijkstra, ., “structured programming”, software engineering, concepts and techniques, (. buxton ., eds.), van nostrand-reinhold, . [dij] dijkstra, ., discipline programming, prentice hall, . [dij] dijksta, ., “ the role scientific thought”, selected writings computing: personal perspective, springer-verlag, . [dix] dix, ., “design user interfaces for the web”, proc. user interfaces data systems conference, septiembre , descargable users/dixa/topics/webarch/. [dob] dobb, ., iso : quality registration step--step, . ., butterworth- heinemann, . [don] donahue, ., . weinschenck . nowicki, “usability good business”, compuware corp., julio , disponible [dre] dreilinger, ., “cvs version control for web site projects”, , disponible www .durak.org/ cvswebsites/howto-cvs/howto-cvs.html. [dru] drucker, ., management, . . heinemann, .[duc] ducatel, ., . , scenarios for ambient intelligence , istag-european commission, , descargable ftp:/ /ftp.cordis.europa./pub/ist/docs/ istagscenarios.pdf. [dun] dunn, . . ullman, quality assurance for computer software, mcgraw-hill, . [dun] dunaway, . . masters, cmm-based appraisal for internal process improvement (cba ipi version , method description), software engineering institute, , descargable tions/documents/.reports/.html. [dun] dunn, ., practical design safety-critical computer systems, william dunn, . [duy] vanduyne, ., . landay . hong, the design sites, addison-wesley, . [dye] dyer, ., the cleanroom approach quality software development, wiley, . [edg] edgemon, ., “right stuff: how recognize when selecting project manager”, application deve- lopment trends, vol. , núm. , mayo , . -. [eji] ejiogu, ., software engineering with formal metrics, qed publishing, . [elr] elrad, ., . filman . bader (eds.), “aspect oriented programming”, comm. acm, vol. , núm. , octubre , número especial. [eri] ericson, ., hazard analysis techniques for system safety, wiley-interscience, . [eri] erickson, ., the interaction design patterns page, mayo , disponible .com/~snowfall/ interactionpatterns.html. [eva] evans, ., domain driven design, addison-wesley, . [fag] fagan, ., “advances software inspections”, ieee trans. software engineering, vol. , núm. , julio . [fel] felican, . . zalateu, “validating halstead’ theory for pascal programs”, ieee trans. software - gineering, vol. -, núm. , diciembre , . -. [fel] feller, ., . (eds.), perspectives free and open source software, the mit press, . [fen] fenton, ., software metrics, chapman hall, .[fen] fenton, ., “software measurement: necessary scientific basis”, ieee trans. software engineering, vol. -, núm. , marzo , . -. [fer] ferguson, ., ., “results applying the personal software process”, ieee computer, vol. , núm. , mayo , . -. [fer] ferdinandi, . ., “facilitating communication”, ieee software, septiembre , . -. [fer] fernandez, . . . yuan, “semantic analysis patterns”, proceedings the int. conf. concep- tual modeling, , lecture notes computer science , springer, , . -. también disponible [fir] firesmith, . ., object-oriented requirements analysis and logical design, wiley, . [fis] fisher, . . shapiro, beyond reason: using emotions you negotiate, penguin, . [fit] fitts, ., “the information capacity the human motor system controlling the amplitude - vement”, journal experimental psychology, vol. , , . -. [fle] fleming, . . . . koppelman, “earned value project management”, crosstalk, vol. , núm. , julio , . . [fos] foster, ., “quality culprits”, infoworld grip line weblog, mayo , , disponible http:/ /weblog. infoworld.com/gripeline///.html. [fow] fowler, ., analysis patterns: reusable object models, addison-wesley, . [fow] fowler, ., ., refactoring: improving the design existing code , addison-wesley, . [fow] fowler, . . highsmith, “the agile manifesto”, software development magazine, agosto , www. sdmagazine.com/documents/=/sdm/.htm. [fow] fowler. ., “the new methodology”, junio , logy.html#. [fow] fowler, ., ., patterns enterprise application architecture, addison-wesley, . (-)refer.indd (-)refer.indd // ::// :: referencias [fow] fowler, ., uml distilled, . ., addison-wesley, . [fra] frankl, . . . weiss, “ experimental comparison the effectiveness branch testing and data flow”, ieee trans. software engineering, vol. -, núm. , agosto , . -. [fra] francois, ., “software architecture for immersipresence”, imsc technical report imsc--, university southern california, diciembre , disponible http:/ /iris.usc.edu/ ~afrancoi/pdf/sai- .pdf. [fre] freeman, ., “the context design”, software design techniques , . . (. freeman . wasser- man, eds.), ieee computer society press, , . -. [fre] freedman, . . . . weinberg, handbook walkthroughs, inspections and technical reviews, . ., dorset house, . [gag] gage, . . mccormick, “ did nothing wrong”, baseline magazine, marzo , , disponible [gai] gaines, ., “modeling and forecasting the information sciences”, technical report, university calgary, calgary, alberta, septiembre . [gam] gamma, ., ., design patterns: elements reusable object-oriented software, addison-wesley, . [gar] garvin, ., “what does ‘product quality’ really mean?” sloan management review, otoño , . -. [gar] garvin ., “competing the eight dimensions quality”, harvard business review , noviembre , . -. resumen disponible xrds-/software.html. [gar] garlan, . . shaw, “ introduction software architecture”, advances software engineering and knowledge engineering, vol. (. ambriola and . tortora, eds.), world scientific publishing company, . [gar] gartnergroup, “understanding hype cycles”, , disponible pages/story. php.....jsp. [gau] gause, . . . . weinberg, exploring requirements: quality before design, dorset house, . [gey] geyer-schulz, . . hahsler, “software engineering with analysis patterns”, technical report /, institut für informationsverarbeitung und -wirtschaft, wirschaftsuniversität wien, noviembre , descargable wwwai.-wien../~hahsler/ research/virlib_working/virlib/. [gil] gilb, ., principles software project management, addison-wesley, . [gil] gilb, ., “what fail our current testing culture”, testing techniques newsletter (online edition, ttn@soft.com), software research, enero . [gil] gillis, ., “pattern-based design”, tehan + lax blog, septiembre , , disponible lax.com/blog/?=. [gla] glass, ., “defining quality intuitively”, ieee software, mayo , . -, . [gla] gladwell, ., the tipping point, back bay books, . [gli] glinz, . . wieringa, “stakeholders requirements engineering”, ieee software , vol. , núm. , marzo-abril , . -. [glu] gluch, ., “ construct for describing software development risks”, cmu/sei---, software engineering institute, . [gna] gnaho, . . larcher, “ user-centered methodology for complex and customizable web enginee- ring”, proc. icse workshop web engineering, acm, los angeles, mayo . [gon] gonzales, ., “requirements engineering”, sandia national laboratories, presentación diapositi- vas, disponible [gor] gordon, . . gordon, the complete guide digital graphic design , watson- guptill, . [gor] gorton, ., essential software architecture, springer, . [gra] grady, . . . . caswell, software metrics: establishing company-wide program , prentice hall, . [gra] grady, . ., practical software metrics for project management and process improvement, prentice hall, . [gra] grable, ., ., “metrics for small projects: experiences sed ,” ieee software, marzo , . -. [gra] gradecki, . . lesiecki, mastering aspectj: aspect-oriented programming java, wiley, . [gru] grundy, ., “aspect-oriented component engineering”, , pects.html. [gus] gustavsson, ., “maintaining the evolution software objects integrated environment”, proc. intl. workshop software configuration management, acm, princeton, , octubre , . -. [gut] guttag, . . . . horning, larch: languages and tools for formal specification, springer-verlag, . [hac] hackos, . . redish, user and task analysis for interface design, wiley, . [hai] hailpern, . . santhanam, “software debugging, testing and verification”, ibm systems journal, vol. , núm. , , disponible /hailpern.html. [hal] halstead, ., elements software science, north-holland, . (-)refer.indd (-)refer.indd // ::// :: [hal] hall, ., “seven myths formal methods”, ieee software, septiembre , . -. [hal] hall, . ., managing risk: methods for software systems development, addison-wesley, . [ham] hammer, ., “reengineer work: don’ automate, obliterate”, harvard business review, julio-agosto , . -. [han] hanna, ., “farewell waterfalls”, software magazine, mayo , . -. [har] harmon, ., “navigating the distributed components landscape”, cutter journal., vol. , núm. , diciembre , . -. [har] harrison, ., . . counsell . . nithi, “ evaluation the mood set object-oriented software metrics”, ieee trans. software engineering, vol. -, núm. , junio , . -. [her] herrmann, ., software safety and reliability, wiley-ieee computer society press, . [het] hetzel, ., the complete guide software testing, qed information sciences, . [het] hetzel, ., making software measurement work, qed publishing, . [hev] hevner, . . . . mills, “box structure methods for system development with objects”, ibm sys- tems journal, vol. , núm. , febrero , . -. [hig] higuera, . ., “team risk management”, crosstalk, .. dept. defense, enero , . -. [hig] highsmith, ., adaptive software development: evolutionary approach managing complex systems , dorset house publishing, . [hig] highsmith, . (.), “the great methodologies debate: part ”, cutter journal., vol. , núm. , - ciembre . [hig] highsmith, . (.), “the great methodologies debate: part ”, cutter journal., vol. , núm. , enero . [hig] highsmith, ., agile software development ecosystems, addison-wesley, . [hil] hildreth, ., “buggy software: from low quality quagmire”, computerworld, julio , , dis- ponible ,,,.html. [hil] hillside.net, patterns catalog, , disponible http:/ /hillside.net/patterns/ onlinepatterncatalog. htm. [hob] hoberman, ., data modeling made simple, technics publications, . [hof] hofmeister, ., . nord . soni, applied software architecture, addison-wesley, .[hof] hofmann, ., ., “approaches software architecture”, , descargable http:/ /citeseer. .nec.com/.html. [hol] holzner, ., design patterns for dummies, for dummies publishers, . [hoo] hooker, ., “seven principles software development”, septiembre , disponible http:/ / .com/cgi/wikisevenprinciplesofsoftwaredevelopment. [hop] hopper, . ., “rattling sabre, new ways compete information”, harvard business review, mayo-junio . [hor] horch, ., practical guide software quality management, . ., artech house, . [hpr] hypermedia design patterns repository, , disponible ..unisi./index. htm. [hum] humphrey, ., discipline for software engineering, addison-wesley, . [hum] humphrey, ., “using defined and measured personal software process”, ieee software, vol. , núm. , mayo-junio , . -. [hum] humphrey, ., introduction the personal software process, addison-wesley, . [hum] humphrey, ., “the three dimensions process improvement, part iii: the team process”, cross- talk, abril , disponible [hum] humphrey, ., introduction the team software process , addison- esley, . [hun] hunt, ., . thomas . cunningham, the pragmatic programmer, addison- wesley, . [hur] hurley, . ., decision tables software engineering, van nostrand-reinhold, . [hya] hyatt, . . rosenberg, “ software quality model and metrics for identifying project risks and assessing software quality”, nasa satc, , disponible http:/ /satc.gsfc.nasa.gov/support/stc_apr/quality/stc_qual.html. [ibm] “implementing software inspections”, notas del curso, ibm systems sciences institute, ibm corpo- ration, . [ibm] ibm, web services globalization model, , disponible developerworks/webser- vices/library/-global/. [iee] ieee standards collection: software engineering, ieee standard .-, ieee, . [iee] ieee standard glossary software engineering terminology, ieee, . [iee] ieee standard association, ieee-std--, recommended practice for architectural description software-intensive systems, , disponible http://standards.ieee.org/ reading/ieee/std_public/ description//-.html. [ifp] function point counting practices manual, release .., international function point users group, , disponible [ifp] function point bibliography/reference library, international function point users group, , dis- ponible [isi] isixsigma, llc, “new six sigma: guide for both novice and experiences quality practitioners”, , disponible (-)refer.indd (-)refer.indd // ::// :: referencias [iso] iso : document set, international organization for standards, , iso-/iso/iso.html. [iso] formal specification notation—syntax, type system and semantics, iso/iec :, intl. stan- dards organization, . [iso] iso spice, , [ivo] ivory, ., . sinha . hearst, “empirically validated web page design metrics”, acm sigchi’, marzo -abril , , disponible http:/ /webtango.berkeley.edu/papers/chi/. [jac] jackson, . ., principles program design, academic press, . [jac] jacobson, ., object-oriented software engineering, addison-wesley, . [jac] jackman, ., “homeopathic remedies for team toxicity”, ieee software, julio , . -. [jac] jacobson, ., . booch . rumbaugh, the unified software development process, addison-wesley, . [jac] jacobson, ., “ resounding ‘yes’ agile processes—but also more”, cutter journal, vol. , núm. , enero , . -. [jac] jacyntho, ., . schwabe . rossi, “ architecture for structuring complex web applications”, , disponible [jac] jacobson, . . , aspect-oriented software development, addison-wesley, . [jal] jalote, ., ., “timeboxing: process model for iterative software development”, journal systems and software,vol. , núm. , , . -. disponible .iitk../users/jalote/papers/timeboxing.pdf. [jay] jaychandra, ., -engineering the networked enterprise, mcgraw-hill, . [jec] jech, ., set theory, . ., springer, .[jon] jones, ., programming productivity, mcgraw-hill, .[jon] jones, ., systematic software development using vdm, . ., prentice hall, . [jon] jones, ., “how software estimation tools work”, american programmer , vol. , núm. , julio , . -. [jon] jones, ., estimating software costs, mcgraw-hill, .[jon] jones, ., “software project management practices: failure versus success”, crosstalk, octubre . disponible [joy] joy, ., “the future doesn’ need ”, wired, vol. , núm. , abril .[kai] kaiser, ., “elements effective web design”, about, inc., , disponible http:/ / webdesign. about.com/library/weekly/.htm. [kal] kalman, ., web security field guide, cisco press, .[kan] kaner, ., . falk . . nguyen, testing computer software, . ., van nostrand-reinhold, . [kan] kaner, ., “lawyers, lawsuits, and quality related costs”, , disponible www .badsoftware. com/plaintif.htm. [kan] kaner, ., “pattern: scenario testing” (draft), , disponible patterns/pattern-scenario-testing-kaner.html. [kar] karten, ., managing expectations, dorset house, .[kau] kauffman, ., home the universe, oxford, .[kaz] kazman, ., ., the architectural tradeoff analysis method, software engineering institute, cmu/ sei---, julio . [kaz] kazman, . . eden, “defining the terms architecture, design, and implementation”, news@sei interactive, software engineering institute, vol. , núm. , , disponible [kei] keil, ., ., “ framework for identifying software project risks”, cacm, vol. , núm. , viem- bre , . -. [kel] kelly, . . oshana, “improving software quality using statistical techniques, information and software technology”, elsevier, vol. , agosto , . -, disponible ~kchang/comp/readings/improving_quality_with_statistical_ testing_infosofttech_agosto. pdf. [ker] kernighan, . . plauger, the elements programming style, . ., mcgraw-hill, . [ker] kerievsky, ., industrial : making work large organizations, cutter consortium, executive report, vol. ., núm. , , disponible resource-centers/agile-project-management/sample-our-research/apmr.html. [kim] kim, ., “ manifesto for collaborative tools”, . dobb’ journal, mayo , disponible www. blueoxen.com/papers//. [kir] kirani, . . . tsai, “specification and verification object-oriented programs”, technical report -, computer science department, university minnesota, diciembre . [kiz] kizza, ., computer network security, springer, .[knu] knuth, ., the art computer programming, tres volúmenes, addison-wesley, .[kon] konrad, . . cheng, “requirements patterns for embedded systems”, proceedings the - niversary ieee joint international conference requirements engineering , ieee, septiembre , . - , descargable http:/ /citeseer.ist.psu.edu/.html. (-)refer.indd (-)refer.indd // ::// :: [kra] krasner, . . pope, “ cookbook for using the model-view-controller user interface paradigm smalltalk-”, journal object-oriented programming , vol. , núm. , agosto-septiembre , . - . [kra] kraul, . . streeter, “coordination software development”, cacm, vol. , núm. , marzo , . -. [kru] krutchen, ., “software design postmodern era”, ieee software, vol. , núm. , marzo-abril , . -. [kru] kruchten, ., . obbink . stafford (eds.), “software architectural” (número especial), ieee software, vol. , núm. , marzo-abril, . [kur] kurzweil, ., the singularity near, penguin books, . [kyb] kyburg, . ., theory and measurement, cambridge university press, .[laa] laakso, ., ., “improved scroll bars”, chi conf. proc. , acm, , . -, disponible [lai] laitenberger, ., “ survey software inspection technologies”, handbook software enginee- ring and knowledge engineering, world scientific publishing company, . [lam] lam, ., “testing -commerce systems: practical guide”, ieee pro, marzo-abril , . -. [lan] lange, ., “’ testing time! patterns for testing software”, junio , descargable com/test-patterns/patterns/index.html. [lan] land, ., “ brief survey software architecture”, technical report, dept. computer engineering, mälardalen university, suecia, febrero . [leh] lehman, . . belady, program evolution: processes software change, academic press, . [leh] lehman, ., ., “metrics and laws software evolution—the nineties view”, proceedings the . international software metrics symposium (metrics ’), ieee, , descargable [let] lethbridge, . . laganiere, object-oriented software engineering: practical software development using uml and java, mcgraw-hill, . [let] lethbridge, ., personal communication domain analysis, mayo .[let] lethbridge, ., personal communication software metrics, junio .[lev] leveson, . ., safeware: system safety and computers, addison-wesley, . [lev] levinson, ., “let’ stop wasting $ billion year”, cio magazine, octubre , , disponible [lew] lewicki, ., . barry . saunders, essentials negotiation, mcgraw-hill, . [lie] lieberherr, ., “demeter: aspect-oriented programming”, mayo , disponible edu/home/lieber/lod.html. [lin] linger, ., . mills . witt, structured programming, addison-wesley, . [lin] linger, . . . . mills, “ case study cleanroom software engineering: the ibm cobol struc- turing facility”, proc. compsac ’, chicago, octubre . [lin] linger, ., “cleanroom process model”, ieee software, vol. , núm. , marzo , . -. [lis] liskov, ., “data abstraction and hierarchy”, sigplan notices, vol. , núm. , mayo . [liu] liu, ., ., “report the first sebpc workshop legacy systems”, durham university, febrero , disponible [lon] longstreet, ., “fundamental function point analysis”, longstreet consulting, inc., , dispo- nible [lor] lorenz, . . kidd, object-oriented software metrics, prentice hall, . [maa] maassen, . . stelting, “creational patterns: creating objects system”, , disponible [man] mantai, ., “the effect programming team structures programming tasks”, cacm, vol. , núm. , marzo , . -. [man] mandel, ., the elements user interface design, wiley, . [mar] marick, ., the craft software testing, prentice hall, . [mar] martin, ., “design principles and design patterns”, descargable www .objectmentor .com, . [mar] marciniak, . . (.), encyclopedia software engineering, . ., wiley, . [mar] marick, ., “software testing patterns”, , index.html. [mcc] mccabe, ., “ software complexity measure”, ieee trans. software engineering, vol. -, diciem- bre , . -. [mcc] mccall, ., . richards . walters, “factors software quality”, tres volúmenes, ntis -- , , , noviembre . [mcc] mccabe, . . . . watson, “software complexity”, crosstalk, vol. , núm. , diciembre , . -. [mcc] mcconnell, ., “best practices: daily build and smoke test”, ieee software, vol. , núm. , julio , . -. [mcc] mcconnell, ., software project survival guide, microsoft press, .[mcc] mcconnell, ., “software engineering principles”, ieee software, vol. , núm. , marzo-abril , disponible [mcc] mcconnell, ., code complete, microsoft press, . (-)refer.indd (-)refer.indd // ::// :: referencias [mcc] mccrory, ., “ten technologies watch ”, seachcio.com, octubre , , disponible http:/ /searchcio.techtarget.com/originalcontent/,,sid,. html. [mcde] mcdermid, . . rook, “software development process models”, software engineer’ reference book, crc press, , . /-/. [mcg] mcglaughlin, ., “some notes program design”, software engineering notes, vol. , núm. , octubre , . -. [mcg] mcgregor, . . . . korson, “integrated object-oriented testing and development processes”, communications the acm, vol. , núm. , septiembre, , . -. [men] mendes, ., . mosley . counsell, “estimating design and authoring effort”, ieee multimedia, vol. , núm. , enero-marzo , . -. [mer] merlo, ., ., “reengineering user interfaces”, ieee software, enero , . -. [mic] microsoft accessibility technology for everyone, , disponible [mic] microsoft, “prescriptive architecture: integration and patterns”, msdn, mayo , disponible http:/ /msdn.microsoft.com/-/library/.aspx. [mic] microsoft, “patterns and practices”, msdn, , disponible http://msdn.microsoft .com/- /library/.aspx. [mil] mills, . ., “mathematical foundations for structured programming”, technical report fsc -, ibm corp., federal systems division, gaithersburg, , . [mil] miller, ., “the philosophy testing”, program testing techniques , ieee computer society press, , . -. [mil] mills, . ., . dyer . linger, “cleanroom software engineering”, ieee software , septiembre , . -. [mil] mills, . ., “stepwise refinement and verification box structured systems”, computer, vol. , núm. , junio , . -. [mil] miller, ., “website testing”, , disponible white.papers/ website.testing.html. [mil] mili, . . cowan, “software engineering technology watch”, abril , , disponible www. serc.net/projects/techwatch/nsf%%.htm. [min] minoli, ., analyzing outsourcing, mcgraw-hill, .[mon] monk, . (.), fundamentals human-computer interaction, academic press, . [mor] moran, . ., “the command language grammar: representation for the user interface interac- tive computer systems”, intl. journal man-machine studies, vol. , . -. [mor] morales, ., “the dream team”, . dobbs portal, marzo , , disponible .com/dept/ global/. [mus] musa, . ., . iannino . okumoto, engineering and managing software with reliability measures, mcgraw-hill, . [mus] musa, ., “operational profiles software reliability engineering”, ieee software, marzo , . -. [mut] mutafelija, . . stromberg, systematic process improvement using iso : and cmmi, - tech, . [mye] myers, ., composite structured design, van nostrand, . [mye] myers, ., the art software testing, wiley, . [nas] nasa, software risk checklist, form ler-., marzo , descargable http:/ /osat-ext.grc. nasa.gov/rmo/spa/softwareriskchecklist.doc. [nau] naur, . . randall (eds.), software engineering: report conference sponsored the nato science committee, nato, . [ngu] nguyen, ., “testing web-based applications”, software testing and quality engineering , mayo-junio , disponible [ngu] nguyen, ., esting applications the web, wiley, . [ngu] nguyen, ., “model-based version and configuration management for web engineering lifecycle”, proc. intl. world wide web conf., edinburgo, escocia, , descargable mme/item.php?=. [nie] nierstrasz, ., . gibbs . tsichritzis, “component-oriented software development,” cacm, vol. , núm. , septiembre , . -. [nie] nielsen, . . levy, “measuring usability: preference . performance”, cacm, vol. , núm. , abril , . -. [nie] nielsen, . . wagner, “user interface design for the www”, proc. chi ’ conf. human factors computing systems, acm press, , . -. [nie] nielsen, ., designing web usability, new riders publishing, . [nog} nogueira, ., . jones luqi, “surfing the edge chaos: applications software engineering”, command and control research and technology symposium, naval post graduate school, monterey, , junio , descargable //html/pdf_papers/track_/.pdf. [nor] norden, ., “useful tools for project management” management production, . . starr (.), penguin books, . (-)refer.indd (-)refer.indd // ::// :: [nor] norman, . ., “cognitive engineering”, user centered systems design, lawrence earlbaum asso- ciates, . [nor] norman, ., the design everyday things, doubleday, . [nov] novotny, ., “next generation tools for object-oriented development”, the architecture journal, enero , disponible http://msdn.microsoft.com/-/library/.aspx. [noy] noyes, ., “rugby, anyone?” managing development ( online publication fawcette technical publications), junio , methodologies/scrum/. [off] offutt, ., “quality attributes web software applications”, ieee software , marzo-abril , . - . [ols] olsina, ., ., “specifying quality characteristics and attributes for web sites”, proc. icse wor- kshop web engineering, acm, los angeles, mayo . [ols] olsen, ., “from com common”, component technologies, acm, vol. , núm. , junio , dispo- nible http:/ /acmqueue.com/modules.php?name=content&=showpage& pid=. [omg] object management group, omg unified modeling language specification, version ., marzo , disponible [omg] “object constraint language specification”, unified modeling language, ., object manage- ment group, septiembre , descargable [orf] orfali, ., . harkey . edwards, client/server survival guide, . ., wiley, . [osb] osborne, . . . . chikofsky, “fitting pieces the maintenance puzzle”, ieee software, enero , . -. [oso] opensource.org, , disponible [pag] page-jones, ., practical project management, dorset house, , . vii. [pal] palmer, . . felsing, practical guide feature driven development, prentice hall, . [par] parnas, . ., “ criteria used decomposing systems into modules”, cacm, vol. , núm. , abril , . -. [par] pardee, ., satisfy and delight your customer, dorset house, . [par] park, . ., . . goethert . . florac, goal driven software measurement— guidebook, cmu/ sei---, software engineering institute, carnegie mellon university, agosto . [pat] patton, ., “understanding user centricity”, ieee software, vol. , núm. , noviembre- diciembre, , . -. [pau] paulish, . . carleton, “case studies software process improvement measurement”, computer, vol. , núm. , septiembre , . -. [pcm] “technologies watch”, magazine , julio , disponible ,.asp. [per] persig, ., zen and the art motorcycle maintenance, bantam books, . [pet] pethokoukis, ., “small biz watch: future business trends”, .. news & world report, enero , , disponible .htm. [pha] phadke, . ., quality engineering using robust design, prentice hall, . [pha] phadke, . ., “planning efficient software tests”, crosstalk, vol. , núm. , octubre , . -. [phi] phillips, ., the software project manager’ handbook, ieee computer society press, . [phi] phillips, ., “cmmi . tutorial.”, abril , disponible polya, ., how solve , princeton university press, .[poo] poore, . . . . mills, “bringing software under statistical quality control”, quality progress, - viembre , . -. [poo] poore , . ., . . mills . mutchler, “planning and certifying software system reliability”, ieee software, vol. , núm. , enero , . -. [pop] poppendieck, . . poppendieck, lean software development, addison-wesley, . [pop] poppendeick, llc, lean software development, disponible [pop] poppendieck, . . poppendieck, implementing lean software development, addison-wesley, . [pop] popcorn, ., faith popcorn’ brain reserve, , disponible [pot] potter, ., set theory and its philosophy: critical introduction, oxford university press, . [pow] powell, ., web site engineering, prentice hall, .[pow] powell, ., web design, . ., mcgraw-hill/osborne, .[pre] premerlani, . . blaha, “ approach for reverse engineering relational databases”, cacm, vol. , núm. , mayo , . -. [pre] pressman, ., making software engineering happen, prentice hall, . [pre] pressman, ., adaptable process model, revision ., . . pressman & associates, , disponible [pre] pressman, . . lowe, web engineering: practitioner’ approach, mcgraw-hill, .[put] putnam, ., “ general empirical solution the macro software sizing and estimation problem”, ieee trans. software engineering, vol. -, núm. , julio , . -. [put] putnam, . . myers, measures for excellence, yourdon press, . (-)refer.indd (-)refer.indd // ::// :: referencias [put] putnam, . . myers, “how solved the cost estimation problem?” ieee software, noviembre , . -. [put] putnam, . . myers, industrial strength software: effective management using measurement , ieee computer society press, . [pyz] pyzdek, ., the six sigma handbook, mcgraw-hill, . [qai] software engineering curriculum, qai, , información obtenida www .qaieschool.com/- nerpages/offer.asp. [qsm] “qsm function point language gearing factors”, version ., quantitative software management, , [rad] radice, ., high-quality low cost software inspections, paradoxicon publishing, . [rai] raiffa, ., the art and science negotiation, belknap press, . [ree] reel, . ., “critical success factors software projects”, ieee software, mayo , . -. [ric] ricadel, ., “the state software quality”, informationweek, mayo , , disponible www. informationweek.com//quality.htm. [ric] rico, ., roi software process improvement, . ross publishing, . puede encontrar artículo resumido http://davidfrico.com/rico.pdf. [roc] roche, . ., “software metrics and measurement principles”, software engineering notes, acm, vol. , núm. , enero , . -. [roc] graphic design that works, rockport publishers, . [roe] roetzheim, ., “estimating internet development”, software development, agosto , disponible [roo] roos, ., “the poised organization: navigating effectively knowledge landscapes”, , dispo- nible [ros] ross, ., . goodenough . irvine, “software engineering: process, principles and goals”, ieee computer, vol. , núm. , mayo . [ros] rosenhainer, ., “identifying crosscutting concerns requirements specifications”, , disponi- ble http:/ /trese..utwente./workshops/oopsla-early-aspects-/ papers/rosenhainer.pdf. [rou] rout, (project manager), spice: software process assessment—part : concepts and introductory guide, , descargable .html. [roy] royce, . ., “managing the development large software systems: concepts and techniques”, proc. wescon, agosto . [roz] rozanski, . . woods, software systems architecture, addison-wesley, . [rub] rubin, ., user interface design for computer systems, halstead press (wiley), . [rum] rumbaugh, ., ., object-oriented modeling and design, prentice hall, .[sar] sarwate, ., “hot not: web application vulnerabilities”, magazine, diciembre , , dispo- nible http:/ /scmagazine.com//news/article//hot-not-web- application-vulnerabilities. [sca] scacchi, ., “understanding software process redesign using modeling, analysis, and simulation”, software process improvement and practice, wiley, , . -, descargable ~wscacchi/papers/software_process_redesign/ spip-prosim.pdf. [sce] sceppa, ., microsoft ado.net, microsoft press, . [sch] schwabe, . . rossi, “the object-oriented hypermedia design model”, cacm, vol. , núm. , agosto , . -. [sch] schorsch, ., “the capability -maturity model”, crosstalk, noviembre , disponible www. stsc.hill..mil/crosstalk///.asp. [sch] schneider, . . winters, applying use cases, addison-wesley, .[sch] schwabe, . . rossi, “developing hypermedia applications using oohdm”, proc. workshop hypermedia development process, methods and models, hypertext ‘, , descargable http:/ /citeseer. .nec.com/schwabe.html. [sch] schulmeyer , . . . . mcmanus (eds.), handbook software quality assurance , . ., prentice hall, . [sch] schneidewind, ., “measuring and evaluating maintenance process using reliability, risk, and test metrics”, ieee trans. , vol. , núm. , noviembre-diciembre , . -, descargable www. dacs.dtic.mil/topics/reliability/ieeetrans.pdf. [sch] schwabe, ., . rossi barbosa, ., “systematic hypermedia application design using oohdm”, , disponible www-.inf.puc-rio./~schwabe// section.html. [sch] schwaber, . . beedle, agile software development with scrum, prentice hall, . [sch] schwaber, ., “agile processes and self-organization”, agile alliance, , cles/index. [sch] schlickman, ., iso : quality management system design , artech house publishers, . [sch] schmidt, ., “model-driven engineering”, ieee computer, vol. , núm. , febrero , . -. [sds] spice document suite, “the spice and iso document suite”, iso-spice, , disponible www. isospice.com/articles///spice-project/page.html. [sea] sears, ., “layout appropriateness: metric for evaluating user interface widget layout, ieee trans. software engineering, vol. -, núm. , julio , . -. (-)refer.indd (-)refer.indd // ::// :: [see] the software engineering ethics research institute, “ucita updates”, , disponible http:/ / seeri.etsu.edu/default.htm. [sei] scampi, . standard cmmi ®assessment method for process improvement: method description, soft- ware engineering institute, technical report cmu/sei---, descargable publications/documents/.reports/.html. [sei] “maintainability index technique for measuring program maintainability”, sei, , disponible [sei] “the ideal model”, software engineering institute, , disponible .edu/ideal/.[sha] shaw, . . garlan, “formulations and formalisms software architecture”, volume —lec- ture notes computer science, springer-verlag, . [sha] shaw, ., ., “abstractions for software architecture and tools support them”, ieee trans. software engineering, vol. -, núm. , abril , . -. [sha] shaw, . . garlan, software architecture, prentice hall, . [sha] shalloway, . . trott, design patterns explained, . ., addison-wesley, . [shn] shneiderman, ., software psychology, winthrop publishers, , . .[shn] shneiderman, . . plaisant, designing the user interface, . ., addison-wesley, . [sho] shooman, . ., software engineering, mcgraw-hill, . [sim] simsion, . . witt, data modeling essentials, . ., morgan kaufman, . [sin] singpurwalla, . . wilson, statistical methods software engineering: reliability and risk , springer- verlag, . [smi] smith, ., “the estimation effort based use cases”, rational software corp., , descargable [smi] smith, , reliability, maintainability and risk, . ., butterworth-heinemann, . [sne] sneed, ., “planning the reengineering legacy systems”, ieee software, enero , . -. [sne] snee, . . hoerl, leading six sigma, prentice hall, . [sol] van solingen, . . berghout, the goal/question/metric method, mcgraw-hill, . [som] somerville, . . sawyer, requirements engineering, wiley, . [som] somerville, ., “integrating requirements engineering: tutorial”, ieee software, vol. , núm. , enero-febrero , . -. [spi] “spice: software process assessment, part : concepts and introduction”, version ., iso/iec jtc, . [spl] splaine, . . jaskiel, the web testing handbook, stqe publishing, . [spo] spolsky, , “the law leaky abstractions”, noviembre , disponible www .joelonsoftware. com/articles/leakyabstractions.html. [sri] sridhar, . . mandyam, “effective use data models building web applications,” , dispo- nible [sso] software-supportability.org, .[sta] stapleton, ., dsdm—dynamic system development method: the method practice , addison-wesley, . [sta] statz, ., . oxley . ’toole, “identifying and managing risks for software process improvement”, crosstalk, abril , disponible /identifying.asp. [ste] stevens, ., . myers . constantine, “structured design”, ibm systems journal, vol. , núm. , , . -. [ste] stewart, . ., “reengineering: the hot new managing tool”, fortune, agosto , , . -. [ste] stelzer, . . mellis, “success factors organizational change software process improvement”, software process improvement and practice, vol. , núm. , wiley, , descargable [ste] stephens, . . rosenberg, extreme programming refactored, apress, .[sto] stone, ., ., user interface design and evaluation, morgan kaufman, . [tai] tai, . ., “what beyond branch testing,” acm software engineering notes, vol. , núm. , abril , . -. [ ] taylor, ., object-oriented technology: manager’ guide, addison-wesley, . [tha] thayer, . . . dorfman, software requirements engineering, . ., ieee computer society press, . [the] thelin, ., . petersson . wohlin, “sample driven inspections”, proc. workshop inspection software engineering (wise’) , parís, francia, julio , . -, descargable http:// mcmaster./wise/wise/thelinpeterssonwohlin.pdf. [tho] thomsett, ., “the indiana jones school risk management”, american programmer, vol. , núm. , septiembre , . -. [tic] tickit, , tidwell, ., “ patterns and techniques”, mayo , disponible http://time-tripper.com/ uipatterns/index.html. [til] tillmann, ., practical guide logical data modeling, mcgraw-hill, . [til] tillman, ., “evaluating quality the net”, babson college, mayo , , disponible petillman.com/findqual.html#. (-)refer.indd (-)refer.indd // ::// :: referencias [tog] tognozzi, ., “first principles”, asktog, , disponible html. [tra] tracz, ., “third international conference software reuse—summary”, acm software engineering notes, vol. , núm. , abril , . -. [tre] trivedi, , professional web services security, wrox press, . [tri] tricker, . . sherring-lucas, iso : brief, . ., butterworth- heinemann, . [tyr] tyree, . . akerman, “architectural decisions: demystifying architecture”, ieee software, vol. , núm. , marzo-abril, . [uem] uemura, ., . kusumoto . inoue: “ function point measurement tool for uml design specifi- cations”, proc. sixth international symposium software metrics , ieee, noviembre , . - [ull] ullman, ., close the machine: technophilia and its discontents, city lights books, . [uml] the uml café, “customers don’ print themselves”, mayo , disponible com/.htm. [uni] unicode, inc., the unicode home page, , disponible management quality insight, afcsp - (.. air force), enero , .[vac] vacca, ., practical internet security, springer, .[van] van vleck, ., “three questions about each bug you find”, acm software engineering notes, vol. , núm. , julio , . -. [van] van steen, . . tanenbaum, distributed systems: principles and paradigms, prentice hall, . [ven] venners, ., “design contract: conversation with bertrand meyer”, artima developer, diciembre , , disponible [wal] wallace, ., . raggett . aufgang, extreme programming for web projects, addison-wesley, . [war] warnier, . ., logical construction programs, van nostrand-reinhold, .[war] ward, ., “using voip software building zblocks— look the choices”, tmnnet, , disponible building-blocks.htm. [web] weber, ., the success open source, harvard university press, .[wei] weinberg, ., becoming technical leader, dorset house, .[wel] wells, ., “—unit tests”, , disponible html. [wel] vanwelie, ., “interaction design patterns”, , disponible patterns/.[whi] whittle, ., “models and languages for component description and reuse”, acm software enginee- ring notes, vol. , núm. , abril , . -. [whi] whitmire, ., object-oriented design measurement, wiley, .[wie] wiegers, ., peer reviews software, addison-wesley, .[wie] wiegers, ., software requirements, . ., microsoft press, .[wil] wilde, . . huitt, “maintaining object-oriented software”, ieee software, enero , . -. [wil] williams, . , . . walker . . dorofee, “putting risk management into practice”, ieee software, mayo , . -. [wil] wilkens, . ., “earned value, clear and simple”, primavera systems, abril , , . .[wil] williams, . . kessler, “all really need know about pair programming learned kindergar- ten”, cacm, vol. , núm. , mayo , disponible http:/ /collaboration.csc.ncsu.edu/laurie/papers/ kindergarten.pdf. [wil] willoughby, ., “&: quality software means more secure software”, computerworld, marzo , , disponible ,,,.html. [win] wing, . ., “ specifier’ introduction formal methods”, ieee computer , vol. , núm. , septiem- bre , . -. [ ] wirth, ., “program development stepwise refinement”, cacm, vol. , núm. , , . - . [wir] wirfs-brock, ., . wilkerson . weiner, designing object-oriented software, prentice hall, . [wmt] web mapping testbed tutorial., , disponible vcgdocuments/vcg- tutorial/. [woh] wohlin, . . runeson, “certification software components”, ieee trans. software engineering, vol. -, núm. , junio , . -. [wor] world bank, digital technology risk checklist, , descargable /wwbank_technology_risk_checklist_ver_.pdf. [] world wide web consortium, web content accessibility guidelines, , disponible www. .org///-wcag-/. [yac] yacoub, ., ., pattern-oriented analysis and design, addison-wesley, . [you] yourdon, ., techniques program structure and design, prentice hall, . [you] yourdon, . . constantine, structured design, prentice hall, .[you] yourdon, ., “when good enough best”, ieee software, vol. , núm. , mayo , . -. [you] young, ., effective requirements practices, addison-wesley, .[zah] zahniser, . ., “building software groups”, american programmer , vol. , núms. -, julio-agosto . [zah] zahniser, ., “timeboxing for top team performance,” software development, marzo , . -. (-)refer.indd (-)refer.indd // ::// :: [zha] zhao, , “ assessing the complexity software architectures”, proc. intl. software architecture workshop, acm, orlando, , , . -. [zha] zhao, ., “fitt’ law: modeling movement time hci”, theories computer human interaction, university maryland, octubre , disponible fitts.html. [zul] zultner, ., “quality function deployment for software: satisfying customers”, american programmer, febrero , . -. [zus] zuse, ., software complexity: measures and methods, degruyter, . [zus] zuse, ., framework software measurement, degruyter, . (-)refer.indd (-)refer.indd // ::// ::(-)refer.indd (-)refer.indd // ::// :: analítico índice analítico abstracción, datos, dimensión , accesibilidad, , , , , -(), estructural(), -, , - actor(), , , contenido, - complejidad, - configuración del software, , reutilización, los requerimientos, , cambio, - riesgo, las acciones , - pruebas, administración configuración del software, auditoría configuración, cambio, - versión, - , - operativo, - objetos, - (ics), , referencia, - webapps, - del estado configuración, repositorio, - administración calidad; véase aseguramiento calidad del software administración proyectos, conceptos clave, - agilidad, -, costo del cambio, - ágil, humanos, - , -, alcance del proyecto, trabajo, del software, -, , , clases , - interfaz, , , - tarea, , - patrones, - valor frontera (bva), -, valor ganado (avg), - dominio, -, flujo del trabajo, - mercado, usuario, -, , , -, objetos, , , - análisis los requerimientos, objetivos, prácticas, - modelo, aplicaciones interactivas inmersión, aprendizaje, continuo, interfaz webapp, , - árbol decisión, -, , (), intercambio objetos comunes solicitados (gao/atocs), una webapp, - contenido, -, redes, arquitectura del software, , - centrada los datos, , flujo datos, inmerpresencia (asi), llamada procedimiento remoto, llamar regresar, , programa principal/subprograma, decisiones arquitectónicas, , dependencias entre los componentes, descripción arquitectónica (), - diagrama contexto arquitectónico (dca), diseño arquitectónico, , - capas, - arquitectónico, - , - arquitectónico, - , , - descripción arquitectónica (lda), - mapeo, - negociación para analizar , - orientadas objetos, , , -, - arreglo ortogonal, - calidad del software, , acciones , -, , - formales, - del, estadísticos, - , - vitales, sigma, - asi; véase arquitectura software inmerpresencia asignación tiempo, , - véase método negociación para arquitectura atractivo visual webapps, , , configuración, autenticación, controlada, , ; véase análisis valor ganado barra navegación horizontal, datos, prueba , -, reutilización, -, -; véase análisis valor frontera calendarización, calendario del proyecto, - proyectos webapp, - proyecto software, - del programa técnica revisión (pert), fechas límite agresivas, (-)index.indd (-)index.indd // ::// :: índice analítico método ruta crítica (cpm), , para proyecto , - básicos, - calidad, , , árbol requerimientos , , conformidad, diseño, función , , - vista, calidad del software, , administración proyectos, , , - , , - administrativas, - , garvin , iso , mccall, , - , -, subjetiva , -, - aplicación web, -, , seguridad, calificación del proyecto, , , dimensionamiento del, “campeón del proyecto”, -, , para resolver problemas difusos, capas interacción, -, calidad las, , impredecible, acoplamiento, -, riesgos, del dominio, métricas , patrones, - datos, -, calidad, uso, , - diseño, potenciales, , ciclomática, - diseño, acs, - acerca las métricas, ágil software, actividades, contexto arquitectónico (dca), diagrama estado, flujo datos, -, - diagrama secuencia uml, interfaz usuario, - diseño pruebas únicas, . codificación, preliminar pantalla, enfoque métricas, comunicación, preliminar uso, arquitectura, , arquitectura, caso uso, del proyecto, - del comportamiento, del flujo datos, crc, clase, -, , - requerimientos, - para prueba, abierto-cerrado, , clase, -, - los requerimientos, , - arquitectura, dorada, del diseño interfaz, calendario, cascada, modelo , prueba, - , caso() uso, , , - creación , - , - actividad uml, - canal uml, ( trigger), , , , , -, -, - , - uml, - contexto, -, castellano estructurado; véase lenguaje diseño del programa cba ipi; véase cmmcentro transformación, , vida clásico; véase modelo cascadamdsd, clase(), , -, categorías , análisis, , -, controlador, diseño, - entidad, , equivalencia, frontera, proceso, sistemas, sustantivos, usuario interfaz, dominio negocios, una, -, negocio, objetos, , , clases análisis atributos las, - selección, - las operaciones, - estado para, - las, - , clientes, expectativas los, cmm; véase modelo madurez capacidad cmmi; véase integración del modelo madurez capacidades codificación , principios , - coherencia, , , -, , , , , recabación, - colaboraciones, -, navegación vertical, escritos, , webapps, , , arquitectónica, , componente(), , , adaptación, , , , - , , experiencia completa, experiencia parcial, , del contenido nivel , - envoltura , - del software , marcos basados , , -, , comportamiento, , (-)index.indd (-)index.indd // ::// :: analítico comprobabilidad, computación mundo abierto, , , , , cara cara, interfaz webapp, , - comunicaciones, del proyecto, interfaz webapp, , -, -, , modelo , , , - compuesta, , , , , del software, , confianza, , tareas, identificación , consistencia interfaz, - webapps, interfaz webapp, - construcción(), basada componentes, - interfaz, , , - contenido acoplamiento , autor, pantalla, - del, nivel componentes, - modelo , , -, contexto, modelo , acoplamiento del, acceso, , calidad, cambio, - sincronización, versión, - , - usuario, - controlabilidad, , vista del modelo (cvm), - convergencia, -, , , , calidad, - las revisiones, cpm; véase método ruta críticacrc; véase modelo clase-responsabilidad- colaborador crítica las arquitecturas candidatas, , -; véase especificación controlcvm; véase controlador vista del modelo ; véase descripción arquitectónica das; véase desarrollo adaptativo software datos abstracción , , los, los, , , , flujo , - , -, , , , abstractos (vda), dca; véase diagrama contexto arquitectónico decisión(), arquitectónicas, , /comprar, - , - defecto, amplificación del, densidad del error, , , , , -; véase diagrama entidad-relacióndesarrollo, adaptativo software (das), -, - casos uso, - software orientado aspectos, - impulsado por las características (dic), - desarrollo esbelto software (des), - descomponibilidad, , enfoque , - arquitectónica (), - los estilos patrones arquitectura, desempeño, calidad del, , función calidad (dfc), , - dfc; véase despliegue función calidad dfd; véase diagrama flujo datosdiagrama() actividad uml, -, , - canal uml, clase, - colaboración, contexto, contexto arquitectónico (dca), despliegue, , estado, -, - flujo, flujo datos (dfd), implementación, secuencia, , - uso caso, --relación (der), , clases análisis, - dibujo, ; véase desarrollo impulsado por las características diseño, abstracto interfaz, -, - del, del buen, alto nivel, arquitectura, -, interfaz, interfaz del usuario, - navegación para mdhoo, los datos, , navegación, - nivel componente, , - , - estructurado, , para , del, - gráfica del, - tabular del, - reutilización (dpr), , , - diseño basado patrones contexto, - comunes , - pensar, - arquitectónicos, - organizadora patrones, del, - diseño componentes, aplicado sistema orientado objetos, - componente, lógicas, - basados componentes, interfaz uml, , - del, objetos, - webapps, - básicos, -, del proceso, tradicional, -, - clases, diseño software, , abstracción, - del software, -, (-)index.indd (-)index.indd // ::// :: índice analítico basado patrones, - calidad, las clases , - , - problemas, del, información, - funcional, del, , - información, - objeto, diseño, , stepwise, generales, ingeniería software, diseño webapps arquitectura del contenido, - visual, del, -, , vista del modelo (cvm), - controlador, gráfico, , pantalla, nivel componentes, -, , -, - calidad, - gráficos, , -, , - revisión, , - navegación, para , -, , contenido, - mercado, del, , , navegación, -, navegación, -, , - disparador ( trigger), , , las webapps, software, dispositivos, , pantalla webapps, diversificación, -, -, , () análisis del, - aplicación del software, - aplicación específica, información, del, funcional, dpr; véase diseño para reutilizacióndsoa; véase desarrollo software orientado aspectos durabilidad, ecuación software, -, , , remoción defecto (erd), , interfaz webapp, eis; véase entorno ingeniería software elaboración, , , , , común, descomposición, - enlaces, , - externas, , ingeniería software (eis), , entrevistas, , ágil, tóxico, , -, - erd; véase eficiencia remoción defecto error, corrección del, del, ers; véase especificación requerimientos software escalabilidad, () investigación, uso, basados , , basadas , -, - escuchar, distribución , - , - para webapps , personal, - especificación control (cspec), - requerimientos software (ers), del proceso (pspec), - especulación, ágil, , cmmi, , estereotipo, , , webapps, - estilos arquitectónicos, - control, , - del, -, - , - estimación(), , - basada problema, - proceso, - casos uso, - , proyecto software, -, -, - , - cocomo , - proyectos ágiles, - software , - webapps, , - , estrategia() depuración, - desarrollo incremental, prueba software, - pruebas , - estructura(), , arquitectónicas canónicas, , caja, concurrencia, control, - desarrollo, implementación, las webapps, malla, red, proceso, , , , , , -, evaluación costos , calidad, - factibilidad, interfaz usuario, - los atributos calidad, programa técnica revisión (pert), del riesgo, evento(), común, evolución continua, software, - (-)index.indd (-)index.indd // ::// :: analítico exactitud, excepción, facilitador, ajuste valor (fav), , , costos , - fallas tiempo (fet), ; véase formas navegarfet; véase fallas tiempofirewall, , interfaz webapp, flujo trabajo, , , , - transformación, procesamiento, orientados , , formalidad las revisiones técnicas, - formas navegar (fdn), caso uso, - patrón diseño, modelo del diseño, formulación, abierta, , , , las webapps, gao/atocs; véase arquitectura intercambio objetos comunes solicitados género arquitectónico, -, ; véase grupo prueba independientegráfico(), flujo programa, - gantt, granularidad, prueba independiente (gpi), - guardia, ; véase interfaz gráfica del usuarioguiones cgi, hardware sustitución del, falla del, herramientas software administración contenido, - calidad del software, administración proyecto, del proceso, estructurado, del proyecto, , casos uso, arquitectónico, casos prueba, métricas, - esfuerzo costo, del cambio, los requerimientos, software, inversa, del usuario, , descripción arquitectónica, manejo riesgo, formales, producto, del proyecto del proceso, métricas técnicas para webapps, análisis con uml, datos, del proceso, proceso ágil, - tendencias blandas, - administración pruebas, prueba aplicaciones web, software, -, versiones concurrentes (svc), tecnología del proceso, -, - historias del usuario, definidos, dinámico, icoa; véase ingeniería componentes orientada aspectos ics; véase ítems configuración del software identidad webapps, - sensibilidad, , , del mdhoo, del software, ; véase índice madurez softwareincrementos software, , , , madurez software (ims), continuidad del flujo , , , , ingeniería concurrente, componentes orientada aspectos, - hacia adelante, -, - ingeniería requerimientos, -, colaboración, -, -, , - recabación, -, puntos vista, , -, prioridad, ingeniería software, asistida por computadora, componentes (isbc), quirófano, salas limpias, , dominio, software, - , construcción, , - , - , por modelo, - por pruebas, - , , - , - fundamentales, - , - , -, - ingeniería del software cuarto limpio certificación, , -, -, -, - inmediatez, , del modelo madurez capacidades (cmmi), - integridad, , ambiental (ami), , interacción flexible, , , , - diseño abstracto , - una webapp, - , mecanismo , - interfaz del usuario accesibilidad, trabajo, , , , - tarea, , - (-)index.indd (-)index.indd // ::// :: índice analítico análisis del mercado, casos uso, - escritos, , - , pantalla, - usuario, - objetos , - , - tarea, del objeto, -, unicode, , - (gui), ayuda, apoyo, ventas, , - menú, , - error, - del diseño , del diseño , - diseño , - diseño , - análisis diseño , - prueba , - respuesta, - , interfaz para una webapp aprendizaje, controlada, fundamentales, , , , -, , trabajo, - los productos, , fitt, prácticos, -, visible, interfaz, , latencia, del estado, interoperabilidad, las webapps, interpretación, ; véase ingeniería software basada componentes iso: para software, , configuración del software (ics), , ixp; véase industrial juegos, kit desarrollo bean (kdb), lda; véase lenguajes descripción arquitectónica ldp; véase lenguaje diseño del programa legibilidad interfaz webapp, () descripción arquitectónica (lda), , - diseño del programa (ldp), - especificación , - restricción objeto, -, - ley fitt, menú, código (loc), verificación para , ; véase líneas códigológica difusa, , ; véase modelado ágilmaestro scrum, , , , , del dominio funcional, software, - mapas del sitio, , arquitectónico, transformación, - marcas página, framesets, grafo, ; véase modelo componentes objetos mdhoo; véase método diseño hipermedios orientado objetos mdsd; véase método desarrollo sistemas dinámicos mecanismos interacción, -, , , del software, - médicos, (), directas, mejoramiento del proceso software (mps), - actividad selección justificación, - cmm personal, -, - capacitación, , - éxito cruciales, riesgo, marcos conceptuales, -, conceptuales, - proceso, madurez, -, sobre inversión, -, - memorización, - error, -, para diseño webapps, - método() desarrollo sistemas dinámicos (mdsd), diseño hipermedios orientado objetos (mdhoo), - ingeniería web, ingeniería software, , negociación para arquitectura (atam), - prueba , - ruta crítica (cpm), , , - servicios, métrica(), , - acoplamiento, cohesión, complejidad, contenido, - diseño interfaz usuario, diseño nivel componente, - halstead aplicadas, interfaz, - las revisiones técnicas, - navegación, diseño arquitectónico, -, , -, operación, código fuente, - diseño orientado objetos, - para mantenimiento, pruebas, - pruebas orientadas objetos, - para webapps, - métricas proceso, - producto basada funciones, - atributos, - punto función (), - conceptual, -, medición métrica, valorar calidad, - meta/pregunta/métrica (mpm), - principios medición, - métricas proyecto, , (-)index.indd (-)index.indd // ::// :: analítico métricas software, proyecto webapp, - una organización pequeña, - medición calidad, - caso uso, función, tamaño, - proyectos , - entre loc , - militares, del software, -; véase plan mitigación, monitoreo manejo riesgo modalidad, , , ágil (), -, - datos, - estado finito, - flujo datos, flujo transacción, navegación para webapps, los requerimientos, temporización, análisis, diseño, - flujo control, modelado basado clases asociaciones, -, --responsabilidad-colaborador (crc), - clases, análisis, , -, , , , -, -, , - modelado los requerimientos, análisis estructurado, , clases, - escenarios, - casos uso, - del, , - del, - profundidad, comportamiento, - flujo, - webapps, - para , - del, - modelo(), , , - doo, -responsabilidad-colaborador (crc), -, - cocomo , - amplificación del defecto, - certificación, componente, componentes objetos (mco), , comportamiento, - configuración para webapps, contenido para webapps, - estimación, flujo control, flujo datos, - implementación, interacción para webapps, - madurez, - madurez capacidad personal, - madurez capacidad (cmm), , , marco, muestreo, referencia para revisiones técnicas, requerimientos, , , -, usuario, - análisis, , diseño, proceso, , , para webapps, -, , , objetos, - basada (pbm), modelo del diseño arquitectura datos, abstracción, del proceso, datos, arquitectura, interfaz, - usabilidad, del despliegue, - nivel los componentes, - formato descriptor, , , modelos del proceso ágil, desarrollo adaptativo software (das), - desarrollo esbelto software (des), - desarrollo impulsado por las características (dic), - familia cristal, desarrollo sistemas dinámicos (mdsd), modelado ágil (), - unificado ágil (pua), - extrema (), -, - modelos del proceso prescriptivo, , concurrente, - basado componentes, , -, - trabajo, , - cascada, - métodos formales, , espiral, del equipo software, - personal del software, - unificado, - modularidad, - búsqueda, ; véase mejoramiento del proceso software multiplicidad, - navegabilidad webapps, diseño , - , para mdhoo, (), , - , - semánticas (usn, )visible, negligencia, -, , -, -; véase nodos navegaciónnodo() gráfico flujo, navegación (), , , notación matemática, - objetivo contexto, -(), agregado, -, orientado , , , orientada , aplicación, contenido webapps, - datos, interfaz webapp, , , observabilidad, los requerimientos restricciones, ocurrencias, tick (), , mercado, propia, - objetos (), atributos, (-)index.indd (-)index.indd // ::// :: índice analítico calendarización para proyecto, - casos prueba, - clase, diseño, - independientes, casos prueba, para software, - prueba, -, clase, -, prueba, -, del diseño, - para proyectos, - análisis diseño, - objetos, , basada hebra, basada uso, grupo, integración los sistemas, , pruebas unidad , -, validación , para software, - outsourcing, pac; véase principio abierto-cerradoparadigma meta/pregunta/métrica (mpm), partición equivalencia, , -, planeación, patrón(), , arquitectónicos, - análisis, -, - diseño, , - interfaz usuario, -. prueba, - proceso, - basado , - modelado requerimientos, - patrones diseño, , arquitectónicos, , , componentes, datos, interfaz usuario, - webapp, -, - nivel componentes, -, simplificado , , , , , - forma pensar, , , -, fuerzas, organizadora , pbm; véase prueba basada modelopcc; véase principio cierre comúnpcu; véase puntos caso usopeople-cmm; véase modelo madurez capacidades del personal per; véase principio equivalencia liberación reutilización percepción, operativo, , , , - esfuerzo, - pes; véase proceso del equipo softwarepestañas, ; véase punto funciónpid; véase principio inversión dependencia pirámide del diseño webapps, acs, - mitigación, monitoreo manejo riesgo (mmmr), - planeación, , iterativa, , -, - planificación proyecto, - conjunto tareas, , -, - plantillas programa, , ; véase programación orientada aspectos pocas vitales, del desarrollo ágil, , , mortem, ; véase proceso personal del softwarepráctica, - eficaces respecto los requerimientos, esencia , - fundamentales , - prc; véase proceso reutilización común precondición, libres del contexto, producción del producto del trabajo, prevención, costos , , (), abierto-cerrado (pac), - agrupamiento, - agilidad, - cierre común (pcc), codificación, - comunicación, - construcción, - despliegue, - diseño interfaz, - equivalencia liberación reutilización (per), inversión dependencia (pid), ingeniería software, -, - planeación, - práctica, - prueba, - reutilización común (prc), modelado, - preparación, programación, - segregación interfaz (psi), sustitución liskov (psl), validación, modelado del diseño, - proceso del software, , problemas, división , , , ágil, análisis diseño interfaz, - ingeniería software, - equipo software, - software, - del, , del, del, - del, del, - producto , general del, - , - del software, -, , -, - ágil (pua), -, - proceso del software, -, enfoques para evaluación mejora del, métricas, - fundamentales del, proceso unificado concepción, -, -, , , , productor, (), -, - del trabajo, , - del, -, , programación decisiones , - aspectos, pares, - , - (-)index.indd (-)index.indd // ::// :: analítico programación estructurada, , programación extrema, (), codificación, , -, -, , -, -, -, - programación por parejas, arquitectura del software, protocolos interfaz, , -, , - software, - prueba() alfa, valor frontera, -, - escenario, - hebra, modelo (pbm), uso, , , - módulos atómicos, - builds, terminación, aceptación del cliente, aceptación , arquitecturas cliente-servidor, - arreglo ortogonal, - base datos, - caja blanca, caja vidrio, caja negra, , - comportamiento, , comunicación red, condición, configuración, despliegue, - esfuerzo, - flujo datos, función aplicación, grupo, gui, humo, - integración, - estructura control, - recuperación, regresión, - rendimiento, ruta trayectoria básica, - seguridad, sensibilidad, servidor, sistema, tareas, transacción, unidad, - validación, - ampliada , sistema, , - causa, estratégico, - pruebas, , -, humano, , - prueba independiente (gpi), - integración primero profundidad, - intertarea, grafo, basados gráficos, - crítico, , - software , - sistemas tiempo real, - para software convencional, - webapps, - equivalencia, , - , - depuración, - sándwich, hacia atrás, , , , pruebas aplicaciones , - aleatoria, fallo, , bucle, - clase múltiple, - integración, , - partición, unidad, -, validación, sistema, aoo doo, comportamiento, - pruebas para webapps, - capas interacción, - carga, - compatibilidad, configuración, - contenido, - error forzado, - esfuerzo, interfaz usuario, - base datos, - semántica interfaz, semántica navegación, - mecanismo interfaz, - rendimiento, - rutas, seguridad, - sintaxis navegación, - usabilidad, - calidad, nivel componente, -, para, - , , - psi; véase principio segregación interfaz psl; véase principio sustitución liskov pspec; véase especificación del procesopua; véase proceso unificado ágilpunto función (), dimensionamiento del, puntos caso uso (pcu), prioridad, referencia puntuales, - vista múltiples, recolección, ambientales, software reutilizables, -, - red tareas, arquitecturas sencillas , intensivo , redirecciones, , latencia, software, -, doradas, -, análisis costo-beneficio para, - procesos empresa (rpe), - software, - relación(), dependencia, rendimiento, , las webapps, reporte, -, acs, - hipermedios, patrones diseño, , -, requerimientos análisis los, - los principios modelado, - del modelo , -, - recabación los, - ingeniería , - los, , , - los, - , , los, - (-)index.indd (-)index.indd // ::// :: índice analítico resistencia, respeto mutuo, (), , -, definidas, resultados definidos, , , , , , casual, scrum, , administración , para , , - para (dpr), revisión del diseño alto nivel, , , revisiones técnicas (), , , eficacia del costo las, - (rtf), -, - para las, - pendientes las, verificación para, las, - referencia para, formalidad apropiado, - objetivo principal las, muestreo, , por pares, - técnico formal las, casual, , escritorio, riesgo(), , administración del, , , , software, - orientadas , del, , - , - del, - del, - , mitigación, monitoreo manejo (mmmr), - proyección , - del, , - del, - riqueza, , webapps, roles, ; véase reingeniería procesos empresa ; véase revisiones técnicas rtf; véase revisiones técnicas formalesruta independiente, - scampi; véase estándar cmmscripts instalación, , -; véase separación entidadesseguimiento del estado, control del proyecto software, seguridad, , las webapps, , software, seis sigma, - navegación, -, entidades (sde), , ; véase lenguaje diseño del programa simplicidad, , webapps, sintaxis navegación, -() aseguramiento calidad, - fuerzas, tiempo real, - iguales, , , del, -, , software ámbito del, - web webapps, , - del, , -, - calidad del, configuración, constructores , del, , del, - , - del, aplicación, ingeniería ciencias, inteligencia artificial, línea productos, mundo abierto, sistemas, , - del, - , - del, - abierta, - del, , - del, , - del, - del, -, - del, desafíos , dual del, - del proyecto , acerca , del, -, eficaz , vista economista sobre , seguimiento control del proyecto , soportabilidad , - fallas del, - soportabilidad software, - (iso/iec ), , -, probarse, tabla activación del proceso (tap), decisión, - voz del cliente, patrones, tap; véase tabla activación del proceso tarea() análisis , , - uso, - , , una, para webapp, - tecnología() administración complejidad, - ciclo promoción excesiva, - vida innovación, -, las, - desafío, -, - blandas, - larga, - tiempo respuesta, - cambio (tmc), reparación (tmr), tmc; véase tiempo medio cambiotmr; véase tiempo medio reparacióntoma decisiones, información, , flujo, ; véase disparador uml diagrama actividad, -, - diagrama canal , clase, - comunicación, - (-)index.indd (-)index.indd // ::// :: analítico diagrama despliegue, diagrama estado, - implementación, secuencia, , - uso caso, -, , - unidades organizacionales, semánticas navegación (usn), , - usabilidad, , , , , las webapps, usn; véase unidades semánticas navegación uso hipermedios, abstracción, usuarios finales, conocedores, , utilidades, validación, , interfaz, los requerimientos, - , ( & ), - valor agregado, , -, ; véase vista datos abstractosventanas pop-, , información , , escritorio, validación ( & ), - vínculo(), navegación, , vista, - datos abstractos (vda), walkthroughs, -(), - acs para, - una, - proyectos, - del diseño , - calidad, componentes para, - interfaz , - del contenido, - las, las, , para, calidad, - , , - para diseño , - para, - - navegación para, modelado requerimientos para, - modelo configuración para, contenido para, - interacción para, - funcional para, - mercado, diseño , -, - seguridad las, ; véase programación extremaxp industrial, , - (-)index.indd (-)index.indd // ::// ::(-)index.indd (-)index.indd // ::// ::