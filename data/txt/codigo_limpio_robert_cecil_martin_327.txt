findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } private boolean shouldnotcompact() { return expected == null || actual == null || arestringsequal(); } en la función compact , this.expected y this.actual no son demasiado relevantes. sucede al cambiar el nombre de fexpected por expected . ¿por qué esta función tiene variables con los mismos nombres que las variables miembro? ¿no representan cosas diferentes?[n4]. los nombres deben ser exclusivos. string compactexpected = compactstring( expected ); string compactactual = compactstring( actual ); los negativos son más difíciles de entender que los positivos [g29]. por ello, invertimos esa instrucción if para cambiar el sentido de la condicional. public string compact(string message) { if ( canbecompacted() ) { findcommonprefix(); findcommonsuffix(); string compactexpected = compactstring(expected); string compactactual = compactstring(actual); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private boolean canbecompacted () { return expected != null && actual != null && !arestringsequal(); } el nombre de la función es extraño [n7]. aunque compacta las cadenas, puede que lo haga si canbecompacted devuelve false . al asignar el nombre compact a esta función se oculta el efecto secundario de la comprobación de errores. además, la función devuelve un mensaje con formato, no sólo las cadenas compactadas. por tanto, el nombre de la función debería ser formatcompactedcomparison . de esta forma, se lee mejor junto al argumento de la función: 328