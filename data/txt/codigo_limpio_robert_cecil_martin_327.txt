findCommonPrefix(); findCommonSuffix(); String expected = compactString(this.expected); String actual = compactString(this.actual); return Assert.format(message, expected, actual); } private boolean shouldNotCompact() { return expected == null || actual == null || areStringsEqual(); } En la función  compact ,  this.expected  y  this.actual  no son demasiado relevantes. Sucede al cambiar el nombre de  fExpected  por  expected . ¿Por qué esta función tiene variables con los mismos nombres que las variables miembro? ¿No representan cosas diferentes?[N4]. Los nombres deben ser exclusivos. String  compactExpected  = compactString( expected ); String  compactActual  = compactString( actual ); Los negativos son más difíciles de entender que los positivos [G29]. Por ello, invertimos esa instrucción  if  para cambiar el sentido de la condicional. public String compact(String message) { if ( canBeCompacted() ) { findCommonPrefix(); findCommonSuffix(); String compactExpected = compactString(expected); String compactActual = compactString(actual); return Assert.format(message, compactExpected, compactActual); } else { return Assert.format(message, expected, actual); } } private boolean  canBeCompacted () { return expected  !=  null  &&  actual  !=  null  &&  !areStringsEqual(); } El nombre de la función es extraño [N7]. Aunque compacta las cadenas, puede que lo haga si  canBeCompacted  devuelve  false . Al asignar el nombre compact  a esta función se oculta el efecto secundario de la comprobación de errores. Además, la función devuelve un mensaje con formato, no sólo las cadenas compactadas. Por tanto, el nombre de la función debería ser formatCompactedComparison . De esta forma, se lee mejor junto al argumento de la función: 328