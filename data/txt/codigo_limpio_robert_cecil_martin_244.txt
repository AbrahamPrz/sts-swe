continuos, los escritores perecen de inanición. Por otra parte, si hay escritores frecuentes y se les asigna prioridad, la producción se ve afectada. Determinar el equilibrio y evitar problemas de actualización concurrente es el objetivo de este modelo. La cena de los filósofos [84] Imagine varios filósofos sentados alrededor de una mesa redonda. A la izquierda de cada uno hay un tenedor. En el centro de la mesa, una gran fuente de espaguetis. Los filósofos pasan el tiempo pensando a menos que tengan hambre. Cuando tienen hambre, utilizan los tenedores situados a ambos lados para comer. No pueden comer a menos que tengan dos tenedores. Si el filósofo situado a la derecha o izquierda de otros ya tiene uno de los tenedores que necesita, tendrá que esperar a que termine de comer y deje los tenedores. Cuando un filósofo termina de comer, vuelve a colocar los tenedores en la mesa hasta que vuelve a tener hambre. Cambie los filósofos por procesos y los tenedores por recursos y tendrá un problema habitual en muchas aplicaciones en las que los procesos compiten por recursos. A menos que se diseñen correctamente, los sistemas que compiten de esta forma experimentan problemas de bloqueo, bloqueo mutuo, producción y degradación de la eficacia. La mayoría de problemas de concurrencia que encontrará serán alguna variante de éstos. Analice los algoritmos y cree soluciones propias para estar preparado cuando surjan problemas de concurrencia. Recomendación :  Aprenda estos algoritmos básicos y comprenda sus soluciones . Dependencias entre métodos sincronizados Las dependencias entre métodos sincronizados generan sutiles errores en el código concurrente. Java cuenta con  synchronized , que protege métodos individuales. No obstante, si hay más de un método sincronizado en la misma clase compartida, puede que su sistema sea incorrecto [85] . 245