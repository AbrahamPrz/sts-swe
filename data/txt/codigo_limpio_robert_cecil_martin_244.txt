continuos, los escritores perecen de inanición. por otra parte, si hay escritores frecuentes y se les asigna prioridad, la producción se ve afectada. determinar el equilibrio y evitar problemas de actualización concurrente es el objetivo de este modelo. la cena de los filósofos [84] imagine varios filósofos sentados alrededor de una mesa redonda. a la izquierda de cada uno hay un tenedor. en el centro de la mesa, una gran fuente de espaguetis. los filósofos pasan el tiempo pensando a menos que tengan hambre. cuando tienen hambre, utilizan los tenedores situados a ambos lados para comer. no pueden comer a menos que tengan dos tenedores. si el filósofo situado a la derecha o izquierda de otros ya tiene uno de los tenedores que necesita, tendrá que esperar a que termine de comer y deje los tenedores. cuando un filósofo termina de comer, vuelve a colocar los tenedores en la mesa hasta que vuelve a tener hambre. cambie los filósofos por procesos y los tenedores por recursos y tendrá un problema habitual en muchas aplicaciones en las que los procesos compiten por recursos. a menos que se diseñen correctamente, los sistemas que compiten de esta forma experimentan problemas de bloqueo, bloqueo mutuo, producción y degradación de la eficacia. la mayoría de problemas de concurrencia que encontrará serán alguna variante de éstos. analice los algoritmos y cree soluciones propias para estar preparado cuando surjan problemas de concurrencia. recomendación : aprenda estos algoritmos básicos y comprenda sus soluciones . dependencias entre métodos sincronizados las dependencias entre métodos sincronizados generan sutiles errores en el código concurrente. java cuenta con synchronized , que protege métodos individuales. no obstante, si hay más de un método sincronizado en la misma clase compartida, puede que su sistema sea incorrecto [85] . 245