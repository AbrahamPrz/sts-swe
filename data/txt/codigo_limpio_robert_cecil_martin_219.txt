XmlBeanFactory bf = new XmlBeanFactory(new ClassPathResource(“app.xml”, getclass())); Bank bank = (Bank) bf.getBean(“bank”); Como apenas se necesitan líneas de código Java específico de Spring, la aplicación se desconecta casi por completo de Spring y desaparecen los problemas de conexión de sistemas como EJB2. Aunque XML puede ser difícil de leer [64] , la directiva especificada en estos archivos de configuración es más sencilla que la complicada lógica de proxy y aspectos oculta a la vista y creada de forma automática. Es una arquitectura tan atractiva que sistemas como Spring modificaron totalmente el estándar EJB para la versión 3. EJB3 sigue el modelo de Spring de aspectos transversales admitidos mediante declaraciones con archivos de configuración XML y/o anotaciones de Java 5. El Listado 11-5 muestra nuestro objeto Bank reescrito en EJB3 [65] . Listado 11-5 Un EJB Bank EJB3. package com.example.banking.model; import javax.persistence; import java.util.ArrayList; import java.util.Collection; @Entity @Table(name = “BANKS”) public class Bank implements java.io.Serializable { @Id @GeneratedValue(strategy=GenerationType.AUTO) private int id; @Embeddable // Un objeto en línea en la fila DB de Bank public class Address { protected String streetAddr1; protected String streetAddr2; protected String city; protected String state; protected String zipCode; } @Embedded private Address address; @OneToMany (cascade = CascadeType.ALL, fetch = FetchType.EAGER, mappedBy=“bank”) private Collection<Account> accounts = new ArrayList<Account>(); 220