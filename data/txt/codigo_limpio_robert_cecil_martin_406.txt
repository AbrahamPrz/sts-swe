public  synchronized  void incrementValue() { ++lastIdUsed; } El número de posibles rutas de ejecución es dos para dos subprocesos y N! para el caso general. Un examen más profundo ¿Qué piensa del sorprendente resultado de dos subprocesos que invoquen el método una vez (antes de añadir  synchronized ) y obtengan el mismo resultado numérico? ¿Cómo es posible? Vayamos por partes. ¿Qué es una operación atómica? Podemos definir una operación atómica como toda operación ininterrumpible. Por ejemplo, en el siguiente código, la línea 5, donde se asigna  0  a  lastId , es atómica ya que de acuerdo al modelo de memoria de Java, la asignación a un valor de 32 bits es ininterrumpible. 01: public class Example { 02: int lastId; 03: 04: public void resetId() { 05: value = 0; 06: } 07: 08: public int getNextId() { 09: ++value; 10: } 11: } ¿Qué sucede si cambiamos el tipo de  lastId  de  int  a  long ? ¿Sigue siendo atómica la línea 5? No de acuerdo a la especificación de la MVJ. Podría ser atómica en un procesador concreto, pero según la especificación de la MVJ, la asignación a un valor de 64 bits requiere dos asignaciones de 32 bits. Esto significa que entre la primera y la segunda podría irrumpir otro subproceso y cambiar uno de los valores. ¿Y qué sucede con el operador de preincremento,  ++ , de la línea 9? Este operador se puede interrumpir, de modo que no es atómico. Para entenderlo, repasemos el código de  bytes  de ambos métodos. Antes de continuar, hay tres definiciones importantes: 407