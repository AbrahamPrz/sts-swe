} public string toshortstring() { return dateformatsymbols.getshortmonths()[index – 1]; } el siguiente método es stringtomonthcode (líneas 428-472). lo cambio de nombre, lo paso a la enumeración month y lo simplifico [n1], [n3], [c3], [g14], [g12]. public static month parse(string s) { s = s.trim(); for (month m : month.values()) if (m.matches(s)) return m; try { return make(integer.parseint(s)); } catch (numberformatexception e) {} throw new illegalargumentexception(“invalid month ” + s); } private boolean matches(string a) { return s.equalsignorecase(tostring()) || s.equalsignorecase(toshortstring()); } el método isleapyear (líneas 495-517) se puede modificar para que sea más expresivo [g16]. public static boolean isleapyear(int year) { boolean fourth = year % 4 == 0; boolean hundredth = year % 100 == 0; boolean fourhundredth = year % 400 == 0; return fourth && (!hundredth || fourhundredth); } la siguiente función, leapyearcount (líneas 519-536) no pertenece realmente a daydate . nadie la invoca, excepto los dos métodos de spreadsheetdate , de modo que la desplazo hacia abajo [g6]. la función lastdayofmonth (líneas 538-560) usa la matriz last_day_of_month , que en realidad pertenece a la enumeración month [g17], por lo que la cambio de ubicación. también simplifico la función y aumento su expresividad [g16]. public static int lastdayofmonth(month month, int year) { if (month == month.february && isleapyear(year)) return month.lastday() + 1; else 351