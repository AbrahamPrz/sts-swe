} public String toShortString() { return dateFormatSymbols.getShortMonths()[index – 1]; } El siguiente método es  stringToMonthCode  (líneas  428-472).  Lo cambio de nombre, lo paso a la enumeración  Month  y lo simplifico [N1], [N3], [C3], [G14], [G12]. public static Month parse(String s) { s = s.trim(); for (Month m : Month.values()) if (m.matches(s)) return m; try { return make(Integer.parseInt(s)); } catch (NumberFormatException e) {} throw new IllegalArgumentException(“Invalid month ” + s); } private boolean matches(String a) { return s.equalsIgnoreCase(toString()) || s.equalsIgnoreCase(toShortString()); } El método  isLeapYear  (líneas  495-517)  se puede modificar para que sea más expresivo [G16]. public static boolean isLeapYear(int year) { boolean fourth = year % 4 == 0; boolean hundredth = year % 100 == 0; boolean fourHundredth = year % 400 == 0; return fourth && (!hundredth || fourHundredth); } La siguiente función,  leapYearCount  (líneas  519-536)  no pertenece realmente a  DayDate . Nadie la invoca, excepto los dos métodos de SpreadsheetDate , de modo que la desplazo hacia abajo [G6]. La función  lastDayOfMonth  (líneas  538-560)  usa la matriz LAST_DAY_OF_MONTH , que en realidad pertenece a la enumeración  Month [G17], por lo que la cambio de ubicación. También simplifico la función y aumento su expresividad [G16]. public static int lastDayOfMonth(Month month, int year) { if (month == Month.FEBRUARY && isLeapYear(year)) return month.lastDay() + 1; else 351