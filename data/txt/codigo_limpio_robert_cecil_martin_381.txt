} Este fragmento de código realiza tres operaciones. Itera por todos los empleados, comprueba si cada uno debe recibir su paga y después paga al empleado. Se podría reescribir de esta forma: public void pay() { for (Employee e : employees) payifNecessary(e); } private void payifNecessary(Employee e) { if (e.isPayday()) calculateAndDeliverPay(e); } private void calculateAndDeliverPay(Employee e) { Money pay = e.calculatePay(); e.deliverPay(pay); } Cada una de estas funciones hace una sola cosa (véase el capítulo 3). G31: Conexiones temporales ocultas Las conexiones temporales suelen ser necesarias pero no debe ocultar la conexión. Estructure los argumentos de sus funciones de modo que el orden de invocación sea evidente. Fíjese en lo siguiente: public class MoogDiver { Gradient gradient; List<Spline> splines; public void dive(String reason) { saturateGradient(); reticulateSplines(); diveForMoog(reason); } … } El orden de las tres funciones es importante. Debe saturar el degradado antes de poder entrelazar las tiras, para después continuar. Desafortunadamente, el código no aplica esta conexión temporal. Otro programador podría invocar  reticulateSplines  antes de saturateGradient , lo que generaría  UnsaturatedGradientException . Una solución más acertada sería: 382