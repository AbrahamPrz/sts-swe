if (expected.charAt(prefix Index ) != actual.charAt(prefix Index )) break; } return prefixIndex; } private  int  findCommonSuffix() { int expectedSuffix = expected.length() - 1; int actualSuffix = actual.length() - 1; for (; actualSuffix >= prefix Index  && expectedSuffix >= prefixIndex; actualSuffix--, expectedSuffix--) { if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix)) break; } return  expected.length() - expectedSuffix; } También debemos cambiar los nombres de las variables miembro para que sean más preciosas [N1], ya que en el fondo son índices. Al examinar  findCommonSuffix  vemos una conexión temporal oculta [G31]; depende de que  prefixIndex  se calcule por  findCommonPrefix . Si estas dos funcione se invocan de forma desordenada, la sesión de depuración posterior sería complicada. Por ello, para mostrar esta combinación temporal, haremos que  findCommonSuffix  acepte  prefixIndex  como argumento. private void compactExpectedAndActual() { prefixIndex = findCommonPrefix(); suffixIndex = findCommonSuffix( prefixIndex ); compactExpected = compactString(expected); compactActual = compactString(actual); } private int findCommonSuffix( int prefixIndex ) { int expectedSuffix = expected.length() - 1; int actualSuffix = actual.length() - 1; for (; actualSuffix >= prefixIndex && expectedSuffix >= prefixIndex; actualSuffix--, expectedSuffix--) { if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix)) break; } return expected.length() - expectedSuffix; } No me convence del todo. El hecho de pasar  prefixIndex  como argumento es un tanto arbitrario [G32]. Permite establecer el orden pero no explica la necesidad del mismo. Otro programador podría deshacer esta operación ya que no se indica en ningún momento para qué sirve el parámetro. Adoptemos un enfoque diferente. 330