if (expected.charat(prefix index ) != actual.charat(prefix index )) break; } return prefixindex; } private int findcommonsuffix() { int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefix index && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix--) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } también debemos cambiar los nombres de las variables miembro para que sean más preciosas [n1], ya que en el fondo son índices. al examinar findcommonsuffix vemos una conexión temporal oculta [g31]; depende de que prefixindex se calcule por findcommonprefix . si estas dos funcione se invocan de forma desordenada, la sesión de depuración posterior sería complicada. por ello, para mostrar esta combinación temporal, haremos que findcommonsuffix acepte prefixindex como argumento. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix( prefixindex ); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonsuffix( int prefixindex ) { int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefixindex && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix--) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } no me convence del todo. el hecho de pasar prefixindex como argumento es un tanto arbitrario [g32]. permite establecer el orden pero no explica la necesidad del mismo. otro programador podría deshacer esta operación ya que no se indica en ningún momento para qué sirve el parámetro. adoptemos un enfoque diferente. 330