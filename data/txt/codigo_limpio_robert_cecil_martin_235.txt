“Los objetos son abstracciones de procesamiento. Los subprocesos son abstracciones de programaciones”. —James O. Coplien [74] La creación de programas concurrentes limpios es complicada, muy complicada. Es mucho más sencillo crear código que se ejecute en un mismo proceso. También es fácil crear código de subprocesamiento múltiple que parezca correcto en la superficie pero que esté dañado a niveles más profundos. Este código funciona correctamente hasta que el sistema se somete a determinadas presiones. En este capítulo analizaremos la necesidad de la programación concurrente y sus dificultades. Tras ello, presentaremos diversas recomendaciones para superar dichas dificultades y crear código concurrente limpio. Por último, finalizaremos con los problemas relacionados con la prueba de código concurrente. La concurrencia limpia es un tema complejo, merecedor de un libro propio. Aquí, intentaremos ofrecer una visión general, que después ampliaremos en el apéndice A. Si simplemente tiene curiosidad por el tema, le bastará con este capítulo. Si necesita entender la concurrencia a un nivel más profundo, consulte también el apéndice. ¿Por qué concurrencia? La concurrencia es una estrategia de desvinculación. Nos permite desvincular lo que se hace de dónde se hace. En aplicación de un solo proceso, el qué y el cuándo están tan firmemente vinculados que el estado de la aplicación se puede determinar analizando la huella de la pila. Un programador que depure este tipo de sistemas puede definir un punto de interrupción (o varios) y saber el estado de la aplicación en función del punto al que se llegue. La desvinculación del qué del dónde puede mejorar considerablemente el rendimiento y la estructura de una aplicación. Desde un punto de vista estructural, la aplicación parece una serie de equipos colaboradores y no un gran bucle principal. Esto puede hacer que el sistema sea más fácil de 236