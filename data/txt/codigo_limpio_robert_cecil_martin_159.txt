componentes o subsistemas que utilizamos. De algún modo debemos integrar este código externo con el nuestro. En este capítulo veremos prácticas y técnicas para definir con claridad los límites de nuestro  software . Utilizar código de terceros Existe una tensión natural entre el proveedor de una interfaz y el usuario de la misma. Los proveedores de paquetes y estructuras de terceros abogan por una capacidad de aplicación global para poder trabajar en diversos entornos y atraer a un público más amplio. Los usuarios, por su parte, desean una interfaz centrada en sus necesidades concretas. Esta tensión puede provocar problemas en los límites de nuestros sistemas. Analicemos  java.util.Map  como ejemplo. Como puede apreciar en la siguiente lista.  Map  tiene una amplia interfaz con numerosas prestaciones. Esta potencia y flexibilidad es muy útil, pero también puede ser un problema. Por ejemplo, nuestra aplicación puede generar un  Map  y compartirlo. Nuestra intención puede que sea que ninguno de los receptores del mapa borre sus elementos. Pero en la parte superior de la lista encontramos el método clear() . Cualquier usuario del mapa puede borrarlo. O puede que nuestra convención de diseño determine que sólo se puedan almacenar objetos concretos en el mapa, pero  Map  no limita de forma fiable los tipos de objetos que admite. Cualquier usuario puede añadir elementos de cualquier tipo a cualquier mapa. clear() void - Map containsKey (Object key) boolean - Map containsValue (Object value) boolean - Map entrySet() Set - Map equals(Object o) boolean - Map get(Object key) Object - Map getClass() Class<? extends Object> - Object hashCode() int - Map isEmpty() boolean - Map keySet() Set - Map notify() void - Object 160