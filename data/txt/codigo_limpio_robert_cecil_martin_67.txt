es complicado usar una instrucción switch de tamaño reducido [15] . aunque sólo tenga dos casos, es mayor de lo que un bloque o función debería ser. también es complicado crear una instrucción switch que haga una sola cosa. por su naturaleza, las instrucciones switch siempre hacen n cosas. desafortunadamente, no siempre podemos evitar las instrucciones switch pero podemos asegurarnos de incluirlas en una clase de nivel inferior y de no repetirlas. para ello, evidentemente, recurrimos al polimorfismo. fíjese en el listado 3-4. muestra una de las operaciones que pueden depender del tipo de empleado. listado 3-4 payroll.java. public money calculatepay(employee e) throws invalidemployeetype ( switch (e.type) { case commissioned: return calculatecommissionedpay(e); case hourly: return calculatehourlypay(e); case salaried: return calculatesalariedpay(e); default: throw new invalidemployeetype(e.type); } } esta función tiene varios problemas. por un lado, es de gran tamaño y cuando se añadan nuevos tipos de empleado, aumentará más. por otra parte, hace más de una cosa. también incumple el principio de responsabilidad única ( single responsibility principie o srp) [16] ya que hay más de un motivo para cambiarla. además, incumple el principio de abierto/cerrado ( open closed principle u ocp) [17] , ya que debe cambiar cuando se añadan nuevos tipos, pero posiblemente el peor de los problemas es que hay un número ilimitado de funciones que tienen la misma estructura. por ejemplo, podríamos tener: ispayday(employee e, date date), o 68