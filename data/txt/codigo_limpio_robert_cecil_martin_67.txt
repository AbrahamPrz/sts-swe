Es complicado usar una instrucción  switch  de tamaño reducido [15] . Aunque sólo tenga dos casos, es mayor de lo que un bloque o función debería ser. También es complicado crear una instrucción  switch  que haga una sola cosa. Por su naturaleza, las instrucciones  switch  siempre hacen N cosas. Desafortunadamente, no siempre podemos evitar las instrucciones  switch pero podemos asegurarnos de incluirlas en una clase de nivel inferior y de no repetirlas. Para ello, evidentemente, recurrimos al polimorfismo. Fíjese en el Listado 3-4. Muestra una de las operaciones que pueden depender del tipo de empleado. Listado 3-4 Payroll.java. public Money calculatePay(Employee e) throws InvalidEmployeeType ( switch (e.type) { case COMMISSIONED: return calculateCommissionedPay(e); case HOURLY: return calculateHourlyPay(e); case SALARIED: return calculateSalariedPay(e); default: throw new InvalidEmployeeType(e.type); } } Esta función tiene varios problemas. Por un lado, es de gran tamaño y cuando se añadan nuevos tipos de empleado, aumentará más. Por otra parte, hace más de una cosa. También incumple el Principio de responsabilidad única ( Single Responsibility Principie  o SRP) [16]  ya que hay más de un motivo para cambiarla. Además, incumple el Principio de abierto/cerrado ( Open Closed Principle  u OCP) [17] , ya que debe cambiar cuando se añadan nuevos tipos, pero posiblemente el peor de los problemas es que hay un número ilimitado de funciones que tienen la misma estructura. Por ejemplo, podríamos tener: isPayday(Employee e, Date date), o 68