26-27 Esperar a que terminen los dos subprocesos antes de comprobar los resultados. 29 Registrar el valor final. 31-32 ¿Es diferente  endingId  a lo que esperábamos? En caso afirmativo, se finaliza la prueba; hemos demostrado que el código es incorrecto. En caso negativo, volver a intentarlo. 35 Si hemos llegado hasta aquí, la prueba no ha podido demostrar que el código de producción era incorrecto en una cantidad de tiempo razonable; el código ha fallado. O no es incorrecto o no hemos realizado suficientes iteraciones para que se produzca la condición de fallo. Esta prueba establece las condiciones de un problema de actualización concurrente. Sin embargo, el problema es tan infrecuente que la mayoría de las veces la prueba no lo detecta. En realidad, para detectar el problema debemos establecer el número de iteraciones en más de un millón. Incluso con esa cantidad, en diez ejecuciones de un bucle de  1 000 000,  el problema sólo apareció una vez, lo que significa que debemos aumentar las iteraciones para obtener fallos fiables. ¿Cuánto estamos dispuestos a esperar? Aunque ajustáramos la prueba para obtener fallos fiables en un equipo, seguramente tendríamos que ajustarla con otros valores para ilustrar el fallo en otro equipo, sistema operativo o versión de la MVJ. Y es un problema  sencillo . Si no podemos demostrarlo, ¿qué pasará cuando detectemos problemas realmente complejos? ¿Qué enfoques debemos adoptar para demostrar este sencillo fallo? Y, sobre todo, ¿cómo podemos crear pruebas que demuestren fallos en un código más complejo? ¿Cómo podremos saber si el código tiene fallos cuando ni siquiera sabemos dónde buscar? Veamos algunas sugerencias: Pruebas Monte Carlo: Crear pruebas flexibles que se puedan ajustar. Después, ejecutarlas repetidamente, por ejemplo, en un servidor de prueba, y cambiar los valores de ajuste aleatoriamente. Si las pruebas 430