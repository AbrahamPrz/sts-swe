WikiPageProperty symLinks = properties.set(SymbolicPage.PROPERTY_NAME); symLinks.set(“SymPage”, “PageTwo”); pageOne.commit(data); request.setResource(“root”); request.addInput(“type”, “pages”); Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse( new FitNesseContext(root), request); String xml = response.getContent(); assertEquals(“text/xml”, response.getContentType()); assertSubString(“<name>PageOne</name>”, xml); assertSubString(“<name>PageTwo</name>”, xml); assertSubString(“<name>ChildOne</name>”, xml); assertNotSubString(“SymPage”, xml); } public void testGetDataAsHtml() throws Exception { crawler.addPage(root, PathParser.parse(“TestPageOne”), “test page”); request.setResource(“TestPageOne”); request.addInput(“type”, “data”); Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse( new FitNesseContext(root), request); String xml = response.getContent(); assertEquals(“text/xml”, response.getContentType()); assertSubString(“test page”, xml); assertSubString(“<Test”, xml); } Fíjese en las invocaciones de  PathParser . Transforman cadenas en instancias de  PagePath  usadas por las arañas. Esta transformación es totalmente irrelevante para la prueba y únicamente complica su cometido. Los detalles circundantes a la creación del respondedor y la obtención y conversión de la respuesta también sobran. También la forma de crear la URL de solicitud a partir de un recurso y un argumento (contribuí a crear este código, por lo que tengo todo el derecho a criticarlo). Al final, el código no se ha diseñado de forma legible. El lector se ve rodeado de miles de detalles que debe comprender antes de que las pruebas tengan sentido. Fíjese ahora en las pruebas mejoradas del Listado 9-2. Hacen exactamente lo mismo, pero se han refactorizado de forma más clara y 175