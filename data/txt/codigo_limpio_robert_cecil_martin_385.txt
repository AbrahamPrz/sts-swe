La separación de niveles de abstracción es una de las tareas más importantes de la refactorización, y también una de las más complejas. Por ejemplo, fíjese en el siguiente código. Fue mi primer intento de separar los niveles de abstracción del método  HruleWidget.render . public String render() throws Exception { HtmlTag hr = new HtmlTag(“hr”); if (size > 0) { hr.addAttribute (“size”, “”+(size+1)); } return hr.html(); } Mi objetivo, en esta fase, es crear la separación necesaria y conseguir superar las pruebas. El objetivo lo alcancé fácilmente pero el resultado fue una función con niveles de abstracción mezclados. En este caso, fueron obra de la etiqueta HR y de la interpretación y el formato de la variable size. Esto indica que al dividir una función en líneas de abstracción, suelen aparecer nuevas líneas de abstracción ocultas por la estructura anterior. G35: Mantener los datos configurables en los niveles superiores Si tiene una constante como un valor predeterminado o de configuración que se conoce y se espera en un nivel superior de abstracción, no debe sepultarla en una función de nivel inferior. Muéstrela como argumento para esa función de nivel inferior invocado desde la función de nivel superior. Fíjese en este ejemplo de FitNesse: public static void main(String[] args) throws Exception { Arguments arguments = parseCommandLine(args); … } public class Arguments { public static final String DEFAULT_PATH = “.”; public static final String DEFAULT_ROOT = “FitNesseRoot”; public static final int DEFAULT_PORT = 80; public static final int DEFAULT_VERSION_DAYS = 14; … } 386