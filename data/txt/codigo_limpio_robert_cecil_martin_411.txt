Soluciones no bloqueantes La MV Java 5 aprovecha el diseño de los procesadores modernos que admiten actualizaciones fiables y no bloqueantes. Imagine una clase que usa sincronización (y por tanto bloqueo) para proporcionar la actualización compatible con subprocesos de un valor: public class ObjectWithValue { private int value; public void synchronized incrementValue() { ++value; } public int getValue() { return value; } } Java 5 dispone de varias clases nuevas para este tipo de situaciones, como por ejemplo  AtomicBoolean ,  AtomicInteger  y  AtomicReference . Podemos modificar el código anterior para usar un enfoque no bloqueante: public class ObjectWithValue { private AtomicInteger value = new AtomicInteger(0); public void incrementValue() { value.incrementAndGet(); } public int getValue() { return value.get(); } } Aunque use un objeto en lugar de una primitiva y envíe mensajes como incrementAndGet()  en lugar de  ++ , el rendimiento de esta clase supera en la mayoría de los casos al de la versión anterior. En algunos casos será ligeramente más rápido pero los casos en los que es más lento son prácticamente inexistentes. ¿Cómo es posible? Los procesadores modernos disponen de una operación denominada CAS (Compare and Swap, Comparar e intercambiar). Es una operación similar al bloqueo optimista de una base de datos, mientras que la versión sincronizada es similar al bloqueo pesimista. La palabra clave  synchronized  siempre adquiere un bloqueo, incluso cuando un segundo subproceso no intenta actualizar el mismo valor. Aunque el rendimiento de los bloqueos intrínsecos ha mejorado con respecto a versiones anteriores, sigue siendo muy costoso. La versión no bloqueante asume inicialmente que varios subprocesos no 412