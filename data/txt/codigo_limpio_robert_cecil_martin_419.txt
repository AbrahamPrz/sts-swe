if(iterator.hasNext()) return iterator.next(); return null; } } Mejor todavía, usar colecciones compatibles con subprocesos con interfaces ampliadas. Aumentar la producción Imagine que desea leer el contenido de una serie de páginas de una lista de URL en la red. Al leer cada página, la analizamos para acumular estadísticas. Después de leer todas, imprimimos un informe de resumen. La siguiente clase devuelve el contenido de una página, dada una URL. public class PageReader { //… public String getPageFor(String url) { HttpMethod method = new GetMethod(url); try { httpClient.executeMethod(method); String response = method.getResponseBodyAsString(); return response; } catch (Exception e) { handle(e); } finally { method.releaseConnection(); } } } La siguiente clase es el iterador que proporciona el contenido de las páginas en función de un iterador de URL: public class PageIterator { private PageReader reader; private URLIterator urls; public PageIterator(PageReader reader, URLIterator urls) { this.urls = urls; this.reader = reader; } public synchronized String getNextPageOrNull() { if (urls.hasNext()) getPageFor(urls.next()); 420