return  am != null &&  am.getBoolean(); } Argumentos de cadena La inclusión de los argumentos  String  fue similar a la de los argumentos boolean . Tuve que cambiar  HashMap  y conseguir que funcionaran  parse ,  set y  get . No deberían producirse sorpresas posteriores a excepción de que la implementación completa se incluía en la clase  ArgumentMarshaller  en lugar de distribuirla en variantes. private Map<Character,  ArgumentMarshaler > stringArgs = new HashMap<Character,  ArgumentMarshaler >(); … private void parseStringSchemaElement(char elementId) { stringArgs.put(elementId, new StringArgumentMarshaler()); } … private void setStringArg(char argChar) throws ArgsException { currentArgument++; try { stringArgs. get (argChar). setString (args[currentArgument]); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } … public String getString (char arg) { Args.ArgumentMarshaler am =  stringArgs.get(arg); return  am == null ? “”  : am.getString(); } … private class ArgumentMarshaler { private boolean booleanValue = false; private String stringValue; public void setBoolean(boolean value) { booleanValue = value; } public boolean getBoolean() { return booleanValue; } public void setString(String s) { 279