hace que  hasNext()  devuelva  false . Se vuelve a iniciar el subproceso 1, pensando que  hasNext()  sigue siendo true , y después invoca  next() . Aunque los métodos concretos están sincronizados, el cliente usa dos métodos. Es un problema real y un ejemplo que puede surgir en código concurrente. En este caso concreto, el problema es especialmente sutil ya que la única ocasión en la que produce un fallo es durante la iteración final del iterador. Si los subprocesos se dividen de forma correcta, puede que uno supere el final del iterador. Es el tipo de error que surge en un sistema que lleva tiempo en producción, y es difícil de detectar. Tiene tres opciones: Tolerar el fallo. Solucionar el problema cambiando el cliente: bloqueo basado en el cliente. Solucionar el problema cambiando el servidor, lo que también provoca que cambie el cliente: bloqueo basado en el servidor. Tolerar el fallo En ocasiones, los sistemas se configuran para que un fallo no produzca daños. Por ejemplo, el cliente anterior podía capturar la excepción y limpiarla, aunque sería un tanto torpe. Es como limpiar fugas de memoria reiniciando a medianoche. Bloqueo basado en el cliente Para que  IntegerIterator  funcione correctamente con varios subprocesos, cambie el cliente (y los demás) como se indica a continuación: IntegerIterator iterator = new IntegerIterator(); while (true) { int nextValue; synchronized (iterator) { if (!iterator.hasNext()) break; nextValue = iterator.next(); 416