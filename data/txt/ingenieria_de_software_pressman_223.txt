192 parte dos modelado se ha dicho que “la modularidad es el único atributo del software que permite que un pro- grama sea manejable en lo intelectual” [mye78]. el software monolítico (un programa grande compuesto de un solo módulo) no es fácil de entender para un ingeniero de software. el número de trayectorias de control, alcance de referencia, número de variables y complejidad general haría que comprenderlo fuera casi imposible. en función de las circunstancias, el diseño debe descomponerse en muchos módulos con la esperanza de que sea más fácil entenderlos y, en consecuencia, reducir el costo requerido para elaborar el software. según el punto de vista de la división de problemas, sería posible concluir que si el software se dividiera en forma indefinida, el esfuerzo requerido para desarrollarlo ¡sería despreciable por pequeño! desafortunadamente, hay otras fuerzas que entran en juego y que hacen que esta conclusión sea (tristemente) inválida. de acuerdo con la figura 8.2, el esfuerzo (costo) de desa-rrollar un módulo individual de software disminuye conforme aumenta el número total de mó-dulos. dado el mismo conjunto de requerimientos, tener más módulos significa tamaños indi-viduales más pequeños. sin embargo, a medida que se incrementa el número de módulos, el esfuerzo (costo) asociado con su integración también aumenta. estas características llevan a una curva de costo total como la que se muestra en la figura. existe un número, m, de módulos que arrojarían el mínimo costo de desarrollo, pero no se dispone de las herramientas necesarias para predecir m con exactitud. las curvas que aparecen en la figura 8.2 constituyen una guía útil al considerar la modulari- dad. deben hacerse módulos, pero con cuidado para permanecer en la cercanía de m. debe evitarse hacer pocos o muchos módulos. pero, ¿cómo saber cuál es la cercanía de m? ¿cuán modular debe hacerse el software? las respuestas a estas preguntas requieren la comprensión de otros conceptos de diseño que se analizan más adelante en este capítulo. debe hacerse un diseño (y el programa resultante) con módulos, de manera que el desarrollo pueda planearse con más facilidad, que sea posible definir y desarrollar los incrementos del software, que los cambios se realicen con más facilidad, que las pruebas y la depuración se efectúen con mayor eficiencia y que el mantenimiento a largo plazo se lleve a cabo sin efectos colaterales de importancia. 8.3.6 ocultamiento de información el concepto de modularidad lleva a una pregunta fundamental: “¿cómo descomponer una so-lución de software para obtener el mejor conjunto de módulos?” el principio del ocultamiento de información sugiere que los módulos se “caractericen por decisiones de diseño que se ocul-ten (cada una) de las demás”. en otras palabras, deben especificarse y diseñarse módulos, de forma que la información (algoritmos y datos) contenida en un módulo sea inaccesible para los que no necesiten de ella.mregión de costo mínimo número de móduloscosto del esfuerzo costo por módulocosto de integracióncosto total del softwarefigura 8.2 modularidad y costo del software ¿cuál es el número correcto de módulos para un sistema dado?? punto clave el objetivo de ocultar la información es esconder los detalles de las estructuras de datos y el procesamiento tras una interfaz de módulo. no es necesario que los usuarios de éste los conozcan. 08pressman(183-205).indd  19208pressman(183-205).indd  192 14/1/10  14:31:0914/1/10  14:31:09