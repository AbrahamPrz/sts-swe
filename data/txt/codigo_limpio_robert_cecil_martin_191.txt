if (topOfStack == 0) throw new PoppedWhenEmpty(); int element = elements.get(--topOfStack); elements.remove(topOfStack); return element; } } La estrategia de reducir el tamaño de las funciones y de las listas de parámetros suele provocar la proliferación de variables de instancia usadas por un subconjunto de los métodos. Si esto sucede, siempre existe al menos una clase que intenta huir de la clase de mayor tamaño. Debe intentar separar las variables y métodos en dos o más clases para que las nuevas sean más consistentes. Mantener resultados consistentes en muchas clases de tamaño reducido La división de grandes funciones en otras más pequeñas aumenta la proliferación de clases. Imagine una gran función con numerosas variables declaradas. Imagine que desea extraer una pequeña parte de esa función en otra independiente. Sin embargo, el código que extrae usa cuatro de las variables declaradas en la función. ¿Debe pasar las cuatro variables como argumentos a la nueva función? En absoluto. Si ascendemos estas cuatro variables a variables de instancia de la clase, podremos extraer el código sin pasar las variables. Resultaría más sencillo dividir la función en pequeños fragmentos. Desafortunadamente, eso significaría que nuestras clases perderían cohesión ya que acumularían más y más variables de instancia que sólo existen para que otras funciones las compartan. Pero un momento. Si apenas existen funciones que compartan determinadas variables, ¿no son entonces una clase con derecho propio? Por supuesto. Cuando las clases pierdan cohesión, divídalas. Por tanto, dividir una gran función en otras más reducidas también nos permite dividir varias clases más reducidas. De este modo mejora la organización del programa y su estructura resulta más transparente. Como ejemplo, usaremos un ejemplo obtenido del libro de Knuth  Literate 192