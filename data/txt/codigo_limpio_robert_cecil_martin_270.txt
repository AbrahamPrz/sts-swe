} else unexpectedArguments.add(argChar); } private void setBooleanArg(char argChar, boolean value) { booleanArgs.put(argChar, value); } private boolean isBoolean(char argChar) { return booleanArgs.containsKey(argChar); } public int cardinality() { return numberOfArguments; } public String usage() { if (schema.length() > 0) return “-[”+schema+“]”; else return “”; } public String errorMessage() { if (unexpectedArguments.size() > 0) { return unexpectedArgumentMessage(); } else return “”; } private String unexpectedArgumentMessage() { StringBuffer message = new StringBuffer(“Argument(s) -”); for (char c : unexpectedArguments) { message.append(c); } message.append(“ unexpected.”); return message.toString(); } public boolean getBoolean(char arg) { return booleanArgs.get(arg); } } Aunque hay motivos para quejarse del código, no es tan malo. Es compacto y sencillo, y fácil de entender. Sin embargo, en este código se aprecia la semilla del desastre posterior y resulta evidente porqué. La versión posterior sólo tiene dos tipos de argumentos más que ésta: String  e  integer . La inclusión de sólo dos tipos más tiene un tremendo impacto negativo en el código. Lo convierte de algo que sería razonablemente 271