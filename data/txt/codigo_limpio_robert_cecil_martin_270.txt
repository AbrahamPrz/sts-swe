} else unexpectedarguments.add(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return numberofarguments; } public string usage() { if (schema.length() > 0) return “-[”+schema+“]”; else return “”; } public string errormessage() { if (unexpectedarguments.size() > 0) { return unexpectedargumentmessage(); } else return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return booleanargs.get(arg); } } aunque hay motivos para quejarse del código, no es tan malo. es compacto y sencillo, y fácil de entender. sin embargo, en este código se aprecia la semilla del desastre posterior y resulta evidente porqué. la versión posterior sólo tiene dos tipos de argumentos más que ésta: string e integer . la inclusión de sólo dos tipos más tiene un tremendo impacto negativo en el código. lo convierte de algo que sería razonablemente 271