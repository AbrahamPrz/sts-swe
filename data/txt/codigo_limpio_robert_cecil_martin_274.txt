public String errorMessage() throws Exception { if (unexpectedArguments.size() > 0) { return unexpectedArgumentMessage(); } else switch (errorCode) { case MISSING_STRING: return String.format (“Could not find string parameter for -%c.”, errorArgument); case OK: throw new Exception(“TILT: Should not get here.”); } return “”; } private String unexpectedArgumentMessage() { StringBuffer message = new StringBuffer(“Argument(s) -”); for (char c : unexpectedArguments) { message.append(c); } message.append(“ unexpected.”); return message.toString(); } public boolean getBoolean(char arg) { return falseIfNull(booleanArgs.get(arg)); } private boolean falseIfNull(Boolean b) { return b == null ? false : b; } public String getString(char arg) { return blankIfNull(stringArgs.get(arg)); } private String blankIfNull(String s) { return s == null ? “” : s; } public boolean has(char arg) { return argsFound.contains(arg); } public boolean isValid() { return valid; } } Comprobará que empieza a desbocarse. No es terrible pero el desastre se está gestando. Basta con incluir el tipo de argumento  integer  para que resulte fatídico. 275