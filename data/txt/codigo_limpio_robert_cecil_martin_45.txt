public static void copychars(char a1[], char a2[]) { for (int i = 0; i < a1.length; i++) { a2[i] = a1[i]; } } esta función se lee mejor cuando se usa source y destination como nombres de argumentos. las palabras adicionales son otra distinción sin sentido. imagine que tiene la clase product. si tiene otra clase con el nombre productinfo o productdata , habrá creado nombres distintos, pero con el mismo significado. info y data son palabras adicionales, como a , an y the . no es incorrecto usar prefijos como a y the mientras la distinción tenga sentido. imagine que usa a para variables locales y for para argumentos de funciones [8] . el problema aparece cuando decide invocar la variable thezork porque ya tiene otra variable con el nombre zork . las palabras adicionales son redundantes. la palabra variable no debe incluirse nunca en el nombre de una variable. la palabra table no debe incluirse nunca en el nombre de una tabla. ¿es mejor namestring que name ? ¿podría ser name un número de coma flotante? en caso afirmativo, incumple la regla anterior sobre desinformación. imagine que encuentra una clase con el nombre customer y otra con el nombre customerobject . ¿cuál sería la distinción? ¿cuál representa mejor el historial de pagos de un cliente? existe una aplicación que lo ilustra. hemos cambiado los nombres para proteger al culpable. veamos el error exacto: getactiveaccount(); getactiveaccounts(); getactiveaccountinfo(); ¿cómo saben los programadores de este proyecto qué función deben invocar? en ausencia de convenciones concretas, la variable moneyamount no se distingue de money , customerinfo no se distingue de customer , accountdata no se distingue de account y themessage no se distingue de message . debe diferenciar los nombres de forma que el lector aprecie las diferencias. 46