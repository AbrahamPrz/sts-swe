public int getInt(char arg) { Args.ArgumentMarshaler am =  marshalers .get(arg); try { return am == null ? 0 : (Integer) am.get(); } catch (Exception e) { return 0; } } … public class Args { … private Map<Character, ArgumentMarshaler> stringArgs = new HashMap<Character, ArgumentMarshaler>(); private Map<Character, ArgumentMarshaler> intArgs = new HashMap<Character, ArgumentMarshaler>(); private Map<Character, ArgumentMarshaler> marshalers = new HashMap<Character, ArgumentMarshaler>(); … Seguidamente, dispuse en línea los tres métodos  parse  ya que no servían para mucho: private void parseSchemaElement(String element) throws ParseException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (isBooleanSchemaElement(elementTail)) marshalers.put(elementId, new BooleanArgumentMarshaler()); else if (isStringSchemaElement(elementTail)) marshalers.put(elementId, new StringArgumentMarshaler()); else if (isIntegerSchemaElement(elementTail)) { marshalers.put(elementId, new IntegerArgumentMarshaler()); } else { throw new ParseException(String.format( “Argument: %c has invalid format: %s.”, elementId, elementTail), 0); } } Es el momento de ver la estructura completa. El Listado 14-12 muestra la clase  Args  actual. Listado 14-12 Args.java (tras la primera refactorización) package com.objectmentor.utilities.getopts; import java.text.ParseException; import java.util.*; public class Args { private String schema; 291