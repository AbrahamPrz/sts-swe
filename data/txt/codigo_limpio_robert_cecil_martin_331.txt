return actual.length() - suffixlength < prefixlength || expected.length() - suffixlength < prefixlength; } mucho mejor. muestra que suffixindex es en realidad la longitud del sufijo y que su nombre no es correcto. lo mismo sucede con prefixindex , aunque en ese caso índice y longitud son sinónimos. incluso así, es más coherente usar length . el problema es que la variable suffixindex no es de base cero, sino de base 1 y no es una verdadera longitud. éste es el motivo de la abundancia de +1 en computecommonsuffix [g33]. lo corregimos. en el listado 15-4 puede ver el resultado. listado 15-4 comparisoncompactor.java (versión intermedia). public class comparisoncompactor { … private int suffixlength ; … private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = 0; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } } private char charfromend(string s, int i) { return s.charat(s.length() - i - 1 ); } private boolean suffixoverlapsprefix(int suffixlength) { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } … private string compactstring(string source) { string result = delta_start + source.substring(prefixlength, source.length() - suffixlength ) + delta_end; if (prefixlength > 0) result = computecommonprefix() + result; if ( suffixlength > 0) 332