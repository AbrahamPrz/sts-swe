return actual.length() - suffixLength < prefixLength || expected.length() - suffixLength < prefixLength; } Mucho mejor. Muestra que  suffixIndex  es en realidad la longitud del sufijo y que su nombre no es correcto. Lo mismo sucede con  prefixIndex , aunque en ese caso índice y longitud son sinónimos. Incluso así, es más coherente usar  length . El problema es que la variable  suffixIndex  no es de base cero, sino de base  1  y no es una verdadera longitud. Éste es el motivo de la abundancia de  +1  en  computeCommonSuffix  [G33]. Lo corregimos. En el Listado 15-4 puede ver el resultado. Listado 15-4 ComparisonCompactor.java (versión intermedia). public class ComparisonCompactor { … private int  suffixLength ; … private void findCommonPrefixAndSuffix() { findCommonPrefix(); suffixLength = 0; for (; !suffixOverlapsPrefix(suffixLength); suffixLength++) { if (charFromEnd(expected, suffixLength) != charFromEnd(actual, suffixLength)) break; } } private char charFromEnd(String s, int i) { return s.charAt(s.length() - i  - 1 ); } private boolean suffixOverlapsPrefix(int suffixLength) { return actual.length() - suffixLength  <=  prefixLength || expected.length() - suffixLength  <=  prefixLength; } … private String compactString(String source) { String result = DELTA_START + source.substring(prefixLength, source.length() -  suffixLength ) + DELTA_END; if (prefixLength > 0) result = computeCommonPrefix() + result; if ( suffixLength  > 0) 332