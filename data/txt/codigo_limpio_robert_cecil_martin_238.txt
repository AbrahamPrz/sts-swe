siguiente clase: public class X { private int lastIdUsed; public int getNextId() { return ++lastIdUsed; } } Imagine que creamos una instancia  X , establecemos el campo  lastIdUsed en 42 y después compartimos la instancia entre dos procesos. Imagine ahora que esos dos procesos invocan el método  getNextId() ; hay tres resultados posibles: El primer proceso obtiene el valor 43, el segundo el valor 44 y lastIdUsed  es 44. El primer proceso obtiene el valor 44, el segundo el valor 43 y lastIdUsed  es 44. El primer proceso obtiene el valor 43, el segundo el valor 43 y lastIdUsed  es 43. El sorprendente tercer resultado [76]  se produce cuando los dos procesos coinciden. Se debe a que pueden adoptar varias rutas posibles en una línea de código de Java y algunas generan resultados incorrectos. ¿Cuántas rutas distintas existen? Para responder, debemos entender lo que hace el compilador justo a tiempo con el código de  bytes  generado, y lo que el modelo de memoria de Java considera atómico. Una rápida respuesta, con el código de  bytes  generado, es que existen  12 870  rutas de ejecución diferentes [77]  para los dos procesos ejecutados en el método  getNextId . Si el tipo de  lastIdUsed  cambia de  int  a  long , el número de rutas asciende a  2 704 156.  Evidentemente, muchas generan resultados válidos. El problema es que  algunas no lo hacen . Principios de defensa de la concurrencia A continuación le mostramos una serie de principios y técnicas para proteger 239