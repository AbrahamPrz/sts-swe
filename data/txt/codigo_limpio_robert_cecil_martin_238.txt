siguiente clase: public class x { private int lastidused; public int getnextid() { return ++lastidused; } } imagine que creamos una instancia x , establecemos el campo lastidused en 42 y después compartimos la instancia entre dos procesos. imagine ahora que esos dos procesos invocan el método getnextid() ; hay tres resultados posibles: el primer proceso obtiene el valor 43, el segundo el valor 44 y lastidused es 44. el primer proceso obtiene el valor 44, el segundo el valor 43 y lastidused es 44. el primer proceso obtiene el valor 43, el segundo el valor 43 y lastidused es 43. el sorprendente tercer resultado [76] se produce cuando los dos procesos coinciden. se debe a que pueden adoptar varias rutas posibles en una línea de código de java y algunas generan resultados incorrectos. ¿cuántas rutas distintas existen? para responder, debemos entender lo que hace el compilador justo a tiempo con el código de bytes generado, y lo que el modelo de memoria de java considera atómico. una rápida respuesta, con el código de bytes generado, es que existen 12 870 rutas de ejecución diferentes [77] para los dos procesos ejecutados en el método getnextid . si el tipo de lastidused cambia de int a long , el número de rutas asciende a 2 704 156. evidentemente, muchas generan resultados válidos. el problema es que algunas no lo hacen . principios de defensa de la concurrencia a continuación le mostramos una serie de principios y técnicas para proteger 239