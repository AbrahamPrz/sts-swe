híbridos dificultan la inclusión de nuevas funciones y también de nuevas estructuras de datos. son lo peor de ambos mundos. evítelos. indican un diseño descuidado cuyos autores dudan, o peor todavía, desconocen, si necesitan protegerse de funciones o tipos. ocultar la estructura ¿qué pasaría si ctxt , options y scratchdir fueran objetos con un comportamiento real? como los objetos deben ocultar su estructura interna, no podríamos desplazarnos por los mismos. entonces, ¿cómo obtendríamos la ruta absoluta del directorio scratch ? ctxt.getabsolutepathofscratchdirectoryoption(); o ctxt.getscratchdirectoryoption().getabsolutepath() la primera opción provocaría una explosión de métodos en el objeto ctxt . la segunda asume que getscratchdirectoryoption() devuelve una estructura de datos, no un objeto. ninguna de las opciones parece correcta. si ctxt es un objeto, deberíamos indicarle que hiciera algo, no preguntar sobre sus detalles internos. entonces, ¿para qué queremos la ruta absoluta del directorio scratch ? ¿cómo vamos a usarla? fíjese en este código del mismo módulo (muchas líneas después): string outfile = outputdir + “/” + classname.replace(‘.’, ‘/’) + “.class”; fileoutputstream fout = new fileoutputstream(outfile); bufferedoutputstream bos = new bufferedoutputstream(fout); la mezcla de distintos niveles de detalle [g34][g6] es preocupante. puntos, guiones, extensiones de archivo y objetos file no deben mezclarse de esta forma, junto al código contenedor. si lo ignoramos, vemos que la intención de obtener la ruta absoluta del directorio scratch es crear un archivo de borrador de un nombre concreto. ¿y si le dijéramos al objeto ctxt que hiciera esto? bufferedoutputstream bos = ctxt.createscratchfilestream(classfilename); parece algo razonable para un objeto. permite a ctxt ocultar sus detalles internos e impide que la función actual incumpla la ley de demeter y se 142