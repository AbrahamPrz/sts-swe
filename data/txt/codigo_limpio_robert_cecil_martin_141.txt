híbridos dificultan la inclusión de nuevas funciones y también de nuevas estructuras de datos. Son lo peor de ambos mundos. Evítelos. Indican un diseño descuidado cuyos autores dudan, o peor todavía, desconocen, si necesitan protegerse de funciones o tipos. Ocultar la estructura ¿Qué pasaría si  ctxt ,  options  y  scratchDir  fueran objetos con un comportamiento real? Como los objetos deben ocultar su estructura interna, no podríamos desplazarnos por los mismos. Entonces, ¿cómo obtendríamos la ruta absoluta del directorio  scratch ? ctxt.getAbsolutePathOfScratchDirectoryOption(); o ctxt.getScratchDirectoryOption().getAbsolutePath() La primera opción provocaría una explosión de métodos en el objeto ctxt . La segunda asume que  getScratchDirectoryOption()  devuelve una estructura de datos, no un objeto. Ninguna de las opciones parece correcta. Si ctxt  es un objeto, deberíamos indicarle que hiciera algo, no preguntar sobre sus detalles internos. Entonces, ¿para qué queremos la ruta absoluta del directorio  scratch ? ¿Cómo vamos a usarla? Fíjese en este código del mismo módulo (muchas líneas después): String outFile = outputDir + “/” + className.replace(‘.’, ‘/’) + “.class”; FileOutputStream fout = new FileOutputStream(outFile); BufferedOutputStream bos = new BufferedOutputStream(fout); La mezcla de distintos niveles de detalle [G34][G6] es preocupante. Puntos, guiones, extensiones de archivo y objetos  File  no deben mezclarse de esta forma, junto al código contenedor. Si lo ignoramos, vemos que la intención de obtener la ruta absoluta del directorio  scratch  es crear un archivo de borrador de un nombre concreto. ¿Y si le dijéramos al objeto  ctxt  que hiciera esto? BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName); Parece algo razonable para un objeto. Permite a  ctxt  ocultar sus detalles internos e impide que la función actual incumpla la Ley de Demeter y se 142