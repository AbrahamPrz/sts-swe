módulo que comienza correctamente pero no mantiene dicha corrección. Tras ello, veremos cómo se refactoriza y se limpia. Muchos hemos tenido que analizar argumentos de línea de comando. Si no disponemos de una utilidad para ello, recorremos la matriz de cadenas pasadas a la función principal. Puede encontrar utilidades de calidad pero ninguna hace exactamente lo que necesitamos. Por ello, decidí crear una propia, a la que he denominado  Args . Args  es muy fácil de usar. Basta crearla con los argumentos de entrada y una cadena de formato, y después consultar a la instancia de  Args  los valores de los argumentos. Fíjese en el siguiente ejemplo: Listado 14-1 Uso de Args public static void main(String[] args) { try { Args arg = new Args(“l,p#,d*”, args); boolean logging = arg.getBoolean(‘l’); int port = arg.getInt(‘p’); String directory = arg.getString(‘d’); executeApplication(logging, port, directory); } catch (ArgsException e) { System.out.printf(“Argument error: %s\n”, e.errorMessage()); } } Comprobará lo sencillo que es. Creamos una instancia de la clase  Args con dos parámetros. El primero es la cadena de formato o esquema: “l,p#,d*” . Define tres argumentos de línea de comandos. El primero,  -l , es un argumento booleano. El segundo,  -p , es un argumento entero. El tercero,  - d , es un argumento de cadena. El segundo parámetro del constructor  Args  es la matriz de argumentos de línea de comandos pasada a  main . Si el constructor no genera  ArgsException , la línea de comandos entrante se ha analizado y se puede consultar la instancia  Args . Se usan métodos como getBoolean ,  getInteger  y  getString  para acceder a los valores de los argumentos por sus nombres. Si hay un problema, ya sea en la cadena de formato o en los argumentos de línea de comandos, se genera  ArgsException . La descripción del error se 256