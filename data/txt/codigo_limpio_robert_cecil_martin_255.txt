módulo que comienza correctamente pero no mantiene dicha corrección. tras ello, veremos cómo se refactoriza y se limpia. muchos hemos tenido que analizar argumentos de línea de comando. si no disponemos de una utilidad para ello, recorremos la matriz de cadenas pasadas a la función principal. puede encontrar utilidades de calidad pero ninguna hace exactamente lo que necesitamos. por ello, decidí crear una propia, a la que he denominado args . args es muy fácil de usar. basta crearla con los argumentos de entrada y una cadena de formato, y después consultar a la instancia de args los valores de los argumentos. fíjese en el siguiente ejemplo: listado 14-1 uso de args public static void main(string[] args) { try { args arg = new args(“l,p#,d*”, args); boolean logging = arg.getboolean(‘l’); int port = arg.getint(‘p’); string directory = arg.getstring(‘d’); executeapplication(logging, port, directory); } catch (argsexception e) { system.out.printf(“argument error: %s\n”, e.errormessage()); } } comprobará lo sencillo que es. creamos una instancia de la clase args con dos parámetros. el primero es la cadena de formato o esquema: “l,p#,d*” . define tres argumentos de línea de comandos. el primero, -l , es un argumento booleano. el segundo, -p , es un argumento entero. el tercero, - d , es un argumento de cadena. el segundo parámetro del constructor args es la matriz de argumentos de línea de comandos pasada a main . si el constructor no genera argsexception , la línea de comandos entrante se ha analizado y se puede consultar la instancia args . se usan métodos como getboolean , getinteger y getstring para acceder a los valores de los argumentos por sus nombres. si hay un problema, ya sea en la cadena de formato o en los argumentos de línea de comandos, se genera argsexception . la descripción del error se 256