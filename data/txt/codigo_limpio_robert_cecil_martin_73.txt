incluso funciones diádicas evidentes como assertequals(expected, actual) resultan problemáticas. ¿cuántas veces ha incluido el valor real en su posición esperada? los dos argumentos carecen de un orden natural. el orden real y esperado es una convención que se adquiere gracias a la práctica. las combinaciones diádicas no son el mal en persona y tendrá que usarlas. sin embargo, recuerde que tienen un precio y que debe aprovechar los mecanismos disponibles para convertirlas en unitarias. por ejemplo, puede hacer que el método writefield sea un miembro de outputstream para poder usar outputstream.writefield(name) , o podría convertir outputstream en una variable miembro de la clase actual para no tener que pasarla. incluso podría extraer una nueva clase como fieldwriter que usara outputstream en su constructor y tuviera un método write . triadas las funciones que aceptan tres argumentos son sin duda mucho más difíciles de entender que las de dos. los problemas a la hora de ordenar, ignorar o detenerse en los argumentos se duplican. piense atentamente antes de crear una triada. por ejemplo, fíjese en la sobrecarga de assertequals que acepta tres argumentos: assertequals(message, expected, actual) . ¿cuántas veces lee el mensaje y piensa que es lo esperado? he visto esta triada en concreto muchas veces. de hecho, siempre que la veo, tengo que repasarla antes de ignorar el mensaje. por otra parte, hay otra triada que no es tan negativa: assertequals(1.0, amount, .001) . aunque también exija doble atención, merece la pena. conviene recordar siempre que la igualdad de los valores de coma flotante es algo relativo. objeto de argumento cuando una función parece necesitar dos o más argumentos, es probable que 74