Incluso funciones diádicas evidentes como  assertEquals(expected, actual)  resultan problemáticas. ¿Cuántas veces ha incluido el valor real en su posición esperada? Los dos argumentos carecen de un orden natural. El orden real y esperado es una convención que se adquiere gracias a la práctica. Las combinaciones diádicas no son el mal en persona y tendrá que usarlas. Sin embargo, recuerde que tienen un precio y que debe aprovechar los mecanismos disponibles para convertirlas en unitarias. Por ejemplo, puede hacer que el método  writeField  sea un miembro de  outputStream para poder usar  outputStream.writeField(name) , o podría convertir outputStream  en una variable miembro de la clase actual para no tener que pasarla. Incluso podría extraer una nueva clase como  FieldWriter  que usara outputStream  en su constructor y tuviera un método  write . Triadas Las funciones que aceptan tres argumentos son sin duda mucho más difíciles de entender que las de dos. Los problemas a la hora de ordenar, ignorar o detenerse en los argumentos se duplican. Piense atentamente antes de crear una triada. Por ejemplo, fíjese en la sobrecarga de  assertEquals  que acepta tres argumentos:  assertEquals(message, expected, actual) . ¿Cuántas veces lee el mensaje y piensa que es lo esperado? He visto esta triada en concreto muchas veces. De hecho, siempre que la veo, tengo que repasarla antes de ignorar el mensaje. Por otra parte, hay otra triada que no es tan negativa:  assertEquals(1.0, amount, .001) . Aunque también exija doble atención, merece la pena. Conviene recordar siempre que la igualdad de los valores de coma flotante es algo relativo. Objeto de argumento Cuando una función parece necesitar dos o más argumentos, es probable que 74