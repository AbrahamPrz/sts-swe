boolean dial(String phoneNumber); boolean disconnect(); boolean send(char c); char recv(); String getConnectedPhoneNumber(); } Inicialmente parece correcta. Las funciones parecen las adecuadas. De hecho lo son para muchas aplicaciones, pero piense ahora en una aplicación en la que algunos módems no se conecten mediante marcación telefónica, sino mediante cables (como los usados para conexiones domésticas a Internet). Puede que algunos se conecten enviando un número de puerto a un concentrador a través de una conexión USB. Es evidente que la noción de números de teléfono se encuentra en un nivel de abstracción equivocado. Una estrategia de nomenclatura más adecuada para este caso sería la siguiente: public interface Modem { boolean connect(String connectionLocator); boolean disconnect(); boolean send(char c); char recv(); String getConnectedLocator(); } Ahora los nombres no se limitan a números de teléfono. Se pueden usar para números de teléfono o para otros tipos de estrategia de conexión. N3: Usar nomenclatura estándar siempre que sea posible Los nombres son más fáciles de entender si se basan en una convención o un uso existente. Por ejemplo, si emplea el patrón  DECORATOR , debería usar la palabra  Decorator  en los nombres de las clases. Por ejemplo, AutoHangupModemDecorator  podría ser el nombre de una clase que permite a un módem colgar automáticamente al final de una sesión. Los patrones son un tipo de estándar. En Java, por ejemplo, las funciones que convierten objetos en representaciones de cadena suelen tener el nombre  toString . Es mejor seguir estas convenciones que inventar otras propias. Los equipos suelen inventar su propio sistema estándar de nombres para un proyecto concreto. Eric Evans lo denomina  lenguaje omnipresente  del 393