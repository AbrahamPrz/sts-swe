un estorbo. puede que lo piense porque el tipo de errores que puede capturar final ya se capturan en las pruebas de unidad que he creado. las instrucciones if duplicadas [g5] del bucle for (líneas 259 y 263) son irrelevantes, de modo que las conecté en una única instrucción if con el operador || . también usé la enumeración day para dirigir el bucle for y realicé otros cambios estéticos. este método no pertenece realmente a daydate . en realidad es la función de análisis de day . por lo tanto, lo cambié a la enumeración day , lo que hizo que aumentara considerablemente de tamaño. como el concepto de day no depende de daydate , extraje la enumeración day de la clase daydate a un archivo propio [g13]. también cambié la siguiente función, weekdaycodetostring (líneas 272-286) a la enumeración day y le asigné el nombre tostring . public enum day { monday(calendar.monday), tuesday(calendar.tuesday), wednesday(calendar.wednesday), thursday(calendar.thursday), friday(calendar.friday), saturday(calendar.saturday), sunday(calendar.sunday); public final int index; private static dateformatsymbols datesymbols = new dateformatsymbols(); day(int day) { index = day; } public static day make(int index) throws illegalargumentexception { for (day d : day.values()) if (d.index == index) return d; throw new illegalargumentexception( string.format(“illegal day index: %d.”, index)); } public static day parse(string s) throws illegalargumentexception { string[] shortweekdaynames = datesymbols.getshortweekdays(); string[] weekdaynames = datesymbols.getweekdays(); s = s.trim(); for (day day : day.values()) { 349