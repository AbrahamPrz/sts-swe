un estorbo. Puede que lo piense porque el tipo de errores que puede capturar final  ya se capturan en las pruebas de unidad que he creado. Las instrucciones  if  duplicadas [G5] del bucle  for  (líneas 259 y 263) son irrelevantes, de modo que las conecté en una única instrucción  if  con el operador  || . También usé la enumeración  Day  para dirigir el bucle  for  y realicé otros cambios estéticos. Este método no pertenece realmente a  DayDate . En realidad es la función de análisis de  Day . Por lo tanto, lo cambié a la enumeración  Day , lo que hizo que aumentara considerablemente de tamaño. Como el concepto de  Day  no depende de  DayDate , extraje la enumeración  Day  de la clase  DayDate  a un archivo propio [G13]. También cambié la siguiente función,  weekdayCodeToString  (líneas  272-286)  a la enumeración  Day  y le asigné el nombre  toString . public enum Day { MONDAY(Calendar.MONDAY), TUESDAY(Calendar.TUESDAY), WEDNESDAY(Calendar.WEDNESDAY), THURSDAY(Calendar.THURSDAY), FRIDAY(Calendar.FRIDAY), SATURDAY(Calendar.SATURDAY), SUNDAY(Calendar.SUNDAY); public final int index; private static DateFormatSymbols dateSymbols = new DateFormatSymbols(); Day(int day) { index = day; } public static Day make(int index) throws IllegalArgumentException { for (Day d : Day.values()) if (d.index == index) return d; throw new IllegalArgumentException( String.format(“Illegal day index: %d.”, index)); } public static Day parse(String s) throws IllegalArgumentException { String[] shortWeekdayNames = dateSymbols.getShortWeekdays(); String[] weekDayNames = dateSymbols.getWeekdays(); s = s.trim(); for (Day day : Day.values()) { 349