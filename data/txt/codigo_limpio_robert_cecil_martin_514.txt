169 int overestimatedyear = minimum_year_supported + days / 365; 170 int nonleapdays = days - dateutil.leapyearcount(overestimatedyear); 171 int underestimatedyear = minimum_year_supported + nonleapdays / 365; 172 173 year = huntforyearcontaining(ordinalday, underestimatedyear); 174 int firstordinalofyear = firstordinalofyear(year); 175 month = huntformonthcontaining(ordinalday, firstordinalofyear); 176 day = ordinalday - firstordinalofyear - daysbeforethismonth(month.toint()); 177 } 178 179 private month huntformonthcontaining(int anordinal, int firstordinalofyear) { 180 int daysintothisyear = anordinal - firstordinalofyear; 181 int amonth = 1; 182 while (daysbeforethismonth(amonth) < daysintothisyear) 183 amonth++; 184 185 return month.fromint(amonth - 1); 186 } 187 188 private int daysbeforethismonth(int amonth) { 189 if (dateutil.isleapyear(year)) 190 return leap_year_aggregate_days_to_end_of_preceding_month[amonth] - 1; 191 else 192 return aggregate_days_to_end_of_preceding_month[amonth] - 1; 193 } 194 195 private int huntforyearcontaining(int anordinalday, int startingyear) { 196 int ayear = startingyear; 197 while (firstordinalofyear(ayear) <= anordinalday) 198 ayear++; 199 200 return ayear - 1; 201 } 202 203 private int firstordinalofyear(int year) { 204 return calcordinal(1, month.january, year); 205 } 206 207 public static daydate createinstance(date date) { 208 gregoriancalendar calendar = new gregoriancalendar(); 209 calendar.settime(date); 210 return new spreadsheetdate(calendar.get(calendar.date), 515