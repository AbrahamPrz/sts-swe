private void setbooleanarg(char argchar, boolean value) { booleanargs. get (argchar). setboolean (value); } … public boolean getboolean(char arg) { return falseifnull (booleanargs.get(arg). getboolean() ); } estos cambios se aplican a las zonas que mencionamos antes: parse , set y get para el tipo de argumento. desafortunadamente, aunque sean cambios menores, algunas de las pruebas comenzaron a fallar. si se fija atentamente en getboolean , comprobará que se puede invocar con y pero no existe un argumento y , por lo que booleanargs.get(‘y’) devolverá null y la función generará nullpointerexception . la función falseifnull se usa como protección ante este hecho pero el cambio aplicado hace que la función sea irrelevante. el incrementalismo exigía que esto funcionara antes de realizar otros cambios. la solución no era demasiado complicada; bastaba con cambiar la comprobación de null . ya no era necesario comprobar null en boolean, sino en argumentmarshaller . primero, eliminé la invocación de falseifnull en la función getboolean . ya no servía de nada, por lo que eliminé directamente la función. las pruebas seguían fallando igual, lo que suponía que no había nuevos errores. public boolean getboolean(char arg) { return booleanargs.get(arg).getboolean(); } tras ello, dividí la función en dos líneas y añadí argumentmarshaller a una variable propia: argumentmarshaller . no me preocupaba el extenso nombre de la variable; era redundante y estorbaba a la función, por lo que lo reduje a am [n5]. public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am .getboolean(); } y tras ello añadí la lógica de detección de null . public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); 278