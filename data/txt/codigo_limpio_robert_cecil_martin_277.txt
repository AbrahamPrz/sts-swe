private void setBooleanArg(char argChar, boolean value) { booleanArgs. get (argChar). setBoolean (value); } … public boolean getBoolean(char arg) { return falseIfNull (booleanArgs.get(arg). getBoolean() ); } Estos cambios se aplican a las zonas que mencionamos antes:  parse ,  set y  get  para el tipo de argumento. Desafortunadamente, aunque sean cambios menores, algunas de las pruebas comenzaron a fallar. Si se fija atentamente en  getBoolean , comprobará que se puede invocar con  y  pero no existe un argumento  y , por lo que  booleanArgs.get(‘y’)  devolverá  null  y la función generará  NullPointerException . La función  falseIfNull  se usa como protección ante este hecho pero el cambio aplicado hace que la función sea irrelevante. El incrementalismo exigía que esto funcionara antes de realizar otros cambios. La solución no era demasiado complicada; bastaba con cambiar la comprobación de  null . Ya no era necesario comprobar  null  en boolean, sino en  ArgumentMarshaller . Primero, eliminé la invocación de  falseIfNull  en la función getBoolean . Ya no servía de nada, por lo que eliminé directamente la función. Las pruebas seguían fallando igual, lo que suponía que no había nuevos errores. public boolean getBoolean(char arg) { return booleanArgs.get(arg).getBoolean(); } Tras ello, dividí la función en dos líneas y añadí  ArgumentMarshaller  a una variable propia:  argumentMarshaller . No me preocupaba el extenso nombre de la variable; era redundante y estorbaba a la función, por lo que lo reduje a  am  [N5]. public boolean getBoolean(char arg) { Args.ArgumentMarshaler  am  = booleanArgs.get(arg); return  am .getBoolean(); } Y tras ello añadí la lógica de detección de  null . public boolean getBoolean(char arg) { Args.ArgumentMarshaler am = booleanArgs.get(arg); 278