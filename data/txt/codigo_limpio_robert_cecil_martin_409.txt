value 43, en el valor de campo del objeto actual, representado por el siguiente valor superior de la pila de operandos, this . ireturn devolver el valor superior (y único) de la pila de operandos. <vacío> imagine que el primer subproceso completa las tres primeras instrucciones, hasta getfield incluida y después se interrumpe. aparece un segundo subproceso y ejecuta el método completo, incrementando lastid en uno; devuelve 43. tras ello, el primer subproceso retoma desde donde se detuvo; 42 sigue en la pila de operandos por ser el valor de lastid cuando ejecutó getfield . suma uno para obtener 43 y almacena el resultado. el valor 43 también se devuelve al primer subproceso. como resultado, uno de los incrementos se pierde ya que el primer subproceso interfiere con el segundo después de que éste haya interrumpido al primero. al convertir el método getnextid() en synchronized se corrige este problema. conclusión no se necesita un conocimiento extenso del código de bytes para entender cómo unos subprocesos interrumpen a otros. si consigue entender este ejemplo, demostrará la posibilidad de varios subprocesos entrelazados, un conocimiento suficiente. dicho esto, lo que este sencillo ejemplo revela es la necesidad de entender el modelo de memoria para saber qué se permite y qué no. equivocadamente se piensa que el operador ++ (pre o postincremento) es atómico, y evidentemente no lo es. esto significa que tiene que saber: dónde están los objetos y valores compartidos. el código que provoca problemas de lectura/actualización concurrente. cómo evitar que se produzcan dichos problemas. 410