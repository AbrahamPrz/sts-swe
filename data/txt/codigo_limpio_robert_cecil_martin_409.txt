value 43, en el valor de campo del objeto actual, representado por el siguiente valor superior de la pila de operandos,  this . IRETURN Devolver el valor superior (y único) de la pila de operandos. <Vacío> Imagine que el primer subproceso completa las tres primeras instrucciones, hasta  GETFIELD  incluida y después se interrumpe. Aparece un segundo subproceso y ejecuta el método completo, incrementando  lastId  en uno; devuelve 43. Tras ello, el primer subproceso retoma desde donde se detuvo; 42 sigue en la pila de operandos por ser el valor de  lastId  cuando ejecutó  GETFIELD . Suma uno para obtener 43 y almacena el resultado. El valor 43 también se devuelve al primer subproceso. Como resultado, uno de los incrementos se pierde ya que el primer subproceso interfiere con el segundo después de que éste haya interrumpido al primero. Al convertir el método  getNextId()  en  synchronized  se corrige este problema. Conclusión No se necesita un conocimiento extenso del código de  bytes  para entender cómo unos subprocesos interrumpen a otros. Si consigue entender este ejemplo, demostrará la posibilidad de varios subprocesos entrelazados, un conocimiento suficiente. Dicho esto, lo que este sencillo ejemplo revela es la necesidad de entender el modelo de memoria para saber qué se permite y qué no. Equivocadamente se piensa que el operador  ++  (pre o postincremento) es atómico, y evidentemente no lo es. Esto significa que tiene que saber: Dónde están los objetos y valores compartidos. El código que provoca problemas de lectura/actualización concurrente. Cómo evitar que se produzcan dichos problemas. 410