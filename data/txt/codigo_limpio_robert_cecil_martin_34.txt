Sabemos que estamos trabajando con código limpio cuando cada rutina que leemos resulta ser lo que esperábamos. Se puede denominar código atractivo cuando el código hace que parezca que el lenguaje se ha creado para el problema en cuestión. Este tipo de afirmaciones son características de Ward. Las leemos, asentimos y pasamos a la siguiente. Es tan razonable y evidente que apenas parece profundo. Incluso podemos pensar que es lo que esperábamos. Pero preste atención. «… resulta ser lo que esperábamos». ¿Cuándo fue la última vez que vio un módulo que fuera más o menos lo que esperaba? ¿Lo habitual no es ver módulos complicados y enrevesados? ¿No es esta falta de concreción lo habitual? ¿No está acostumbrado a intentar extraer el razonamiento de un sistema para llegar al módulo que está leyendo? ¿Cuándo fue la última vez que leyó un código y asintió como seguramente haya hecho al leer la afirmación de Ward? Ward espera que al leer código limpio no le sorprenda. De hecho, ni siquiera tendrá que esforzarse. Lo leerá y será prácticamente lo que esperaba. Será evidente, sencillo y atractivo. Cada módulo prepara el camino del siguiente. Cada uno indica cómo se escribirá el siguiente. Los programas limpios están tan bien escritos que ni siquiera se dará cuenta. El diseñador consigue simplificarlo todo enormemente, como sucede con todos los diseños excepcionales. ¿Y la noción de atractivo de Ward? Todos hemos criticado que nuestros lenguajes no se hayan diseñado para nuestros problemas. Pero la afirmación de Ward hace que ahora la responsabilidad sea nuestra. Afirma que  el código atractivo hace que el lenguaje parezca creado para el problema . Por tanto, somos responsables de que el lenguaje parezca sencillo. No es el lenguaje el que hace que los programas parezcan sencillos, sino el programador que consigue que el lenguaje lo parezca. 35