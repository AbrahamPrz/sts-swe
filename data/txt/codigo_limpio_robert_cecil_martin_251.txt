evidentemente, si dividimos el sistema pojo que no sepa nada los procesos en clases que controlen los procesos, resultará más sencillo ubicar los puntos en los que instrumentar el código. es más, podríamos crear diferentes pruebas que invoquen los pojo bajo distintos regímenes de invocaciones a sleep , yield y demás. automática puede usar herramientas como la estructura orientada a aspectos, cglib o asm para instrumentar su código mediante programación. por ejemplo, podría usar una clase con un único método: public class threadjigglepoint { public static void jiggle() { } } puede añadir invocaciones en distintos puntos del código: public synchronized string nexturlornull() { if(hasnext()) { threadjigglepoint.jiggle(); string url = urlgenerator.next(); threadjigglepoint.jiggle(); updatehasnext(); threadjigglepoint.jiggle(); return url; } return null; } tras ello, use un sencillo aspecto que seleccione aleatoriamente entre no hacer nada, pausar o generar un resultado. imagine que la clase threadjigglepoint tiene dos implementaciones. la primera implementa jiggle para no hacer nada y se usa en producción. la segunda genera un número aleatorio para elegir entre sleep , yield o nada. si ejecuta sus pruebas mil veces con jiggle de forma aleatoria, puede descubrir algunos fallos. si la prueba es satisfactoria, al menos puede felicitarse por haber actuado correctamente. aunque sea un tanto simple, puede resultar una opción razonable en lugar de recurrir a una herramienta más sofisticada. la herramienta contest [91] , desarrollada por ibm, tiene un funcionamiento 252