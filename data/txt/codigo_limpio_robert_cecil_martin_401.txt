Observaciones del servidor El servidor actualizado completa satisfactoriamente la prueba en algo más de un segundo. Desafortunadamente, la solución genera ciertos problemas. ¿Cuántos subprocesos podría crear nuestro servidor? El código no define límites de modo que podríamos alcanzar el impuesto por la Máquina virtual de Java (MVJ), suficiente en muchos sistemas sencillos. ¿Pero y si el sistema tiene que asumir multitud de usuarios de una red pública? Si se conectan demasiados usuarios al mismo tiempo, el sistema podría colapsarse. Pero dejemos temporalmente este problema de comportamiento. La solución mostrada tiene problemas de limpieza y estructura. ¿Cuántas responsabilidades tiene el código del servidor? Administración de conexiones. Procesamiento de clientes. Política de subprocesos. Política de cierre del servidor. Desafortunadamente, todas estas responsabilidades se encuentran en la función  process . Además, el código cruza varios niveles diferentes de abstracción. Por tanto, a pesar de la reducida función  process , es necesario dividirlo. Existen varios motivos para cambiar el servidor; por tanto, incumple el principio de responsabilidad única. Para mantener la limpieza de un sistema concurrente, la administración de subprocesos debe limitarse a una serie de puntos controlados. Es más, el código que gestione los subprocesos únicamente debe encargarse de la gestión de subprocesos. ¿Por qué? Si no existe otro motivo, el control de problemas de concurrencia ya es lo suficientemente complicado como para generar simultáneamente otros problemas no relacionados con la concurrencia. Si creamos una lista independiente para cada una de las responsabilidades anteriores, incluyendo la administración de subprocesos, al cambiar la estrategia de administración de subprocesos, el cambio tiene un menor impacto sobre el código y no contamina a otras responsabilidades. De este 402