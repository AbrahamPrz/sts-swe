existen otras clases añadidas para admitir diseño avanzado de concurrencia. veamos algunos ejemplos: reentrantlock bloqueo que se puede adquirir en un método y liberar en otro. semaphore una implementación del clásico semáforo, un bloqueo con un contador. countdownlatch bloqueo que espera un número de eventos antes de liberar todos los subprocesos retenidos. de este modo todos tienen la misma oportunidad de iniciarse al mismo tiempo. recomendación : revise las clases de las que disponga. en el caso de java, debe familiarizarse con java.util.concurrent, java.util.concurrent.atomic y java.util.concurrent.locks . conocer los modelos de ejecución existen diversas formas de dividir el comportamiento de una aplicación concurrente. para describirlos debe conocer ciertas definiciones básicas. recursos vinculados recursos de tamaño o número fijo usados en un entorno concurrente, como por ejemplo conexiones de base de datos y búfer de lectura/escritura de tamaño fijo. exclusión mutua sólo un proceso puede acceder a datos o a un recurso compartido por vez. inanición se impide que un proceso o grupo de procesos continúen demasiado tiempo o indefinidamente. por ejemplo, si permite primero la ejecución de los procesos más rápidos, los que se ejecutan durante más tiempo pueden perecer de inanición si los primeros no terminan nunca. bloqueo dos o más procesos esperan a que ambos terminen. cada proceso tiene un recurso y ninguno puede terminar hasta que obtenga el otro recurso. bloqueo procesos bloqueados, intentando realizar su labor pero 243