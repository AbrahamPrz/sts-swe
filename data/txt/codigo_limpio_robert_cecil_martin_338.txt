lograr sin una cobertura mayor de las pruebas. Por ello diseñé mi propia  suite de pruebas de unidad independientes (véase el Listado  B-4). Si se fija en las pruebas, comprobará que muchas están comentadas, ya que no se superaron. Representan un comportamiento que considero debería incluirse en  SerialDate . Por tanto, al refactorizar  SerialDate , intentaré que estas pruebas funcionen. Incluso con algunas de las pruebas comentadas, el informe de Clover indica que ahora ejecutan 170 (el 92 por ciento) de las 185 instrucciones ejecutables. Un gran resultado que creo que puedo mejorar. Las primeras pruebas comentadas (líneas  23-63)  son un tanto pretenciosas. El programa no fue diseñado para superar estas pruebas, pero el comportamiento me parecía evidente [G2]. Desconozco por qué se ha creado el método  testWeekdayCodeToString  pero ya que está ahí, parece obvio que no debe distinguir entre mayúsculas y minúsculas. El diseño de las pruebas fue sencillo [T3] y más todavía que fueran satisfactorias; simplemente cambié las líneas 259 y 263 para usar  equalsIgnoreCase . Comenté las pruebas de las líneas 32 y 45 ya que no estaba seguro de si las abreviaturas  tues  y  thurs  se admitían o no. Las pruebas de las líneas 153 y 154 no se superaron, aunque deberían haberlo hecho [G2]. Podemos corregirlas, junto a las pruebas de las líneas 163 a la 213, si realizamos los siguientes cambios en la función  stringToMonthCode . 457 if ((result < 1) || (result > 12)) { result = -1; 458 for (int i = 0; i < monthNames.length; i++) { 459 if (s.equalsIgnoreCase(shortMonthNames[i])) { 460 result = i + 1; 461 break; 462 } 463 if (s.equalsIgnoreCase(monthNames[i])) { 464 result = i + 1; 465 break; 466 } 467 } 468 } La prueba comentada de la línea 318 descubre un error en el método getFollowingDayOfWeek  (línea 672). El 25 de diciembre de 2004 fue sábado y el siguiente sábado fue el 1 de enero de 2005. Sin embargo, al ejecutar la 339