transform(StringBuffer out) , aunque la implementación del primer caso devuelva solamente el argumento de entrada. Al menos se ajusta a la forma de la transformación. Argumentos de indicador Los argumentos de indicador son horribles. Pasar un valor Booleano a una función es una práctica totalmente desaconsejable. Complica inmediatamente la firma del método e indica que la función hace más de una cosa. Hace algo si el indicador es  true  y otra cosa diferente si es  false . En el Listado 3-7 no se puede evitar, porque los invocadores ya pasan el indicador y el objetivo era limitar el ámbito a la función y después, pero la invocación de  render (true)  es confusa para el lector. Si se desplaza el ratón sobre la invocación vemos que  render (boolean isSuite)  puede ayudar, pero no demasiado. Tendremos que dividir la función en dos:  renderForSuite()  y renderForSingleTest() . Funciones diádicas Una función con dos argumentos es más difícil de entender que una función monádica. Por ejemplo  writeField(name)  es más fácil de entender que writeField (outputStream, name) [19] . Aunque en ambos casos el significado es evidente, la primera se capta mejor visualmente. La segunda requiere una breve pausa hasta que ignoramos el segundo parámetro, lo que en última instancia genera problemas ya que no debemos ignorar esa parte del código. Las partes que ignoramos son las que esconden los errores. Pero en ocasiones se necesitan dos argumentos. Por ejemplo.  Point p = new Point(0,0);  es totalmente razonable. Los puntos cartesianos suelen adoptar dos argumentos. De hecho, sería muy sorprendente ver  Point(0) . Sin embargo, en este caso ambos argumentos son componentes ordenados de un mismo valor, mientras que  outputStream  y  name  carecen de una cohesión o un orden natural. 73