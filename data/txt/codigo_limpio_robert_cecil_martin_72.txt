transform(stringbuffer out) , aunque la implementación del primer caso devuelva solamente el argumento de entrada. al menos se ajusta a la forma de la transformación. argumentos de indicador los argumentos de indicador son horribles. pasar un valor booleano a una función es una práctica totalmente desaconsejable. complica inmediatamente la firma del método e indica que la función hace más de una cosa. hace algo si el indicador es true y otra cosa diferente si es false . en el listado 3-7 no se puede evitar, porque los invocadores ya pasan el indicador y el objetivo era limitar el ámbito a la función y después, pero la invocación de render (true) es confusa para el lector. si se desplaza el ratón sobre la invocación vemos que render (boolean issuite) puede ayudar, pero no demasiado. tendremos que dividir la función en dos: renderforsuite() y renderforsingletest() . funciones diádicas una función con dos argumentos es más difícil de entender que una función monádica. por ejemplo writefield(name) es más fácil de entender que writefield (outputstream, name) [19] . aunque en ambos casos el significado es evidente, la primera se capta mejor visualmente. la segunda requiere una breve pausa hasta que ignoramos el segundo parámetro, lo que en última instancia genera problemas ya que no debemos ignorar esa parte del código. las partes que ignoramos son las que esconden los errores. pero en ocasiones se necesitan dos argumentos. por ejemplo. point p = new point(0,0); es totalmente razonable. los puntos cartesianos suelen adoptar dos argumentos. de hecho, sería muy sorprendente ver point(0) . sin embargo, en este caso ambos argumentos son componentes ordenados de un mismo valor, mientras que outputstream y name carecen de una cohesión o un orden natural. 73