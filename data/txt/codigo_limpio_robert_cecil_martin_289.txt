unidad y otra serie independiente de pruebas de aceptación creadas en FitNesse. Las pruebas de FitNesse garantizan que si se invoca  getBoolean  en un argumento no Booleano, se obtiene  false . No sucede lo mismo con las pruebas de unidad. Hasta el momento, sólo había ejecutado las pruebas de unidad [93] . Este último cambio me permitió extraer otro uso de la asignación boolean: private void parseBooleanSchemaElement(char elementId) { ArgumentMarshaler m = new BooleanArgumentMarshaler(); booleanArgs.put(elementId, m); marshalers.put(elementId, m); } Y ahora ya podemos eliminar la asignación boolean. public class Args { … private Map<Character, ArgumentMarshaler> booleanArgs = new HashMap<Character, ArgmentMarshaler>(); private Map<Character, ArgumentMarshaler> stringArgs = new HashMap<Character, ArgumentMarshaler>(); private Map<Character, ArgumentMarshaler> intArgs = new HashMap<Character, ArgumentMarshaler>(); private Map<Character, ArgumentMarshaler> marshalers = new HashMap<Character, ArgumentMarshaler>(); … Tras ello, cambié los argumentos  String  e  Integer  de la misma forma y limpié los valores  boolean . private void parseBooleanSchemaElement(char elementId) { marshalers.put(elementId,  new BooleanArgumentMarshaler() ); } private void parseIntegerSchemaElement(char elementId) { marshalers.put(elementId,  new IntegerArgumentMarshaler() ); } private void parseStringSchemaElement(char elementId) { marshalers.put(elementId,  new StringArgumentMarshaler() ); } … public String getString(char arg) { Args.ArgumentMarshaler am =  marshalers .get(arg); try { return am null ? “” : (String) am.get(); } catch (ClassCastException e) { return “”; } } 290