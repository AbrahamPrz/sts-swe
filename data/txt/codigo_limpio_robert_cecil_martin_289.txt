unidad y otra serie independiente de pruebas de aceptación creadas en fitnesse. las pruebas de fitnesse garantizan que si se invoca getboolean en un argumento no booleano, se obtiene false . no sucede lo mismo con las pruebas de unidad. hasta el momento, sólo había ejecutado las pruebas de unidad [93] . este último cambio me permitió extraer otro uso de la asignación boolean: private void parsebooleanschemaelement(char elementid) { argumentmarshaler m = new booleanargumentmarshaler(); booleanargs.put(elementid, m); marshalers.put(elementid, m); } y ahora ya podemos eliminar la asignación boolean. public class args { … private map<character, argumentmarshaler> booleanargs = new hashmap<character, argmentmarshaler>(); private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … tras ello, cambié los argumentos string e integer de la misma forma y limpié los valores boolean . private void parsebooleanschemaelement(char elementid) { marshalers.put(elementid, new booleanargumentmarshaler() ); } private void parseintegerschemaelement(char elementid) { marshalers.put(elementid, new integerargumentmarshaler() ); } private void parsestringschemaelement(char elementid) { marshalers.put(elementid, new stringargumentmarshaler() ); } … public string getstring(char arg) { args.argumentmarshaler am = marshalers .get(arg); try { return am null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } 290