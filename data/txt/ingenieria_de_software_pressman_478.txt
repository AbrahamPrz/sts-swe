CAPÍTULO 19  PRUEBA DE APLICACIONES ORIENTADAS A OBJETOS 447 colaboraciones entre objetos y subsistemas que pueden no ser visibles de manera externa. En- tonces el diseño de caso de prueba pregunta: “¿Se capturó (como prueba) alguna tarea que ejercita la colaboración anotada en el diagrama de colaboración? Si no fue así, ¿por qué no se hizo?”  19.5 M ÉTODOS  DE PRUEBA  APLICABLES  EN EL NIVEL  CLASE La prueba “en lo pequeño” se enfoca en una sola clase y en los métodos que encapsula ésta. La prueba aleatoria y la partición son métodos que pueden usarse para ejercitar una clase durante la prueba OO. 19.5.1  Prueba aleatoria para clases OO Para ofrecer breves ilustraciones de estos métodos, considere una aplicación bancaria en la que una clase Account (cuenta) tiene las siguientes operaciones: open( ), setup( ), deposit( ),  withdraw( ), balance( ) , sumaries( ) , creditLimit( )  y close( )  (abrir, configurar, depósito, retiro, saldo,  resumen, límite de crédito y cerrar) [Kir94]. Cada una de estas operaciones puede aplicarse a Account, pero ciertas restricciones (por ejemplo, la cuenta debe abrirse antes de que otras operaciones puedan aplicarse y debe cerrarse después de que todas las operaciones se comple-ten) están implícitas por la naturaleza del problema. Incluso con estas restricciones, existen muchas permutas de las operaciones. La historia de vida de comportamiento mínima de una instancia de Account incluye las siguientes operaciones: opensetupdepositwithdrawclose Esto representa la secuencia de prueba mínima para account. Sin embargo, dentro de esta  secuencia puede ocurrir una amplia variedad de otros comportamientos: opensetupdeposit[deposit|withdraw|balance|summarize|creditLimit]nwithdrawclose Varias secuencias diferentes de operaciones pueden generarse al azar. Por ejemplo: Caso de prueba r1: opensetupdepositdepositbalancesummarizewithdrawclose Caso de prueba r2: opensetupdepositwithdrawdepositbalancecreditLimitwithdrawclose Éstas y otras pruebas de orden aleatorio se realizan para ejercitar diferentes historias de vida  de las instancias de clase.El número de posibles permutas para  la prueba aleatoria puede volverse muy grande. Para mejorar la eficiencia de la prueba, puede usarse una estrategia similar a la prueba de arreglo ortogonal.CONSEJO La escena: Cubículo de Shakira. Participantes: Jamie y Shakira, miembros del  equipo de ingeniería de software CasaSegura, que trabajan en el  diseño de casos de prueba para la función seguridad. La conversación:Shakira: Desarrollé algunas pruebas para la clase Detector [figu- ra 10.4]; tú sabes, la que permite el acceso a todos los objetos Sen- sor para la función seguridad. ¿Estás familiarizado con ella?Jamie (ríe): Seguro, es la que te permite agregar el sensor “angus-tia de perrito”. Shakira: La única. De cualquier forma, tiene una interfaz con cua- tro operaciones: read( ), enable( ), disable( ) y test( ). Antes de poder  leer un sensor, debe habilitársele. Una vez habilitado, puede leerse y probarse. Puede deshabilitarse en cualquier momento, excepto si se procesa una condición de alarma. Así que definí una secuencia de prueba simple que ejercitará su historia de vida de comportamiento. [Muestra a Jamie la siguiente secuencia].CASASEGURA Prueba de clase 19Pressman(437-452).indd   44719Pressman(437-452).indd   447 21/1/10   10:58:3521/1/10   10:58:35