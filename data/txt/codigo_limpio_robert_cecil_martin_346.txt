los comentarios que las describen son redundantes [C3]. Basta con sus nombres, de modo que eliminamos los comentarios. No hay motivos para que la tabla no sea privada [G8], ya que existe una función estática  lastDayOfMonth  que proporciona los mismos datos. La siguiente tabla,  AGGREGATE_DAYS_TO_END_OF_MONTH , es más misteriosa, ya que no se usa en ninguna parte de la estructura JCommon [G9], de modo que la elimino. Lo mismo sucede con  LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH . La siguiente tabla,  AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH , sólo se usa en  SpreadsheetDate  (líneas 434 y 473), lo que me hace dudar si transferirla a  SpreadsheetDate . La razón de no cambiarla es que la tabla no es específica de ninguna implementación concreta [G6]. Por otra parte, sólo existe la implementación  SpreadsheetDate , de modo que la tabla debe acercarse a donde se vaya a usar [G10], Para zanjar la duda y ser coherentes [G11], deberíamos privatizar la tabla y mostrarla a través de una función como  julianDateOfLastDayOfMonth . Pero nadie parece que la necesita. Es más, la tabla se puede cambiar a DayDate  si una nueva implementación de  DayDate  la necesita. Así que la cambiamos. Lo mismo sucede con  LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH . Tras ello, vemos tres grupos de constantes que se pueden convertir en enumeraciones (líneas  162-205).  La primera selecciona una semana de un mes. La transformo en la enumeración  WeekInMonth . public enum WeekInMonth { FIRST(1), SECOND(2), THIRD(3), FOURTH(4), LAST(0); public final int index; WeekInMonth(int index) { this.index = index; } } El segundo grupo de constantes (líneas 177-187) es más complicado. Las constantes  INCLUDE_NONE, INCLUDE_FIRST, INCLUDE_SECOND  e INCLUDE_BOTH  se usan para describir si las fechas finales de un intervalo deben incluirse en el mismo. Matemáticamente, se describe como intervalo 347