los comentarios que las describen son redundantes [c3]. basta con sus nombres, de modo que eliminamos los comentarios. no hay motivos para que la tabla no sea privada [g8], ya que existe una función estática lastdayofmonth que proporciona los mismos datos. la siguiente tabla, aggregate_days_to_end_of_month , es más misteriosa, ya que no se usa en ninguna parte de la estructura jcommon [g9], de modo que la elimino. lo mismo sucede con leap_year_aggregate_days_to_end_of_month . la siguiente tabla, aggregate_days_to_end_of_preceding_month , sólo se usa en spreadsheetdate (líneas 434 y 473), lo que me hace dudar si transferirla a spreadsheetdate . la razón de no cambiarla es que la tabla no es específica de ninguna implementación concreta [g6]. por otra parte, sólo existe la implementación spreadsheetdate , de modo que la tabla debe acercarse a donde se vaya a usar [g10], para zanjar la duda y ser coherentes [g11], deberíamos privatizar la tabla y mostrarla a través de una función como juliandateoflastdayofmonth . pero nadie parece que la necesita. es más, la tabla se puede cambiar a daydate si una nueva implementación de daydate la necesita. así que la cambiamos. lo mismo sucede con leap_year_aggregate_days_to_end_of_month . tras ello, vemos tres grupos de constantes que se pueden convertir en enumeraciones (líneas 162-205). la primera selecciona una semana de un mes. la transformo en la enumeración weekinmonth . public enum weekinmonth { first(1), second(2), third(3), fourth(4), last(0); public final int index; weekinmonth(int index) { this.index = index; } } el segundo grupo de constantes (líneas 177-187) es más complicado. las constantes include_none, include_first, include_second e include_both se usan para describir si las fechas finales de un intervalo deben incluirse en el mismo. matemáticamente, se describe como intervalo 347