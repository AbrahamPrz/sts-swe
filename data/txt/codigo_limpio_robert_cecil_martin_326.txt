} private String compactString(String s) { String result = “[” + s.substring(pfx, s.length() - sfx + 1) + “]”; if (pfx > 0) result = (pfx > ctxt ? “…” : “”) + s1.substring(Math.max(0, pfx - ctxt), pfx) + result; if (sfx > 0) { int end = Math.min(s1.length() - sfx + 1 + ctxt, s1.length()); result = result + (s1.substring(s1.length() - sfx + 1, end) + (s1.length() - sfx + 1 < s1.length() - ctxt ? “…” : “”)); } return result; } } Aunque los autores hicieron un buen trabajo con este módulo, la  Regla del Boy Scout [95]  muestra que podrían haberlo dejado más limpio de lo que se encontró. ¿Cómo podemos mejorar el código original del Listado 15-2? Lo primero que no necesitamos es el prefijo  f  de las variables miembro [N6]. Los entornos actuales hacen que este tipo de código de ámbito sea redundante, por lo que eliminaremos todas las  f . private int contextLength; private String expected; private String actual; private int prefix; private int suffix; Tras ello, tenemos una condicional sin encapsular al inicio de la función compact [G28]. public String compact(String message) { if (expected == null || actual == null || areStringsEqual()) return Assert.format(message, expected, actual); findCommonPrefix(); findCommonSuffix(); String expected = compactString(this.expected); String actual = compactString(this.actual); return Assert.format(message, expected, actual); } Es necesario encapsular esta condicional para que nuestra intención sea más clara. Por tanto, extraemos un método que la explique. public String compact(String message) { if ( shouldNotCompact() ) return Assert.format(message, expected, actual); 327