} private string compactstring(string s) { string result = “[” + s.substring(pfx, s.length() - sfx + 1) + “]”; if (pfx > 0) result = (pfx > ctxt ? “…” : “”) + s1.substring(math.max(0, pfx - ctxt), pfx) + result; if (sfx > 0) { int end = math.min(s1.length() - sfx + 1 + ctxt, s1.length()); result = result + (s1.substring(s1.length() - sfx + 1, end) + (s1.length() - sfx + 1 < s1.length() - ctxt ? “…” : “”)); } return result; } } aunque los autores hicieron un buen trabajo con este módulo, la regla del boy scout [95] muestra que podrían haberlo dejado más limpio de lo que se encontró. ¿cómo podemos mejorar el código original del listado 15-2? lo primero que no necesitamos es el prefijo f de las variables miembro [n6]. los entornos actuales hacen que este tipo de código de ámbito sea redundante, por lo que eliminaremos todas las f . private int contextlength; private string expected; private string actual; private int prefix; private int suffix; tras ello, tenemos una condicional sin encapsular al inicio de la función compact [g28]. public string compact(string message) { if (expected == null || actual == null || arestringsequal()) return assert.format(message, expected, actual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } es necesario encapsular esta condicional para que nuestra intención sea más clara. por tanto, extraemos un método que la explique. public string compact(string message) { if ( shouldnotcompact() ) return assert.format(message, expected, actual); 327