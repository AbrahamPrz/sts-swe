final string outputdir = scratchdir.getabsolutepath(); ¿incumplen estos dos fragmentos de código la ley de demeter? sin duda el módulo contenedor sabe que el objeto ctxt contiene opciones, que contienen un directorio scratch , que tiene una ruta absoluta. la función sabe demasiado. la función que realiza la invocación sabe cómo desplazarse por numerosos objetos diferentes. si incumple o no la ley de demeter depende de si ctxt , options y scratchdir son objetos o estructuras de datos. si son objetos, debería ocultarse su estructura interna, no mostrarse, y conocer sus detalles internos sería un claro incumplimiento de la ley de demeter. por otra parte, si ctxt , options y scratchdir son simples estructuras de datos, mostrarán su estructura interna con naturalidad y la ley de demeter no se aplica. el uso de funciones de acceso complica el problema. si el código se hubiera escrito de esta otra forma, probablemente no nos preocuparíamos de si se incumple la ley de demeter o no. final string outputdir = ctxt.options.scratchdir.absolutepath; el problema sería menos confuso si las estructuras de datos tuvieran variables públicas y no funciones, y los objetos tuvieran variables privadas y funciones públicas. sin embargo, existen estructuras y estándares (como los bean ) que exigen que incluso una sencilla estructura de datos tenga elementos de acceso y mutación. híbridos esta confusión genera ocasionalmente desafortunadas estructuras híbridas mitad objeto y mitad estructura de datos. tienen funciones que realizan tareas significativas y también variables públicas o método públicos de acceso y mutación que hacen que las variables privadas sean públicas, y tientan a otras funciones externas a usar dichas variables de la misma forma que un programa por procedimientos usaría una estructura de datos [32] . estos 141