else throw new ParseException(String.format( “Argument: %c has invalid format: %s.”, elementId, elementTail), 0); } Seguidamente, creamos la clase  DoubleArgumentMarshaler . private class DoubleArgumentMarshaler implements ArgumentMarshaler { private double doubleValue = 0; public void set(Iterator<String> currentArgument) throws ArgsException { String parameter = null; try { parameter = currentArgument.next(); doubleValue = Double.parseDouble(parameter); } catch (NoSuchElementException e) { errorCode = ErrorCode.MISSING_DOUBLE; throw new ArgsException(); } catch (NumberFormatException e) { errorParameter = parameter; errorCode = ErrorCode.INVALID_DOUBLE; throw new ArgsException(); } } public Object get() { return doubleValue; } } Esto nos obliga a añadir un nuevo código de error ( ErrorCode ). private enum ErrorCode { OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT, MISSING_DOUBLE, INVALID_DOUBLE } Y necesitamos una función  getDouble . public double getDouble(char arg) { Args.ArgumentMarshaler am = marshalers.get(arg); try { return am = null ? 0 : (Double) am.get(); } catch (Exception e) { return 0.0; } } Y todas las pruebas son correctas. Ha sido sencillo. A continuación comprobamos que el procesamiento de errores funciona correctamente. El siguiente caso de prueba comprueba que se declare un error si se proporciona 305