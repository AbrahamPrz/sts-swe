else throw new parseexception(string.format( “argument: %c has invalid format: %s.”, elementid, elementtail), 0); } seguidamente, creamos la clase doubleargumentmarshaler . private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_double; throw new argsexception(); } catch (numberformatexception e) { errorparameter = parameter; errorcode = errorcode.invalid_double; throw new argsexception(); } } public object get() { return doublevalue; } } esto nos obliga a añadir un nuevo código de error ( errorcode ). private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } y necesitamos una función getdouble . public double getdouble(char arg) { args.argumentmarshaler am = marshalers.get(arg); try { return am = null ? 0 : (double) am.get(); } catch (exception e) { return 0.0; } } y todas las pruebas son correctas. ha sido sencillo. a continuación comprobamos que el procesamiento de errores funciona correctamente. el siguiente caso de prueba comprueba que se declare un error si se proporciona 305