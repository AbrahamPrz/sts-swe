MULT[N] = MULT[N] + P[N] + P[N]; if (MULT[N] == J) JPRIME = false; N = N + 1; } } while (!JPRIME); K = K + 1; P[K] = J; } { PAGENUMBER = 1; PAGEOFFSET = 1; while (PAGEOFFSET <= M) { System.out.println(“The First ” + M + “ Prime Numbers --- Page ” + PAGENUMBER); System.out.println(“”); for (ROWOFFSET = PAGEOFFSET; ROWOFFSET < PAGEOFFSET + RR; ROWOFFSET++) { for (C = 0; C < CC;C++) if (ROWOFFSET + C * RR <= M) System.out.format(“%10d”, P[ROWOFFSET + C * RR]); System.out.println(“”); } System.out.println(“\f”); PAGENUMBER = PAGENUMBER + 1; PAGEOFFSET = PAGEOFFSET + RR * CC; } } } } Este programa, escrito como una sola función, es un desastre. El sangrado de su estructura es excesivo y hay demasiadas variables extrañas. Como mínimo, la función debería dividirse en otras más pequeñas. Los listados del 10-6 al 10-8 muestran la división del código del Listado 10-5 en clases y funciones de menor tamaño, además de los nombres elegidos para dichas clases, funciones y variables. Listado 10-6 PrimePrinter.java (refactorizado) package literatePrimes; public class PrimePrinter ( public static void main(String[] args) { final int NUMBER_OF_PRIME5 = 1000; int[] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES); final int ROWS_PER_PAGE = 50; 194