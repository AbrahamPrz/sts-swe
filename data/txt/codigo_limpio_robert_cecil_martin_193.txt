mult[n] = mult[n] + p[n] + p[n]; if (mult[n] == j) jprime = false; n = n + 1; } } while (!jprime); k = k + 1; p[k] = j; } { pagenumber = 1; pageoffset = 1; while (pageoffset <= m) { system.out.println(“the first ” + m + “ prime numbers --- page ” + pagenumber); system.out.println(“”); for (rowoffset = pageoffset; rowoffset < pageoffset + rr; rowoffset++) { for (c = 0; c < cc;c++) if (rowoffset + c * rr <= m) system.out.format(“%10d”, p[rowoffset + c * rr]); system.out.println(“”); } system.out.println(“\f”); pagenumber = pagenumber + 1; pageoffset = pageoffset + rr * cc; } } } } este programa, escrito como una sola función, es un desastre. el sangrado de su estructura es excesivo y hay demasiadas variables extrañas. como mínimo, la función debería dividirse en otras más pequeñas. los listados del 10-6 al 10-8 muestran la división del código del listado 10-5 en clases y funciones de menor tamaño, además de los nombres elegidos para dichas clases, funciones y variables. listado 10-6 primeprinter.java (refactorizado) package literateprimes; public class primeprinter ( public static void main(string[] args) { final int number_of_prime5 = 1000; int[] primes = primegenerator.generate(number_of_primes); final int rows_per_page = 50; 194