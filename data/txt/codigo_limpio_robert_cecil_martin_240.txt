Se olvide de proteger uno o varios de esos puntos, y se dañe el código que modifica los datos compartidos. Se duplique el esfuerzo necesario para garantizar la protección de todos los elementos (incumplimiento de DRY [80] ). Resulta complicado determinar el origen de los fallos, que por naturaleza son difíciles de detectar. Recomendación :  Encapsule los datos y limite el acceso a los datos compartidos . Corolario: Usar copias de datos Una forma de evitar datos compartidos es no compartirlos. En algunos casos se pueden copiar objetos y procesarlos como si fueran de sólo lectura. En otros, se pueden copiar objetos, recopilar los resultados de varios procesos en las copias y después combinar los resultados en un mismo proceso. Si existe una forma sencilla de evitar los objetos compartidos, el código resultante tendrá menos problemas. Puede que le preocupe el coste de la creación de objetos adicionales. Merece la pena experimentar y comprobar si es un problema real. No obstante, si el uso de copias de objetos permite al código evitar la sincronización, las ventajas de evitar el bloque compensan la creación adicional y la sobrecarga de la recolección de elementos sin usar. Corolario: Los procesos deben ser independientes Pruebe a crear el código de sus procesos de forma que cada uno sea independiente y no comparta datos con otros. Cada uno procesa una solicitud cliente y todos los datos necesarios provienen de un origen sin compartir y se almacenan como variables locales. De este modo, los procesos se comportan como si fueran los únicos del mundo y no existieran requisitos de sincronización. Por ejemplo, las subclases de  HttpServlet  reciben toda su información como parámetros pasados en los métodos  doGet  y  doPost . Esto hace que cada servlet actúe como si dispusiera de su propio equipo. Mientras 241