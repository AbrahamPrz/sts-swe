} private void printandclearitemlist() { formatter.format(page); page.clear(); } private void addlineitemtopage(hourlyemployee e) { lineitem item = new lineitem(); item.name = e.getname(); item.hours = e.gettenthsworked() / 10; item.tenths = e.gettenthsworked() % 10; page.add(item); } public class lineitem { public string name; public int hours; public int tenths; } } este código tiene una dependencia lógica que no se ha convertido en física. ¿la detecta? es la constante page_size . ¿para qué necesita hourlyreporter saber el tamaño de la página? el tamaño de la página debe ser responsabilidad de hourlyreportformatter . la declaración de page_size en hourlyreporter representa una responsabilidad desubicada [g17] que hace que hourlyreporter asuma que conoce el tamaño que debe tener la página. esta presunción es una dependencia lógica. hourlyreporter depende de que hourlyreportformatter pueda procesar tamaños de página de hasta 55. si alguna implementación de hourlyreportformatter no puede asumir esos tamaños, se producirá un error. podemos convertir en física esta dependencia si creamos un nuevo método en hourlyreportformatter con el nombre getmaxpagesize() . tras ello, hourlyreporter invoca esta función en lugar de usar la constante page_size . g23: polimorfismo antes que if/else o switch/case puede parecer una sugerencia extraña dado el tema descrito en el capítulo 6. en este capítulo, afirmo que las instrucciones switch son adecuadas en partes del sistema en las que se añadan más funciones nuevas que tipos nuevos. 377