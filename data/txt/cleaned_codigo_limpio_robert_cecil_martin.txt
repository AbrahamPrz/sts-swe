cada año, invierten innumerables horas pierden numerosos recursos debido código mal escrito, ralentizando desarrollo, disminuyendo productividad, generando graves fallos incluso pudiendo acabar con organización empresa. reconocido experto software robert . martin, junto con sus colegas object mentor, nos presentan sus óptimas técnicas metodologías ágiles para limpiar código sobre marcha crearlo forma correcta, este modo mejorará como programador. esta obra divide tres partes. primera describe los principios, patrones prácticas para crear código limpio. segunda incluye varios casos estudio cuya complejidad aumentando. cada ejemplo ejercicio limpieza transformación código con problemas. tercera parte del libro contiene una lista heurística síntomas código erróneo (smells) confeccionada crear los casos prácticos. resultado una base conocimientos que describe cómo pensamos cuando creamos, leemos limpiamos código. imprescindible para cualquier desarrollador, ingeniero software, director proyectos, jefe equipo analista sistemas interesado crear código mejor calidad. ¡ libro que todo programador debe leer! cecil martin código limpio manual estilo para desarrollo ágil software epub . xcuidi .. original: clean code: handbook agile software craftsmanship robert cecil martin, traducción: josé luis gómez celador ilustraciones: jeniffer kohnke & angela brooks editor digital: xcuidi colaborador: mario . . (pdf-español) epub base . este libro maquetado siguiendo los estándares calidad página, sus editores, obtienen ningún tipo beneficio económico por ello. llegado poder desde otra web debes saber que seguramente sus propietarios obtengan ingresos publicitarios mediante archivos como este ann marie: verdadero amor vida. gustaría dar las gracias mis dos artistas, jeniffer kohnke angela brooks. jennifer encargada las impresionantes ilustraciones del inicio cada capítulo también los retratos kent beck, ward cunningham, bjarne stroustrup, ron jeffries, grady booch, dave thomas, michael feathers mío propio. angela encarga las ilustraciones internas los capítulos. realizado muchos dibujos para los últimos años, incluidos muchos los del libro agile software development: principles, patterns, and practices . también primogénita. agradecimiento especial los revisores bob bogetti, george bullock, jeffrey overbey especialmente matt heusser. han sido increíbles. han sido inmisericordes. han sido minuciosos. han forzado máximo para realizar las mejoras necesarias. gracias editor, chris guzikowski, por apoyo, aliento amistad. gracias todo personal editorial, incluida raina chrobak, que encargó que fuera honesto cumpliera los plazos. gracias micah martin todos los light ( por sus críticas apoyo. gracias todos los object mentor, pasados, presentes futuros, incluidos bob koss, michael feathers, michael hill, erik meade, jeff langr, pascal roy, david farber, brett schuchert, dean wampler, tim ottinger, dave thomas, james grenning, brian button, ron jeffries, lowell lindstrom, angelique martin, cindy sprague, libby ottinger, joleen craig, janice , susan rosso resto. gracias jim newkirk, amigo socio, que enseñado más que cree. agradecimiento kent beck, martin fowler, ward cunningham, bjarne stroustrup, grady booch todos mis mentores, compatriotas colegas. gracias john vlissides por estar ahí cuando necesitaba. gracias todos los zebra por permitirme despotricar sobre extensión que debe tener una función. , por último, darle las gracias por leer estos agradecimientos. una nuestras golosinas preferidas dinamarca -jol , con fuerte sabor regaliz, que constituye complemento perfecto para nuestro húmedo frío clima. parte del encanto -jol para los daneses frase que suele incluir envoltorio. esta mañana compré paquete dos encontré con este antiguo dicho danés: ærlighed små ting ikke nogen lille ting. « honestidad por las cosas pequeñas algo menor». perfecto para que que pensaba escribir. las cosas pequeñas importan. este libro trata sobre humildes preocupaciones cuyo valor dista mucho ser menor. está los detalles , afirmó arquitecto ludwig mies van der rohe. esta cita recuerda argumentos contemporáneos sobre papel arquitectura desarrollo software , especial universo ágil. bob hemos tenido esta conversación muchas veces. , mies van der rohe fijaba utilidad forma atemporal construcción que subyace las grandes creaciones arquitectónicas. por otra parte, seleccionaba personalmente los pomos todas las puertas todas las casas que diseñaba. ¿por qué? porque las cosas pequeñas importan. nuestro interminable debate sobre tdd, bob coincidimos que arquitectura del software desempeña una importante labor desarrollo, aunque tenemos diferentes visiones que esto significa. estas diferencias carecen importancia, que podemos aceptar que los profesionales responsables dedican parte tiempo planificar proyecto antes comenzarlo. las nociones diseño controlado únicamente por pruebas código, propias finales década , son válidas. atención detalle pilar fundamental los profesionales, casi como cualquier visión. por lado, práctica los detalles otorga dominio los profesionales, aumenta confianza para práctica mayor escala. por otra parte, más mínimo fallo construcción, una puerta que cierre bien baldosín mal colocado, acaba con encanto del todo. eso trata código limpio. pero arquitectura sólo una metáfora del desarrollo software concreto parte del software que ofrece producto inicial, misma forma que arquitecto entrega edificio inmaculado. hoy día, objetivo comercializar rápidamente los productos. queremos que las fábricas produzcan software pleno rendimiento. trata fábricas humanas, programadores que piensan, que sienten que trabajan para crear producto. metáfora manufacturación incluso más evidente este pensamiento. los aspectos productivos las fábricas automóviles japonesas fueron una gran inspiración para serum. pero incluso industria automovilística, gran parte del trabajo radica fabricación sino mantenimiento, más bien cómo evitarlo. software , por más que hacemos denomina cuantitativamente mantenimiento, acto reparar. lugar optar por costumbre occidental crear software calidad, debemos pensar como reparadores mecánicos. ¿qué piensan los directores japoneses todo esto? , enfoque calidad denominado tpm ( total productive maintenance mantenimiento productivo total) apareció escena. centraba mantenimiento producción. uno los pilares tpm conjunto principios denominados , una serie disciplinas. estos principios son realidad base lean, otro conocido término escena occidental, cada vez más presente mundo del software . estos principios son opcionales. como indica uncle bob, práctica del software correcto requiere disciplina. siempre trata hacer, producir velocidad óptima. filosofía incluye estos conceptos: seiri organización : fundamental saber dónde están las cosas, mediante enfoques como uso nombres correctos. ¿cree que los nombres los identificadores son relevantes? lea los siguientes capítulos. seiton sistematización : existe antiguo dicho norteamericano: sitio para cada cosa cada cosa sitio. fragmento código debe estar donde esperamos encontrarlo; caso contrario, refactorice hasta conseguirlo. seiso limpieza : mantenga limpio lugar trabajo. ¿qué dicen los autores sobre inundar código comentarios líneas que capturan historias deseos futuros? elimínelos. seiketsu estandarización : grupo decide cómo mantener limpio lugar trabajo. ¿cree que este libro habla sobre tener estilo código coherente una serie prácticas dentro del grupo? ¿ dónde provienen esos estándares? siga leyendo. shutsuke disciplina : significa ser disciplinado aplicación las prácticas reflejarlas trabajo aceptar los cambios. acepta reto, leído bien, reto, leer llevar práctica este libro, podrá comprender apreciar último punto. aquí nos acercamos profesionalidad responsable una profesión que debería preocuparse del ciclo vital producto. igual que mantenemos coches otras máquinas, mantenimiento divisible, esperar que surjan los errores, excepción. por contrario, ascendemos nivel: inspeccionamos diariamente las máquinas arreglamos los componentes gastados antes que rompan, cambiamos aceite cada varios miles kilómetros para evitar problemas. código, debemos refactorizar sin compasión. puede ascender otro nivel más, como hizo movimiento tpm hace años: crear máquinas que pueden mantener mejor. crear código legible tan importante como crear código ejecutable. práctica definitiva, que apareció los círculos tpm , que centra introducir nuevas máquinas sustituir las antiguas. como fred brooks nos advirtió, deberíamos rehacer software cada siete años para eliminar los problemas latentes. tendríamos que actualizar este plazo por semanas, días incluso horas lugar años. ahí donde encuentra detalle. detalle tiene gran poder, enfoque vital humilde profundo, como esperar cualquier enfoque origen japonés. pero sólo visión oriental vida; también encontramos pueblo norteamericano. cita seiton anterior proviene pluma ministro ohio que, literalmente, consideraba limpieza como remedio para todas las formas del mal. ¿ seiso ? limpieza pureza . aunque una casa sea bella, mobiliario inadecuado acaba con encanto. ¿ opinión shutsuke respecto? que confíe pequeño confiará superior . ¿ predisposición refactorizar momento adecuado, reforzando nuestra posición para las posteriores grandes decisiones, lugar dejarlo pasar? una puntada tiempo ahorra ciento. que madruga, dios ayuda. dejes para mañana que puedas hacer hoy (éste era sentido original frase « momento adecuado» lean hasta que cayó manos consultores software ). ¿ sobre calibrar importancia los pequeños esfuerzos individuales todo mayor? pequeñas semillas crecen grandes árboles . ¿ integración sencillas tareas preventivas vida diaria? más vale prevenir que curar . código limpio honra las raíces sabiduría popular, antes ahora, puede aplicar con atención detalle. literatura arquitectónica encontramos ejemplos estos detalles. piense los pomos mies van der rohe. eso seiri . atención todos los nombres variables. debe bautizar una variable con mismo cuidado como fuera primogénito. como todo sabemos, este cuidado acaba nunca. arquitecto christopher alexander, padre patrones lenguajes patrones, considera todo acto diseño como pequeño acto local reparación, considera maestría estructura como competencia única del arquitecto; las formas mayores ceden los patrones aplicación los habitantes. diseño interminable sólo añadir una nueva habitación una casa, sino prestar atención pintura, cambiar las alfombras instalar nuevo fregadero cocina. otras artes muestran sentimientos análogos. nuestra búsqueda por importancia los detalles, nos topamos con autor francés del siglo xix gustav flaubert. poeta francés paul valery afirma que poema acaba nunca que tiene que retocarse continuamente, que dejar trabajar poema señal abandono. tal preocupación por detalle común todas las empresas excelencia. puede que esto sea nada nuevo, pero leer este libro sentirá necesidad adoptar disciplinas rechazadas momento por apatía por deseo espontaneidad una simple respuesta cambio. desafortunadamente, solemos considerar estas preocupaciones clave del arte programación. renunciamos pronto nuestro código, porque hayamos completado, sino porque nuestro sistema valores centra futuro más que sustancia nuestros productos. esto tiene precio final: hierba mala nunca muere . investigación, mundo industrial académico, reduce mantener limpio código. cuando trabajaba organización bell labs software production research (sin duda producción) comprobamos que estilo sangrado coherente era uno los mayores indicadores estadísticamente significativos una baja densidad errores. queremos que una arquitectura, lenguaje programación otra noción superior sea motivo calidad; como seres cuya supuesta profesionalidad debe dominio herramientas métodos diseño, nos sentimos insultados por valor que los programadores añaden con tan sólo aplicar estilo sangrado coherente. citar propio libro hace años, dicho estilo distingue excelencia simple competencia. visión japonesa comprende verdadero valor del trabajador cotidiano , especial, los sistemas desarrollo que dependen las sencillas acciones diarias tales trabajadores. calidad resultado millón acciones cuidadosas, método magnífico caído del cielo. que dichas acciones sean simples significa que sean simplistas, mucho menos que sean sencillas. son base grandeza , cada vez más, cualquier empresa humana. ignorarlas humano absoluto. evidentemente, todavía defiendo pensamiento global, especial valor los enfoques arquitectónicos cimentados conocimiento los dominios capacidad uso del software . este libro versa sobre esto, menos forma evidente. este libro transmite mensaje más sutil cuya profundidad debe menospreciarse. coincide con visión gente como peter sommerlad, kevlin henney giovanni asproni, cuyos mantras son « código diseño» «código simple». aunque debemos recordar que interfaz programa que sus estructuras dicen mucho sobre propia estructura del programa, fundamental adoptar forma continuada humilde posición que diseño vive código. aunque los cambios metáfora fábrica supongan costes, los cambios diseño suponen valor. debemos considerar código como articulación los esfuerzos diseño, visto como proceso, como algo estático. código donde desarrollan los conceptos arquitectónicos conexión cohesión. escucha larry constantine describir conexión cohesión, hace términos del código, desde conceptos abstractos propios uml. ensayo abstraction descant , richard gabriel afirma que abstracción mal. código remedio mal código limpio puede que sea divino. volviendo caja -jol , considero importante recordar que sabiduría danesa nos recomienda sólo prestar atención las pequeñas cosas, sino también ser honestos con ellas. esto significa ser honesto con código, con nuestros colegas sobre estado del código , especial, con nosotros mismos. ¿hemos hecho todo posible para dejar las cosas mejor que como las encontramos? ¿hemos refactorizado código antes terminarlo? trata preocupaciones periféricas, sino que encuentran base misma los valores agile. serum recomienda que refactorización sea parte del concepto terminado. arquitectura código limpio insisten perfección, sino honestidad hacerlo mejor posible. errar humano; perdonar divino . serum, todo hacemos forma visible. aireamos los trapos sucios. somos honestos sobre estado nuestro código que nunca perfecto. nos hemos hecho más humanos, más merecedores divino estamos más próximos grandeza los detalles. nuestra profesión, necesitamos desesperadamente toda ayuda posible. suelo seco reduce riesgo resbalones las herramientas bien organizadas aumentan productividad, nuestra meta. cuanto libro, mejor aplicación pragmática los principios lean software que visto nunca formato impreso. esperaba menos este grupo individuos que durante años han esforzado sólo por mejorar sino ofrecer sus conocimientos industria mediante obras como que ahora tiene entre manos. hace que mundo sea poco mejor que antes que uncle bob enviara manuscrito. tras completar este ejercicio, dispongo limpiar escritorio. james . coplien mørdrup, dinamarca reproducido con permiso thom holwerda. http:// © focus shift. ¿qué puerta representa código? ¿qué puerta representa equipo ? ¿por qué estamos esa habitación? ¿ una sencilla revisión del código hemos detectado sinfín problemas terribles? ¿depuramos presas del pánico código que pensábamos que funcionaba? ¿los clientes huyen despavoridos los directores nos pisan los talones? ¿cómo asegurarnos que abrimos puerta correcta cuando las cosas ponen feas? respuesta: maestría . maestría consigue dos formas: conocimientos trabajo. debe adquirir conocimiento los principios, patrones, prácticas heurística propios maestro, dominar dichos conocimientos través práctica. puedo enseñarle teoría montar bicicleta. hecho, los conceptos matemáticos clásicos son muy sencillos. gravedad, fricción, velocidad angular, centro masa, etc., pueden demostrar menos una página repleta ecuaciones. con esas fórmulas, puedo demostrar que montar bicicleta práctico proporcionarle los conocimientos necesarios para conseguirlo. pero primera vez que monte una bici caerá suelo. diseño código diferente. podríamos enumerar todos los principios del código limpio confiar que encargue del resto ( decir, dejar que cayera bici) pero entonces pregunta sería qué clase profesores somos qué clase alumno sería. . así funciona este libro. aprender crear código limpio complicado . requiere algo más que conocer principios patrones. tiene que sudar. debe practicarlo fallar. debe ver cómo otros practican fallan. debe observar cómo caen recuperan paso. debe ver cómo agonizan cada decisión precio que pagan por tomar decisiones equivocadas. para leer este libro, prepárese trabajar duro. libro que pueda leer avión terminarlo antes aterrizar. este libro hará trabajar, mucho. ¿ qué tipo trabajo? tendrá que leer código, abundancia. pedirá que piense qué acierta código qué falla. pedirá que siga nuestras descripciones mientras despedazamos módulos los volvemos ensamblar. para ello necesitará tiempo esfuerzo, pero creemos que merece pena. hemos dividido libro tres partes. los primeros capítulos describen principios, patrones prácticas para crear código limpio. incluyen abundante código resultan difíciles leer. sirven como preparación segunda parte. abandona tras leer primera sección, que tenga buena suerte. segunda parte del libro más difícil. incluye varios casos estudio cuya complejidad aumentando. cada ejemplo ejercicio limpieza código, transformar código con problemas para que tenga menos problemas. detalle esta parte abundante . tendrá que alternar entre texto los listados código. tendrá que analizar entender código, comprender razonamiento cada cambio realizado. piense que esta parte llevará varios días . tercera parte del libro único capítulo que contiene una lista heurística síntomas código erróneo ( smells ) confeccionada crear los casos prácticos. analizar limpiar código los ejemplos, documentamos motivo todas nuestras acciones como heurística síntoma. intentamos comprender nuestras reacciones código que leíamos modificábamos, nos esforzamos por capturar las sensaciones que tuvimos las decisiones que adoptamos. resultado una base conocimientos que describe cómo pensamos cuando creamos, leemos limpiamos código. esta base conocimientos servirá mucho lee atentamente los casos segunda parte del libro. esos capítulos hemos anotado con precisión todos los cambios realizados con referencias heurística. estas referencias muestran entre corchetes, como []. este modo puede ver contexto que aplicado creado dicha heurística. importa tanto propio valor las heurísticas sino relación entre ellas las decisiones adoptadas limpiar código los ejemplos . lee primera tercera parte salta los casos prácticos, habrá leído otro libro distinto sobre cómo crear código correcto, pero dedica tiempo analizar los casos, sigue todos cada uno los pasos, cada una las decisiones, pone nuestro lugar obliga pensar tal como hicimos nosotros, entonces comprenderá mucho mejor todos los principios, patrones, prácticas heurística. será conocimiento superficial. convertirá algo profundo. integrará misma forma que una bicicleta convierte una extensión propia una vez dominada forma . imagen cubierta imagen portada : galaxia del sombrero. encuentra virgo, unos millones años luz, núcleo súper agujero negro que pesa aproximadamente mil millones masas solares. ¿ imagen recuerda explosión luna praxis klingon? recuerdo escena star trek que mostraba anillo restos flotando tras explosión. tras esa escena, anillo convertido elemento habitual las explosiones ciencia ficción. incluso añadió explosión alderaan ediciones posteriores primera película guerra las galaxias. ¿qué provocó formación este anillo alrededor ? ¿por qué tiene centro tales dimensiones núcleo tan brillante diminuto? parece como agujero negro central hubiera provocado orificio años luz centro galaxia. desgracia caería sobre las civilizaciones que encontraran camino este desastre cósmico. los súper agujeros negros desayunan estrellas convierten parte masa energía. = puede bastar, pero cuando una masa estelar hay que tener cuidado. ¿cuántas estrellas habrá engullido este monstruo antes saciar apetito? tamaño del vacío central podría ser una pista. imagen portada una combinación famosa fotografía del hubble (imagen superior) reciente imagen infrarrojos del observatorio orbital spitzer (inferior). esta última muestra claramente forma anillo galaxia. luz, sólo vemos borde frontal silueta del anillo. portada: © spitzet space telescope. masa central oculta resto. pero imagen infrarrojos, las partículas calientes del anillo brillan través masa central. las dos imágenes combinadas nos ofrecen una vista desconocida hasta ahora implican que hace tiempo era auténtico infierno activo. código limpio está leyendo este libro por dos motivos. por lado, programador. por otro, quiere ser mejor programador. perfecto. necesitamos mejores . este libro trata sobre programación correcta. está repleto código. analizaremos desde todas las direcciones. desde arriba, desde abajo desde dentro. cuando terminemos, sabremos mucho sobre código , especial sabremos distinguir entre código correcto incorrecto. sabremos cómo escribir código correcto cómo transformar código incorrecto código correcto. hágase código podría afirmar que libro sobre código algo obsoleto, que código problema que deberíamos centrarnos modelos requisitos. hay quienes sugieren que final del código está próximo. que los programadores serán necesarios porque los empresarios generarán programas partir especificaciones. cierto. código nunca desaparecerá, que representa los detalles los requisitos. algún nivel, dichos detalles pueden ignorar abstraer; deben especificarse, para especificar requisitos forma que equipo pueda ejecutarlos necesita programación. dicha especificación código. espero que nivel abstracción nuestros lenguajes siga aumentando. también espero que aumente número lenguajes específicos dominios. será algo positivo, pero eliminará código. hecho, todas las especificaciones creadas estos lenguajes nivel superior específicos los dominios serán código, tendrá que ser riguroso, preciso, formal detallado para que equipo pueda entenderlo ejecutarlo. que piense que código desaparecer como matemático que espera que día las matemáticas sean formales. esperan descubrir una forma crear máquinas que hagan que queramos lugar que digamos. esas máquinas tendrían que entendernos tal forma que puedan traducir necesidades ambiguas programas perfectamente ejecutados que satisfagan dichas necesidades perfección. esto nunca sucederá. siquiera los humanos, con toda intuición , han sido capaces crear sistemas satisfactorios partir las sensaciones sus clientes. realidad, disciplina especificación requisitos nos enseñado algo que los requisitos bien especificados son tan formales como código que pueden actuar como pruebas ejecutables dicho código. recuerde que código básicamente lenguaje que expresamos los requisitos última instancia. podemos crear lenguajes que asemejen dichos requisitos. podemos crear herramientas que nos permitan analizar combinar dichos requisitos estructuras formales, pero nunca eliminaremos precisión necesaria; por ello, siempre habrá código. código incorrecto recientemente leí prólogo del libro implementation pattern [] kent beck, donde afirmaba que «…este libro basa una frágil premisa: que código correcto relevante…». ¿una frágil premisa? absoluto. considero que una las más robustas, admitidas importantes nuestro sector ( creo que kent sabe). sabemos que código correcto relevante porque durante mucho tiempo hemos tenido que sufrir ausencia. una empresa que, finales década , creó una magnífica aplicación, muy popular que muchos profesionales compraron utilizaron. pero los ciclos publicación empezaron distanciarse. corrigieron los errores entre una versión siguiente. crecieron los tiempos carga aumentaron los fallos. todavía recuerdo día que apagué producto nunca más volví usar. poco después, empresa desapareció. décadas después conocí uno los empleados empresa pregunté sobre que había pasado. respuesta confirmó mis temores. habían comercializado producto antes tiempo con graves fallos código. añadir nuevas funciones, código empeoró hasta que pudieron controlarlo. código incorrecto fue motivo del fin empresa . ¿ alguna ocasión código incorrecto supuesto obstáculo? programador seguramente . hecho, tenemos una palabra que describe: sortear . tenemos que sortear código incorrecto. nos arrastramos por una maraña zarzas trampas ocultas. intentamos buscar camino, una pista que está pasando, pero único que vemos más más código sin sentido. sin duda código incorrecto supuesto obstáculo. entonces, ¿por qué escribió? ¿tenía prisa? ¿plazos entrega? seguramente. puede que pensara que tenía tiempo para hacer buen trabajo; que jefe enfadaría necesitaba tiempo para limpiar código. puede que estuviera cansado trabajar ese programa quisiera acabar cuanto antes. que viera trabajo pendiente tuviera que acabar con módulo para pasar siguiente. todos nos pasado. todos hemos visto lío que estábamos hemos optado por dejarlo para otro día. todos hemos sentido alivio ver cómo programa incorrecto funcionaba hemos decidido que mal programa que funciona mejor que nada. todos hemos dicho que solucionaríamos después. evidentemente, por aquel entonces, conocíamos ley leblanc: después igual nunca . coste total desastre programador desde hace dos tres años, probablemente haya sufrido los desastres cometidos por otros código. tiene más experiencia, habrá sufrido mayor medida. grado sufrimiento puede ser significativo. periodo año dos, los equipos que avancen rápidamente inicio proyecto pueden acabar paso tortuga. cada cambio código afecta dos tres partes del mismo. ningún cambio trivial. para ampliar modificar sistema necesario comprender todos los detalles, efectos consecuencias, para ese modo poder añadir nuevos detalles, efectos consecuencias. con tiempo, desastre aumenta tal modo que puede remediar. imposible. aumentar este desastre, productividad del equipo disminuye acaba por desaparecer. reducirse productividad, director hace único que puede: ampliar plantilla del proyecto con esperanza aumentar productividad. pero esa nueva plantilla conoce diseño del sistema. conocen diferencia entre cambio adecuado objetivo diseño otro que destroce. por tanto, todos encuentran sometidos una gran presión para aumentar productividad. por ello, cometen más errores, aumenta desastre productividad acerca cero cada vez más (véase figura .). figura .. productividad frente tiempo. gran cambio diseño última instancia, equipo rebela. informan director que pueden seguir trabajando con ese código. exigen cambio diseño. dirección requiere invertir cambio diseño del proyecto, pero puede ignorar bajo nivel productividad. por ceder las exigencias los programadores autoriza gran cambio diseño. selecciona nuevo equipo. todos quieren formar parte del nuevo equipo por ser lienzo blanco. pueden empezar cero crear algo realmente bello, pero sólo los mejores serán elegidos para nuevo equipo. los demás deben continuar con mantenimiento del sistema actual. ahora los dos equipos compiten. nuevo debe crear sistema que haga que antiguo puede. además, deben asumir los cambios que continuamente aplican sistema antiguo. dirección sustituirá sistema antiguo hasta que nuevo sea capaz hacer todo que hace antiguo. esta competición puede durar mucho tiempo. conozco casos casi años. cuando acaba, los miembros originales del equipo nuevo han desaparecido los miembros actuales exigen cambio diseño del nuevo sistema porque desastre. experimentado alguna fase esta historia, sabrá que dedicar tiempo que código sea correcto sólo rentable, una cuestión supervivencia profesional. actitud ¿alguna vez tenido que superar desastre tan grave que tardado semanas que normalmente hubiera tardado horas? ¿ visto cambio que debería haberse realizado una línea, aplicado cientos módulos distintos? son síntomas demasiado habituales. ¿por qué sucede código? ¿por qué código calidad transforma tan rápidamente código incorrecto? hay muchas explicaciones. nos quejamos que los requisitos cambian forma que comprometen diseño original, que los plazos entrega son demasiado exigentes para hacer las cosas bien. culpamos directores incompetentes, usuarios intolerantes comerciales sin sentido. pero culpa, querido dilbert, nuestra. somos profesionales. puede que resulte duro escucharlo. ¿cómo posible que seamos responsables tales desastres? ¿qué pasa con los requisitos? ¿ los plazos entrega? ¿ los directores incompetentes los comerciales sin sentido? ¿ también culpa suya? . los directores los comerciales nos exigen información que necesitan para realizar sus promesas compromisos, incluso cuando recurren nosotros, debemos tener miedo decirles que pensamos. los usuarios acuden nosotros para validar forma encajar los requisitos sistema. los directores proyectos acuden nosotros para determinar los objetivos. somos cómplices programación del proyecto compartimos gran parte responsabilidad los fallos, especial tienen que ver con código incorrecto. seguramente piense que, hace que jefe dice, despedirán. improbable. muchos jefes sólo quieren verdad, aunque disimulen. muchos quieren código correcto, aunque estén obsesionados con los objetivos. pueden defender apasionadamente los objetivos los requisitos, pero trabajo. nuestro defender código con misma intensidad. para resumir, imagine que médico paciente exige que lave las manos antes una operación porque pierde demasiado tiempo [] . este caso, paciente jefe, pero médico debe negarse que pide. ¿por qué? porque médico sabe más que paciente sobre los riesgos infecciones. sería profesional (incluso sería ilegal) que médico cediera las exigencias del paciente. tampoco sería profesional que los programadores cedieran voluntad los jefes que entienden los riesgos posible desastre. enigma los programadores enfrentan enigma valores básicos. los que tienen años experiencia saben que desastre ralentiza trabajo, aun así todos los programadores sienten presión cometer errores para poder cumplir los plazos entrega. definitiva, toman tiempo necesario para avanzar. los verdaderos profesionales saben que segunda parte del enigma cierta. cumple plazo entrega cometiendo error. hecho, error nos ralentiza forma inmediata hace que lleguemos plazo entrega. única forma cumplirlo, única forma avanzar, intentar código siempre sea limpio. ¿ arte del código limpio? imagine que cree que código incorrecto obstáculo significativo. imagine que acepta que única forma avanzar mantener código limpio. entonces preguntará cómo crear código limpio. tiene sentido intentar crearlo sabe que . mala noticia que crear código limpio como pintar cuadro. muchos sabemos cuadro pintado bien , pero poder reconocer calidad una obra significa que sepamos pintar. por ello, reconocer código limpio significa que sepamos cómo crearlo. para crearlo requiere uso disciplinado miles técnicas aplicadas mediante detallado sentido «corrección». este sentido del código clave. algunos nacen con este sentido. otros han luchar para conseguirlo. sólo permite distinguir entre código correcto incorrecto, sino que también muestra estrategia para aplicar nuestra disciplina transformar código incorrecto código correcto. programador sin este sentido puede reconocer desastre cometido módulo, pero saber cómo solucionarlo. programador con este sentido verá las posibles opciones elegirá variante óptima para definir una secuencia cambios. definitiva, programador que cree código limpio artista que puede transformar lienzo blanco sistema código elegante. concepto código limpio existen tantas definiciones como programadores. por ello, consultado opinión conocidos experimentados programadores. bjarne stroustrup, inventor ++ autor the ++ programming language gusta que código sea elegante eficaz. lógica debe ser directa para evitar errores ocultos, las dependencias deben ser mínimas para facilitar mantenimiento, procesamiento errores completo sujeto una estrategia articulada, rendimiento debe ser óptimo para que los usuarios tiendan estropear código con optimizaciones sin sentido. código limpio hace bien una cosa. bjarne usa palabra «elegante». menuda palabra. según diccionario, «elegante» significa « dotado gracia, nobleza sencillez ». aparentemente bjarne piensa que código limpio placer hora leerlo. lectura debe hacernos sonreír, como una caja música coche bien diseñado. bjarne también menciona eficacia, dos ocasiones . debería sorprendemos viniendo del inventor ++; pero considero que hay algo más que mero deseo velocidad. los ciclos malgastados son elegantes, son placer. fíjese palabra empleada por bjarne para describir consecuencia esta falta elegancia. usa tiendan . una gran verdad. código incorrecto tiende aumentar desastre. cuando otros cambian código incorrecto, tienden empeorarlo. dave thomas andy hunt expresan forma diferente. usan metáfora las ventanas rotas [] . edificio con ventanas rotas parece abandonado. hace que otros abandonen. dejan que rompan otras ventanas. incluso las rompen propósito. fachada ensucia con pintadas acumula basura. una ventana rota inicia proceso decadencia. bjarne también menciona que procesamiento errores debe ser completo, que relaciona con disciplina prestar atención los detalles. procesamiento errores abreviado una forma ignorar los detalles. otras son las fugas memoria, las condiciones carrera uso los nombres. definitiva, código limpio muestra gran atención detalle. bjarne termina afirmando que código limpio hace una cosa bien . accidental que existan tantos principios diseño software que puedan reducir esta sencilla máxima. muchos escritores han tratado comunicar este pensamiento. código incorrecto intenta hacer demasiadas cosas cometido ambiguo enrevesado. código limpio concreto . cada función, cada clase cada módulo muestran una única actitud que mantiene invariable contamina por los detalles circundantes. grady booch, autor object oriented analysis and design with applications código limpio simple directo. código limpio lee como texto bien escrito. código limpio oculta intención del diseñador, sino que muestra nítidas abstracciones líneas directas control. grady mantiene las mismas ideas que bjarne, pero adopta una perspectiva legibilidad . gusta especialmente que código limpio pueda leer como texto bien escrito. piense buen libro. recordará que las palabras desaparecen sustituyen por imágenes, como ver una película. mejor todavía. ver los caracteres, escuchar los sonidos, experimentar las sensaciones. leer código limpio nunca será como leer señor los anillos . pero esta metáfora literaria incorrecta. como una buena novela, código limpio debe mostrar forma clara suspense del problema que hay que resolver. debe llevar ese suspense hasta punto álgido para después demostrar lector que los problemas suspense han solucionado forma evidente. frase «nítida abstracción» grady oxímoron fascinante. nítido casi sinónimo concreto, con potente mensaje. código debe ser específico especulativo. sólo debe incluir necesario. nuestros lectores deben percibir que hemos tomado decisiones. «big» dave thomas, fundador oti, padrino estrategia eclipse código limpio puede leer mejorar por parte programador que sea autor original. tiene pruebas unidad aceptación. tiene nombres con sentido. ofrece una varias formas hacer algo. sus dependencias son mínimas, definen forma explícita ofrece una api clara mínima. código debe ser culto función del lenguaje, que toda información necesaria puede expresar forma clara código. big dave comparte deseo grady legibilidad, pero con una importante variante. dave afirma que código limpio facilita las labores mejora otros . puede parecer evidente pero debemos excedernos. después todo, existe una diferencia entre código fácil leer código fácil cambiar. dave vincula limpieza las pruebas. hace años esto hubiera provocado cierta controversia. pero disciplina del desarrollo controlado por pruebas tenido gran impacto nuestro sector convertido uno sus pilares. dave tiene razón. código, sin pruebas, limpio. independientemente elegancia, legibilidad accesibilidad, tiene pruebas, será limpio. dave usa dos veces palabra mínimo . valora código tamaño , una opinión habitual literatura software desde concepción. cuanto más pequeño, mejor. también afirma que código debe ser culto , una referencia indirecta programación knuth [] que definitiva indica que código debe redactarse una forma legible para los humanos. michael feathers, autor working effectively with legacy code podría enumerar todas las cualidades del código limpio, pero hay una principal que engloba todas ellas. código limpio siempre parece que sido escrito por alguien quien importa. hay nada evidente que hacer para mejorarlo. autor del código pensó todos los aspectos posibles intentamos imaginar alguna mejora, volvemos punto partida sólo nos queda disfrutar del código que alguien quien importa realmente nos proporcionado. una palabra; dar importancia. verdadero tema este libro, que incluso podría usar subtítulo « cómo dar importancia código ». michael acertado pleno. código limpio aquél que dado importancia. alguien dedicado tiempo para que sea sencillo prestado atención los detalles. preocupado. ron jeffries, autor extreme programming installed extreme programming adventures # comenzó carrera como programador con fortran strategic air command escrito código para práctica totalidad lenguajes equipos. merece pena fijarse sus palabras: los últimos años, comencé prácticamente terminé con las reglas código simple beck. orden prioridad, código simple: ejecuta todas las pruebas. contiene duplicados. expresa todos los conceptos diseño del sistema. minimiza número entidades como clases, métodos, funciones similares. todos ellos, quedo con duplicación. cuando algo repite una otra vez, una señal que tenemos una idea que acabamos representar correctamente código. intento determinar cuál , después, expresar esa idea con mayor claridad. para , expresividad debe incluir nombres con sentido estoy dispuesto cambiar los nombres las cosas varias veces. con las modernas herramientas creación código como eclipse, cambio nombres muy sencillo, por que supone problema alguno. expresividad más allá los nombres. también fijo objeto método hacen más una cosa. trata objeto, probablemente tenga que dividirse dos más. trata método, siempre recurro refactorización extracción métodos para generar método que exprese con mayor claridad cometido varios métodos secundarios que expliquen cómo hace. duplicación expresividad son dos factores que permiten mejorar considerablemente código que sea limpio. sin embargo, otra cosa que también hago conscientemente, aunque sea más difícil explicar. tras años este trabajo, creo que todos los programas están formados elementos muy similares. ejemplo búsqueda elementos una colección. independientemente que sea una base datos registros empleados mapa claves valores, una matriz elementos, por general tenemos que buscar elemento concreto esa colección. cuando esto sucede, suelo incluir esa implementación concreta método una clase más abstractos. ese modo disfruto una serie interesantes ventajas. puedo implementar funcionalidad con algo sencillo, como mapa hash, por ejemplo, pero como ahora todas las referencias búsqueda ocultan pequeña abstracción, puedo modificar implementación siempre que desee. puedo avanzar rápidamente tiempo que conservo posibilidad realizar cambios posteriores. además, abstracción colección suele captar atención que realmente sucede impide que implemente comportamientos colecciones arbitrarias que realmente necesito una forma sencilla localizar elemento. reducir los duplicados, maximizar expresividad diseñar sencillas abstracciones las fases iniciales. para , que hace que código sea limpio. estos breves párrafos, ron resume contenido este libro. nada duplicados, objetivo, expresividad pequeñas abstracciones. todo está ahí. ward cunningham, inventor wiki, fit, uno los inventores programación extreme. uno los impulsores los patrones diseño. una las mentes tras smalltalk programación orientada objetos. padrino todos los que les importa código. que estamos trabajando con código limpio cuando cada rutina que leemos resulta ser que esperábamos. puede denominar código atractivo cuando código hace que parezca que lenguaje creado para problema cuestión. este tipo afirmaciones son características ward. las leemos, asentimos pasamos siguiente. tan razonable evidente que apenas parece profundo. incluso podemos pensar que que esperábamos. pero preste atención. «… resulta ser que esperábamos». ¿cuándo fue última vez que vio módulo que fuera más menos que esperaba? ¿ habitual ver módulos complicados enrevesados? ¿ esta falta concreción habitual? ¿ está acostumbrado intentar extraer razonamiento sistema para llegar módulo que está leyendo? ¿cuándo fue última vez que leyó código asintió como seguramente haya hecho leer afirmación ward? ward espera que leer código limpio sorprenda. hecho, siquiera tendrá que esforzarse. leerá será prácticamente que esperaba. será evidente, sencillo atractivo. cada módulo prepara camino del siguiente. cada uno indica cómo escribirá siguiente. los programas limpios están tan bien escritos que siquiera dará cuenta. diseñador consigue simplificarlo todo enormemente, como sucede con todos los diseños excepcionales. ¿ noción atractivo ward? todos hemos criticado que nuestros lenguajes hayan diseñado para nuestros problemas. pero afirmación ward hace que ahora responsabilidad sea nuestra. afirma que código atractivo hace que lenguaje parezca creado para problema . por tanto, somos responsables que lenguaje parezca sencillo. lenguaje que hace que los programas parezcan sencillos, sino programador que consigue que lenguaje parezca. pensamiento ¿ (uncle bob)? ¿qué para código limpio? este libro contaremos, con todo detalle, que mis colegas pensamos del código limpio. contaremos que pensamos que hace que nombre variable, una función una clase sean limpias. presentaremos estas opiniones forma absoluta, sin disculparnos. este punto nuestra carrera, son absolutas. son nuestra escuela pensamiento del código limpio. los especialistas las artes marciales ponen acuerdo sobre cuál mejor todas, siquiera sobre cuál mejor técnica arte marcial. habitual que los maestros las artes marciales creen sus propias escuelas pensamiento los alumnos aprendan ellos. esta forma nació gracie jiu jitsu , creada impartida por familia gracie brasil; hakkoryu jiu jitsu , fundada impartida por okuyama ryuho tokio jeet kune , fundada impartida por bruce lee estados unidos. los alumnos estas disciplinas sumergen las enseñanzas del fundador. dedican aprender que maestro les enseña suelen excluir las enseñanzas otros maestros. después, cuando han mejorado arte, pueden convertirse alumnos otro maestro diferente para ampliar sus conocimientos experiencia. algunos seguirán mejorando sus habilidades, descubriendo nuevas técnicas fundando sus propias escuelas. ninguna estas escuelas tiene razón absoluta pero dentro cada una actuamos como las enseñanzas las técnicas fueran correctas. después todo, existe una forma correcta practicar hakkoryu jiu jitsu jeet kune , pero esta corrección dentro una escuela determinada anula las enseñanzas otra diferente. que este libro una descripción escuela mentores del código limpio . las técnicas enseñanzas impartidas son forma que practicamos nuestro arte. podemos afirmar que, sigue nuestras enseñanzas, disfrutará que hemos disfrutado nosotros, aprenderá crear código limpio profesional. pero cometa error pensar que somos los únicos que tenemos razón. existen otras escuelas otros maestros tan profesionales como nosotros, labor aprender ellos también. hecho, muchas las recomendaciones del libro son controvertidas, seguramente esté acuerdo con muchas ellas puede que rechace algunas forma definitiva. correcto. somos autoridad final. pero, por otra parte, las recomendaciones del libro son algo que hemos pensado mucho. las hemos aprendido tras décadas experiencia ensayo error. por tanto, esté acuerdo, sería una lástima que apreciara, respetara, nuestro punto vista. somos autores campo @author javadoc indica quiénes somos. somos autores. los autores tienen lectores. hecho, los autores son responsables comunicarse correctamente con sus lectores. próxima vez que escriba una línea código, recuerde que autor que escribe para que sus lectores juzguen esfuerzo. seguramente pregunte qué cantidad código lee realmente mayor parte del esfuerzo concentra crearlo. ¿alguna vez reproducido una sesión edición? las décadas teníamos editores como emacs que controlaban cada pulsación tecla. podía trabajar durante una hora después reproducir sesión edición completa como una película alta velocidad. cuando hice, los resultados fueron fascinantes. mayor parte reproducción eran desplazamientos entre módulos. bob accede módulo. desplaza hasta función que tiene que cambiar. detiene piensa las posibles opciones. , vuelve inicio del módulo para comprobar inicialización una variable. ahora vuelve bajar comienza escribir. vaya, borra que había escrito. vuelve escribirlo. vuelve borrar. escribe algo diferente pero también borra. desplaza otra función que invoca función que está modificando para comprobar cómo invoca. vuelve subir escribe mismo código que acaba borrar. detiene. vuelve borrar código. abre otra ventana examina las subclases. ¿ reemplazado esa función? … hace una idea. realidad, proporción entre tiempo dedicado leer frente tiempo dedicado escribir más :. constantemente tenemos que leer código antiguo como parte del esfuerzo crear código nuevo. ser una proporción tan elevada, queremos que lectura del código sea sencilla, aunque eso complique creación. evidentemente, puede escribir código sin leerlo, modo que más fácil leer será más fácil escribir . una lógica sin escapatoria. puede escribir código puede leer código circundante. código que intente escribir hoy será fácil difícil escribir función fácil difícil leer que sea código circundante. quiere avanzar rápidamente, terminar cuanto antes que código sea fácil escribir, haga que sea fácil leer. regla del boy scout basta con escribir código correctamente. código debe limpiarse con tiempo. todos hemos visto que código corrompe con tiempo, modo que debemos adoptar papel activo para evitarlo. los boy scouts norteamericanos tienen una sencilla regla que podemos aplicar nuestra profesión: dejar campamento más limpio que encontrado [] . todos entregamos código más limpio que hemos recibido, corromperá. hace falta que limpieza sea masiva. cambie nombre una variable, divida una función demasiado extensa, elimine elementos duplicados, simplifique una instrucción compuesta. ¿ imagina trabajar proyecto que código mejorara con tiempo? ¿cree que hay otras opciones que puedan considerarse profesionales? hecho, ¿ mejora continuada una parte intrínseca profesionalidad? precuela principios muchos aspectos, este libro una «precuela» otro que escribí titulado agile software development: principles, patterns, and practices (ppp). libro ppp trata sobre los principios del diseño orientado objetos muchas las técnicas empleadas por desarrolladores profesionales. leído ppp, comprobará que continúa historia contada este libro. leído, encontrará muchas las sensaciones ese libro reproducidas éste nivel del código. este libro encontrará referencias esporádicas distintos principios diseño como srp ( single responsibility principle principio responsabilidad única), ocp ( open closed principle principio abierto/cerrado) dip ( dependency inversion principle principio inversión dependencias) entre otros. todos estos principios describen detalladamente ppp. los libros sobre arte prometen que convertirá artista. solamente pueden mostrarle herramientas, técnicas procesos pensamiento que otros artistas hayan utilizado. del mismo modo, este libro puede prometer que convierta buen programador, que tenga sentido del código. sólo puede mostrarle los procesos pensamiento buenos programadores los trucos, técnicas herramientas que emplean. igual que libro sobre arte, este libro está repleto detalles. encontrará mucho código. verá código correcto código incorrecto. verá código incorrecto transformado código correcto. verá listas heurística, disciplinas técnicas. verá ejemplo tras otro. después todo, será responsabilidad suya. ¿recuerda chiste sobre violinista que pierde camino concierto? cruza con anciano pregunta cómo llegar teatro real. anciano mira violinista violín que lleva bajo brazo responde: «practique joven, practique». bibliografía [beck] : implementation patterns , kent beck, addison-wesley, . [knuth] : literate programming , donald . knuth, center for the study language and information, leland stanford junior university, . nombres con sentido por tim ottinger introducción software , los nombres son omnipresentes. aparecen variables, , argumentos, clases paquetes. asignamos nombres archivos directorios, archivos jar, war ear. usamos nombres constantemente. por ello, debemos hacerlo bien. continuación, veremos algunas reglas básicas para crear nombres correctos. usar nombres que revelen las intenciones fácil afirmar que los nombres deben revelar nuestras intenciones. que queremos recalcar importancia hacerlo. elegir nombres correctos lleva tiempo, pero también ahorra trabajo. por ello, preste atención los nombres cámbielos cuando encuentre otros mejores. todo que lea código agradecerá. nombre una variable, función clase debe responder una serie cuestiones básicas. debe indicar por qué existe, qué hace cómo usa. nombre requiere comentario, significa que revela cometido. int ; // tiempo transcurrido días nombre revela nada. evoca una sensación tiempo transcurrido, días. debe elegir nombre que especifique que mide unidad dicha medida: int elapsedtimeindays; int dayssincecreation; int dayssincemodification; int fileageindays; elección nombres que revelen intenciones facilita considerablemente comprensión modificación del código. ¿para qué sirve siguiente código? public list<int[] getthem() { list<int[] list = new arraylist<int[](); for (int[] : thelist) ([] == ) list.add(); return list; } ¿por qué complicado saber función este código? hay expresiones complejas. los espacios sangrado son razonables. sólo hay tres variables dos constantes. siquiera contiene clases complejas polimórficos, sólo una lista matrices ( eso parece). problema simplicidad del código sino carácter implícito : grado que contexto explícito propio código. implícitamente, código requiere que sepamos las respuestas las siguientes preguntas: ¿qué contiene thelist ? ¿qué significado tiene subíndice cero elemento thelist ? ¿qué importancia tiene valor ? ¿cómo usa lista devuelta? las respuestas estas preguntas encuentran código, pero podrían haber incluido. imagine que trabaja juego buscar minas. tablero una lista celdas llamada thelist . cambiemos nombre por gameboard . cada celda del teclado representa por medio una matriz. subíndice cero ubicación valor estado que, cuando , significa que detectado. asignar nombres estos conceptos mejoramos considerablemente código: public list<int[] getflaggedcells() { list<int[] flaggedcells = new arraylist<int[](); for (int[] cell : gameboard) (cell[status_value] == flagged) flaggedcells.add(cell); return flaggedcells; } simplicidad del código cambiado. sigue teniendo los mismos operadores constantes mismo número niveles anidados, pero ahora mucho más explícito. podemos crear una sencilla clase para celdas lugar usar una matriz elementos int . puede incluir una función que revele objetivo (con nombre isflagged ) para ocultar los números. resultado una nueva versión función: public list<cell getflaggedcells() { list<cell flaggedcells = new arraylist<cell(); for (cell cell : gameboard) (cell.isflagged()) flaggedcells.add(cell); flaggedcells; } con estos sencillos cambios nombre, fácil saber qué sucede. ventaja seleccionar nombres adecuados. evitar desinformación los programadores deben evitar dejar pistas falsas que dificulten significado del código. debemos evitar palabras cuyo significado aleje del que pretendemos. por ejemplo, , aix sco son nombres variables pobres que son los nombres plataformas variantes unix. aunque trate del código una hipotenusa parezca abreviatura correcta, puede serlo. haga referencia grupo cuentas como accountlist menos que realmente sea una lista ( list ). palabra lista tiene significado concreto para los programadores. contenedor las cuentas realmente una lista, puede provocar falsas conclusiones [] . por tanto, resulta más adecuado usar accountgroup , bunchofaccounts simplemente accounts . evite usar nombres con variaciones mínimas. ¿cuánto tarda apreciar sutil diferencia entre xyzcontrollerforefficienthandlingofstrings xyzcontrollerforefficientstorageofstrings módulo? ambas palabras tienen una forma similar. ortografía similar conceptos parecidos información; uso ortografía incoherente desinformación. los entornos modernos java, código completa forma automática. escribimos varios caracteres nombre pulsamos varias teclas para obtener una lista posibles opciones nombre. muy útil los nombres elementos similares ordenan alfabéticamente forma conjunta las diferencias son muy evidentes, que probable que programador elija objeto por nombre sin fijarse los comentarios lista métodos proporcionados por una clase. ejemplo nombre desinformativo sería uso minúscula mayúscula como nombres variables, sobre todo combinados. problema, evidentemente, que parecen las constantes respectivamente: int = ; ( == ) = ; else = ; lector puede pensar que una invención, pero hemos visto código con abundancia estos elementos. caso, autor del código, sugirió usar una fuente distinta para que las diferencias fueran más evidentes, una solución que hubiera transmitido todos los futuros programadores como tradición oral documento escrito. problema resolvió con carácter definitivo sin necesidad crear nuevos productos, con tan sólo cambiar los nombres. realizar distinciones con sentido los programadores crean problema crear código únicamente dirigido compilador intérprete. por ejemplo, como puede usar mismo nombre para hacer referencia dos elementos distintos mismo ámbito, puede verse tentado cambiar nombre forma arbitraria. ocasiones hace escribiéndolo incorrectamente, que provoca que los errores ortográficos impidan compilación [] . basta con añadir series números palabras adicionales, aunque eso satisfaga compilador. los nombres tienen que ser distintos, también deben tener significado diferente. los nombres series numéricas ( , … ) son contrario los nombres intencionados. desinforman, simplemente ofrecen información; son una pista sobre intención del autor. fíjese siguiente: static void copychars(char [], char []) { for (int = ; < .length; ++) { [] = []; } } esta función lee mejor cuando usa source destination como nombres argumentos. las palabras adicionales son otra distinción sin sentido. imagine que tiene clase product. tiene otra clase con nombre productinfo productdata , habrá creado nombres distintos, pero con mismo significado. info data son palabras adicionales, como , the . incorrecto usar prefijos como the mientras distinción tenga sentido. imagine que usa para variables locales for para argumentos funciones [] . problema aparece cuando decide invocar variable thezork porque tiene otra variable con nombre zork . las palabras adicionales son redundantes. palabra variable debe incluirse nunca nombre una variable. palabra table debe incluirse nunca nombre una tabla. ¿ mejor namestring que name ? ¿podría ser name número coma flotante? caso afirmativo, incumple regla anterior sobre desinformación. imagine que encuentra una clase con nombre customer otra con nombre customerobject . ¿cuál sería distinción? ¿cuál representa mejor historial pagos cliente? existe una aplicación que ilustra. hemos cambiado los nombres para proteger culpable. veamos error exacto: getactiveaccount(); getactiveaccounts(); getactiveaccountinfo(); ¿cómo saben los programadores este proyecto qué función deben invocar? ausencia convenciones concretas, variable moneyamount distingue money , customerinfo distingue customer , accountdata distingue account themessage distingue message . debe diferenciar los nombres forma que lector aprecie las diferencias. nombres que puedan pronunciar los humanos nos dan bien las palabras. gran parte nuestro cerebro dedica concepto palabras. , por definición, las palabras son pronunciables. sería una pena malgastar esa parte nuestro cerebro dedicada lenguaje hablado. por tanto, cree nombres pronunciables. puede pronunciar, podrá explicarlo sin parecer tonto. factor importante, que programación una actividad social. conozco una empresa que usa genymdhms (fecha generación, año, mes, día, hora, minuto segundo) pronuncian tal cual. tengo costumbre pronunciar todo tal como veo escrito, forma que muchos analistas diseñadores acabaron por llamarme algo como «genimedemes». era chiste nos parecía divertido, pero realidad estábamos tolerando uso nombres pobres. teníamos que explicar las variables los nuevos programadores cuando las pronunciaban, usaban palabras inventadas lugar nombres correctos. compare: class dtarcrd { private date genymdhms; private date modymdhms; private final string pszqint = “”; /*… */ }; con: class customer { private date generationtimestamp; private date modificationtimestamp; private final string recordid = “”; /*… */ }; ahora puede mantener una conversación inteligente: «, mikey, fíjate este registro. marca tiempo generación para mañana. ¿cómo posible?» usar nombres que puedan buscar nombres una letra las constantes numéricas tienen problema: son fáciles localizar texto. puede detectar max_classes_per_student , pero número resulta más complicado. las búsquedas pueden devolver dígito como parte nombres archivo, otras definiciones constantes expresiones las que use con otra intención. mucho peor constante número extenso alguien intercambiado los dígitos, que genera error inmediato aparece búsqueda. del mismo modo, nombre una opción muy pobre para variables que programador tenga que buscar. letra más usada inglés aparece práctica totalidad los textos programa. este respecto, los nombres extensos superan los breves cualquier nombre que pueda buscar supera una constante código. personalmente prefiero nombres una letra que sólo puedan usar como variables locales dentro métodos breves. longitud nombre debe corresponderse tamaño ámbito []. una variable constante usa varios puntos del código, debe asignarle nombre que pueda buscar. compare: for (int =; <; ++) { += ([]*)/; } con: int realdaysperidealday = ; const int work_days_per_week = ; int sum = ; for (int = ; < number_of_tasks; ++) { int realtaskdays = taskestimate[] * realdaysperidealday; int realtaskweeks = (realdays / work_days_per_week); sum += realtaskweeks; } este ejemplo, sum nombre especialmente útil, pero menos puede buscar. usa una función más extensa, pero comprobará que resulta mucho más fácil buscar work_days_per_week que todas las instancias filtrar lista los casos con significado adecuado. evitar codificaciones tenemos suficientes codificaciones como para tener que añadir otras nuevas. codificar información tipos ámbitos nombre dificulta descodificación. parece razonable que todos los nuevos empleados tengan que aprender otro lenguaje codificación además del código con que van trabajar. una carga mental innecesaria hora intentar solucionar problema. los nombres codificados resultan impronunciables suelen escribirse forma incorrecta. notación húngara antiguamente, cuando trabajábamos con lenguajes los que longitud los nombres era reto, incumplíamos esta regla nuestro pesar. fortran forzaba las codificaciones convirtiendo primera letra tipo código. sus primeras versiones, basic sólo permitía una letra dígito. notación húngara () llevó nuevo nivel. consideraba muy importante api windows, donde todo era control entero, puntero long , puntero void una varias implementaciones string (con diferentes usos atributos). por aquel entonces, compilador comprobaba los tipos, modo que los programadores tenían que recordarlos. los lenguajes modernos disponemos sistemas tipos más completos los compiladores recuerdan los tipos los aplican. más, existe una tendencia usar clases funciones más breves para que los usuarios aprecien declaración las variables que usan. los programadores java tienen que codificar tipos. los objetos son tipos fuertes los entornos edición han avanzado tanto que detectan error tipo antes ejecutar compilación. por ello, actualidad otras formas codificación tipos son más que impedimento. hacen que sea más complicado cambiar nombre tipo una variable clase. dificultan legibilidad del código pueden hacer que sistema codificación confunda lector: phonenumber phonestring; // nombre cambia cuando cambia tipo miembros tampoco necesario añadir como prefijo los nombres variables. las clases funciones tienen tamaño necesario para tener que hacerlo, debe usar entorno edición que resalte coloree los miembros para distinguirlos. public class part { private string m_dsc; // descripción textual void setname(string name) { m_dsc = name; } } public class part { string description; void setdescription(string description) { this.description = description; } } además, los usuarios aprenden rápidamente ignorar prefijo ( sufijo) fijarse parte con sentido del nombre. cuanto más código leemos, menos nos fijamos los prefijos. última instancia, los prefijos son indicio código antiguo. interfaces implementaciones existe caso especial para usar codificaciones. imagine por ejemplo que crea una factoría abstracta para crear formas. esta factoría será una interfaz implementará por medio una clase concreta. ¿qué nombres debe asignar? ¿ ishapefactory shapefactory ? prefiero las interfaces sin adornos. inicial, tan habitual los archivos legado actuales , mejor los casos, una distracción, peor, exceso información. quiero que mis usuarios sepan que trata una interfaz, solamente que trata shapefactory . tengo que codificar interfaz implementación, opto por ésta última. mejor usar shapefactoryimp incluso cshapefactory , que codificar interfaz. asignaciones mentales los lectores tienen que traducir mentalmente sus nombres otros que conocen. este problema suele aparecer elegir entre usar términos dominio problemas soluciones. problema los nombres variables una sola letra. contador bucles podría bautizar como , (pero nunca ) ámbito muy reducido hay conflictos con otros nombres, que los nombres una letra son tradicionales contadores bucles. sin embargo, otros contextos, nombre una letra una opción muy pobre: como marcador posición que lector debe asignar mentalmente concepto real. hay peor motivo para usar nombre que estén seleccionados. por general, los programadores son gente inteligente. gente inteligente gusta presumir sus habilidades mentales. puede recordar que versión minúscula una url sin host sistema, debe ser muy listo. una diferencia entre programador inteligente programador profesional que este último sabe que claridad que importa . los profesionales usan sus poderes para hacer bien crean código que otros puedan entender. nombres clases las clases los objetos deben tener nombres frases nombre como customer , wikipage , account addressparser . evite palabras como manager , processor , data , info nombre una clase. nombre una clase debe ser verbo. nombres métodos métodos deben tener nombres verbo como postpayment , deletepage save . los métodos acceso, modificación los predicados deben tener como nombre valor usar como prefijo get , set acuerdo estándar javabean [] . string name = employee.getname(); customer.setname(“mike”); (paycheck.isposted())… sobrecargar constructores, use métodos factoría estáticos con nombres que describan los argumentos. por ejemplo: complex fulcrumpoint = complex.fromrealnumber(.); mejor que: complex fulcrumpoint = new complex(.); refuerce uso convirtiendo privados sus constructores correspondientes. exceda con atractivo los nombres son demasiado inteligentes, sólo los recordarán los que compartan sentido del humor autor, sólo mientras acuerden del chiste. ¿sabrán qué significa función holyhandgrenade ? sin duda atractiva, pero este caso puede que deleteitems fuera más indicado. opte por claridad antes que por entretenimiento. código, atractivo suele aparecer como formas coloquiales jergas. por ejemplo, use whack() lugar kill() . recurra bromas culturales como eatmyshorts() quiere decir abort() . diga que piense. piense que diga. una palabra por concepto elija una palabra por cada concepto abstracto manténgala. por ejemplo, confuso usar fetch , retrieve get como métodos equivalentes clases distintas. ¿cómo recordar qué método corresponde cada clase? desafortunadamente, tendrá que recordar qué empresa, grupo individuo creado biblioteca clase cuestión para recordar qué término empleado. caso contrario, perderá mucho tiempo buscando encabezados fragmentos código. los entornos edición modernos como eclipse intellij ofrecen pistas sensibles contexto, como lista métodos que puede invocar determinado objeto. pero esta lista suele incluir los comentarios nombres funciones listas parámetros. tendrá suerte muestra los nombres parámetros las declaraciones funciones. los nombres funciones deben ser independientes coherentes para que pueda elegir método correcto sin necesidad búsquedas adicionales. del mismo modo, resulta confuso tener controlador, administrador control misma base código. ¿cuál diferencia entre devicemanager protocolcontroller ? ¿por qué son los dos controladores administradores? ¿son controladores? nombre hace que espere que dos objetos tengan tipo diferente clases diferentes. léxico coherente una gran ventaja para los programadores que tengan que usar código. haga juegos palabras evite usar misma palabra con dos fines distintos. suele hacerse juegos palabras. aplica regla una palabra por conceptos, acabará con muchas clases que por ejemplo tengan método add . mientras las listas parámetros los valores devueltos los distintos métodos add sean semánticamente equivalentes, hay problema. sin embargo, alguien puede decidir usar palabra add por motivos coherencia, aunque sea mismo sentido. imagine que hay varias clases las que add crea nuevo valor sumando concatenando dos valores existentes. imagine ahora que crea una nueva clase con método añada parámetro una colección. ¿este método debe tener método add ? parece coherente que hay otros muchos métodos add , pero este caso hay una diferencia semántica, modo que debemos usar nombre como insert append . llamar add nuevo método sería juego palabras. nuestro objetivo, como autores, facilitar comprensión del código. queremos que código sea algo rápido, estudio exhaustivo. queremos usar modelo que autor sea responsable transmitir significado, modelo académico que exija investigar significado mostrado. usar nombres dominios soluciones recuerde que los lectores código serán programadores. por ello, use términos informáticos, algoritmos, nombres patrones, términos matemáticos demás. conviene extraer todos los nombres del dominio problemas que queremos que nuestros colegas tengan que preguntar significado cada nombre especial cuando conocen concepto bajo otro nombre diferente. nombre accountvisitor tiene mucho significado para programador familiarizado con patrón visitor . ¿qué programador sabe que jobqueue ? hay cientos cosas técnicas que los programadores tienen que hacer elegir nombres técnicos para dichas cosas suele ser más adecuado. usar nombres dominios problemas cuando exista término programación para que esté haciendo, use nombre del dominio problemas. menos programador que mantenga código podrá preguntar significado experto dominios. separar los conceptos dominio soluciones problemas parte del trabajo buen programador diseñador. código que tenga más relación con los conceptos del dominio problemas tendrá nombres dicho dominio. añadir contexto con sentido algunos nombres tienen significado por mismos, pero mayoría . por ello, debe incluirlos contexto, clases, funciones espacios nombres con nombres adecuados. cuando todo demás falle, pueden usarse prefijos como último recurso. imagine que tiene las variables firstname , lastname , street , housenumber , city , state ipcode . las combina, evidente que forman una dirección. pero variable state usa forma aislada método, ¿sabría que forma parte una dirección? puede añadir contexto por medio prefijos: addrfirstname , addrlastname , addrstate , etc. menos los lectores comprenderán que estas variables forman parte una estructura mayor. evidentemente, mejor crear clase address . ese modo, incluso compilador sabrá que las variables pertenecen concepto más amplio. fíjese método del listado -. ¿las variables necesitan contexto con más sentido? nombre función sólo ofrece parte del contexto, resto obtiene del algoritmo. tras leer función, verá que las tres variables number , verb pluralmodifier forman parte del mensaje guess statistics . desafortunadamente, necesario inferir contexto. leer método, significado las variables evidente. listado - variables contexto ambiguo. private void printguessstatistics(char candidate, int count) { string number; string verb; string pluralmodifier; (count == ) { number = “”; verb = “are”; pluralmodifier = “”; } else (count == ) { number = “”; = “”; pluralmodifier = “”; } else { number = integer.tostring(count); verb = “are”; pluralmodifier = “”; } string guessmessage = string.format( “there % % %%”, verb, number, candidate, pluralmodifier ); print(guessmessage); } función demasiado extensa las variables aparecen por todas partes. para dividir función fragmentos más reducidos necesitamos crear una clase guessstatisticsmessage convertir las tres variables campos misma. este modo contamos con contexto más obvio para las tres variables. forman parte sin duda guessstatisticsmessage . mejora del contexto también permite que algoritmo sea más limpio divida funciones más reducidas (véase listado -). listado - variables con contexto. public class guessstatisticsmessage ( private string number; private string verb; private string pluralmodifier; public string make(char candidate, int count) { createpluraldependentmessageparts(count); return string.format( “there % % %%, verb, number, candidate, pluralmodifier); } private void createpluraldependentmessageparts(int count) { (count == ) { therearenoletters(); } else (cout == ) { thereisoneletter(); } else { therearemanyletters(count); } } private void therearemanyletters(int count) { number = “”; = “”; pluralmodifier = “”; } private void thereisoneletter() { number = “”; verb = “”; pluralmodifier = “”; } private void therearenoletters() { number = “”; verb = “are”; pluralmodifier = “”; } } añadir contextos innecesarios aplicación imaginaria gas station deluxe, aconsejable usar prefijo gsd todas las clases. trabajar contra las herramientas proporcionadas. introduzca pulse tecla finalización para acceder una lista interminable todas las clases del sistema. ¿ correcto? ¿por qué dificultar ayuda del ide? del mismo modo, imagine que creado clase mailingaddress módulo contabilidad gsd , con nombre gsdaccountaddress . después, necesita una dirección correo para aplicación contacto con cliente. ¿usará gsdaccountaddress ? ¿ parece nombre correcto? los caracteres son redundantes irrelevantes. los nombres breves suelen ser más adecuados que los extensos, siempre que sean claros. añada más contexto del necesario nombre. los nombres accountaddress customeraddress son perfectos para instancias clase address pero sirven como nombres clase. address sirve como nombre clase. para distinguir entre direcciones mac, direcciones puertos direcciones web, podría usar postaladdress , mac uri . los nombres resultantes son más precisos, objetivo cualquier nombre. más complicado hora elegir buen nombre que requiere habilidad descriptiva acervo cultural. problema formación más que técnico, empresarial administrativo. como resultado, mucha gente del sector aprende hacerlo bien. gente teme que cambiar los nombres otros programadores quejen. nosotros compartimos ese temor agradecemos los cambios nombre (siempre que sean mejor). muchos casos memorizamos los nombres clases métodos. usamos herramientas modernas para estos detalles así poder centrarnos código lee como frases párrafos, menos como tablas estructuras datos (una frase siempre mejor forma mostrar datos). seguramente acabará sorprendiendo alguien cuando cambie los nombres, como puede suceder con cualquier otra mejora del código. deje que detenga. aplique estas reglas compruebe mejora legibilidad código. encargado mantener código terceros, use herramientas para solucionar estos problemas. obtendrá recompensas corto largo plazo. funciones los inicios programación, creábamos sistemas partir rutinas subrutinas. después, época fortran /, creábamos nuestros sistemas con programas, subprogramas funciones. actualidad, sólo las funciones han sobrevivido. son primera línea organizativa cualquier programa. este capítulo veremos cómo crearlas. fíjese código del listado -. complicado encontrar una función extensa fitnesse [] , pero acabé encontrando ésta. sólo extensa, sino que también contiene código duplicado, muchas cadenas tipos datos extraños, además api poco habituales nada evidentes. intente los próximos tres minutos. listado - htmlutil.java (fitnesse ). public static string testablehtml { pagedata pagedata, boolean includesuitesetup } throws exception { wikipage wikipage = pagedata.getwikipage(); stringbuffer buffer = new stringbuffer(); (pagedata.hasattribute(“test”)) { (includesuitesetup) { wikipage suitesetup = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_setup_name, wikipage ); (suitesetup != null) { wikipagepath pagepath = suitesetup.getpagecrawler().getfullpath (suitesetup); string pagepathname = pathparser.render(pagepath); buffer.append(“!include -setup .”) .append(pagepathname) .append(“\”); } } wikipage setup = pagecrawlerimpl.getinheritedpage(“setup”, wikipage); (setup != null) { wikipagepath setuppath = wikipage.getpagecrawler().getfullpath(setup); string setuppathname = pathparser.render(setuppath); buffer.append(“!include -setup .”) .append(setuppathname) .append(“\”); } } buffer.append(pagedata.getcontent()); (pagedata.hasattribute(“test”)) { wikipage teardown = pagecrawlerimpl.getinheritedpage(“teardown”, wikipage); (teardown != null) { wikipagepath teardownpath = wikipage.getpagecrawler().getfullpath(teardown); string teardownpathname = pathparser.render(teardownpath); buffer.append(“\”) .append(“!include -teardown .”) .append(teardownpathname) .append(“\”); } (includesuitesetup) { suiteteardown = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_teardown_name, wikipage ); (suiteteardown != null) { wikipagepath pagepath = suiteteardown.getpagecrawler().getfullpath (suiteteardown); string pagepathname = pathparser.render(pagepath); buffer.append(“!include -teardown .”) .append(pagepathname) .append(“\”); } } } pagedata.setcontent(buffer.tostring()); return pagedata.gethtml(); } ¿tras tres minutos entiende función? seguramente . pasan demasiadas cosas hay demasiados niveles abstracción diferentes. hay cadenas extrañas invocaciones funciones mezcladas instrucciones doblemente anidadas controladas por indicadores. sin embargo, con sencillas extracciones código, algún cambio nombres cierta reestructuración, pude capturar intención función las nueve líneas del listado -. compruebe ahora entiende. listado - htmlutil.java (refactorización). public static string renderpagewithsetupsandteardowns( pagedata pagedata, boolean issuite ) throws exception { boolean istestpage = pagedata.hasattribute(“test”); (istestpage) { wikipage testpage = pagedata.getwikipage(); stringbuffer newpagecontent = new stringbuffer(); includesetuppages (testpage, newpagecontent, issuite); newpagecontent.append(pagedata.getcontent()); includeteardownpages(testpage, newpagecontent, issuite); pagedata.setcontent(newpagecontent.tostring()); } return pagedata.gethtml(); } menos que sea alumno fitnesse, seguramente entienda los . entenderá que función encarga añadir páginas configuración detalles una página prueba, que después muestra html. está familiarizado con junit [] , verá que esta función pertenece algún tipo estructura pruebas basada web , evidentemente, correcto. resulta sencillo adivinar esta información del listado - pero del listado -. ¿qué tiene función del listado - para que resulte sencilla leer entender? ¿qué hay que hacer para que una función transmita intención? ¿qué atributos podemos asignar nuestras funciones para que lector pueda intuir tipo programa que pertenecen? tamaño reducido primera regla las funciones que deben ser tamaño reducido. segunda que deben ser todavía más reducidas . una afirmación que pueda justificar. puedo mostrar referencias estudios que demuestren que las funciones muy reducidas sean mejores. que puedo afirmar que durante casi cuatro décadas creado funciones diferentes tamaños. creado monstruos casi líneas otras muchas funciones entre líneas. también creado funciones líneas longitud. esta experiencia demostrado, mediante ensayo error, que las funciones deben ser muy reducidas. década decía que una función debía superar tamaño una pantalla. por aquel entonces, las pantallas tenían líneas por columnas, nuestros editores usaban líneas para tareas administrativas. actualidad, con una fuente mínima monitor gran tamaño, pueden encajar caracteres por línea líneas más una pantalla. las líneas deben tener caracteres. las funciones deben tener líneas longitud. las funciones deben tener una longitud aproximada líneas. ¿qué tamaño mínimo debe tener una función? visité kent beck casa oregon. nos sentamos comenzamos programar. enseñó atractivo programa java/swing que había llamado sparkle . generaba efecto visual pantalla, similar varita mágica del hada . mover ratón, salían estrellitas del cursor, descendían parte inferior pantalla campo gravitatorio simulado. cuando kent enseñó código, sorprendió brevedad las funciones. estaba acostumbrado ver programas swing con funciones que ocupaban kilómetros espacio vertical. este programa, las funciones tenían dos, tres cuatro líneas longitud. todas eran obvias. todas contaban una historia cada una llevaba siguiente orden atractivo. ¡así breves deberían ser todas las funciones! [] ¿qué tamaño mínimo deben tener sus funciones? deberían ser más breves que las del listado -. hecho, listado - debería reducirse como listado -. listado - htmlutil.java (nueva refactorización). public static string renderpagewithsetupsandteardowns( pagedata pagedata, boolean issuite) throws exception { (istestpage(pagedata)) includesetupandteardownpages(pagedata, issuite); return pagedata.gethtml(); } bloques sangrado esto implica que los bloques instrucciones , else , while similares deben tener una línea longitud que, seguramente, sea invocación una función. esta forma, sólo reduce tamaño función, sino que también añade valor documental que función invocada desde bloque puede tener nombre descriptivo. también implica que las funciones deben tener tamaño excesivo que albergue estructuras anidadas. por tanto, nivel sangrado una función debe ser mayor uno dos. evidentemente, esta forma las funciones son más fáciles leer entender. hacer una cosa evidente que listado - hace más una cosa. crea búferes, obtiene páginas, busca páginas heredadas, añade cadenas antiguas genera html. listado - está muy ocupado realizando varias tareas. por parte, listado - sólo hace una cosa: incluye configuraciones detalles páginas prueba. siguiente consejo lleva vigente, una otra forma, durante más años: las funciones sólo deben hacer una cosa. deben hacerlo bien debe ser único que hagan. problema esta afirmación saber qué una cosa. ¿ listado - hace una cosa? podría pensar que hace tres: . determinar página una página prueba. . caso afirmativo, incluir configuraciones detalles. . representar página html. ¿cuál será las tres? ¿ función hace una tres cosas? los tres pasos función encuentran nivel abstracción por debajo del nombre función. podemos describir función como breve párrafo (para) [] : para renderpagewithsetupsandteardowns , comprobamos página prueba , caso afirmativo, incluimos las configuraciones los detalles. ambos casos, representamos html. una función sólo realiza los pasos situados nivel por debajo del nombre función, entonces hace una cosa. definitiva, creamos funciones para descomponer conceptos más amplios ( decir, nombre función) conjunto pasos siguiente nivel abstracción. evidente que listado - contiene pasos distintos niveles abstracción, por que obvio que hace más una cosa. incluso listado - tiene tres niveles abstracción, como demostrado capacidad reducirlo, pero sería complicado reducir con sentido listado -. podríamos extraer instrucción función includesetupsandteardownsiftestpage , pero sólo reduciríamos código sin cambiar nivel abstracción. por ello, otra forma saber que una función hace más una cosa extraer otra función misma con nombre que sea una reducción implementación []. secciones funciones fíjese listado -. verá que función generateprimes divide secciones como declaraciones, inicializaciones filtros. síntoma evidente que hace más una cosa. las funciones que hacen una sola cosa pueden dividir secciones. nivel abstracción por función para que las funciones realicen «una cosa», asegúrese que las instrucciones función encuentran mismo nivel abstracción. listado - incumple esta regla. incluye conceptos elevado nivel abstracción, como gethtml(); otros encuentran nivel intermedio, como stringpagepathname = pathparser.render(pagepath) hay otros nivel especialmente bajo, como .append(“\”). mezcla niveles abstracción una función siempre resulta confusa. los lectores sabrán una determinada expresión concepto esencial detalle. peor todavía, mezclan detalles con conceptos esenciales, aumentarán los detalles dentro función. código arriba abajo: regla descendente objetivo que código lea como texto arriba abajo [] . queremos que tras todas las funciones aparezcan las del siguiente nivel abstracción para poder leer programa, descendiendo nivel abstracción por vez mientras leemos lista funciones. que denomino regla descendente. para decirlo otra forma, queremos leer programa como fuera conjunto párrafos , que cada uno describe nivel actual abstracción hace referencia los párrafos posteriores siguiente nivel. para incluir configuraciones detalles, incluimos configuraciones, después del contenido página prueba, por último los detalles. para incluir las configuraciones, incluimos configuración suite trata una suite , después configuración convencional. para incluir configuración suite ; buscamos jerarquía principal página suitesetup añadimos una instrucción include con ruta dicha página. para buscar jerarquía principal… los programadores les resulta complicado aprender esta regla crear funciones único nivel abstracción, pero truco importante. clave para reducir longitud las funciones garantizar que sólo hagan una cosa. conseguir que código lea arriba abajo, mantiene coherencia los niveles abstracción. fíjese listado - del final del capítulo. muestra función testablehtml modificada acuerdo estos principios. cada función presenta siguiente mantiene nivel abstracción coherente. instrucciones switch complicado usar una instrucción switch tamaño reducido [] . aunque sólo tenga dos casos, mayor que bloque función debería ser. también complicado crear una instrucción switch que haga una sola cosa. por naturaleza, las instrucciones switch siempre hacen cosas. desafortunadamente, siempre podemos evitar las instrucciones switch pero podemos asegurarnos incluirlas una clase nivel inferior repetirlas. para ello, evidentemente, recurrimos polimorfismo. fíjese listado -. muestra una las operaciones que pueden depender del tipo empleado. listado - payroll.java. public money calculatepay(employee ) throws invalidemployeetype ( switch (.type) { case commissioned: return calculatecommissionedpay(); case hourly: return calculatehourlypay(); case salaried: return calculatesalariedpay(); default: throw new invalidemployeetype(.type); } } esta función tiene varios problemas. por lado, gran tamaño cuando añadan nuevos tipos empleado, aumentará más. por otra parte, hace más una cosa. también incumple principio responsabilidad única ( single responsibility principie srp) [] que hay más motivo para cambiarla. además, incumple principio abierto/cerrado ( open closed principle ocp) [] , que debe cambiar cuando añadan nuevos tipos, pero posiblemente peor los problemas que hay número ilimitado funciones que tienen misma estructura. por ejemplo, podríamos tener: ispayday(employee , date date), (employee , date date), muchas otras, todas con misma estructura. solución problema (véase listado -) consiste ocultar instrucción switch una factoría abstracta [] impedir que nadie vea. factoría usa instrucción switch para crear las instancias adecuadas los derivados employee las distintas funciones, como calculatepay , ispayday deliverpay , entregarán forma polimórfica través interfaz employee . listado - employee factory. public abstract class employee { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } public interface employeefactory { public employee makeemployee(employeerecord ) throws invalidemployeetype; } public class employeefactoryimpl implements employeefactory { public employee makeemployee(employeerecord ) throws invalidemployeetype { switch (.type) { case commissioned: return new commissionedemployee(); case hourly: return new hourlyemployee(); case salaried: return new salariedemployee(); default: throw new invalidemployeetype(.type); } } } regla general para las instrucciones switch que pueden tolerar sólo aparecen una vez, usan para crear objetos polimórficos ocultan tras una relación herencia para que resto del sistema las pueda ver []. evidentemente, cada caso diferente ocasiones puede una varias partes esta regla. usar nombres descriptivos listado -, hemos cambiado nombre función ejemplo testablehtml setupteardownincluder.render . nombre más apropiado que describe mejor cometido función. también hemos asignado los métodos privados nombre descriptivo como istestable includesetupandteardownpages . hay que olvidar valor los nombres correctos. recuerde principio ward: «sabemos que trabajamos con código limpio cuando cada rutina más menos que esperábamos». para alcanzar este principio, gran parte del esfuerzo basa seleccionar nombres adecuados para pequeñas funciones que hacen una cosa. cuanto más reducida concreta sea una función, más sencillo será elegir nombre descriptivo. tema los nombres extensos. nombre descriptivo extenso mucho mejor que uno breve pero enigmático. use una convención nombres que permita leer varias palabras los nombres las funciones use esas palabras para asignar función nombre que describa cometido. tema dedicar tiempo elegir buen nombre. hecho, debería probar con varios nombres leer código con todos ellos. los ide modernos como eclipse intellij facilitan cambio nombres. use uno estos ide experimente con diferentes nombres hasta que encuentre uno que sea bastante descriptivo. elección nombres descriptivos clarifica diseño los módulos permite mejorarlos. extraño que búsqueda nombres adecuados genere una reestructuración favorable del código. sea coherente con los nombres. use las mismas frases, sustantivos verbos los nombres función que elija para los módulos. pruebe, por ejemplo, con includesetupandteardownpages , includesetuppages , includesuitesetuppage includesetuppage . estructura similar estos nombres permite que secuencia cuente una historia. realidad, secuencia anterior, seguramente pregunte qué pasado con , includesuiteteardownpage includeteardownpage . argumentos funciones número ideal argumentos para una función cero. después uno (monádico) dos (diádico). siempre que sea posible, evite presencia tres argumentos (triádico). más tres argumentos (poliádico) requiere una justificación especial muy habitual. los argumentos son complejos que requieren gran poder conceptual. por ello suelo evitarlos los ejemplos. fíjese stringbuffer . podríamos haberlo pasado como argumento lugar como variable instancia, pero los lectores habrían tenido que interpretarlo cada vez que vieran. leer historia que cuenta módulo, includesetuppage() más sencillo interpretar que includesetuppageinto(newpagecontent) . argumento encuentra nivel abstracción diferente que nombre función nos obliga conocer detalle ( stringbuffer ) que especialmente importante ese momento. los argumentos son todavía más complicados desde punto vista pruebas. imagine dificultad crear todos los casos prueba para garantizar funcionamiento las distintas combinaciones argumentos. hay argumentos, todo más sencillo. hay uno, demasiado difícil. con dos argumentos problema más complejo. con más dos argumentos, probar cada combinación valores adecuados todo reto. los argumentos salida son más difíciles entender que los entrada. leer una función, estamos acostumbrados concepto información añadida función través argumentos extraída través valor devuelto. esperamos que información devuelva través los argumentos. por ello, los argumentos salida suelen obligamos realizar una comprobación doble. argumento salida mejor opción, después ausencia argumentos. setupteardownincluder.render(pagedata) entiende bien. evidentemente, vamos representar los datos objeto pagedata . formas monádicas habituales hay dos motivos principales para pasar solo argumento una función. puede que realice una pregunta sobre argumento, como boolean fileexists(“myfile”), que procese argumento, transforme otra cosa devuelva. por ejemplo, inputstream fileopen(“myfile”) transforma nombre archivo string valor devuelto inputstream . los usuarios esperan estos dos usos cuando ven una función. debe elegir nombres que realicen distinción con claridad usar siempre ambas formas contexto coherente (consulte apartado sobre separación consultas comandos). una forma menos habitual pero muy útil para argumento evento. esta forma, hay argumento entrada pero salida. programa debe interpretar invocación función como evento usar argumento para alterar estado del sistema, por ejemplo, void passwordattemptfailedntimes(int attempts) . use esta forma con precaución. debe ser claro para lector que trata evento. elija nombres contextos con atención. intente evitar funciones monádicas que tengan estas formas, por ejemplo, void includesetuppageinto(stringbuffer pagetext) . uso argumento salida lugar valor devuelto para realizar transformaciones resulta confuso. una función transformar argumento entrada, transformación debe aparecer como valor devuelto. sin duda stringbuffertransform(stringbuffer ) mejor que void (stringbuffer out) , aunque implementación del primer caso devuelva solamente argumento entrada. menos ajusta forma transformación. argumentos indicador los argumentos indicador son horribles. pasar valor booleano una función una práctica totalmente desaconsejable. complica inmediatamente firma del método indica que función hace más una cosa. hace algo indicador true otra cosa diferente false . listado - puede evitar, porque los invocadores pasan indicador objetivo era limitar ámbito función después, pero invocación render (true) confusa para lector. desplaza ratón sobre invocación vemos que render (boolean issuite) puede ayudar, pero demasiado. tendremos que dividir función dos: renderforsuite() renderforsingletest() . funciones diádicas una función con dos argumentos más difícil entender que una función monádica. por ejemplo writefield(name) más fácil entender que writefield (outputstream, name) [] . aunque ambos casos significado evidente, primera capta mejor visualmente. segunda requiere una breve pausa hasta que ignoramos segundo parámetro, que última instancia genera problemas que debemos ignorar esa parte del código. las partes que ignoramos son las que esconden los errores. pero ocasiones necesitan dos argumentos. por ejemplo. point = new point(,); totalmente razonable. los puntos cartesianos suelen adoptar dos argumentos. hecho, sería muy sorprendente ver point() . sin embargo, este caso ambos argumentos son componentes ordenados mismo valor, mientras que outputstream name carecen una cohesión orden natural. funciones diádicas evidentes como assertequals(expected, actual) resultan problemáticas. ¿cuántas veces incluido valor real posición esperada? los dos argumentos carecen orden natural. orden real esperado una convención que adquiere gracias práctica. las combinaciones diádicas son mal persona tendrá que usarlas. sin embargo, recuerde que tienen precio que debe aprovechar los mecanismos disponibles para convertirlas unitarias. por ejemplo, puede hacer que método writefield sea miembro outputstream para poder usar outputstream.writefield(name) , podría convertir outputstream una variable miembro clase actual para tener que pasarla. incluso podría extraer una nueva clase como fieldwriter que usara outputstream constructor tuviera método write . triadas las funciones que aceptan tres argumentos son sin duda mucho más difíciles entender que las dos. los problemas hora ordenar, ignorar detenerse los argumentos duplican. piense atentamente antes crear una triada. por ejemplo, fíjese sobrecarga assertequals que acepta tres argumentos: assertequals(message, expected, actual) . ¿cuántas veces lee mensaje piensa que esperado? visto esta triada concreto muchas veces. hecho, siempre que veo, tengo que repasarla antes ignorar mensaje. por otra parte, hay otra triada que tan negativa: assertequals(., amount, .) . aunque también exija doble atención, merece pena. conviene recordar siempre que igualdad los valores coma flotante algo relativo. objeto argumento cuando una función parece necesitar dos más argumentos, probable que ellos incluya una clase propia. fíjese diferencia entre las dos siguientes declaraciones: circle makecircle (double , double , double radius); circle makecircle(point center, double radius); reducción del número argumentos mediante creación objetos puede parecer una trampa pero . cuando pasan grupos variables forma conjunta, como ejemplo anterior, probable que formen parte concepto que merece nombre propio. listas argumentos ocasiones tendremos que pasar número variable argumentos una función. fíjese método string.format : string.format (“% worked %. hours.”, name, hours); los argumentos variables procesan misma forma, como ejemplo anterior, serán equivalentes único argumento tipo list . por tanto, string.format realidad diádico. hecho, siguiente declaración string.format claramente diádica. public string format(string format, object… args) así pues, aplican las mismas reglas. las funciones que aceptan argumentos variables pueden ser monádicas, diádicas incluso triádicas, pero sería error asignar más argumentos. void monad(integer… args); void dyad(string name, integer… args); void triad(string name, int count, integer… args); verbos palabras clave selección nombres correctos para una función mejora explicación cometido, así como orden cometido los argumentos. formato monádico, función argumento deben formar par verbo sustantivo. por ejemplo, write(name) resulta muy evocador. sea que sea name , sin duda escribe (write) . nombre más acertado podría ser writefield(name) , que nos dice que name campo (field) . éste ejemplo palabra clave como nombre función. con este formato codificamos los nombres los argumentos nombre función. por ejemplo, assertequals podría haber escrito como assertexpectedequalsactual(expected, actual) , que mitiga problema tener que recordar orden los argumentos. sin efectos secundarios los efectos secundarios son mentiras. función promete hacer una cosa, pero también hace otras cosas ocultas. ocasiones realiza cambios inesperados las variables propia clase. ocasiones las convierte las variables pasadas función elementos globales del sistema. cualquier caso, comete engaño que suele provocar extrañas combinaciones temporales dependencias orden. fíjese función del listado -, aparentemente inofensiva. usa algoritmo estándar para comparar username con password . devuelve true coinciden false hay algún problema, pero también hay efecto secundario. ¿ detecta? listado - uservalidator.java. public class uservalidator { private cryptographer cryptographer; public boolean checkpassword(string username, string password) { user user = usergateway.findbyname(username); (user != user.null) { string codedphrase = user.getphraseencodedbypassword(); string phrase = cryptographer.decrypt(codedphrase, password); (“valid password”.equals(phrase)){ session.initialize(); return true; } } return false; } } efecto secundario invocación session.initialize() . función checkpassword , por nombre, afirma comprobar contraseña. nombre implica que inicialice sesión. por tanto, invocador que crea que dice nombre función arriesga borrar los datos sesión actuales cuando decida comprobar validez del usuario. este efecto secundario genera una combinación temporal. decir, sólo puede invocar checkpassword determinados momentos (cuando pueda inicializar sesión). invoca orden, pueden perder los datos sesión. las combinaciones temporales son confusas, especial cuando ocultan como efecto secundario. tiene que realizar una combinación temporal, hágalo forma clara nombre función. este caso, podríamos cambiar nombre función por checkpasswordandinitializesession , pero incumpliría norma hacer una sola cosa. argumentos salida los argumentos suelen interpretarse como entradas una función. lleva varios años programando, estoy seguro que habrá visto argumento que vez ser entrada era salida. por ejemplo; appendfooter(); ¿está función añade final algo? ¿ añade final algo ? ¿ una entrada una salida? sabemos ver firma función: public void appendfooter(stringbuffer report) esto aclara todo, pero para ello hay que comprobar declaración función. todo que obligue comprobar firma función esfuerzo doble. una pausa cognitiva debe evitarse. antes programación orientada objetos, era necesario tener argumentos salida. sin embargo, gran parte necesidad desaparece los lenguajes orientados objetos, pensados para actuar como argumento salida. decir, sería más indicado invocar appendfooter como report.appendfooter();. por general, los argumentos salida deben evitarse. función que cambiar estado elemento, haga que cambie estado objeto contenedor. separación consultas comando las funciones deben hacer algo responder algo, pero ambas cosas. función debe cambiar estado objeto devolver información sobre mismo, pero ambas operaciones causan confusión. fíjese siguiente función: public boolean set(string attribute, string value); esta función establece valor atributo devuelve true caso éxito false atributo existe. esto provoca presencia una extraña instrucción como siguiente: (set(“username”, “unclebob”))… imagínelo desde punto vista del lector. ¿qué significa? ¿pregunta atributo « username » establecido antes « unclebob », atributo «username» establecido correctamente « unclebob »? complicado saberlo por invocación que evidente set verbo adjetivo. autor pretendía que set fuera verbo, pero contexto instrucción parece adjetivo. instrucción lee como « atributo username establecido previamente unclebob », como «establecer atributo username unclebob funciona, entonces…». podríamos solucionarlo cambiamos nombre función set por setandcheckifexists , pero mejoraría legibilidad instrucción . verdadera solución separar comando consulta para evitar ambigüedad. (attributeexists(“username”)) { setattribute(“username”, “unclebob”); … } excepciones que devolver códigos error devolver códigos error funciones comando sutil incumplimiento separación comandos consulta. hace que los comandos usados asciendan expresiones los predicados las instrucciones . (deletepage(page) == e_ok) padece confusión entre verbo adjetivo, pero genera estructuras anidadas. devolver código error crea problema: invocador debe procesar error forma inmediata. (deletepage(page) == e_ok) { (registry.deletereference(page.name) == e_ok) { (configkeys.deletekey(page.name.makekey()) == e_ok) { logger.log(“page deleted”); } else { logger.log(“configkey not deleted”); } } else { logger.log(“deletereference from registry failed”); } } else { logger.log(“delete failed”); return e_error; } por otra parte, usa excepciones lugar códigos error, código procesamiento del error puede separar del código ruta puede simplificar: try { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } catch (exception ) { logger.log(.getmessage()); } extraer bloques try/catch los bloques try/catch son atractivos por naturaleza. confunden estructura del código mezclan procesamiento errores con normal. ello, conviene extraer cuerpo los bloques try catch funciones individuales. public void delete(page page) { try { deletepageandallreferences(page); } catch (exception ) { logerror(); } } private void deletepageandallreferences(page page) throws exception { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } private void logerror(exception ) { logger.log(.getmessage()); } este caso, función delete procesamiento errores. fácil entender ignorar. función deletepageandallreferences para los procesos borrar una página. procesamiento errores puede ignorar. este modo, separación facilita comprensión modificación del código. procesamiento errores una cosa las funciones sólo deben hacer una cosa procesamiento errores ejemplo. por tanto, una función que procese errores debe hacer nada más. esto implica (como ejemplo anterior) que, una función incluye palabra clave try , debe ser primera función que debe haber nada más después los bloques catch/finally . imán dependencias error.java devolución códigos error suele implicar que existe una clase enumeración que definen los códigos error. public enum error { , invalid, no_such, locked, out_of_resources, waiting_for_event; } clases como ésta son imán para las dependencias ; otras muchas clases deben importarlas usarlas. por ello, cuando cambia enumeración error , necesario volver compilar implementar dichas clases [] . esto añade presión clase error . los programadores quieren añadir nuevos errores porque tendrán que volver generar implementarlo todo. por ello, reutilizan códigos error antiguos lugar añadir otros nuevos. usar excepciones lugar códigos error, las nuevas excepciones son derivaciones clase excepción. pueden añadir sin necesidad volver compilar implementar [] . repetirse [] fíjese nuevo listado -; verá que hay algoritmo que repite cuatro veces, los casos setup , suitesetup , teardown suiteteardown . fácil detectar esta repetición que las cuatro instancias mezclan con otro código, pero duplicación problema que aumenta tamaño del código requerirá una modificación cuádruple alguna vez cambia algoritmo. también cuadriplica riesgo errores. esta duplicación remedia gracias método include del listado -. vuelva leer código fíjese cómo mejorado legibilidad del código reduciendo duplicación. duplicación puede ser raíz todos los problemas del software . existen numerosos principios prácticas para controlarla eliminarla. imagine que todas las formas normales base datos codd sirvieran eliminar duplicación datos. imagine también cómo programación orientada objetos concentra código clases base que otros casos serian redundantes. programación estructurada, programación orientada aspecto orientada componentes son, parte, estrategias para eliminar duplicados. parece que, desde aparición las subrutinas, las innovaciones desarrollo software han sido intento continuado por eliminar duplicación nuestro código fuente. programación estructurada algunos programadores siguen las reglas programación estructurada edsger dijkstra [] . dijkstra afirma que todas las funciones todos los bloques una función deben tener una entrada una salida. estas reglas implican que sólo debe haber una instrucción return una función, que debe haber instrucciones break continue bucle nunca, bajo ningún concepto, debe haber instrucciones goto . aunque apreciemos los objetivos disciplinas programación estructurada, sirven mucho cuando las funciones son reducido tamaño. verdadero beneficio aprecia funciones gran tamaño. por tanto, sus funciones son tamaño reducido, una instrucción return , break continue hará daño alguno ocasiones puede resultar más expresiva que regla una entrada una salida. por otra parte, goto sólo tiene sentido funciones gran tamaño debe evitarse. cómo crear este tipo funciones creación software como cualquier otro proceso creativo. escribir informe artículo, primero estructuran las ideas después mensaje hasta que lea bien. primer borrador puede estar desorganizado, modo que retoca mejora hasta que lea forma adecuada. cuando creo funciones, suelen ser extensas complicadas, con abundancia sangrados bucles anidados. con extensas listas , nombres arbitrarios código duplicado, pero también cuento con una serie pruebas unidad que abarcan todas cada una las líneas código. por tanto, retoco código, divido las funciones, cambio los nombres elimino los duplicados. reduzco los métodos los reordeno. ocasiones, elimino clases enteras, mientras mantengo las pruebas. final, consigo funciones que cumplen las reglas detalladas este capítulo. las escribo comenzar dudo que nadie pueda hacerlo. conclusión todo sistema crea partir lenguaje específico del dominio diseñado por los programadores para describir dicho sistema. las funciones son los verbos del lenguaje las clases los sustantivos. volver noción que los sustantivos verbos documento requisitos son las clases funciones sistema. una verdad mucho más antigua. arte programación , sido siempre, arte del diseño del lenguaje. los programadores experimentados piensan los sistemas como historias que contar, como programas que escribir. recurren las prestaciones del lenguaje programación seleccionado para crear lenguaje expresivo mejor más completo que poder usar para contar esa historia. parte ese lenguaje jerarquía funciones que describen las acciones que pueden realizar sistema. dichas acciones crean para usar lenguaje dominio concreto que definen para contar pequeña parte historia. este capítulo hemos visto mecánica creación funciones correctas. aplica estas reglas, sus funciones serán breves, con nombres correctos, bien organizadas, pero olvide que verdadero objetivo contar historia del sistema que las funciones que escriba deben encajar lenguaje claro preciso que sirva para contar esa historia. setupteardownincluder - setupteardownincluder.java. package fitnesse.html; import fitnesse.responders.run.suiteresponder; import fitnesse.wiki.*; public class setupteardownincluder { private pagedata pagedata; private boolean issuite; private wikipage testpage; private stringbuffer newpagecontent; private pagecrawler pagecrawler; public static string render(pagedata pagedata) throws exception { return render(pagedata, false); } public static string render(pagedata pagedata, boolean issuite) throws exception { return new setupteardownincluder(pagedata).render(issuite); } private setupteardownincluder(pagedata pagedata) { this.pagedata = pagedata; testpage = pagedata.getwikipage(); pagecrawler = testpage.getpagecrawler(); newpagecontent = new stringbuffer(); } private string render(boolean issuite) throws exception { this.issuite = issuite; (istestpage()) includesetupandteardownpages(); return pagedata.gethtml(); } private boolean istestpage() throws exception { return pagedata.hasattribute(“test”); } private void includesetupandteardownpages() throws exception { includesetuppages(); includepagecontent(); includeteardownpages(); updatepagecontent(); } private void includesetuppages() throws exception { (issuite) includesuitesetuppage(); includesetuppage(); } void includesuitesetuppage() throws exception { include(suiteresponder.suite_setup_name, “-setup”); } private void includesetuppage() throws exception { include(“setup”, “-setup”); } private void includepagecontent() throws exception { newpagecontent.append(pagedata.getcontent()); } private void includeteardownpages() throws exception { includeteardownpage(); (issuite) includesuiteteardownpage(); } private void includeteardownpage() throws exception { include(“teardown”, “-teardown”); } private void includesuiteteardownpage() throws exception { include(suiteresponder.suite_teardown_name, “-teardown”); } private void updatepagecontent() throws exception { pagedata.setcontent(newpagecontent.tostring()); } private void include(string pagename, string arg) throws exception ( wikipage inheritedpage = findinheritedpage(pagename); (inheritedpage != null) { string pagepathname = getpathnameforpage(inheritedpage); buildincludedirective(pagepathname, arg); } } private wikipage findinheritedpage(string pagename) throws exception { return pagecrawlerimpl.getinheritedpage(pagename, testpage); } private string getpathnameforpage(wikipage page) throws exception { wikipagepath pagepath = pagecrawler.getfullpath(page); return pathparser.render(pagepath); } private void buildincludedirective(string pagepathname, string arg) { newpagecontent .append(“\!include ”) .append(arg) .append(“ .”) .append(pagepathname) .append(“\”); } } bibliografía [] : kernighan and plaugher, the elements programming style , . ., mcgraw-hill, . [ppp] : robert . martin, agile software development: principles, patterns, and practices, prentice hall, . [gof] : design patterns: elements reusable object oriented software, gamma ., addison wesley, . [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, . [] : structured programming , . . dahl, . . dijkstra, . . . hoare, academic press, london, . comentarios « comente código incorrecto, reescríbalo». brian . kernighan . . plaugher [] hay nada más útil que comentario bien colocado. hay nada que colapse más módulo que comentarios dogmáticos innecesarios. hay nada más dañino que comentario antiguo que propague mentiras desinformación. los comentarios son como lista schindler. son pura bondad. hecho, mejor los casos, son mal necesario. los lenguajes fueran más expresivos pudiéramos dominarlos para expresar nuestras intenciones, necesitaríamos demasiados comentarios, puede que incluso ninguno. uso correcto los comentarios permite compensar nuestra incapacidad para expresarnos código. usado palabra incapacidad, propósito. los comentarios siempre son fallos. debemos usarlos porque siempre sabemos cómo expresarnos sin ellos pero uso motivo celebración. cuando tenga que escribir comentario, piense existe otra forma expresarse código. siempre que exprese código, debe felicitarse. siempre que escriba comentario, debe hacer gesto desaprobación sentir incapacidad para expresarse. ¿por qué estoy contra los comentarios? porque mienten. siempre siempre intencionadamente, pero hacen. cuando más antiguo comentario más aleja del código que describe, mayor probabilidad que sea equivocado. motivo sencillo. los programadores los pueden mantener. código cambia evoluciona. los fragmentos cambian lugar, bifurcan, reproducen vuelven combinar para crear quimeras. desafortunadamente, los comentarios siempre siguen ritmo, siempre pueden hacerlo suelen separarse del código que describen convierten huérfanos sin precisión alguna. por ejemplo, fíjese que sucede con este comentario línea que pretendía describir: mockrequest request; private final string http_date_regexp = “[smtwf][-]{}\\,\\[-]{}\\[jfmasond][-]{}\\” + “[-]{}\\[-]{}\\:[-]{}\\:[-]{}\\sgmt”; private response response; private fitnessecontext context; private fileresponder responder; private locale savelocale; // ejemplo: «tue, apr :: gmt» seguramente añadieron después otras variables instancia entre constante http_date_regexp comentario explicativo. podría afirmar que los programadores deben ser bastante disciplinados como para mantener los comentarios actualizados, relevantes precisos. acuerdo, debería, pero esa energía debería invertirse crear claro expresivo que necesite comentario alguno. los comentarios imprecisos son mucho peor que ausencia comentarios. suelen confundir usuario. generan expectativas que nunca cumplen. definen reglas que deben seguirse absoluto. verdad sólo encuentra punto: código. sólo código puede contar que hace. única fuente información precisa. por tanto, aunque los comentarios sean necesarios ocasiones, dedicaremos nuestra energía minimizarlos. los comentarios compensan código incorrecto una las principales motivaciones para crear comentarios código incorrecto. creamos módulo sabemos que confuso está desorganizado. sabemos que desastre entonces decidimos comentarlo. error. mejor límpielo. código claro expresivo sin apenas comentarios muy superior código enrevesado complejo con multitud comentarios. lugar perder tiempo escribiendo comentarios que expliquen desastre cometido, dedíquelo solucionarlo. explicarse código ocasiones, código pobre vehículo expresión. desafortunadamente, muchos programadores entienden como que código buen medio expresión. esto falso. ¿qué prefiere ver? esto: // comprobar empleado tiene derecho todos los beneficios ((employee.flags & hourly_flag) && (employee.age )) esto otro: (employee.iseligibleforfullbenefits()) apenas tardan unos segundos explicar nuestras intenciones código. muchos casos, basta con crear una función que diga mismo que comentario que pensaba escribir. comentarios calidad algunos comentarios son necesarios beneficiosos. veremos algunos los que considero válidos. obstante, recuerde que único comentario realmente bueno que tiene que escribir. comentarios legales ocasiones, nuestros estándares corporativos creación código nos obligan crear determinados comentarios por motivos legales. por ejemplo, los comentarios derechos autor son necesarios deben incluirse inicio cada archivo. siguiente encabezado comentario incluye forma estándar inicio todos los archivos fuente fitnesse. nuestro ide evita que este comentario parezca sobrante replegándolo forma automática. // copyright () ,, object mentor, inc. todos los derechos reservados. // publicado bajo las condiciones licencia pública general gnu versión posterior. este tipo comentarios deben ser contratos tomos legales. siempre que sea posible, haga referencia una licencia estándar otro documento externo lugar incluir todos los términos condiciones comentario. comentarios informativos ocasiones útil proporcionar información básica con comentario. por ejemplo, siguiente comentario explica valor devuelto por método abstracto: // devuelve una instancia del elemento responder probado. protected abstract responder responderinstance(); estos comentarios pueden ser útiles, pero mejor usar nombre función para transmitir información siempre que sea posible. por ejemplo, este caso comentario sería redundante cambiamos nombre función por responderbeingtested. veamos ejemplo mejor: // formato coincide con :: eee, mmm , yyyy pattern timematcher = pattern.compile( “\\*:\\*:\\* \\*, \\* \\*, \\*”); este caso, comentario nos indica que expresión regular debe coincidir con una fecha una hora con formato aplicado por función simpledateformat.format con cadena formato especificada. hubiera resultado mejor más claro código hubiera cambiado una clase especial que convirtiera los formatos fechas horas. ese modo comentario habría sido superfluo. explicar intención ocasiones, comentario algo más que información útil sobre implementación proporciona intención una decisión. siguiente caso, vemos una interesante decisión documentada por comentario. comparar dos objetos, autor decidió ordenar los objetos clase por encima los objetos otra. public int compareto(object ) { ( instanceof wikipagepath) { wikipagepath = (wikipagepath) ; string compressedname = stringutil.join(names, “”); string compressedargumentname = stringutil.join(.names, “”); return compressedname.compareto(compressedargumentname); } return ; // somos mayores porque somos tipo correcto. } veamos otro ejemplo mejor. puede que esté acuerdo con solución del programador, pero menos sabe que intentaba hacer. public void testconcurrentaddwidgets() throws exception { widgetbuilder widgetbuilder = new widgetbuilder(new class[](boldwidget.class)); string text = “‘‘‘bold text’’’”; parentwidget parent = new boldwidget(new mockwidgetroot(), “‘‘‘bold text’’’”); atomicboolean failflag = new atomicboolean(); failflag.set(false); //nuestro mejor intento obtener una condición carrera //creando gran número procesos. for (int = ; < ; ++) { widgetbuilderthread widgetbuiiderthread = new widgetbuilderthread(widgetbuilder, text, parent, failflag); thread thread = new thread(widgetbuilderthread); thread.start(); } assertequals(false, failflag.get()); } clarificación ocasiones, basta con traducir significado argumento valor devuelto algo más legible. por general, conviene buscar forma que argumento valor devuelto sean claros por mismos; pero cuando forma parte una biblioteca estándar código que puede alterar, comentario aclarativo puede ser muy útil. public void testcompareto() throws exception { wikipagepath = pathparser.parse(“pagea”); wikipagepath = pathparser.parse(“pagea.pageb”); wikipagepath = pathparser.parse(“pageb”); wikipagepath = pathparser.parse(“pagea.pagea”); wikipagepath = pathparser.parse(“pageb.pageb”); wikipagepath = pathparser.parse(“pageb.pagea”); asserttrue(.compareto() == ); // == asserttrue(.compareto() != ); // != asserttrue(.compareto() == ); // == asserttrue(.compareto() == -); // < asserttrue(.compareto() == -); // < asserttrue(.compareto() == -); // < asserttrue(.compareto() == ); // asserttrue(.compareto () == ); // asserttrue(.compareto() == ); // } pero también existe riesgo que comentario aclarativo sea incorrecto. ejemplo anterior, compruebe difícil que resulta comprobar los comentarios son correctos. esto explica por qué clarificación necesaria también arriesgada. por ello, antes escribir estos comentarios, asegúrese que hay una solución mejor también que sean precisos. las consecuencias ocasiones muy útil advertir otros programadores determinadas consecuencias. por ejemplo, siguiente comentario explica por qué determinado caso prueba está desactivado: // ejecutar menos // que sobre tiempo. public void _testwithreallybigfile() { writelinestofile(); response.setbody(testfile); response.readytosend(this); string responsestring = output.tostring(); assertsubstring(“content-length: ”, responsestring); asserttrue(bytessent ); } actualidad, evidentemente, desactivaríamos prueba por medio del atributo @ignore con correspondiente cadena explicativa: @ignore(“takes too long run”) , pero antes aparición junit , era habitual añadir guion bajo delante del nombre del método. comentario realizaba cometido. veamos otro ejemplo: public static simpledateformat makestandardhttpdateformat() { //simpledataformat compatible con procesos, //por que debe crear cada instancia forma independiente. simpledateformat = new simpledateformat(“eee, mmm yyyy :: ”); .settimezone (timezone.gettimezone (“gmt”)); return ; } seguramente conozca soluciones mejores para este problema. estoy acuerdo, pero comentario perfectamente razonable. evita que programador use inicializador estático por motivos eficacia. comentarios todo ocasiones conviene usar notas con forma comentarios //todo . caso, comentario todo explica por qué función tiene una implementación incorrecta cuál debe ser futuro. // todo-mdm son necesarios // esperamos que desaparezca modelo definitivo protected versioninfo makeversion() throws exception { return null; } todo son tareas que programador piensa que debería haber hecho pero que así. pueden ser recordatorio para eliminar una función obsoleta una petición para resolver problema. pueden ser una solicitud para buscar nombre más adecuado para realizar cambio que dependa evento planeado. sea que sea, excusa para mantener código incorrecto sistema. actualidad, muchos ide cuentan con funciones especiales para localizar comentarios todo , por que seguramente pierda. sin embargo, colapse código con estos comentarios. examínelos elimine todos los que pueda. amplificación puede usar comentario para amplificar importancia algo que, caso contrario, parecería irrelevante. string listitemcontent = match.group().trim(); // recorte importante. elimina los espacios iniciales // que harían que elemento reconociera como // otra lista. new listitemwidget(this, listitemcontent, this.level + ); return buildlist(text.substring(match.end())); javadoc api públicas hay nada más útil satisfactorio que una api pública bien descrita. los javadoc biblioteca estándar java son ejemplo. sería muy complicado crear programas java sin ellos. usa una api pública, debe crear javadoc calidad para misma, pero recuerde siguiente consejo largo del capítulo: los javadoc pueden ser ambiguos, amplios descorteses como cualquier otro tipo documento. comentarios incorrectos muchos comentarios pertenecen esta categoría. suelen ser excusas código pobre justificaciones decisiones insuficientes, algo así como programador hablara mismo. balbucear añadir comentario sin razón porque proceso requiere error. decide escribir comentario, tómese tiempo necesario para asegurarse que sea mejor que puede redactar. siguiente ejemplo fitnesse, donde comentario sin duda sería utilidad, pero autor tenía prisa prestó demasiada atención. balbuceo generó enigma: public void loadproperties() { try { string propertiespath = propertieslocation + “/” + properties_file; fileinputstream propertiesstream = new fileinputstream(propertiespath); loadedproperties.load(propertiesstream); } catch(ioexception ) { // hay archivos propiedades significan que cargan las predeterminadas } } ¿qué significa comentario del bloque catch ? seguro que algo para autor, pero significado está claro. aparentemente, genera ioexception , significa que hay archivo propiedades , ese caso, cargan los valores predeterminados. ¿pero quién carga los valores predeterminados? ¿ cargan antes invocación loadproperties.load loadproperties.load captura excepción, carga los valores predeterminados después nos pasa excepción para que ignoremos? ¿ será que loadproperties.load carga todos los valores antes intentar abrir archivo? ¿intentaba autor consolarse por dejar bloque catch vacío? ésta posibilidad más temida, ¿ estaba diciendo que volviera más tarde para crear código para cargar los valores predeterminados? nuestro único recurso examinar código otras partes del sistema para determinar qué sucede. cualquier comentario que obligue buscar significado otro módulo fallado intento comunicación merece los bits que consume. comentarios redundantes listado - muestra una sencilla función con comentario encabezado totalmente redundante. seguramente tarde más leer que propio código. listado - waitforclose. // método utilidad devuelto cuando this.closed true. genera una excepción // alcanza tiempo espera. public synchronized void waitforclose(final long timeoutmillis) throws exception { (!closed) { wait(timeoutmillis); (!closed) throw new exception (“mockresponsesender could not closed”); } } ¿para qué sirve este comentario? más informativo que código. justifica transmite intención lógica. más fácil leer que código. hecho, menos preciso obliga lector aceptar falta precisión lugar entenderlo. como vendedor coches segunda menos que asegura que hace falta revisar motor. fíjese ahora legión javadoc inútiles redundantes del listado - , obtenido tomcat. estos comentarios únicamente ensucian oscurecen código. tienen ninguna función documental. para empeorar las cosas, mostramos algunos. módulo tiene muchos más. listado - containerbase.java (tomcat). public abstract class containerbase implements container, lifecycle, pipeline, mbeanregistration, serializable { /** * retardo del procesador para este componente. */ protected int backgroundprocessordelay = -; /** * compatibilidad con eventos ciclo vital este componente. */ protected lifecyclesupport lifecycle = new lifecyclesupport(this); /** * escuchadores eventos contenedor este contenedor. */ protected arraylist listeners = new arraylist(); /** * implementación loader que asocia este contenedor. */ protected loader loader = null; /** * implementación logger que asocia este contenedor. */ protected log logger = null; /** * nombre registrador asociado. */ protected string logname = null; /** * implementación manager que asocia este contenedor. */ protected manager manager = null; /** * clúster que asocia este contenedor. */ protected cluster cluster = null; /** * nombre legible este contenedor. */ protected string name = null; /** * contenedor principal este contenedor. */ protected container parent = null; /** * cargador clase principal que configurar instalar elemento * loader. */ protected classloader parentclassloader = null; /** * objeto pipeline que asocia este contenedor. */ protected pipeline pipeline = new standardpipeline(this); /** * objeto realm que asocia este contenedor. */ protected realm realm = null; /** * objeto dircontext recursos que asocia este contenedor. */ protected dircontext resources = null; comentarios confusos ocasiones, pesar las buenas intenciones, programador realiza una afirmación sus comentarios que del todo precisa. fíjese otra vez comentario redundante confuso del listado -. ¿sabe por qué confuso? método devuelve nada cuando this.closed convierte true . devuelve algo this.closed true ; caso contrario, espera genera una excepción this.closed true . este sutil fragmento, oculto comentario más difícil leer que cuerpo del código, puede hacer que otro programador invoque función con esperanza que devuelva algo cuando this.closed sea true . ese pobre programador encontrará una sesión depuración intentando determinar por qué código ejecuta tan lentamente. obligatorios una locura tener una regla que afirme que todas las funciones deben tener javadoc que todas las variables deben tener comentario. este tipo comentarios ensucian código generan confusión desorganización. por ejemplo, los javadoc obligatorios para todas las funciones crean abominaciones como listado -. sirven nada, complican código constituyen posibles engaños desorientaciones. listado - /** * * @param title título del * @param author autor del * @param tracks número pistas del * @param durationinminutes duración del minutos */ public void addcd(string title, string author, int tracks, int durationinminutes) { = new (); .title = title; .author = author; .tracks = tracks; .duration = duration; cdlist.add(); } comentarios periódicos ocasiones, añade comentario inicio módulo cada vez que edita. estos comentarios acumulan una especie registro todos los cambios realizados. visto módulos con decenas páginas con estas entradas. * cambios (-oct-) * ----------------------------- * -oct- : reorganización clase cambio nuevo paquete * com.jrefinery.date (); * -nov- : añade método getdescription() elimina clase notabledate (); * -nov- : ibd requiere método setdescription(), una vez eliminada clase notabledate * (); cambian getpreviousdayofweek(), getfollowingdayofweek() * getnearestdayofweek() para corregir errores (); * -dic- : error corregido clase spreadsheetdate (); * -may- : transfieren todas las constantes mes una interfaz * independiente (monthconstants) (); * -ago- : error corregido método addmonths(), gracias nálevka petr (); * -oct- : errores indicados por checkstyle () corregidos; * -mar- : implementación serializable (); * -may- : error corregido método addmonths (); * -sep- : implementación comparable. actualización los javadoc isinrange (); * -ene- : error corregido método addyears() () (); hace tiempo hubo una buena razón para crear mantener estas entradas registro inicio cada módulo. carecíamos sistemas control código fuente que encargaran ello, pero actualidad, estas entradas son elementos sobrantes que complican los módulos. debe eliminarlas totalmente. comentarios sobrantes ocasiones vemos comentarios que simplemente sobran. restan importancia evidente ofrecen información nueva. /** * constructor predeterminado. */ protected annualdaterule() { } ¿ serio? ¿ este otro?: /** día del mes. */ private int dayofmonth; aquí parangón redundancia: /** * devuelve día del mes. * * @return día del mes. */ public int getdayofmonth() { return dayofmonth; } estos comentarios son tan inservibles que aprendemos ignorarlos. leer código, vista los salta. con tiempo, los comentarios empiezan mentir cuando cambia código que les rodea. primer comentario del listado - parece correcto [] . explica por qué ignora bloque catch , pero segundo comentario sobra. parece que programador estaba tan frustrado con crear bloques try/catch función que necesitaba explotar. listado - startsending. private void startsending() { try { dosending(); } catch(socketexception ) { // normal, alguien detenido solicitud. } catch(exception ) { try { response.add(errorresponder.makeexceptionstring()); response.closeall(); } catch(exception ) { //¡ respiro! } } } lugar explotar comentario sin sentido, programador debería haber sabido que frustración podría aliviar mejorando estructura del código. tendría que haber centrado energía extraer último bloque try/catch una función independiente, como muestra -. listado - startsending (refactorizado). private void startsending() { try { dosending(); } catch(socketexception ) { // normal. alguien detenido solicitud. } catch(exception ) { addexceptionandcloseresponse(); } } private void addexceptionandcloseresponse(exception ) { try { response.add(errorresponder.makeexceptionstring()); response.closeall(); } catch(exception ) { } } cambie tentación crear elementos sobrantes por determinación limpiar código. mejorará como programador será más fácil. comentarios sobrantes espeluznantes los javadoc también pueden ser innecesarios. ¿para qué sirven los siguientes javadoc ( una conocida biblioteca) código abierto? respuesta: para nada. son comentarios redundantes creados intento equivocado redactar documentación. /** nombre. */ private string name; /** versión. */ string version; /** licencename. */ private string licencename; /** versión. */ private string info; vuelva leer los comentarios. ¿detecta error corta pega? los autores prestan atención escribir sus comentarios ( pegarlos), ¿por qué espera que sean utilidad para los lectores? usar comentarios puede usar una función una variable fíjese siguiente código: // ¿ módulo lista global <mod depende del // subsistema del que formamos parte? (smodule.getdependsubsystems().contains(subsysmod.getsubsystem())) podría cambiar sin comentario esta forma: arraylist moduledependees = smodule.getdependsubsystems(); string oursubsystem = subsysmod.getsubsystem(); (moduledependees.contains(oursubsystem)) autor del código original seguramente escribió primero comentario (improbable) después código para ajustarlo comentario. sin embargo, autor tendría que haber refactorizado código, como hice , para poder eliminar comentario. marcadores posición ocasiones los programadores marcan una determinada posición archivo. por ejemplo, recientemente encontré esto programa: // acciones ////////////////////////////////// son escasas las ocasiones las que tiene sentido agrupar funciones bajo esta estructura. por general, debe eliminarse, sobre todo molesta hilera barras final. piénselo esta forma. estas estructuras son atractivas las usa demasiado. por ello, úselas esporádicamente sólo cuando beneficio sea . las usa exceso, acabarán por ser ignoradas. comentarios llave cierre ocasiones, los programadores incluyen comentarios especiales llaves cierre, como listado -. aunque pueda tener sentido funciones extensas con estructuras anidadas, únicamente estorba las funciones encapsuladas pequeño tamaño que nos gustan. por ello, siente deseo marcar sus llaves cierre, pruebe reducir tamaño sus funciones. listado - .java. public class { public static void main(string[] args) { bufferedreader = new bufferedreader(new inputstreamreader(system.)); string line; int linecount = ; int charcount = ; int wordcount = ; try { while ((line = .readline()) != null) { linecount++; charcount += line.length(); string words[] = line.split(“\\”); wordcount += words.length; } //while system.out.println(“wordcount = ” + wordcount); system.out.println(“linecount = ” + linecount); system.out.println(“charcount = ” + charcount); } // try catch (ioexception ) { system.err.println(“error: ” + .getmessage()); } //catch } //main } asignaciones menciones /* añadido por rick */ los sistemas control código fuente recuerdan perfección quién añadido qué cuándo. necesario plagar código con pequeñas . puede pensar que estos comentarios son útiles que ayudan otros hablar sobre código, pero realidad sobreviven durante años cada vez son menos precisos relevantes. sistema control código fuente punto idóneo para este tipo información. código comentado hay nada más odioso que código comentado. ¡ haga! inputstreamresponse response = new inputstreamresponse(); response.setbody(formatter.getresultstream(), formatter.getbytecount()); // inputstream resultsstream = formatter.getresultstream(); // streamreader reader = new streamreader(resultsstream); // response.setcontent(reader.read(formatter.getbytecount())); los lectores que vean código comentado tendrán valor borrarlo. pensarán que está ahí por algo que demasiado importante para borrarlo. por ello, código comentado acumula como los sedimentos una botella vino malo. fíjese este fragmento apache commons: this.bytepos = writebytes(pngidbytes, ); //hdrpos = bytepos; writeheader(); writeresolution(); //datapos = bytepos; (writeimagedata()) { writeend(); this.pngbytes = resizebytearray(this.pngbytes, this.maxpos); } else { this.pngbytes = null; } return this.pngbytes; ¿por qué hay dos líneas comentadas? ¿son importantes? ¿ han conservado como recordatorio cambio inminente algo que alguien comentó hace años preocupado limpiar? hubo una época, década , que código comentado pudo ser útil, pero hace tiempo que contamos con buenos sistemas control código fuente, sistemas que recuerdan código por nosotros. tenemos que comentarlo. elimínelo. perderá. aseguro. html html comentarios código fuente una aberración, como puede apreciar siguiente fragmento. dificulta lectura los comentarios donde debería ser más fácil; editor ide. los comentarios van extraer con una herramienta (como javadoc) para mostrarlos una página web, debe ser responsabilidad dicha herramienta del programador adornar los comentarios con correspondiente html. /** * tarea para ejecutar pruebas aceptación. * esta tarea ejecuta pruebas aceptación publica los resultados. * </ * <pre * uso: * &;taskdef name=&quot;execute-fitnesse-tests&quot; * classname=&quot;fitnesse.ant.executefitnesseteststask&quot; * classpathref=&quot;classpath&quot; /&; * * &;taskdef classpathref=&quot;classpath&quot; * resource=&quot;tasks.properties&quot; /&; * </ * &;execute-fitnesse-tests * suitepage=&quot;fitnesse.suiteacceptancetests&quot; * fitnesseport=&quot;&quot; * resultsdir=&quot;$(results.dir)&quot; * resultshtmlpage=&quot;fit-results.html&quot; * classpathref=&quot;classpath&quot; /&; * </pre */ información local tiene que escribir comentario, asegúrese que describa código que rodea. ofrezca información global del sistema contexto comentario local. fíjese siguiente comentario javadoc. aparte terrible redundancia, también ofrece información sobre puerto predeterminado función tiene control alguno sobre puerto predeterminado. comentario describe función sino otra parte distinta sistema. evidentemente, hay garantías que comentario cambie cuando haga código que contiene valor predeterminado. /** * puerto para ejecutar fitnesse. predeterminado <</. * * @param fitnesseport */ public void setfitnesseport(int fitnesseport) { this.fitnesseport = fitnesseport; } demasiada información incluya sus comentarios interesantes reflexiones históricas irrelevantes descripciones detalles. siguiente comentario extraído módulo diseñado para probar que una función puede codificar descodificar base. aparte del número rfc, lector este código necesita información obsoleta que contiene comentario. /* rfc - extensiones multipropósito correo internet (mime) primera parte: formato del cuerpo los mensajes internet sección .. codificación transferencia contenidos base proceso codificación representa grupos bits entrada como cadenas salida caracteres codificados. procediendo izquierda derecha, forma grupo bits entrada concatenando grupos bits entrada. estos bits tratan como grupos concatenados bits, cada uno los cuales traduce solo dígito del alfabeto base. cuando codifica flujo bits mediante codificación base, flujo bits debe considerar ordenado con bit más significativo primero. esto , primer bit del flujo será bit orden más alto primer byte bits, octavo bit será orden más bajo primer byte bits, así sucesivamente. */ conexiones evidentes conexión entre comentario código que describe debe ser evidente. preocupado escribir comentario, mínimo que lector que vea entienda qué refiere. fíjese este comentario obtenido apache commons: /* * comienza con una matriz tamaño suficiente para albergar todos los pixeles * (más bytes filtro), bytes adicionales para información encabezado */ this.pngbytes = new byte[((this.width + ) * this.height * ) + ]; ¿qué byte filtro? ¿está relacionado con + ? ¿ con * ? ¿con ambos? ¿ pixel byte ? ¿por qué ? función comentario explicar código que explica por mismo. una lástima que comentario requiera propia explicación. encabezados función las funciones breves apenas requieren explicación. nombre bien elegido para una función que hace una cosa suele ser mejor que encabezado comentario. javadocs código público pesar utilidad los javadoc para las api públicas, sirven para código dirigido consumo público. generación páginas javadoc para clases funciones sistema suele ser útil formalidad adicional los comentarios javadoc más que una distracción. ejemplo escribí módulo del listado - para primera versión immersion . debía ser ejemplo estilo incorrecto creación código comentarios. después, kent beck refactorizó este código algo mucho más atractivo delante varios alumnos. posteriormente, adapté ejemplo para libro agile software development, principles, patterns, and practices para primero mis artículos craftsman publicados revista software development . que fascina este módulo que hubo tiempo que muchos hubiéramos considerado bien documentado. ahora vemos que auténtico desastre. ver cuántos problemas detecta los comentarios. listado - generateprimes.java. /** * esta clase genera números primos hasta cantidad máxima especificada por * usuario. algoritmo usado criba eratóstenes. * < * eratóstenes cirene, . ., cirene, libia - * . ., alejandría. primer hombre calcular * circunferencia tierra. también trabajó con calendarios * con años bisiestos fue responsable biblioteca alejandría. * < * algoritmo muy simple. dada una matriz enteros * empezando por , tachan todos los múltiplos . busca siguiente * entero sin tachar tachan todos sus múltiplos. * repetir hasta superar raíz cuadrada del valor * máximo. * * ©author alphonse * ©version feb atp */ import java.util.*; public class generateprimes { /** * @param maxvalue límite generación. */ public static int[] generateprimes(int maxvalue) { (maxvalue = ) // único caso válido { // declaraciones int = maxvalue + ; // tamaño matriz boolean[] = new boolean[]; int ; // inicializar matriz true. for ( = ; < ; ++) [] = true; // eliminar los números primos conocidos [] = [] = false; // cribar int ; ( = ; < math.sqrt() + ; ++) { ([]) // está tachado, tachar sus múltiplos. { for ( = * ; < ; += ) [] = false; // múltiplo primo } } // ¿cuántos primos hay? int count = ; for ( = ; < ; ++) { ([]) count++; // contador. } int[] primes = new int[count]; // enviar primos resultado for ( = , = ; < ; ++) { ([]) // primo primes[++] = ; } return primes; // devolver los primos } else // maxvalue < return new int[]; // devolver matriz null entrada correcta. } } listado - puede ver una versión refactorizada del mismo módulo. limitado considerablemente uso comentarios. hay sólo dos todo módulo ambos claramente descriptivos. listado - primegenerator.java (refactorizado). /** * esta clase genera números primos hasta cantidad máxima especificada por * usuario. algoritmo usado criba eratóstenes. dada una matriz enteros * empezando por : buscar primer entero sin tachar tachar todos sus * múltiplos. repetir hasta que haya más múltiplos matriz. */ public class primegenerator { static boolean[] crossedout; private static int[] result; public static int[] generateprimes(int maxvalue) { (maxvalue < ) return new int[]; else { uncrossintegersupto(maxvalue); crossoutmultiples(); putuncrossedintegersintoresult(); return result; } } private static void uncrossintegersupto(int maxvalue) { crossedout = new boolean[maxvalue + ]; for (int = ; < crossedout.length; ++) crossedout[] = false; } private static void crossoutmultiples() { int limit = determineiterationlimit(); for (int = ; <= limit; ++) (notcrossed()) crossoutmultiplesof(); } private static int determineiterationlimit() { // cada múltiplo matriz tiene factor primordial que // menor igual que raíz del tamaño matriz, // entonces tenemos que tachar múltiplos números // más grande que esa raíz. double iterationlimit = math.sqrt(crossedout.length); return (int) iterationlimit; } private static void crossoutmultiplesof (int ) { for (int multiple = * ; multiple < crossedout.length; multiple += ) crossedout[multiple] = true; } private static boolean notcrossed(int ) { return crossedout[] == false; } private static void putuncrossedintegersintoresult() { result = new int[numberofuncrossedintegers()]; for (int = , = ; < crossedout.length; ++) (notcrossed()) result[++] = ; } private static int numberofuncrossedintegers() { int count = ; for (int = ; < crossedout.length; ++) (notcrossed()) count++; return count; } } podría decir que primer comentario redundante que muy similar función generateprimes , pero creo que muestra mejor algoritmo lector, motivo por que mantenido. segundo argumento sin duda necesario. explica lógica del uso raíz cuadrada como límite del bucle. encontré otro nombre variable más sencillo otra estructura código que aclarara más. por otra parte, uso raíz cuadrada podría resultar presuntuoso. ¿realmente ahorra tanto tiempo limitando iteración raíz cuadrada? ¿ cálculo raíz cuadrada llevaría más tiempo del que ahorra? conviene analizarlo. uso raíz cuadrada como límite iteración satisface viejo hacker lenguajes ensamblado interior, pero estoy convencido que merezca tiempo esfuerzo que los demás puedan dedicar entenderlo. bibliografía [] : kernighan and plaugher, the elements programming style , . ., mcgraw-hill, . formato cuando los usuarios miran entre bastidores, queremos que queden por atractivo, coherencia atención detalle que perciben. queremos que orden les sorprenda, que abran los ojos con asombro cuando desplacen por los módulos. queremos que aprecien que trata trabajo profesionales. ven una masa amorfa código que parece escrito por grupo marineros borrachos, probable que piensen que sucederá mismo otros aspectos del proyecto. debe preocuparse por formato código. debe elegir una serie reglas sencillas que controlen formato del código después aplicarlas forma coherente. trabaja equipo, debe acordar una serie reglas que todos los miembros deben cumplir. también muy útil usar una herramienta automatizada que encargue aplicar las reglas. función del formato primer lugar, debe ser claro. formato código importante, demasiado importante como para ignorarlo también demasiado importante como para tratarlo forma religiosa. formato del código basa comunicación comunicación debe ser principal pilar desarrollador profesional. puede que piense que conseguir que algo funcione principal preocupación programador profesional. espero que este libro haga cambiar idea. funcionalidad que cree hoy muy probable que cambie siguiente versión, pero legibilidad código afectará profundamente todos los cambios que realice. estilo del código legibilidad establecen los precedentes que afectan capacidad mantenimiento ampliación mucho después que código cambie. estilo disciplina sobrevivirán, aunque código haga. veamos qué aspectos del formato nos permiten comunicarnos mejor. formato vertical comencemos por tamaño vertical. ¿qué tamaño debe tener archivo ? java, tamaño los archivos está relacionado con tamaño las clases, como veremos más adelante. por momento, nos detendremos tamaño los archivos. ¿qué tamaño tienen mayoría archivos fuente java? existe una amplia gama tamaños importantes diferencias estilo, como aprecia figura .. figura .. escala log distribuciones longitud archivos (altura del cuadro = sigma). describen siete proyectos: junit, fitnesse, testng, time and money, jdepend, ant tomcat. las líneas que cruzan los cuadros muestran longitud máxima mínima cada proyecto. cuadro muestra aproximadamente tercio (una desviación estándar [] ) los archivos. parte central del cuadro media. por tanto, tamaño archivo medio del proyecto fitnesse líneas tercio los archivos ocupan entre + líneas. mayor archivo fitnesse tiene unas líneas menor tamaño, . una escala registro, modo que pequeña diferencia posición vertical supone una gran diferencia tamaño absoluto. junit, fitnesse time and money tienen archivos relativamente pequeños. ninguno supera las líneas mayoría tienen menos . tomcat ant, por parte, tienen archivos con varios miles líneas más mitad superan las . ¿qué significa todo esto? aparentemente pueden crear sistemas (fitnesse aproxima las líneas) partir archivos unas líneas longitud, con límite máximo . aunque debería ser una regla, intervalo aconsejable. los archivos pequeño tamaño entienden mejor que los grandes. metáfora del periódico piense artículo periódico bien escrito. parte superior espera titular que indique qué trata historia permita determinar quiere leerlo . primer párrafo ofrece una sinopsis historia, oculta los detalles muestra conceptos generales. avanzar lectura, aumentan los detalles junto con todas las fechas, nombres, citas otros elementos. archivo código debe ser como artículo periódico. nombre debe ser sencillo pero claro. por mismo, debe bastar para indicarnos estamos módulo correcto. los elementos superiores del archivo deben proporcionar conceptos algoritmos nivel superior. los detalles deben aumentar según avanzamos, hasta que parte final encontremos las funciones nivel inferior del archivo. periódico compone varios artículos, algunos muy reducidos otros gran tamaño. hay muchos que ocupen toda página con texto, para que periódico sea manejable. periódico fuera único extenso texto con una aglomeración desorganizada hechos, fechas nombres, leeríamos. apertura vertical entre conceptos práctica totalidad del código lee izquierda derecha arriba abajo. cada línea representa una expresión una cláusula, cada grupo líneas representa pensamiento completo. estos pensamientos deben separarse mediante líneas blanco. fíjese listado -. hay líneas blanco que separan declaración paquete, las importaciones las funciones. una regla muy sencilla con profundo efecto diseño visual del código. cada línea blanco una pista visual que identifica nuevo concepto independiente. avanzar por listado, vista fija primera línea que aparece tras una línea blanco. listado - boldwidget.java package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = “‘‘‘.+?’’’”; private static final pattern pattern = pattern.compile (“‘‘‘(.+?)’’’”, pattern.multiline + pattern.dotall ); public boldwidget(parentwidget parent, string text) throws exception { super(parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group()); } public string render() throws exception { stringbuffer html = new stringbuffer(“<”); html.append(childhtml()).append (“</”); return html.tostring(); } } eliminamos las líneas blanco, como listado -, oscurece legibilidad del código. listado - boldwidget.java package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = “‘‘‘.+?’’’”; private static final pattern pattern = pattern.compile(“‘‘‘(.+?)’’’”, pattern.multiline + pattern.dotall); public boldwidget(parentwidget parent, string text) throws exception { (parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group());} public string render() throws exception { stringbuffer html = new stringbuffer(“<”); html.append(childhtml()).append(“</”); return html.tostring(); } } este efecto aumenta todavía más centramos vista. primer ejemplo, los distintos grupos líneas saltan vista, mientras que segundo una mezcla amorfa. diferencia entre ambos listados una ligera apertura vertical. densidad vertical apertura separa los conceptos, densidad vertical implica asociaciones. por tanto, las líneas código con una relación directa deben aparecer verticalmente densas. fíjese cómo los comentarios sin sentido del listado - anulan asociación entre las dos variables instancia. listado - public class reporterconfig { /** * nombre clase del escuchador */ private string m_classname; /** * propiedades del escuchador */ private list<property m_properties = new arraylist<property(); public void addproperty(property property) { m_properties.add(property); } listado - mucho más fácil leer. apreciamos simple vista menos hago. mirarlo, veo que una clase con dos variables método, sin tener que mover cabeza vista. listado anterior nos forzar vista mover cabeza para alcanzar mismo nivel comprensión. listado - public class reporterconfig { private string m_classname; private list<property m_properties = new arraylist<property(); public void addproperty(property property) { m_properties.add(property); } distancia vertical ¿alguna vez tenido que recorrer una clase, saltando una función otra, desplazándose por código para intentar adivinar relación funcionamiento las funciones, acabar totalmente confundido? ¿alguna vez escudriñado cadena herencia buscando definición una variable función? resulta frustrante porque intenta comprender que hace sistema, pero pierde tiempo energía mental intentar localizar recordar sus elementos. los conceptos relacionados entre deben mantenerse juntos verticalmente []. esta regla funciona con conceptos archivos independientes. por tanto, debe separar conceptos relacionados archivos independientes menos que tenga motivo peso. hecho, uno los motivos por los que debe evitar uso variables protegidas. para los conceptos relacionados que pertenecen mismo archivo, separación vertical debe medir importancia con respecto legibilidad del otro. debe evitar que lector deambule entre archivos clases. declaraciones variables las variables deben declararse forma más aproximada uso. como las funciones son muy breves, las variables locales deben aparecer parte superior cada función, como este ejemplo junit... static void readpreferences() { inputstream = null; try { = new fileinputstream(getpreferencesfile()); setpreferences(new properties(getpreferences())); getpreferences().load(); } catch (ioexception ) { try { ( != null) .close(); } catch (ioexception ) { } } } las variables control bucles deben declararse instrucción del bucle, como esta pequeña función del mismo código fuente: public int counttestcases() { int count= ; for ( test each : tests) count += each.counttestcases(); return count; } casos excepcionales, una variable puede declararse parte superior bloque antes bucle una función extensa. puede ver este tipo variable siguiente función testng. … for (xmltest test: m_suite.gettests()) { testrunner = m_runnerfactory.newtestrunner(this, test); .addlistener(m_textreporter); m_testrunners.add(); invoker = .getinvoker(); for (itestngmethod : .getbeforesuitemethods()) { beforesuitemethods.put(.getmethod(), ); } for (itestngmethod : .getaftersuitemethods()) { aftersuitemethods.put(.getmethod(), ); } } … variables instancia las variables instancia, por parte, deben declararse parte superior clase. esto debe aumentar distancia vertical las variables, una clase bien diseñada usan muchos sino todos sus métodos. existen discrepancias sobre ubicación las variables instancia. ++ suele aplicarse denominada regla las tijeras, que sitúa todas las variables instancia parte inferior. java, sin embargo, habitual ubicarlas parte superior clase. veo motivos para hacerlo. importante declarar las variables instancia punto conocido para que todo mundo sepa dónde buscarlas. fíjese extraño caso clase testsuite junit ... atenuado considerablemente esta clase para ilustrar este concepto. fija mitad del listado, verá dos variables instancia declaradas. resultaría complicado ocultarlas punto mejor. cualquiera que lea este código tendría que toparse con las declaraciones por casualidad (como pasó ). public class testsuite implements test { static public test createtest(class<? extends testcase theclass, string name) { … } public static constructor<? extends testcase gettestconstructor(class<? extends testcase theclass) throws nosuchmethodexception { … } public static test warning(final string message) { … } private static string exceptiontostring(throwable ) { … } private string fname; private vector<test ftests = new vector<test(); public testsuite() { } public testsuite(final class<? extends testcase theclass) { … } public testsuite(class<? extends testcase theclass, string name) { … } … … … … } funciones dependientes una función invoca otra, deben estar verticalmente próximas, función invocación debe estar por encima invocada siempre que sea posible. este modo programa fluye con normalidad. convención sigue forma fiable, los lectores sabrán que las definiciones función aparecen después uso. fíjese fragmento fitnesse del listado -. función superior invoca las situadas por debajo que, vez, invocan las siguientes. esto facilita detección las funciones invocadas mejora considerablemente legibilidad del módulo completo. listado - wikipageresponder.java. public class wikipageresponder implements secureresponder { protected wikipage page; protected pagedata pagedata; protected string pagetitle; protected request request; protected pagecrawler crawler; public response makeresponse(fitnessecontext context, request request) throws exception { string pagename = getpagenameordefault(request, “frontpage”); loadpage(pagename, context); (page == null) return notfoundresponse(context, request); else return makepageresponse(context); } private string getpagenameordefault(request request, string defaultpagename) { string pagename = request.getresource(); (stringutil.isblank(pagename)) pagename = defaultpagename; return pagename; } protected void loadpage(string resource, fitnessecontext context) throws exception { wikipagepath path = pathparser.parse(resource); = context.root.getpagecrawler(); crawler.setdeadendstrategy(new virtualenabledpagecrawler()); page = crawler.getpage(context.root, path); (page != null) pagedata = page.getdata(); } private response notfoundresponse(fitnessecontext context, request request) throws exception { return new notfoundresponder().makeresponse(context, request); } private simpleresponse makepageresponse(fitnessecontext context) throws exception { pagetitle = pathparser.render(crawler.getfullpath(page)); string html = makehtml(context); simpleresponse response = new simpleresponse(); response.setmaxage(); response.setcontent(html); return response; } … además, este fragmento buen ejemplo ubicación constantes nivel correcto []. constante frontpage podría haber ocultado función getpagenameordefault , pero eso habría ocultado una constante conocida esperada una función nivel inferior forma incorrecta. mejor pasar constante desde punto que tiene sentido posición que realmente usa. afinidad conceptual determinados conceptos código deben estar próximos otros. tienen una afinidad conceptual concreta. cuanto mayor sea esta afinidad, menor distancia vertical debe existir entre ellos. como hemos visto, esta afinidad puede basar una dependencia directa, como cuando una función invoca otra, cuando usa una variable. pero hay otras causas afinidad. puede generarse porque grupo funciones realice una operación similar. fíjese este fragmento código junit ..: public class assert { static public void asserttrue(string message, boolean condition) { (!condition) fail(message); } static public void asserttrue(boolean condition) { asserttrue (null, condition); } static public void assertfalse(string message, boolean condition) { asserttrue(message, !condition); } static public void assertfalse(boolean condition) { assertfalse(null, condition); } … estas funciones tienen una elevada afinidad conceptual que comparten sistema nombres común realizan variantes misma tarea básica. hecho que invoquen unas otras secundario. aunque hicieran, deberían seguir estando próximas entre ellas. orden vertical por general, las dependencias invocaciones funciones deben apuntar hacia abajo. decir, función invocada debe situarse por debajo que realice invocación [] . esto genera agradable flujo código fuente, los niveles superiores los inferiores. como sucede los artículos del periódico, esperamos que los conceptos más importantes aparezcan antes que expresen con menor cantidad detalles sobrantes. esperamos que los detalles nivel inferior sean los últimos. este modo, podemos ojear los archivos código captar mensaje las primeras funciones sin necesidad sumergirnos los detalles. listado - organiza esta forma. puede que otros ejemplos mejores sean los listados - -. formato horizontal ¿qué ancho debe tener una línea? para responderlo, fíjese anchura las líneas programa convencional. nuevo, examinamos siete proyectos diferentes. figura . puede ver distribución longitud todos ellos. regularidad impresionante, especial tomo los caracteres. hecho, los tamaños entre representan uno por cien del número total líneas. ¡eso por ! puede que otro por sea menos caracteres ancho. recuerde que una escala registro, modo que apariencia lineal muy significativa. evidente que los programadores prefieren líneas menos anchas. figura .. distribución anchura líneas java. esto sugiere que debemos intentar reducir las líneas código. antiguo límite hollerith tanto arbitrario opongo líneas que tienen incluso , pero más. como norma, debe tener que desplazarse hacia derecha. los monitores modernos son más anchos los programadores noveles pueden reducir fuente para encajar hasta caracteres pantalla. haga. límite personal . apertura densidad horizontal espacio blanco horizontal para asociar elementos directamente relacionados separar otros con una relación menos estrecha. fíjese siguiente función: private void measureline(string line) { linecount++; int linesize = line.length(); totalchars += linesize; linewidthhistogram.addline(linesize, linecount); recordwidestline(linesize); } hemos rodeado los operadores asignación con espacios blanco para destacarlos. las instrucciones asignación tienen dos elementos principales: lado izquierdo derecho. los espacios acentúan esta separación. por otra parte, hemos incluido espacios entre los nombres las funciones paréntesis apertura, que función sus argumentos están estrechamente relacionados. separación los desconectaría. separo los argumentos los paréntesis invocación función para acentuar coma indicar que los argumentos son independientes. espacio blanco también usa para acentuar precedencia los operadores: public class quadratic { public static double root(double , double , double ) { double determinant = determinant(, , ); return (- + math.sqrt(determinant)) / (*); } public static double root(int , int , int ) { double determinant = determinant(, , ); return (- - math.sqrt(determinant)) / (*); } private static double determinant(double , double , double ) { return * - **; } } fíjese bien que leen las ecuaciones. los factores carecen espacios blanco que tienen una mayor precedencia. los términos separan mediante espacios blanco que suma resta son precedencia inferior. desafortunadamente, muchas herramientas formato código ignoran precedencia los operadores imponen espaciado uniforme. por ello, separaciones sutiles como las anteriores suelen perderse tras modificar del código. alineación horizontal cuando era programador lenguajes ensamblado [] , usaba alineación horizontal para acentuar determinadas estructuras. cuando comencé programar , ++ java, seguía intentando alinear los nombres variables conjunto declaraciones todos los valores grupo instrucciones asignación. aspecto código era siguiente: public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long requestprogress; private long requestparsingdeadline; private boolean haserror; public fitnesseexpediter( socket , fitnessecontext context) throws exception { this.context = context; socket = ; input = .getinputstream(); output = .getoutputstream(); requestparsingtimelimit = ; } sin embargo, este tipo alineación útil. parece enfatizar los elementos incorrectos aleja vista verdadera intención. por ejemplo, lista anterior declaraciones, nos vemos tentados leer lista nombres variables sin fijarnos sus tipos. del mismo modo, lista instrucciones asignación, nos fijamos los valores sin ver operador. para empeorarlo todo, las herramientas automáticas formato suelen eliminar este tipo alineación. por tanto, final, uso. ahora prefiero declaraciones asignaciones sin alinear, como muestra , que resaltan una deficiencia importante. tengo listas extensas que deben alinearse, problema longitud las listas, falta alineación. longitud siguiente lista declaraciones fitnesseexpediter sugiere que esta clase debe dividirse. public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long request progress; private long requestparsingdeadline; private boolean haserror; public fitnesseexpediter(socket , fitnessecontext context) throws exception { this.context = context; socket = ; input = .getinputstream(); output = .getoutputstream(); requestparsingtimelimit = ; } sangrado archivo código una jerarquía más que contorno. incluye información que pertenece totalidad del archivo, sus clases individuales, los métodos las clases, los bloques los métodos los bloques los bloques. cada nivel esta jerarquía ámbito que pueden declarar nombres que interpretan declaraciones instrucciones ejecutables. para que esta jerarquía ámbitos sea visible, sangramos las líneas código fuente acuerdo posición jerarquía. las instrucciones nivel del archivo, como las declaraciones clases, sangran. los métodos una clase sangran nivel derecha clase. las implementaciones dichos métodos implementan nivel derecha declaración los métodos. las implementaciones bloques nivel derecha bloque contenedor así sucesivamente. los programadores dependen este sistema sangrado. alinean visualmente las líneas izquierda para ver ámbito que pertenece. este modo pueden acceder rápidamente los ámbitos, como por ejemplo implementaciones instrucciones while , que son relevantes para situación actual. buscan izquierda nuevas declaraciones métodos, variables incluso clases. sin sangrado, los programas serian prácticamente ilegibles. fíjese los siguientes programas, sintáctica semánticamente idénticos: public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket ) { serve(, ); } public void serve(socket , long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch(exception ) { .printstacktrace(); } } } public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket ) { serve (, ); } public void serve(socket , long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch (exception ) { .printstacktrace(); } } } vista puede incluso apreciar estructura del archivo sangrado. detectamos inmediatamente las variables, constructores métodos acceso. cuestión segundos vemos que una especie interfaz conexión, tiempo espera. versión sin sangrar, por parte, prácticamente impenetrable. romper sangrado ocasiones tenemos tentación romper regla sangrado con instrucciones breves, bucles while breves funciones breves. siempre que sucumbido esta tentación, acabado por volver aplicar sangrado. por ello, evito replegar ámbitos una línea, como este ejemplo: public class commentwidget extends textwidget { public static final string regexp = “^#[^\\]*(?:(?:\\)|\|\)?”; public commentwidget(parentwidget parent, string text){super (parent, text);} public string render() throws exception { return “”; } } prefiero desplegar sangrar los ámbitos: public class commentwidget extends textwidget { public static final string regexp = “^#[^\\]*(?:(?:\\)|\|\)?”; public commentwidget(parentwidget parent, string text) { super(parent, text); } public string render() throws exception { return “”; } } ámbitos ficticios ocasiones, cuerpo una instrucción while for ficticio, como muestra continuación. gustan estas estructuras prefiero evitarlas. caso poder hacerlo, aseguro sangrar cuerpo ficticio incluirlo entre paréntesis. sabría decir cuántas veces engañado punto coma situado final bucle while misma línea. menos que haga visible sangre una línea propia, difícil ver. while (dis.read(buf, , readbuffersize) != -) ; equipo todo programador tiene sus reglas formato preferidas, pero forma parte equipo, equipo manda. equipo programadores debe acordar único estilo formato todos los integrantes del equipo deben aplicarlo. objetivo que software tenga estilo coherente. queremos que parezca escrito por individuos enfrentados. cuando comencé proyecto fitnesse , reuní con equipo para definir estilo código. tardamos minutos. decidimos dónde añadir las llaves, qué tamaño sangrado utilizar, los nombres clases, variables métodos, demás. tras ello, codificamos las reglas ide las cumplimos desde entonces. son las reglas que prefiero, son las que equipo decidió. como miembro ese equipo, las apliqué cuando creamos código del proyecto fitnesse. recuerde que buen sistema software compone una serie documentos que leen fácilmente. deben tener estilo coherente dinámico. lector debe confiar que los formatos que nuestro archivo código significarán mismo para otros. último que queremos aumentar complejidad del código creando una mezcla estilos diferentes. reglas formato uncle bob las reglas que uso personalmente son sencillas ilustran código del listado -. considérelo ejemplo documento estándar código óptimo. listado - .java. public class codeanalyzer implements javafileanalysis { private int linecount; private int maxlinewidth; private int widestlinenumber; private linewidthhistogram linewidthhistogram; private int totalchars; public codeanalyzer() { linewidthhistogram = new linewidthhistogram(); } public static list<file findjavafiles(file parentdirectory) { list<file files = new arraylist<file(); findjavafiles(parentdirectory, files); return files; } private static void findjavafiles(file parentdirectory, list<file files) { for (file file : parentdirectory.listfiles()) { (file.getname().endswith(“.java”)) files.add(file); else (file.isdirectory()) findjavafiles(file, files); } } public void analyzefile(file javafile) throws exception { bufferedreader = new bufferedreader(new filereader(javafile)); string line; while ((line = .readline()) != null) measureline(line); } private void measureline(string line) { linecount++; int linesize = line.length(); totalchars += linesize; linewidthhistogram.addline(linesize, linecount); recordwidestline(linesize); } private void recordwidestline(int linesize) { (linesize maxlinewidth) { maxlinewidth = linesize; widestlinenumber = linecount; } } public int getlinecount() { return linecount; } int getmaxlinewidth() { return maxlinewidth; } public int getwidestlinenumber() { return widestlinenumber; } public linewidthhistogram getlinewidthhistogram() { return linewidthhistogram; } public double getmeanlinewidth() { return (double)totalchars/linecount; } public int getmedianlinewidth() { integer[] sortedwidths = getsortedwidths(); int cumulativelinecount = ; for (int width : sortedwidths) { cumulativelinecount += linecountforwidth(width); (cumulativelinecount linecount/) return width; } throw new error (“cannot get here”); } private int linecountforwidth(int width) { return linewidthhistogram.getlinesforwidth(width).size(); } private integer[] getsortedwidths() { set<integer widths = linewidthhistogram.getwidths(); integer[] sortedwidths = (widths.toarray(new integer[])); arrays.sort(sortedwidths); return sortedwidths; } } objetos estructuras datos una razón para que las variables sean privadas. queremos que nadie más dependa ellas. queremos poder cambiar tipo implementación cuando deseemos. entonces, ¿por qué tantos programadores añaden automáticamente métodos establecimiento recuperación que muestran sus variables privadas como fueran públicas? abstracción datos fíjese diferencia entre los listados - -. ambos representan los datos punto cartesiano, pero uno muestra implementación otro oculta totalmente. listado - punto concreto. public class point { public double ; public double ; } listado - punto abstracto. public interface point { double getx(); double gety(); void setcartesian(double , double ); double getr(); double gettheta(); void set polar(double , double theta); } mejor del listado - que hay forma saber implementación está coordenadas rectangulares polares. ¡puede que ninguna! aun así interfaz representa sin lugar dudas una estructura datos. pero representa algo más que una estructura datos. los métodos refuerzan una política acceso. puede leer las coordenadas forma , pero debe establecerlas forma conjunta como operación atómica. listado -, por parte, implementa claramente coordenadas rectangulares nos obliga manipularlas forma independiente, que muestra implementación. hecho, mostraría igualmente, aunque las variables fueran privadas usáramos métodos variables establecimiento recuperación. para ocultar implementación basta con añadir una capa funciones entre las variables. basa abstracción. una clase fuerza sus variables través métodos establecimiento recuperación. por contrario, muestra interfaces abstractas que permiten sus usuarios manipular esencia los datos sin necesidad conocer implementación. fíjese los listados - -. primero usa términos concretos para indicar nivel combustible vehículo mientras que segundo hace con abstracción del porcentaje. caso concreto, podemos estar seguros que trata métodos acceso variables. caso abstracto, desconocemos forma los datos. listado - vehículo concreto. public interface vehicle { double getfueltankcapacityingallons(); double getgallonsofgasoline(); } listado - vehículo abstracto. public interface vehicle { double getpercentfuelremaining(); } ambos casos, segunda opción preferible. queremos mostrar los detalles los datos, sino expresarlos términos abstractos. esto consigue simplemente mediante interfaces métodos establecimiento recuperación. hay que meditar seriamente forma óptima representar los datos que contiene objeto. peor opción añadir métodos recuperación ciegas. antisimetría datos objetos estos dos ejemplos ilustran diferencia entre objetos estructuras datos. los objetos ocultan sus datos tras abstracciones muestran funciones que operan dichos datos. estructura datos muestra sus datos carece funciones con significado. vuelva leerlos. fíjese naturaleza complementaria las dos definiciones. son virtualmente opuestas. puede parecer una diferencia menor, pero tiene importantes implicaciones. fíjese ejemplo del listado -. clase geometry opera las tres clases formas, que son sencillas estructuras datos sin comportamiento. todo comportamiento encuentra clase geometry. listado - forma mediante procedimientos. public class square { public point topleft; public double side; } public class rectangle { public point topleft; public double height; public double width; } public class circle { public point center; public double radius; } public class geometry { public final double = .; public double area(object shape) throws nosuchshapeexception { (shape instanceof square) { square = (square)shape; return .side * .side; } else (shape instanceof rectangle) { = (rectangle)shape; return .height * .width; } else (shape instanceof circle) { circle = (circle)shape; return * .radius * .radius; } throw new nosuchshapeexception(); } } los programadores orientados objetos quejarán que ejemplo procedimiento, tienen razón. imagine qué pasaría añadimos función perimeter() geometry . ¡las clases formas verían afectadas! ¡ las demás clases que dependieran las formas tampoco! por otra parte, añado una nueva forma, tendría que cambiar todas las funciones geometry . vuélvalo leer. comprobará que las dos condiciones son diametralmente opuestas. fíjese ahora solución orientada objetos del listado -. aquí, método area() polimórfico. necesita una clase geometry . por tanto, añado una nueva forma, ninguna las funciones existentes ven afectadas, pero añado otra función, habrá que cambiar todas las formas [] . listado - formas polimórficas. public class square implements shape { private point topleft; private double side; public double area() { return side*side; } public class rectangle implements shape { private point topleft; private double height; private double width; public double area() { return height * width; } } public class circle implements shape { private point center; double radius; public final double = .; public double area() { return * radius * radius; } } nuevo, vemos naturaleza complementaria estas dos definiciones; totalmente contrarias. esto ilustra dicotomía fundamental entre objetos estructuras datos: código por procedimientos ( que usa estructuras datos) facilita inclusión nuevas funciones sin modificar las estructuras datos existentes. código orientado objetos, por parte, facilita inclusión nuevas clases sin cambiar las funciones existentes. complemento también cierto: código por procedimientos dificulta inclusión nuevas estructuras datos que necesario cambiar todas las funciones. código orientado objetos dificulta inclusión nuevas funciones que necesario cambiar todas las clases. por tanto, que difícil para programación orientada objetos fácil para los procedimientos, viceversa. cualquier sistema complejo habrá ocasiones las que queramos añadir nuevos tipos datos lugar nuevas funciones. dichos casos, los objetos programación orientada objetos más adecuado. por otra parte, ocasiones tendremos que añadir nuevas funciones lugar tipos datos, para que resulta más adecuado usar código por procedimientos estructuras datos. los programadores experimentados saben que idea que todo objeto mito. ocasiones solamente queremos sencillas estructuras datos con procedimientos que operen las mismas. ley demeter existe una conocida heurística denominada ley demeter [] que afirma que módulo debe conocer los entresijos los objetos que manipula. como vimos apartado anterior, los objetos ocultan sus datos muestran operaciones, que significa que objeto debe mostrar estructura interna través métodos acceso que, hace, mostraría, ocultaría, estructura interna. concreto, ley demeter afirma que método una clase sólo debe invocar los métodos : . objeto creado por . objeto pasado como argumento . objeto una variable instancia . método debe invocar métodos objetos devueltos por ninguna las funciones permitidas. decir, hable con desconocidos, sólo con amigos. siguiente código [] parece incumplir ley demeter (entre otras cosas) que invoca función getscratchdir() valor devuelto getoptions() después invoca getabsolutepath() valor devuelto getscratchdir() . final string outputdir = ctxt.getoptions().getscratchdir().getabsolutepath(); choque trenes ese tipo código suele denominarse choque trenes que asemeja grupo vagones tren. estas cadenas invocaciones suelen considerarse estilo descuidado deben evitarse []. conviene dividirlas esta forma: options opts = ctxt.getoptions(); file scratchdir = opts.getscratchdir(); string outputdir = scratchdir.getabsolutepath(); ¿incumplen estos dos fragmentos código ley demeter? sin duda módulo contenedor sabe que objeto ctxt contiene opciones, que contienen directorio scratch , que tiene una ruta absoluta. función sabe demasiado. función que realiza invocación sabe cómo desplazarse por numerosos objetos diferentes. incumple ley demeter depende ctxt , options scratchdir son objetos estructuras datos. son objetos, debería ocultarse estructura interna, mostrarse, conocer sus detalles internos sería claro incumplimiento ley demeter. por otra parte, ctxt , options scratchdir son simples estructuras datos, mostrarán estructura interna con naturalidad ley demeter aplica. uso funciones acceso complica problema. código hubiera escrito esta otra forma, probablemente nos preocuparíamos incumple ley demeter . final string outputdir = ctxt.options.scratchdir.absolutepath; problema sería menos confuso las estructuras datos tuvieran variables públicas funciones, los objetos tuvieran variables privadas funciones públicas. sin embargo, existen estructuras estándares (como los bean ) que exigen que incluso una sencilla estructura datos tenga elementos acceso mutación. híbridos esta confusión genera ocasionalmente desafortunadas estructuras híbridas mitad objeto mitad estructura datos. tienen funciones que realizan tareas significativas también variables públicas método públicos acceso mutación que hacen que las variables privadas sean públicas, tientan otras funciones externas usar dichas variables misma forma que programa por procedimientos usaría una estructura datos [] . estos dificultan inclusión nuevas funciones también nuevas estructuras datos. son peor ambos mundos. evítelos. indican diseño descuidado cuyos autores dudan, peor todavía, desconocen, necesitan protegerse funciones tipos. ocultar estructura ¿qué pasaría ctxt , options scratchdir fueran objetos con comportamiento real? como los objetos deben ocultar estructura interna, podríamos desplazarnos por los mismos. entonces, ¿cómo obtendríamos ruta absoluta del directorio scratch ? ctxt.getabsolutepathofscratchdirectoryoption(); ctxt.getscratchdirectoryoption().getabsolutepath() primera opción provocaría una explosión métodos objeto ctxt . segunda asume que getscratchdirectoryoption() devuelve una estructura datos, objeto. ninguna las opciones parece correcta. ctxt objeto, deberíamos indicarle que hiciera algo, preguntar sobre sus detalles internos. entonces, ¿para qué queremos ruta absoluta del directorio scratch ? ¿cómo vamos usarla? fíjese este código del mismo módulo (muchas líneas después): string outfile = outputdir + “/” + classname.replace(‘.’, ‘/’) + “.class”; fileoutputstream fout = new fileoutputstream(outfile); bufferedoutputstream bos = new bufferedoutputstream(fout); mezcla distintos niveles detalle [][] preocupante. puntos, guiones, extensiones archivo objetos file deben mezclarse esta forma, junto código contenedor. ignoramos, vemos que intención obtener ruta absoluta del directorio scratch crear archivo borrador nombre concreto. ¿ dijéramos objeto ctxt que hiciera esto? bufferedoutputstream bos = ctxt.createscratchfilestream(classfilename); parece algo razonable para objeto. permite ctxt ocultar sus detalles internos impide que función actual incumpla ley demeter por objetos que debería conocer. objetos transferencia datos quintaesencia una estructura datos una clase con variables públicas sin funciones. ocasiones denomina objeto transferencia datos ( data transfer object otd). los otd son estructuras muy útiles, especial para comunicarse con bases datos analizar mensajes conexiones, etc. suelen ser los primeros una serie fases traducción que convierten datos sin procesar objetos código aplicación. más común forma bean mostrada listado -. los bean tienen variables privadas manipuladas por métodos establecimiento recuperación. cuasi-encapsulación bean hace que algunos puristas programación orientada objetos sientan mejor pero ofrece ningún otro beneficio. listado - address.java public class address { private string street; private string streetextra; private string city; private string state; private string zip; public address(string street, string streetextra, string city, string state, string zip) { this.street = street; this.streetextra = streetextra; this.city = city; this.state = state; this.zip = zip; } public string getstreet() { return street; } public string getstreetextra() { return streetextra; } string getcity() { return city; } public string getstate() { return getstate; } public string getzip() { return zip; } } registro activo los registros activos son una forma especial otd. son estructuras datos con variables públicas ( acceso por bean) pero suelen tener métodos navegación como save find . por general, estos registros activos son traducciones directas tablas base datos otros orígenes datos. desafortunadamente, muchos programadores intentan procesar estas estructuras datos como fueran objetos les añaden métodos reglas empresariales. algo extraño que crea híbrido entre una estructura datos objeto. solución, evidentemente, consiste considerar registro activo una estructura datos crear objetos independientes que contengan las reglas empresariales que oculten sus datos internos (que probablemente sean instancias del propio registro activo). conclusión los objetos muestran comportamiento ocultan datos. esto facilita inclusión nuevos tipos objetos sin necesidad cambiar los comportamientos existentes. también dificulta inclusión nuevos comportamientos objetos existentes. las estructuras datos muestran datos carecen comportamiento significativo. esto facilita inclusión nuevos comportamientos las estructuras datos existentes, pero dificulta inclusión nuevas estructuras datos funciones existentes. sistema, ocasiones necesitaremos flexibilidad añadir nuevos tipos datos, por que preferimos objetos para esa parte del sistema. otros casos, querremos añadir nuevos comportamientos, para que preferimos tipos datos procedimientos esa parte del sistema. los buenos programadores software entienden estos problemas sin prejuicios eligen enfoque más adecuado para cada tarea concreta. bibliografía [refactoring] : refactoring: improving the design existing code , martin fowler ., addison-wesley, . procesar errores por michael feathers parecerá extraño encontrar una sección control errores libro sobre código limpio. control errores algo que todos tenemos que hacer programar. las entradas pueden ser incorrectas los dispositivos pueden fallar, cuando hacen, los programadores somos responsables comprobar que código hace que debe hacer. obstante, conexión con código limpio debe ser evidente. muchas bases código están totalmente dominadas por control errores. cuando digo que están dominadas, quiero decir que únicamente realicen control , sino que prácticamente imposible ver que código hace debido todo ese control errores. control errores importante, pero oscurece lógica, incorrecto . este capítulo detallaremos diversas técnicas consideraciones que puede usar para crear código limpio robusto, código que procese los errores con elegancia estilo. usar excepciones lugar códigos devueltos pasado, muchos lenguajes carecían excepciones. las técnicas para procesar informar errores eran limitadas. definía indicador error devolvía código error que invocador podía comprobar. código del listado - ilustra estos enfoques. listado - devicecontroller.java. public class devicecontroller { … public void sendshutdown() { devicehandle handle = gethandle(dev); // comprobar estado del dispositivo (handle != devicehandle.invalid) { // guardar estado del dispositivo campo registro retrievedevicerecord(handle); // está suspendido, cerrarlo { record.getstatus() != device_suspended) { pausedevice(handle); cleardeviceworkqueue(handle); closedevice(handle); } else { logger.log(“device suspended. unable shut down”); } } else { logger.log(“invalid handle for: ” + dev.tostring()); } } … } problema estos enfoques que confunden invocador. invocador debe comprobar inmediatamente los errores después . desafortunadamente, algo que suele olvidar. por ello, más recomendable generar una excepción detectar error. código invocación más limpio. lógica oscurece por control errores. listado - muestra código tras generar una excepción los métodos que pueden detectar errores. listado - devicecontroller.java (con excepciones). public class devicecontroller { … public void sendshutdown() { try { trytoshutdown(); } catch (deviceshutdownerror ) { logger.log(); } } private void trytoshutdown() throws deviceshutdownerror { devicehandle handle = gethandle(dev); devicerecord record = retrievedevicerecord(handle); pausedevice(handle); cleardeviceworkqueue(handle); closedevice(handle); } private devicehandle gethandle(deviceid ) { … throw new deviceshutdownerror(“invalid handle for: ” - .tostring()); … } … } comprobará que mucho más limpio. cuestión estética. código mejor porque solventan dos preocupaciones: algoritmo para apagar dispositivo control errores ahora encuentran separados. puede ver cada uno ellos entenderlos forma independiente. crear primero instrucción try-catch-finally los aspectos más interesantes las excepciones que definen ámbito programa. ejecutar código parte try una instrucción try-catch-finally , indicamos que ejecución puede cancelar cualquier momento después retomar catch . los bloques try son como las transacciones, catch debe salir del programa estado coherente, independientemente que suceda try . por este motivo, aconsejable iniciar con una instrucción try-catch- finally código que genere excepciones. este modo define que debe esperar usuario del código, independientemente que produzca error código ejecutado cláusula try . veamos ejemplo. imagine que tiene que crear código que acceda archivo lea objetos serializados. comenzamos con una prueba unidad que muestra que obtendremos una excepción cuando archivo exista: @test(expected = storageexception.class) public void retrievesectionshouldthrowoninvalidfilename() { sectionstore.retrievesection(“invalid - file”); } prueba nos lleva crear siguiente: public list<recordedgrip retrievesection(string sectionname) { // devuelve resultado ficticio hasta tener una implementación real return new arraylist<recordedgrip(); } nuestra prueba falla que genera una excepción. tras ello, cambiamos implementación para que intente acceder archivo válido. esta operación genera una excepción: public list<recordedgrip retrievesection (string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname) } catch (exception ) { throw new storageexception(“retrieval error”, ); } return new arraylist<recordedgrip(); } ahora prueba correcta que capturamos excepción podemos refactorizar. podemos reducir tipo excepción capturada para que coincida con tipo generado desde constructor fileinputstream: : public list<recordedgrip retrievesection(string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname); stream.close(); } catch (filenotfoundexception ) { throw new storageexception(“retrieval error”, ); } return new arraylist<recordedgrip(); } ahora que hemos definido ámbito con una estructura try-catch , podemos usar tdd para diseñar resto lógica necesaria. dicha lógica añade entre creación fileinputstream cierre, podemos pretender que pasa nada incorrecto. intente crear pruebas que fuercen las excepciones, para después añadir controlador comportamiento que satisfaga dichas pruebas. este modo primero creará ámbito transacción del bloque try podrá mantener naturaleza transacción del ámbito. usar excepciones sin comprobar debate terminado. durante años, los programadores java han debatido las ventajas los problemas las excepciones comprobadas. cuando aparecieron primera versión java, parecían una gran idea. firma todos los métodos enumeraría todas las excepciones que podían pasar invocador. más, estas excepciones formaban parte del tipo del método. código compilaría firma coincidía con que código iba hacer. aquel momento, pensábamos que las excepciones comprobadas eran una gran idea , ofrecían ciertas ventajas. sin embargo, ahora evidente que necesitan para crear software robusto. # carece excepciones comprobadas , pesar los intentos, ++ tampoco, como sucede python ruby. todos estos lenguajes puede crear software robusto. por ello, debemos decidir las excepciones comprobadas valen precio. ¿qué precio? precio las excepciones comprobadas del principio abierto/cerrado [] . genera una excepción comprobada desde método código cláusula catch encuentra tres niveles por debajo, debe declarar dicha excepción firma todos los métodos comprendidos entre posición catch . esto significa que cambio nivel inferior del software puede forzar cambios firma muchos niveles superiores. será necesario volver generar implementar los módulos cambiados, aunque cambien los elementos los que hacen referencia. piense jerarquía invocación sistema. las funciones parte superior invocan las funciones situadas debajo, que invocan otras funciones inferiores así sucesivamente. imagine que una las funciones nivel inferior modifica forma que debe generar una excepción. excepción comprueba, firma función tendrá que añadir una cláusula throws . pero esto significa que todas las funciones que invoquen nuestra función modificada también tendrán que cambiarse para capturar nueva excepción para añadir correspondiente cláusula throws firma. así indefinidamente. resultado final una cascada cambios que pasan desde los niveles inferiores del software hasta los superiores. encapsulación rompe que todas las funciones ruta throw deben conocer detalles excepción nivel inferior. como cometido las excepciones permitimos procesar errores distancia, una lástima que las excepciones comprobadas rompan encapsulación esta forma. las excepciones comprobadas pueden ser útiles tiene que crear una biblioteca crítica: tendrá que capturarlas. pero desarrollo aplicaciones generales, los costes dependencia superan las ventajas. ofrecer contexto junto las excepciones las excepciones que genere deben proporcionar contexto adecuado para determinar origen ubicación error. java, puede obtener rastreo pila cualquier excepción; sin embargo, indicará cometido función fallida. redacte mensajes error informativos páselos junto sus . mencione operación fallida tipo fallo. guarda registros aplicación, incluya información suficiente para poder registrar error cláusula catch . definir clases excepción acuerdo las necesidades del invocador existen varias formas clasificar los errores. podemos hacerlo por origen (¿provienen uno otro componente?) por tipo (¿son fallos del dispositivo, red errores programación?). sin embargo, definir clases excepción una aplicación, debemos preocuparnos principalmente cómo capturan . veamos pobre ejemplo clasificación excepciones. una instrucción try-catch-finally invocación una biblioteca terceros. abarca todas las excepciones que las invocaciones pueden generar: acmeport port = new acmeport(); try { port.open(); } catch (deviceresponseexception ) { reportporterror(); logger.log{“device response exception”, ); } catch (atm ) { reportporterror(); logger.log(“unlock exception”, ); } catch (gmxerror ) { reportporterror(); logger.log(“device response exception”); } finally { … } esta instrucción contiene elementos duplicados, algo que debería sorprendernos. muchos casos control excepciones, trabajo que realizamos relativamente estándar independientemente causa real. debemos registrar error asegurarnos poder continuar. este caso, como sabemos que trabajo mismo independientemente excepción, podemos simplificar código incluimos api invocada nos aseguramos que devuelve tipo común: localport port = new localport(); try { port.open(); } catch (portdevicefailure ) { reporterror(); logger.log(.getmessage(), ); } finally { … } nuestra clase localport simple envoltorio que captura traduce excepciones generadas por clase acmeport : public class localport { private acmeport innerport; public localport(int portnumber) { innerport = new acmeport(portnumber); } public void open() { try { innerport.open(); } catch (deviceresponseexception ) { throw new portdevicefailure(); } catch (atm ) { throw new portdevicefailure(); } catch (gmxerror ) { throw new portdevicefailure(); } } … } los envoltorios como definido para acmeport pueden ser muy útiles. hecho, recomendable envolver api terceros. hacerlo, minimizan las dependencias: puede cambiar otra biblioteca diferente sin apenas problemas envoltorio también facilita imitar invocaciones terceros cuando prueba código. una última ventaja que estamos limitados las decisiones diseño api determinado fabricante. puede definir una api que resulte cómoda. ejemplo anterior, definimos único tipo excepción para fallo puertos podemos escribir código mucho más limpio. menudo, una única clase excepción suficiente para una zona concreta del código. información enviada con excepción puede distinguir los errores. use clases diferentes para capturar una excepción permitir paso otra distinta. definir flujo normal sigue los consejos apartados anteriores, realizará una importante separación entre lógica empresarial control errores. mayoría código parecerá algoritmo limpio sin adornos. sin embargo, proceso desplaza detección errores hacia los bordes del programa. debe envolver api externas para poder generar sus propias excepciones definir controlador por encima del código para poder procesar cálculos cancelados. muchos casos enfoque más acertado, pero ocasiones conviene cancelar. veamos ejemplo, código extraño que suma gastos una aplicación facturación: try { mealexpenses expenses = expensereportdao.getmeals(employee.getid()); m_total += expenses.gettotal(); } catch(mealexpensesnotfound ) { m_total += getmealperdiem(); } esta empresa, las comidas son gastos, pasan formar parte del total. son, los trabajadores reciben una cantidad diaria para comida. excepción entorpece lógica. sería más adecuado tener que procesar caso especial código sería mucho más sencillo: mealexpenses expenses = expensereportdao.getmeals(employee.getid()); m_total += expenses.gettotal(); ¿ verdad que código puede ser tan simple? pues . podemos cambiar expensereportdao para que siempre devuelva objeto mealexpense . hay gastos comida, devuelve objeto mealexpense que devuelve dieta diaria como total: public class perdiemmealexpenses implements mealexpenses { public int gettotal() { // devolver dieta diaria predeterminada } } que denomina patrón caso especial [fowler]. crea una clase configura objeto que procese caso especial. hacerlo, código cliente tiene que procesar comportamientos excepcionales. dichos comportamientos encapsulan objeto caso especial. devolver null creo que toda descripción del control errores debe mencionar los elementos proclives errores. primero devolver null. perdido cuenta cantidad aplicaciones que las que línea línea también comprueba null: public void registeritem(item item) { (item != null) { itemregistry registry = peristentstore.getitemregistry(); (registry != null) { item existing = registry.getitem(item.getid()); (existing.getbillingperiod().hasretailowner()) { existing.register(item); } } } } trabaja una base código como ésta, puede que parezca tan mala, pero . devolver null , básicamente nos creamos trabajo generamos problemas para los invocadores. basta con que falte una comprobación null para que aplicación pierda control. ¿ fijado que hay una comprobación null segunda línea instrucción anidada? ¿qué sucedería tiempo ejecución persistentstore fuera null ? generaría nullpointerexception tiempo ejecución capturaría nullpointerexception nivel superior . ambos casos incorrecto. ¿qué debería hace como respuesta generación nullpointerexception desde interior aplicación? puede afirmar que problema este código ausencia una comprobación null pero realidad problema exceso. tentación devolver null desde método, pruebe generar una excepción devolver objeto caso especial. invoca método que devuelva null desde una api terceros, envuélvalo método que genere una excepción devuelva objeto caso especial. muchos casos, los objetos caso especial son remedio sencillo. imagine que tiene siguiente código: list<employee employees = getemployees(); (employees != null) { for(employee : employees) { totalpay += .getpay(); } } ahora, getemployees puede devolver null , ¿pero necesario? cambiamos getemployee para que devuelva una lista vacía, podremos limpiar código: list<employee employees = getemployees(); for(employee : employees) { totalpay += .getpay(); } afortunadamente, java dispone collections.emptylist() devuelve una lista inmutable predefinida que podemos usar para este cometido: public list<employee getemployees() { (… there are employees …) return collections.emptylist(); } usa este tipo código, minimizará presencia nullpointerexception código será más limpio. pasar null devolver null desde métodos incorrecto, pero peor pasar null métodos. menos que trabaje con una api que espere que pase null , debe evitarlo siempre que sea posible. veamos otro ejemplo, sencillo método que calcula una métrica para dos puntos: public class metricscalculator { public double xprojection(point , point ) { return (. – .) * .; } … } ¿qué sucede cuando alguien pasa null como argumento? calculator.xprojection(null, new point (, )); genera nullpointerexception , evidentemente. ¿cómo solucionarlo? podríamos crear nuevo tipo excepción generarla: public class metricscalculator { public double xprojection(point , point ) { (==null || ==null) { throw invalidargumentexception( “invalid argument for metricscalculator.xprojection”); } return (. – .) * .; } } } ¿mejor? puede que sea mejor que una excepción puntero nulo, pero recuerde que debe definir controlador para invalidargumentexception . ¿qué debe hacer controlador? ¿hay alguna forma correcta hacerlo? existe otra alternativa, usar grupo afirmaciones: public class metricscalculator ( public double xprojection{point , point ) { assert != null : “ should not null”; assert != null : “ should not null”; return (. - .) * .; } } documentación correcta pero soluciona problema. alguien pasa null , seguirá produciéndose error tiempo ejecución. mayoría lenguajes programación hay una forma correcta procesar null pasado por accidente. como éste caso, enfoque racional impedir que pase null forma predeterminada. hace, puede diseñar código sabiendo que null una lista argumentos indica problema los errores serán menores. código limpio legible pero también debe ser robusto. son objetivos opuestos. podemos crear código limpio robusto consideramos control errores una preocupación diferente, algo que vemos forma independiente desde nuestra lógica principal. somos capaces lograrlo, razonaremos forma independiente podemos aumentar capacidad mantenimiento nuestro código. bibliografía [martin] : agile software development: principles, patterns, and practices , robert . martin, prentice hall, . límites por james grenning habitual que controlemos todo software nuestros sistemas. ocasiones, adquirimos paquetes terceros usamos código abierto. otros casos, dependemos equipos nuestra propia empresa para producir subsistemas que utilizamos. algún modo debemos integrar este código externo con nuestro. este capítulo veremos prácticas técnicas para definir con claridad los límites nuestro software . utilizar código terceros existe una tensión natural entre proveedor una interfaz usuario misma. los proveedores paquetes estructuras terceros abogan por una capacidad aplicación global para poder trabajar diversos entornos atraer público más amplio. los usuarios, por parte, desean una interfaz centrada sus necesidades concretas. esta tensión puede provocar problemas los límites nuestros sistemas. analicemos java.util.map como ejemplo. como puede apreciar siguiente lista. map tiene una amplia interfaz con numerosas prestaciones. esta potencia flexibilidad muy útil, pero también puede ser problema. por ejemplo, nuestra aplicación puede generar map compartirlo. nuestra intención puede que sea que ninguno los receptores del mapa borre sus elementos. pero parte superior lista encontramos método clear() . cualquier usuario del mapa puede borrarlo. puede que nuestra convención diseño determine que sólo puedan almacenar objetos concretos mapa, pero map limita forma fiable los tipos objetos que admite. cualquier usuario puede añadir elementos cualquier tipo cualquier mapa. clear() void - map containskey (object key) boolean - map containsvalue (object value) boolean - map entryset() set - map equals(object ) boolean - map get(object key) object - map getclass() class<? extends object - object hashcode() int - map isempty() boolean - map keyset() set - map notify() void - object () void - object put(object key, object value) object - map putall(map ) void - map remove(object key) object - map size() int - map tostring() string - object values() collection - map wait() void - object wait(long timeout) void - object wait(long timeout, int nanos) void - object figura .. los métodos map nuestra aplicación necesita mapa sensor , comprobará que los sensores definen esta forma: map sensors = new hashmap(); tras ello, cuando otra parte del código necesite acceder sensor, vemos este código: sensor = (sensor)sensors.get(sensorid); vemos una sola vez, sino repetidamente largo del código. cliente este código responsable obtener objeto map convertirlo tipo correcto. funciona, pero código limpio. además, este código cuenta historia como debería. legibilidad del código podría mejorar mediante uso genéricos, como indica continuación: map<sensor sensors = new hashmap<sensor(); … sensor = sensors.get(sensorid); sin embargo, esto soluciona problema que map<sensor ofrezca más prestaciones las que necesitamos deseamos. pasar una instancia map<sensor sistema, significa que habrá muchos puntos que corregir interfaz map cambia. seguramente piense que son cambios improbables, pero recuerde que han producido añadir compatibilidad con genéricos java . sin duda hemos visto sistemas que impiden uso genéricos debido gran cantidad cambios necesarios para compensar uso liberal map . una forma más limpia usar map sería siguiente. ningún usuario importa usan genéricos . esa opción convertido ( siempre debería serlo) detalle implementación. public class sensors { private map sensors = new hashmap(); public sensor getbyid(string ) { return (sensor) sensors.get(); } //corte } interfaz límite (map) está oculta. conseguido evolucionar sin apenas impacto resto aplicación. uso genéricos problema que conversión administración tipos procesa dentro clase sensors . esta interfaz también ajustado limitado las necesidades aplicación. genera código más fácil entender con menor probabilidad errores. clase sensors puede aplicar las reglas empresariales diseño. sugerimos que encapsulen esta forma todos los usos map, sino que pase map ( otras interfaces límite) por sistema. usa una interfaz límite como map , manténgala dentro clase familia clases que use. evite devolverla aceptarla como argumento api públicas. explorar aprender límites código terceros nos permite obtener mayor funcionalidad menos tiempo. ¿por dónde empezamos cuando queremos utilizar paquete terceros? nuestra labor probar código, pero crear pruebas para código terceros que utilicemos. imagine que evidente cómo usar una biblioteca terceros. podríamos perder uno varios días leer documentación decidir cómo usarla. tras ello, podríamos escribir código para usar código terceros comprobar comporta forma esperada. deberíamos sorprendernos por tener que realizar extensas sesiones depuración intentando localizar errores nuestro código suyo. código terceros complicado, también integrarlo. hacer ambas cosas mismo tiempo doble complicado. necesitamos enfoque diferente. lugar experimentar probar nuevo material nuestro código producción, podríamos crear pruebas que analicen nuestro entendimiento del código terceros. jim newkirk las denomina pruebas aprendizaje [] . las pruebas aprendizaje, invocamos api terceros como supuestamente usaríamos nuestra aplicación. básicamente realizamos experimentos controlados para comprobar entendemos. las pruebas centran que queremos obtener api. aprender log imagine que desea usar paquete apache log lugar propio dispositivo registro personalizado. descarga abre página inicial documentación. sin una lectura exhaustiva, crea primer caso prueba con esperanza que escriba hello consola. @test public void testlogcreate() { logger logger = logger.getlogger(“mylogger”); logger.info(“hello”); } ejecutarlo, registrador genera error que nos indica que necesitamos algo denominado appender . tras investigar, descubrimos que existe elemento consoleappender . creamos consoleappender comprobamos hemos conseguido revelar los secretos del registro consola. @test public void testlogaddappender() { logger logger = logger.getlogger (“mylogger”); consoleappender appender = new consoleappender(); logger.addappender(appender); logger.info(“hello”); } esta ocasión descubrimos que appender carece flujo salida, algo extraño, que parece lógico que tuviera. tras recurrir google, siguiente: @test public void testlogaddappender() { logger logger = logger.getlogger(“mylogger”); logger.removeallappenders(); logger.addappender(new consoleappender( new patternlayout(“% % %%”), consoleappender.system_out)); logger.info(“hello”); } funciona; consola aparece mensaje con palabra hello . resulta extraño tener que indicarle consoleappender que escriba consola. eliminar argumento consoleappender.systemout , vemos que hello sigue impreso. pero eliminar patternlayout , nuevo vemos queja falta flujo salida. comportamiento muy extraño. nos fijamos documentación, vemos que constructor consoleappender predeterminado está configurado, que parece demasiado obvio útil. parece más bien error una incoherencia log . tras nuevas búsquedas google, investigaciones pruebas, conseguimos listado -. hemos descubierto cómo funciona log hemos codificado esos conocimientos grupo sencillas pruebas unidad. listado - logtest.java. public class logtest ( private logger logger; @before public void initialize() { logger = logger.getlogger(“logger”); logger.removeallappenders(); logger.getrootlogger().removeallappenders(); } @test public void basiclogger() { basicconfigurator.configure(); logger.info(“basiclogger”); } @test public void addappenderwithstream() { logger.addappender(new consoleappender( new patternlayout (“% % %%”), consoleappender.system_out)); logger.info(“addappenderwithstream”); } @test public void addappenderwithoutstream() { logger.addappender(new consoleappender( new patternlayout(“% % %%”))); logger.info(“addappenderwithoutstream”); } } ahora sabemos cómo inicializar sencillo registrador consola encapsular ese conocimiento nuestra propia clase registro para que resto aplicación aísle interfaz límite log . las pruebas aprendizaje son algo más que gratuitas las pruebas aprendizaje cuestan nada. todas formas, hemos tenido que aprender api crear las pruebas fue una forma sencilla aislada adquirir esos conocimientos. las pruebas aprendizaje fueron experimentos precisos que permitieron aumentar nuestros conocimientos. las pruebas sólo son gratuitas, sino también rentables. cuando aparezcan nuevas versiones del paquete terceros, ejecutamos las pruebas aprendizaje para comprobar hay diferencias comportamiento. las pruebas aprendizaje demuestran que los paquetes terceros que usamos funcionan forma esperada. una vez integrados, hay garantía que código terceros sea compatible con nuestras necesidades. los autores originales verán presionados para cambiar código ajustarlo sus propias necesidades. corregirán errores añadirán nuevas funciones. cada versión surgirán nuevos riesgos. paquete terceros cambia una forma incompatible con nuestras pruebas, sabremos instante. independientemente que necesite los conocimientos proporcionados por las pruebas aprendizaje, límite claro debe estar respaldado por conjunto pruebas que ejerciten interfaz misma forma que hace producción. sin estas pruebas límites para facilitar transición, podríamos conservar versión antigua más tiempo del necesario. usar código que todavía existe existe otro tipo límite, que separa conocido desconocido. ocasiones, nuestro conocimiento del código parece desvanecerse. que hay otro lado del límite desconocido ( menos por momento). ocasiones, decidimos mirar más allá del límite. hace años formé parte equipo desarrollo software para sistema comunicación por radio. había subsistema, transmisor, que apenas conocíamos cuya interfaz todavía había diseñado. como queríamos quedarnos parados, comenzamos trabajar alejándonos parte desconocida del código. sabíamos perfectamente dónde acababa nuestro mundo comenzaba nuevo. mientras avanzábamos, ocasiones nos topábamos con este límite. aunque ignorancia ocultaba nuestra visión más allá del límite, sabíamos cómo queríamos que fuera interfaz. queríamos decirle transmisor algo como siguiente: ajustar transmisor frecuencia proporcionada emitir una representación analógica los datos que provienen este flujo. sabíamos cómo hacerlo que todavía había diseñado api. por ello decidimos determinar después los detalles. para quedarnos bloqueados, definimos nuestra propia interfaz. dimos nombre sencillo, transmitter . asignamos método transmit que aceptaba una frecuencia flujo datos. interfaz que deseábamos haber tenido. mejor escribir interfaz que deseábamos haber tenido era que controlábamos. esto hace que código cliente sea más legible ciña los objetivos previstos. figura . aprecia que aislamos las clases api del transmisor (que controlábamos estaba por definir). usar nuestra propia interfaz específica aplicación, código communicationscontroller era limpio expresivo. una vez definida api del transmisor, creamos transmitteradapter para reducir las distancias. adaptador [] encapsulaba interacción con api ofrecía único punto que evolucionaba. figura .. predicción del transmisor este diseño también nos ofrece sello [] código para realizar pruebas. con elemento faketransmitter , podemos probar las clases communicationscontroller . también podemos crear pruebas límite una vez diseñada api transmitter para asegurarnos que utilizamos correctamente. límites limpios los límites suceden cosas interesantes. los cambios una ellas. los diseños código correctos acomodan los cambios sin necesidad grandes modificaciones. cuando usamos código que controlamos, hay que prestar especial atención proteger nuestra inversión asegurarnos que los cambios futuros son demasiado costosos. código los límites requiere una separación evidente pruebas que definan expectativas. debemos evitar que código conozca los detalles terceros. más aconsejable depender algo que controlemos que algo que controlemos, menos todavía nos controla. los límites terceros gestionan gracias presencia mínimos código que hagan referencia los mismos. podemos envolverlos como hicimos con map usar adaptador para convertir nuestra interfaz perfecta interfaz proporcionada. cualquier caso, código lee mejor, promueve uso coherente interno límite hay menos puntos mantenimiento cuando cambie código terceros. bibliografía [becktdd] : test driven development , kent beck, addison-wesley, . [gof] : design patterns: elements reusable object oriented software , gamma ., addison wesley, %. [welc] : working effectively with legacy code , addison-wesley, . pruebas unidad nuestra profesión evolucionado mucho los últimos años. nadie había oído hablar del desarrollo guiado por pruebas (dgp). para mayoría, las pruebas unidad eran pequeños fragmentos código que creábamos para asegurarnos que nuestros programas funcionaban. escribíamos clases métodos, después código hoc para probarlos, que implicaba algún tipo programa controlador que nos permitiera interactuar manualmente con programa que habíamos escrito. recuerdo crear programa ++ para sistema incrustado tiempo real mediados década . programa era sencillo temporizador con siguiente firma: void timer::schedulecommand(command* thecommand, int milliseconds) idea era sencilla; método execute command ejecutaba nuevo subproceso tras número especificado milisegundos. problema era cómo probarlo. confeccioné sencillo programa controlador que escuchaba teclado. cada vez que introducía carácter, programaba comando que escribía mismo carácter cinco segundos después. introduje una rítmica melodía teclado esperé que reprodujera pantalla cinco segundos después: «… want--girl… just… like-the-girl-who-marr… ied… dear… old… dad.» incluso tarareé melodía mientras pulsaba tecla, volví cantar cuando aparecieron los puntos pantalla. ésa fue prueba. cuando que funcionaba mostré mis compañeros, deshice del código prueba. como afirmado, nuestra profesión evolucionado mucho. ahora crearía una prueba que garantizara funcionamiento hasta más mínimo detalle del código. aislaría código del sistema operativo lugar invocar las funciones estándar temporización. las imitaría para tener control total sobre tiempo. programaría comandos que definieran indicadores booleanos avanzaría tiempo, para observar los indicadores asegurarme que pasaran false true cambiar tiempo valor correcto. cuando superara una serie pruebas, comprobaría que fueran adecuadas para todo que tuviera que trabajar con código. aseguraría comprobar las pruebas código mismo paquete. , hemos mucho, pero nos queda mucho por avanzar. los movimientos agile tdd han animado muchos programadores crear pruebas unidad automatizadas cada vez son más. pero esta alocada carrera por añadir pruebas nuestra disciplina, muchos programadores han pasado por alto dos los aspectos más sutiles importantes diseñar pruebas calidad. las tres leyes del dgp todos sabemos que dgp nos pide que primero creemos las pruebas unidad, antes que código producción. pero esa norma sólo punta del iceberg. tenga cuenta las tres siguientes leyes [] : primera ley : debe crear código producción hasta que haya creado una prueba unidad que falle. segunda ley : debe crear más una prueba unidad que baste como fallida, compilar considera fallo. tercera ley : debe crear más código producción que necesario para superar prueba fallo actual. estas tres leyes generan ciclo unos segundos duración. las pruebas código producción crean forma conjunta, las pruebas unos segundos antes que código. trabajamos esta forma, crearemos decenas pruebas día, cientos mes miles año. trabajamos esta forma, las pruebas abarcarán todos los aspectos nuestro código producción. tamaño dichas pruebas, que puede ser similar del código producción, puede suponer problema administración. realizar pruebas limpias hace unos años pidieron que dirigiera equipo que había decidido explícitamente que código prueba debía mantenerse con los mismos estándares calidad que código producción. podían incumplir las sus pruebas unidad. premisa era «rápido directo». era necesario que las variables tuvieran nombres adecuados, que las funciones prueba fueran breves descriptivas. era necesario que código prueba estuviera bien diseñado. bastaba con que funcionara abarcara código producción. puede que algunos lectores empaticen con esta decisión. puede que pasado creara tipo pruebas que cree para clase timer . supone gran paso crear ese tipo pruebas desechables diseñar una suite pruebas unidad automatizadas. por ello, como equipo que dirigía, puede decidir que pruebas incorrectas sea mejor que tener pruebas. pero equipo daba cuenta que tener pruebas incorrectas era igual peor que tener prueba alguna. problema que las pruebas deben cambiar acuerdo evolución del código. cuanto menos limpias sean, más difícil cambiarlas. cuando más enrevesado sea código prueba, más probabilidades que dedique más tiempo añadir nuevas pruebas suite que empleado crear nuevo código producción. modificar código producción, las pruebas antiguas comienzan fallar desastre impide que las pruebas superen, por que acaban por convertirse obstáculo interminable. entre versiones, aumentó coste mantener suite pruebas equipo. acabó por convertirse principal queja entre los desarrolladores. cuando los directores preguntaron sobre este aumento, los desarrolladores culparon las pruebas. final, vieron obligados descartar suite pruebas completa. pero sin una suite pruebas perdieron posibilidad garantizar funcionamiento esperado los cambios código. sin una suite pruebas podían asegurar que los cambios una parte del sistema afectaran otras diferentes. los defectos aumentaron, que propició que temieran realizar cambios. dejaron limpiar código producción por miedo que los cambios fueran dañinos. código producción comenzó corromperse. final, quedaron sin pruebas, con código producción enmarañado defectuoso, clientes frustrados sensación que esfuerzo les había fallado. cierto modo tenían razón. esfuerzo les había fallado. pero fue permitir que las pruebas fueran incorrectas que provocó fallo. hubieran empleado pruebas limpias, esfuerzo habría fallado. puedo afirmarlo con cierta seguridad porque participado dirigido muchos equipos que han tenido éxito gracias pruebas unidad limpias. moraleja historia sencilla: código prueba tan importante como producción. ciudadano segunda. requiere concentración, diseño cuidado. debe ser tan limpio como código producción. las pruebas propician posibilidades sus pruebas son limpias, las perderá. sin ellas pierde mismo que hace que código producción sea flexible. , leído bien. las pruebas unidad son las que hacen que código sea flexible pueda mantener reutilizar. razón sencilla. tiene pruebas, tendrá miedo realizar cambios código. sin pruebas, cada cambio posible error. independientemente flexibilidad arquitectura, división del diseño, sin pruebas tendrá miedo realizar cambios por posibilidad añadir errores detectados. pero con las pruebas ese miedo desaparece. cuanto mayor sea alcance sus pruebas, menos miedo tendrá. podrá modificar código con total impunidad, aunque arquitectura sea mejor diseño sea mediocre. podrá mejorar arquitectura diseño sin miedo alguno. por tanto, disponer una suite automatizada pruebas unidad que cubran código producción clave para mantener limpio diseño arquitectura. las pruebas proporcionan las posibilidades, que permiten cambio. sus pruebas son limpias, capacidad modificar código verá limitada perderá posibilidad mejorar estructura dicho código. cuanto menos limpias sean las pruebas, menos será código. última instancia perderá las pruebas código corromperá. pruebas limpias ¿qué hace que una prueba sea limpia? tres elementos: legibilidad, legibilidad legibilidad. legibilidad sin duda más importante las pruebas unidad que código producción. ¿qué hace que una prueba sea legible? mismo que código: claridad, simplicidad densidad expresión. una prueba debe decir mucho con menor número expresiones posible. fíjese código fitnesse del listado -. estas tres pruebas son difíciles entender sin duda pueden mejorar. por lado, hay mucho código duplicado [] las invocaciones repetidas addpage assertsubstring . sobre todo, este código carga con detalles que interfieren con expresividad prueba. listado - serializedpagerespondertest.java. public void testgetpagehieratchyasxml() throws exception { crawler.addpage(root, pathparser.parse(“pageone”)); crawler.addpage(root, pathparser.parse(“pageone.childone”)); crawler.addpage(root, pathparser.parse(“pagetwo”)); request.setresource(“root”); request.addinput(“type”, “pages”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“<namepageone</name”, xml); assertsubstring(“<namepagetwo</name”, xml); assertsubstring(“<namechildone</name”, xml); } public void testgetpagehieratchyasxmldoesntcontainsymboliclinks() throws exception { wikipage pageone = crawler.addpage(root, pathparser.parse(“pageone”)); crawler.addpage(root, pathparser.parse(“pageone.childone”)); crawler.addpage(root, pathparser.parse(“pagetwo”)); pagedata data = pageone.getdata(); wikipageproperties properties = data.getproperties(); symlinks = properties.set(symbolicpage.property_name); symlinks.set(“sympage”, “pagetwo”); pageone.commit(data); request.setresource(“root”); request.addinput(“type”, “pages”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“<namepageone</name”, xml); assertsubstring(“<namepagetwo</name”, xml); assertsubstring(“<namechildone</name”, xml); assertnotsubstring(“sympage”, xml); } public void testgetdataashtml() throws exception { crawler.addpage(root, pathparser.parse(“testpageone”), “test page”); request.setresource(“testpageone”); request.addinput(“type”, “data”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“test page”, xml); assertsubstring(“<test”, xml); } fíjese las invocaciones pathparser . transforman cadenas instancias pagepath usadas por las arañas. esta transformación totalmente irrelevante para prueba únicamente complica cometido. los detalles circundantes creación del respondedor obtención conversión respuesta también sobran. también forma crear url solicitud partir recurso argumento (contribuí crear este código, por que tengo todo derecho criticarlo). final, código diseñado forma legible. lector rodeado miles detalles que debe comprender antes que las pruebas tengan sentido. fíjese ahora las pruebas mejoradas del listado -. hacen exactamente mismo, pero han refactorizado forma más clara . listado - serializedpagerespondertest.java (refactorizado) public void testgetpagehierarchyasxml() throws exception { makepages(“pageone”, “pageone.childone”, “pagetwo”); submitrequest(“root”, “type:pages”); assertresponseisxml(); assertresponsecontains( “<namepageone</name”, “<namepagetwo</name”, “<namechildone</name” ); } public void testsymboliclinksarenotinxmlpagehierarchy() throws exception { wikipage page = makepage(“pageone”); makepages(“pageone.childone”, “pagetwo”); addlinkto(page, “pagetwo”, “sympage”); submitrequest(“root”, “type:pages”); assertresponseisxml(); assertresponsecontains( “<namepageone</name”, “<namepagetwo</name”, “<namechildone</name” ); assertresponsedoesnotcontain(“sympage”); } public void testgetdataasxml() throws exception { makepagewithcontent(“testpageone”, “test page”); submitrequest(“testpageone”, “type:data”); assertresponseisxml(); assertresponsecontains(“test page”, “<test”); } patrón generar-operar-comprobar [] evidente estructura las pruebas. cada una divide claramente tres partes. primera crea los datos prueba, segunda opera dichos datos tercera comprueba que operación devuelva los resultados esperados. comprobará que eliminado gran parte los detalles molestos. las pruebas son concisas sólo usan los tipos datos funciones que realmente necesitan. todo que lea estas pruebas sabrá rápidamente para qué sirven perderá entre detalles irrelevantes. pruebas específico del dominio las pruebas del listado - ilustran creación lenguaje específico del dominio para sus pruebas. lugar usar las api que los programadores emplean para manipular sistema, creamos una serie funciones utilidades que usan dichas api que facilitan escritura lectura las pruebas. estas funciones utilidades convierten una api especializada usada por las pruebas. son lenguaje pruebas que los programadores usan personalmente para crear sus pruebas para ayudar los que después las lean. esta api pruebas diseña con antelación, sino que evoluciona con refactorización continuada del código prueba. igual que refactorizamos listado - listado -, los programadores disciplinados refactorizan código prueba versiones más sucintas expresivas. estándar dual sentido, equipo que mencionamos antes tenía razón. código api pruebas tiene conjunto estándares ingeniería diferentes código producción. también tiene que ser sencillo, sucinto expresivo, pero tan eficaz como código producción. después todo, ejecuta entorno prueba, producción, cada entorno tiene sus propias necesidades. fíjese prueba del listado -. creé como parte prototipo sistema control medioambiental. sin entrar detalles, aprecia que esta prueba comprueba que alarma baja temperatura, calentador fuelle estén activados cuando temperatura sea demasiado fría. listado - environmentcontrollertest.java @test public void turnonlotempalarmatthreashold() throws exception { .settemp(way_too_cold); .tic(); asserttrue(.heaterstate()); asserttrue(.blowerstate()); assertfalse(.coolerstate()); assertfalse(.hitempalarm()); asserttrue(.lotempalarm()); } aquí hay muchos detalles. por ejemplo, ¿para qué sirve función tic ? hecho, ignoraría mientras leemos esta prueba. intente centrarse saber está acuerdo que estado final del sistema tiene que ver con que temperatura sea demasiado baja. leer prueba, vista tiene que cambiar entre nombre del estado comprobado sentido del estado comprobado. vemos heaterstate después vista salta asserttrue . vemos coolerstate nos fijamos assertfalse . resulta tedioso dificulta lectura prueba. conseguido mejorar legibilidad prueba transformándola listado -. listado - environmentcontrollertest.java (refactorizado) @test public void turnonlotempalarmatthreshold() throws exception { waytoocold(); assertequals(“hbchl”, .getstate()); } evidentemente, ocultado detalle función tic creando una función waytoocold . pero importante extraña cadena assertequals . las mayúsculas significan activado las minúsculas desactivado, las letras siempre aparece este orden: {heater, blower, cooler, -temp-alarm, -temp-alarm} . aunque prácticamente sea incumplimiento las reglas asignación mental [] , este caso parece apropiado. una vez que conocemos significado, vista pasa por cadena podemos interpretar los resultados. lectura prueba casi placer. fíjese listado - compruebe con qué facilidad entiende las pruebas. - environmentcontrollertest.java (una selección mayor). @test public void turnoncoolerandbloweriftoohot() throws exception { toohot(); assertequals(“hbchl”, .getstate()); } @test public void turnonheaterandbloweriftoocold() throws exception { toocold(); assertequals(“hbchl”, .getstate()); } @test public void turnonhitempalarmatthreshold() throws exception { waytoohot(); assertequals(“hbchl”, .getstate()); } @test public void turnonlotempalarmatthreshold() throws exception { waytoocold(); assertequals(“hbchl”, .getstate()); } función getstate reproduce listado -. código muy eficaz. para que sea, deberíamos haber usado stringbuffer . listado - mockcontrolhardware.java. public string getstate() { string state = “”; state += heater ? “” : “”; state += blower ? “” : “”; state += cooler ? “” : “”; state += hitempalarm ? “” : “”; state += lotempalarm ? “” : “”; return state; } stringbuffer poco atractivo. incluso código producción, intento evitarlo coste mínimo, como podría suceder listado -. pero esta aplicación claramente sistema incrustado tiempo real probable que los recursos del equipo memoria estén limitados. sin , entorno pruebas improbable que esté. naturaleza del estándar dual. hay cosas que nunca haría entorno producción totalmente válidas para entorno prueba. suelen ser problemas memoria eficacia cpu, pero nunca problemas limpieza. una afirmación por prueba existe una escuela pensamiento [] que afirma que todas las funciones prueba una prueba junit sólo deben tener una instrucción afirmación. puede parecer una regla draconiana pero ventaja aprecia listado - . las pruebas llegan una misma conclusión, que entiende forma rápida sencilla. ¿pero qué sucede con listado -? parece razonable afirmar que resultado xml que contiene determinadas subcadenas. sin embargo, podemos dividir prueba dos, cada una con una afirmación concreta, como muestra listado -. listado - serializedpagerespondertest.java (una sola afirmación). public void testgetpagehierarchyasxml() throws exception { givenpages(“pageone”, “pageone.childone”, “pagetwo”); whenrequestisissued(“root”, “type:pages”); thenresponseshouldbexml(); } public void testgetpagehierarchyhasrighttags() throws exception { givenpages(“pageone”, “pageone.childone”, “pagetwo”); whenrequestisissued(“root”, “type:pages”); thenresponseshouldcontain( “<namepageone</name”, “<namepagetwo</name”, “<namechildone</name” ); } cambiado los nombres las funciones para usar convención dado- cuando-entonces [] . este modo las pruebas son más fáciles leer. desafortunadamente, dividir las pruebas genera código duplicado. eliminar los duplicados por medio del patrón método plantilla [] incluir las partes dado/cuando clase base, las partes entonces derivaciones diferentes. podríamos crear una clase prueba independiente incluir las partes dado cuando función @before las partes entonces cada función @test . pero parece mecanismo excesivo para problema tan menor. final, opto por las afirmaciones múltiples del listado -. considero que regla una sola afirmación una directriz adecuada [] . siempre intento crear lenguaje pruebas específico del dominio que complemente, como listado -, pero rechazo incluir más una afirmación una prueba. creo que mejor que podemos decir que número afirmaciones una prueba debe ser mínimo. solo concepto por prueba puede que una regla más indicada sea probar único concepto cada función prueba. queremos extensas funciones que prueben una cosa diferente tras otra, como sucede listado -. esta prueba debería dividirse tres diferentes que probaran tres cosas distintas. combinarlas misma función obliga lector determinar por qué cada sección ubica ese punto qué prueba dicha sección. listado - /** * varias pruebas para método addmonths(). */ public void testaddmonths() { serialdate = serialdate.createinstance(, , ); serialdate = serialdate.addmonths(, ); assertequals(, .getdayofmonth()); assertequals(, .getmonth()); assertequals(, .getyyyy()); serialdate = serialdate.addmonths(, ); assertequals(, .getdayofmonth()); assertequals(, .getmonth()); assertequals(, .getyyyy()); = serialdate.addmonths(, serialdate.addmonths(, )); assertequals(, .getdayofmonth()); assertequals(, .getmonth()); assertequals(, .getyyyy()); } las tres funciones deberían ser las siguientes: dado último día mes con días (como mayo): . cuando añade mes, último día ese mes (como junio), entonces fecha debe ser día ese mes, . . cuando añaden dos meses esa fecha, último mes tiene días, entonces fecha debe ser día . dado último día mes con días (como junio): . cuando añade, último día ese mes tiene días, entonces fecha debe ser , . expresado esta forma, aprecia que existe una regla general entre las distintas pruebas. incrementar mes, fecha puede ser mayor que último día. esto implica que incrementar mes febrero debe generarse marzo. falta esa prueba convendría que escribiéramos. así pues, son las múltiples afirmaciones del listado - las causantes del problema, sino hecho que prueba más concepto. probablemente regla óptima sea minimizar número activos por concepto probar solo concepto por función prueba. ..... [] las pruebas limpias siguen otras cinco reglas, cuyas iniciales forman las siglas first inglés: rapidez ( fast ): las reglas deben ser rápidas ejecutarse forma rápida. hacen lentamente, las ejecutará con frecuencia. hacerlo, detectará los problemas con suficiente antelación como para solucionarlos. sentirá con libertad para limpiar código, que acabará corrompiéndose. ( independent ): las pruebas deben depender entre ellas. una prueba debe establecer condiciones para siguiente. debe poder ejecutar cada prueba forma independiente orden que desee. las pruebas dependen unas otras, primera que falle provocará una sucesión fallos, dificultará diagnóstico ocultará efectos posteriores. repetición ( repeatable ): las pruebas deben poder repetirse cualquier entorno. debe poder ejecutarlas entorno producción, calidad portátil camino casa tren sin red. puede repetir las pruebas cualquier entorno, siempre tendrá una excusa fallo. también verá que puede ejecutar las pruebas entorno está disponible. validación automática ( self-validating ): las pruebas deben tener resultado booleano: aciertan fallan. debe tener que leer extenso archivo registro para saber una prueba acertado, comparar manualmente dos archivos texto distintos para ello. las pruebas validan automáticamente, fallo puede ser subjetivo ejecución las pruebas puede requerir una extensa evaluación manual. puntualidad ( timely ): las pruebas deben crearse momento preciso: antes del código producción que hace que acierten. crea las pruebas después del código producción, puede que resulte difícil probarlo. puede decidir qué parte del código producción sea demasiado difícil probar. diseñe código producción que pueda probar. conclusión apenas hemos abordado superficie este tema. hecho, podría crear libro entero sobre pruebas limpias. las pruebas son tan importantes para salud proyecto como código producción. puede que incluso más, que conservan mejoran flexibilidad, capacidad mantenimiento reutilización del código producción. por ello, intente que sean limpias. trabaje para que resulten expresivas concisas. invente api prueba que actúen como lenguaje específico del dominio que ayude crear las pruebas. deja que las pruebas corrompan, sucederá mismo con código . mantenga limpias las pruebas. bibliografía [rspec] : rspec: behavior driven development for ruby programmers , aslak hellesay, david chelimsky, pragmatic bookshelf, . [gof] : design patterns: elements reusable object oriented software , gamma ., addison-wesley, . clases con jeff langr hasta ahora nos hemos centrado escribir bien líneas bloques código. nos hemos adentrado correcta composición las funciones interrelación. pero pesar atención dedicada expresividad las instrucciones las funciones, tendremos código limpio hasta que nos fijemos los niveles superiores organización. hablemos sobre clases. clases acuerdo convención estándar java, una clase debe comenzar con una lista variables. las constantes estáticas públicas, existen, deben aparecer primero. tras ello, las variables estáticas privadas después las variables instancia privadas. suele ser necesario usar variables públicas. las funciones públicas deben seguir lista variables. incluimos las utilidades públicas invocadas por una función pública tras propia función pública. este sistema cumple regla descendente permite que programa lea como artículo periódico. encapsulación queremos que nuestras variables funciones utilidad sean privadas, pero imprescindible. ocasiones podemos proteger una variable función utilidad para que sea accesible para una prueba. las reglas mandan. una regla del mismo paquete tiene que invocar una función acceder una variable, hacemos que tenga ámbito protected paquete. sin embargo, primero veremos una forma mantener privacidad. relajación encapsulación siempre último resorte. las clases deben ser tamaño reducido primera regla las clases que deben ser tamaño reducido. segunda regla que deben ser todavía más reducidas. , vamos repetir mismo texto capítulo sobre las funciones, pero como sucede con las funciones, tamaño reducido principal hora diseñar una clase. pregunta inmediata qué nivel reducción. con las funciones medimos tamaño contando líneas físicas. con las clases usamos otra medida distinta: las responsabilidades [] . listado - muestra una clase, superdashboard , que muestra públicos. muchos programadores estarán acuerdo que tamaño excesivo. algunos denominarían superdashboard una clase dios. listado - demasiadas responsabilidades. public class superdashboard extends jframe implements metadatauser public string getcustomizerlanguagepath() public void setsystemconfigpath(string systemconfigpath) public string getsystemconfigdocument() public void setsystemconfigdocument(string systemconfigdocument) public boolean getgurustate() public boolean getnovicestate() public boolean getopensourcestate() public void showobject(metaobject object) public void showprogress(string ) public boolean ismetadatadirty() public void setismetadatadirty(boolean ismetadatadirty) public component getlastfocusedcomponent() public void setlastfocused(component lastfocused) public void setmouseselectstate(boolean ismouseselected) public boolean ismouseselected() public languagemanager getlanguagemanager() public project getproject() public project getfirstproject() public project getlastproject() public string getnewprojectname() public void setcomponentsizes(dimension dim) public string getcurrentdir() public void setcurrentdir(string newdir) public void updatestatus(int dotpos, int markpos) public class[] getdatabaseclasses() public metadatafeeder getmetadatafeeder() public void addproject(project project) public boolean setcurrentproject(project project) public boolean removeproject(project project) public metaprojectheader getprogrammetadata() public void resetdashboard() public project loadproject(string filename, string projectname) public void setcansavemetadata(boolean cansave) public metaobject getselectedobject() public void deselectobjects() public void setproject(project project) public void editoraction(string actionname, actionevent event) public void setmode(int mode) public filemanager getfilemanager() public void setfilemanager(filemanager filemanager) public configmanager getconfigmanager() public void setconfigmanager(configmanager configmanager) public classloader getclassloader() void setclassloader(classloader classloader) public properties getprops() public string getuserhome() public string getbasedir() public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() public metaobject pasting( metaobject target, metaobject pasted, metaproject project) public void processmenuitems(metaobject metaobject) public void processmenuseparators(metaobject metaobject) public void processtabpages(metaobject metaobject) public void processplacement(metaobject object) public void processcreatelayout(metaobject object) public void updatedisplaylayer(metaobject object, int layerindex) public void propertyeditedrepaint(metaobject object) public void processdeleteobject(metaobject object) public boolean getattachedtodesigner() public void processprojectchangedstate(boolean hasprojectchanged) public void processobjectnamechanged(metaobject object) public void runproject() public void setallowdragging(boolean allowdragging) public boolean allowdragging() public boolean iscustomizing() public void settitle(string title) public idemenubar getidemenubar() public void showhelper(metaobject metaobject, string propertyname) //… otros muchos métodos públicos… } ¿ superdashboard sólo incluyera los métodos mostrados listado -? listado - ¿suficientemente reducido? public class superdashboard extends jframe implements metadatauser public component getlastfocusedcomponent() public void setlastfocused(component lastfocused) public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() } cinco métodos demasiado, ¿verdad? este caso que pesar del reducido número métodos, superdashboard también tiene demasiadas responsabilidades. nombre una clase debe describir las responsabilidades que . hecho, nombre primera forma para determinar tamaño una clase. podemos derivar nombre conciso para una clase, seguramente sea demasiado extenso. cuanto más ambiguo sea nombre clase, más probabilidades hay que tenga demasiadas responsabilidades. por ejemplo, los nombres clase con palabras como processor , manager super suelen indicar una desafortunada acumulación responsabilidades. también debemos ser capaces escribir una breve descripción clase unas palabras, sin usar las palabras « », « », « » « pero ». ¿cómo describiríamos superdashboard ?: superdashboard permite acceder componente con enfoque nos permite controlar los números versión producto. primer indica que superdashboard tiene demasiadas responsabilidades. principio responsabilidad única principio responsabilidad única ( single responsibility principle , srp) [] indica que una clase módulo debe tener uno sólo motivo para cambiar. este principio nos indica definición responsabilidad una directriz para tamaño clase. las clases sólo deben tener una responsabilidad, motivo para cambiar. clase superdashboard aparentemente reducida del listado - tiene dos motivos para cambiar. primero, controla información versión que supuestamente debe actualizarse cada vez que comercialice software . por otra parte, gestiona componentes java swing ( derivado jframe, representación swing una ventana igu nivel superior). sin duda, querremos cambiar número versión cambiamos código swing, pero contrario necesario: podríamos cambiar información versión función los cambios otro código del sistema. identificación responsabilidades (los motivos del cambio) nos permite reconocer mejorar las abstracciones nuestro código. podemos extraer los tres métodos superdashboard relacionados con información versiones una clase independiente como version (véase listado -.) clase version una construcción puede reutilizar otras aplicaciones. listado - una clase con una única responsabilidad. public class version { public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() } srp uno los conceptos más importantes del diseño orientado objetos también uno los más sencillos entender cumplir, pero también uno los que más abusa diseñar clases. habitualmente nos encontramos clases que hacen demasiadas cosas. ¿por qué? crear software que funcione crear software limpio son dos actividades diferentes. muchos tenemos cerebro limitado, modo que nos centramos que código funcione más que organización limpieza. algo totalmente válido. mantener objetivos separados tan importante nuestras actividades programación como nuestros programas. problema que muchos creemos que hemos terminado cuando programa funciona. cambiamos otro objetivo organización limpieza. pasamos siguiente problema lugar retroceder dividir las clases unidades independientes con una única responsabilidad. mismo tiempo, muchos programadores temen que elevado número pequeñas clases con único propósito dificulten comprensión del conjunto. les preocupa que tengan que desplazarse entre las clases para determinar cómo funciona aspecto concreto. sin embargo, sistema con muchas clases reducidas tiene más elementos móviles que sistema con algunas clases enormes. ambos hay que entender mismo. pregunta quiere organizar sus herramientas cajas con muchos pequeños cajones que contengan componentes bien definidos etiquetados, usar varios cajones grandes los que mezcle todo. todos los sistemas tienen una gran lógica complejidad. objetivo principal para gestionar dicha complejidad organizarla para que programador sepa dónde buscar comprenda complejidad directamente afectada cada momento concreto. por contrario, sistema con clases mayor tamaño nos obliga buscar entre numerosos elementos que siempre necesitamos conocer. para reformular los puntos anteriores, diremos que los sistemas deben estar formados por muchas claves reducidas, por algunas gran tamaño. cada clase reducida encapsula una única responsabilidad, tiene solo motivo para cambiar colabora con algunas otras para obtener los comportamientos deseados del sistema. cohesión las clases deben tener número reducido variables instancia. los métodos una clase deben manipular una varias dichas variables. por general, cuantas más variables manipule método, más cohesión tendrá con clase. una clase que cada variable usa cada método tiene una cohesión máxima. por general, recomendable posible crear este tipo clases pero queremos que cohesión nuestras clases sea elevada. logramos, significa que los métodos variables clase dependen unos otros actúan como todo lógico. fíjese implementación stack listado -. una clase muy consistente. los tres métodos, sólo size() usa ambas variables. listado - stack.java, una clase consistente. public class stack { private int topofstack = ; list<integer elements = new linkedlist<integer(); public int size() { return topofstack; } public void push(int element) { topofstack++; elements.add(element); } public int pop() throws poppedwhenempty { (topofstack == ) throw new poppedwhenempty(); int element = elements.get(--topofstack); elements.remove(topofstack); return element; } } estrategia reducir tamaño las funciones las listas parámetros suele provocar proliferación variables instancia usadas por subconjunto los métodos. esto sucede, siempre existe menos una clase que intenta huir clase mayor tamaño. debe intentar separar las variables métodos dos más clases para que las nuevas sean más consistentes. mantener resultados consistentes muchas clases tamaño reducido división grandes funciones otras más pequeñas aumenta proliferación clases. imagine una gran función con numerosas variables declaradas. imagine que desea extraer una pequeña parte esa función otra independiente. sin embargo, código que extrae usa cuatro las variables declaradas función. ¿debe pasar las cuatro variables como argumentos nueva función? absoluto. ascendemos estas cuatro variables variables instancia clase, podremos extraer código sin pasar las variables. resultaría más sencillo dividir función pequeños fragmentos. desafortunadamente, eso significaría que nuestras clases perderían cohesión que acumularían más más variables instancia que sólo existen para que otras funciones las compartan. pero momento. apenas existen funciones que compartan determinadas variables, ¿ son entonces una clase con derecho propio? por supuesto. cuando las clases pierdan cohesión, divídalas. por tanto, dividir una gran función otras más reducidas también nos permite dividir varias clases más reducidas. este modo mejora organización del programa estructura resulta más transparente. como ejemplo, usaremos ejemplo obtenido del libro knuth literate [] . listado - muestra una traducción java del programa printprimes knuth. para hacerle justicia, programa que creó sino resultado generado por herramienta web. usamos aquí por ser magnífico punto partida para dividir una función gran tamaño varias funciones clases más reducidas. listado - printprimes.java package literateprimes; public class printprimes { public static void main(string[] args) { final int = ; final int = ; final int = ; final int = ; final int ordmax = ; int [] = new int[ + ]; int pagenumber; int pageoffset; int rowoffset; int ; int ; int ; boolean jprime; int ord; int square; int ; int mult[] = new int[ordmax + ]; = ; = ; [] = ; ord = ; square = ; while ( < ) { { = + ; ( == square) { ord = ord + ; square = [ord] * [ord]; mult[ord - ] = ; } = ; jprime = true; while ( < ord && jprime) { while (mult[] < ) [] = mult[] + [] + []; (mult[] == ) jprime = false; = + ; } } while (!jprime); = + ; [] = ; } { pagenumber = ; pageoffset = ; while (pageoffset <= ) { system.out.println(“the first ” + + “ prime numbers --- page ” + pagenumber); system.out.println(“”); for (rowoffset = pageoffset; rowoffset < pageoffset + ; rowoffset++) { for ( = ; < ;++) (rowoffset + * <= ) system.out.format(“%”, [rowoffset + * ]); system.out.println(“”); } system.out.println(“\”); pagenumber = pagenumber + ; pageoffset = pageoffset + * ; } } } } este programa, escrito como una sola función, desastre. sangrado estructura excesivo hay demasiadas variables extrañas. como mínimo, función debería dividirse otras más pequeñas. los listados del - - muestran división del código del listado - clases funciones menor tamaño, además los nombres elegidos para dichas clases, funciones variables. listado - primeprinter.java (refactorizado) package literateprimes; public class primeprinter ( public static void main(string[] args) { final int number_of_prime = ; int[] primes = primegenerator.generate(number_of_primes); final int rows_per_page = ; int columns_per_page = ; rowcolumnpageprinter tableprinter = new rowcolumnpageprinter(rows_per_page, columns_per_page, “the first ” + number_of_primes + “ prime numbers”); tableprinter.print(primes); } } listado - rowcolumnpageprinter.java. package literateprimes; import java..printstream; public class rowcolumnpageprinter { private int rowsperpage; private int columnsperpage; private int numbersperpage; private string pageheader; private printstream printstream; public rowcolumnpageprinter(int rowsperpage, int columnsperpage, string pageheader) { this.rowsperpage = rowsperpage; this.columnsperpage = columnsperpage; this.pageheader = pageheader; numbersperpage = rowsperpage * columnsperpage; printstream = system.out; } public void print(int data[]) { int pagenumber = ; for (int firstindexonpage = ; firstindexonpage < data.length; firstindexonpage += numbersperpage) { int lastindexonpage = math.min(firstindexonpage + numbersperpage - , data.length - ); printpageheader(pageheader, pagenumber); printpage(firstindexonpage, lastindexonpage, data); printstream.println(“\”); pagenumber++; } } private void printpage (int firstindexonpage, int lastindexonpage, int[] data) { firstindexoflastrowonpage = firstindexonpage + rowsperpage - ; for (int firstindexinrow = firstindexonpage; firstindexinrow <= firstindexoflastrowonpage; firstindexinrow++) { printrow(firstindexinrow, lastindexonpage, data); printstream.println(“”); } } private void printrow(int firstindexinrow, int lastindexonpage, int[] data) { for (int column = ; column < columnsperpage; column++) { int index = firstindexinrow + column * rowsperpage; (index <= lastindexonpage) printstream.format(“%”, data[index]); } } private void printpageheader(string pageheader, int pagenumber) { printstream.println(pageheader + “ --- page ” + pagenumber); printstream.println(“”); } public void setoutput(printstream printstream) { this.printstream = printstream; } } listado - primegenerator.java package literateprimes; import java.util.arraylist; public class primegenerator { private static int[] primes; private static arraylist<integer multiplesofprimefactors; protected static int[] generate(int ) { primes = new int[]; multiplesofprimefactors = new arraylist<integer(); set(); checkoddnumbersforsubsequentprimes(); return primes; } private static void set() { primes[] = ; multiplesofprimefactors.add(); } private static void checkoddnumbersforsubsequentprimes() { int primeindex = ; for (int candidate = ; primeindex < primes.length; candidate += ) { (isprime(candidate)) primes[primeindex++] = candidate; } } private static boolean isprime(int candidate) { (isleastrelevantmultipleofnextlargerprimefactor(candidate)) { multiplesofprimefactors.add(candidate); return false; } return isnotmultipleofanypreviousprimefactor(candidate); } private static boolean isleastrelevantmultipleofnextlargerprimefactor(int candidate) { int nextlargerprimefactor = primes[multiplesofprimefactors.size()]; int leastrelevantmultiple = nextlargerprimefactor * nextlargerprimefactor; return candidate == leastrelevantmultiple; } private static boolean isnotmultipleofanypreviousprimefactor(int candidate) { for (int = ; < multiplesofprimefactors.size(); ++) { (ismultipleofnthprimefactor(candidate, )) return false; } return true; } private static boolean ismultipleofnthprimefactor(int candidate, int ) { return candidate == smallestoddnthmultiplenotlessthancandidate(candidate, ); } private static int smallestoddnthmultiplenotlessthancandidate(int candidate, int ) { int multiple = multiplesofprimefactors.get(); while (multiple < candidate) multiple += * primes[]; multiplesofprimefactors.set(, multiple); return multiple; } } primero que apreciará que aumentado longitud del programa, una casi tres páginas. este aumento debe varios motivos. primer lugar, programa refactorizado usa nombres variable más extensos descriptivos. por otra parte, usa declaraciones funciones clases como comentarios del código. por último, usamos espacios blanco técnicas formato para mantener legibilidad. programa dividido tres responsabilidades principales. parte principal incluye clase primeprinter , responsable controlar entorno ejecución. cambia modifica método invocación. por ejemplo, este programa convierte servicio soa, clase que verá afectada. rowcolumnpageprinter sabe cómo aplicar formato una lista números con una determinada cantidad filas columnas. necesario cambiar formato del resultado, clase que verá afectada. clase primegenerator sabe cómo generar una lista números primos. creará una instancia como objeto. clase sólo ámbito útil que declarar ocultar sus variables. esta clase cambia modifica algoritmo para calcular números primos. hemos reescrito programa. hemos empezado cero los hemos vuelto diseñar. realidad, fija atentamente los dos programas, verá que usan los mismos algoritmos mecanismos. cambio realizado creando una suite pruebas que verifican comportamiento preciso del primer programa. tras ello, aplican numerosos cambios mínimos, uno uno. tras cada cambio, ejecuta programa para garantizar que comportamiento varía. paso paso, primer programa limpia transforma segundo. organizar los cambios muchos sistemas, cambio continuo. cada cambio supone riesgo que resto del sistema funcione forma esperada. sistema limpio organizamos las clases para reducir los riesgos los cambios. clase sql del listado - usa para generar cadenas sql forma correcta con los metadatos adecuados. trabajo continuo , como tal, funciones sql como instrucciones update . cuando clase sql tenga que admitir una instrucción update , tendremos que abrirla para realizar modificaciones. problema abrir una clase riesgo que conlleva. cualquier modificación puede afectar otro código clase. debe probarse concienzudamente. listado - clase que debemos abrir para realizar cambios. public class sql { public sql(string table, column[] columns) public string create() public string insert(object[] fields) public string selectall() public string findbykey(string keycolumn, string keyvalue) public string select(column column, string pattern) public string select(criteria criteria) public string preparedinsert() private string columnlist(column[] columns) private string valueslist(object[] fields, final column[] columns) private string selectwithcriteria(string criteria) private string placeholderlist(column[] columns) } clase sql debe cambiar añadir nuevo tipo instrucción. también debe cambiar cuando variemos los detalles tipo instrucción concreto; por ejemplo, tenemos que modificar funcionalidad select para admitir selecciones secundarias. estos dos motivos cambio significan que clase sql incumple srp. podemos detectar este incumplimiento desde punto vista organizativo. método outline sql muestra que hay métodos privados, como selectwithcriteria , que parecen relacionarse únicamente con instrucciones select . comportamiento métodos privados aplicados pequeño subconjunto una clase puede ser una heurística útil para detectar zonas que mejorar. sin embargo, verdadera razón debe ser cambio del sistema. clase sql considera totalmente lógica, debemos preocuparnos por separar las responsabilidades. necesitamos funcionalidad actualización futuro, podemos olvidarnos sql . pero tenemos que una clase, debemos corregir diseño. ¿ optamos por una solución como del listado -? los métodos públicos interfaz definidos sql listado - refactorizan sus propias variantes clase sql . los métodos privados, como valueslist , mueven directamente las posiciones necesarias. comportamiento privado reduce par clases utilidad: where columnlist . listado - grupo clases cerradas. abstract public class sql { public sql(string table, column[] columns) abstract public string generate(); } public class createsql extends sql { public createsql(string table, column[] columns) @override public string generate() } public class selectsql extends sql { public selectsql(string table, column[] columns) @override public string generate() } public class insertsql extends sql { public selectsql(string table, column[] columns, object[] fields) @override public string generate() private string valueslist(object[] fields, final column[] columns) } public class selectwithcriteriasql extends sql { public selectwithcriteriasql( string table, column[] columns, criteria criteria) @override public string generate() } public class selectwithmatchsql extends sql { public selectwithmatchsql( string table, column[] columns, column column, string pattern) @override public string generate() } public class findbykeysql extends sql { public findbykeysql( string table, column[] columns, string keycolumn, string keyvalue) @override public string generate() } class preparedinsertsql extends sql { public preparedinsertsql(string table, column[] columns) @override public string generate() private string placeholderlist(column[] columns) } public class where { public where(string criteria) public string generate() } public class columnlist { public columnlist(column[] columns) public string generate() } código cada clase simplifica enormemente. tiempo necesario para entender las clases reduce mínimo. riesgo que una función afecte otra desaparece casi por completo. desde punto vista las pruebas, resulta más sencillo probar lógica esta solución, que las clases aíslan unas otras. además, cuando llegue momento añadir las instrucciones update , cambia ninguna las clases existentes. añadimos lógica para generar instrucciones update una nueva subclase sql , updatesql . este cambio afecta otro código del sistema. nuestra lógica sql reestructurada representa mejor ambos mundos. cumple con srp también con otro principio clave del diseño clases orientadas objetos, denominado principio abierto/cerrado [] : las clases deben abrirse para ampliación para cerrarse para modificación. nueva clase sql abre nuevas funcionalidades mediante creación subclases pero podemos realizar estos cambios mantener cerradas las demás clases. basta con añadir nuestra clase updatesql . debemos estructurar nuestros sistemas para ensuciarlos menos posible cuando los actualicemos con nuevas funciones cambios. sistema ideal, incorporamos nuevas funciones ampliándolo, modificando código existente. aislarnos los cambios necesidades cambiarán también hará código. programación orientada objetos aprendemos que hay clases concretas que contienen detalles implementación ( código) clases abstractas que sólo representan conceptos. una clase cliente que dependa detalles concretos está peligro dichos detalles cambian. podemos recurrir interfaces clases abstractas para aislar impacto dichos detalles. las dependencias detalles concretos crean retos para nuestro sistema. tenemos que crear clase portfolio ésta depende una api tokyostockexchange externa para obtener valor, nuestros casos prueba verán afectados por volatilidad esta búsqueda. resulta complicado crear una prueba cuando obtiene una respuesta diferente cada cinco minutos. lugar diseñar portfolio para que dependa directamente tokyostockexchange , creamos una interfaz, stockexchange , que declara único método: public interface stockexchange { money currentprice(string symbol); } diseñamos tokyostockexchange para implementar esta interfaz. también nos aseguramos que constructor portfolio adopte como argumento una referencia stockexchange: public portfolio { private stockexchange exchange; public portfolio(stockexchange exchange) { this.exchange = exchange; } //… } ahora prueba puede crear una implementación interfaz stockexchange que emule tokyostockexchange . esta implementación prueba fijará valor actual del símbolo que usemos prueba. nuestra prueba demuestra adquisición cinco acciones microsoft para nuestra cartera valores, diseñe código implementación prueba para que siempre devuelva dólares por acción microsoft. nuestra implementación prueba interfaz stockexchange reduce una sencilla búsqueda tabla. este modo crear una prueba que espere valor cartera total dólares: public class portfoliotest { private fixedstockexchangestub exchange; private portfolio portfolio; @before protected void setup() throws exception { exchange = new fixedstockexchangestub(); exchange.fix(“msft”, ); portfolio = new portfolio(exchange); } @test public void givenfivemsfttotalshouldbe() throws exception { portfolio.add(, “msft”); assert.assertequals(, portfolio.value()); } } diseccionamos sistema para poder probarlo esta forma, resultará más flexible podrá reutilizar. ausencia conexiones significa que los elementos del sistema aíslan entre ellos otros cambios. este aislamiento hace que comprendamos mejor los elementos del sistema. minimizar las conexiones esta forma, nuestras clases cumplen otro principio diseño: dependency inversion principle (dip) principio inversión dependencias [] . básicamente afirma que nuestras clases deben depender abstracciones, detalles concretos. lugar depender los detalles implementación clase tokyostockexchange , nuestra clase portfolio depende interfaz stockexchange , que representa concepto abstracto solicitar precio actual una acción. esta abstracción aísla todos los datos concretos obtención dicho precio, incluyendo dónde obtiene. bibliografía [rdd] : object design: roles, responsibilities, and collaborations , rebecca wirfs-brock ., addison-wesley, . [ppp] : agile software development: principles, patterns, and practices , robert . martin, prentice hall, . [knuth] : literate programming , donald . knuth, center for the study language and information, leland stanford junior university, . sistemas por . kevin dean wampler « complejidad letal. acaba con los desarrolladores dificulta planificación, generación pruebas los productos». —ray ozzie, cto, microsoft corporation cómo construir una ciudad ¿podría encargarse todos los detalles por cuenta? seguramente . incluso gestión una ciudad existente sería demasiado para una sola persona. aun así, las ciudades funcionan ( mayoría los casos). funcionan porque tienen equipos que controlan partes concretas ciudad, alcantarillado, red eléctrica, tráfico, seguridad, las normativas , etc. algunos encargan aspectos generales otros centran los detalles. las ciudades también funcionan porque disponen evolucionados niveles abstracción modularidad que permiten individuos componentes trabajar forma eficaz, sin necesidad entender trasfondo general. aunque los equipos software suelen organizar esta forma, los sistemas los que trabajan suelen contar con misma separación aspectos niveles abstracción. este capítulo veremos cómo mantener limpieza niveles superiores abstracción, sistema. separar construcción sistema uso primer lugar, recuerde que construcción proceso muy diferente uso. mientras escribo estas líneas, través ventana veo nuevo hotel construcción chicago. hoy instalarán una gran grúa. todos los obreros llevan casco. dentro año habrán acabado hotel. grúa desaparecerá. edificio estará terminado, con reluciente fachada cristal atractiva decoración. gente que trabajará también será diferente. los sistemas software deben separar proceso inicio, que crean los objetos aplicación conectan las dependencias, lógica ejecución que toma testigo tras inicio. proceso inicio aspecto que toda aplicación debe abordar. primero que veremos este capítulo. separación aspectos una las técnicas diseño más antiguas importantes nuestra profesión. desafortunadamente, muchas aplicaciones hacen. código del proceso inicio mezcla con lógica tiempo ejecución. veamos ejemplo típico: public service getservice() { (service == null) service = new myserviceimpl (…); //¿ bastante predeterminado para los casos? return service; } técnica inicialización/evaluación tardía tiene sus méritos. incurrimos sobrecarga construcción menos que usemos objeto realmente, como resultado tiempo inicio puede acelerar. también evitamos que devuelva null . sin embargo, ahora tenemos una dependencia myserviceimpl todo que constructor requiere (que omitido). podemos compilar sin resolver estas dependencias, aunque nunca usemos objeto este tipo tiempo ejecución. las pruebas también pueden ser problema. myserviceimpl objeto pesado, tendremos que asegurarnos asignar correspondiente test double [] objeto simulado campo servicio antes invocar este método las pruebas unidad. como lógica construcción mezcla con procesamiento normal tiempo ejecución, debemos probar todas las rutas ejecución (como prueba null bloque). contar con ambas responsabilidades, método hace más una cosa, por que incumple principio responsabilidad única. peor todo que sabemos myserviceimpl objeto correcto todos los casos. ¿por qué clase con este método tiene que conocer contexto global? ¿podemos saber realmente cuál objeto correcto que usar aquí? ¿ posible que mismo tipo sea correcto para todos los contextos posibles? caso inicialización tardía problema serio. sin embargo, suele haber muchos casos este tipo configuración las aplicaciones. por tanto, estrategia configuración global ( existe) disemina por aplicación, sin apenas modularidad con una significativa duplicación. somos diligentes sobre diseño sistemas robustos bien formados, debemos permitir fallos modularidad. proceso inicio construcción conexión objetos una excepción. debemos modularizar este proceso asegurarnos contar con una estrategia global coherente para resolver las dependencias principales. main una forma separar construcción del uso consiste trasladar todos los aspectos construcción main módulos invocados por main , diseñar resto del sistema suponiendo que todos los objetos han creado conectado correctamente (véase figura .). flujo control fácil seguir. función main crea los objetos necesarios para sistema, los pasa aplicación ésta los utiliza. verá que las flechas dependencia atraviesan barrera entre main aplicación. todas van misma dirección, alejándose main , que significa que aplicación tiene conocimiento main del proceso construcción. simplemente espera que todo haya construido correctamente. figura .. separación construcción main() . factorías ocasiones, aplicación tendrá que ser responsable creación objeto. por ejemplo, sistema procesamiento pedidos, aplicación debe crear las instancias lineitem que añadir order . este caso, podemos usar patrón factoría abstracta [] para que aplicación controle cuándo crear lineitem , pero mantener los detalles dicha construcción separados del código aplicación (véase figura .). nuevo vemos que todas las dependencias desplazan desde main aplicación orderprocessing , que significa que aplicación desconecta los detalles creación lineitem . esta capacidad incluye lineitemfactoryimplementation , extremo main línea. sin embargo, aplicación tiene control total sobre cuándo crean las instancias lineitem incluso puede proporcionar argumentos constructor específicos aplicación. figura .. separación construcción con una factoría. inyectar dependencias potente mecanismo para separar construcción del uso inyección dependencias, aplicación inversión control ( inversion control ioc) administración dependencias [] . inversión control pasa responsabilidades secundarias objeto otros dedicados ese cometido, por que admite principio responsabilidad única. contexto administración dependencias, objeto debe ser responsable instanciar dependencias, sino que debe delegar esta responsabilidad otro mecanismo autorizado, modo que invierte control. como configuración aspecto global, este mecanismo autorizado suele ser main contenedor propósito especial. las búsquedas jndi son una implementación parcial inyección dependencias, las que objeto solicita servidor directorios servicio que coincida con nombre concreto. myservice myservice = (myservice)(jndicontext.lookup(“nameofmyservice”)); objeto invocador controla tipo objeto devuelto (siempre que implemente interfaz correcta, evidentemente), pero que resuelve dependencia forma activa. verdadera inyección dependencias paso más allá. clase hace nada directamente para resolver sus dependencias, totalmente pasiva. por contrario, ofrece métodos establecimiento argumentos constructor ( ambos) que usan para inyectar las dependencias. proceso construcción, contenedor inyección dependencias crea instancias los objetos necesarios (normalmente bajo demanda) usa los argumentos constructor métodos establecimiento proporcionados para conectar las dependencias. los objetos dependientes empleados suelen especificarse través archivo configuración mediante programación módulo construcción propósito especial. estructura spring proporciona contenedor inyección dependencias más conocido para java [] . los objetos que van conectar definen archivo configuración xml después solicitan objetos concretos por nombre código java. veremos ejemplo breve. ¿ qué sucede con las virtudes inicialización tardía? ocasiones útil con inyección dependencias. por lado, muchos contenedores inyección dependencias crean objeto hasta que necesario. por otra parte, muchos estos contenedores cuentan con mecanismos para invocar factorías crear proxies que pueden usar para evaluación tardía optimizaciones similares [] . evolucionar las ciudades nacen pueblos, que nacen asentamientos. inicialmente, los son estrechos prácticamente inexistentes, después asfaltan aumentan tamaño. los pequeños edificios solares vacíos llenan otros mayores que acaban convirtiéndose rascacielos. principio hay servicios, electricidad, agua, alcantarillado internet (¡vaya!). estos servicios añaden cuando aumenta densidad población. este crecimiento fácil. cuántas veces mientras conduce por una carretera llena baches una señal obras preguntado por qué hicieron más ancha desde principio. podía haber hecho otra forma. ¿quién puede justificar gasto una autopista seis carriles que atraviese pequeño pueblo como anticipación supuesto crecimiento? ¿quién querría una autopista así ciudad? conseguir sistemas perfectos primera mito. por contrario, debemos implementar hoy, refactorizar ampliar mañana. esencia agilidad iterativa incremental. desarrollo controlado por pruebas, refactorización código limpio que generan hace que funcione nivel del código. ¿pero qué sucede nivel del sistema? ¿ arquitectura del sistema requiere una planificación previa? sin duda puede aumentar incrementalmente algo sencillo algo complejo, ¿ ? los sistemas software son únicos los comparamos con los sistemas físicos. sus arquitecturas pueden crecer incrementalmente, mantenemos correcta separación los aspectos. naturaleza efímera los sistemas software hace que sea posible, como veremos. primero nos centraremos una arquitectura que separa correctamente los aspectos. las arquitecturas ejb ejb originales separaban correctamente los aspectos por tanto imponían barreras innecesarias crecimiento orgánico. imagine bean entidad para una clase bank persistente. bean entidad una representación memoria datos relacionales, decir, una fila una tabla. primero, debe definir una interfaz local ( proceso) remota (mvj ), que los clientes usen. listado - muestra una posible interfaz local: listado - una interfaz local ejb para ejb bank. package com.example.banking; import java.util.collections; import javax.ejb.*; public interface banklocal extends java.ejb.ejblocalobject { string getstreetaddrl{} throws ejbexception; string getstreetaddr{} throws ejbexception; string getcity() throws ejbexception; string getstate() throws ejbexception; string getzipcode() throws ejbexception; void setstreetaddr(string street) throws ejbexception; void setstreetaddr(string street) throws ejbexception; void setcity(string city) throws ejbexception; void setstate(string state) throws ejbexception; void setzipcode(string zip) throws ejbexception; collection getaccounts() throws ejbexception; void setaccounts(collection accounts) throws ejbexception; void addaccount(accountdto accountdto) throws ejbexception; } mostramos diversos atributos dirección bank una colección cuentas del banco, cuyos datos procesarán por ejb account diferente. listado - muestra correspondiente clase implementación del bean bank . listado - implementación del bean entidad ejb. package com.example.banking; import java.util.collections; import javax.ejb.*; public abstract class bank implements javax.ejb.entitybean { // lógica empresarial… public abstract string getstreeraddr(); public abstract string getstreetaddr(); public abstract string getcity(); public abstract string getstate(); public abstract string getzipcode(); public abstract void setstreetaddr(string street); abstract void setstreetaddr(string street); public abstract void setcity(string city); public abstract void setstate(string state); public abstract void setzipcode(string zip); public abstract collection getaccounts(); public abstract void setaccounts(collection accounts); public void addaccount(accountpto accountdto) { initialcontext context = new initialcontext(); accounthomelocal accounthome = context.lookup(“accounthomelocal”); accountlocal account = accounthome.create(accountdto); collection accounts = getaccounts(); accounts.add(account); } // lógica del contenedor ejb public abstract void setid(integer ); public abstract integer getid(); public integer ejbcreate(integer ) {…} public void ejbpostcreate(integer ) {…} // resto tendría que implementarse pero deja vacío: public void setentitycontext(entitycontext ctxt) {} public void unsetentitycontext() {} public void ejbactivate() {} public void ejbpassivate() {} public void ejbload() {} public void ejbstore() {} public void ejbremove() {} } mostramos correspondiente interfaz localhome , básicamente una factoría usada para crear objetos, los métodos consulta bank que pueda añadir. por último, debemos crear uno varios descriptores implementación xml que especifiquen los detalles asignación relacional objetos almacén persistente, comportamiento deseado transacción, limitaciones seguridad demás. lógica empresarial está directamente conectada contenedor aplicación ejb. debe crear subclases tipos contenedor proporcionar los métodos ciclo vital necesarios para contenedor. debido esta conexión contenedor pesado, las pruebas unidad aisladas son complicadas. necesario imitar contenedor, algo difícil, perder demasiado tiempo implementación ejb pruebas servidor real. reutilización fuera arquitectura ejb imposible, debido esta estrecha conexión. por último, incluso programación orientada objetos afectada. bean puede heredar otro. fíjese lógica para una nueva cuenta. bean ejb habitual definir objetos transferencia datos ( data transfer objects dto), estructuras sin comportamiento. esto suele generar tipos redundantes con los mismos datos requiere código predefinido para copiar datos entre objetos. aspectos transversales arquitectura ejb acerca verdadera separación aspectos determinados aspectos. por ejemplo, los comportamientos transaccionales, seguridad comportamiento deseados declaran los descriptores implementación, independientemente del código fuente. aspectos como persistencia suelen cruzar los límites objeto naturales dominio. por general intentará mantener todos sus objetos mediante misma estrategia, por ejemplo con determinado dbms [] archivos planos, usando determinadas convenciones nomenclatura para tablas columnas, una semántica transaccional coherente, etc. principio, puede razonar estrategia persistencia una forma modular encapsulada, pero práctica tendrá que distribuir mismo código que implemente estrategia persistencia entre varios objetos. usamos término transversales para este tipo aspectos. nuevo, estructura persistencia podría ser modular lógica dominios, aislada, también. problema intersección entre ambos dominios. hecho, forma que arquitectura ejb procesa persistencia, seguridad transacciones una programación orientada aspectos ( aspect oriented programming aop) [] anticipada, enfoque carácter general para restaurar modularidad aspectos transversales. aop, construcciones modulares denominadas aspectos especifican qué puntos del sistema deben modificar comportamiento forma coherente para admitir determinado aspecto. esta especificación realiza mediante sucinto mecanismo declaración programación. usamos persistencia como ejemplo, podría declarar qué objetos atributos ( patrones) deben conservarse después delegar las tareas persistencia estructura persistencia. las modificaciones son invasivas [] para código destino. veamos tres aspectos mecanismos similares java. proxies java los proxies java son útiles casos sencillos, como envolver invocaciones métodos objetos clases concretas. sin embargo, los proxies dinámicos proporcionados jdk sólo funcionan con interfaces. para aplicarlos clases, debe usar una biblioteca manipulación código bytes , como cglib, asm javassist [] . listado - muestra estructura proxy jdk para ofrecer asistencia persistencia nuestra aplicación bank; únicamente abarca los métodos para obtener establecer lista cuentas. listado - ejemplo proxy del jdk. // bank.java (eliminando nombres paquetes…) import java.utils.*; // abstracción banco. public interface bank { collection<account getaccounts(); void setaccounts(collection<accounts accounts); } // bankimpl.java import java.utils.*; // “plain old java object” pojo que implementa abstracción. public class bankimpl implements bank { private list<account accounts; public collection<account getaccounts() { return accounts; } public void setaccounts(collections<accounts accounts) { this.accounts = new arraylist<accounts(); for (account account: accounts) { this.accounts.add(account); } } } // bankproxyhandler.java import java.lang.reflect.*; import java.util.*; // «invocationhandler» necesario para api proxy. public class bankproxyhandler implements invocationhandler { private bank bank; public bankhandler (bank bank) { this.bank = bank; } // método definido invocationhandler public object invoke(object proxy, method method, object[] args) throws throwable { string methodname = method.getname(); (methodname.equals(“getaccounts”)) { bank.setaccounts(getaccountsfromdatabase()); return bank.getaccounts(); } else (methodname.equals(“setaccounts”)) { bank.setaccounts((collection<account) args[]); setaccountstodatabase(bank.getaccounts()); return null; } else { … } } // muchos detalles: protected collection<account getaccountsfromdatabase() {…} protected void setaccountstodatabase(collection<account accounts) {…} } // otra parte… bank bank = (bank) proxy.newproxyinstance( bank.class.getclassloader(), new class[] { bank.class }, new bankproxyhandler(new bankimpl())); definimos interfaz bank , que envolvemos proxy pojo ( plain-old object objeto sencillo java), bankimpl , que implementa lógica empresarial (encontrará más información sobre pojo apartado posterior). api proxy requiere objeto invocationhandler que invocar para implementar las invocaciones métodos bank realizadas proxy. bankproxyhandler usa api reflexión java para asignar las invocaciones métodos genéricos los métodos correspondientes , así sucesivamente. código abundante complejo, incluso para este sencillo caso [] . uso una las bibliotecas manipulación bytes igualmente complicado. volumen complejidad este código son dos los inconvenientes los proxies . dificultan creación código limpio. además, los proxies ofrecen mecanismo para especificar puntos ejecución globales del sistema, imprescindibles para una verdadera solución aop [] . estructuras aop java puras afortunadamente, gran parte del código predefinido proxy puede procesar forma automática mediante herramientas. los proxies usan internamente varias estructuras java como spring aop jboss aop, para implementar aspectos java [] . spring, crea lógica empresarial forma pojo, específicos dominio. dependen estructuras empresariales ( otros dominios). por tanto, son conceptualmente más sencillos más fáciles probar. relativa simplicidad garantiza que implementen correctamente las correspondientes historias mantenimiento evolución del código historias futuras. infraestructura necesaria aplicación, incluidos aspectos transversales como persistencia, transacciones, seguridad, almacenamiento caché recuperación ante fallos, incorpora por medio archivos configuración declarativos api. muchos casos, especifican aspectos bibliotecas spring jboss, los que estructura controla uso proxies java bibliotecas código bytes forma transparente usuario. estas declaraciones controlan contenedor inyección dependencias, que crea instancias los principales objetos las conecta bajo demanda. listado - muestra fragmento tipo archivo configuración spring ., app.xml [] . - archivo configuración spring . <beans … <bean =“appdatasource” class=“org.apache.commons.dbcp.basicdatasource” destroy-method=“close” :driverclassname=“com.mysql.jdbc.driver” :url=“jdbc:mysql://localhost:/mydb” :username=“”/ <bean =“bankdataaccessobject” class=“com.example.banking.persistence.bankdataaccessobject” :datasource-ref=“appdatasource”/ <bean =“bank” class=“com.example.banking.model.bank” :dataaccessobject-ref=“bankdataaccessobject”/ … </beans cada bean como una parte una muñeca rusa anidada, con objeto domino proxy bank (envuelto) por objeto acceso datos ( data accessor object , dao), que también procesa través proxy por medio origen datos controlador jdbc (véase figura .). figura .. “muñeca rusa” elementos decoración. cliente cree que invoca getaccounts() objeto bank , pero realidad comunica con objeto decorator [] más externo grupo, objeto que amplía comportamiento básico del pojo bank . podríamos añadir otros objetos decoración para transacciones, almacenamiento caché demás. aplicación, bastan unas líneas para solicitar contenedor los objetos nivel superior del sistema, como especifica archivo xml. = new xmlbeanfactory(new classpathresource(“app.xml”, getclass())); bank bank = (bank) .getbean(“bank”); como apenas necesitan líneas código java específico spring, aplicación desconecta casi por completo spring desaparecen los problemas conexión sistemas como ejb. aunque xml puede ser difícil leer [] , directiva especificada estos archivos configuración más sencilla que complicada lógica proxy aspectos oculta vista creada forma automática. una arquitectura tan atractiva que sistemas como spring modificaron totalmente estándar ejb para versión . ejb sigue modelo spring aspectos transversales admitidos mediante declaraciones con archivos configuración xml / anotaciones java . listado - muestra nuestro objeto bank reescrito ejb [] . listado - ejb bank ejb. package com.example.banking.model; import javax.persistence; import java.util.arraylist; import java.util.collection; @entity @table(name = “banks”) public class bank implements java..serializable { @ @generatedvalue(strategy=generationtype.auto) private int ; @embeddable // objeto línea fila bank public class address { protected string streetaddr; protected string streetaddr; protected string city; protected string state; protected string zipcode; } @embedded private address address; @onetomany (cascade = cascadetype.all, fetch = fetchtype.eager, mappedby=“bank”) private collection<account accounts = new arraylist<account(); int getid() { return ; } public void setid(int ) { this. = ; } public void addaccount(account account) { account.setbank(this); accounts.add(account); } public collection<account getaccounts() { return accounts; } public void setaccounts(collection<account accounts) { this.accounts = accounts; } } este código mucho más limpio que código ejb original. conservan algunos detalles entidades, las anotaciones. sin embargo, como hay información fuera las anotaciones, código limpio fácil probar, mantener demás. parte información persistencia las anotaciones puede cambiar descriptores implementación xml necesario, dejando pojo puro. los detalles asignación persistencia cambian con frecuencia, muchos equipos pueden optar por mantener las anotaciones pero con menos obstáculos que usaran ejb. aspectos aspectj por último, herramienta más completa separación través aspectos lenguaje aspectj [] , una extensión java que ofrece compatibilidad primer nivel para aspectos como construcciones modularidad. los enfoques puros java proporcionados por spring aop jboss aop son suficientes - por los casos los que los aspectos son útiles. sin embargo, aspectj ofrece conjunto herramientas avanzadas completas para separación aspectos. inconveniente aspectj necesidad adoptar nuevas herramientas aprender nuevas construcciones lenguaje. los problemas adopción han mitigado parcialmente gracias introducción formato anotación aspectj, que usan anotaciones java para definir aspectos con código puro java. además, estructura spring dispone funciones que facilitan incorporación aspectos basados anotaciones equipo con experiencia limitada con aspectj. análisis completo aspectj supera los objetivos este libro. necesita más información respecto, consulte [aspectj], [colyer] [spring]. pruebas unidad arquitectura del sistema separación través enfoques similares aspectos puede menospreciar. puede crear lógica dominios aplicación mediante pojo, sin conexión con los aspectos arquitectónicos nivel del código, entonces podrá probar realmente arquitectura. puede evolucionar simple sofisticado, acuerdo las necesidades, adoptando nuevas tecnologías bajo demanda. necesario realizar buen diseño por adelantado (big design front [] , bduf). hecho, bduf puede ser negativo que impide adaptación cambio, debido resistencia fisiológica descartar esfuerzos previos forma que las decisiones arquitectónicas influyen concepción posterior del diseño. los arquitectos deben realizar bduf que resulta factible aplicar cambios arquitectónicos radicales una estructura física una vez avanzada construcción [] . aunque software rige por una física propia [] , económicamente factible realizar cambios radicales estructura del software separa sus aspectos forma eficaz. esto significa que podemos iniciar proyecto software con una arquitectura simple pero bien desconectada, ofrecer historias funcionales forma rápida, para después aumentar infraestructura. algunos los principales sitios web del mundo han alcanzado una gran disponibilidad rendimiento por medio sofisticadas técnicas almacenamiento caché, seguridad, virtualización demás, todo ello forma eficaz flexible que los diseños mínimamente conectados son adecuadamente simples cada abstracción ámbito. evidentemente, quiere decir que acometamos los proyectos sin timón. debemos tener expectativas del ámbito general, objetivos programa, así como estructura general del sistema resultante. sin embargo, debemos mantener capacidad cambiar rumbo respuesta las circunstancias. arquitectura ejb inicial una las api conocidas con exceso ingeniería que compromete separación aspectos. incluso las api bien diseñadas pueden ser excesivas cuando resultan necesarias. una api correcta debe desaparecer vista mayoría los casos, para que equipo dedique sus esfuerzos creativos las historias implementadas. caso contrario, las limitaciones arquitectónicas impedirán entrega eficaz valor óptimo para cliente. para recapitular: una arquitectura sistema óptima compone dominios aspectos modularizados, cada uno implementado con pojo. los distintos dominios integran mediante aspectos herramientas similares mínimamente invasivas. igual que código, esta arquitectura pueden realizar pruebas. optimizar toma decisiones modularidad separación aspectos permite descentralización administración toma decisiones. sistema suficientemente amplio, sea una ciudad proyecto software , debe haber una sola persona que adopte todas las decisiones. sabemos que conviene delegar las responsabilidades las personas más cualificadas. solemos olvidar que también conviene posponer decisiones hasta último momento. falta responsabilidad; nos permite tomar decisiones con mejor información posible. una decisión prematura siempre subjetiva. decidimos demasiado pronto, tendremos menos información del cliente, reflexión mental sobre proyecto experiencia con las opciones implementación. agilidad que proporciona sistema pojo con aspectos modularizados nos permite adoptar decisiones óptimas tiempo, basadas los conocimientos más recientes. además, reduce complejidad estas decisiones. usar estándares cuando añadan valor demostrable construcción edificios una maravilla para vista debido ritmo empleado (incluso invierno) los extraordinarios diseños posibles gracias tecnología actual. construcción sector maduro con elementos, métodos estándares optimizados que han evolucionado bajo presión durante siglos. muchos equipos usaron arquitectura ejb por ser estándar, aunque hubiera bastado con diseños más ligeros sencillos. visto equipos obsesionados con estándares moda que olvidaron implementar valor para sus clientes. los estándares facilitan reutilización ideas componentes, reclutan individuos con experiencia, encapsulan buenas ideas conectan componentes. sin embargo, proceso creación estándares puede tardar demasiado para sector, algunos pierden contacto con las verdaderas necesidades aquello para los que están dirigidos. los sistemas necesitan lenguajes específicos del dominio construcción edificios, como muchos dominios, desarrollado rico lenguaje con vocabularios, frases patrones [] que comunican información esencial forma clara concisa. mundo del software , renacido interés por crear lenguajes específicos del dominio ( domain-specific languages dsl) [] , pequeños lenguajes independientes creación secuencias comandos api lenguajes estándar que permiten crear que lea una forma estructurada, como escribiría experto del dominio. buen dsl minimiza vacío comunicación entre concepto dominio código que implementa, igual que las prácticas ágiles optimizan comunicación entre equipo los accionistas del proyecto. tiene que implementar lógica dominios mismo lenguaje usado por experto del dominio, hay menos riesgo traducir incorrectamente dominio implementación. los dsl, usan forma eficaz, aumentan nivel abstracción por encima del código los patrones diseño. permiten desarrollador revelar intención del código nivel abstracción adecuado. los lenguajes específicos del dominio permiten expresar como pojo todos los niveles abstracción todos los dominios aplicación, desde directivas nivel superior los detalles más mínimos. conclusión los sistemas también deben ser limpios. una arquitectura invasiva afecta lógica dominios agilidad. lógica dominios afectada, calidad resiente, que los errores ocultan las historias son más difíciles implementar. agilidad comprometida, productividad sufre las ventajas tdd pierden. todos los niveles abstracción, los objetivos deben ser claros. esto sólo sucede crea pojo usa mecanismos similares aspectos para incorporar otros aspectos implementación forma invasiva. independientemente que diseñe sistemas módulos individuales, olvide usar los elementos más sencillos que funcionen. bibliografía [alexander] : christopher alexander, timeless way building , oxford university press, new york, . [aosd] : puerto desarrollo software orientado aspectos, http://aosd.net. [asm] : página asm, http://asm.objectweb.org/. [aspectj] : http: //eclipse.org/aspectj. [cglib] : biblioteca generación código, http://cglib.sourceforge.net/. [colyer] : adrian colyer, andy clement, george hurley, mathew webster, eclipse aspectj , person education, inc., upper saddle river, , . [dsl] : lenguaje programación específico del dominio, http://.wikipedia.org/wiki/lenguaje_espec%%adfico_del_dominio. [fowler] : inversión contenedores control patrón inyección dependencias (http://martinfowler.com/articles/injection.html). [goetz] : brian goetz, java theory and practice: decorating with dynamic proxies , http:// jtp.html. [javassist] : página javassist, http:// [jboss] : página jboss, http: //jboss.org. [jmock] : jmock: una biblioteca objetos mock ligeros para java, http://jmock.org. [kolence] : kenneth . kolence, software physics and computer performance measurements, proceedings the acm annual conference-volume , boston, massachusetts, . -,. [spring] : the spring framework , http:// [mezzaros] : xunit patterns , gerard mezzaros, addison-wesley, . [gof] : design patterns: elements reusable object oriented software , gamma ., addison-wesley, . emergencia con jeff langr limpieza través diseños emergentes que existieran cuatro sencillas reglas para crear diseños calidad. imagine que siguiéndolas accediera estructura diseño código facilitara aplicación principios como srp dip. imagine que estas cuatro reglas facilitaran emergencia diseños calidad. muchos consideramos que las cuatro reglas kent beck diseño sencillo [] son fundamentales para crear software bien diseñado. según kent, diseño sencillo cumple estas cuatro reglas: ejecuta todas las pruebas. contiene duplicados. expresa intención del programador. minimiza número clases métodos. describiremos estas reglas orden importancia. primera regla del diseño sencillo: ejecutar todas las pruebas primer lugar, diseño debe generar sistema que actúe forma prevista. sistema puede tener diseño perfecto sobre papel pero existe una forma sencilla comprobar que realmente funciona forma esperada, esfuerzo sobre papel cuestionable. sistema minuciosamente probado que supera todas las pruebas todo momento denomina sistema testable. una afirmación obvia, pero importante. los sistemas que pueden probar pueden verificar, sistema que puede verificar debe implementarse. afortunadamente, crear sistemas testables hace que diseñemos clases tamaño reducido solo cometido. resulta más sencillo probar clases que cumplen srp. cuantas más pruebas diseñemos, más nos acercaremos elementos más fáciles probar. por tanto, hacer que nuestro sistema pueda probar nos ayuda crear mejores diseños. las conexiones rígidas dificultan creación pruebas. del mismo modo, cuantas más pruebas creemos, más usaremos principios como dip con inyección dependencias, interfaces abstracción para minimizar dichas conexiones. nuestros diseños mejorarán todavía más. especial, seguir una sencilla regla que afirme que debemos realizar pruebas ejecutarlas continuamente afecta cumplimiento por parte nuestro sistema los principales objetivos programación orientada objetos baja conexión elevada cohesión. creación pruebas conduce obtener mejores diseños. reglas del diseño sencillo: refactorizar una vez creadas las pruebas, debemos mantener limpio código las clases. para ello, refactorizamos código progresivamente. tras añadir unas líneas, nos detenemos reflejamos nuevo diseño. ¿ empeorado? caso afirmativo, limpiamos ejecutamos las pruebas para comprobar que hay elementos afectados. presencia las pruebas hace que perdamos miedo limpiar código que resulte dañado . fase refactorización, podemos aplicar todos los aspectos del diseño software correcto. podemos aumentar cohesión, reducir las conexiones, separar las preocupaciones, modularizar aspectos del sistema, reducir tamaño funciones clases, elegir nombres más adecuados, etc. aquí también aplicamos las tres últimas reglas del diseño correcto: eliminar duplicados, garantizar capacidad expresión minimizar número clases métodos. eliminar duplicados los duplicados son los mayores enemigos sistema bien diseñado. suponen esfuerzo adicional, riesgos añadidos una complejidad mayores innecesaria. los duplicados manifiestan diversas formas. las líneas código similar pueden modificarse para que parezcan refactorizadas, hay otras formas duplicación como implementación. por ejemplo, podríamos tener dos métodos una clase colección: size() {} boolean isempty() {} podríamos tener implementaciones separadas para cada método. método isempty podría controlar valor booleano size contador, podemos eliminar duplicación vincular isempty definición size : boolean isempty() { return == size(); } creación sistema limpio requiere eliminación duplicados, aunque sean unas cuantas líneas código. fíjese siguiente ejemplo: public void scaletoonedimension { float desireddimension, float imagedimension) { (math.abs(desireddimension - imagedimension) < errorthreshold) return; float scalingfactor = desireddimension / imagedimension; scalingfactor = (float)(math.floor(scalingfactor * ) * .); renderedop newimage = imageutilities.getscaledimage( image, scalingfactor, scalingfactor); image.dispose(); system.(); image = newimage; } public synchronized void rotate(int degrees) { renderedop newimage = imageutilities.getrotatedimage( image, degrees); image.dispose(); system.(); image = newimage; } para mantener limpio este sistema, debemos eliminar pequeña cantidad duplicación entre los métodos scaletoonedimension rotate : public void scaletoonedimension ( float desireddimension, float imagedimension) { (math.abs(desireddimension - imagedimension) < errorthreshold) return; float scalingfactor = desireddimension / imagedimension; scalingfactor = (float)(math.floor(scalingfactor * ) * .); replaceimage(imageutilities.getscaledimage( image, scalingfactor, scalingfactor)); } public synchronized void rotate (int degrees) { replaceimage(imageutilities.getrotatedimage(image, degrees)); } private void replaceimage(renderedop newimage) ( .dispose(); system.(); image = newimage; } extraer este reducido nivel, comenzamos detectar incumplimientos srp. por ello, podríamos cambiar nuevo método extraído otra clase. esto aumenta visibilidad. otro miembro del equipo puede ver necesidad volver extraer nuevo método usarlo otro contexto diferente. esta reutilización mínima puede reducir considerablemente complejidad del sistema. saber cómo lograrlo fundamental para alcanzar reutilización gran escala. patrón método plantilla [] una técnica muy utilizada para eliminar duplicados nivel superior. por ejemplo: public class vacationpolicy { public void accrueusdivisionvacation() { // código para calcular las vacaciones función las horas trabajadas //… // código para garantizar que las vacaciones cumplen los mínimos legales //… // código para aplicar vacation registro payroll //… } public void accrueeudivisionvacation() { // código para calcular las vacaciones función las horas trabajadas //… // código para garantizar que las vacaciones cumplen los mínimos legales //… // código para aplicar vacation registro payroll //… } } código entre accrueusdivisionvacation accrueeuropeandivisionvacation prácticamente idéntico, excepción del cálculo mínimos legales. esa parte del algoritmo cambia función del tipo empleado. podemos eliminar duplicación evidente aplicamos patrón método plantilla : abstract public class vacationpolicy { public void accruevacation() { calculatebasevacationhours(); alterforlegalminimums(); applytopayroll(); } void calculatebasevacationhours() { /* … */ }; abstract protected void alterforlegalminimums(); private void applytopayroll(); { /* … */ }; } public class usvacationpolicy extends vacationpolicy { @override protected void alterforlegalminimums() { // lógica específica .. } } public class euvacationpolicy extends vacationpolicy { @override protected void alterforlegalminimums() { // lógica específica . } } las subclases ocupan vacío generado algoritmo accruevacation solamente proporcionan los datos que están duplicados. expresividad muchos tenemos experiencia con código enrevesado. muchos hemos creado. fácil crear código que entendamos, que durante creación nos centramos comprender problema que intentamos resolver. los encargados mantener código comprenderán misma forma. principal coste proyecto software mantenimiento largo plazo. para minimizar los posibles defectos realizar cambios, fundamental que comprendamos funcionamiento del sistema. aumentar complejidad los sistemas, programador necesita más tiempo para entenderlo aumentan las posibilidades errores. por tanto, código debe expresar con claridad intención autor. cuando más claro sea código, menos tiempo perderán otros intentar comprenderlo. esto reduce los defectos coste mantenimiento. puede expresarse elige nombres adecuados. objetivo ver nombre una clase función, que sus responsabilidades nos sorprendan. también puede expresarse reduce tamaño funciones clases. hacerlo, resulta más sencillo asignarles nombres, crearlas comprenderlas. forma expresarse usar una nomenclatura estándar. los patrones diseño, por ejemplo, basan comunicación capacidad expresión. usar los nombres patrones estándar, como command visitor , los nombres las clases que implementan dichos patrones puede describir sucintamente diseño otros programadores. las pruebas unidad bien escritas también son expresivas. uno los principales objetivos una prueba servir documentación mediante ejemplos. los que lean las pruebas deben entender con facilidad para qué sirve una clase. pero forma más importante ser expresivo práctica. menudo, conseguimos que código funcione pasamos siguiente problema sin detenernos facilitar lectura del código para otros. olvide que seguramente sea próximo que lea código. por tanto, afronte creación con orgullo. dedique tiempo sus funciones clases. seleccione nombres mejores, divida las funciones extensas otras más reducidas cuide obra. cuidado recurso precioso. clases métodos mínimos incluso conceptos tan básicos como eliminación código duplicado, expresividad del código srp pueden exagerarse. esfuerzo por reducir tamaño clases métodos, podemos crear demasiadas clases métodos reducidos. esta regla también sugiere minimizar cantidad funciones clases. una gran cantidad clases métodos suele indicar dogmatismo sin sentido. imagine estándar código que insista creación una interfaz para todas las clases, programadores que insisten qué campos comportamientos siempre deben separarse clases datos clases comportamiento. este dogma debe evitarse cambiarse por enfoque más pragmático. nuestro objetivo reducir tamaño general del sistema además del tamaño clases funciones, pero recuerde que esta regla menor las cuatro. por ello, aunque sea importante reducir cantidad clases funciones, más importante contar con pruebas, eliminar duplicados expresarse correctamente. conclusión ¿existen prácticas sencillas que puedan reemplazar experiencia? por supuesto que . sin embargo, las prácticas descritas este capítulo libro son una forma cristalizada décadas experiencia muchos autores. práctica del diseño correcto anima permite los programadores adoptar principios patrones que caso contrario tardarían años aprender. bibliografía [xpe] : extreme programming explained: embrace change , kent beck, addison wesley, . [gof] : design patterns: elements reusable object oriented software , gamma ., addison-wesley, . concurrencia por brett . schuchert “los objetos son abstracciones procesamiento. los subprocesos son abstracciones programaciones”. —james . coplien [] creación programas concurrentes limpios complicada, muy complicada. mucho más sencillo crear código que ejecute mismo proceso. también fácil crear código subprocesamiento múltiple que parezca correcto superficie pero que esté dañado niveles más profundos. este código funciona correctamente hasta que sistema somete determinadas presiones. este capítulo analizaremos necesidad programación concurrente sus dificultades. tras ello, presentaremos diversas recomendaciones para superar dichas dificultades crear código concurrente limpio. por último, finalizaremos con los problemas relacionados con prueba código concurrente. concurrencia limpia tema complejo, merecedor libro propio. aquí, intentaremos ofrecer una visión general, que después ampliaremos apéndice . simplemente tiene curiosidad por tema, bastará con este capítulo. necesita entender concurrencia nivel más profundo, consulte también apéndice. ¿por qué concurrencia? concurrencia una estrategia desvinculación. nos permite desvincular que hace dónde hace. aplicación solo proceso, qué cuándo están tan firmemente vinculados que estado aplicación puede determinar analizando huella pila. programador que depure este tipo sistemas puede definir punto interrupción ( varios) saber estado aplicación función del punto que llegue. desvinculación del qué del dónde puede mejorar considerablemente rendimiento estructura una aplicación. desde punto vista estructural, aplicación parece una serie equipos colaboradores gran bucle principal. esto puede hacer que sistema sea más fácil ofrece diversas formas separar las preocupaciones. pongamos por caso modelo servlet estándar aplicaciones web. estos sistemas ejecutan bajo contenedor web ejb que gestiona parcialmente concurrencia. los servlet ejecutan forma asíncrona cuando reciben solicitudes web. programador los servlet tiene que gestionar todas las solicitudes entrantes. principio, ejecución cada servlet vive mundo propio desvincula del resto. evidentemente, fuera tan sencillo, necesitaríamos este capítulo. hecho, desvinculación proporcionada por los contenedores web dista mucho ser perfecta. los programadores servlet deben asegurarse que sus programas sean correctos. obstante, las ventajas estructurales del modelo servlet son significativas. pero estructura único motivo para adoptar concurrencia. algunos sistemas tienen limitaciones tiempo respuesta producción que requieren soluciones concurrentes manuales. imagine dispositivo para añadir información, con solo proceso, que obtiene datos distintos sitios web los combina resumen diario. tener solo proceso, accede por turnos cada sitio web siempre termina uno antes comenzar siguiente. recorrido diario debe ejecutarse menos horas. sin embargo, añadir nuevos sitios web, tiempo aumenta hasta necesitarse más horas para recopilar todos los datos. único proceso implica una prolongada espera para completar /. podríamos mejorar rendimiento con ayuda algoritmo subprocesamiento múltiple que visite más sitio web por vez. imagine sistema que procesa usuario por vez sólo requiere segundo por cada uno. capacidad respuesta válida para número reducido usuarios pero aumenta, también hace tiempo respuesta del sistema. ningún usuario querrá esperar otros . podríamos mejorar tiempo respuesta este sistema procesando varios usuarios vez. imagine sistema que interprete grandes conjuntos datos pero que sólo ofrezca una solución completa tras procesarlos todos. podría procesar cada conjunto datos equipo distinto, para poder procesarlos todos paralelo. imprecisiones también existen motivos evidentes para adoptar concurrencia aunque, como indicamos antes, sea complicada. presta suficiente atención, pueden darse casos desagradables. veamos los mitos imprecisiones más habituales: concurrencia siempre mejora rendimiento : ocasiones hace pero sólo cuando puede compartir tiempo entre varios procesos procesadores. ninguna situación trivial. diseño cambia crear programas concurrentes : hecho, diseño algoritmo concurrente puede ser muy distinto sistema solo proceso. desvinculación entre qué cuándo suele tener efecto importante estructura del sistema. importante entender los problemas concurrencia trabajar con contenedor web ejb : realidad, debe saber que hace contenedor protegerlo problemas actualizaciones concurrentes bloqueo, como veremos después. veamos otros aspectos relacionados con creación software concurrente: concurrencia genera cierta sobrecarga , tanto rendimiento como creación código adicional. concurrencia correcta compleja , incluso para problemas sencillos. los errores concurrencia suelen repetir , modo que ignoran [] lugar considerarse verdaderos problemas. concurrencia suele acarrear cambio fundamental estrategia diseño . desafíos ¿qué hace que programación concurrente sea tan complicada? fíjese clase: public class { private int lastidused; public int getnextid() { return ++lastidused; } } imagine que creamos una instancia , establecemos campo lastidused después compartimos instancia entre dos procesos. imagine ahora que esos dos procesos invocan método getnextid() ; hay tres resultados posibles: primer proceso obtiene valor , segundo valor lastidused . primer proceso obtiene valor , segundo valor lastidused . primer proceso obtiene valor , segundo valor lastidused . sorprendente tercer resultado [] produce cuando los dos procesos coinciden. debe que pueden adoptar varias rutas posibles una línea código java algunas generan resultados incorrectos. ¿cuántas rutas distintas existen? para responder, debemos entender que hace compilador justo tiempo con código bytes generado, que modelo memoria java considera atómico. una rápida respuesta, con código bytes generado, que existen rutas ejecución diferentes [] para los dos procesos ejecutados método getnextid . tipo lastidused cambia int long , número rutas asciende . evidentemente, muchas generan resultados válidos. problema que algunas hacen . principios defensa concurrencia continuación mostramos una serie principios técnicas para proteger sus sistemas los problemas del código concurrente. principio responsabilidad única (srp) srp [] establece que método, clase componente sólo debe tener motivo para cambiar. diseño concurrencia bastante complejo como para ser motivo cambio con derecho propio , por tanto, debe separarse del resto del código. desafortunadamente, habitual incrustar los detalles implementación concurrencia directamente otro código producción. tenga cuenta los siguientes aspectos: código relacionado con concurrencia tiene propio ciclo desarrollo , cambios ajustes. código relacionado con concurrencia tiene sus propios desafíos , diferentes más complicados, que los del código relacionado con concurrencia. número formas las que código incorrecto basado concurrencia puede fallar complica por , sin carga añadida del código aplicación circundante. recomendación : separe código concurrencia del resto del código [] . corolario: limitar ámbito los datos como hemos visto, dos procesos que modifican mismo campo objeto compartido pueden interferir entre ellos provocar comportamiento inesperado. una solución consiste usar palabra clave synchronized para proteger una sección importante del código que use objeto compartido, aunque conviene limitar cantidad estas secciones. cuantos más puntos actualicen datos compartidos, más probable que: olvide proteger uno varios esos puntos, dañe código que modifica los datos compartidos. duplique esfuerzo necesario para garantizar protección todos los elementos (incumplimiento dry [] ). resulta complicado determinar origen los fallos, que por naturaleza son difíciles detectar. recomendación : encapsule los datos limite acceso los datos compartidos . corolario: usar copias datos una forma evitar datos compartidos compartirlos. algunos casos pueden copiar objetos procesarlos como fueran sólo lectura. otros, pueden copiar objetos, recopilar los resultados varios procesos las copias después combinar los resultados mismo proceso. existe una forma sencilla evitar los objetos compartidos, código resultante tendrá menos problemas. puede que preocupe coste creación objetos adicionales. merece pena experimentar comprobar problema real. obstante, uso copias objetos permite código evitar sincronización, las ventajas evitar bloque compensan creación adicional sobrecarga recolección elementos sin usar. corolario: los procesos deben ser independientes pruebe crear código sus procesos forma que cada uno sea independiente comparta datos con otros. cada uno procesa una solicitud cliente todos los datos necesarios provienen origen sin compartir almacenan como variables locales. este modo, los procesos comportan como fueran los únicos del mundo existieran requisitos sincronización. por ejemplo, las subclases httpservlet reciben toda información como parámetros pasados los métodos doget dopost . esto hace que cada servlet actúe como dispusiera propio equipo. mientras código del servlet sólo use variables locales, imposible que cause problemas sincronización. evidentemente, muchas aplicaciones que usan servlet topan con recursos compartidos como conexiones base datos. recomendación : intente dividir los datos subconjuntos independientes que puedan procesar procesos independientes, posiblemente distintos procesadores . conocer las bibliotecas java ofrece muchas mejoras para desarrollo concurrente con respecto versiones anteriores. existen diversos aspectos que tener cuenta hora crear código procesos java : usar las colecciones compatibles con procesos proporcionadas. usar estructura ejecución tareas relacionadas. usar soluciones antibloqueo siempre que sea posible. varias clases bibliotecas son compatibles con procesos. colecciones compatibles con procesos los albores java, doug lea escribió conocido libro [] concurrent programming java . mismo tiempo, desarrolló varias colecciones compatibles con procesos, que posteriormente pasaron formar parte del jdk paquete java.util.concurrent . las colecciones dicho paquete son compatibles con casos procesos múltiples tienen rendimiento adecuado. hecho, implementación concurrenthashmap tiene mejor rendimiento que hashmap mayoría los casos. también permite lecturas escrituras simultáneas, dispone métodos que admiten operaciones composición habituales que caso contrario serian incompatibles con subprocesos. java entorno desarrollo, comience con concurrenthashmap . otras clases añadidas para admitir diseño avanzado concurrencia. veamos algunos ejemplos: reentrantlock bloqueo que puede adquirir método liberar otro. semaphore una implementación del clásico semáforo, bloqueo con contador. countdownlatch bloqueo que espera número eventos antes liberar todos los subprocesos retenidos. este modo todos tienen misma oportunidad iniciarse mismo tiempo. recomendación : revise las clases las que disponga. caso java, debe familiarizarse con java.util.concurrent, java.util.concurrent.atomic java.util.concurrent.locks . conocer los modelos ejecución existen diversas formas dividir comportamiento una aplicación concurrente. para describirlos debe conocer ciertas definiciones básicas. recursos vinculados recursos tamaño número fijo usados entorno concurrente, como por ejemplo conexiones base datos búfer lectura/escritura tamaño fijo. exclusión mutua sólo proceso puede acceder datos recurso compartido por vez. inanición impide que proceso grupo procesos continúen demasiado tiempo indefinidamente. por ejemplo, permite primero ejecución los procesos más rápidos, los que ejecutan durante más tiempo pueden perecer inanición los primeros terminan nunca. bloqueo dos más procesos esperan que ambos terminen. cada proceso tiene recurso ninguno puede terminar hasta que obtenga otro recurso. bloqueo procesos bloqueados, intentando realizar labor pero estorbándose unos otros. por motivos resonancia, los procesos siguen intentando avanzar pero pueden durante demasiado tiempo, forma indefinida. tras mostrar estas definiciones, podemos describir los distintos modelos ejecución empleados programación concurrente. productor-consumidor [] uno varios procesos productores crean trabajo añaden búfer una cola. uno varios procesos consumidores adquieren dicho trabajo cola completan. cola entre productores consumidores recurso vinculado, que significa que los productores deben esperar que libere espacio cola antes escribir los consumidores deben esperar hasta que haya algo que consumir cola. coordinación entre productores consumidores través cola hace que unos emitan señales otros. los productores escriben cola indican que está vacía. los consumidores leen cola indican que está llena. ambos esperan notificación para poder continuar. lectores-escritores [] cuando recurso compartido actúa básicamente como fuente información para lectores pero ocasionalmente actualiza por parte escritores, producción problema. énfasis producción puede provocar inanición acumulación información caducada. las actualizaciones pueden afectar producción. coordinación lectores para que lean algo que escritor está actualizando viceversa complicada. los escritores tienden bloquear los lectores durante periodos prolongados, que genera problemas producción. desafío consiste equilibrar las necesidades ambos para satisfacer funcionamiento correcto, proporcionar una producción razonable evitar inanición. una sencilla estrategia hace que los escritores esperen hasta que deje haber lectores antes realizar una actualización. hay lectores , los escritores perecen inanición. por otra parte, hay escritores frecuentes les asigna prioridad, producción afectada. determinar equilibrio evitar problemas actualización concurrente objetivo este modelo. cena los filósofos [] imagine varios filósofos sentados alrededor una mesa redonda. izquierda cada uno hay tenedor. centro mesa, una gran fuente espaguetis. los filósofos pasan tiempo pensando menos que tengan hambre. cuando tienen hambre, utilizan los tenedores situados ambos lados para comer. pueden comer menos que tengan dos tenedores. filósofo situado derecha izquierda otros tiene uno los tenedores que necesita, tendrá que esperar que termine comer deje los tenedores. cuando filósofo termina comer, vuelve colocar los tenedores mesa hasta que vuelve tener hambre. cambie los filósofos por procesos los tenedores por recursos tendrá problema habitual muchas aplicaciones las que los procesos compiten por recursos. menos que diseñen correctamente, los sistemas que compiten esta forma experimentan problemas bloqueo, bloqueo mutuo, producción degradación eficacia. mayoría problemas concurrencia que encontrará serán alguna variante éstos. analice los algoritmos cree soluciones propias para estar preparado cuando surjan problemas concurrencia. recomendación : aprenda estos algoritmos básicos comprenda sus soluciones . dependencias entre métodos sincronizados las dependencias entre métodos sincronizados generan sutiles errores código concurrente. java cuenta con synchronized , que protege métodos individuales. obstante, hay más método sincronizado misma clase compartida, puede que sistema sea incorrecto [] . : evite usar más método objeto compartido . ocasiones tendrá que usar más método objeto compartido. ese caso, hay tres formas crear código correcto: bloqueo basado clientes : cliente debe bloquear servidor antes invocar primer método asegurarse que alcance del bloque incluye código que invoque último método. bloqueo basado servidores : debe crear método servidor que bloquee servidor, invoque todos los métodos después anule bloqueo. cliente debe invocar nuevo método. servidor adaptado : cree intermediario que realice bloque. ejemplo bloqueo basado servidores que servidor original puede modificar. reducir tamaño las secciones sincronizadas palabra clave synchronized presenta bloqueo. todas las secciones código protegidas por mismo bloque sólo tendrán proceso que las ejecute momento dado. los bloqueos son costosos que generan retrasos añaden sobrecarga. por ello, conviene colapsar código con instrucciones synchronized . por otra parte, las secciones críticas [] deben protegerse, modo que debemos diseñar nuestro código con menor número posible secciones críticas. algunos programadores intentan lograrlo ampliando tamaño sus secciones críticas. sin embargo, ampliar sincronización más allá sección crítica mínima aumentan los problemas afecta negativamente rendimiento [] . recomendación : reduzca máximo tamaño las secciones synchronized . crear código cierre correcto complicado sistema activo que ejecute indefinidamente distinto crear algo que funcione forma temporal después cierre correctamente. entre los problemas más habituales destacan los bloqueos [] , con procesos que esperan una señal para continuar que nunca produce. imagine, por ejemplo, sistema con proceso principal que genera varios procesos secundarios que espera que todos terminen antes liberar sus recursos cerrarse. ¿qué sucede uno los procesos secundarios está bloqueado? principal esperará indefinidamente sistema nunca cerrará. imagine ahora sistema similar que indica que cierre. proceso principal indica todos los secundarios que abandonen sus tareas terminen. pero imagine que dos procesos secundarios funcionan como par productor/consumidor que productor recibe una señal del principal cierra rápidamente. consumidor espera mensaje del productor puede quedar bloqueado estado que recibe señal del principal, que también impide que éste finalice. son situaciones habituales. por tanto, tiene que crear código concurrente con cierres correctos, tendrá que dedicar tiempo que cierre produzca forma correcta. recomendación : planifique con antelación proceso cierre pruébelo hasta que funcione. llevará más tiempo del que espera. repase los algoritmos existentes porque será complicado . probar código con procesos demostrar que código correcto resulta práctico. las pruebas garantizan corrección. sin embargo, las pruebas adecuadas pueden minimizar los riesgos, especial aplicaciones solo proceso. cuando hay dos más procesos que usan mismo código trabajan con datos compartidos, situación vuelve más compleja. recomendación : cree pruebas que puedan detectar problemas ejecútelas periódicamente, con distintas configuraciones programación del sistema, cargas. las pruebas fallan, identifique fallo. ignore las pruebas superen una ejecución posterior . hay muchos factores que tener cuenta. veamos algunas recomendaciones concretas: considere los fallos como posibles problemas los procesos. consiga que primero funcione código sin procesos. código con procesos debe poder conectar otros elementos. código con procesos debe ser modificable. ejecute con más procesos que procesadores. ejecute diferentes plataformas. diseñe código para probar forzar fallos. considerar los fallos como posibles problemas los procesos código con procesos hace que fallen elementos que deberían fallar. muchos desarrolladores desconocen cómo interactúan los procesos con otro tipo código. los problemas del código con procesos pueden mostrar sus síntomas una vez cada mil millón ejecuciones. los intentos por repetir los sistemas pueden resultar frustrantes, que suele provocar que los programadores consideren fallo como algo aislado. recomendable asumir que los fallos aislados existen. cuanto más los ignore, mayor será cantidad código que acumule sobre enfoque defectuoso. recomendación : ignore los fallos del sistema como algo aislado . conseguir que primero funcione código sin procesos puede parecer evidente pero está más recordarlo. asegúrese que código funciona fuera sus procesos. por general, esto significa crear algunos pojo que los procesos deban invocar. los pojo son compatibles con los procesos por tanto pueden probar fuera entorno. conviene los pojo mayor cantidad posible del sistema. recomendación : intente identificar fallos procesos que sean procesos mismo tiempo. asegúrese que código funciona fuera los procesos . código con procesos debe poder conectar otros elementos cree código compatible con concurrencia forma que pueda ejecutar distintas configuraciones: proceso, varios procesos variarlo durante ejecución. código con procesos interactúa con algo que puede ser real probado. ejecutar con pruebas dobles ejecutadas forma rápida, lenta variable. configurar pruebas que ejecutar diferentes iteraciones. recomendación : código con procesos debe poder conectar otros elementos ejecutar distintas configuraciones . código con procesos debe ser modificable obtención del equilibrio adecuado procesos suele requerir operaciones ensayo error. las fases iniciales, compruebe rendimiento del sistema bajo diferentes configuraciones. permita que puedan modificar los distintos procesos también durante ejecución del sistema. también puede permitir modificación automática función producción utilización del sistema. ejecutar con más procesos que procesadores cuando sistema cambia tarea, producen reacciones. para promover intercambio tareas, realice ejecución con más procesos que procesadores núcleos. cuanto mayor sea frecuencia intercambio las , más probabilidades existen que código carezca una sección crítica produzcan bloqueos. ejecutar diferentes plataformas diseñamos curso sobre programación concurrente, principalmente . clase presentó con windows ejecutado una . crearon pruebas para ilustrar condiciones fallo que fallaban con más frecuencia que . todos los casos, código probado era incorrecto. esto refuerza hecho que cada sistema operativo tiene una política procesos diferente que afecta ejecución del código. código con procesos múltiples comporta forma distinta cada entorno [] . debe ejecutar sus pruebas todos los entornos implementación posibles. recomendación : ejecute código con procesos todas las plataformas destino con frecuencia las fases iniciales . diseñar código para probar forzar fallos habitual que los fallos del código concurrente oculten. las pruebas sencillas suelen mostrarlos. realidad, suelen ocultarse durante procesamiento normal. pueden aparecer horas, días semanas después. razón que los problemas procesos sean infrecuentes, esporádicos apenas repitan que sólo fallan algunas las miles rutas posibles que recorren una sección vulnerable. por tanto, probabilidad adoptar una ruta fallida realmente baja, que dificulta detección depuración. preguntará cómo aumentar las posibilidades capturar estos casos. puede diseñar código forzarle que ejecute diferentes órdenes añadiendo métodos como object.wait() , object.sleep() , object.yield() object.priority() . estos métodos afectan orden ejecución , por tanto, aumentan las posibilidades detectar error. resulta más adecuado que código falle antes posible con frecuencia. hay dos opciones instrumentación código: manual. automática. manual puede añadir invocaciones wait() , sleep() , yield() priority() manualmente código, especial tiene que probar fragmento especialmente escabroso. veamos ejemplo: public synchronized string nexturlornull() { (hasnext()) { string url = urlgenerator.next(); thread.yield(); // añade para pruebas. updatehasnext(); return url; } return null; } invocación yield() cambia ruta ejecución adoptada por código posiblemente hace que código falla donde hacía antes. código falla, debe invocación yield() añadida [] . debe que código incorrecto hemos hecho que fallo sea más evidente. este enfoque presenta varios problemas: tendrá que buscar manualmente los puntos adecuados donde hacerlo. ¿cómo sabe dónde incluir invocación qué tipo invocación usar? presencia este código entorno producción ralentiza innecesariamente código. enfoque que puede detectar los fallos; hecho, las tiene todas consigo. que necesitamos una forma hacerlo durante fase pruebas, producción. también debemos poder mezclar configuraciones entre ejecuciones, que aumenta las probabilidades detectar los errores. , dividimos sistema pojo que sepa nada los procesos clases que controlen los procesos, resultará más sencillo ubicar los puntos los que instrumentar código. más, podríamos crear diferentes pruebas que invoquen los pojo bajo distintos regímenes invocaciones sleep , yield demás. automática puede usar herramientas como estructura orientada aspectos, cglib asm para instrumentar código mediante programación. por ejemplo, podría usar una clase con único método: public class threadjigglepoint { public static void jiggle() { } } puede añadir invocaciones distintos puntos del código: public synchronized string nexturlornull() { (hasnext()) { threadjigglepoint.jiggle(); string url = urlgenerator.next(); threadjigglepoint.jiggle(); updatehasnext(); threadjigglepoint.jiggle(); return url; } return null; } tras ello, use sencillo aspecto que seleccione aleatoriamente entre hacer nada, pausar generar resultado. imagine que clase threadjigglepoint tiene dos implementaciones. primera implementa jiggle para hacer nada usa producción. segunda genera número aleatorio para elegir entre sleep , yield nada. ejecuta sus pruebas mil veces con jiggle forma aleatoria, puede descubrir algunos fallos. prueba satisfactoria, menos puede felicitarse por haber actuado correctamente. aunque sea tanto simple, puede resultar una opción razonable lugar recurrir una herramienta más sofisticada. herramienta contest [] , desarrollada por ibm, tiene funcionamiento pero más sofisticada. objetivo que los procesos del código ejecuten distinto orden momentos diferentes. combinación pruebas bien escritas ejecuciones aleatorias puede aumentar considerablemente capacidad detectar errores. recomendación : use estas estrategias para detectar errores . conclusión complicado conseguir código concurrente correcto. código sencillo puede complicar añadir varios procesos datos compartidos. tiene que crear código concurrente, tendrá que hacerlo con rigor enfrentará sutiles esporádicos fallos. primer lugar, siga principio responsabilidad única. divida sistema varios pojo que separen código compatible con procesos del resto. asegúrese probar únicamente código compatible con procesos nada más, por que este código debe ser tamaño reducido específico. conozca los orígenes los problemas concurrencia: varios procesos que operen datos compartidos usen una agrupación recursos común. los casos límites, como cierre correcto conclusión iteración bucle, pueden ser especialmente espinosos. conozca biblioteca los algoritmos fundamentales. debe comprender cómo las funciones biblioteca permiten resolver problemas similares los los algoritmos fundamentales. aprenda localizar regiones del código que puedan bloquear bloquéelas. bloquee otras regiones que necesiten. evite invocar una sección bloqueada desde otra. para ello debe saber elemento está compartido . reduzca cantidad objetos compartidos ámbito. cambie los diseños los objetos con datos compartidos para acomodar clientes lugar obligar los clientes gestionar estado compartido. los problemas acumularán. los que aparezcan inicialmente suelen considerarse esporádicos suelen producirse fase carga modo aparentemente aleatorio. por tanto, debe poder ejecutar código con diferentes configuraciones plataformas forma repetida continua. capacidad prueba, algo natural aplica las tres leyes tdd, implica cierto nivel conectividad, que ofrece compatibilidad necesaria para ejecutar código distintas configuraciones. probabilidad detectar errores mejora toma tiempo necesario para instrumentar código. puede hacerlo manualmente mediante tecnologías automatizadas. hágalo las fases iniciales. aconsejable ejecutar código basado procesos durante mayor tiempo posible antes pasarlo producción. adopta enfoque limpio, aumentarán las probabilidades hacerlo forma correcta. bibliografía [lea] : concurrent programming java: design principles and patterns , . ., doug lea, prentice hall, . [ppp] : agile software development: principles, patterns, and practices , robert . martin, prentice hall, . [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, . refinamiento sucesivo caso práctico analizador argumentos línea comandos este capítulo caso práctico refinamiento sucesivo. veremos que comienza correctamente pero mantiene dicha corrección. tras ello, veremos cómo refactoriza limpia. muchos hemos tenido que analizar argumentos línea comando. disponemos una utilidad para ello, recorremos matriz cadenas pasadas función principal. puede encontrar utilidades calidad pero ninguna hace exactamente que necesitamos. por ello, decidí crear una propia, que denominado args . args muy fácil usar. basta crearla con los argumentos entrada una cadena formato, después consultar instancia args los valores los argumentos. fíjese siguiente ejemplo: listado - uso args public static void main(string[] args) { try { args arg = new args(“,#,*”, args); boolean logging = arg.getboolean(‘’); int port = arg.getint(‘’); string directory = arg.getstring(‘’); executeapplication(logging, port, directory); } catch (argsexception ) { system.out.printf(“argument error: %\”, .errormessage()); } } comprobará sencillo que . creamos una instancia clase args con dos parámetros. primero cadena formato esquema: “,#,*” . define tres argumentos línea comandos. primero, - , argumento booleano. segundo, - , argumento entero. tercero, - , argumento cadena. segundo parámetro del constructor args matriz argumentos línea comandos pasada main . constructor genera argsexception , línea comandos entrante analizado puede consultar instancia args . usan métodos como getboolean , getinteger getstring para acceder los valores los argumentos por sus nombres. hay problema, sea cadena formato los argumentos línea comandos, genera argsexception . descripción del error recuperar del método errormessage excepción. implementación args listado - implementación clase args . examínela con atención. estilo estructura han trabajado concienzudamente espero que los imite. listado - args.java package com.objectmentor.utilities.args; import static com.objectmentor.utilities.args.argsexception.errorcode.*; import java.util.*; public class args { private map<character, argumentmarshaler marshalers; private set<character argsfound; private listiterator<string currentargument; public args(string schema, string[] args) throws argsexception { marshalers = new hashmap<character, argumentmarshaler(); argsfound = new hashset<character(); parseschema(schema); parseargumentstrings(arrays.aslist(args)); } private void parseschema(string schema) throws argsexception { for (string element : schema.split(“,”)) (element.length() ) parseschemaelement(element.trim()); } private void parseschemaelement(string element) throws argsexception { char elementid = element.charat(); string elementtail = element.substring(); validateschemaelementid(element ); (elementtail.length() == ) marshalers.put(elementid, new booleanargumentmarshaler()); else (elementtail.equals(“*”)) marshalers.put(elementid, new stringargumentmarshaler()); else (elementtail.equals(“#”)) marshalers.put(elementid, new integerargumentmarshaler()); else (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); (elementtail.equals(“[*]”)) marshalers.put(elementid, new stringarrayargumentmarshaler()); else throw new argsexception(invalid_argument_format, elementid, elementtail); } private void validateschemaelementid(char elementid) throws argsexception { {!character.isletter(elementid)) throw new argsexception(invalid_argument_name, elementid, null); } private void parseargumentstrings(list<string argslist) throws argsexception { for (currentargument = argslist.listiterator(); currentargument.hasnext();) { string argstring = currentargument.next(); (argstring.startswith(“-”)) { parseargumentcharacters(argstring.substring()); } else { currentargument.previous(); break; } } } private void parseargumentcharacters(string argchars) throws argsexception { for (int = ; < argchars.length(); ++) parseargumentcharacter(argchars.charat()); } private void parseargumentcharacter(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); ( == null) { throw new argsexception (unexpected_argument, argchar, null); } else { argsfound.add(argchar); try { .set(currentargument); } catch (argsexception ) { .seterrorargumentid(argchar); throw ; } } } public boolean has(char arg) { return argsfound.contains(arg); } public int nextargument() { currentargument.nextindex(); } public boolean getboolean(char arg) { return booleanargumentmarshaler.getvalue(marshalers.get(arg)); } public string getstring(char arg) { return stringargumentmarshaler.getvalue(marshalers.get(arg)); } public int getint(char arg) { return integerargumentmarshaler.getvalue (marshalers.get(arg)); } public double getdouble(char arg) { return doubleargumentmarshaler.getvalue(marshalers.get(arg)); } public string[] getstringarray(char arg) { return stringarrayargumentmarshaler.getvalue(marshalers.get(arg)); } } puede leer código arriba abajo sin necesidad saltar punto otro buscar hacia adelante. que seguramente busque definición argumentmarshaler , que hemos omitido intencionadamente. tras leer código, comprenderá interfaz argumentmarshaler función sus variantes. veamos algunas ellas (entre los listados - -). listado - argumentmarshaler.java public interface argumentmarshaler { void set(iterator<string currentargument) throws argsexception; } listado - booleanargumentmarshaler.java public class booleanargumentmarshaler implements argumentmarshaler { private boolean booleanvalue = false; public void set (iterator<string currentargument) throws argsexception { booleanvalue = true; } public static boolean getvalue(argumentmarshaler ) { ( != null && instanceof booleanargumentmarshaler) return ((booleanargumentmarshaler) ).booleanvalue; else return false; } } listado - stringargumentmarshaler.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class stringargumentmarshaler implements argumentmarshaler { private string stringvalue = “”; public void set(iterator<string currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception ) { throw new argsexception(missing_string); } } public static string getvalue(argumentmarshaler ) { ( != null && instanceof stringargumentmarshaler) return ((stringargumentmarshaler) ).stringvalue; else return “”; } } listado - integerargumentmarshaler.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class integerargumentmarshaler implements argumentmarshaler { private int intvalue = ; public void set(iterator<string currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); intvalue = integer.parseint(parameter); } catch (nosuchelementexception ) { throw new argsexception(missing_integer); } catch (numberformatexception ) { throw new argsexception(invalid_integer, parameter); } } static int getvalue (argumentmarshaler ) { ( != null && instanceof integerargumentmarshaler) return ((integerargumentmarshaler) ).intvalue; else return ; } } las otras variantes argumentmarshaler simplemente repiten este patrón matrices double string sólo complicarían capítulo. puede consultarlas como ejercicio. otro fragmento que puede resultar complicado definición las constantes código error, incluidas clase argsexception (véase listado -). listado - argsexception.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class argsexception extends exception { private char errorargumentid = ‘\’; private string errorparameter = null; private errorcode errorcode = ; public argsexception() {} public argsexception(string message) { super(message); } public argsexception(errorcode errorcode) { this.errorcode = errorcode; } public argsexception(errorcode errorcode, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; } public argsexception(errorcode errorcode, char errorargumentid, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; this.errorargumentid = errorargumentid; } public char geterrorargumentid() { return errorargumentid; } public void seterrorargumentid(char errorargumentid) { this.errorargumentid = errorargumentid; } public string geterrorparameter() { return errorparameter; } public void seterrorparameter(string errorparameter) { this.errorparameter = errorparameter; } public errorcode geterrorcode() { return errorcode; } public void seterrorcode(errorcode errorcode) { this.errorcode = errorcode; } public string errormessage() { switch (errorcode) { case : return “tilt: should not get here.”; case unexpected_argument: return string.format(“argument -% unexpected.”, errorargumentid); case missing_string: return string.format(“could not find string parameter for -%.”, errorargumentid); case invalid integer: return string.format(“argument -% expects integer but was ‘%’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%.”, errorargumentid); case invalid_double: return string.format(“argument -% expects double but was ‘%’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%.”, errorargumentid); case invalid_argument_name: return string.format(“‘%’ not valid argument name.”, errorargumentid); case invalid_argument_format: return string.format(“‘%’ not valid argument format.”, errorparameter); } return “”; } public enum errorcode { , invalid_argument_format, unexpected_argument, invalid_argument_name, missing_string, missing_integer, invalid_integer, missing_double, invalid_double } } sorprendente cantidad código necesario para detallar este sencillo concepto. uno los motivos uso lenguaje especialmente profuso. java, ser lenguaje tipos estáticos, requiere muchas palabras para satisfacer sistema tipos. lenguajes como ruby, python smalltalk, este programa mucho más reducido [] . vuelva leer código. fíjese especialmente los nombres los elementos, tamaño las funciones formato. tiene experiencia como programador, partes del estilo estructura convencerán, pero espero que, desde punto vista global, considere que programa está bien escrito tiene una estructura limpia. por ejemplo, debería ser evidente cómo añadir nuevo tipo argumento, como una fecha número complejo, que dicha inclusión apenas requeriría código. definitiva, bastaría con una nueva variante argumentmarshaler , una nueva función getxxx una nueva instrucción case función parseschemaelement . también habría nuevo código argsexception.errorcode nuevo mensaje error. cómo realizado diseñé este programa principio fin forma actual , sobre todo, espero que pueda crear programas limpios elegantes primera. algo hemos aprendido las dos últimas décadas que programación arte más que una ciencia. para escribir código limpio, primero debe crear código imperfecto después limpiarlo. debería sorprenderle. aprendimos colegio cuando los profesores (normalmente vano) nos obligaban crear borradores nuestras redacciones. proceso, nos decían, era escribir primer borrador, después otro, después otros muchos hasta lograr una versión definitiva. para escribir redacciones limpias, refinamiento debía ser continuado. muchos programadores noveles (como sucede con los alumnos) siguen este consejo. creen que objetivo principal que programa funcione. una vez que consiguen, pasan siguiente tarea, conservan estado funcional del programa, sea cual sea. los programadores saben que esto suicidio profesional. args: primer borrador listado - muestra una versión inicial clase args . funciona, pero desastre. listado - args.java (primer borrador) import java.text.parseexception; import java.util.*; public class args { private string schema; private string[] args; private boolean valid = true; private set<character unexpectedarguments = new treeset<character(); private map<character, boolean booleanargs = new hashmap<character, boolean(); private map<character, string stringargs = new hashmap<character, string(); private map<character, integer intargs = new hashmap<character, integer(); private set<character argsfound = new hashset<character(); private int currentargument; private char errorargumentid = ‘\’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.; private enum errorcode { , missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema. string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { (schema.length() == && args.length == ) return true; parseschema(); try { parsearguments(); } catch (argsexception ) { } return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { (element.length() ) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(); string elementail = element.substring(); validateschemaelementid(elementid); (isbooleanschemaelement(elementtail)); parsebooleanschemaelement(elementid); else (isstringschemaelement(elementtail)) parsestringschemaelement(elementid); else (isintegerschemaelement(elementtail)) { parseintegerschemaelement(elementid); } else { throw new parseexception( string.format(“argument: % has invalid format: %.”, elementid, elementtail), ); } } private void validateschemaelementid(char elementid) throws parseexception { (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “ args format: ” + schema, ); } } private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, false); } private void parseintegerschemaelement(char elementid) { intargs.put(elementid, ); } private void parsestringschemaelement(char elementid) { stringargs.put(elementid, “”); } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == ; } private boolean isintegerschemaelement(string elementtail) { return elementtail.equals(“#”); } private boolean parsearguments() throws argsexception { for (currentargument = ; currentargument < args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) throws argsexception { (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int = ; < arg.length(); ++) parseelement(arg.charat()); } private void parseelement(char argchar) throws argsexception { (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = errorcode.unexpected_argument; valid = false; } } private boolean setargument(char argchar) throws argsexception { (isbooleanarg(argchar)) setbooleanarg(argchar, true); else (isstringarg(argchar)) setstringarg(argchar); else (isintarg(argchar)) setintarg(argchar); else return false; return true; } private boolean isintarg(char argchar) { return intargs.containskey(argchar); } void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.put(argchar, new integer(parameter)); } catch (arrayindexoutofboundsexception ) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch (numberformatexception ) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.put(argchar, args[currentargument]); } catch (arrayindexoutofboundsexception ) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } private boolean isstringarg(char argchar) { return stringargs.containskey(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isbooleanarg(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return argsfound.size(); } public string usage() { (schema.length() ) return "-[" + schema + “]”; else return “”; } string errormessage() throws exception { switch (errorcode) { case : throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%.”, errorargumentid); case invalid_integer: return string.format(“argument - % expects integer but was ‘%’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%.”, errorargumentid); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“arguments() -”); for (char : unexpectedarguments) { message.append(); } message.append(“ unexpected.”); return message.tostring(); } private boolean falseifnull(boolean ) { return != null && ; } private int zeroifnull(integer ) { return == null ? : ; } private string blankifnull(string ) { return = null ? “” : ; } public string getstring(char arg) { return blankifnull(stringargs.get(arg)); } public int getint(char arg) { return zeroifnull(intargs.get(arg)); } public boolean getboolean(char arg) { return falseifnull(booleanargs.get(arg)); } public boolean has(char arg) ( argsfound.contains(arg); } public boolean isvalid() { return valid; } private class argsexception extends exception { } } espero que reacción inicial ante tal cantidad código alegrarse por haberlo conservado tal cual. sido reacción, recuerde que será que tengan otros que lean borrador código. realidad, primer borrador mejor que puede decir sobre este código. evidentemente trabajo progreso. cantidad variables instancia apabullante. cadenas extrañas como « tilt », hashset treeset , los bloques try-catch-catch aumentan desastre. era intención crear este desastre. realidad, intentaba mantener cierta organización, como demuestra elección nombres funciones variables, estructura del programa. pero evidente que problema fue las manos. desastre aumentó gradualmente. las versiones anteriores fueron tan malas. por ejemplo, listado - muestra una versión inicial que sólo funcionaban los argumentos booleanos. listado - args.java (sólo argumentos booleanos) package com.objectmentor.utilities.getopts; import java.util.*; public class args { private string schema; private string[] args; private boolean valid; private set<character unexpectedarguments = new treeset<character(); private map<character, boolean booleanargs = new hashmap<character, boolean(); private int numberofarguments = ; public args(string schema, string[] args) { this.schema = schema; this.args = args; = parse(); } public boolean isvalid() { return valid; } private boolean parse() { (schema.length() == && args.length == ) return true; parseschema(); parsearguments(); return unexpectedarguments.size() == ; } private boolean parseschema() { for (string element : schema.split(“,”)) { parseschemaelement(element); } return true; } private void parseschemaelement(string element) { (element.length() == ) { parsebooleanschemaelement(element); } } private void parsebooleanschemaelement(string element) { char = element.charat(); (character.isletter()) { booleanargs.put(, false); } } private boolean parsearguments() { for (string arg : args) parseargument(arg); return true; } private void parseargument(string arg) { (arg.startswith(“-”)) parseelement(arg); } private void parseelements(string arg) { for (int = ; < arg.length(); ++) parseelement(arg.charat()); } private void parseelement(char argchar) { (isboolean(argchar)) { numberofarguments++; setbooleanarg(argchar, true); } else unexpectedarguments.add(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return numberofarguments; } public string usage() { (schema.length() ) return “-[”+schema+“]”; else return “”; } public string errormessage() { (unexpectedarguments.size() ) { return unexpectedargumentmessage(); } else return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument() -”); for (char : unexpectedarguments) { message.append(); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return booleanargs.get(arg); } } aunque hay motivos para quejarse del código, tan malo. compacto sencillo, fácil entender. sin embargo, este código aprecia semilla del desastre posterior resulta evidente porqué. versión posterior sólo tiene dos tipos argumentos más que ésta: string integer . inclusión sólo dos tipos más tiene tremendo impacto negativo código. convierte algo que sería razonablemente algo que seguramente esté plagado errores. añadí los dos tipos argumento forma incremental. primero, argumento string , que genera siguiente: listado - args.java (booleano string) package com.objectmentor.utilities.getopts; import java.text.parseexception; import java.util.*; public class args { private string schema; private string[] args; private boolean valid = true; private set<character unexpectedarguments = new treeset<character(); private map<character, boolean booleanargs = new hashmap<character, boolean(); private map<character, string stringargs = new hashmap<character, string(); private set<character argsfound = new hashset<character(); private int currentargument; private char errorargument = ‘\’; enum errorcode { , missing_string } private errorcode errorcode = errorcode.; public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { (schema.length() == && args.length == ) return true; parseschema(); parsearguments(); return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { (element.length() ) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(); string elementtail = element.substring(); validateschemaelementid(elementid); (isbooleanschemaelement(elementtail)) parsebooleanschemaelement(elementid); else (isstringschemaelement(elementtail)) parsestringschemaelement(elementid); } private void validateschemaelementid(char elementid) throws parseexception { (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “ args format: ” + schema, ); } } private void parsestringschemaelement(char elementid) { stringargs.put(elementid, “”); } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == ; } private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, false); } private boolean parsearguments() { for (currentargument = ; currentargument < args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) { (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) { for (int = ; < arg.length(); ++) parseelement(arg.charat()); } void parseelement(char argchar) { (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); valid = false; } } private boolean setargument(char argchar) { boolean set = true; (isboolean(argchar)) setbooleanarg(argchar, true); else (isstring(argchar)) setstringarg (argchar, “”); else set = false; return set; } private void setstringarg(char argchar, string ) { currentargument++; try { stringargs.put(argchar, args[currentargument]); } catch (arrayindexoutofboundsexception ) { valid = false; errorargument = argchar; errorcode = errorcode.missing_string; } } private boolean isstring(char argchar) { return stringargs.containskey(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return argsfound.size(); } public string usage() { (schema.length() ) return “-[” + schema + “]”; else return “”; } string errormessage() throws exception { (unexpectedarguments.size() ) { return unexpectedargumentmessage(); } else switch (errorcode) { case missing_string: return string.format (“could not find string parameter for -%.”, errorargument); case : throw new exception(“tilt: should not get here.”); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument() -”); for (char : unexpectedarguments) { message.append(); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return falseifnull(booleanargs.get(arg)); } private boolean falseifnull(boolean ) { return == null ? false : ; } public string getstring(char arg) { return blankifnull(stringargs.get(arg)); } private string blankifnull(string ) { return == null ? “” : ; } public boolean has(char arg) { return argsfound.contains(arg); } public boolean isvalid() { return valid; } } comprobará que empieza desbocarse. terrible pero desastre está gestando. basta con incluir tipo argumento integer para que resulte fatídico. detuve todavía tenía que añadir otros dos tipos argumentos sabía que empeorarían las cosas. los forzaba, seguramente funcionarían pero provocaría desastre demasiado complicado arreglar. estructura del código tenía que poder mantenerse, era momento corregirla. por ello dejé añadir elementos comencé refactorización. tras añadir los argumentos string integer , sabía que cada uno necesitaría nuevo código tres puntos principales. primer lugar, cada tipo argumento necesita una forma analizar elemento esquema para poder seleccionar hashmap ese tipo. tras ello, sería necesario analizar cada tipo argumento las cadenas línea comandos convertirlos tipo correcto. por último, cada tipo argumento necesitaría método getxxx para poder devolverlo invocador como tipo correcto. muchos tipos diferentes todos con métodos similares, que realidad era una clase. este modo nació concepto argumentmarshaler . sobre incrementalismo una las mejores formas acabar con programa realizar cambios masivos con intención mejorarlo. algunos programas nunca recuperan estas mejoras. problema complicado que resulta conseguir que programa funcione misma forma que antes mejora. para evitarlo, recurro disciplina tdd ( test-driven development desarrollo guiado por pruebas). una las doctrinas centrales este enfoque mantener ejecución del sistema todo momento. decir, con tdd puedo realizar cambios que afecten funcionamiento del sistema. todos los cambios deben mantenerlo como antes los cambios. para lograrlo, necesito una serie pruebas automatizadas que ejecutar rápidamente que verifiquen que comportamiento del sistema variado. para clase args , creé una serie pruebas unidad aceptación. las pruebas unidad crearon java administraron con junit. las aceptación crearon como páginas wiki fitnesse. podría haber ejecutado estas pruebas cualquier momento , eran satisfactorias, sabría que sistema funcionaba forma especificada. así pues, comencé realizar pequeños cambios. cada uno desplazaba estructura del sistema hacia concepto argumentmarshaler , cada cambio mantenía funcionamiento del sistema. primer cambio realizado fue añadir esqueleto argumentmarshaller final del desastre anterior (véase listado -). listado - argumentmarshaller añadido args.java private class argumentmarshaler { private boolean booleanvalue = false; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } private class booleanargumentmarshaler extends argumentmarshaler { } private class stringargumentmarshaler extends argumentmarshaler { } private class integerargumentmarshaler extends argumentmarshaler { } } evidentemente, esto afectaría nada, por que realicé modificación más sencilla posible que afectara mínima cantidad código. cambié hashmap para que los argumentos boolean aceptaran argumentmarshaler . private map<character, argumentmarshaler booleanargs = new hashmap<character, argumentmarshaler (); esto afectaba varias instrucciones que corregí rápidamente. … private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, new booleanargumentmarshaler ()); } … void setbooleanarg(char argchar, boolean value) { booleanargs. get (argchar). setboolean (value); } … public boolean getboolean(char arg) { return falseifnull (booleanargs.get(arg). getboolean() ); } estos cambios aplican las zonas que mencionamos antes: parse , set get para tipo argumento. desafortunadamente, aunque sean cambios menores, algunas las pruebas comenzaron fallar. fija atentamente getboolean , comprobará que puede invocar con pero existe argumento , por que booleanargs.get(‘’) devolverá null función generará nullpointerexception . función falseifnull usa como protección ante este hecho pero cambio aplicado hace que función sea irrelevante. incrementalismo exigía que esto funcionara antes realizar otros cambios. solución era demasiado complicada; bastaba con cambiar comprobación null . era necesario comprobar null boolean, sino argumentmarshaller . primero, eliminé invocación falseifnull función getboolean . servía nada, por que eliminé directamente función. las pruebas seguían fallando igual, que suponía que había nuevos errores. public boolean getboolean(char arg) { return booleanargs.get(arg).getboolean(); } tras ello, dividí función dos líneas añadí argumentmarshaller una variable propia: argumentmarshaller . preocupaba extenso nombre variable; era redundante estorbaba función, por que reduje []. public boolean getboolean(char arg) { args.argumentmarshaler = booleanargs.get(arg); return .getboolean(); } tras ello añadí lógica detección null . public boolean getboolean(char arg) { args.argumentmarshaler = booleanargs.get(arg); != null && .getboolean(); } argumentos cadena inclusión los argumentos string fue similar los argumentos boolean . tuve que cambiar hashmap conseguir que funcionaran parse , set get . deberían producirse sorpresas posteriores excepción que implementación completa incluía clase argumentmarshaller lugar distribuirla variantes. private map<character, argumentmarshaler stringargs = new hashmap<character, argumentmarshaler (); … private void parsestringschemaelement(char elementid) { stringargs.put(elementid, new stringargumentmarshaler()); } … private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs. get (argchar). setstring (args[currentargument]); } catch (arrayindexoutofboundsexception ) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring (char arg) { args.argumentmarshaler = stringargs.get(arg); return == null ? “” : .getstring(); } … private class argumentmarshaler { private boolean booleanvalue = false; private string stringvalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string ) { = ; } public string getstring() { return stringvalue == null ? “” : stringvalue; } } nuevo, estos cambios realizaron individualmente para conservar las pruebas, aunque fallaran. una prueba fallaba, aseguraba que fuera correcta antes continuar con siguiente cambio. debería reconocer intención. tras incluir comportamiento señalización clase base argumentmarshaler , comencé transferirlo las variantes, para esta forma mantener funcionamiento mientras cambiaba gradualmente forma del programa. siguiente paso consistía transferir funcionalidad del argumento int argumentmarshaler . nuevo, hubo sorpresas. private map<character, argumentmarshaler intargs = new hashmap<character, argumentmarshaler (); … private void parseintegerschemaelement(char elementid) { intargs.put(elementid, new integerargumentmarshaler() ); } … private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs. get (argchar). setinteger (integer.parseint(parameter)); } catch (arrayindexoutofboundsexception ) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch (numberformatexception ) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } … public int getint(char arg) { args.argumentmarshaler = intargs.get(arg); return == null ? : .getinteger(); } … private class argumentmarshaler { private boolean booleanvalue = false; private string stringvalue; private int integervalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string ) { stringvalue = ; } public string getstring() { return stringvalue == null ? “” : stringvalue; } public void setinteger(int ) { integervalue = ; } public int getinteger() { return integervalue; } } tras transferir señalización argumentmarshaler , comencé transferir funcionalidad las variantes. primer paso fue pasar función setboolean booleanargumentmarshaller garantizar correcta invocación. para ello creé método set abstracto. private abstract class argumentmarshaler { protected boolean booleanvalue = false; private string stringvalue; private int integervalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string ) { stringvalue = ; } public string getstring() { stringvalue == null ? “” : stringvalue; } public void set integer(int ) { integervalue = ; } public int getinteger() { return integervalue; } public abstract void set(string ); } tras ello, implementé método set booleanargumentmarshaller . private class booleanargumentmarshaler extends argumentmarshaler { public void set(string ) { booleanvalue = true; } } por último cambié invocación setboolean por set . private void setbooleanarg(char argchar, boolean value) { booleanargs.get(argchar). set(“true”) ; } las pruebas seguían siendo satisfactorias. como este cambio hacía que set implementara booleanargumentmarshaler , eliminé método setboolean clase base argumentmarshaler . función abstracta set acepta argumento string pero implementación booleanargumentmarshaler usa. incluido argumento porque sabía que stringargumentmarshaler integerargumentmarshaler utilizarían. tras ello, objetivo era implementar método get booleanargumentmarshaler . implementación funciones get siempre escabrosa que tipo devuelto tiene que ser object este caso debe convertirse boolean . public boolean getboolean(char arg) { args.argumentmarshaler = booleanargs.get(arg); return != null && (boolean) . get (); } para compilarlo, añadí función get argumentmarshaler . private abstract class argumentmarshaler { … object get() { return null; } } compila las pruebas fallan. para que vuelvan funcionar, basta con convertir get abstracto implementarlo booleanargumentmarshaler . private abstract class argumentmarshaler { protected boolean booleanvalue = false; … public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { public void set (string ) { booleanvalue = true; } public object get() { return booleanvalue; } } nuevo, las pruebas son satisfactorias. ahora tanto get como set implementan booleanargumentmarshaler . esto permite eliminar antigua función getboolean argumentmarshaler , cambiar variable protegida booleanvalue booleanargumentmarshaler convertirla privada. repetí mismo patrón cambios con las cadenas. implementé set get , eliminé las funciones sin usar desplacé las variables. private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.get(argchar). set (args[currentargument]); } catch (arrayindexoutofboundsexception ) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring(char arg) { args.argumentmarshaler = stringargs.get(arg); return == null ? “” : (string) . get (); } … private abstract class argumentmarshaler { private int integervalue; public void setinteger(int ) { integervalue = ; } public int getinteger() { return integervalue; } public abstract void set(string ); public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(string ) { booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(string ) { stringvalue = ; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { public void set(string ){ } public object get() { return null; } } } por último, repetí proceso con los enteros. resulta más complicado que los enteros deben analizarse operación análisis puede generar una , pero resultado más indicado que concepto numberformatexception oculta totalmente integerargumentmarshaler . private boolean isintarg(char argchar) { return intargs.containskey(argchar); } private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.get(argchar). set (parameter); } catch (arrayindexoutofboundsexception ) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( argsexception ) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw ; } } … private void setbooleanarg(char argchar) { try { booleanargs.get(argchar).set(“true”); } catch (argsexception ) { } } … public int getint(char arg) { args.argumentmarshaler = intargs.get(arg); return == null ? : (integer) . get (); } … private abstract class argumentmarshaler { public abstract void set(string ) throws argsexception; public abstract object get(); } … private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = ; public void set(string ) throws argsexception { try { intvalue = integer.parseint(); } catch (numberformatexception ) { throw new argsexception(); } } public object get() { return intvalue; } } evidentemente, las pruebas seguían funcionando. tras ello, deshice las distintas asignaciones parte superior del algoritmo, que hace que sistema sea mucho más genérico. sin embargo, las puede eliminar que afectaría integridad del sistema. lugar, añadí nuevo map para argumentmarshaler , tras ello, cambié uno uno los métodos para que usaran nueva asignación lugar las originales. public class args { … private map<character, argumentmarshaler booleanargs = new hashmap<character, argumentmarshaler(); private map<character, argumentmarshaler stringargs = new hashmap<character, argumentmarshaler(); private map<character, argumentmarshaler intargs = new hashmap<character, argumentmarshaler(); private map<character, argumentmarshaler marshalers = new hashmap<character, argumentmarshaler(); … private void parsebooleanschemaelement(char elementid) { argumentmarshaler = new booleanargumentmarshaler(); booleanargs.put(elementid, ); marshalers.put(elementid, ); } private void parseintegerschemaelement(char elementid) { argumentmarshaler = new integerargumentmarshaler(); intargs.put(elementid, ); marshalers.put(elementid, ); } private void parsestringschemaelement(char elementid) { argumentmarshaler = new stringargumentmarshaler(); stringargs.put(elementid, ); marshalers.put(elementid, ); } las pruebas seguían funcionando. tras ello, cambié isbooleanarg esto: private boolean isbooleanarg(char argchar) { return booleanargs.containskey(argchar); } este otro: boolean isbooleanarg(char argchar) { argumentmarshaler = marshalers.get(argchar); return instanceof booleanargumentmarshaler; } las pruebas funcionaban, por que apliqué mismo cambio isintarg isstringarg . private boolean isintarg(char argchar) { argumentmarshaler = marshalers.get(argchar); return instanceof integerargumentmarshaler; } private boolean isstringarg(char argchar) { argumentmarshaler = marshalers.get(argchar); return instanceof stringargumentmarshaler; } las pruebas eran correctas, por que eliminé las invocaciones duplicadas marshalers.get : private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); (isbooleanarg( )) setbooleanarg(argchar); else (isstringarg( )) setstringarg(argchar); else (isintarg( )) setintarg(argchar); else return false; return true; } private boolean isintarg ( argumentmarshaler ) { return instanceof integerargumentmarshaler; } private boolean isstringarg ( argumentmarshaler ) { return instanceof stringargumentmarshaler; } private boolean isbooleanarg ( argumentmarshaler ) { return instanceof booleanargumentmarshaler; } los tres argumentos isxxxarg tenían sentido, modo que los reubiqué: private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); ( instanceof booleanargumentmarshaler ) setbooleanarg(argchar); ( instanceof stringargumentmarshaler ) setstringarg(argchar); else ( instanceof integerargumentmarshaler ) setintarg(argchar); else return false; return true; } tras ello, empecé usar asignación marshalers las funciones set , dividiendo uso las otras tres asignaciones. comencé por los elementos boolean . private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); ( instanceof booleanargumentmarshaler) setbooleanarg( ); else ( instanceof stringargumentmarshaler) setstringarg(argchar); else ( instanceof integerargumentmarshaler) setintarg(argchar); else return false; return true; } … private void setbooleanarg( argumentmarshaler ) { try { .set(“true”); // era: booleanargs.get(argchar).set(“true”); } catch (argsexception ) { } } las pruebas seguían siendo correctas modo que repetí operación con las cadenas los enteros. esta manera puede integrar parte del desagradable código gestión excepciones función setargument . private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); try { ( instanceof booleanargumentmarshaler) setbooleanarg(); else ( instanceof stringargumentmarshaler) setstringarg( ); else ( instanceof integerargumentmarshaler) setintarg( ); else return false; } catch (argsexception ) { valid = false; errorargumentid = argchar; ; } return true; } private void setintarg( argumentmarshaler ) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; .set(parameter); } catch (arrayindexoutofboundsexception ) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception ) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw ; } } private void setstringarg( argumentmarshaler ) throws argsexception { currentargument++; try { .set(args[currentargument]); } catch (arrayindexoutofboundsexception ) { errorcode = errorcode.missing_string; throw new argsexception(); } } podía eliminar las tres asignaciones antiguas. primero, debía cambiar función getboolean : public boolean getboolean(char arg) { args.argumentmarshaler = booleanargs.get(arg); return != null && (boolean) .get(); } : public boolean getboolean(char arg) { args.argumentmarshaler = marshalers.get(arg); boolean = false; try { = != null && (boolean) .get(); } catch (classcastexception ) { = false; } return ; } este último cambio puede parecer sorprendente. ¿por qué repente decidí enfrentarme classcastexception ? por tener una serie pruebas otra serie independiente pruebas aceptación creadas fitnesse. las pruebas fitnesse garantizan que invoca getboolean argumento booleano, obtiene false . sucede mismo con las pruebas unidad. hasta momento, sólo había ejecutado las pruebas unidad [] . este último cambio permitió extraer otro uso asignación boolean: private void parsebooleanschemaelement(char elementid) { argumentmarshaler = new booleanargumentmarshaler(); booleanargs.put(elementid, ); marshalers.put(elementid, ); } ahora podemos eliminar asignación boolean. public class args { … private map<character, argumentmarshaler booleanargs = new hashmap<character, argmentmarshaler(); private map<character, argumentmarshaler stringargs = new hashmap<character, argumentmarshaler(); private map<character, argumentmarshaler intargs = new hashmap<character, argumentmarshaler(); private map<character, argumentmarshaler marshalers = new hashmap<character, argumentmarshaler(); … tras ello, cambié los argumentos string integer misma forma limpié los valores boolean . private void parsebooleanschemaelement(char elementid) { marshalers.put(elementid, new booleanargumentmarshaler() ); } private void parseintegerschemaelement(char elementid) { marshalers.put(elementid, new integerargumentmarshaler() ); } private void parsestringschemaelement(char elementid) { marshalers.put(elementid, new stringargumentmarshaler() ); } … public string getstring(char arg) { args.argumentmarshaler = marshalers .get(arg); try { return null ? “” : (string) .get(); } catch (classcastexception ) { return “”; } } int getint(char arg) { args.argumentmarshaler = marshalers .get(arg); try { return == null ? : (integer) .get(); } catch (exception ) { return ; } } … public class args { … private map<character, argumentmarshaler stringargs = new hashmap<character, argumentmarshaler(); private map<character, argumentmarshaler intargs = new hashmap<character, argumentmarshaler(); private map<character, argumentmarshaler marshalers = new hashmap<character, argumentmarshaler(); … seguidamente, dispuse línea los tres métodos parse que servían para mucho: private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(); string elementtail = element.substring(); validateschemaelementid(elementid); (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentmarshaler()); else (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( “argument: % has invalid format: %.”, elementid, elementtail), ); } } momento ver estructura completa. listado - muestra clase args actual. listado - args.java (tras primera refactorización) package com.objectmentor.utilities.getopts; import java.text.parseexception; import java.util.*; public class args { private string schema; string[] args; private boolean valid = true; private set<character unexpectedarguments = new treeset<character(); private map<character, argumentmarshaler marshalers = new hashmap<character, argumentmarshaler(); private set<character argsfound = new hashset<character(); private int currentargument; private char errorargumentid = ‘\’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.; private enum errorcode { , missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { (schema.length() == && args.length == ) return true; parseschema(); try { parsearguments(); } catch (argsexception ) { } return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { (element.length() ) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(); string elementtail = element.substring(); validateschemaelementid(elementid); (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentwarshaler()); else (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( “argument: % has invalid format: %.”, elementid, elementtail), ); } } private void validateschemaelementid(char elementid) throws parseexception { (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “ args format: ” + schema, ); } } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == ; } private boolean isintegerschemaelement(string elementtail) { return elementtail.equals(“#”); } private boolean parsearguments() throws argsexception { for (currentargument=; currentargument<args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) throws argsexception { (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int = ; < arg.length(); ++) parseelement(arg.charat()); } private void parseelement(char argchar) throws argsexception { (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = errorcode.unexpected_argument; valid = false; } } private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); try { ( instanceof booleanargumentmarshaler) setbooleanarg(); else ( instanceof stringargumentmarshaler) setstringarg(); else ( instanceof integerargumentmarshaler) setintarg(); else return false; } catch (argsexception ) { valid = false; errorargumentid = argchar; throw ; } return true; } private void setintarg(argumentmarshaler ) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; .set(parameter); } catch (arrayindexoutofboundsexception ) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception ) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw ; } } private void setstringarg(argumentmarshaler ) throws argsexception { currentargument++; try { .set (args[currentargument]); } catch (arrayindexoutofboundsexception ) { errorcode = errorcode.missing_string; throw new argsexception(); } } private void setbooleanarg(argumentmarshaler ) { try { .set(“true”); } catch (argsexception ) { } } public int cardinality() { return argsfound.size(); } public string usage() { (schema.length() ) return = “-[” + schema + “]”; else return “”; } public string errormessage() throws exception { switch (errorcode) { case : throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%.”, errorargumentid); case invalid_integer: return string.format(“argument -% expects integer but was ‘%’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%.”, errorargumentid); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument() -”); for {char : unexpectedarguments) { message.append(); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { args.argumentmarshaler = marshalers.get(arg); boolean = false; try { = != null && (boolean) .get(); } catch (classcastexception ) { = false; } return ; } public string getstring(char arg) { args.argumentmarshaler = marshalers.get (arg); try { return == null ? “” : (string) .get(); } catch (classcastexception ) { return “”; } } int getint(char arg) { args.argumentmarshaler = marshalers.get(arg); try { return == null ? : (integer) .get(); } catch (exception ) { return ; } } public boolean has(char arg) { return argsfound.contains(arg); } public boolean isvalid() { return valid; } private class argsexception extends exception { } private abstract class argumentmarshaler { public abstract void set(string ) throws argsexception; public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(string ) { booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(string ) { stringvalue = ; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = ; public void set(string ) throws argsexception { try { intvalue = integer.parseint(); } catch (numberformatexception ) { throw new argsexception(); } } public object get() { return intvalue; } } } tras todo este esfuerzo, tanto decepcionante. estructura mejorado pero todavía hay demasiadas variables parte superior; mantiene terrible caso tipos setargument ; todas las funciones set . sin mencionar procesamiento errores. todavía nos queda mucho trabajo por hacer. intención eliminar caso tipos setargument [] que sólo incluya una invocación argumentmarshaler.set . para ello, debo desplazar setintarg , setstringarg setbooleanarg las correspondientes variantes argumentmarshaler . pero hay problema. fija atentamente setintarg , comprobará que usa dos variables instancia: args currentarg . para desplazar setintarg hasta booleanargumentmarshaler , tengo que pasar args currentargs como argumentos función. muy desagradable []. resultaría más indicado pasar argumento dos. afortunadamente, solución sencilla. podemos convertir matriz args list pasar iterator las funciones set . para siguiente cambio necesité diez pasos, superar todas las pruebas tras cada uno. pero sólo mostraremos resultado. debería determinar mayoría estos pequeños pasos. public class args { private string schema; private string[] args; private boolean valid = true; private set<character unexpectedarguments = new treeset<character(); private map<character, argumentmarshaler marshalers = new hashmap<character, argumentmarshaler(); private set<character argsfound = new hashset<character(); private iterator<string currentargument; private char errorargumentid = ‘\’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.; private list<string argslist; enum errorcode { , missing_string, missing_integer, invalid_integer, unexpected_argument } public args(string schema. string[] args) throws parseexception { this.schema = schema; argslist = arrays.aslist(args); valid = parse(); } private boolean parse() throws parseexception { (schema.length() == && argslist.size() == ) return true; parseschema(); try { parsearguments(); } catch (argsexception ) { } return valid; } … private boolean parsearguments() throws argsexception { for (currentargument = argslist.iterator(); currentargument. hasnext() ;) { string arg = currentargument. next() ; parseargument(arg); } return true; } … private void setintarg(argumentmarshaler ) throws argsexception { string parameter = null; try { parameter = currentargument. next() ; .set(parameter); } catch ( nosuchelementexception ) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception ) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw ; } } private void setstringarg(argumentmarshaler ) throws argsexception { try { .set (currentargument. next() ); } catch ( nosuchelementexception ) { errorcode = errorcode.missing_string; throw new argsexception(); } } pequeños cambios que conservan funcionamiento las pruebas. ahora podemos empezar desplazar las funciones set las correspondientes variantes. primero, debemos realizar siguiente cambio setargument : private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); ( == null) return false; try { ( instanceof booleanargumentmarshaler) setbooleanarg(); else ( instanceof stringargumentmarshaler) setstringarg(); else ( instanceof integerargumentmarshaler) setintarg(); else return false; } catch (argsexception ) { valid = false; errorargumentid = argchar; throw ; } return true; } cambio importante que queremos eliminar totalmente cadena -else . por tanto, debemos excluir condición error. podemos empezar desplazar las funciones set . función setbooleanarg trivial, modo que prepararemos primer lugar. objetivo cambiar función setbooleanarg para redirigirla booleanargumentmarshaler . private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); ( == null) return false; try { ( instanceof booleanargumentmarshaler) setbooleanarg(, currentargument ); else ( instanceof stringargumentmarshaler) setstringarg(); else ( instanceof integerargumentmarshaler) setintarg(); } catch (argsexception ) { valid = false; errorargumentid = argchar; throw ; } true; } --- private void setbooleanarg (argumentmarshaler , iterator<string currentargument) throws argsexception { try { .set(“true”); catch (argsexception ) { } } ¿ acabamos incluir procesamiento excepciones? añadir elementos para después excluirlos habitual los procesos refactorización. los pasos reducidos necesidad que las pruebas sigan siendo correctas implican que los elementos cambien posición. refactorización como resolver cubo rubik. necesitan muchos pasos pequeños para lograr objetivo mayor. cada paso habilita siguiente. preguntará por qué pasamos iterator setbooleanarg necesita. pues porque setintarg setstringarg . como objetivo implementar las tres funciones través método abstracto argumentmarshaller , necesario pasarlo setbooleanarg . ahora setbooleanarg sirve nada. hubiera una función set argumentmarshaler , podríamos invocarla directamente. momento crear dicha función. primer paso consiste añadir nuevo método abstracto argumentmarshaler . private abstract class argumentmarshaler { public abstract void set(iterator<string currentargument) throws argsexception; public abstract void set (string ) throws argsexception; public abstract object get(); } evidentemente, esto afecta todas las variantes, modo que implementamos nuevo método cada una. private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(iterator<string currentargument) throws argsexception { booleanvalue = true; } public void set(string ) { = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(iterator<string currentargument) throws argsexception { } public void set(string ) { stringvalue = ; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = ; public void set(iterator<string currentargument) throws argsexception { } public void set(string ) throws argsexception { try { intvalue = integer.parseint(); } catch (numberformatexception ) { throw new argsexception(); } } public object get() { return intvalue; } } ahora podemos eliminar setbooleanarg : private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); ( == null) return false; try { ( instanceof booleanargumentmarshaler) .set (currentargument); else ( instanceof stringargumentmarshaler) setstringarg(); else ( instanceof integerargumentmarshaler) setintarg(); } catch (argsexception ) { valid = false; errorargumentid = argchar; throw ; } return true; } las pruebas siguen siendo satisfactorias función set implementa boolean argumentmarshaler . podemos repetir operación con las cadenas los enteros. private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); ( == null) return false; try { ( instanceof booleanargumentmarshaler) .set(currentargument); else ( instanceof stringargumentmarshaler) .set(currentargument); else ( instanceof integerargumentmarshaler) .set(currentargument); } catch (argsexception ) { valid = false; errorargumentid = argchar; throw ; } return true; } --- private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(iterator<string currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception ) { errorcode = errorcode.missing_string; throw new argsexception(); } } public void set(string ){ } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { int intvalue = ; public void set(iterator<string currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); set(parameter); } catch (nosuchelementexception ) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception ) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw ; } } public void set(string ) throws argsexception { try { intvalue = integer.parseint(); } catch (numberformatexception ) { throw new argsexception(); } } public object get() { return intvalue; } } golpe gracia: elimina caso tipos. private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); ( == null) return false; try { .set(currentargument); return true; } catch (argsexception ) { valid = false; errorargumentid = argchar; throw ; } } podemos deshacernos las funciones integerargumentmarshaler limpiar resto. private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = public void set (iterator<string currentargument) throws argsexception { string parameter = null; try { = currentargument.next(); intvalue = integer.parseint (parameter); } catch (nosuchelementexception ) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( numberformatexception ) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } public object get() { return intvalue; } } también podemos convertir argumentmarshaler una interfaz. private interface argumentmarshaler { void set (iterator<string currentargument) throws argsexception; object get(); } veamos ahora sencillo que resulta añadir nuevo tipo argumento estructura. apenas necesitaremos cambios los que apliquemos tendrán que ser aislados. primer lugar, añadimos nuevo caso prueba para comprobar que argumento double funciona correctamente: public void testsimpledoublepresent() throws exception { args args = new args(“##”, new string[] {“-”,“.”}); asserttrue(args.isvalid()); assertequals(, args.cardinality()); asserttrue(args.has(‘’)); assertequals(., args.getdouble(‘’), .); } limpiamos código análisis esquemas añadimos detección ## para tipo argumento double . private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(); string elementtail = element.substring(); validateschemaelementid(elementid); (elementtail. length() == ) marshalers.put(elementid, new booleanargumentmarshaler()); else (elementtail. equals(“*”) ) marshalers.put(elementid, new stringargumentmarshaler()); else (elementtail. equals(“#”) ) marshalers.put(elementid, new integerargumentmarshaler()); else (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); throw new parseexception(string.format( “argument: % has invalid format: %.”, elementid, elementtail), ); } seguidamente, creamos clase doubleargumentmarshaler . private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = ; public void set(iterator<string currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception ) { errorcode = errorcode.missing_double; throw new argsexception(); } catch (numberformatexception ) { errorparameter = parameter; errorcode = errorcode.invalid_double; throw new argsexception(); } } public object get() { return doublevalue; } } esto nos obliga añadir nuevo código error ( errorcode ). private enum errorcode { , missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } necesitamos una función getdouble . public double getdouble(char arg) { args.argumentmarshaler = marshalers.get(arg); try { return = null ? : (double) .get(); } catch (exception ) { return .; } } todas las pruebas son correctas. sido sencillo. continuación comprobamos que procesamiento errores funciona correctamente. siguiente caso prueba comprueba que declare error proporciona cadena que puede analizar argumento ##. public void testinvaliddouble() throws exception { args args = new args(“##”, new string[] {“-”, “forty two”}); assertfalse(args.isvalid()); assertequals(, args.cardinality()); assertfalse(args.has(‘’)); assertequals(, args.getint(‘’)); assertequals(“argument - expects double but was ‘forty two’.”, args.errormessage()); } --- public string errormessage() throws exception { switch (errorcode) { case : throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%.”, errorargumentid); case invalid_integer: return string.format(“argument -% expects integer but was ‘%’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%.”, errorargumentid); case invalid_double: return string.format(“argument -% expects double but was ‘%’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%”, errorargumentid); } return “”; } las pruebas son satisfactorias. siguiente prueba garantiza que detecte correctamente ausencia argumento double . public void testmissingdouble() throws exception { args args = new args(“##”, new string[]{"-"}); assertfalse (args.isvalid()); assertequals(, args.cardinality()); assertfalse(args.has(‘’)); assertequals(., args.getdouble(‘’), .); assertequals(“could not find double parameter for -.”, args.errormessage()); } correcto. incluimos para que ejemplo resulte más completo. código excepciones atractivo pertenece realmente args . también generamos parseexception , que nos pertenece. por ello, combinamos todas las excepciones una única clase argsexception incluimos propio módulo. public class argsexception extends exception { private char errorargumentid = ‘\’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.; public argsexception() {} public argsexception(string message) { super(message); } public enum errorcode { , missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } } … public class args { … private char errorargumentid = ‘\’; private string errorparameter = “tilt”; private argsexception .errorcode errorcode = argsexception .errorcode.; private list<string argslist; public args(string schema, string[] args) throws argsexception { this.schema = schema; argslist = arrays.aslist(args); valid = parse(); } private boolean parse() throws argsexception { (schema.length() == && argslist.size() == ) return true; parseschema(); try { parsearguments(); } catch ( argsexception ) { } return valid; } private boolean parseschema() throws argsexception { … } private void parseschemaelement(string element) throws argsexception { … else throw new argsexception ( string.format(“argument: % has invalid format: %.”, elementid, elementtail)); } void validateschemaelementid(char elementid) throws argsexception { (!character.isletter(elementid)) { throw new argsexception ( “bad character:” + elementid + “ args format: ” + schema); } } … private void parseelement(char argchar) throws argsexception { (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = argsexception .errorcode.unexpected_argument; valid = false; } } … private class stringargumentmarshaler implements argumentmarshaler { private string stringvalue = “”; public void set(iterator<string currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception ) { errorcode = argsexception .errorcode.missing_string; throw new argsexception(); } } public object get() { return stringvalue; } } private class integerargumentmarshaler implements argumentmarshaler { private int intvalue = ; public void set (iterator<string currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); intvalue = integer.parseint(parameter); } catch (nosuchelementexception ) { errorcode = argsexception.errorcode.missing_integer; throw new argsexception (); } catch (numberformatexception ) { errorparameter = parameter; errorcode = argsexception .errorcode.invalid_integer; throw new argsexception (); } } public object get() { return intvalue; } } private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = ; public void set(iterator<string currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception ) { errorcode = argsexception .errorcode.missing_double; throw new argsexception(); } catch (numberformatexception ) { errorparameter = parameter; errorcode = argsexception .errorcode.invalid_double; throw new argsexception); } } public object get() { return doublevalue; } } } muy bien. ahora, args solamente genera argsexception . desplazar argsexception módulo propio, podemos añadir dicho módulo gran parte del código error extraerlo del módulo args . una posición natural evidente para incluir todo código nos permitirá limpiar posteriormente módulo args . hemos separado código excepciones error del módulo args (véanse los listados del - -). para ello realizamos una serie pasos mínimos las pruebas fueron satisfactorias entre todos ellos. listado - argstest.java. package com.objectmentor.utilities.args; import junit.framework.testcase; class argstest extends testcase { public void testcreatewithnoschemaorarguments() throws exception { args args = new args(“”, new string[]); assertequals(, args.cardinality()); } public void testwithnoschemabutwithoneargument() throws exception { try { new args(“”, new string[]{“-”}); fail(); } catch (argsexception ) { assertequals(argsexception.errorcode.unexpected_argument, .geterrorcode()); assertequals(‘’, .geterrorargumentid()); } } public void testwithnoschemabutwithmultiplearguments() throws exception { try { new args(“”, new string[]{“-”, “-”}); fail(); } catch (argsexception ) { assertequals(argsexception.errorcode.unexpected_argument, .geterrorcode()); assertequals(‘’, .geterrorargumentid()); } } public void testnonletterschema() throws exception { try { new args(“*”, new string[]{}); fail(“args constructor should have thrown exception”); } catch (argsexception ) { assertequals(argsexception.errorcode.invalid_argument_name, .geterrorcode()); assertequals(‘*’, .geterrorargumentid()); } } public void testinvalidargumentformat() throws exception { try { new args(“~”, new string[]{}); fail(“args constructor should have throws exception”); } catch (argsexception ) { assertequals(argsexception.errorcode.invalid_format, .geterrorcode()); assertequals(‘’, .geterrorargumentid()); } } public void testsimplebooleanpresent() throws exception { args args = new args(“”, new string []{“-”}); assertequals(, args.cardinality()); assertequals(true, args.getboolean(‘’)); } public void testsimplestringpresent() throws exception { args args = new args(“*”, new string[]{“-”, “param”}); assertequals(, args.cardinality()); asserttrue(args.has(‘’)); assertequals(“param”, args.getstring(‘’)); } public void testmissingstringargument() throws exception { try { new args(“*”, new string[]{"-"}); fail(); } catch (argsexception ) { assertequals(argsexception.errorcode.missing_string, .geterrorcode()); assertequals(‘’, .geterrorargumentid()); } } public void testspacesinformat() throws exception { args args = new args(“, ”, new string[]{“-”}); assertequals(, args.cardinality()); asserttrue(args.has(‘’)); asserttrue(args.has(‘’)); } public void testsimpleintpresent() throws exception { args args = new args(“#”, new string[]{“-”, “”}); assertequals(, args.cardinality()); asserttrue(args.has(‘’)); assertequals(, args.getint(‘’)); } public void testinvalidinteger() throws exception { try { new args(“#”, new string[] {“-”, “forty two”}); fail(); } catch (argsexception ) { assertequals(argsexception.errorcode.invalid_integer, .geterrorcode()); assertequals(‘’, .geterrorargumentid()); assertequals(“forty two”, .geterrorparameter()); } } public void testmissinginteger() throws exception { try { new args(“#”, new string[]{“-”}); fail(); } catch (argsexception ) { assertequals(argsexception.errorcode.missing_integer, .geterrorcode()); assertequals(‘’, .geterrorargumentid()); } } void testsimpledoublepresent() throws exception { args args = new args(“##”, new string[](“-”, “.”}); assertequals(, args.cardinality()); asserttrue(args.has(‘’)); assertequals(., args.getdouble(‘’), .); } public void testinvaliddouble() throws exception { try { new args(“##”, new string []{“-”, “forty two”}); fail(); } catch (argsexception ) { assertequals(argsexception.errorcode.invalid_double, .geterrorcode()); assertequals(‘’, .geterrorargumentid()); assertequals(“forty two”, .geterrorparameter()); } } public void testmissingdouble() throws exception { try { new args(“##”, new string[]{“-”}); fail(); } catch (argsexception ) { assertequals(argsexception.errorcode.missing_double, .geterrorcode()); assertequals(‘’, .geterrorargumentid()); } } } listado - argsexceptiontest.java. public class argsexceptiontest extends testcase { public void testunexpectedmessage() throws exception { argsexception = new argsexception(argsexception.errorcode.unexpected_argument, ‘’, null); assertequals(“argument - unexpected.”, .errormessage()); } public void testmissingstringmessage() throws exception { argsexception = new argsexception(argsexception.errorcode.missing_string, ‘’, null); assertequals(“could not find string parameter for –.”, .errormessage()); } public void testinvalidintegermessage() throws exception { argsexception = new argsexception(argsexception.errorcode.invalid_integer, ‘’, “forty two”); assertequals(“argument – expects integer but was ‘forty two’.”, .errormessage()); } public void testmissingintegermessage() throws exception { argsexception = new argsexception(argsexception.errorcode.missing_integer, ‘’, null); assertequals(“could not find integer parameter for -.”, .errormessage()); } public void testinvaliddoublemessage() throws exception { argsexception = new argsexception(argsexception.errorcode.invalid_double, ‘’, “forty two”); assertequals(“argument - expects double but was ‘forty two’.”, .errormessage()); } public void testmissingdoublemessage() throws exception { argsexception = new argsexception(argsexception.errorcode.missing_double, ‘’, null); assertequals(“could not find double parameter for -.”, .errormessage()); } } listado - argsexception.java. public class argsexception extends exception { private char errorargumentid = ‘\’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.; public argsexception() {} public argsexception(string message) {super(message);} public argsexception(errorcode errorcode) { this.errorcode = errorcode; } public argsexception(errorcode errorcode, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; } public argsexception(errorcode errorcode, char errorargumentid, string errorparameter) { this.errorcode = errorcode; .errorparameter = errorparameter; this.errorargumentid = errorargumentid; } public char geterrorargumentid() { return errorargumentid; } public void seterrorargumentid(char errorargumentid) { this.errorargumentid = errorargumentid; } public string geterrorparameter() { return errorparameter; } public void seterrorparameter(string errorparameter) { this.errorparameter = errorparameter; } public errorcode geterrorcode() { return errorcode; } public void seterrorcode(errorcode errorcode) { this.errorcode = errorcode; } public string errormessage() throws exception { switch (errorcode) { case : throw new exception(“tilt: should not get here.”); case unexpected_argument: return string.format(“argument -% unexpected.”, errorargumentid); case missing_string: return string.format(“could not find string parameter for -%.”, errorargumentid); case invalid_integer: return string.format(“argument -% expects integer but was ‘%’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%.”, errorargumentid); case invalid_double: return string.format(“argument -% expects double but was ‘%’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%.”, errorargumentid); } return “”; } public enum errorcode { , invalid_format, unexpected_argument, invalid_argument_name, , missing_integer, invalid_integer, missing_double, invalid_double} } listado - args.java. public class args { private string schema; private map<character, argumentmarshaler marshalers = new hashmap<character, argumentmarshaler(); private set<character argsfound = new hashset<character(); private iterator<string currentargument; private list<string argslist; public args(string schema, string[] args) throws argsexception { this.schema = schema; argslist = arrays.aslist(args); parse(); } private void parse() throws argsexception { parseschema(); parsearguments(); } private boolean parseschema() throws argsexception { for (string element : schema.split(“,”)) { (element.length() ) { parseschemaelement(element.trim()); } } return true; } private void parseschemaelement(string element) throws argsexception { char elementid = element.charat(); string elementtail = element.substring(); validateschemaelementid(elementid); (elementtail.length() == ) marshalers.put(elementid, new booleanargumentmarshaler()); else (elementtail.equals(“*”)) marshalers.put(elementid, new stringargumentmarshaler()); else (elementtail.equals(“#”)) marshalers.put(elementid, new integerargumentmarshaler()); else (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); else throw new argsexception(argsexception.errorcode.invalid_format, elementid, elementtail); } void validateschemaelementid(char elementid) throws argsexception { (!character.isletter(elementid)) { throw new argsexception(argsexception.errorcode.invalid_argument_name, elementid, null); } } private void parsearguments() throws argsexception { for (currentargument = argslist.iterator(); currentargument.hasnext();) { string arg = currentargument.next(); parseargument(arg); } } private void parseargument(string arg) throws argsexception { (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int = ; < arg.length(); ++) parseelement(arg.charat()); } private void parseelement(char argchar) throws argsexception { (setargument(argchar)) argsfound.add(argchar); else { throw new argsexception(argsexception.errorcode.unexpected_argument, argchar, null); } } private boolean setargument(char argchar) throws argsexception { argumentmarshaler = marshalers.get(argchar); ( == null) return false; try { .set(currentargument); return true; } catch (argsexception ) { .seterrorargumentid(argchar); throw ; } } public int cardinality() { return argsfound.size(); } public string usage() { (schema.length() ) return "-[" + schema + “]”; return “”; } public boolean getboolean(char arg) { argumentmarshaler = marshalers.get(arg); boolean = false; try { = != null && (boolean) .get(); } catch (classcastexception ) { = false; } return ; } public string getstring(char arg) { argumentmarshaler = marshalers.get(arg); try { return == null ? “” : (string) .get(); } catch (classcastexception ) { return “”; } } public int getint(char arg) { argumentmarshaler = marshalers.get(arg); try { return == null ? : (integer) .get(); } catch (exception ) { return ; } } public double getdouble(char arg) { argumentmarshaler = marshalers.get(arg); try { return == null ? : (double) .get(); } catch (exception ) { return .; } } public boolean has(char arg) { return argsfound.contains(arg); } } mayoría los cambios realizados clase args han sido eliminaciones. gran parte del código extrajo args añadió argsexception . perfecto. también cambiamos todos los elementos argumentmarshaller sus propios archivos. mejor todavía. diseño software correcto basa gran parte las particiones, crear zonas adecuadas para incluir distintos tipos código. esta separación hace que código sea más fácil entender mantener. especialmente interesante método errormessage argsexception . incumple claramente srp incluir formato mensajes error args . args debe centrarse procesamiento argumentos, formato los mensajes error. sin embargo, ¿realmente tiene sentido incluir código formato mensajes error argsexception ? francamente compromiso. los usuarios que deseen los mensajes error proporcionados por argsexception tendrán que crear los suyos propios, pero utilidad mensajes error preparados evidente. debería haberse dado cuenta distancia recorrida con respecto solución mostrada inicio del capítulo. las transformaciones finales puede examinarlas por cuenta. conclusión basta con que código funcione. código que funciona suele ser incorrecto. los programadores que conforman con código funcional comportan forma profesional. puede que teman que tienen tiempo para mejorar estructura diseño del código, pero discrepo. hay nada que afecte más negativamente proyecto desarrollo que código incorrecto. los plazos incorrectos pueden rehacer los requisitos equivocados pueden volver definir. dinámica incorrecta equipo puede reparar pero código incorrecto corrompe convierte una carga que arrastra equipo completo. visto equipos dominados por desastre que han generado que han dominado destino. evidentemente, código incorrecto puede limpiar pero resulta muy costoso. cuando código corrompe los módulos insinúan unos otros generan multitud dependencias ocultas entrelazadas. localización división dependencias antiguas una tarea larga complicada. por otra parte, resulta relativamente sencillo mantener código limpio. comete error módulo, más fácil limpiarlo directamente. mejor todavía, error hace cinco minutos, muy fácil limpiarlo ahora. por tanto, solución consiste mantener código limpio sencillo siempre que pueda dejar que llegue corromperse. aspectos internos junit una las estructuras java más conocidas. concepción sencilla, definición precisa documentación elegante. ¿ código? este capítulo analizaremos ejemplo extraído estructura junit. estructura junit junit tenido muchos autores, comenzando por kent beck eric gamma vuelo atlanta. kent quería aprender java eric quería saber más sobre estructura pruebas smalltalk kent. “¿hay algo más natural que fanáticos enciendan sus portátiles empiecen escribir código?” [] tras tres horas trabajo altura, habían creado los fundamentos junit. módulo que analizaremos inteligente fragmento código que permite identificar errores comparación cadenas. nombre del módulo comparisoncompactor . dadas dos cadenas diferentes, como abcde abxde , muestra diferencia entre ambas generando una cadena como <… []… . podríamos explicarlo más, pero los casos prueba son mejores. fíjese listado - para comprender los requisitos este módulo. analice estructura las pruebas. ¿podrían ser más simples más evidentes? listado - comparisoncompactortest.java. package junit.tests.framework; import junit.framework.comparisoncompactor; import junit.framework.testcase; public class comparisoncompactortest extends testcase { public void testmessage() { string failure= new comparisoncompactor(, “”, “”).compact(“”); asserttrue(“ expected:<[] but was:<[]”.equals(failure)); } public void teststartsame() { string failure= new comparisoncompactor(, “”, “”).compact(null); assertequals(“expected:<[] but was:<[]”, failure); } public void testendsame() { string failure= new comparisoncompactor(, “”, “”).compact(null); assertequals(“expected:<[] but was:<[]”, failure); } public void testsame() { string failure= new comparisoncompactor(, “”, “”).compact(null); assertequals(“expected:< but was:<”, failure); } public void testnocontextstartandendsame() { string failure= new comparisoncompactor(, “abc”, “adc”).compact(null); assertequals(“expected:<…[]… but was:<…[]…”, failure); } void teststartandendcontext() { string failure= new comparisoncompactor(, “abc”, “adc”).compact(null); assertequals(“expected:<[] but was:<[]”, failure); } public void teststartandendcontextwithellipses() { string failure= new comparisoncompactor(, “abcde”, “abfde”).compact(null); assertequals(“expected:<…[]… but was:<…[]…”, failure); } public void testcomparisonerrorstartsamecomplete() { string failure= new comparisoncompactor(, “”, “abc”).compact(null); assertequals(“expected:<[] but was:<[]”, failure); } public void testcomparisonerrorendsamecomplete() { string failure= new comparisoncompactor(, “”, “abc”).compact(null); assertequals(“expected:<[]… but was:<[]…”, failure); } public void testcomparisonerrorendsamecompletecontext() { string failure= new comparisoncompactor(, “”, “abc”).compact(null); assertequals(“expected:<[] but was:<[]”, failure); } public void testcomparisonerroroverlapingmatches() { string failure= new comparisoncompactor(, “abc”, “abbc”).compact(null); assertequals(“expected:<…[]… but was:<…[]…”, failure); } public void testcomparisonerroroverlapingmatchescontext() { string failure= new comparisoncompactor(, “abc”, “abbc”).compact(null); assertequals(“expected:<[] but was:<[]”, failure); } public void testcomparisonerroroverlapingmatches() { string failure= new comparisoncompactor(, “abcdde”, “abcde”).compact(null); assertequals(“expected:<…[]… but was:<…[]…”, failure); } public void testcomparisonerroroverlapingmatches() { string failure= new comparisoncompactor(, “abcdde”, “abcde”).compact(null); assertequals(“expected:<…[] but was:<…[]”, failure); } public void testcomparisonerrorwithactualnull() { string failure= new comparisoncompactor(, “”, null).compact(null); assertequals(“expected:< but was:<null”, failure); } public void testcomparisonerrorwithactualnullcontext() { string failure= new comparisoncompactor(, “”, null).compact(null); (“expected:< but was:<null”, failure); } public void testcomparisonerrorwithexpectednull() { string failure= new comparisoncompactor(, null, “”).compact(null); assertequals(“expected:<null but was:<”, failure); } public void testcomparisonerrorwithexpectednullcontext() { string failure= new comparisoncompactor(, null, “”).compact(null); assertequals(“expected:<null but was:<”, failure); } public void testbug() { string failure= new comparisoncompactor(, “&”, “”).compact(null); assertequals(“expected:<[&] but was:<[]”, failure); } } realicé análisis alcance código comparisoncompactor con estas pruebas. código cubre por . cada línea, cada instrucción cada bucle for ejecuta con las pruebas. este modo que código funciona sus autores merecen mayor los respetos. código comparisoncompactor reproduce listado -. examínelo. creo que encontrará bien distribuido, razonablemente expresivo estructuralmente sencillo. cuando termine, diseccionaremos. listado - comparisoncompactor.java (original). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int fcontextlength; private string fexpected; private string factual; private int fprefix; private int fsuffix; public comparisoncompactor(int contextlength, string expected, string actual) { fcontextlength = contextlength; fexpected = expected; = actual; } public string compact(string message) { (fexpected == null || factual == null || arestringsequal()) return assert.format(message, fexpected, factual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(fexpected); string actual = compactstring(factual); return assert.format(message, expected, actual); } private string compactstring(string source) { string result = delta_start + source.substring(fprefix, source.length() - fsuffix + ) + delta_end; (fprefix ) result = computecommonprefix() + result; (fsuffix ) result = result + computecommonsuffix(); return result; } private void findcommonprefix() { fprefix = ; int end = math.min(fexpected.length(), factual.length()); for (; fprefix < end; fprefix++) { (fexpected.charat(fprefix) != factual.charat(fprefix)) break; } } private void findcommonsuffix() { int expectedsuffix = fexpected.length() - ; int actualsuffix = factual.length() - ; for (; actualsuffix = fprefix && expectedsuffix = fprefix; actualsuffix--, expectedsuffix--) { (fexpected.charat(expectedsuffix) != factual.charat(actualsuffix)) break; } fsuffix = fexpected.length() - expectedsuffix; } private string computecommonprefix() { return (fprefix fcontextlength ? ellipsis : “”) + fexpected.substring(math.max(, fprefix - fcontextlength), fprefix); } private string computecommonsuffix() { int end = math.min(fexpected.length() - fsuffix + + fcontextlength, fexpected.length()); fexpected.substring(fexpected.length() - fsuffix + , end) + (fexpected.length() - fsuffix + < fexpected.length() - fcontextlength ? ellipsis : “”); } private boolean arestringsequal() { return fexpected.equals(factual); } } puede que tenga varias quejas sobre módulo. incluye expresiones extensas extraños elementos + . pero general, está bastante bien. después todo, podría haber sido como listado -. listado - comparisoncompator.java (defactorizado) package junit.framework; public class comparisoncompactor { private int ctxt; private string ; private string ; private int pfx; private int sfx; public comparisoncompactor(int ctxt, string , string ) { this.ctxt = ctxt; this. = ; this. = ; } public string compact(string msg) { ( == null || == null || .equals()) return assert.format(msg, , ); pfx = ; for (; pfx < math.min(.length(), .length()); pfx++) { (.charat(pfx) != .charat(pfx)) break; } int sfx = .length() - ; int sfx = .length() - ; for (; sfx = pfx && sfx = pfx; sfx--, sfx--) { (.charat(sfx) != .charat(sfx)) break; } sfx = .length() - sfx; string cmp = compactstring(); string cmp = compactstring(); return assert.format(msg, cmp, cmp); } private string compactstring(string ) { string result = “[” + .substring(pfx, .length() - sfx + ) + “]”; (pfx ) result = (pfx ctxt ? “…” : “”) + .substring(math.max(, pfx - ctxt), pfx) + result; (sfx ) { int end = math.min(.length() - sfx + + ctxt, .length()); result = result + (.substring(.length() - sfx + , end) + (.length() - sfx + < .length() - ctxt ? “…” : “”)); } return result; } } aunque los autores hicieron buen trabajo con este módulo, regla del boy scout [] muestra que podrían haberlo dejado más limpio que encontró. ¿cómo podemos mejorar código original del listado -? primero que necesitamos prefijo las variables miembro []. los entornos actuales hacen que este tipo código ámbito sea redundante, por que eliminaremos todas las . private int contextlength; private string expected; private string actual; private int prefix; private int suffix; tras ello, tenemos una condicional sin encapsular inicio función compact []. public string compact(string message) { (expected == null || actual == null || arestringsequal()) return assert.format(message, expected, actual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } necesario encapsular esta condicional para que nuestra intención sea más clara. por tanto, extraemos método que explique. public string compact(string message) { ( shouldnotcompact() ) return assert.format(message, expected, actual); (); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } private boolean shouldnotcompact() { return expected == null || actual == null || arestringsequal(); } función compact , this.expected this.actual son demasiado relevantes. sucede cambiar nombre fexpected por expected . ¿por qué esta función tiene variables con los mismos nombres que las variables miembro? ¿ representan cosas diferentes?[]. los nombres deben ser exclusivos. string compactexpected = compactstring( expected ); string compactactual = compactstring( actual ); los negativos son más difíciles entender que los positivos []. por ello, invertimos esa instrucción para cambiar sentido condicional. public string compact(string message) { ( canbecompacted() ) { findcommonprefix(); findcommonsuffix(); string compactexpected = compactstring(expected); string compactactual = compactstring(actual); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private boolean canbecompacted () { return expected != null && actual != null && !arestringsequal(); } nombre función extraño []. aunque compacta las cadenas, puede que haga canbecompacted devuelve false . asignar nombre compact esta función oculta efecto secundario comprobación errores. además, función devuelve mensaje con formato, sólo las cadenas compactadas. por tanto, nombre función debería ser formatcompactedcomparison . esta forma, lee mejor junto argumento función: string formatcompactedcomparison(string message) { cuerpo instrucción donde realiza verdadera compactación las cadenas. debemos extraerlo como método con nombre compactexpectedandactual . sin embargo, queremos que función formatcompactedcomparison realice todo formato. función compact … sólo debe realizar compactación [], modo que dividimos esta forma: … private string compactexpected; private string compactactual; … public string formatcompactedcomparison(string message) { (canbecompacted()) { compactexpectedandactual(); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private void compactexpectedandactual () { findcommonprefix(); findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } para ello, hemos tenido que ascender compactexpected compactactual variables miembro. gusta forma que las dos últimas líneas nueva función devuelven variables pero las dos primeras hacen. utilizan convenciones coherentes []. debemos cambiar findcommonprefix findcommonsuffix para que devuelvan los valores prefijo sufijo. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonprefix() { int prefix index = ; int end = math.min(expected.length(), actual.length()); for (; prefix index < end; prefix index ++) { (expected.charat(prefix index ) != actual.charat(prefix index )) break; } return prefixindex; } private int findcommonsuffix() { int expectedsuffix = expected.length() - ; int actualsuffix = actual.length() - ; for (; actualsuffix = prefix index && expectedsuffix = prefixindex; actualsuffix--, expectedsuffix--) { (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } también debemos cambiar los nombres las variables miembro para que sean más preciosas [], que fondo son índices. examinar findcommonsuffix vemos una conexión temporal oculta []; depende que prefixindex calcule por findcommonprefix . estas dos funcione invocan forma desordenada, sesión depuración posterior sería complicada. por ello, para mostrar esta combinación temporal, haremos que findcommonsuffix acepte prefixindex como argumento. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix( prefixindex ); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonsuffix( int prefixindex ) { int expectedsuffix = expected.length() - ; int actualsuffix = actual.length() - ; for (; actualsuffix = prefixindex && expectedsuffix = prefixindex; actualsuffix--, expectedsuffix--) { (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } convence del todo. hecho pasar prefixindex como argumento tanto arbitrario []. permite establecer orden pero explica necesidad del mismo. otro programador podría deshacer esta operación que indica ningún momento para qué sirve parámetro. adoptemos enfoque diferente. void compactexpectedandactual() { findcommonprefixandsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private void findcommonprefixandsuffix () { findcommonprefix(); int expectedsuffix = expected.length() - ; int actualsuffix = actual.length() - ; for (; actualsuffix = prefixindex && expectedsuffix = prefixindex; actualsuffix--, expectedsuffix-- ) { (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } suffixindex = expected.length() - expectedsuffix; } private void findcommonprefix() { prefixindex = ; int end = math.min(expected.length(), actual.length()); for (; prefixindex < end; prefixindex++) (expected.charat(prefixindex) != actual.charat(prefixindex)) break; } devolvemos findcommonprefix findcommonsuffix posición original, cambiamos nombre findcommonsuffix por findcommonprefixandsuffix hacemos que invoque findcommonprefix antes hacer nada más. ese modo establece naturaleza temporal ambas funciones forma más evidente que antes. además, muestra mínimo atractivo findcommonprefixandsuffix , que limpiaremos continuación: private void findcommonprefixandsuffix() { findcommonprefix(); int suffixlength = ; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } suffixindex = suffixlength; } private char charfromend(string , int ) { return .charat(.length()-);} private boolean suffixoverlapsprefix(int suffixlength) { actual.length() - suffixlength < prefixlength || expected.length() - suffixlength < prefixlength; } mucho mejor. muestra que suffixindex realidad longitud del sufijo que nombre correcto. mismo sucede con prefixindex , aunque ese caso índice longitud son sinónimos. incluso así, más coherente usar length . problema que variable suffixindex base cero, sino base una verdadera longitud. éste motivo abundancia + computecommonsuffix []. corregimos. listado - puede ver resultado. listado - comparisoncompactor.java (versión intermedia). public class comparisoncompactor { … private int suffixlength ; … private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = ; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } } private char charfromend(string , int ) { return .charat(.length() - - ); } private boolean suffixoverlapsprefix(int suffixlength) { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } … private string compactstring(string source) { string result = delta_start + source.substring(prefixlength, source.length() - suffixlength ) + delta_end; (prefixlength ) result = computecommonprefix() + result; ( suffixlength ) = result + computecommonsuffix(); return result; } … private string computecommonsuffix() { int end = math.min(expected.length() - suffixlength + contextlength, expected.length() ); return expected.substring(expected.length() - suffixlength , end) + (expected.length() - suffixlength < expected.length() - contextlength ? ellipsis : “”); } cambiamos + computecommonsuffix por - charfromend, donde tiene sentido, dos operadores <= suffixoverlapsprefix , totalmente correctos. este modo podemos cambiar nombre suffixindex por suffixlength , que mejora considerablemente legibilidad del código. pero hay problema. comenzar eliminar los + , fijé siguiente línea compactstring : (suffixlength ) búsquela listado -. como ahora suffixlength una unidad menos que antes, debemos cambiar operador por = . pero eso tiene sentido. ahora . significa que tenía sentido antes que seguramente fuera error. bueno, del todo. tras análisis detallado, vemos que ahora instrucción impide que añada sufijo longitud cero. antes realizar cambio, instrucción funcionaba que suffixindex nunca podía ser menos uno. esto cuestiona ambas instrucciones compactstring . parece como pudieran eliminar. por ello, las comentamos ejecutamos las pruebas. satisfactorias. reestructuremos compactstring para eliminar las instrucciones sobrantes simplificar función []. private string compactstring(string source) { return computecommonprefix() + delta_start + source.substring(prefixlength, source.length() - suffixlength) + + computecommonsuffix(); } mucho mejor. ahora vemos que función compactstring simplemente combina los fragmentos. probablemente podríamos limpiar más, pequeñas operaciones, pero lugar desarrollar resto los cambios, mostraremos resultado final listado -. listado - comparisoncompactor.java (versión definitiva). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int contextlength; private string expected; private string actual; private int prefixlength; private int suffixlength; public comparisoncompactor( int contextlength, string expected, string actual ) { this.contextlength = contextlength; this.expected = expected; this.actual = actual; } public string formatcompactedcomparison(string message) { string compactexpected = expected; string compactactual = actual; (shouldbecompacted()) { findcommonprefixandsuffix(); compactexpected = compact(expected); compactactual = compact(actual); } return assert.format(message, compactexpected, compactactual); } private boolean shouldbecompacted() { return !shouldnotbecompacted(); } private boolean shouldnotbecompacted() { return expected == null || == null || expected.equals(actual); } private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = ; for (; !suffixoverlapsprefix(); suffixlength++) { (charfromend(expected, suffixlength) != charfromend(actual, suffixlength) ) break; } } private char charfromend(string , int ) { return .charat(.length() - - ); } private boolean suffixoverlapsprefix() { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } private void findcommonprefix() { prefixlength = ; int end = math.min(expected.length(), actual.length()); for (; prefixlength < end; prefixlength++) (expected.charat(prefixlength) != actual.charat(prefixlength)) break; } private string compact(string ) { return new stringbuilder() .append(startingellipsis()) .append(startingcontext()) .append(delta_start) .append(delta()) .append(delta_end) .append(endingcontext()) .append(endingellipsis()) .tostring(); } private string startingellipsis() { return prefixlength contextlength ? ellipsis : “”; } private string startingcontext() { int contextstart = math.max(, prefixlength - contextlength); int contextend = prefixlength; return expected.substring(contextstart, contextend); } private string delta(string ) { deltastart = prefixlength; int deltaend = .length() - suffixlength; return .substring(deltastart, deltaend); } private string endingcontext() { int contextstart = expected.length() - suffixlength; int contextend = math.min(contextstart + contextlength, expected.length()); return expected.substring(contextstart, contextend); } private string endingellipsis() { return (suffixlength contextlength ? ellipsis : “”); } } bastante atractivo. módulo separa grupo funciones análisis otro grupo funciones síntesis. ordenan topológicamente para que definición cada función aparezca donde realmente usa. primero muestran las funciones análisis después las síntesis. fija atentamente, verá que invertido algunas las decisiones adoptadas inicialmente. por ejemplo, añadido algunos métodos extraídos formatcompactedcomparison modificado sentido expresión shouldnotbecompacted . algo habitual. menudo, cambio refactorización lleva otro que vez lleva deshacer primero. refactorización proceso iterativo ensayo error, inevitablemente converge algo que consideramos digno profesional. conclusión hemos cumplido regla del boy scout. hemos dejado este módulo más limpio como encontramos. que estuviera limpio originalmente, que trabajo sus autores excelente, pero cualquier módulo puede mejorar nuestra responsabilidad dejar código más limpio que encontramos. refactorización serialdate visita http:// , encontrará biblioteca jcommon. interior incluye paquete org.jfree.date , dentro éste, clase serialdate . vamos analizar esta clase. autor serialdate david gilbert. david programador experimentado competente. como veremos, muestra elevado grado profesionalidad disciplina código. que éste respecta, puede calidad. voy despedazarlo. acto malicia, tampoco creo mejor que david con derecho juzgar código. hecho, leyera algún código que creado, seguramente tendría que objetar muchos aspectos del mismo. acto arrogancia. que voy hacer más que una revisión profesional, algo con que todos deberíamos sentirnos cómodos algo que deberíamos agradecer alguien hace. través las críticas como podemos aprender, como hacen médicos, pilotos abogados. nosotros, como programadores, también tenemos que aprender hacerlo. otra cosa más sobre david gilbert: más que buen programador. david tenido valor buena voluntad ofrecer este código público gratuitamente, para que cualquiera pueda usarlo examinarlo. ¡bien hecho! serialdate (véase listado -) una clase que representa una fecha java. ¿para qué necesita una clase que represente una fecha java cuenta con java.util.date java.util.calendar , entre otras? autor creó esta clase como respuesta problema que también padecido. comentario javadoc inicial (línea ) explica. podríamos cuestionar intención, pero también sufrido este problema agradece una clase sobre fechas lugar horas. primero, conseguir que funcione hay varias pruebas unidad clase serialdatetests (véase listado -). todas son satisfactorias. desafortunadamente, rápido examen demuestra que comprueban todos los aspectos []. por ejemplo, realizar una búsqueda usos método monthcodetoquarter (línea ) indica que usa []. por tanto, las pruebas unidad comprueban. por ello, recurrí clover para ver alcance las pruebas unidad. clover indicó que las pruebas sólo ejecutan las instrucciones ejecutables serialdate (aproximadamente por ) []. mapa alcance muestra grandes fragmentos código sin ejecutar desperdigados por clase. objetivo era comprender clase refactorizarla, algo que podía sin una cobertura mayor las pruebas. por ello diseñé propia suite pruebas unidad independientes (véase listado -). fija las pruebas, comprobará que muchas están comentadas, que superaron. representan comportamiento que considero debería incluirse serialdate . por tanto, refactorizar serialdate , intentaré que estas pruebas funcionen. incluso con algunas las pruebas comentadas, informe clover indica que ahora ejecutan ( por ciento) las instrucciones ejecutables. gran resultado que creo que puedo mejorar. las primeras pruebas comentadas (líneas -) son tanto pretenciosas. programa fue diseñado para superar estas pruebas, pero comportamiento parecía evidente []. desconozco por qué creado método testweekdaycodetostring pero que está ahí, parece obvio que debe distinguir entre mayúsculas minúsculas. diseño las pruebas fue sencillo [] más todavía que fueran satisfactorias; simplemente cambié las líneas para usar equalsignorecase . comenté las pruebas las líneas que estaba seguro las abreviaturas tues thurs admitían . las pruebas las líneas superaron, aunque deberían haberlo hecho []. podemos corregirlas, junto las pruebas las líneas , realizamos los siguientes cambios función stringtomonthcode . ((result < ) || (result )) { result = -; for (int = ; < monthnames.length; ++) { (.equalsignorecase(shortmonthnames[])) { result = + ; break; } (.equalsignorecase(monthnames[])) { result = + ; break; } } } prueba comentada línea descubre error método getfollowingdayofweek (línea ). diciembre fue sábado siguiente sábado fue enero . sin embargo, ejecutar , vemos que getfollowingdayofweek devuelve diciembre como siguiente sábado después del diciembre, error evidente [], []. vemos problema línea . error condición límite típico []. debería ser siguiente: (basedow = targetweekday) { conviene destacar que esta función sufrió una reparación anterior. historial cambios (línea ) muestra que corrigieron los errores getpreviousdayofweek , getfollowingdayofweek getnearestdayofweek []. prueba unidad testgetnearestdayofweek (línea ), que prueba método getnearestdayofweek (línea ), inicialmente era tan extensa completa. añadí multitud casos prueba que los iniciales superaban []. puede ver patrón fallos fija los casos prueba comentados. patrón revelador []. muestra que algoritmo falla día más próximo una fecha futura. evidentemente trata algún tipo error condición límite []. patrón alcance las pruebas generado por clover también interesante []. línea nunca ejecuta, que significa que instrucción línea siempre false , pero nos fijamos código, indica que debe ser true . variable adjust siempre negativa puede ser mayor igual , por que algoritmo incorrecto. continuación muestra algoritmo correcto: int delta = targetdow - base.getdayofweek(); int positivedelta = delta + ; int adjust = positivedelta % ; (adjust ) adjust -= ; return serialdate.adddays (adjust, base); por último, las pruebas líneas pueden superar genera illegalargumentexception lugar devolver una cadena error desde weekinmonthtostring relativetostring . con estos cambios, todas las pruebas unidad superan creo que ahora serialdate funciona. llega momento hacer que sea correcta. que sea correcta describiremos serialdate arriba abajo para mejorarla nuestro recorrido. aunque veamos este análisis, ejecutaré todas las pruebas unidad jcommon , incluida prueba unidad mejorada para serialdate , con todos los cambios efectuados. por ello, tenga seguridad que todos los cambios que vea funcionan para jcommon . línea vemos abundantes comentarios sobre información licencia, derechos autor, autores historial cambios. asumo que hay ciertos aspectos legales que mostrar, por que los derechos autor las licencias deben conservarse. por otra parte, historial cambios una rémora década . ahora tenemos herramientas control código fuente que encargan ello. hay que eliminar este historial []. lista importación que comienza línea puede reducir por medio java.text.* java.util.* . [] convence formato html del javadoc (línea ). archivo fuente con más lenguaje parece problema. este comentario tiene cuatro lenguajes: java, español, javadoc html []. con tantos lenguajes hace difícil mantener coherencia. por ejemplo, ubicación las líneas pierde generar javadoc además, ¿quién quiere ver < < código fuente? una estrategia más acertada consiste rodear comentario con <pre para que formato del código fuente conserve javadoc [] . línea declaración clase. ¿por qué asigna nombre serialdate ? ¿qué sentido tiene palabra serial ? ¿ porque clase deriva serializable ? parece improbable. basta adivinanzas. por qué ( menos eso creo) usa palabra serial . clave encuentra las constantes serial_lower_bound serial_upper_bound las líneas . una clave todavía mejor comentario línea . nombre clase serialdate que implementa con número serie, que parece ser número días desde diciembre . esto supone problema. por lado, término «número serie» realmente correcto. puede ser detalle menor pero representación más desplazamiento relativo que número serie. término «número serie» tiene que ver más con marcadores identificación productos que con fechas. por ello, considero especialmente descriptivo []. término más descriptivo sería «ordinal». segundo problema más significativo. nombre serialdate implica una implementación. esta clase abstracta. necesario que implique nada sobre implementación; hecho, aconsejable ocultarla. por ello, creo que nombre encuentra nivel abstracción incorrecto []. opinión, nombre esta clase debería ser simplemente date . desafortunadamente, hay demasiadas clases con nombre date biblioteca java, modo que más adecuado. como esta clase trabaja con días horas, podríamos usar day , pero usa otros muchos puntos. final, opté por daydate como mejor opción. partir ahora, usaremos daydate . recuerde que los listados que leer siguen usando serialdate . entiendo porque daydate hereda comparable serializable . ¿pero monthconstants ? clase monthconstants (véase listado -) una serie constantes finales estáticas que definen los meses. heredar clases con constantes viejo truco que los programadores java usan para evitar expresiones como monthconstants.january , pero una mala idea []. monthconstants debería ser una enumeración. public abstract class daydate implements comparable, serializable { public static enum month { january(), february(), march(), april(), may(), june(), july(), august(), september(), october(), november(), december(); (int index) { this.index = index; } public static month make(int monthindex) { for (month : month.values()) { (.index == monthindex) return ; } throw new illegalargumentexception(“invalid month index ” + monthindex); } public final int index; } cambiar monthconstants por esta enumeración modifica clase daydate todos sus usuarios. tardé una hora realizar todos los cambios. sin embargo, las funciones que antes aceptaban valor int para mes, ahora aceptan enumerador month . esto significa que podemos deshacernos del método isvalidmonthcode (línea ) comprobación errores del código los meses como monthcodetoquarter (línea ) []. tras ello, línea , tenemos serialversionuid . esta variable usa para controlar señalizador. cambiamos, con que todos los elementos daydate escritos con una versión antigua del software serán ilegibles generará invalidclassexception . declara variable serialversionuid , compilador genera una automáticamente será diferente cada vez que modifique módulo. que todos los documentos recomiendan control manual esta variable, pero creo que control automático señalización más seguro []. después todo, prefiero depurar una invalidclassexception que extraño comportamiento que produciría olvido cambiar serialversionuid . por ello, eliminaré variable, menos por ahora [] . creo que comentario línea redundante. los comentarios redundantes sólo sirven para acumular mentiras desinformación []. por ello los eliminaré. los comentarios las líneas hablan sobre números serie, que hemos mencionado antes []. las variables que describen son primera última fecha posible que daydate puede describir. podríamos hacer que fuera más claro []. static final int earliest_date_ordinal = ; // // public static final int latest_date_ordinal = ; // // desconozco por qué earliest_date_ordinal lugar . comentario línea sugiere que tiene que ver con forma representar fechas microsoft excel. hay información mucho más completa una variante daydate : spreadsheetdate (véase listado -). comentario línea describe este problema. problema parece relacionado con implementación spreadsheetdate con daydate . conclusión que earliest_date_ordinal latest_date_ordinal pertenecen daydate deberían cambiarse spreadsheetdate []. hecho, una búsqueda código demuestra que estas variables sólo usan spreadsheetdate . daydate , otras clases estructura jcommon. por tanto, las cambio por spreadsheetdate . las siguientes variables, minimum_year_supported maximum_year_supported (líneas ), constituyen dilema. parece evidente que daydate una clase abstracta que dice nada sobre implementación, debería informarnos año mínimo máximo. nuevo, siento necesidad cambiar las variables spreadsheetdate []. pero una búsqueda rápida los usuarios estas variables muestra que otra clase las utiliza: relativedayofweekrule (véase listado -), vemos dicho uso las líneas , función getdate , donde usan para comprobar que argumento getdate sea año válido. dilema que usuario una clase abstracta necesita información sobre implementación. tendremos que proporcionar esta información sin contaminar daydate . por general, obtendríamos información implementación una instancia una variante. sin embargo, función getdate recibe una instancia daydate , aunque devuelve, que significa que debe crearla alguna parte. solución está las líneas -. instancia daydate crea por medio una estas tres funciones: getpreviousdayofweek , getnearestdayofweek getfollowingdayofweek . nos fijamos daydate , vemos que estas funciones (líneas -) devuelven una fecha creada por adddays (línea ), que invoca createinstance (línea ), que crea spreadsheetdate []. recomendable que las clases base conozcan sus variantes. para corregirlo, debemos usar patrón factoría abstracta [] crear daydatefactory . esta factoría creará las instancias daydate que necesitamos también responderá preguntas sobre implementación, como las fechas máxima mínima. public abstract class daydatefactory { private static daydatefactory factory = new spreadsheetdatefactory(); public static void set instance(daydatefactory factory) { daydatefactory.factory = factory; } protected abstract daydate _makedate(int ordinal); protected abstract daydate _makedate(int day, daydate.month month, int year); protected abstract daydate _makedate(int day, int month, int year); protected abstract daydate _makedate(java.util.date date); protected abstract int _getminimumyear(); protected abstract int _getmaximumyear(); public static daydate makedate(int ordinal) { return factory._makedate(ordinal); } public static daydate makedate(int day, daydate.month month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(int day, int month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(java.util.date date) { return factory._makedate(date); } public static int getminimumyear() { return factory._getminimumyear(); } public static int getmaximumyear() { return factory._getmaximumyear(); } } esta clase factoría sustituye los métodos createinstance por métodos , que mejora ligeramente los nombres []. forma predeterminada spreadsheetdatefactory pero puede cambiar por otra factoría. los métodos estáticos delegados métodos abstractos usan una combinación los patrones instancia única [] , decorador [] factoría abstracta que considero muy útil. spreadsheetdatefactory tiene este aspecto: public class spreadsheetdatefactory extends daydatefactory { public daydate _makedate(int ordinal) { return new spreadsheetdate(ordinal); } public daydate _makedate(int day, daydate.month month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(int day, int month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(date date) { final gregoriancalendar calendar = new gregoriancalendar(); calendar.settime(date); return new spreadsheetdate( calendar.get(calendar.date), daydate.month.make(calendar.get(calendar.month) + ), calendar.get(calendar.year)); } protected int _getminimumyear() { return spreadsheetdate.minimum_year_supported; } protected int _getmaximumyear() { return spreadsheetdate.maximum_year_supported; } } como puede apreciar, hemos enviado las variables minimum_year_supported maximum_year_supported spreadsheetdate , donde pertenecen []. siguiente problema daydate son las constantes días, comenzando línea . deberían ser otra enumeración []. hemos visto este patrón, modo que repetiremos. incluye los listados definitivos. seguidamente, vemos una serie tablas que comienzan last_day_of_month (línea ). primer problema con estas tablas que comentarios que las describen son redundantes []. basta con sus nombres, modo que eliminamos los comentarios. hay motivos para que tabla sea privada [], que existe una función estática lastdayofmonth que proporciona los mismos datos. siguiente tabla, aggregate_days_to_end_of_month , más misteriosa, que usa ninguna parte estructura jcommon [], modo que elimino. mismo sucede con leap_year_aggregate_days_to_end_of_month . siguiente tabla, aggregate_days_to_end_of_preceding_month , sólo usa spreadsheetdate (líneas ), que hace dudar transferirla spreadsheetdate . razón cambiarla que tabla específica ninguna implementación concreta []. por otra parte, sólo existe implementación spreadsheetdate , modo que tabla debe acercarse donde vaya usar [], para zanjar duda ser coherentes [], deberíamos privatizar tabla mostrarla través una función como juliandateoflastdayofmonth . pero nadie parece que necesita. más, tabla puede cambiar daydate una nueva implementación daydate necesita. así que cambiamos. mismo sucede con leap_year_aggregate_days_to_end_of_month . tras ello, vemos tres grupos constantes que pueden convertir enumeraciones (líneas -). primera selecciona una semana mes. transformo enumeración weekinmonth . public enum weekinmonth { first(), second(), third(), fourth(), last(); public final int index; weekinmonth(int index) { this.index = index; } } segundo grupo constantes (líneas -) más complicado. las constantes include_none, include_first, include_second include_both usan para describir las fechas finales intervalo deben incluirse mismo. matemáticamente, describe como intervalo , intervalo medio abrir intervalo cerrado. creo que resulta más claro con nomenclatura matemática [], modo que cambio por enumeración dateinterval con los enumeradores closed, closed_left, closed_right open . tercer grupo constantes (líneas -) describen búsqueda día concreto semana devuelve última instancia, siguiente más próxima. decidir nombre adecuado complicado. final, opté por weekdayrange con los enumeradores last, next nearest . puede que esté acuerdo con los nombres elegidos. para tienen sentido. importante que ahora son más fáciles cambiar []. pasan como enteros, sino como símbolos. puedo usar función cambio nombre ide para cambiar los nombres los tipos sin preocuparme haberme olvidado - alguna parte del código que declaración argumento int estén bien descrita. campo descripción línea parece que use ninguna parte. elimino junto sus elementos acceso mutación []. también elimino constructor predeterminado línea []. compilador encargará generarlo. podemos ignorar método isvalidweekdaycode (líneas -) que eliminamos crear enumeración day . llegamos método stringtoweekdaycode (líneas -). los javadoc que suponen demasiado para firma del método sobran [], []. único valor este javadoc descripción del valor devuelto - . sin embargo, como cambiamos enumeración day , comentario realidad incorrecto []. ahora método genera illegalargumentexception . por ello, eliminamos javadoc. también elimino las palabras clave final argumentos declaraciones variables, que parecen servir mucho []. eliminación final goza gran aceptación. por ejemplo, robert simmons [] recomienda «… diseminar final por totalidad del código». estoy acuerdo. creo que existen casos para usar final , por ejemplo como constante ocasional, pero general, esta palabra clave apenas añade valor suele ser estorbo. puede que piense porque tipo errores que puede capturar final capturan las pruebas unidad que creado. las instrucciones duplicadas [] del bucle for (líneas ) son irrelevantes, modo que las conecté una única instrucción con operador || . también usé enumeración day para dirigir bucle for realicé otros cambios estéticos. este método pertenece realmente daydate . realidad función análisis day . por tanto, cambié enumeración day , que hizo que aumentara considerablemente tamaño. como concepto day depende daydate , extraje enumeración day clase daydate archivo propio []. también cambié siguiente función, weekdaycodetostring (líneas -) enumeración day asigné nombre tostring . public enum day { monday(calendar.monday), tuesday(calendar.tuesday), wednesday(calendar.wednesday), thursday(calendar.thursday), friday(calendar.friday), saturday(calendar.saturday), sunday(calendar.sunday); public final int index; private static dateformatsymbols datesymbols = new dateformatsymbols(); day(int day) { index = day; } public static day make(int index) throws illegalargumentexception { for (day : day.values()) (.index == index) return ; throw new illegalargumentexception( string.format(“illegal day index: %.”, index)); } public static day parse(string ) throws illegalargumentexception { string[] shortweekdaynames = datesymbols.getshortweekdays(); string[] weekdaynames = datesymbols.getweekdays(); = .trim(); for (day day : day.values()) { (.equalsignorecase(shortweekdaynames[day.index]) || .equalsignorecase(weekdaynames[day.index])) { return day; } } throw new illegalargumentexception( string.format(“% not valid weekday string”, )); } public string tostring() { return datesymbols.getweekdays()[index]; } } hay dos funciones getmonths (líneas -). primera invoca segunda. segunda solamente invoca desde primera. por ello, las combinado una las simplificado considerablemente [], [], []. por último, cambiado nombre por otro más descriptivo []. public static string[] getmonthnames() { return dateformatsymbols.getmonths(); } función isvalidmonthcode (líneas -) ahora irrelevante gracias enumeración month , modo que elimino []. función monthcodetoquarter (líneas -) parece sufrir envidia las características [] [] seguramente pertenezca enumeración month como método quarter , motivo por que sustituyo. public int quarter() { return + (index-)/; } este modo, enumeración month tiene tamaño suficiente como para estar una clase propia. extraigo daydate para mantener coherencia con enumeración day [], []. los dos siguientes métodos tienen nombre monthcodetostring (líneas -). vemos nuevo que uno invoca otro con indicador. recomendable pasar indicador como argumento una función, especial dicho indicador sólo selecciona formato del resultado []. por tanto, cambio nombre, simplifico reestructuro estas funciones las incluyo enumeración month [], [], [], []. public string tostring() { return dateformatsymbols.getmonths()[index - ]; } public string toshortstring() { return dateformatsymbols.getshortmonths()[index – ]; } siguiente método stringtomonthcode (líneas -). cambio nombre, paso enumeración month simplifico [], [], [], [], []. public static month parse(string ) { = .trim(); for (month : month.values()) (.matches()) return ; try { return make(integer.parseint()); } catch (numberformatexception ) {} throw new illegalargumentexception(“invalid month ” + ); } private boolean matches(string ) { return .equalsignorecase(tostring()) || .equalsignorecase(toshortstring()); } método isleapyear (líneas -) puede modificar para que sea más expresivo []. public static boolean isleapyear(int year) { boolean fourth = year % == ; boolean hundredth = year % == ; boolean fourhundredth = year % == ; return fourth && (!hundredth || fourhundredth); } siguiente función, leapyearcount (líneas -) pertenece realmente daydate . nadie invoca, excepto los dos métodos spreadsheetdate , modo que desplazo hacia abajo []. función lastdayofmonth (líneas -) usa matriz last_day_of_month , que realidad pertenece enumeración month [], por que cambio ubicación. también simplifico función aumento expresividad []. public static int lastdayofmonth(month month, int year) { (month == month.february && isleapyear(year)) return month.lastday() + ; else month.lastday(); } ahora empieza ponerse interesante. siguiente función adddays (líneas -). primer lugar, como opera las variables daydate , debería ser estática []. cambio por método instancia. por otra parte, invoca función toserial , cuyo nombre deberíamos cambiar por toordinal []. por último, método puede simplificar. public daydate adddays(int days) { return daydatefactory.makedate(toordinal() + days); } mismo sucede con addmonths (líneas -). debería ser método instancia []. algoritmo tanto complicado, modo que recurro explicación variables temporales [] [] para que sea más transparente. también cambio nombre del método getyyy por getyear []. public daydate addmonths(int months) { int thismonthasordinal = * getyear() + getmonth().index - ; int resultmonthasordinal = thismonthasordinal + months; int resultyear = resultmonthasordinal / ; month resultmonth = month.make(resultmonthasordinal % + ); int lastdayofresultmonth = lastdayofmonth(resultmonth, resultyear); int resultday = math.min(getdayofmonth(), lastdayofresultmonth); return daydatefactory.makedate(resultday, resultmonth, resultyear); } función addyears (líneas -) similar resto. public daydate plusyears(int years) { int resultyear = getyear() + years; int lastdayofmonthinresultyear = lastdayofmonth(getmonth(), resultyear); int resultday = math.min(getdayofmonth(), lastdayofmonthinresultyear); return daydatefactory.makedate(resultday, getmonth(), resultyear); } hay algo que preocupa sobre cambio estos métodos estáticos métodos instancia. ¿ expresión date.adddays() aclara que objeto date cambia que devuelve una nueva instancia daydate supone, equivocadamente, que añaden cinco días objeto date ? pensará que gran problema, pero fragmento código como siguiente puede ser muy engañoso []. daydate date = datefactory.makedate(, month.december, ); date.adddays(); // desplazar fecha una semana lector este código podría aceptar que adddays cambia objeto date , modo que necesitamos nombre que acabe con ambigüedad []: plusdays plusmonths . creo que intención del método captura correctamente por medio daydate date = olddate.plusdays(); mientras que siguiente transmite con fluidez lector que objeto date cambiado: date.plusdays(); los algoritmos son cada vez más interesantes. getpreviousdayofweek (líneas -) funciona pero complicado. tras meditar que sucedía [], pude simplificarlo aplicar explicación variables temporales [] para aclarar significado. también cambié método estático método instancia [] deshice del método instancia duplicado [] (líneas -). public daydate getpreviousdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index = getdayofweek().index; (offsettotarget = ) offsettotarget - ; return plusdays(offsettotarget); } sucede exactamente mismo con getfollowingdayofweek (líneas -). public daydate getfollowingdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index - getdayofweek().index; (offsettotarget <= ) offsettotarget += ; return plusdays(offsettotarget); } siguiente función getnearestdayofweek (líneas -), que corregimos apartado anterior. pero esos cambios son coherentes con patrón actual las dos últimas funciones []. por ello, recurro explicación variables temporales [] para aclarar algoritmo. public daydate getnearestdayofweek(final day targetday) { int offsettothisweekstarget = targetday.index - getdayofweek().index; int offsettofuturetarget = (offsettothisweekstarget + ) % ; int offsettoprevioustarget = offsettofuturetarget - ; (offsettofuturetarget ) plusdays(offsettoprevioustarget); else return plusdays(offsettofuturetarget); } método getendofcurrentmonth (líneas -) tanto extraño que método instancia que envidia [] propia clase aceptado argumento daydate . convierto verdadero método instancia clarifico algunos los nombres. public daydate getendofmonth() { month month = getmonth(); int year = getyear(); int lastday = lastdayofmonth(month, year); return daydatefactory.makedate(lastday, month, year); } refactorización weekinmonthtostring (líneas -) resultó ser muy interesante. mediante las herramientas refactorización ide, primero cambié método enumeración weekinmonth creada antes después cambié nombre por tostring . tras ello, convertí método instancia. todas las pruebas fueron correctas (¿adivina hacia dónde nos dirigimos?). seguidamente, eliminé método. fallaron cinco afirmaciones (líneas - del listado -). cambié estas líneas para usar los nombres los enumeradores ( first , second , etc.). las pruebas fueron correctas. ¿ por qué? ¿puede ver también por qué son necesarios estos pasos? herramienta refactorización encargó que los invocadores anteriores weekinmonthtostring invocaran ahora tostring enumerador weekinmonth que todos los enumeradores implementan tostring para devolver sus nombres… desafortunadamente, pasé listo. pesar elegancia cadena refactorización, comprobé que los únicos usuarios esta función eran las pruebas que acababa modificar, modo que las eliminé. así pues, tras determinar que sólo las pruebas invocaban relativetostring (líneas -), eliminé directamente función sus pruebas. hemos llegado los métodos abstractos esta clase abstracta. primero toserial (líneas -). apartado anterior cambié nombre por toordinal . verlo este contexto, decidí que cambio debería ser por getordinalday . siguiente método abstracto todate (líneas -). convierte daydate java.util.date . ¿por qué abstracto? analizamos implementación spreadsheetdate (líneas - del listado -), vemos que depende implementación esa clase []. por tanto, desplazo hacia arriba. los métodos getyyyy , getmonth getdayofmonth son evidentemente abstractos. sin embargo, getdayofweek debería ascender desde spreadsheetdate que depende nada que encontremos daydate []. ¿ ? fija atentamente (línea del listado -), verá que algoritmo depende implícitamente del origen del día ordinal ( decir, día semana del día ). por ello, aunque esta función carezca dependencias físicas que puedan cambiar daydate , cuenta con una dependencia lógica. este tipo dependencias lógicas molestan []. algo lógico depende implementación, también debería haber algo físico. además, parece que propio algoritmo podría ser genérico que debería depender menor medida implementación []. por tanto, creé método abstracto daydate con nombre getdayofweekforordinalzero implementé spreadsheetdate para devolver day.saturday . tras ello, envié método getdayofweek daydate cambié para que invocara getordinalday getdayofweekforordinalzero . public day getdayofweek() { day startingday = getdayofweekforordinalzero(); int startingoffset = startingday.index - day.sunday.index; return day.make((getordinalday() + startingoffset) % + ); } fíjese comentario las líneas -. ¿necesitamos realmente esta repetición? como costumbre, eliminé este comentario junto los demás. siguiente método compare (líneas -). nuevo, incorrectamente abstracto [], por que cambio implementación daydate . además, nombre descriptivo []. realidad, este método devuelve diferencia días desde argumento, por que cambié nombre por dayssince . tampoco existían pruebas para este método, que las creé. las seis siguientes funciones (líneas -) son métodos abstractos que deben implementarse daydate , por que las extraje spreadsheetdate . última función, isinrange (líneas -), también debe extraerse refactorizarse. instrucción switch agradable [] puede modificar enviamos los casos enumeración dateinterval . public enum dateinterval { open { public boolean isin(int , int left, int right) { return left && < right; } }, closed_left { public boolean isin(int , int left, int right) { return = left && < right; } }, closed_right { public boolean isin(int , int left, int right) { return left && <= right; } }, closed { public boolean isin(int , int left, int right) { return = left && <= right; } }; public abstract boolean isin(int , int left, int right); } public boolean isinrange(daydate , daydate , dateinterval interval) { int left = math.min(.getordinalday(), .getordinalday()); int right = math.max(.getordinalday(), .getordinalday()); return interval.isin(getordinalday(), left, right); } con esto llegamos final daydate . realizaremos una nueva pasada por clase completa para comprobar cómo fluye. primero, comentario inicial está desfasado, modo que reduzco mejoro []. tras ello, desplazo las enumeraciones restantes sus propios archivos []. seguidamente, desplazo variable estática ( dateformatsymbols ) tres métodos estáticos ( getmonthnames , isleapyear , lastdayofmonth ) una nueva clase con nombre dateutil []. los métodos abstractos una posición superior, donde pertenecen []. cambio month.make por month.fromint [] repito operación con las demás enumeraciones. también creo método acceso toint() para todas las enumeraciones convierto privado campo index . produce una interesante duplicación [] plusyears plusmonths que conseguí eliminar extrayendo nuevo método con nombre correctlastdayofmonth , que aclaraba significado los tres métodos. deshice del número mágico [] sustituí por month.january.toint() day.sunday.toint() , según caso. detuve limpiar los algoritmos spreadsheetdate . resultado final puede comprobar los listados . .. alcance del código daydate reducido . por , porque pruebe una cantidad menor funcionalidad, sino porque clase reducido tanto que las líneas sin alcance tienen peso mayor. ahora, daydate las pruebas aplican las instrucciones ejecutables. las líneas sin alcance son tan triviales que merece pena probarlas. conclusión otra vez hemos aplicado regla del boy scout. hemos entregado código más limpio que recibimos. nos llevado tiempo, pero merecido pena. alcance las pruebas aumentado, hemos corregido algunos errores hemos aclarado reducido tamaño del código. próxima persona que lea seguramente encontrará más fácil leer. probablemente esa persona sea capaz limpiarlo algo más que hemos hecho nosotros. bibliografía [gof] : design patterns: elements reusable object oriented , gamma ., addison-wesley, . [simmons] : hardcore java , robert simmons, ., ’reilly, . [refactoring] : refactoring: improving the design existing code , martin fowler ., addison-wesley, . [beck] : smalltalk best practice patterns , kent beck, prentice hall, . síntomas heurística magnífico libro refactoring [] , martin fowler identifica diversos síntomas código ( smells ). lista que mostramos continuación incluye muchos los síntomas martin otros propios. también contiene otras perlas heurística que suelo emplear trabajo. compilar esta lista examinado diversos programas los refactorizado. aplicar cambio, preguntaba por qué anotaba motivo. resultado una extensa lista aspectos que «huelen» bien cuando leo código. lista debe leer arriba abajo, también puede usar como referencia. comentarios : información inapropiada apropiado que comentario contenga información que pueda almacenar otro tipo sistema como sistema control código fuente, seguimiento problemas mantenimiento registros. los historiales cambios, por ejemplo, abarrotan los archivos código con abundante texto sin interés alguno. por general, metadatos como autores, fechas modificación, números spr similares deben aparecer los comentarios. los comentarios deben reservarse para notas técnicas sobre código diseño. : comentario obsoleto comentario anticuado, irrelevante incorrecto obsoleto. los comentarios envejecen rápidamente. recomendable escribir comentario que vaya quedar obsoleto. detecta comentario obsoleto, conviene actualizarlo eliminarlo antes posible. los comentarios obsoletos tienden alejarse del código que describían. convierten islas irrelevancia desorientación código. : comentario redundante comentario redundante describe algo que define correctamente mismo. por ejemplo: ++; // incrementar otro ejemplo javadoc que dice más ( incluso menos) que firma una función: /** * @param sellrequest * @return * @throws managedcomponentexception */ public sellresponse beginsellitem(sellrequest sellrequest) throws managedcomponentexception los comentarios deben comunicar que código pueda expresar por mismo. : comentario mal escrito comentario que merezca pena escribir merece pena ser leído. piensa escribir comentario, asegúrese que mejor que puede crear. elija las palabras con atención. use gramática puntuación correctas. divague. afirme evidente. sea breve. : código comentado molesta ver grandes fragmentos código comentado. ¿quién sabe qué antigüedad tienen? ¿quién sabe tiene sentido ? pero nadie borra porque piensa que alguien más necesita. ese código estanca corrompe, cada día que pasa menos relevante. invoca funciones que existen. usa variables cuyos nombres han cambiado. rige por convenciones obsoletas. contamina los módulos los que aparece distrae los usuarios que leen. código comentado una aberración. cuando vea código comentado, elimínelo. preocupe, sistema control código fuente recordará. alguien necesita, puede consultar una versión anterior. sufra código comentado para sobrevivir. : generación requiere más paso generación proyecto debería ser una operación sencilla. debería tener que comprobar demasiados elementos del control código fuente. debería necesitar una secuencia antiguos comandos secuencias comandos dependientes del contexto para generar cada elemento. debería tener que buscar los distintos archivos jar, xml similares necesarios para sistema. debería finalizar sistema con sencillo comando después ejecutar otro igual sencillo para generarlo. svn get mysystem mysystem ant all : las pruebas requieren más paso debería poder ejecutar todas las pruebas unidad con solo comando. mejor los casos, debería poder ejecutarlas pulsando botón ide. peor, debería poder ejecutar único comando una línea comandos. capacidad ejecutar todas las pruebas tan importante que debe ser algo rápido, sencillo obvio. funciones : demasiados argumentos las funciones deben tener número reducido argumentos. mejor que tengan, seguido uno, dos tres argumentos. más tres cuestionable debería evitarse (véase capítulo ). : argumentos salida los argumentos salida son ilógicos. lector espera que los argumentos sean entradas, salidas. función tiene que cambiar estado algo, haga que cambie estado del objeto que invoca (véase capítulo ). : argumentos indicador los argumentos booleanos declaran abiertamente que función hace más una cosa. resultan confusos deben eliminarse (véase capítulo ). : función muerta los métodos que nunca invocan deben descartarse. presencia código muerto innecesaria. tema eliminar función. sistema control código fuente recordará. general : varios lenguajes archivo código los modernos entornos programación actuales permiten incluir varios lenguajes diferentes mismo archivo código. por ejemplo, archivo java puede contener fragmentos xml, html, yaml, javadoc, javascript, similares. además html, archivo jsp podría incluir java, sintaxis biblioteca etiquetas, comentarios español, javadoc, xml, javascript, etc. resulta confuso mejor los casos desastre peor. ideal sería que archivo código incluyera solo lenguaje pero, realidad, seguramente tendremos que usar más uno. debemos intentar minimizar cantidad alcance los lenguajes adicionales nuestros código. : comportamiento evidente implementado acuerdo principio mínima sorpresa [] , una función clase debe implementar los comportamientos que otro programador esperaría. por ejemplo, imagine una función que traduce nombre día una enumeración que represente dicho día. day day = daydate.stringtoday(string dayname); esperaríamos que cadena « monday » tradujera day.monday. también esperaríamos traducción las abreviaturas habituales que función ignorara mayúsculas minúsculas. cuando comportamiento obvio implementa, los lectores usuarios del código dependen intuición sobre los nombres las funciones. pierden confianza autor original ven obligados leer los detalles del código. : comportamiento incorrecto los límites parece evidente afirmar que código debe comportarse forma correcta. problema que nos damos cuenta complicado que dicho comportamiento correcto. los programadores suelen crear funciones que esperan que funcionen confían intuición más que comprobar que código funciona todos los casos límites. existe sustituto para meticulosidad. las condiciones límite, los casos extremos, las excepciones, representan algo que puede confundir algoritmo elegante intuitivo. dependa intuición . busque todas las condiciones límite cree pruebas para cada una. : medidas seguridad canceladas chernobyl derritió porque director central ignoró todos cada uno los mecanismos seguridad. impedían que realizara experimento. resultado fue que experimento salió bien mundo fue testigo primera gran catástrofe nuclear para población. anular las medidas seguridad riesgo. puede que sea necesario ejercer control manual sobre serialversionuid pero siempre arriesgado. desactivación determinadas advertencias del compilador ( todas) puede ayudarle conseguir generación, pero corre riesgo sufrir interminables sesiones depuración. desactivar las pruebas que fallan convencerse que conseguirá que después sean satisfactorias tan erróneo como pensar que sus tarjetas crédito son dinero gratuito. : duplicación una las reglas más importantes del libro que debe tomarse muy serio. práctica totalidad los autores que escriben sobre diseño software mencionan esta regla. dave thomas andy hunt denominaron principio dry [] ( don' repeat yourself , repetirse). kent beck convirtió uno los principios fundamentales programación extreme denominó «una sola vez». ron jeffries sitúa esta regla segunda posición, por debajo consecución satisfactoria todas las pruebas. siempre que vea duplicados código, indican una oportunidad abstracción fallida. duplicación podría convertirse una subrutina otra clase. incluir duplicación una abstracción, aumenta vocabulario del lenguaje del diseño. otros programadores pueden usar sus creaciones abstractas. código vuelve más rápido menos proclive errores que aumentado nivel abstracción. caso más evidente duplicación presencia fragmentos código idéntico que parecen pegados repetidamente por programador, sin sentido. conviene reemplazarlos por métodos simples. una forma más sutil cadena switch/case /else que aparece repetidamente diversos módulos que siempre prueba las mismas condiciones. conviene reemplazar estas cadenas por polimorfismo. más sutiles todavía son los módulos con algoritmos similares pero que comparten las mismas líneas código. sigue siendo duplicación debe por medio del patrón método plantilla [] estrategia [] . realidad, mayoría patrones diseño aparecidos los últimos años son formas eliminar duplicación. las formas normales codd también son una estrategia para eliminar duplicación esquemas base datos. incluso programación orientada objetos una estrategia para organizar módulos eliminar duplicación. debería sorprenderle, que trata programación estructurada. creo que objetivo evidente: localice los elementos duplicados elimínelos siempre que pueda. : código nivel abstracción incorrecto importante crear abstracciones que separen conceptos generales nivel superior conceptos detallados nivel inferior. para ello, ocasiones creamos clases abstractas que contengan los conceptos nivel superior variantes los nivel inferior. hacemos, debemos asegurarnos que separación sea completa. todos los conceptos nivel inferior deben estar las variantes los nivel superior clase base. por ejemplo, constantes, variables funciones utilidad que solamente pertenezcan implementación detallada deben aparecer clase base. clase base debe saber nada respecto estos elementos. esta regla también aplica archivos fuente, componentes módulos. diseño correcto software requiere separación conceptos distintos niveles inclusión contenedores diferentes. ocasiones, dichos contenedores son clases base variantes, otros casos son archivos fuente, módulos componentes. independientemente del caso, separación debe ser completa. queremos que conceptos nivel inferior superior mezclen. fíjese este código: public interface stack { object pop() throws emptyexception; void push(object ) throws fullexception; double percentfull(); class emptyexception extends exception {} class fullexception extends exception {} } función percentfull encuentra nivel abstracción . aunque hay implementaciones stack las que concepto amplitud razonable, otras pueden conocer nivel amplitud. por tanto, función debería incluirse una interfaz derivada como boundedstack . pensará que implementación podría devolver cero pila tuviera límites. problema que existen pilas totalmente sin límites. puede evitar outofmemoryexception mediante comprobación stack.percentfull() < .. implementación esta función para que devuelva sería una mentira. moraleja que puede mentir escapar una abstracción mal ubicada. aislamiento abstracciones una las operaciones más complicadas para los desarrolladores software puede corregir cuando realiza forma incorrecta. : clases base que dependen sus variantes motivo más habitual para dividir conceptos clases base derivadas para que los conceptos nivel superior clase base sean independientes los nivel inferior las derivadas. por ello, cuando vemos clases base que mencionan los nombres sus variantes, intuye problema. por general, las clases base deben saber nada sobre derivadas. evidentemente, hay excepciones. ocasiones, número variantes fijo clase base tiene código que elegir entre las variantes. muy habitual implementaciones equipos con estado finito. sin embargo, ese caso las variantes clase base están íntimamente unidas siempre implementan mismo archivo jar. caso general, deben implementarse archivos independientes. implementar variantes clases base archivos diferentes garantizar que los archivos clase base desconocen contenido los archivos las variantes podemos implementar nuestros sistemas componentes discretos independientes. modificar dichos componentes, pueden volver implementar sin necesidad implementar nuevo los componentes base. este modo reduce significativamente impacto del facilita mantenimiento los sistemas. : exceso información los módulos bien definidos tienen interfaces reducidas que nos permiten hacer mucho con poco. los módulos definidos forma incorrecta tienen interfaces más amplias que nos obligan usar distintos gestos para realizar operaciones sencillas. una interfaz bien definida ofrece demasiadas funciones las conexiones son reducidas. una interfaz definida forma incorrecta ofrece multitud funciones que invocar , por tanto, las conexiones son elevadas. los buenos programadores software aprenden limitar parte sus clases módulos que muestran sus interfaces. cuantos menos métodos tenga una clase, mejor. cuantas menos variables conozca una función, mejor. cuantas menos variables instancia tenga una clase, mejor. oculte sus datos. oculte sus funciones utilidad. oculte sus constantes elementos temporales. cree clases con multitud métodos variables instancia. cree multitud variables funciones protegidas para sus subclases. concéntrese crear interfaces concisas tamaño reducido. limite información para reducir las conexiones. : código muerto código muerto que ejecuta. encuentra cuerpo una instrucción que comprueba una condición que sucede. encuentra bloque catch una instrucción try que carece throws . encuentra pequeños métodos utilidad que nunca invocan condiciones switch/case inexistentes. problema del código muerto que con tiempo empieza oler. cuanto más antiguo , más profundo hedor que despide. debe que código muerto actualiza cambiar los diseños. sigue compilándose pero rige por nuevas convenciones reglas. creó momento que sistema era diferente . debe tener entierro digno. bórrelo del . : separación vertical variables funciones deben definirse cerca donde utilicen. las variables locales deben declararse por encima primer uso deben tener reducido ámbito vertical. deben declararse cientos líneas distancia uso. las funciones privadas deben definirse justo debajo primer uso. pertenecen ámbito clase completa pero conviene limitar distancia vertical entre las invocaciones las definiciones. para localizar una función privada debe bastar con buscar debajo primer uso. : incoherencia hace algo una forma concreta, aplique misma técnica operaciones similares. esto entronca con principio mínima sorpresa. preste atención las convenciones que elija , una vez elegidas, asegúrese mantenerlas. una función concreta usa variable response para almacenar httpservletresponse , use mismo nombre variable las demás funciones que usen objetos httpservletresponse . asigna nombre processverificationrequest método, use nombre similar, como processdeletionrequest , para los métodos que procesen otros tipos solicitudes. este tipo coherencia, aplica repetidamente, facilita lectura modificación del código. : desorden ¿para qué sirve constructor predeterminado sin implementación? únicamente desordena código inunda elementos sin sentido. variables sin usar, funciones que nunca invocan, comentarios que añaden información, etc. todos estos elementos sobran deben eliminarse. limpios sus archivos, bien organizados sin elementos sobrantes. : conexiones artificiales los elementos que dependen unos otros deben conectarse forma artificial. por ejemplo, las enumeraciones generales deben incluirse clases más específicas que esto obliga aplicación saber más sobre dichas clases. mismo sucede con funciones static propósito general declaradas clases específicas. por general, una conexión artificial que establece entre dos módulos sin propósito directo. resultado incluir una variable, constante función una ubicación temporalmente útil pero inadecuada. síntoma falta atención. piense dónde debe declarar sus funciones, constantes variables. las deje punto más cómodo. : envidia las características uno los síntomas martin fowler [] . los métodos una clase deben interesarse por las variables funciones clase que pertenecen, por las variables funciones otras clases. cuando método usa elementos acceso mutación otro objeto para manipular los datos éste, envidia ámbito clase dicho objeto. desea formar parte otra clase para tener acceso directo las variables que manipula. por ejemplo: public class hourlypaycalculator { public money calculateweeklypay(hourlyemployee ) { int tenthrate = .gettenthrate().getpennies(); int tenthsworked = .gettenthsworked(); int straighttime = math.min(, tenthsworked); int overtime = math.max(, tenthsworked - straighttime); int straightpay = straighttime * tenthrate; int overtimepay = (int)math.round(overtime*tenthrate*.); return new money(straightpay + overtimepay); } } método calculateweeklypay acerca objeto hourlyemployee para los datos sobre los que opera. método calculateweeklypay envidia ámbito hourlyemployee . deseo formar parte hourlyemployee . recomendable suprimir envidia características que muestra los detalles internos una clase otra. sin embargo, ocasiones mal necesario. fíjese siguiente: public class hourlyemployeereport { private hourlyemployee employee; public hourlyemployeereport(hourlyemployee ) { this.employee = ; } string reporthours() { return string.format( “name: %\thours:%.%\”, employee.getname(), employee.gettenthsworked()/, employee.gettenthsworked()%); } } evidentemente, método reporthours envidia clase hourlyemployee . por otra parte, queremos que hourlyemployee tenga que conocer formato del informe. incluir cadena formato clase hourlyemployee incumpliríamos varios los principios del diseño orientado objetos [] . conectaría hourlyemployee formato del informe mostraría los cambios dicho formato. : argumentos selector hay nada más abominable que argumento false aislado final invocación una función. ¿qué significa? ¿qué cambiaría fuera true ? sólo propósito argumento selector difícil recordar, sino que cada argumento selector combina varias funciones una. los argumentos selector son una forma indolente evitar dividir una función gran tamaño otras menores. fíjese siguiente: public int calculateweeklypay(boolean overtime) { int tenthrate = gettenthrate(); int tenthsworked = gettenthsworked(); straighttime = math.min(, tenthsworked); int overtime = math.max(, tenthsworked - straighttime); int straightpay = straighttime * tenthrate; double overtimerate = overtime ? . : . * tenthrate; int overtimepay = (int)math.round(overtime*overtimerate); return straightpay + overtimepay; } esta función invoca con true las horas extras pagan como hora media, con false pagan como una hora normal. bastante malo tener que recordar que significa calculateweeklypay(false) cada vez que aparezca. pero peor esta función que autor perdido oportunidad crear siguiente: public int straightpay() { return gettenthsworked() * gettenthrate(); } public int overtimepay() { int overtimetenths = math.max(, gettenthsworked() - ); int overtimepay = overtimebonus(overtimetenths); return straightpay() + overtimepay; } private int overtimebonus(int overtimetenths) { double bonus = . * gettenthrate() * overtimetenths; return (int) math.round(bonus); } evidentemente, los selectores deben ser boolean . pueden ser enumeraciones, enteros otro tipo argumento que use para seleccionar comportamiento función. más recomendable tener varias funciones que pasar código una función para seleccionar comportamiento. : intención desconocida queremos que código sea más expresivo posible. expresiones extensas, notación húngara números mágicos distorsionan intención del autor. por ejemplo, veamos función overtimepay cómo podría haber aparecido: public int m_otcalc() { return ithswkd * ithsrte + (int) math.round(. * ithsrte * math.max(/ ithswkd - ) ); } parezca reducida densa, también prácticamente impenetrable. recomendable dedicar tiempo lograr que intención nuestro código sea aparente para nuestros lectores. : responsabilidad desubicada una las principales decisiones programador software dónde ubicar código. por ejemplo, dónde incluir constante . ¿ clase math ? ¿pertenece clase trigonometry ? ¿ clase circle ? principio mínima sorpresa vuelve aparecer. código debe ubicarse donde lector espera encontrarlo. constante debe incluirse junto declaración las funciones trigonométricas. constante overtime_rate debe declararse clase hourlypaycalculator . ocasiones presumimos dónde añadimos una determinada funcionalidad. incluimos una función porque nos resulta cómodo pero porque sea intuitivo para lector. por ejemplo, puede que tengamos que imprimir informe con total horas que trabajado empleado. podríamos sumar las horas código que imprime informe intentar mantener total código que acepte horarios trabajo. una forma tomar esta decisión consiste analizar nombre las funciones. imagine que módulo del informe tiene función gettotalhours . imagine también que módulo que acepta horarios trabajo tiene función savetimecard . ¿cuál las dos, por nombre, implica que calcula total? respuesta evidente. existen motivos rendimiento para calcular total como horarios trabajo como informe impreso. correcto, pero nombre las funciones debería reflejarlo. por ejemplo, debería haber una función computerunningtotalofhours módulo horarios. : elementos estáticos incorrectos math.max (double , double ) método estático correcto. opera una única instancia; hecho, sería error tener que usar new math().max(,) incluso .max() . todos los datos que usa max provienen sus dos argumentos, objeto. además, prácticamente imposible que queramos que math.max sea polimórfico. sin embargo, ocasiones creamos funciones estáticas que deben serlo. fíjese este ejemplo: hourlypaycalculator.calculatepay(employee, overtimerate). nuevo, parece una función estática razonable. opera objeto concreto recibe todos los datos sus argumentos. sin embargo, existe posibilidad que queramos que sea polimórfica. puede que queramos implementar distintos algoritmos para calcular precio hora, como por ejemplo. overtimehourlypaycalculator straighttimehourlypaycalculator . este caso, función debe ser estática. debería ser una función miembro estática employee . por general, debe decantarse por métodos estáticos. caso duda, convierta función estática. realmente quiere que una función sea estática, asegúrese que nunca querrá que sea polimórfica. : usar variables explicativas kent beck escribió sobre este tema magnífico libro smalltalk best practice patterns [] , más recientemente implementation patterns [] . una las técnicas más completas para que programa sea legible consiste dividir los cálculos valores intermedios almacenados variables con nombres descriptivos. fíjese este ejemplo fitnesse: matcher match = headerpattern.matcher(line); (match.find()) { string key = match.group(); string value = match.group(); headers.put(key.tolowercase(), value); } simple uso variables explicativas ilustra con claridad que primer grupo comparado clave segundo valor . complicado excederse esta técnica. por general, mejor tener más variables explicativas que menos. sorprendente que módulo opaco vuelva más transparente con tan sólo dividir los cálculos valores intermedios con los nombres adecuados. : los nombres función deben indicar que hacen fíjese este código: date newdate = date.add(); ¿intuye que añaden cinco días fecha son semanas horas? ¿ instancia date cambia función simplemente devuelve nuevo objeto date sin cambiar antiguo? por invocación podemos saber qué hace función . función añade cinco días fecha después cambia, nombre debería ser adddaysto increasebydays . , por otra parte, función devuelve una nueva fecha con cinco días más pero cambia instancia date , nombre debería ser dayslater dayssince . tiene que fijarse implementación ( documentación) función para saber qué hace, tendrá que elegir nombre más apropiado modificar funcionalidad para que pueda incluir funciones con nombres más acertados. : comprender algoritmo crea gran cantidad código extraño porque los autores esfuerzan comprender algoritmo. consiguen que algo funcione combinando instrucciones indicadores sin pararse pensar qué sucede realmente. programación una tarea exploración. creemos que conocemos algoritmo adecuado para algo pero después modificamos variamos hasta conseguir que funcione . ¿cómo sabemos que funciona ? porque supera los casos prueba que pensamos. enfoque equivocado. hecho, suele ser única forma conseguir que una función haga que pensamos que debe hacer. sin , basta con conseguir que funcione . antes creer que hemos terminado con una función, asegúrese entender funcionamiento. basta con que supere todas las pruebas. tiene que estar seguro [] que solución correcta. por general, forma óptima saberlo consiste refactorizar función algo tan limpio expresivo que funcionamiento sea evidente . : convertir dependencias lógicas físicas módulo depende otro, dicha dependencia debe ser física, sólo lógica. módulo dependiente debe asumir aspectos ( decir, dependencias lógicas) sobre módulo del que depende. por contrario, debe solicitar forma explícita módulo toda información que depende. por ejemplo, imagine que tiene que crear una función que imprima informe las horas trabajadas por cada empleado. clase hourlyreporter recopila los datos los pasa hourlyreportformatter para imprimirlos (véase listado -). listado - hourlyreporter.java. public class hourlyreporter { private hourlyreportformatter formatter; private list<lineitem page; private final int page_size = ; public hourlyreporter(hourlyreportformatter formatter) { this.formatter = formatter; page = new arraylist<lineitem(); } public void generatereport(list<hourlyemployee employees) { for (hourlyemployee : employees) { addlineitemtopage(); (page.size() == page_size) printandclearitemlist(); } (page.size() ) printandclearitemlist(); } private void printandclearitemlist() { formatter.format(page); page.clear(); } private void addlineitemtopage(hourlyemployee ) { lineitem item = new lineitem(); item.name = .getname(); item.hours = .gettenthsworked() / ; item.tenths = .gettenthsworked() % ; page.add(item); } public class lineitem { public string name; public int hours; public int tenths; } } este código tiene una dependencia lógica que convertido física. ¿ detecta? constante page_size . ¿para qué necesita hourlyreporter saber tamaño página? tamaño página debe ser responsabilidad hourlyreportformatter . declaración page_size hourlyreporter representa una responsabilidad desubicada [] que hace que hourlyreporter asuma que conoce tamaño que debe tener página. esta presunción una dependencia lógica. hourlyreporter depende que hourlyreportformatter pueda procesar tamaños página hasta . alguna implementación hourlyreportformatter puede asumir esos tamaños, producirá error. podemos convertir física esta dependencia creamos nuevo método hourlyreportformatter con nombre getmaxpagesize() . tras ello, hourlyreporter invoca esta función lugar usar constante page_size . : polimorfismo antes que /else switch/case puede parecer una sugerencia extraña dado tema descrito capítulo . este capítulo, afirmo que las instrucciones switch son adecuadas partes del sistema las que añadan más funciones nuevas que tipos nuevos. lado, mayoría usamos instrucciones switch por ser una solución fuerza bruta evidente, por ser solución perfecta. por tanto, esta heurística nos recuerda que debemos considerar uso polimorfismo antes usar switch . por otra parte, los casos que las funciones son más volátiles que los tipos son escasos. por tanto, toda instrucción switch sospechosa. suelo aplicar siguiente regla una instrucción switch : puede haber más una instrucción switch por cada tipo selección. los casos esa instrucción switch deben crear objetos polimórficos que ocupen lugar otras instrucciones switch similares resto del sistema . : seguir las convenciones estándar todos los equipos deben seguir estándar diseño código basado normas comunes industria. este estándar debe especificar aspectos como dónde declarar variables instancia, cómo asignar nombres clases, métodos variables, dónde añadir llaves, etc. equipo debe necesitar documento que describa estas convenciones que código proporciona los ejemplos. todos los miembros del equipo deben seguir estas convenciones, que significa que importa dónde añada cada uno las llaves mientras todos estén acuerdo dónde añadirlas. desea saber qué convenciones aplico, puede verlas código refactorizado los listados . . del apéndice . : sustituir números mágicos por constantes con nombre probablemente una las reglas más antiguas del desarrollo software . recuerdo haberla leído finales década manuales cobol, fortran /. por general, recomendable incluir números sin procesar código; debe ocultarlos tras constantes con correctos. por ejemplo, número debe ocultarse tras constante seconds_per_day . imprimir líneas por página, constante debe ocultarse tras constante lines_per_page . algunas constantes son tan fáciles reconocer que siempre necesitan una constante con nombre tras que ocultarse mientras usen junto código explicativo. por ejemplo: double mileswalked = feetwalked/.; int dailypay = hourlyrate * ; double circumference = radius * math. * ; ¿necesitamos realmente las constantes feet_per_mile, work_hours_per_day two los ejemplos anteriores? último caso absurdo. existen ciertas fórmulas las que las constantes escriben mejor como números sin procesar. puede cuestionar caso work_hours_per_day que las leyes las convenciones pueden cambiar. por otra parte, esa fórmula lee perfectamente incluye por que necesario añadir más. caso feet_per_mile , número una constante tan conocida exclusiva que los lectores reconocerán aunque muestre forma independiente una página sin contexto alguno. constantes como . también son conocidas reconocibles. sin embargo, probabilidad errores alta conviene mostrarlas tal cual. siempre que alguien ., sabe que , molestan examinarlo (¿ visto error dígito?). tampoco queremos que gente use ., ., ., similares. por tanto, una suerte contar con math. . término número mágico sólo aplica números, sino todo símbolo que tenga valor que sea descriptivo por mismo. por ejemplo: assertequals(, employee.find(“john doe”).employeenumber()); esta afirmación hay dos números mágicos. primero obviamente , aunque significa que sea obvio. segundo « john doe » cometido tampoco está claro. “john doe” nombre del empleado # una conocida base datos pruebas creada por nuestro equipo. todo mundo sabe que base datos, cuenta con varios empleados con sus valores atributos. además, « john doe » representa único empleado por horas base datos. por tanto, prueba debería ser siguiente: assertequals( hourly_employee_id, employee.find(hourly_employee_name).employeenumber()); : precisión esperar que primera coincidencia una consulta sea única una ingenuidad. uso números coma flotante para representar divisas casi delito. evitar bloqueos / administración transacciones por creer que las actualizaciones concurrentes son posibles pura indolencia. declarar una variable como arraylist cuando necesita list exceso restricciones. crear todas las variables como protected forma predeterminada falta restricciones. adoptar una decisión código, debe hacerlo forma precisa. debe saber por qué adopta cómo afrontará las excepciones. sea indolente sobre precisión sus decisiones. decide invocar una función que pueda devolver null , asegúrese comprobar null . consulta que considera único registro una base datos, asegúrese que código comprueba que haya otros. tiene que trabajar con divisas, use enteros [] aplique redondeo correcto. existe posibilidad una actualización concurrente, asegúrese implementar algún tipo mecanismo bloqueo. código, ambigüedad las imprecisiones son resultado desacuerdos indolencia. cualquier caso, elimínelas. : estructura sobre convención aplique las decisiones diseño con estructura convenciones. las convenciones nomenclatura son correctas pero resultan inferiores estructuras que refuerzan compatibilidad. por ejemplo, los casos switch con enumeraciones nombres correctos son inferiores clases base con abstractos. estamos obligados implementar siempre instrucción switch/case misma forma, pero las clases base hacen que las clases concretas implementen métodos abstractos. : encapsular condicionales lógica booleana difícil entender sin necesidad verla contexto una instrucción while . extraiga funciones que expliquen cometido condicional. por ejemplo: (shouldbedeleted(timer)) preferible (timer.hasexpired() && !timer.isrecurrent()) : evitar condicionales negativas las condicionales negativas son más difíciles entender que las positivas. por ello, siempre que sea posible, debe expresar las condiciones como positivas. por ejemplo: (buffer.shouldcompact()) preferible (!buffer.shouldnotcompact()) : las funciones sólo deben hacer una cosa tentador crear funciones con varias secciones que realicen una serie operaciones. este tipo funciones hacen más una cosa deben convertirse funciones menor tamaño, cada una para una cosa . por ejemplo: public void pay() { for (employee : employees) { (.ispayday()) { money pay = .calculatepay(); .deliverpay(pay); } } } este fragmento código realiza tres operaciones. itera por todos los empleados, comprueba cada uno debe recibir paga después paga empleado. podría reescribir esta forma: public void pay() { for (employee : employees) payifnecessary(); } private void payifnecessary(employee ) { (.ispayday()) calculateanddeliverpay(); } private void calculateanddeliverpay(employee ) { money pay = .calculatepay(); .deliverpay(pay); } cada una estas funciones hace una sola cosa (véase capítulo ). : conexiones temporales ocultas las conexiones temporales suelen ser necesarias pero debe ocultar conexión. estructure los argumentos sus funciones modo que orden invocación sea evidente. fíjese siguiente: public class moogdiver { gradient gradient; list<spline splines; public void dive(string reason) { saturategradient(); reticulatesplines(); diveformoog(reason); } … } orden las tres funciones importante. debe saturar degradado antes poder entrelazar las tiras, para después continuar. desafortunadamente, código aplica esta conexión temporal. otro programador podría invocar reticulatesplines antes saturategradient , que generaría unsaturatedgradientexception . una solución más acertada sería: class moogdiver { gradient gradient; list<spline splines; public void dive(string reason) { gradient gradient = saturategradient(); list<spline splines = reticulatesplines(gradient); diveformoog(splines, reason); } … } este modo muestra conexión temporal generando una especie embudo. cada función genera resultado que siguiente necesita modo que pueden invocar otro orden. puede argumentar que esto aumenta complejidad las funciones tiene razón, pero ese incremento complejidad sintáctica muestra verdadera complejidad temporal situación. observará que mantenido las variables instancia. imagino que son necesarias para los métodos privados las clases. incluso así, conservo los argumentos para que conexión temporal sea explícita. : evitar arbitrariedad argumente estructura código asegúrese que estructura del código comunica dicho argumento. estructura parece arbitraria, otros verán con derecho modificarla. estructura parece coherente totalidad del sistema, otros usarán conservarán convención. por ejemplo, recientemente repasaba cambios realizados fitnesse descubrí siguiente: public class aliaslinkwidget extends parentwidget { public static class variableexpandingwidgetroot { … … } problema que variableexpandingwidgetroot debía estar ámbito aliaslinkwidget . más, otras clases sin relación usaban aliaslinkwidget.variableexpandingwidgetroot tenían por qué saber aliaslinkwidget . puede que programador añadiera variableexpandingwidgetroot aliaswidget por comodidad que realmente pensara que debía formar parte del ámbito aliaswidget . independientemente del motivo, resultado será arbitrario. las clases públicas que son utilidades otra clase deben incluirse ámbito otra clase. convención convertirlas públicas nivel superior paquete. : encapsular condiciones límite las condiciones límite son difíciles controlar. aísle procesamiento permita que transfieran resto del código. necesitamos legiones + - por todas partes. fíjese este ejemplo fit: (level + < tags.length) { parts = new parse(body, tags, level + , offset + endtag); body = null; } level+ aparece dos veces. una condición límite que debe encapsularse una variable con nombre como nextlevel . int nextlevel = level + ; (nextlevel < tags.length) { parts = new parse(body, tags, nextlevel, offset + endtag); body = null; } : las funciones sólo deben descender nivel abstracción las instrucciones una función deben crearse mismo nivel abstracción, nivel por debajo operación descrita por nombre función. puede que sea heurística más difícil interpretar aplicar. aunque idea simple, como humanos nos cuesta mezclar niveles abstracción. fíjese siguiente código fitnesse: public string render() throws exception { html = new stringbuffer(“<”); (size ) html.append(“ size=\“”).append(size + ).append(“\””); html.append(“”); return html.tostring(); } analiza, verá que sucede. esta función crea etiqueta html que traza una regla horizontal por página. altura regla especifica variable size . fíjese otra vez código. este método mezcla menos dos niveles abstracción. primero noción que una regla horizontal tiene tamaño. segundo sintaxis propia etiqueta . código proviene del módulo hrulewidget fitnesse. este módulo detecta una fila cuatro más guiones convierte correspondiente etiqueta . cuantos más guiones haya, mayor será tamaño. continuación muestro refactorización del código. cambiado nombre del campo size para reflejar verdadero cometido. contenía número guiones adicionales. public string render() throws exception { htmltag = new htmltag(“”); (extradashes ) .addattribute(“size”, hrsize(extradashes)); return .html(); } private string hrsize(int height) { int hrsize = height + ; return string.format(“%”, hrsize); } este cambio separa correctamente los dos niveles abstracción. función render simplemente crea una etiqueta sin tener que saber nada sobre sintaxis html. módulo htmltag encarga los problemas sintácticos. hecho, realizar este cambio detecté sutil error. código original incluía barra final etiqueta , como haría estándar xhtml ( decir, generaba < lugar </ ). módulo htmltag había modificado hace tiempo para ajustarlo xhtml. separación niveles abstracción una las tareas más importantes refactorización, también una las más complejas. por ejemplo, fíjese siguiente código. fue primer intento separar los niveles abstracción del método hrulewidget.render . public string render() throws exception { htmltag = new htmltag(“”); (size ) { .addattribute (“size”, “”+(size+)); } return .html(); } objetivo, esta fase, crear separación necesaria conseguir superar las pruebas. objetivo alcancé fácilmente pero resultado fue una función con niveles abstracción mezclados. este caso, fueron obra etiqueta interpretación formato variable size. esto indica que dividir una función líneas abstracción, suelen aparecer nuevas líneas abstracción ocultas por estructura anterior. : mantener los datos configurables los niveles superiores tiene una constante como valor predeterminado configuración que conoce espera nivel superior abstracción, debe sepultarla una función nivel inferior. muéstrela como argumento para esa función nivel inferior invocado desde función nivel superior. fíjese este ejemplo fitnesse: public static void main(string[] args) throws exception { arguments arguments = parsecommandline(args); … } public class arguments { public static final string default_path = “.”; public static final string default_root = “fitnesseroot”; public static final int default_port = ; public static final int default_version_days = ; … } argumentos línea comandos analizan primera línea ejecutable fitnesse. los valores predeterminados dichos argumentos especifican inicio clase argument . tiene que buscar instrucciones como siguiente los niveles inferiores del sistema: (arguments.port == ) // usar forma predeterminada las constantes configuración encuentran nivel superior son fáciles cambiar. pasan resto aplicación. los niveles inferiores aplicación poseen los valores estas constantes. : evitar desplazamientos transitivos por general, recomendable que módulo sepa demasiado sobre sus colaboradores. concreto, colabora con con , queremos que los módulos que usan sepan nada sobre (por ejemplo, queremos .getb().getc().dosomething(); ). que ocasiones denomina ley demeter. los programadores pragmáticos denominan crear código silencioso [] . cualquier caso, trata garantizar que los módulos sólo tienen conocimiento sus colaboradores inmediatos del mapa navegación completo del sistema. varios módulos usan alguna variante instrucción .getb().getc() , sería complicado cambiar diseño arquitectura para intercalar entre . tendría que localizar todas las instancias .getb().getc() convertirlas .getb().getq().getc() . forma que las arquitecturas vuelven rígidas. demasiados módulos saben demasiado sobre arquitectura. por contrario, queremos que nuestros colaboradores intermedios ofrezcan todos los servicios que necesitamos. debemos deambular por gráfico objetos del sistema busca del método que necesitamos invocar. bastaría con poder usar: mycollaborator.dosomething(). java : evitar extensas listas importación mediante uso comodines usa dos más clases paquete, importe paquete completo con import package.*; las listas extensas importaciones intimidan lector. queremos colapsar parte superior los módulos con líneas importaciones, sino que sean una instrucción concisa los paquetes con los que colaboramos. las importaciones específicas son dependencias rígidas, mientras que las importaciones comodín . importa una clase concreta, esa clase debe existir, pero importa paquete con comodín, necesario que existan clases concretas. instrucción importación simplemente añade paquete ruta búsqueda localizar los nombres. por tanto, genera una verdadera dependencia estas importaciones permiten aligerar las conexiones nuestros módulos. ocasiones, lista extensa importaciones puede resultar útil. por ejemplo, tiene que trabajar con código legado desea saber para qué clases crear elementos ficticios, puede examinar lista importaciones concretas para determinar los verdaderos nombres cualificados todas esas clases después añadirlos. obstante, este uso las importaciones concretas habitual. más, muchos ide modernos permiten convertir las importaciones con comodines una lista importaciones concretas con solo comando. por tanto, incluso caso anterior, recomendable usar comodines. las importaciones comodín pueden probar conflictos nombres ambigüedades. dos clases con mismo nombre pero paquetes diferentes tienen que importarse forma concreta menos cualificarse forma específica cuando usen. puede resultar molesto pero habitual que uso importaciones comodín sea más indicado que importaciones concretas. : heredar constantes visto muchas veces siempre molesta. programador añade una interfaz después accede las mismas heredando dicha interfaz. fíjese siguiente código: public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } ¿ dónde salen las constantes tenths_per_week overtime_rate ? puede que provengan clase employee ; comprobémoslo: public abstract class employee implements payrollconstants { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } , ahí . ¿entonces dónde? fíjese atentamente clase employee . implementa payrollconstants . public interface payrollconstants { public static final int tenths_per_week = ; public static final double overtime_rate = .; } horrible. las constantes ocultan parte superior jerarquía herencia. use herencia para burlar las reglas ámbito del lenguaje. use una importación estática: import static payrollconstants.*; public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } : constantes frente enumeraciones ahora que han añadido enumeraciones lenguaje (java ), ¡úselas! recurra viejo truco public static final int . significado int puede perder. enum , que pertenece una enumeración con nombre. más, analice atentamente sintaxis las enumeraciones . pueden tener métodos campos, que las convierte potentes herramientas que ofrecen mayor expresividad flexibilidad que los int . fíjese esta variante del código: public class hourlyemployee extends employee { private int tenthsworked; hourlypaygrade grade; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( grade.rate() * (tenthsworked + overtime_rate * overtime) ); } … } public enum hourlypaygrade { apprentice { public double rate() { return .; } }, leutenant_journeyman ( public double rate() { return .; } }, journeyman { public double rate() { return .; } }, master { public double rate() { return .; } }; public abstract double rate(); } nombres : elegir nombres descriptivos sea demasiado rápido hora elegir nombre. asegúrese que sea descriptivo. recuerde que los significados suelen variar cuando código evoluciona, modo que debe revisar frecuentemente corrección los nombres elegidos. una recomendación sensaciones. software , los nombres constituyen por legibilidad. dedique tiempo seleccionarlos con atención mantenga relevancia. los nombres son demasiado importantes como para tratarlos mal. fíjese siguiente código. ¿para qué sirve? muestro mismo código con nombres bien elegidos, tendrá sentido, pero con este formato más que una masa símbolos números mágicos. public int () { int = ; int = ; for (int = ; < ; ++) { ([] == ) { += + ([ + ] + [ + ]); += ; } else ([] + [ + ] == ) { += + [ + ]; += ; } else { += [] + [ + ]; += ; } } return ; } continuación, código como debería haberse escrito. este fragmento realidad menos completo que anterior, pero detectará inmediatamente que intenta hacer probable que pudiera crear las funciones que faltan función ese significado que intuye. los números mágicos son estructura del algoritmo descriptiva atractiva: public int score() { int score = ; int frame = ; for (int framenumber = ; framenumber < ; framenumber++) { (isstrike(frame)) { score += + nexttwoballsforstrike(frame); frame += ; } else (isspare(frame)) { score += + nextballforspare(frame); frame += ; } else { score += twoballsinframe(frame); frame += ; } } return score; } los nombres bien elegidos inundan estructura del código con descripciones. dicha inundación define las expectativas del lector sobre cometido otras funciones del módulo. puede inferir implementación isstrike() fija código anterior. cuando lea método isstrike , será prácticamente que esperaba [] . private boolean isstrike(int frame) { return rolls[frame] = ; } : elegir nombres nivel correcto abstracción elija nombres que comuniquen implementación; seleccione nombres que reflejen nivel abstracción clase función con que trabaje. complicado. nuevo, nos cuesta mezclar niveles abstracción. siempre que realice una pasada por código, probable que encuentre una variable con nombre nivel demasiado bajo. cambie esos nombres cuando los vea. para que código sea legible necesita una mejora continua. fíjese siguiente interfaz modem : public interface modem { dial(string phonenumber); boolean disconnect(); boolean send(char ); char recv(); string getconnectedphonenumber(); } inicialmente parece correcta. las funciones parecen las adecuadas. hecho son para muchas aplicaciones, pero piense ahora una aplicación que algunos módems conecten mediante marcación telefónica, sino mediante cables (como los usados para conexiones domésticas internet). puede que algunos conecten enviando número puerto concentrador través una conexión usb. evidente que noción números teléfono encuentra nivel abstracción equivocado. una estrategia nomenclatura más adecuada para este caso sería siguiente: public interface modem { boolean connect(string connectionlocator); boolean disconnect(); boolean send(char ); char recv(); string getconnectedlocator(); } ahora los nombres limitan números teléfono. pueden usar para números teléfono para otros tipos estrategia conexión. : usar nomenclatura estándar siempre que sea posible los nombres son más fáciles entender basan una convención uso existente. por ejemplo, emplea patrón decorator , debería usar palabra decorator los nombres las clases. por ejemplo, autohangupmodemdecorator podría ser nombre una clase que permite módem colgar automáticamente final una sesión. los patrones son tipo estándar. java, por ejemplo, las funciones que convierten objetos representaciones cadena suelen tener nombre tostring . mejor seguir estas convenciones que inventar otras propias. los equipos suelen inventar propio sistema estándar nombres para proyecto concreto. eric evans denomina lenguaje omnipresente del [] . código debe usar los términos este lenguaje. definitiva, cuantos más nombres con significado especial relevante para proyecto utilice, más fácil será para los lectores saber qué trata código. : nombres inequívocos seleccione nombres que ilustren forma inequívoca funcionamiento funciones variables. fíjese este ejemplo fitnesse: private string dorename() throws exception { (refactorreferences) renamereferences(); renamepage(); pathtorename.removenamefromend(); pathtorename.addnametoend(newname); return pathparser.render(pathtorename); } nombre esta función indica qué hace, menos términos amplios sin concretar. además, refuerza por presencia función renamepage dentro función dorename . ¿qué indican los nombres sobre diferencia entre ambas funciones? nada. nombre más acertado para función sería renamepageandoptionallyallreferences . puede parecerle extenso, , pero sólo invoca desde punto del módulo, modo que valor descriptivo supera longitud. : usar nombres extensos para ámbitos extensos longitud nombre debe estar relacionada con ámbito. puede usar nombres variables breves para ámbitos diminutos pero ámbitos mayores debe emplear nombres extensos. los nombres variables como son correctos ámbito tiene cinco líneas longitud. fíjese siguiente fragmento del conocido juego los bolos: private void rollmany(int , int pins) { for (int =; <; ++) .roll(pins); } totalmente claro complicaría variable cambiara por algo como rollcount . por otra parte, las variables funciones con nombres breves pierden significado las grandes distancias. por tanto, cuanto mayor sea ámbito del nombre, más extenso preciso tendrá que ser nombre. : evitar codificaciones los nombres deben codificarse con información tipos ámbitos. prefijos como sirven nada los entornos actuales. además, codificaciones proyecto / subsistema como vis_ (para sistema imágenes visuales) distraen atención son redundantes. los entornos actuales proporcionan toda esa información sin tener que modificar los nombres. aleje sus nombres contaminación húngara. : los nombres deben describir efectos secundarios los nombres deben describir todo que haga una función, variable clase. oculte efectos secundarios con nombre. utilice simple verbo para describir una función que realiza algo más que una simple acción. fíjese este código testng: public objectoutputstream getoos() throws ioexception { (m_oos == null) { m_oos = new objectoutputstream(m_socket.getoutputstream()); } return m_oos; } esta función hace algo más que obtener oos ; crea todavía creado. por tanto, nombre más acertado sería createorreturnoos . pruebas (test) : pruebas insuficientes ¿cuántas pruebas debe incluir una suite pruebas? desafortunadamente, muchos programadores dirían que las que parezcan suficientes. una suite pruebas debe probar todo que pueda fallar. las pruebas son insuficientes mientras haya condiciones que hayan examinado cálculos que hayan validado. : usar una herramienta cobertura las herramientas cobertura indican vacíos estrategia pruebas. facilitan detección módulos, clases funciones insuficientemente probadas. muchos ide ofrecen indicador visual marcan verde las líneas cubiertas rojo las cubiertas. este modo más rápido sencillo detectar instrucciones catch cuyos cuerpos han comprobado. : ignorar pruebas triviales son fáciles redactar valor documental mayor que coste crearlas. : una prueba ignorada una pregunta sobre una ambigüedad ocasiones dudamos detalle comportamiento porque los requisitos son claros. podemos expresar nuestra duda sobre los requisitos forma prueba comentada como prueba anotada con @ignore . decisión depende ambigüedad sobre algo que compila . : probar condiciones límite especial atención las pruebas condiciones límite. solemos acertar con parte central algoritmo pero malinterpretar los límites. : probar forma exhaustiva junto los errores los errores suelen congregarse. detecta error una función, recomendable probarla forma exhaustiva. seguramente sea único error. : los patrones fallo son reveladores ocasiones diagnosticamos problema detectando patrones fallo los casos prueba. otro argumento para crear casos prueba más completos posibles. los casos prueba completos, ordenan forma razonable, revelan patrones. como ejemplo, imagine que detectado que todas las pruebas con entero mayor cinco caracteres fallan. que fallan todas las pruebas que pasan número negativo segundo argumento una función. ocasiones, con ver patrón rojos verdes informe pruebas basta para hacer saltar chispa llegar una solución. capítulo encontrará interesante ejemplo caso serialdate . : los patrones cobertura pruebas pueden ser reveladores análisis del código que ejecuta las pruebas superadas suele indicar porqué fallan las pruebas superadas. : las pruebas deben ser rápidas una prueba lenta ejecuta. cuando las cosas ponen feas, las pruebas lentas eliminan suite . por tanto, intente que sus pruebas sean . conclusión esta lista heurística síntomas podría considerar completa. hecho, dudo que alguna vez exista alguna. pero puede que ese sea objetivo, que que implica esta lista sistema valores. sistema valores sido objetivo base este libro. código limpio crea siguiendo una serie reglas. convertirá maestro del software aprendiendo una lista heurísticas. profesionalidad maestría provienen los valores que impulsan las disciplinas. bibliografía [refactoring] : refactoring: improving the design existing code , martin fowler ., addison-wesley, . [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, . [gof] : design patterns: elements reusable object oriented software , gamma ., addison-wesley, . [beck] : smalltalk best practice patterns , kent beck, prentice hall, . [beck] : implementation patterns , kent beck, addison-wesley, . [ppp] : agile software development: principles, patterns, and practices , robert . martin, prentice hall, . [ddd] : domain driven design , eric evans, addison-wesley, . concurrencia por brett . schuchert este apéndice complementa amplía capítulo sobre concurrencia. escrito como una serie temas independientes que puede leer orden que desee. algunas secciones están duplicadas para facilitar dicha lectura. ejemplo cliente/servidor imagine una sencilla aplicación cliente/servidor. servidor espera que cliente conecte. cliente conecta envía una solicitud. servidor continuación mostramos una versión simplificada una aplicación servidor. código completo este ejemplo recoge listado -. serversocket serversocket = new serversocket(); while (keepprocessing) { try { socket socket = serversocket.accept(); process(socket); } catch (exception ) { handle(); } } esta sencilla aplicación espera una conexión, procesa mensaje entrante vuelve esperar siguiente solicitud cliente. código cliente para conectarse servidor siguiente: private void connectsendreceive(int ) { try { socket socket = new socket (“localhost”, port); messageutils.sendmessage(socket, integer.tostring()); messageutils.getmessage(socket); socket.close(); } catch (exception ) { .printstacktrace(); } } ¿cómo comporta esta combinación cliente servidor? ¿cómo podemos describir formalmente ese rendimiento? siguiente prueba afirma que rendimiento aceptable: @test(timeout = ) public void shouldruninunder() throws exception { thread[] threads = createthreads(); startallthreadsw(threads); waitforallthreadstofinish(threads); } omite configuración para que ejemplo sea sencillo (véase “ clienttest.java ” más adelante). esta prueba afirma que debe completarse milisegundos. ejemplo clásico validación del rendimiento sistema. este sistema debe completar una serie solicitudes cliente segundos. mientras servidor pueda procesar cada solicitud cliente tiempo, prueba será satisfactoria. ¿qué sucede prueba falla? aparte desarrollar algún tipo bucle consulta eventos, hay mucho que hacer único proceso para aumentar velocidad este código. ¿ solucionaría problema con varios procesos? puede, pero necesitamos saber cómo consume tiempo. hay dos posibilidades: /: con socket, conectándose base datos, esperando intercambio memoria virtual, etc. procesador: cálculos numéricos, procesamiento expresiones , recolección elementos sin usar, etc. los sistemas suelen tener uno cada, pero para una operación concreta suele haber uno dominante. código vincula procesador, mayor cantidad hardware procesamiento puede mejorar rendimiento hacer que supere prueba, pero hay tantos ciclos cpu disponibles, modo que añadir procesos problema vinculado procesador hará que aumente velocidad. por otra parte, proceso está vinculado /, concurrencia puede aumentar eficacia. cuando una parte del sistema espera /, otra puede usar ese tiempo espera para procesar algo distinto, maximizando uso eficaz cpu disponible. añadir subprocesos imagine que prueba rendimiento falla. ¿cómo podemos mejorar producción para que prueba rendimiento sea satisfactoria? método process del servidor está vinculado /, existe una forma conseguir que servidor use subprocesos (basta con cambiar processmessage): void process (final socket socket) { (socket == null) return; runnable clienthandler = new runnable() { public void run() { try { string message = messageutils.getmessage(socket); messageutils.sendmessage(socket, “processed: ” + message); closeignoringexception(socket); } catch (exception ) { .printstacktrace(); } } }; thread clientconnection = new thread(clienthandler); clientconnection.start(); } asuma que este cambio hace que prueba supere [] ; código completo, ¿correcto? del servidor servidor actualizado completa satisfactoriamente prueba algo más segundo. desafortunadamente, solución genera ciertos problemas. ¿cuántos subprocesos podría crear nuestro servidor? código define límites modo que podríamos alcanzar impuesto por máquina virtual java (mvj), suficiente muchos sistemas sencillos. ¿pero sistema tiene que asumir multitud usuarios una red pública? conectan demasiados usuarios mismo tiempo, sistema podría colapsarse. pero dejemos temporalmente este problema comportamiento. solución mostrada tiene problemas limpieza estructura. ¿cuántas responsabilidades tiene código del servidor? administración conexiones. procesamiento clientes. política subprocesos. política cierre del servidor. desafortunadamente, todas estas responsabilidades encuentran función process . además, código cruza varios niveles diferentes abstracción. por tanto, pesar reducida función process , necesario dividirlo. existen varios motivos para cambiar servidor; por tanto, incumple principio responsabilidad única. para mantener limpieza sistema concurrente, administración subprocesos debe limitarse una serie puntos controlados. más, código que gestione los subprocesos únicamente debe encargarse gestión subprocesos. ¿por qué? existe otro motivo, control problemas concurrencia suficientemente complicado como para generar simultáneamente otros problemas relacionados con concurrencia. creamos una lista independiente para cada una las responsabilidades anteriores, incluyendo administración subprocesos, cambiar estrategia administración subprocesos, cambio tiene menor impacto sobre código contamina otras responsabilidades. este también más sencillo probar las demás responsabilidades sin necesidad preocuparse los subprocesos. veamos versión actualizada que encarga ello: public void run() { while (keepprocessing) { try { clientconnection clientconnection = connectionmanager.awaitclient(); clientrequestprocessor requestprocessor = new clientrequestprocessor(clientconnection); clientscheduler.schedule(requestprocessor); } catch (exception ) { .printstacktrace(); } } connectionmanager.shutdown(); } ahora centra mismo punto todos los aspectos relacionados con los subprocesos: clientscheduler . hay problemas concurrencia, bastará con examinar punto concreto: public interface clientscheduler { void schedule(clientrequestprocessor requestprocessor); } política actual fácil implementar: public class threadperrequestscheduler implements clientscheduler { public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; thread thread = new thread(runnable); thread.start(); } } tras aislar administración subprocesos, resulta más sencillo cambiar control los mismos. por ejemplo, para cambiar estructura executor java necesario crear una nueva clase conectarla (véase listado -). listado - .java. import java.util.concurrent.executor; import java.util.concurrent.executors; public class executorclientscheduler implements clientscheduler { executor executor; public executorclientscheduler(int availablethreads) { executor = executors.newfixedthreadpool(availablethreads); } public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; executor.execute(runnable); } } conclusión este ejemplo concreto, presencia concurrencia ilustra una forma mejorar producción sistema otra validar dicha producción través una estructura pruebas. centrar código concurrencia número reducido clases, aplicamos principio responsabilidad única. caso programación concurrente, resulta especialmente importante debido complejidad. posibles rutas ejecución repase método incrementvalue , método java una línea sin bucles ramificaciones: public class idgenerator { int lastidused; public int incrementvalue() { return ++lastidused; } } ignore desbordamiento enteros imagine que solamente accede una instancia idgenerator . este caso existe una sola ruta ejecución único resultado garantizado: valor devuelto igual valor lastidused , ambos son una unidad mayores que antes invocar método. ¿qué sucede usamos dos subprocesos cambiamos método? ¿cuáles son los posibles resultados cada subproceso invoca incrementvalue una vez? ¿cuántas rutas ejecución posibles hay? primero, los resultados (imagine que valor inicial lastidused ): primer subproceso obtiene valor , segundo valor lastidused . primer subproceso obtiene valor , segundo valor lastidused . primer subproceso obtiene valor , segundo valor lastidused . resultado final, aunque sorprendente, posible. para ver los distintos resultados, debemos comprender las diferentes rutas ejecución posibles cómo las ejecuta mvj. número rutas para calcular número rutas ejecución posibles, comenzaremos con código bytes generado. única línea java ( return ++lastidused; ) convierte ocho instrucciones código bytes . los dos subprocesos pueden intercambiar ejecución estas ocho instrucciones del mismo modo que mezclamos las cartas una baraja [] . incluso con sólo ocho cartas cada mano, número posibles resultados sorprendente. para este sencillo caso instrucciones una secuencia, sin bucles condicionales subprocesos, número total posibles rutas ejecución igual : ()! ! calcular las órdenes posibles extraído correo electrónico uncle bob brett: con pasos subprocesos hay * pasos totales. antes cada paso hay conmutador contexto que elige entre los subprocesos. por tanto, cada ruta representa como una cadena dígitos que denota los cambios contexto. dados los pasos los subprocesos , las seis rutas posibles son , , , , . , términos pasos, , , , , . para tres subprocesos, secuencia sería , , , , , , , , , … una característica estas cadenas que siempre debe haber instancias cada . por tanto, cadena válida que tiene seis instancias ninguna . por tanto, necesitamos las permutaciones , … . realidad son las permutaciones * tomando cada vez * , que ( * )! , pero sin los duplicados. por tanto, truco consiste contar los duplicados restarlos ( * )! . dados dos pasos dos subprocesos, ¿cuántos duplicados hay? cada cadena cuatro dígitos tiene dos dos . estos pares pueden intercambiar sin modificar sentido cadena. podríamos intercambiar los los , ninguno. por tanto hay cuatro isomorfas por cada cadena, que significa que hay tres duplicados, modo que tres las cuatro opciones son duplicados; por otra parte, una las cuatro permutaciones son duplicados. ! * . = . este razonamiento parece funcionar. ¿cuántos duplicados hay? = = , podría intercambiar los , los , ambos. caso = = , podría intercambiar los , los , los , , , . intercambio son las permutaciones . imagine que hay permutaciones . número formas diferentes organizar dichas permutaciones ** . por tanto número isomorfas posibles !** . número rutas ( * )!/( !** ). nuevo, nuestro caso = , = obtenemos (/). para = = obtenemos / = . para = = obtenemos !/^ = . nuestro sencillo caso una sola línea código java, que equivale ocho líneas código bytes dos subprocesos, número total posibles rutas ejecución . tipo lastidused long , cada lectura escritura convierte dos operaciones una, número posibilidades asciende . ¿qué sucede realizamos cambio este método? synchronized void incrementvalue() { ++lastidused; } número posibles rutas ejecución dos para dos subprocesos ! para caso general. examen más profundo ¿qué piensa del sorprendente resultado dos subprocesos que invoquen método una vez (antes añadir synchronized ) obtengan mismo resultado numérico? ¿cómo posible? vayamos por partes. ¿qué una operación atómica? podemos definir una operación atómica como toda operación ininterrumpible. por ejemplo, siguiente código, línea , donde asigna lastid , atómica que acuerdo modelo memoria java, asignación valor bits ininterrumpible. : public class example { : int lastid; : : public void resetid() { : value = ; : } : : public int getnextid() { : ++value; : } : } ¿qué sucede cambiamos tipo lastid int long ? ¿sigue siendo atómica línea ? acuerdo especificación mvj. podría ser atómica procesador concreto, pero según especificación mvj, asignación valor bits requiere dos asignaciones bits. esto significa que entre primera segunda podría irrumpir otro subproceso cambiar uno los valores. ¿ qué sucede con operador preincremento, ++ , línea ? este operador puede interrumpir, modo que atómico. para entenderlo, repasemos código bytes ambos métodos. antes continuar, hay tres definiciones importantes: : invocación método requiere marco, cual incluye dirección devolución, los parámetros pasados método las variables locales definidas mismo. una técnica estándar empleada para definir una pila invocaciones, que usa muchos lenguajes modernos para permitir invocación funciones métodos básicos, además invocaciones recursivas. variable local: las variables definidas ámbito del método. todos los métodos estáticos tienen menos una variable, this , que representa objeto actual, objeto que recibido último mensaje ( subproceso actual) que propiciado invocación del método. pila operandos: muchas instrucciones mvj aceptan parámetros. pila operandos donde incluyen dichos parámetros. pila una estructura datos lifo ( last-, first-out último entrar, primero salir) estándar. veamos código bytes generado para resetid(). nemónico descripción pila operandos posterior aload cargar variable pila operandos. ¿qué variable ? this. , objeto actual. invocar método, receptor del mensaje, una instancia example , envía matriz variables locales del marco creado para invocación métodos. siempre primera variable que añade todos los métodos instancia. this iconst_ incluir valor constante pila operandos. this, putfield lastid almacenar valor superior pila () valor campo del objeto denominado por referencia objeto una posición alejada parte superior pila, this . <vacío tres instrucciones son atómicas que pesar que subproceso que las ejecuta podría verse interrumpido por cualquiera ellas, información para instrucción putfield ( valor constante parte superior pila referencia éste una posición inferior, junto con valor del campo) alterada por ningún otro subproceso. por tanto, producirse asignación, sabemos que valor almacena valor del campo. operación atómica. todos los operandos procesan información local del método, modo que hay interferencias entre subprocesos. estas instrucciones ejecutan diez subprocesos, hay .+ ordenaciones posibles. sin embargo, sólo hay resultado posible, modo que las distintas ordenaciones son irrelevantes. además, garantiza mismo resultado para valores long este caso. ¿por qué? los diez subprocesos asignan valor constante. aunque entremezclen, resultado final será mismo. habrá problemas con operación ++ método getnextid . imagine que lastid contiene inicio este método. veamos código bytes este nuevo método: nemónico descripción pila operandos posterior aload cargar this pila operandos. this dup copiar parte superior pila. ahora tenemos dos copias this pila operandos. this, this getfield lastid recuperar valor del campo lastid del objeto que apunta parte superior pila ( this ) volver almacenar valor pila. this, iconst_ desplazar constante entera pila. this, , iadd suma entera los dos valores superiores pila operandos volver almacenar resultado pila. this, dup_x duplicar valor añadirlo delante this . , this, putfield almacenar valor superior pila operandos, , valor campo del objeto actual, representado por siguiente valor superior pila operandos, this . ireturn devolver valor superior ( único) pila operandos. <vacío imagine que primer subproceso completa las tres primeras instrucciones, hasta getfield incluida después interrumpe. aparece segundo subproceso ejecuta método completo, incrementando lastid uno; devuelve . tras ello, primer subproceso retoma desde donde detuvo; sigue pila operandos por ser valor lastid cuando ejecutó getfield . suma uno para obtener almacena resultado. valor también devuelve primer subproceso. como resultado, uno los incrementos pierde que primer subproceso interfiere con segundo después que éste haya interrumpido primero. convertir método getnextid() synchronized corrige este problema. conclusión necesita conocimiento extenso del código bytes para entender cómo unos subprocesos interrumpen otros. consigue entender este ejemplo, demostrará posibilidad varios subprocesos entrelazados, conocimiento suficiente. dicho esto, que este sencillo ejemplo revela necesidad entender modelo memoria para saber qué permite qué . equivocadamente piensa que operador ++ (pre postincremento) atómico, evidentemente . esto significa que tiene que saber: dónde están los objetos valores compartidos. código que provoca problemas lectura/actualización concurrente. cómo evitar que produzcan dichos problemas. biblioteca estructura executor como mostramos executorclientscheduler.java , estructura executor java permite ejecución sofisticada por medio agrupaciones subprocesos. una clase del paquete java.util.concurrent . crear subprocesos usa una agrupación subprocesos utiliza una creada mano, considere uso executor. hace que código sea más limpio, más fácil entender menor tamaño. estructura executor agrupa subprocesos, los cambia automáticamente tamaño los vuelve crear necesario. también admite futuros , una construcción programación concurrente habitual. estructura executor funciona con clases que implementan runnable también con clases que implementan interfaz callable . callable parece runnable , pero puede devolver resultado, una necesidad habitual soluciones múltiples subprocesos. futuro resulta muy útil cuando código tiene que ejecutar varias operaciones independientes esperar que terminen: public string processrequest(string message) throws exception { callable<string makeexternalcall = new callable<string() { public string call() throws exception { string result = “”; // realizar solicitud externa return result; } }; future<string result = executorservice.submit(makeexternalcall); string partialresult = dosomelocalprocessing(); return result.get() + partialresult; } este ejemplo, método comienza ejecutar objeto makeexternalcall , prosigue con otro procesamiento última línea invoca result.get(), que bloquea hasta que futuro termina. bloqueantes java aprovecha diseño los procesadores modernos que admiten actualizaciones fiables bloqueantes. imagine una clase que usa sincronización ( por tanto bloqueo) para proporcionar actualización compatible con subprocesos valor: public class objectwithvalue { private int value; public void synchronized incrementvalue() { ++value; } public int getvalue() { return value; } } java dispone varias clases nuevas para este tipo situaciones, como por ejemplo atomicboolean , atomicinteger atomicreference . podemos modificar código anterior para usar enfoque bloqueante: public class objectwithvalue { private atomicinteger value = new atomicinteger(); public void incrementvalue() { value.incrementandget(); } public int getvalue() { return value.get(); } } aunque use objeto lugar una primitiva envíe mensajes como incrementandget() lugar ++ , rendimiento esta clase supera mayoría los casos versión anterior. algunos casos será ligeramente más rápido pero los casos los que más lento son prácticamente inexistentes. ¿cómo posible? los procesadores modernos disponen una operación denominada cas (compare and swap, comparar intercambiar). una operación similar bloqueo optimista una base datos, mientras que versión sincronizada similar bloqueo pesimista. palabra clave synchronized siempre adquiere bloqueo, incluso cuando segundo subproceso intenta actualizar mismo valor. aunque rendimiento los bloqueos intrínsecos mejorado con respecto versiones anteriores, sigue siendo muy costoso. versión bloqueante asume inicialmente que varios subprocesos mismo valor con suficiente periodicidad como para generar problema. por contrario, detecta forma eficaz produce dicha situación reintenta hasta que actualización satisfactoria. esta detección suele ser menos costosa que adquisición bloqueo, incluso situaciones contención moderada alta. ¿cómo hace ? operación cas atómica. por tanto, operación cas tiene este aspecto: int variablebeingset; void simulatenonblockingset (int newvalue) { int currentvalue; { currentvalue = variablebeingset } while(currentvalue != compareandswap(currentvalue, newvalue)); } int synchronized compareandswap(int currentvalue, int newvalue) { (variablebeingset == currentvalue) { variablebeingset = newvalue; return currentvalue; } return variablebeingset; } cuando método intenta actualizar una variable compartida, operación cas comprueba que variable establecida sigue teniendo último valor conocido. caso afirmativo, cambia variable. caso contrario, variable establece que otro subproceso conseguido acceder. método que realiza intento (mediante operación cas) que cambio realizado intenta nuevo. clases incompatibles con subprocesos existen clases que son compatibles con subprocesos, como las siguientes: simpledateformat . conexiones base datos. contenedores java.util . . algunas clases colección tienen métodos concretos compatibles con subprocesos. sin embargo, cualquier operación que invoque más método . por ejemplo, quiere reemplazar algo hashtable porque existe, podría crear siguiente código: (!hashtable.containskey(somekey)) { hashtable.put(somekey, new somevalue()); } cada uno los métodos compatible con subprocesos. sin embargo, otro subproceso podría añadir valor entre las invocaciones containskey put . existen varias formas solucionar este problema: bloquear primero hashtable comprobar que los demás usuarios hashtable hagan mismo; bloqueo basado clientes: synchronized(map) { (!map.containskey(key)) map.put(key,value); } envolver hashtable propio objeto usar dos api distintas; bloqueo basado servidores con adaptador: public class wrappedhashtable<, { private map<, map = new hashtable<, (); public synchronized void putifabsent( key, value) { (map.containskey(key)) map.put(key, value); } } usar colecciones compatibles con subprocesos: concurrenthashmap<integer, string map = new concurrenthashmap<integer, string(); map.putifabsent(key, value); las colecciones java.util.concurrent incluyen operaciones como putifabsent() para acomodar este tipo operaciones. dependencias entre métodos pueden afectar código concurrente siguiente ejemplo una forma añadir dependencias entre métodos: public class integeriterator implements iterator<integer private integer nextvalue = ; public synchronized boolean hasnext() { return nextvalue < ; } public synchronized integer next() { (nextvalue == ) throw new iteratorpastendexception(); return nextvalue++; } public synchronized integer getnextvalue() { return nextvalue; } } veamos otro código que usa integeriterator : integeriterator iterator = new integeriterator(); while(iterator.hasnext()) { int nextvalue = iterator.next(); // hacer algo con nextvalue } subproceso ejecuta este código habrá problemas. ¿qué sucede dos subprocesos intentan compartir una misma instancia integeriterator para procesar valor que reciba cada uno pero cada elemento lista sólo procesa una vez? mayoría los casos, hay consecuencias negativas; los subprocesos comparten lista, procesan los elementos devueltos por iterador detienen cuando éste termina. sin embargo, existe posibilidad que final iteración los dos subprocesos interfieran entre ellos provoquen que uno supere final del iterador genere una excepción. problema siguiente: subproceso pregunta hasnext() , que devuelve true . subproceso evita subproceso realiza misma pregunta, que sigue siendo true . tras ello, subproceso invoca next() , que devuelve valor, como era esperar, pero como efecto secundario que hasnext() devuelva false . vuelve iniciar subproceso , pensando que hasnext() sigue siendo true , después invoca next() . aunque los métodos concretos están sincronizados, cliente usa dos métodos. problema real ejemplo que puede surgir código concurrente. este caso concreto, problema especialmente sutil que única ocasión que produce fallo durante iteración final del iterador. los subprocesos dividen forma correcta, puede que uno supere final del iterador. tipo error que surge sistema que lleva tiempo producción, difícil detectar. tiene tres opciones: tolerar fallo. solucionar problema cambiando cliente: bloqueo basado cliente. solucionar problema cambiando servidor, que también provoca que cambie cliente: bloqueo basado servidor. tolerar fallo ocasiones, los sistemas configuran para que fallo produzca daños. por ejemplo, cliente anterior podía capturar excepción limpiarla, aunque sería tanto torpe. como limpiar fugas memoria reiniciando medianoche. bloqueo basado cliente para que integeriterator funcione correctamente con varios subprocesos, cambie cliente ( los demás) como indica continuación: integeriterator iterator = new integeriterator(); while (true) { int nextvalue; synchronized (iterator) { (!iterator.hasnext()) break; nextvalue = iterator.next(); } dosometingwith(nextvalue); } cada cliente añade bloqueo través palabra clave synchronized . esta duplicación incumple principio dry, pero puede ser necesaria código usa agrupaciones terceros compatibles con subprocesos. estrategia arriesgada que todos los programadores que usen servidor deben acordarse bloquearlo antes usarlo desbloquearlo cuando terminen. hace muchos años, trabajé sistema que usaba bloqueo basado cliente recurso compartido. recurso usaba cientos puntos distintos del código. pobre programador olvidó bloquear recurso uno esos puntos. era sistema varios terminales con software contabilidad para sindicato transportistas. local . ordenador encontraba una sala temperatura controlada piso elevado, unas millas norte sede local . sede, decenas trabajadores introducían datos las terminales, conectadas ordenador mediante líneas telefónicas dedicadas módem semidúplex (esto fue hace mucho , mucho tiempo). una vez día, una las terminales bloqueaba, sin razón aparente. bloqueo tenía preferencia alguna por una terminal una hora concreta. como alguien echara suertes terminal que bloquear hora del bloqueo. ocasiones, bloqueaba más una terminal. ocasiones, podían pasar varios días sin bloqueos. inicialmente, optó por reiniciar como solución, pero era complicado coordinar los reinicios. tenemos que avisar sede esperar que todos terminaran que estuvieran haciendo todas las terminales. tras ello, apagaba sistema reiniciaba. alguien estaba haciendo algo importante para que necesitaba una dos horas, terminal bloqueada tenía que seguir bloqueada. tras varias semanas depuración, descubrimos que causa era contador búfer circular desincronizado con puntero. este búfer controlaba salida terminal. valor del puntero indicaba que búfer estaba vacío pero contador mostraba que estaba lleno. como estaba vacío, había nada que mostrar; pero como también estaba lleno, podía añadir nada búfer que mostrar pantalla. qué era que bloqueaba las terminales pero qué provocaba desincronización del búfer circular, por que añadimos truco para resolver problema. podían leer los conmutadores del panel frontal ordenador (esto fue hace mucho, mucho, mucho tiempo). diseñamos una función trampa que detectaba uno los conmutadores había generado después buscábamos búfer circular que estuviera tanto lleno como vacío. encontrábamos, variábamos. ¡ voilá ! terminal bloqueada volvía funcionar. este modo era necesario reiniciar sistema una terminal bloqueaba. sede nos llamaba nos decía que había bloqueo, nos acercábamos hasta sala ordenadores pulsábamos conmutador. ocasiones ellos trabajan los fines semana pero nosotros . por ello, añadimos una función programador que comprobaba los búfer circulares una vez por minuto restablecía los que estuvieran tanto llenos como vacíos. este modo descongestionaban las pantallas antes que dirección llegara teléfono. necesitamos varias semanas análisis código lenguaje ensamblado antes localizar culpable. habíamos calculado que frecuencia los bloqueos debía uso desprotegido del búfer circular, así que sólo era necesario determinar uso fallido. desafortunadamente, esto fue hace mucho tiempo disponíamos herramientas búsqueda, referencias cruzadas otras técnicas automáticas ayuda. teníamos que escudriñar los listados. aquel frío invierno chicago aprendí que los bloqueos basados cliente son verdaderamente terribles. bloqueo basado servidor duplicación puede eliminar modificamos integeriterator esta forma: public class integeriteratorserverlocked { private integer nextvalue = ; public synchronized integer getnextornull() { (nextvalue < ) return nextvalue++; else return null; } } también cambia código cliente: while (true) { integer nextvalue = iterator.getnextornull(); (next == null) break; // hacer algo con nextvalue } este caso, realidad cambiamos api clase para que sea compatible con subproceso [] . cliente debe realizar una comprobación null lugar comprobar hasnext() . por general, bloqueo basado servidor preferible por estos motivos: reduce código repetido: bloqueo basado servidor hace que cliente bloquee correctamente servidor. incluir código bloqueo servidor, libera los clientes para usar objeto tener que preocuparse crear código bloqueo adicional. permite mejor rendimiento: puede intercambiar servidor compatible con subprocesos por otro incompatible caso desarrollo solo subproceso, que evita sobrecarga. reduce las posibilidades error: sólo necesita programador que olvide del bloqueo. aplica una única política: política aplica solamente servidor, todos los clientes. reduce ámbito las variables compartidas: cliente las desconoce tampoco sabe cómo bloquean. todo oculta servidor. cuando produce fallo, origen busca menos puntos. ¿ propietario del código servidor? usar adaptador para cambiar api añadir bloqueo public class threadsafeintegeriterator { private integeriterator iterator = new integeriterator(); public synchronized integer getnextornull() { (iterator.hasnext()) return iterator.next(); return null; } } mejor todavía, usar colecciones compatibles con subprocesos con interfaces ampliadas. aumentar producción imagine que desea leer contenido una serie páginas una lista url red. leer cada página, analizamos para acumular estadísticas. después leer todas, imprimimos informe resumen. siguiente clase devuelve contenido una página, dada una url. public class pagereader { //… public string getpagefor(string url) { httpmethod method = new getmethod(url); try { httpclient.executemethod(method); string response = method.getresponsebodyasstring(); return response; } catch (exception ) { handle(); } finally { method.releaseconnection(); } } } siguiente clase iterador que proporciona contenido las páginas función iterador url: public class pageiterator { private pagereader reader; private urliterator urls; public pageiterator(pagereader reader, urliterator urls) { this.urls = urls; this.reader = reader; } public synchronized string getnextpageornull() { (urls.hasnext()) getpagefor(urls.next()); return null; } public string getpagefor(string url) { return reader.getpagefor(); } } puede compartir una instancia pageiterator entre varios subprocesos distintos, cada uno con propia instancia pagereader para leer las páginas que obtiene del iterador. hemos reducido tamaño del bloque synchronized . simplemente contiene sección crítica pageiterator . siempre conviene sincronizar menos posible. cálculo producción solo subproceso vayamos con los cálculos. imagine siguiente, acuerdo argumento anterior: tiempo / para recuperar una página ( media): segundo. tiempo procesamiento para analizar página ( media): . segundos. / requiere por cpu mientras que procesamiento requiere por . procesan páginas mismo subproceso, tiempo ejecución total . segundos * . figura . puede ver una instantánea páginas, aproximadamente . segundos. figura .. único subproceso producción con varios subprocesos pueden recuperar páginas cualquier orden procesarlas forma independiente, entonces posible usar varios subprocesos para aumentar producción. ¿qué sucede usamos tres subprocesos? ¿cuántas páginas podemos obtener mismo tiempo? como aprecia figura ., solución con varios procesos permite que análisis las páginas vinculado proceso solape con lectura las mismas, vinculada /. mundo ideal, significaría que procesador utiliza totalmente. cada lectura página por segundo solapa con dos análisis. por tanto, podemos procesar dos páginas por segundo, que triplica producción solución con solo proceso. figura .. tres subprocesos concurrentes. bloqueo mutuo imagine una aplicación web con dos agrupaciones recursos compartidos tamaño finito: una agrupación conexiones base datos para tareas locales almacenamiento procesos. agrupación conexiones repositorio principal. imagine que hay dos operaciones aplicación: crear actualizar: crear: adquirir una conexión repositorio principal base datos. comunicarse con repositorio principal después almacenar trabajo local base datos procesos. actualizar: adquirir una conexión base datos después repositorio principal. leer trabajo base datos enviarlo repositorio principal. ¿qué sucede con los usuarios que superan tamaño agrupación? imagine que tamaño cada agrupación . usuarios intentan usar crear, modo que adquieren diez conexiones base datos cada subproceso interrumpe después esta adquisición pero antes adquirir una conexión repositorio principal. usuarios intentan usar actualizar, modo que adquieren las diez conexiones repositorio principal cada subproceso interrumpe después adquirir repositorio principal pero antes adquirir una conexión base datos. ahora los subprocesos crear deben esperar adquirir una conexión repositorio principal pero los subprocesos actualizar deben esperar adquirir una conexión base datos. bloqueo mutuo. sistema recupera nunca. puede parecerle una situación improbable pero ¿quién desea sistema que colapsa cada semana? ¿quién quiere depurar sistema con síntomas tan difíciles reproducir? tipo problema que tarda semanas resolverse. una solución habitual consiste añadir instrucciones depuración para determinar qué sucede. evidentemente, estas instrucciones cambian tanto código que bloqueo mutuo genera otras situaciones tarda meses producirse [] . para solucionar realmente problema del bloqueo absoluto, debemos entender sus causas. para que produzca, deben darse cuatro condiciones: exclusión mutua. bloqueo espera. expropiación. espera circular. exclusión mutua exclusión mutua produce cuando varios subprocesos deben usar los mismos recursos dichos recursos pueden usar varios subprocesos mismo tiempo. son número limitado. ejemplo típico este tipo recurso una conexión base datos, archivo abierto para escritura, bloqueo registro semáforo. bloqueo espera cuando subproceso adquiere recurso, libera hasta adquirir los demás recursos que necesita terminar trabajo. expropiación subproceso puede adueñarse los recursos otro. cuando subproceso obtiene recurso, única forma que otro consiga que primero libere. espera circular denomina abrazo mortal. imagine dos subprocesos, , dos recursos, . tiene , tiene . también necesita también necesita . similar diagrama figura .: figura .. estas cuatro condiciones deben cumplirse para que produzca bloqueo mutuo. incumple alguna ellas, producirá. evitar exclusión mutua una estrategia para evitar bloqueo mutuo impedir condición exclusión mutua, por medio siguiente: usar recursos que permitan uso simultáneo, como por ejemplo, atomicinteger . incrementar número recursos para que sea igual mayor que número subprocesos implicados. comprobar que todos los recursos están libres antes adquirir ninguno. desafortunadamente, mayoría recursos son limitados permiten uso simultáneo, habitual que identidad del segundo recurso base los resultados operar sobre primero, pero desanime, todavía tres condiciones. evitar bloqueo espera también puede eliminar bloqueo mutuo rechaza espera. compruebe cada uno los recursos antes obtenerlos libere todos los recursos comience nuevo detecta uno que esté ocupado. este enfoque genera algunos problemas: inanición: subproceso consigue adquirir los recursos que necesita (puede que tenga una combinación exclusiva recursos que casi nunca esté disponible). bloqueo activo: varios subprocesos pueden actuar unísono, adquirir recurso liberarlo, forma repetida. especialmente probable algoritmos programación cpu simples (como dispositivos incrustados algoritmos equilibrio subprocesos escritos mano). ambos casos, puede reducir producción. primero reduce utilización cpu, mientras que segundo genera una elevada utilización cpu sin sentido. aunque esta estrategia parezca ineficaz, mejor que nada. como ventaja, siempre puede implementar todo demás falla. evitar expropiación otra estrategia para evitar bloqueo mutuo consiste permitir que todos los subprocesos apropien los recursos otros. suele realizarse través sencillo mecanismo solicitudes. cuando subproceso descubre que hay recurso ocupado, solicita propietario que libere. propietario también espera otro recurso, libera comienza nuevo. similar enfoque anterior, pero, como ventaja, subproceso puede esperar recurso, que reduce número reinicios. sin embargo, gestión todas estas solicitudes puede resultar complicada. espera circular enfoque más habitual para impedir bloqueo mutuo. mayoría sistemas, basta con una sencilla convención acordada entre ambas partes. ejemplo anterior del subproceso que quiere tanto recurso como , subproceso que desea tanto recurso como , forzar ambos subprocesos que asignen los recursos mismo orden imposibilita espera circular. general, todos los subprocesos pueden acordar orden global los recursos todos asignan los recursos ese orden, bloqueo mutuo imposible. pero como todas las estrategias, también pueden producir problemas: orden adquisición puede corresponderse orden uso; por tanto, recurso adquirido inicio puede que use hasta final. esto puede bloquear recursos más tiempo estrictamente necesario. ocasiones puede imponer orden adquisición recursos. del segundo recurso proviene una operación realizada primero, ese orden factible. por tanto, existen varias formas evitar bloqueo mutuo. algunas provocan inanición, mientras que otras usan cpu exceso reducen capacidad respuesta. ¡ tanstaafl ! [] aislamiento parte relacionada con subprocesos solución para permitir ajustes experimentación una forma aprender determinar las estrategias óptimas. probar código con múltiples subprocesos ¿cómo puede crear una prueba que demuestre que siguiente código correcto? : public class classwiththreadingproblem { : int nextid; : : public int takenextid() { : return nextid++; : } : } veamos descripción una prueba que demuestre: recordar valor actual nextid . crear dos subprocesos que cada uno invoque takenextid() una vez. comprobar que valor nextid dos más que inicial. ejecutar hasta demostrar que nextid sólo incrementado uno dos. listado - reproduce prueba: listado - classwiththreadingproblemtest.java. : package example; : : import static org.junit.assert.fail; : : import org.junit.test; : : public class classwiththreadingproblemtest { : @test : public void twothreadsshouldfaileventually() throws exception { : final classwiththreadingproblem classwiththreadingproblem = new classwiththreadingproblem(); : : runnable runnable = new runnable() { : public void run() { : classwiththreadingproblem.takenextid(); : } : }; : : for (int = ; < ; ++) { : int startingid = classwiththreadingproblem.lastid; : int expectedresult = + startingid; : : thread = new thread(runnable); : thread = new thread(runnable); : .start(); : .start(); : .join(); : .join(); : : int endingid = classwiththreadingproblem.lastid; : : (endingid != expectedresult) : return; : } : : fail(“should have exposed threading issue but did not.”); : } : } línea descripción crear una sola instancia classwiththreadingproblem . debemos usar palabra clave final que usa después una clase interna anónima. - crear una clase interna anónima que use instancia classwiththreadingproblem . ejecutar este código hasta demostrar que falla, pero tanto como para que prueba tarde demasiado. acto equilibrio; queremos esperar demasiado para demostrar fallo. elegir cantidad ejecuciones complicado, aunque como veremos después, esta cifra puede reducir considerablemente. recordar valor inicial, prueba intenta demostrar que código classwiththreadingproblem incorrecto. supera prueba, habrá demostrado. prueba falla, habrá sido incapaz demostrarlo. esperamos que valor final sea dos más que actual. - crear dos subprocesos que usen objeto creado las líneas -. este modo contamos con dos posibles subprocesos que intentan usar nuestra instancia classwiththreadingproblem ambos interfieren entre . - hacer que los dos subprocesos puedan ejecutar. - esperar que terminen los dos subprocesos antes comprobar los resultados. registrar valor final. - ¿ diferente endingid que esperábamos? caso afirmativo, finaliza prueba; hemos demostrado que código incorrecto. caso negativo, volver intentarlo. hemos llegado hasta aquí, prueba podido demostrar que código producción era incorrecto una cantidad tiempo razonable; código fallado. incorrecto hemos realizado suficientes iteraciones para que produzca condición fallo. esta prueba establece las condiciones problema actualización concurrente. sin embargo, problema tan infrecuente que mayoría las veces prueba detecta. realidad, para detectar problema debemos establecer número iteraciones más millón. incluso con esa cantidad, diez ejecuciones bucle , problema sólo apareció una vez, que significa que debemos aumentar las iteraciones para obtener fallos fiables. ¿cuánto estamos dispuestos esperar? aunque ajustáramos prueba para obtener fallos fiables equipo, seguramente tendríamos que ajustarla con otros valores para ilustrar fallo otro equipo, sistema operativo versión mvj. problema sencillo . podemos demostrarlo, ¿qué pasará cuando detectemos problemas realmente complejos? ¿qué enfoques debemos adoptar para demostrar este sencillo fallo? , sobre todo, ¿cómo podemos crear pruebas que demuestren fallos código más complejo? ¿cómo podremos saber código tiene fallos cuando siquiera sabemos dónde buscar? veamos algunas sugerencias: pruebas monte carlo: crear pruebas flexibles que puedan ajustar. después, ejecutarlas repetidamente, por ejemplo, servidor prueba, cambiar los valores ajuste aleatoriamente. las pruebas , código incorrecto. diseñe las pruebas las fases iniciales para que servidor integración continua las ejecute antes posible. registre las condiciones fallo las pruebas. ejecutar prueba todas las plataformas desarrollo: forma repetida continuada. cuanto más tiempo ejecuten las pruebas sin fallos, más probable que código producción sea correcto las pruebas sean adecuadas para revelar los problemas. ejecutar las pruebas equipo con distintas cargas: puede simular cargas similares las del entorno producción, hágalo. sin embargo, aunque realice todos estos pasos, probable que detecte problemas subprocesos código. los problemas más complicados son los que sólo producen una vez cada mil millones oportunidades. son azote los sistemas complejos. herramientas para probar código basado subprocesos ibm creado herramienta contest [] . que hace instrumentar las clases para aumentar las probabilidades que falle código sin subprocesos. tenemos relación directa con ibm con equipo que desarrollado contest. colega nos descubrió. tras varios minutos usarla, notamos una gran mejoría detección errores. continuación, indicamos cómo usar contest: crear pruebas código producción, asegurándonos que haya pruebas diseñadas específicamente para simular varios usuarios con diferentes cargas, como mencionamos antes. instrumentar código pruebas producción con contest. ejecutar las pruebas. instrumentar código con contest, tasa éxito pasó fallo por cada millón iteraciones fallo iteraciones. los valores bucle las distintas ejecuciones prueba tras instrumentación son los siguientes: , , , , , , , , , , . evidentemente, las clases instrumentadas fallaban antes con mayor fiabilidad. conclusión este capítulo hemos realizado breve recorrido por vasto complejo territorio programación concurrente. apenas hemos mostrado superficie. nos hemos centrado disciplinas para mantener limpieza del código concurrente, pero hay mucho más que aprender tiene pensado diseñar sistemas concurrentes. recomendamos que empiece por libro doug lea concurrent programming java: design principles and patterns [] . este capítulo hemos presentado actualización concurrente las disciplinas sincronización bloqueo para evitarla. hemos visto cómo los subprocesos pueden mejorar producción sistema vinculado / las técnicas limpias para lograr dichas mejoras. hemos descrito bloqueo mutuo las disciplinas para evitarlo forma limpia. por último, hemos analizado estrategias para mostrar problemas concurrencia mediante instrumentación del código. ejemplos código completos cliente/servidor sin subprocesos listado - server.java package com.objectmentor.clientserver.nonthreaded; java..ioexception; import java.net.serversocket; import java.net.socket; import java.net.socketexception; import common.messageutils; public class server implements runnable { serversocket serversocket; volatile boolean keepprocessing = true; public server(int port, int millisecondstimeout) throws ioexception { serversocket = new serversocket(port); serversocket.setsotimeout(millisecondstimeout); } public void run() { system.out.printf(“server starting\”); while (keepprocessing) { try { system.out.printf(“accepting client\”); socket socket = serversocket.accept(); system.out.printf(“got client\”); process(socket); } catch (exception ) { handle(); } } } private void handle(exception ) { (!( instanceof socketexception)) { .printstacktrace(); } } public void stopprocessing() { keepprocessing = false; closeignoringexception(serversocket); } void process(socket socket) { (socket == null) return; try { system.out.printf(“server: getting message\”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %\”, message); thread.sleep(); system.out.printf(“server: sending reply: %\”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\”); (socket); } catch (exception ) { .printstacktrace(); } } private void closeignoringexception(socket socket) { (socket != null) try { socket.close(); } catch (ioexception ignore) { } } private void closeignoringexception(serversocket serversocket) { (serversocket != null) try { serversocket.close(); } catch (ioexception ignore) { } } } listado - clienttest.java. package com.objectmentor.clientserver.nonthreaded; import java..ioexception; import java.net.serversocket; import java.net.socket; import java.net.socketexception; import common.messageutils; public class server implements runnable { serversocket serversocket; volatile boolean keepprocessing = true; public server(int port, int millisecondstimeout) throws ioexception { serversocket = new serversocket(port); serversocket.setsotimeout(millisecondstimeout); } public void run() { system.out.printf(“server starting\”); while (keepprocessing) { try { system.out.printf(“accepting client\”); socket socket = serversocket.accept(); system.out.printf(“got client\”); process(socket); } catch (exception ) { (); } } } private void handle(exception ) { (!( instanceof socketexception)) { .printstacktrace(); } } public void stopprocessing() { keepprocessing = false; closeignoringexception(serversocket); } void process(socket socket) { (socket == null) return; try { system.out.printf(“server: getting message\”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %\”, message); thread.sleep(); system.out.printf(“server: sending reply: %\”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\”); closeignoringexception(socket); } catch (exception ) { .printstacktrace(); } } private void closeignoringexception(socket socket) { (socket != null) try { socket.close(); } catch (ioexception ignore) { } } private void closeignoringexception(serversocket serversocket) { (serversocket != null) try { serversocket.close(); } catch (ioexception ignore) { } } } listado - .java. package common; import java..ioexception; import java..inputstream; import java..objectinputstream; import java..objectoutputstream; import java..outputstream; import java.net.socket; public class messageutils { public static void sendmessage(socket socket, string message) throws ioexception { outputstream stream = socket.getoutputstream(); objectoutputstream oos = new objectoutputstream(stream); oos.writeutf(message); oos.flush(); } public static string getmessage(socket socket) throws ioexception { inputstream stream = socket.getinputstream(); objectinputstream ois = new objectinputstream(stream); return ois.readutf(); } } cliente/servidor con subprocesos para cambiar servidor para que use subprocesos basta con cambiar mensaje process (las nuevas líneas muestran negrita para destacarlas): void process(final socket socket) { (socket == null) return; runnable clienthandler = new runnable() { public void run() { try { system.out.printf(“server: getting message\”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %\”, message); thread.sleep(); system.out.printf(“server: sending reply: %\”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\”); closeignoringexception(socket); } catch (exception ) { .printstacktrace(); } } }; thread clientconnection = new thread(clienthandler); clientconnection.start(); } org.jfree.date.serialdate listado - serialdate.java /*============================================================== * jcommon: biblioteca gratuita clases propósito general para java() *============================================================== * * () copyright -, object refinery limited colaboradores. * * información del proyecto: http:// * * esta biblioteca software gratuito; puede distribuirla / modificarla * bajo las condiciones licencia pública general gnu publicada por * free software foundation; sea versión . licencia, * otra versión posterior ( elección). * * esta biblioteca distribuye con intención que sea útil, pero * sin garantía alguna, incluida garantía implícita comerciabilidad * idoneidad para determinado fin. consulte licencia * pública general gnu necesita más información respecto. * * debería haber recibido una copia licencia pública general gnu * junto esta biblioteca; caso contrario, contacte con free software * foundation, inc., franklin street, fifth floor, boston, - , * .. * * [java una marca comercial marca comercial registrada sun * microsystems, inc. estados unidos otros países.] * * ------------------ * serialdate.java * ------------------ * () copyright -, object refinery limited. * * autor original: david gilbert (para object refinery limited); * colaborador(): -; * * $: serialdate.java, . // :: mungady exp $ * * cambios (-oct-) * -------------------------------------- * -oct-: reorganización clase cambio nuevo paquete * com.jrefinery.date (); * -nov-: añade método getdescription() elimina clase * notabledate (); * -nov-: ibd requiere método setdescription(), una vez eliminada clase * notabledate (); cambian getpreviousdayofweek(), * getfollowingdayofweek() getnearestdayofweek() para corregir * errores (); * -dic-: error corregido clase spreadsheetdate (); * -may-: transfieren las constantes mes una interfaz independiente * (monthconstants) (); * -ago-: error corregido método addmonths(), gracias nálevka petr (); * -oct-: errores indicados por checkstyle () corregidos; * -mar-: implementación serializable (); * -may-: error corregido método addmonths (); * -sep-: implementación comparable. actualización los javadoc isinrange (); * -ene-: error corregido método addyears() () (); * */ package org.jfree.date; import java..serializable; import java.text.dateformatsymbols; import java.text.simpledateformat; import java.util.calendar; import java.util.gregoriancalendar; /** * clase abstracta que define nuestros requisitos para manipular fechas, * sin limitación una determinada implementación. * < * requisito : coincidir menos con procesamiento fechas excel; * requisito : clase inmutable; * < * ¿por qué usar java.util.date? haremos, cuando tenga sentido. ocasiones, * java.util.date puede ser demasiado precisa; representa instante tiempo, * con una precisión / segundo ( fecha depende * zona horaria). ocasiones sólo querremos representar día concreto (como * enero ) sin preocuparnos hora del día, * zona horaria otros aspectos. para eso hemos definido daydate. * < * puede invocar getinstance() para obtener una subclase concreta serialdate, * sin preocuparse implementación exacta * * @author david gilbert */ public abstract class serialdate implements comparable, serializable, monthconstants { /** para serialización. */ private static final long serialversionuid = -; /** símbolos formato fecha. */ public static final dateformatsymbols date_format_symbols = new simpledateformat().getdateformatsymbols(); /** número serie para enero . */ public static final int serial_lower_bound = ; /** número serie para diciembre . */ public static final int serial_upper_bound = ; /** valor año más bajo admitido por este formato fecha. */ public static final int minimum_year_supported = ; /** valor año más alto admitido por este formato fecha. */ public static final int maximum_year_supported = ; /** constante útil para lunes; equivale java.util.calendar.monday. */ public static final int monday = calendar.monday; /** * constante útil para martes; equivale java.util.calendar.tuesday. * / public static final int tuesday = calendar.tuesday; /** * constante útil para miércoles; equivale * java.util.calendar.wednesday. */ public static final int wednesday = calendar.wednesday; /** * constante útil para jueves; equivale java.util.calendar.thursday. */ public static final int thursday = calendar.thursday; /** constante útil para viernes; equivale java.util.calendar.friday. */ public static final int friday = calendar.friday; /** * constante útil para sábado; equivale java.util.calendar.saturday. */ public static final int saturday = calendar.saturday; /** constante útil para domingo; equivale java.util.calendar.sunday. */ public static final int sunday = calendar.sunday; /** número días cada mes años bisiestos. */ static final int[] last_day_of_month = {, , , , , , , , , , , , }; /** número días año ( bisiesto) hasta final cada mes. */ static final int[] aggregate_days_to_end_of_month = {, , , , , , , , , , , , }; /** número días año hasta final del mes anterior. */ static final int[] aggregate_days_to_end_of_preceding_month = {, , , , , , , , , , , , , }; /** número días año bisiesto hasta final cada mes. */ static final int[] leap_year_aggregate_days_to_end_of_month = {, , , , , , , , , , , , }; /** * número días año bisiesto hasta final del mes anterior. */ static final int[] leap_year_aggregate_days_to_end_of_preceding_month = {, , , , , , , , , , , , , }; /** una constante útil para hacer referencia primera semana del mes. */ public static final int first_week_in_month = ; /** una constante útil para hacer referencia segunda semana del mes. */ public static final int second_week_in_month = ; /** una constante útil para hacer referencia tercera semana del mes. */ public static final int third_week_in_month = ; /** una constante útil para hacer referencia cuarta semana del mes. */ public static final int fourth_week_in_month = ; /** una constante útil para hacer referencia última semana del mes. */ public static final int last_week_in_month = ; /** constante intervalo. */ public static final int include_none = ; /** constante intervalo. */ public static final int include_first = ; /** constante intervalo. */ public static final int include_second = ; /** constante intervalo. */ public static final int include_both = ; /** * constante útil para especificar día semana con respecto una fecha * fija. */ public static final int preceding = -; /** * constante útil para especificar día semana con respecto una fecha * fija. */ public static final int nearest = ; /** * constante útil para especificar día semana con respecto una fecha * fija. */ public static final int following = ; /** una descripción para fecha. */ private string description; /** * constructor predeterminado. */ protected serialdate() { } /** * devuelve <codetrue</code código entero proporcionado representa * día semana válido <codefalse</code caso contrario. * * @param code código del que comprueba validez. * * @return <codetrue</code código entero proporcionado representa * día semana válido <codefalse</code caso contrario. */ public static boolean isvalidweekdaycode(final int code) { switch(code) { case sunday: case monday: case tuesday: case wednesday: case thursday: case friday: case saturday: return true; default: return false; } } /** * convierte cadena proporcionada día semana. * * @param una cadena que representa día semana. * * @return <code-</code cadena puede convertir día * semana caso contrario. */ public static int stringtoweekdaycode(string ) { final string[] shortweekdaynames = date_format_symbols.getshortweekdays(); final string[] weekdaynames = date_format_symbols.getweekdays(); int result = -; = .trim(); for (int = ; < weekdaynames.length; ++) { (.equals(shortweekdaynames[])) { result = ; break; } (.equals(weekdaynames[])) { result = ; break; } } return result; } /** * devuelve una representación cadena del día semana proporcionado. * < * necesitamos enfoque mejor. * * @param weekday día semana. * * @return una cadena que representa día semana proporcionado. */ public static string weekdaycodetostring(final int weekday) { final string[] weekdays = date_format_symbols.getweekdays(); return weekdays[weekday]; } /** * devuelve una matriz nombres mes. * * @return una matriz nombres mes. */ public static string[] getmonths() { return getmonths(false); } /** * devuelve una matriz nombres mes. * * @param shortened indicador para indicar que deben devolverse los nombres * mes formato reducido. * * @return una matriz nombres mes. */ public static string[] getmonths(final boolean shortened) { (shortened) { return date_format_symbols.getshortmonths(); } else { return date_format_symbols.getmonths(); } } /** * devuelve true código entero proporcionado representa mes . * * @param code código del que comprueba validez. * * return <codetrue</code código entero proporcionado representa * mes válido. */ public static boolean isvalidmonthcode(final int code) { switch(code) { case january: case february: case march: case april: case may: case june: case july: case august: case september: case october: case november: case december: return true; default: return false; } } /** * devuelve trimestre del mes especificado. * * @param code código del mes (-). * * @return trimestre que pertenece mes. * @throws java.lang.illegalargumentexception */ public static int monthcodetoquarter(final int code) { switch(code) { case january: case february: case march: return ; case april: case may: case june: return ; case july: case august: case september: return ; case october: case november: case december: return ; default: throw new illegalargumentexception( “serialdate.monthcodetoquarter: invalid month code.”); } } /** * devuelve una cadena que representa mes proporcionado. * < * cadena devuelta forma extensa del nombre del mes obtenido * configuración regional. * * @param month mes. * * @return una cadena que representa mes proporcionado */ public static string monthcodetostring(final int month) { return monthcodetostring(month, false); } /** * devuelve una cadena que representa mes proporcionado. * < * cadena devuelta forma extensa reducida del nombre del mes * obtenido configuración regional. * * @param month mes. * @param shortened <codetrue</code devuelve abreviatura del * mes. * * @return una cadena que representa mes proporcionado. * @throws java.lang.illegalargumentexception */ public static string monthcodetostring(final int month, final boolean shortened) { // comprobar argumentos… (!isvalidmonthcode(month)) { throw new illegalargumentexception( “serialdate.monthcodetostring: month outside valid range.”); } final string[] months; (shortened) { months = date_format_symbols.getshortmonths(); } else { months = date_format_symbols.getmonths(); } return months[month - ]; } /** * convierte una cadena código del mes. * < * este método devuelve una las constantes january, february, …, * december correspondientes cadena. cadena * reconoce, este método devuelve -. * * @param cadena que analizar. * * @return <code-</code cadena puede analizar, mes del * año caso contrario. */ public static int stringtomonthcode(string ) { final string[] shortmonthnames = date_format_symbols.getshortmonths(); final string[] monthnames = date_format_symbols.getmonths(); int result = -; = .trim(); // primero intentar analizar cadena como entero (-)… try { result = integer.parseint(); } catch (numberformatexception ) { // suprimir } // buscar por los nombres los meses… ((result < ) || (result )) { for (int = ; < monthnames.length; ++) { (.equals(shortmonthnames[])) { result = + ; break; } (.equals(monthnames[])) { result = + ; break; } } } return result; } /** * devuelve true código entero proporcionado representa una semana * del mes válida false caso contrario * * @param code código del que comprueba validez. * @return <codetrue</code código entero proporcionado representa una * semana del mes válida. */ public static boolean isvalidweekinmonthcode(final int code) { switch(code) { case first_week_in_month: case second_week_in_month: case third_week_in_month: case fourth_week_in_month: case last_week_in_month: return true; default: return false; } } /** * determina año especificado bisiesto . * * @param yyyy año (entre ). * * @return <codetrue</code año especificado bisiesto. */ public static boolean isleapyear(final int yyyy) { ((yyyy % ) != ) { return false; } else ((yyyy % ) == ) { return true; } else ((yyyy % ) == ) { return false; } else { return true; } } /** * devuelve número años bisiestos desde hasta año especificado * inclusive. * < * año bisiesto. * * @param yyyy año (entre ). * * @return número años bisiestos desde hasta año especificado. */ public static int leapyearcount(final int yyyy) { final int leap = (yyyy - ) / ; final int leap = (yyyy - ) / ; final int leap = (yyyy - ) / ; return leap - leap + leap; } /** * devuelve número del último día del mes, teniendo cuenta los * años bisiestos. * * @param month mes. * @param yyyy año (entre ). * * @return número del último día del mes. */ public static int lastdayofmonth(final int month, final int yyyy) { final int result = last_day_of_month[month]; (month != february) { return result; } else (isleapyear(yyyy)) { return result + ; } else { return result; } } /** * crea una nueva fecha añadiendo número especificado días fecha * base. * * @param days número días que añadir (puede ser negativo). * @param base fecha base. * * @return una nueva fecha. */ public static serialdate adddays(final int days, final serialdate base) { final int serialdaynumber = base.toserial() + days; return serialdate.createinstance(serialdaynumber); } /** * crea una nueva fecha añadiendo número especificado meses fecha * base. * < * fecha base próxima final del mes, día del resultado * puede ajustar ligeramente: mayo + mes = junio. * * @param months número meses que añadir (puede ser negativo). * @param base fecha base. * * @return una nueva fecha. */ public static serialdate addmonths(final int months, final serialdate base) { final int = ( * base.getyyyy() + base.getmonth() + months - ) / ; final int = ( * base.getyyyy() + base.getmonth() + months – ) % + ; final int = math.min( base.getdayofmonth(), serialdate.lastdayofmonth(, ) ); return serialdate.createinstance(, , ); } /** * crea una nueva fecha añadiendo número especificado años fecha * base. * * @param years número años que añadir (puede ser negativo). * @param base fecha base. * * @return una nueva fecha. */ public static serialdate addyears(final int years, final serialdate base) { final int basey = base.getyyyy(); final int basem = base.getmonth(); final int based = base.getdayofmonth(); final int targety = basey + years; final int targetd = math.min( based, serialdate.lastdayofmonth(basem, targety) ); return serialdate.createinstance(targetd, basem, targety); } /** * devuelve última fecha correspondiente día semana especificado * anterior fecha base. * * @param targetweekday código para día semana destino. * @param base fecha base. * * @return última fecha correspondiente día semana especificado * anterior fecha base. */ public static serialdate getpreviousdayofweek(final int targetweekday, final serialdate base) { // comprobar argumentos… (!serialdate.isvalidweekdaycode(targetweekday)) { throw new illegalargumentexception( “invalid day--the-week code.” ); } // buscar fecha… final int adjust; final int basedow = base.getdayofweek(); (basedow targetweekday) { adjust = math.min(, targetweekday - basedow); } else { adjust = - + math.max(, targetweekday - basedow); } return serialdate.adddays(adjust, base); } /** * devuelve primera fecha que coincide con día semana especificado * posterior fecha base. * * @param targetweekday código para día semana destino. * @param base fecha base. * * @return primera fecha que coincide con día semana especificado * posterior fecha base. */ public static serialdate getfollowingdayofweek(final int targetweekday, final serialdate base) { // comprobar argumentos… (!serialdate.isvalidweekdaycode(targetweekday)) { throw new illegalargumentexception( “invalid day--the-week code.” ); } // buscar fecha… final int adjust; final int basedow = base.getdayofweek(); (basedow targetweekday) { adjust = + math.min(, targetweekday - basedow); } else { adjust = math.max(, targetweekday - basedow); } return serialdate.adddays(adjust, base); } /** * devuelve fecha que coincide con día semana especificado más * próxima fecha base. * * @param targetdow código para día semana destino. * @param base fecha base. * * @return fecha que coincide con día semana especificado más * próxima fecha base. */ public static serialdate getnearestdayofweek(final int targetdow, final serialdate base) { // comprobar argumentos… (!serialdate.isvalidweekdaycode(targetdow)) { throw new illegalargumentexception( “invalid day--the-week code.” ); } // buscar fecha… final int basedow = base.getdayofweek(); int adjust = -math.abs(targetdow - basedow); (adjust = ) { adjust = - adjust; } (adjust <= -) { adjust = + adjust; } return serialdate.adddays(adjust, base); } /** * avanzar fecha hasta último día del mes. * * @param base fecha base. * * @return una nueva fecha serie. */ public serialdate getendofcurrentmonth(final serialdate base) { final int last = serialdate.lastdayofmonth( base.getmonth(), base.getyyyy() ); return serialdate.createinstance(last, base.getmonth(), base.getyyyy()); } /** * devuelve una cadena correspondiente código semana del mes. * < * necesitamos enfoque mejor. * * @param count código entero que representa semana del mes. * * @return una cadena correspondiente código semana del mes. */ public static string weekinmonthtostring(final int count) { switch (count) { case serialdate.first_week_in_month : return “first”; case serialdate.second_week_in_month : return “second”; case serialdate.third_week_in_month : return “third”; case serialdate.fourth_week_in_month : return “fourth”; case serialdate.last_week_in_month : return “last”; default : return “serialdate.weekinmonthtostring(): invalid code.”; } } /** * devuelve una cadena que representa valor ‘relativo’ proporcionado. * < * necesitamos enfoque mejor. * * @param relative una constante que representa valor ‘relativo’. * * @return una cadena que representa valor ‘relativo’ proporcionado. */ public static string relativetostring(final int relative) { switch (relative) { case serialdate.preceding : return “preceding”; case serialdate.nearest : return “nearest”; case serialdate.following : return “following”; default : return “error : relative string”; } } /** * método factoría que devuelve una instancia una subclase concreta * {@link serialdate}. * * @param day día (-). * @param month mes (-). * @param yyyy año (entre ). * * @return una instancia {@link serialdate} */ public static serialdate createinstance(final int day, final int , final int yyyy) { return new spreadsheetdate(day, month, yyyy); } /** * método factoría que devuelve una instancia una subclase concreta * {@link serialdate}. * * @param serial numero serie del día ( enero = ). * * @return una instancia serialdate. */ public static serialdate createinstance(final int serial) { return new spreadsheetdate(serial); } /** * método factoría que devuelve una instancia una subclase serialdate. * * @param date objeto fecha java. * * @return una instancia serialdate. */ public static serialdate createinstance(final java.util.date date) { final gregoriancalendar calendar = new gregoriancalendar(); calendar.settime(date); return new spreadsheetdate(calendar.get(calendar.date), calendar.get(calendar.month) + , calendar.get(calendar.year)); } /** * devuelve número serie fecha, siendo enero = ( * corresponde, casi totalmente, sistema numeración empleado microsoft * excel para windows lotus --). * * @return número serie fecha. */ public abstract int toserial(); /** * devuelve java.util.date. como java.util.date tiene mayor precisión que * serialdate, debemos definir una convención para “ hora del día”. * * @return this como <codejava.util.date</code. */ public abstract java.util.date todate(); /** * devuelve una descripción fecha. * * @return una descripción fecha. */ public string getdescription() { return this.description; } /** * establece descripción fecha. * * @param description nueva descripción fecha. */ public void setdescription(final string description) { this.description = description; } /** * convierte fecha una cadena. * * @return una representación cadena fecha. */ public string tostring() { return getdayofmonth() + “-” + serialdate.monthcodetostring(getmonth()) + “-” + getyyyy(); } /** * devuelve año (con intervalo válido ). * * @return año. */ public abstract int getyyyy(); /** * devuelve mes (enero = , febrero = , marzo = ). * * @return mes del año. */ public abstract int getmonth(); /** * devuelve día del mes. * * @return día del mes. */ public abstract int getdayofmonth(); /** * devuelve día semana. * * @return día semana. */ public abstract int getdayofweek(); /** * devuelve diferencia ( días) entre esta fecha * ‘otra’ fecha especificada. * < * resultado positivo esta fecha posterior ‘otra’ * negativo anterior. * * @param other fecha con que compara. * * @return diferencia entre esta fecha otra. */ public abstract int compare(serialdate other); /** * devuelve true esta serialdate representa misma fecha que * serialdate especificada. * * @param other fecha con que compara. * * @return <codetrue</code esta serialdate representa misma fecha que * serialdate especificada. */ public abstract boolean ison(serialdate other); /** * devuelve true esta serialdate representa una fecha anterior * comparación serialdate especificada. * * @param other fecha con que compara. * * @return <codetrue</code esta serialdate representa una fecha anterior * comparación serialdate especificada. */ public abstract boolean isbefore(serialdate other); /** * devuelve true esta serialdate representa misma fecha que * serialdate especificada. * * @param other fecha con que compara. * * @return <codetrue</code esta serialdate representa misma fecha * que serialdate especificada. */ public abstract boolean isonorbefore(serialdate other); /** * devuelve true esta serialdate representa misma fecha que * serialdate especificada. * * @param other fecha con que compara. * * @return <codetrue</code esta serialdate representa misma fecha * que serialdate especificada. */ public abstract boolean isafter(serialdate other); /** * devuelve true esta serialdate representa misma fecha que * serialdate especificada. * * @param other fecha con que compara. * * @return <codetrue</code esta serialdate representa misma fecha * que serialdate especificada. */ public abstract boolean isonorafter(serialdate other); /** * devuelve <codetrue</code {@link serialdate} encuentra * rango especificado (inclusive). orden fecha * importante. * * @param fecha límite del rango. * @param otra fecha límite del rango. * * @return valor booleano. */ public abstract boolean isinrange(serialdate , serialdate ); /** * devuelve <codetrue</code {@link serialdate} encuentra * rango especificado ( invocador especifica los puntos finales * incluyen ). orden fecha importante. * * @param fecha límite del rango. * @param otra fecha límite del rango. * @param include código que controla las fechas inicial final * incluyen rango. * * @return valor booleano. */ public abstract boolean isinrange(serialdate , serialdate , int include); /** * devuelve última fecha que coincide con día semana especificado * que anterior esta fecha. * * @param targetdow código para día semana destino. * * @return última fecha que coincide con día semana especificado * que anterior esta fecha. */ public serialdate getpreviousdayofweek(final int targetdow) { return getpreviousdayofweek(targetdow, this); } /** * devuelve primera fecha que coincide con día semana especificado * que posterior esta fecha. * * @param targetdow código para día semana destino. * * @return primera fecha que coincide con día semana especificado * que posterior esta fecha. */ public serialdate getfollowingdayofweek(final int targetdow) { return getfollowingdayofweek(targetdow, this); } /** * devuelve fecha más próxima que coincide con día semana especificado. * * @param targetdow código para día semana destino. * * @return fecha más próxima que coincide con día semana especificado. */ public serialdate getnearestdayofweek(final int targetdow) { return getnearestdayofweek(targetdow, this); } } listado - serialdatetest.java /* ============================================================= * jcommon : biblioteca gratuita clases propósito general para java() * ============================================================= * * () copyright -, object refinery limited colaboradores. * * información del projecto: http:// * * esta biblioteca software gratuito; puede distribuirla / modificarla * bajo las condiciones licencia pública general gnu publicada por * free software foundation; sea versión . licencia, * otra versión posterior ( elección). * * esta biblioteca distribuye con intención que sea útil, pero * sin garantía alguna, incluida garantía implícita comerciabilidad * idoneidad para determinado fin. consulte licencia pública general gnu * necesita más información respecto. * * debería haber recibido una copia licencia pública general gnu * junto esta biblioteca; caso contrario, contacte con free software * foundation, inc., franklin street, fifth floor, boston, -, * .. * * [java una marca comercial marca comercial registrada sun * microsystems, inc. estados unidos otros países.] * * ------------------------- * serialdatetests.java * ------------------------- * () copyright -, por object refinery limited. * autor original: david gilbert (por object refinery limited); * colaborador(): -; * $: serialdatetests.java, . // :: taqua exp $ * cambios * ----------- * -nov-: version (); * -jun-: elimina importación innecesaria (); * -oct-: errores indicados checkstyle corregidos (); * -mar-: añade prueba serialización (); * -jan-: añade prueba para informe errores (); * */ package org.jfree.date.junit; import java..bytearrayinputstream; import java..bytearrayoutputstream; import java..objectinput; import java..objectinputstream; import java..objectoutput; import java..objectoutputstream; import junit.framework.test; import junit.framework.testcase; import junit.framework.testsuite; import org.jfree.date.monthconstants; import org.jfree.date.serialdate; /** * pruebas junit para clase {@link serialdate}. */ public class serialdatetests extends testcase { /** fecha que representa noviembre. private serialdate nov; /** * crea nuevo caso prueba. * * @param name nombre. */ public serialdatetests(final string name) { super(name); } /** * devuelve una suite pruebas para ejecutor pruebas junit. * * @return suite pruebas. */ public static test suite() { return new testsuite(serialdatetests.class); } /** * problema. */ protected void setup() { this.nov = serialdate.createinstance(, monthconstants.november, ); } /** * nov más dos meses debe ser ene . */ public void testaddmonthsto() { final serialdate jan = serialdate.addmonths(, this.nov); final serialdate answer = serialdate.createinstance(, , ); assertequals(answer, jan); } /** * caso prueba error, corregido. */ public void testaddmonthsto() { final serialdate = serialdate.createinstance(, monthconstants.october, ); final serialdate = serialdate.addmonths(, ); assertequals(, serialdate.createinstance(, monthconstants.december, )); } /** * caso prueba error, corregido. */ public void testaddmonthsto() { final serialdate = serialdate.createinstance(, monthconstants.january, ); final serialdate = serialdate.addmonths(, ); assertequals(, ); } /** * lunes anterior viernes noviembre debe ser noviembre. */ public void testmondayprecedingfriday() { serialdate mondaybefore = serialdate.getpreviousdayofweek( serialdate.monday, this.nov ); assertequals(, mondaybefore.getdayofmonth()); } /** * lunes posterior viernes noviembre debe ser noviembre. */ public void testmondayfollowingfriday() { serialdate mondayafter = serialdate.getfollowingdayofweek( serialdate.monday, this.nov ); assertequals(, mondayafter.getdayofmonth()); } /** * lunes más próximo viernes noviembre debe ser noviembre. */ public void testmondaynearestfriday() { serialdate mondaynearest = serialdate.getnearestdayofweek( serialdate.monday, this.nov ); assertequals(, mondaynearest.getdayofmonth()); } /** * lunes más próximo enero cae . */ public void testmondaynearest() { serialdate jan = serialdate.createinstance(, monthconstants.january, ); serialdate mondaynearest = serialdate.getnearestdayofweek(serialdate.monday, jan); assertequals(, mondaynearest.getdayofmonth()); } /** * problema que conversión días cadenas devuelva resultado * correcto. realidad este resultado depende configuración regional. */ public void testweekdaycodetostring() { final string test = serialdate.weekdaycodetostring(serialdate.saturday); assertequals(“saturday”, test); } /** * probar conversión una cadena día semana. esta prueba falla * configuración regional predeterminada usa nombres días inglés */ public void teststringtoweekday() { int weekday = serialdate.stringtoweekdaycode(“wednesday”); assertequals(serialdate.wednesday, weekday); weekday = serialdate.stringtoweekdaycode(“ wednesday ”); assertequals(serialdate.wednesday, weekday); weekday = serialdate.stringtoweekdaycode(“wed”); assertequals(serialdate.wednesday, weekday); } /** * probar conversión una cadena mes. esta prueba falla * configuración regional predeterminada usa nombres días inglés */ public void teststringtomonthcode() { int = serialdate.stringtomonthcode(“january”); assertequals(monthconstants.january, ); = serialdate.stringtomonthcode(“ january ”); assertequals(monthconstants.january, ); = serialdate.stringtomonthcode(“jan”); assertequals(monthconstants.january, ); } /** * probar conversión código mes cadena. */ public void testmonthcodetostringcode() { final string test = serialdate.monthcodetostring(monthconstants.december); assertequals(“december”, test); } /** * año bisiesto. */ public void testisnotleapyear() { asserttrue(!serialdate.isleapyear()); } /** * año bisiesto. */ public void testisleapyear() { asserttrue(serialdate.isleapyear()); } /** * número años bisiestos desde hasta incluido . */ public void testleapyearcount() { assertequals(serialdate.leapyearcount(), ); } /** * número años bisiestos desde hasta incluido . */ public void testleapyearcount() { assertequals(serialdate.leapyearcount(), ); } /** * número años bisiestos desde hasta incluido . */ public void testleapyearcount() { assertequals(serialdate.leapyearcount(), ); } /** * número años bisiestos desde hasta incluido . */ public void testleapyearcount() { assertequals(serialdate.leapyearcount(), ); } /** * número años bisiestos desde hasta incluido . */ public void testleapyearcount() { assertequals(serialdate.leapyearcount(), ); } /** * serializar una instancia, restaurarla comprobar igualdad. */ public void testserialization() { serialdate = serialdate.createinstance(, , ); serialdate = null; try { bytearrayoutputstream buffer = new bytearrayoutputstream(); objectoutput out = new objectoutputstream(buffer); out.writeobject(); out.close(); objectinput = new objectinputstream( new bytearrayinputstream(buffer.tobytearray())); = (serialdate) .readobject(); .close(); } catch (exception ) { system.out.println(.tostring()); } assertequals(, ); } /** * prueba para informe error ( corregido). */ public void test() { serialdate = serialdate.createinstance(, , ); = serialdate.addyears(, ); serialdate expected = serialdate.createinstance(, , ); asserttrue(.ison(expected)); } /** * diversas pruebas para método addmonths(). */ public void testaddmonths() { serialdate = serialdate.createinstance(, , ); serialdate = serialdate.addmonths(, ); assertequals(, .getdayofmonth()); assertequals(, .getmonth()); assertequals(, .getyyyy()); serialdate = serialdate.addmonths(, ); assertequals(, .getdayofmonth()); assertequals(, .getmonth()); assertequals(, .getyyyy()); serialdate = serialdate.addmonths(, serialdate.addmonths(, )); assertequals(, .getdayofmonth()); assertequals(, .getmonth()); assertequals(, .getyyyy()); } } listado - monthconstants.java /* ============================================================= * jcommon : biblioteca gratuita clases propósito general para java() * ============================================================= * * () copyright -, object refinery limited colaboradores. * * información del proyecto: http:// * * esta biblioteca software gratuito; puede distribuirla / modificarla * bajo las condiciones licencia pública general gnu publicada por * free software foundation; sea versión . licencia, * otra versión posterior ( elección). * * esta biblioteca distribuye con intención que sea útil, pero * sin garantía alguna, incluida garantía implícita comerciabilidad * idoneidad para determinado fin. consulte licencia pública general gnu * necesita más información respecto. * * debería haber recibido una copia licencia pública general gnu * junto esta biblioteca; caso contrario, contacte con free software * foundation, inc., franklin street, fifth floor, boston, -, * .. * * [java una marca comercial marca comercial registrada sun * microsystems, inc. estados unidos otros países.] * * ---------------------- * monthconstants.java * ---------------------- * () copyright , , object refinery limited. * * autor original: david gilbert (para object refinery limited); * colaborador(): -; * * $: monthconstants.java, . // :: taqua exp $ * * cambios * ---------- * -may- : version (code moved from serialdate class) (); * */ package org.jfree.date; /** * constantes útiles para los meses. son equivalentes las * constantes definidas por java.util.calendar (donde january= december=). * < * usa las clases serialdate regulartimeperiod. * * @author david gilbert */ public interface monthconstants { /** constante para enero. */ public static final int january = ; /** constante para febrero. */ public static final int february = ; /** constante para marzo. */ public static final int march = ; /** constante para abril. */ public static final int april = ; /** constante para mayo. */ public static final int may = ; /** constante para junio. */ public static final int june = ; /** constante para julio. */ public static final int july = ; /** constante para agosto. */ public static final int august = ; /** constante para septiembre. */ public static final int september = ; /** constante para octubre. */ public static final int october = ; /** constante para noviembre. */ public static final int november = ; /** constante para diciembre. */ public static final int december = ; } listado - bobsserialdatetest.java package org.jfree.date.junit; import junit.framework.testcase; import org.jfree.date.*; import static org.jfree.date.serialdate.*; import java.util.*; public class bobsserialdatetest extends testcase { public void testisvalidweekdaycode() throws exception { for (int day = ; day <= ; day++) asserttrue(isvalidweekdaycode(day)); assertfalse(isvalidweekdaycode()); assertfalse(isvalidweekdaycode()); } public void teststringtoweekdaycode() throws exception { assertequals(-, stringtoweekdaycode(“hello”)); assertequals(monday, stringtoweekdaycode(“monday”)); assertequals(monday, stringtoweekdaycode(“mon”)); //todo assertequals(monday,stringtoweekdaycode(“monday”)); // assertequals(monday,stringtoweekdaycode(“monday”)); // assertequals(monday, stringtoweekdaycode(“mon”)); assertequals(tuesday, stringtoweekdaycode(“tuesday”)); assertequals(tuesday, stringtoweekdaycode(“tue”)); // assertequals(tuesday,stringtoweekdaycode(“tuesday”)); // assertequals(tuesday,stringtoweekdaycode(“tuesday”)); // assertequals(tuesday, stringtoweekdaycode(“tue”)); // assertequals(tuesday, stringtoweekdaycode(“tues”)); assertequals(wednesday, stringtoweekdaycode (“wednesday”)); assertequals(wednesday, stringtoweekdaycode(“wed”)); // assertequals(wednesday,stringtoweekdaycode(“wednesday”)); // assertequals(wednesday,stringtoweekdaycode(“wednesday”)); // assertequals(wednesday, stringtoweekdaycode(“wed”)); assertequals(thursday, stringtoweekdaycode(“thursday”)); assertequals(thursday, stringtoweekdaycode(“thu”)); // assertequals(thursday,stringtoweekdaycode(“thursday”)); // assertequals(thursday,stringtoweekdaycode(“thursday”)); // assertequals(thursday, stringtoweekdaycode(“thu”)); // assertequals(thursday, stringtoweekdaycode(“thurs”)); assertequals(friday, stringtoweekdaycode(“friday”)); assertequals(friday, stringtoweekdaycode(“fri”)); // assertequals(friday,stringtoweekdaycode(“friday”)); // assertequals(friday,stringtoweekdaycode(“friday”)); // assertequals(friday, stringtoweekdaycode(“fri”)); assertequals(saturday, stringtoweekdaycode(“saturday”)); assertequals(saturday, stringtoweekdaycode(“sat”)); // assertequals(saturday,stringtoweekdaycode(“saturday”)); // assertequals(saturday,stringtoweekdaycode(“saturday”)); // assertequals(saturday, stringtoweekdaycode(“sat”)); assertequals(sunday, stringtoweekdaycode(“sunday”)); assertequals(sunday, stringtoweekdaycode(“sun”)); // assertequals(sunday,stringtoweekdaycode(“sunday”)); // assertequals(sunday,stringtoweekdaycode(“sunday”)); // assertequals(sunday, stringtoweekdaycode(“sun”)); } public void testweekdaycodetostring() throws exception { assertequals(“sunday”, weekdaycodetostring(sunday)); assertequals(“monday”, weekdaycodetostring(monday)); assertequals(“tuesday”, weekdaycodetostring(tuesday)); assertequals(“wednesday”, weekdaycodetostring(wednesday)); assertequals(“thursday”, weekdaycodetostring(thursday)); assertequals(“friday”, weekdaycodetostring(friday)); assertequals(“saturday”, weekdaycodetostring(saturday)); } public void testisvalidmonthcode() throws exception { for (int = ; <= ; ++) asserttrue(isvalidmonthcode()); assertfalse(isvalidmonthcode()); assertfalse(isvalidmonthcode()); } public void testmonthtoquarter() throws exception { assertequals(, monthcodetoquarter(january)); assertequals(, monthcodetoquarter(february)); assertequals(, monthcodetoquarter(march)); assertequals(, monthcodetoquarter(april)); assertequals(, monthcodetoquarter(may)); assertequals(, monthcodetoquarter(june)); assertequals(, monthcodetoquarter(july)); assertequals(, monthcodetoquarter(august)); assertequals(, monthcodetoquarter(september)); assertequals(, monthcodetoquarter(october)); assertequals(, monthcodetoquarter(november)); assertequals(, monthcodetoquarter(december)); try { monthcodetoquarter(-); fail(“invalid month code should throw exception”); } catch (illegalargumentexception ) { } } public void testmonthcodetostring() throws exception { assertequals(“january”, monthcodetostring(january)); assertequals(“february”, monthcodetostring(february)); assertequals(“march”, monthcodetostring(march)); assertequals(“april”, monthcodetostring(april)); assertequals(“may”, monthcodetostring(may)); assertequals(“june”, monthcodetostring(june)); assertequals(“july”, monthcodetostring(july)); assertequals(“august”, monthcodetostring(august)); assertequals(“september”, monthcodetostring(september)); assertequals(“october”, monthcodetostring(october)); assertequals(“november”, monthcodetostring(november)); assertequals(“december”, monthcodetostring(december)); assertequals(“jan”, monthcodetostring(january, true)); assertequals(“feb”, monthcodetostring(february, true)); assertequals(“mar”, monthcodetostring(march, true)); assertequals(“apr”, monthcodetostring(april, true)); assertequals(“may”, monthcodetostring(may, true)); assertequals(“jun”, monthcodetostring(june, true)); assertequals(“jul”, monthcodetostring(july, true)); assertequals(“aug”, monthcodetostring(august, true)); assertequals(“sep”, monthcodetostring(september, true)); assertequals(“oct”, monthcodetostring(october, true)); assertequals(“nov”, monthcodetostring(november, true)); assertequals(“dec”, monthcodetostring(december, true)); try { monthcodetostring(-); fail(“invalid month code should throw exception”); } catch (illegalargumentexception ) { } } public void teststringtomonthcode() throws exception { assertequals(january,stringtomonthcode(“”)); assertequals(february,stringtomonthcode(“”)); assertequals(march,stringtomonthcode(“”)); assertequals(april,stringtomonthcode(“”)); assertequals(may,stringtomonthcode(“”)); assertequals(june,stringtomonthcode(“”)); assertequals(july,stringtomonthcode(“”)); assertequals(august,stringtomonthcode(“”)); assertequals(september,stringtomonthcode(“”)); assertequals(october,stringtomonthcode(“”)); assertequals(november, stringtomonthcode(“”)); assertequals(december,stringtomonthcode(“”)); //todo assertequals(-, stringtomonthcode(“”)); // assertequals(-, stringtomonthcode(“”)); assertequals(-,stringtomonthcode(“hello”)); for (int = ; <= ; ++) { assertequals(, stringtomonthcode(monthcodetostring(, false))); assertequals(, stringtomonthcode(monthcodetostring(, true))); } // assertequals(,stringtomonthcode(“jan”)); // assertequals(,stringtomonthcode(“feb”)); // assertequals(,stringtomonthcode(“mar”)); // assertequals(,stringtomonthcode(“apr”)); // assertequals(,stringtomonthcode(“may”)); // assertequals(,stringtomonthcode(“jun”)); // assertequals(,stringtomonthcode(“jul”)); // assertequals(,stringtomonthcode(“aug”)); // assertequals(,stringtomonthcode(“sep”)); // assertequals(,stringtomonthcode(“oct”)); // assertequals(,stringtomonthcode(“nov”)); // assertequals(,stringtomonthcode(“dec”)); // assertequals(,stringtomonthcode(“jan”)); // assertequals(,stringtomonthcode(“feb”)); // assertequals(,stringtomonthcode(“mar”)); // assertequals(,stringtomonthcode(“apr”)); // assertequals(,stringtomonthcode(“may”)); // assertequals(,stringtomonthcode(“jun”)); // assertequals(,stringtomonthcode(“jul”)); // assertequals(,stringtomonthcode(“aug”)); // assertequals(,stringtomonthcode(“sep”)); // assertequals(,stringtomonthcode(“oct”)); // assertequals(,stringtomonthcode(“nov”)); // assertequals(,stringtomonthcode(“dec”)); // assertequals(,stringtomonthcode(“january”)); // assertequals(,stringtomonthcode(“february”)); // assertequals(,stringtomonthcode(“march”)); // assertequals(,stringtomonthcode(“april”)); // assertequals(,stringtomonthcode(“may”)); // assertequals(,stringtomonthcode(“june”)); // assertequals(,stringtomonthcode(“july”)); // assertequals(,stringtomonthcode(“august”)); // assertequals(,stringtomonthcode(“september”)); // assertequals(,stringtomonthcode(“october”)); // assertequals(,stringtomonthcode(“november”)); // assertequals(,stringtomonthcode(“december”)); // assertequals(,stringtomonthcode(“january”)); // assertequals(,stringtomonthcode(“february”)); // assertequals(,stringtomonthcode(“mar”)); // assertequals(,stringtomonthcode(“april”)); // assertequals(,stringtomonthcode(“may”)); // assertequals(,stringtomonthcode(“june”)); // assertequals(,stringtomonthcode(“july”)); // assertequals(,stringtomonthcode(“august”)); // assertequals(,stringtomonthcode(“september”)); // assertequals(,stringtomonthcode(“october”)); // assertequals(,stringtomonthcode(“november”)); // assertequals(,stringtomonthcode(“december”)); } public void testisvalidweekinmonthcode() throws exception { for (int = ; <= ; ++) { asserttrue(isvalidweekinmonthcode()); } assertfalse(isvalidweekinmonthcode()); } public void testisleapyear() throws exception { assertfalse(isleapyear()); assertfalse(isleapyear()); assertfalse(isleapyear()); assertfalse(isleapyear()); asserttrue(isleapyear()); asserttrue(isleapyear()); assertfalse(isleapyear()); asserttrue(isleapyear()); asserttrue(isleapyear()); asserttrue(isleapyear()); assertfalse(isleapyear()); assertfalse(isleapyear()); } public void testleapyearcount() throws exception { assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); assertequals(, leapyearcount()); } public void testlastdayofmonth() throws exception { assertequals(, lastdayofmonth(january, )); assertequals(, lastdayofmonth(february, )); assertequals(, lastdayofmonth(march, )); assertequals(, lastdayofmonth(april, )); assertequals(, lastdayofmonth(may, )); assertequals(, lastdayofmonth(june, )); assertequals(, lastdayofmonth(july, )); assertequals(, lastdayofmonth(august, )); assertequals(, lastdayofmonth(september, )); assertequals(, lastdayofmonth(october, )); assertequals(, lastdayofmonth(november, )); assertequals(, lastdayofmonth(december, )); assertequals(, lastdayofmonth(february, )); } public void testadddays() throws exception { serialdate newyears = (, january, ); assertequals((, january, ), adddays(, newyears)); assertequals((, february, ), adddays(, newyears)); assertequals((, january, ), adddays(, newyears)); assertequals((, december, ), adddays( * , newyears)); } private static spreadsheetdate (int day, int month, int year) { return new spreadsheetdate(day, month, year); } public void testaddmonths() throws exception { assertequals((, february, ), addmonths(, (, january, ))); assertequals((, february, ), addmonths(, (, january, ))); assertequals((, february, ), addmonths(, (, january, ))); assertequals((, february, ), addmonths(, (, january, ))); assertequals((, february, ), addmonths(, (, january, ))); assertequals((, february, ), addmonths(, (, january, ))); assertequals((, june, ), addmonths(, (, january, ))); assertequals((, june, ), addmonths(, (, january, ))); assertequals((, february, ), addmonths(, (, january, ))); } public void testaddyears() throws exception { assertequals((, january, ), addyears(, (, january, ))); assertequals((, february, ), addyears(, (, february, ))); assertequals((, february, ), addyears(, (, february, ))); assertequals((, february, ), addyears(, (, february, ))); } public void testgetpreviousdayofweek() throws exception { assertequals((, february, ), getpreviousdayofweek(friday, (, march, ))); assertequals((, february, ), getpreviousdayofweek(wednesday, (, march, ))); assertequals((, february, ), getpreviousdayofweek(sunday, (, march, ))); assertequals((, december, ), getpreviousdayofweek(wednesday, (, january, ))); try { getpreviousdayofweek(-, (, january, )); fail(“invalid day week code should throw exception”); } catch (illegalargumentexception ) { } } public void testgetfollowingdayofweek() throws exception { // assertequals((, january, ),getfollowingdayofweek(saturday, (, december, ))); assertequals((, january, ), getfollowingdayofweek(saturday, (, december, ))); assertequals((, march, ), getfollowingdayofweek(wednesday, (, february, ))); try { getfollowingdayofweek(-, (, january, )); fail(“invalid day week code should throw exception”); } catch (illegalargumentexception ) { } } public void testgetnearestdayofweek() throws exception { assertequals((, april, ), getnearestdayofweek(sunday, (, april, ))); assertequals((, april, ), getnearestdayofweek(sunday, (, april, ))); assertequals((, april, ), getnearestdayofweek(sunday, (, april, ))); assertequals((, april, ), getnearestdayofweek(sunday, (, april, ))); assertequals((, april, ), getnearestdayofweek(sunday, (, april, ))); assertequals((, april, ), getnearestdayofweek(sunday, (, april, ))); assertequals((, april, ), getnearestdayofweek(sunday, (, april, ))); //todo assertequals((, april, ), getnearestdayofweek(monday, (, april, ))); assertequals((, april, ), getnearestdayofweek(monday, (, april, ))); assertequals((, april, ), getnearestdayofweek(monday, (, april, ))); assertequals((, april, ), getnearestdayofweek(monday, (, april, ))); assertequals((, april, ), getnearestdayofweek(monday, (, april, ))); assertequals((, april, ), getnearestdayofweek(monday, (, april, ))); assertequals((, april, ), getnearestdayofweek(monday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(tuesday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(tuesday, (, april, ))); assertequals((, april, ), getnearestdayofweek(tuesday, (, april, ))); assertequals((, april, ), getnearestdayofweek(tuesday, (, april, ))); assertequals((, april, ), getnearestdayofweek(tuesday, (, april, ))); assertequals((, april, ), getnearestdayofweek(tuesday, (, , ))); assertequals((, april, ), getnearestdayofweek(tuesday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(wednesday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(wednesday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(wednesday, (, april, ))); assertequals((, april, ), getnearestdayofweek(wednesday, (, april, ))); assertequals((, april, ), getnearestdayofweek(wednesday, (, april, ))); assertequals((, april, ), getnearestdayofweek(wednesday, (, april, ))); assertequals((, april, ), getnearestdayofweek(wednesday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(thursday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(thursday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(thursday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(thursday, (, april, ))); assertequals((, april, ), getnearestdayofweek(thursday, (, april, ))); assertequals((, april, ), getnearestdayofweek(thursday, (, april, ))); assertequals((, april, ), getnearestdayofweek(thursday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(friday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(friday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(friday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(friday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(friday, (, april, ))); assertequals((, april, ), getnearestdayofweek(friday, (, april, ))); assertequals((, april, ), getnearestdayofweek(friday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(saturday, (, , ))); // assertequals((, april, ), getnearestdayofweek(saturday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(saturday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(saturday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(saturday, (, april, ))); // assertequals((, april, ), getnearestdayofweek(saturday, (, april, ))); assertequals((, april, ), getnearestdayofweek(saturday, (, april, ))); try { getnearestdayofweek(-, (, january, )); fail(“invalid day week code should throw exception”); } catch (illegalargumentexception ) { } } public void testendofcurrentmonth() throws exception { serialdate = serialdate.createinstance(); assertequals((, january, ), .getendofcurrentmonth((, january, ))); assertequals((, february, ), .getendofcurrentmonth((, february, ))); assertequals((, march, ), .getendofcurrentmonth((, march, ))); assertequals((, april, ), .getendofcurrentmonth((, april, ))); assertequals((, may, ), .getendofcurrentmonth((, may, ))); assertequals((, june, ), .getendofcurrentmonth((, june, ))); assertequals((, july, ), .getendofcurrentmonth((, july, ))); assertequals((, august, ), .getendofcurrentmonth((, august, ))); assertequals((, september, ), .getendofcurrentmonth((, september, ))); assertequals((, october, ), .getendofcurrentmonth((, october, ))); assertequals((, november, ), .getendofcurrentmonth((, november, ))); assertequals((, december, ), .getendofcurrentmonth((, december, ))); assertequals((, february, ), .getendofcurrentmonth((, february, ))); } public void testweekinmonthtostring() throws exception { assertequals(“first”,weekinmonthtostring(first_week_in_month)); assertequals(“second”,weekinmonthtostring(second_week_in_month)); assertequals(“third”,weekinmonthtostring(third_week_in_month)); assertequals(“fourth”,weekinmonthtostring(fourth_week_in_month)); assertequals(“last”,weekinmonthtostring(last_week_in_month)); //todo try { // weekinmonthtostring(-); // fail(“invalid week code should throw exception”); // } catch (illegalargumentexception ) { // } } public void testrelativetostring() throws exception { assertequals(“preceding”,relativetostring(preceding)); assertequals(“nearest”,relativetostring(nearest)); assertequals(“following”,relativetostring(following)); //todo try { // relativetostring(-); // fail(“invalid relative code should throw exception”); // } catch (illegalargumentexception ) { // } } public void testcreateinstancefromddmmyyyy() throws exception { serialdate date = createinstance(, january, ); assertequals(,date.getdayofmonth()); assertequals(january,date.getmonth()); assertequals(,date.getyyyy()); assertequals(,date.toserial()); } public void testcreateinstancefromserial() throws exception { assertequals((, january, ),createinstance()); assertequals((, january, ), createinstance()); } public void testcreateinstancefromjavadate() throws exception { assertequals((, january, ), createinstance(new gregoriancalendar(,,).gettime())); assertequals((, january, ), (new gregoriancalendar(,,).gettime())); } public static void main(string[] args) { junit.textui.testrunner.run(bobsserialdatetest.class); } } - spreadsheetdate.java. /* ============================================================= * jcommon: biblioteca gratuita clases propósito general para java() * ============================================================= * * () copyright -, object refinery limited colaboradores. * * información del proyecto: http:// * * esta biblioteca software gratuito; puede distribuirla / modificarla * bajo las condiciones licencia pública general gnu publicada por * free software foundation; sea versión . licencia, * otra versión posterior ( elección). * * esta biblioteca distribuye con intención que sea útil, pero * sin garantía alguna, incluida garantía implícita comerciabilidad * idoneidad para determinado fin. consulte licencia pública general gnu * necesita más información respecto. * * debería haber recibido una copia licencia pública general gnu * junto esta biblioteca; caso contrario, contacte con free software * foundation, inc., franklin street, fifth floor, boston, -, * .. * * [java una marca comercial marca comercial registrada sun * microsystems, inc. estados unidos otros países.] * * -------------------------- * spreadsheetdate.java * -------------------------- * () copyright -, object refinery limited colaboradores. * * autor original: david gilbert (por object refinery limited); * colaboradores(): -; * * $: speadsheetdate.java, . // :: mungady exp $ * * cambios * ---------- * -oct- : version (); * -nov- : añaden los métodos getdescription() setdescription() (); * -nov- : cambia nombre exceldate.java por spreadsheetdate.java (); * corrige error hora calcular día, mes año * partir del número serie (); * -jan- : corrige error hora calcular número serie * partir del día, mes año. gracias trevor kills por informe (); * -may- : añade método equals(object) (sourceforge ) (); * -oct- : corrigen los errores detectados por checkstyle (); * -mar- : implementación serializable (); * -sep- : métodos isinrange() completados (); * -sep- : implementación comparable (); * -oct- : añade método hashcode() (); * /* package org.jfree.date; import java.util.calendar; import java.util.date; /** * representa una con entero, forma similar * implementación microsoft excel. intervalo fechas admitido * -ene- -dic-. * < * recuerde que excel tiene error que reconoce año * como bisiesto cuando realidad . encontrará más * información sitio web microsoft, artículo : * < * http://support.microsoft.com/support//articles///.asp * < * excel usa como convención que -ene- = . esta clase usa * convención que -ene- = . * como resultado, número día esta clase será diferente * excel para enero febrero … pero excel añade día * más (-feb- que realidad existe) partir ahí * los números los días coinciden. * * @author david gilbert */ public class spreadsheetdate extends serialdate { /** para serialización. */ private static final long serialversionuid = -; /** * número día (-ene- = , -ene- = …, -dic- = * ). */ private int serial; /** día del mes ( , , función del mes). */ private int day; /** mes del año ( ). */ private int month; /** año ( ). */ private int year; /** una descripción opcional para fecha. */ private string description; /** * crear una nueva instancia fecha. * * @param day día (entre ///). * @param month mes (entre ). * @param year año (entre ). */ public spreadsheetdate(final int day, final int month, final int year) { ((year = ) && (year <= )) { this.year = year; } else { throw new illegalargumentexception( “the ‘year’ argument must range .” ); } ((month = monthconstants.january) && (month <= monthconstants.december)) { this.month = month; } else { throw new illegalargumentexception( “the ‘month’ argument must the range .” ); } ((day = ) && (day <= serialdate.lastdayofmonth(month, year))) { this.day = day; } else { throw new illegalargumentexception(“invalid ‘day’ argument.”); } // necesario sincronizar número serie con día-mes-año… this.serial = calcserial(day, month, year); this.description = null; } /** * constructor estándar: crear nuevo objeto fecha que representa * número día especificado (que debe estar comprendido entre ). * * @param serial número serie para día (entre ). */ public spreadsheetdate(final int serial) { ((serial = serial_lower_bound) && (serial <= serial_upper_bound)) { this.serial = serial; } else { throw new illegalargumentexception( “spreadsheetdate: serial must range .”); } // día-mes-año debe estar sincronizado con número serie… calcdaymonthyear(); } /** * devuelve descripción adjuntada fecha. * obligatorio que fecha tenga una descripción, pero resulta útil * algunas aplicaciones. * * @return descripción adjuntada fecha. */ public string getdescription() { return this.description; } /** * establece descripción fecha. * * @param description descripción esta fecha (<codenull</code * permite) */ public void setdescription(final string description) { this.description = description; } /** * devuelve número serie fecha, siendo enero = * ( corresponde, casi totalmente, sistema numeración empleado * microsoft excel para windows lotus --). * * @return número serie fecha. */ public int toserial() { return this.serial; } /** * devuelve una <codejava.util.date</code equivalente esta fecha. * * @return fecha. */ public date todate() { final calendar calendar = calendar.getinstance(); calendar.set(getyyyy(), getmonth() - , getdayofmonth(), , , ); return calendar.gettime(); } /** * devuelve año (con intervalo válido ). * * @return año. */ public int getyyyy() { return this.year; } /** * devuelve mes (enero = , febrero = , marzo = ). * * @return mes del año. */ public int getmonth() { return this.month; } /** * devuelve día del mes. * * @return día del mes. */ public int getdayofmonth() { return this.day; } /** * devuelve código que representa día semana. * < * los códigos definen clase {@link serialdate} como: * <codesunday</code, <codemonday</code, <codetuesday</code, * <codewednesday</code, <codethursday</code, <codefriday</code, * <codesaturday</code. * * @return código que representa día semana. */ public int getdayofweek() { return (this.serial + ) % + ; } /** * prueba igualdad esta fecha con objeto arbitrario. * < * este método sólo devuelve true objeto una instancia * clase base {@link serialdate} representa mismo día que * {@link spreadsheetdate}. * * @param object objeto que comparar ( permite <codenull</code). * * @return valor booleano. */ public boolean equals(final object object) { (object instanceof serialdate) { final serialdate = (serialdate) object; return (.toserial() == this.toserial()); } else { return false; } } /** * devuelve código hash para instancia este objeto. * * @return código hash. */ public int hashcode() { return toserial(); } /** * devuelve diferencia ( días) entre esta fecha * ‘otra’ fecha especificada. * * @param other fecha con que compara. * * @return diferencia ( días) entre esta fecha * otra’ fecha especificada. */ public int compare(final serialdate other) { return this.serial – other.toserial(); } /** * implementa método necesario para interfaz comparable. * * @param other otro objeto (normalmente otro serialdate). * * @return entero negativo, cero entero positivo este objeto * menor que, igual mayor que objeto especificado. */ public int compareto(final object other) { return compare((serialdate) other); } /** * devuelve true esta serialdate representa misma fecha que * serialdate especificada. * * @param other fecha con que compara. * * @return <codetrue</code esta serialdate representa misma fecha que * otra serialdate especificada. */ public boolean ison(final serialdate other) { return (this.serial == other.toserial()); } /** * devuelve true esta serialdate representa una fecha anterior * serialdate especificada. * * @param other fecha con que compara. * * @return <codetrue</code esta serialdate representa una fecha anterior * serialdate especificada. */ public boolean isbefore(final serialdate other) { return (this.serial < other.toserial()); } /** * devuelve true esta serialdate representa misma fecha que * serialdate especificada. * * @param other fecha con que compara. * * @return <codetrue</code esta serialdate representa misma fecha * que serialdate especificada. */ public boolean isonorbefore(final serialdate other) { return (this.serial <= other.toserial()); } /** * devuelve true esta serialdate representa misma fecha que * serialdate especificada. * * @param other fecha con que compara. * * @return <codetrue</code esta serialdate representa misma fecha * que serialdate especificada. */ public boolean isafter(final serialdate other) { return (this.serial other.toserial()); } /** * devuelve true esta serialdate representa misma fecha que * serialdate especificada. * * @param other fecha con que compara. * * @return <codetrue</code esta serialdate representa misma fecha * que serialdate especificada. */ public boolean isonorafter(final serialdate other) { return (this.serial = other.toserial()); } /** * devuelve <codetrue</code {@link serialdate} encuentra * intervalo especificado (inclusive). orden fecha * importante. * * @param una fecha límite para rango. * @param otra fecha límite para rango. * * @return valor booleano. */ public boolean isinrange(final serialdate , final serialdate ) { return isinrange(, , serialdate.include_both); } /** * devuelve true esta serialdate encuentra intervalo * ( invocador especifica los puntos finales incluyen ). orden * importante. * * @param una fecha límite para rango. * @param otra fecha límite para rango. * @param include código que controla fecha inicial final * incluyen intervalo. * * @return <codetrue</code esta serialdate encuentra intervalo * especificado. */ public boolean isinrange(final serialdate , final serialdate , final int include) { final int = .toserial(); final int = .toserial(); final int start = math.min(, ); final int end = math.max(, ); final int = toserial(); (include == serialdate.include_both) { return ( = start && <= end); } else (include == serialdate.include_first) { return ( = start && < end); } else (include == serialdate.include_second) { return ( start && <= end); } else { return ( start && < end); } } /** * calcular número serie partir del día, mes año. * < * -ene- = . * * @param día. * @param mes. * @param año. * * @return número serie partir del día, mes año. */ private int calcserial(final int , final int , final int ) { final int = (( - ) * ) + serialdate.leapyearcount( - ); int = serialdate.aggregate_days_to_end_of_preceding_month[]; ( monthconstants.february) { (serialdate.isleapyear()) { = + ; } } final int = ; return + + + ; } /** * calcular día, mes año partir del número serie. */ private void calcdaymonthyear() { // obtener año partir del número serie fecha final int days = this.serial - serial_lower_bound; // sobrevalorado que ignoramos los días bisiestos final int overestimatedyyyy = + (days / ); final int leaps = serialdate.leapyearcount(overestimatedyyyy); final int nonleapdays = days - leaps; // subestimado que sobrevaloramos los años int underestimatedyyyy = + (nonleapdays / ); (underestimatedyyyy == overestimatedyyyy) { this.year = underestimatedyyyy; } else { int = calcserial(, , underestimatedyyyy); while ( <= this.serial) { underestimatedyyyy = underestimatedyyyy + ; = calcserial(, , underestimatedyyyy); } this.year = underestimatedyyyy - ; } final int = calcserial(, , this.year); int[] daystoendofprecedingmonth = aggregate_days_to_end_of_preceding_month; (isleapyear(this.year)) { daystoendofprecedingmonth = leap_year_aggregate_days_to_end_of_preceding_month; } // get the month from the serial date int = ; int sss = + daystoendofprecedingmonth[] - ; while (sss < this.serial) { = + ; sss = + daystoendofprecedingmonth[] - ; } this.month = - ; // resto (+); this.day = this.serial - - daystoendofprecedingmonth[this.month] + ; } } listado - relativedayofweekrule.java /* ============================================================= * jcommon : biblioteca gratuita clases propósito general para java() * ============================================================= * * () copyright -, object refinery limited colaboradores. * * información del proyecto: http:// * * esta biblioteca software gratuito; puede distribuirla / modificarla * bajo las condiciones licencia pública general gnu publicada por * free software foundation; sea versión . licencia, * otra versión posterior ( elección). * * esta biblioteca distribuye con intención que sea útil, pero * sin garantía alguna, incluida garantía implícita comerciabilidad * idoneidad para determinado fin. consulte licencia pública general gnu * necesita más información respecto. * * debería haber recibido una copia licencia pública general gnu * junto esta biblioteca; caso contrario, contacte con free software * foundation, inc., franklin street, fifth floor, boston, -, * .. * * [java una marca comercial marca comercial registrada sun * microsystems, inc. estados unidos otros países.] * * -------------------------- * relativedayofweekrule.java * -------------------------- * () copyright -, object refinery limited colaboradores. * * autor original: david gilbert (por object refinery limited); * colaboradores(): -; * * $: relativedayofweekrule.java, . // :: taqua exp $ * * cambios (-oct-) * -------------------------- * -oct- : cambió paquete por com.jrefinery.date.*; * -oct- : corrigen los errores detectados por checkstyle (); * */ package org.jfree.date; /** * una regla fechas anuales que devuelve una fecha por cada año función * () una regla referencia; () día semana () parámetro * selección (serialdate.preceding, serialdate.nearest, serialdate.following). * < * por ejemplo, viernes santo puede especificado ‘ viernes anterior * domingo resurrección. * * @author david gilbert */ public class relativedayofweekrule extends annualdaterule { /** una referencia regla fechas anuales sobre que basa esta regla. */ private annualdaterule subrule; /** * día semana (serialdate.monday, serialdate.tuesday, etc). */ private int dayofweek; /** indica que día semana (preceding, nearest following). */ private int relative; /** * constructor predeterminado: genera una regla para lunes siguiente enero. */ public relativedayofweekrule() { this(new dayandmonthrule(), serialdate.monday, serialdate.following); } /** * constructor estándar: genera una regla función subregla proporcionada. * * @param subrule regla que determina fecha referencia. * @param dayofweek día semana relativo fecha referencia. * @param relative indica “qué” día semana (anterior, más próximo * posterior). */ public relativedayofweekrule(final annualdaterule subrule, final int dayofweek, final int relative) { this.subrule = subrule; this.dayofweek = dayofweek; this.relative = relative; } /** * devuelve subregla (también denominada regla referencia). * * @return regla fechas anuales que determina fecha referencia para * esta regla. */ public annualdaterule getsubrule() { return this.subrule; } /** * establece subregla. * * @param subrule regla fechas anuales que determina fecha * referencia para esta regla. */ public void setsubrule(final annualdaterule subrule) { this.subrule = subrule; } /** * devuelve día semana esta regla. * * @return día semana esta regla. */ public int getdayofweek() { return this.dayofweek; } /** * establece día semana esta regla. * * @param dayofweek día semana (serialdate.monday, * serialdate.tuesday, etc.). */ public void setdayofweek(final int dayofweek) { this.dayofweek = dayofweek; } /** * devuelve atributo ‘relativo’ que determina “qué” * día semana nos interesa (serialdate.preceding, * serialdate.nearest serialdate.following). * * @return atributo ‘relativo’. */ public int getrelative() { return this.relative; } /** * establece atributo ‘relativo’ (serialdate.preceding, serialdate.nearest, * serialdate.following). * * @param relative determina “qué” día semana selecciona con esta * regla. */ public void setrelative(final int relative) { this.relative = relative; } /** * crea clon esta regla. * * @return clon esta regla. * * @throws clonenotsupportedexception nunca debe producirse. */ public object clone() throws clonenotsupportedexception { final relativedayofweekrule duplicate = (relativedayofweekrule) super.clone(); duplicate.subrule = (annualdaterule) duplicate.getsubrule().clone(); return duplicate; } /** * devuelve fecha generada por esta regla, para año especificado. * * @param year año ( &;= year &;= ). * * @return fecha generada por esta regla para año concreto (posiblemente * <codenull</code). */ public serialdate getdate(final int year) { // comprobar argumento… ((year < serialdate.minimum_year_supported) || (year serialdate.maximum_year_supported)) { throw new illegalargumentexception( “relativedayofweekrule.getdate(): year outside valid range.”); } // calcular fecha… serialdate result = null; final serialdate base = this.subrule.getdate(year); (base != null) { switch (this.relative) { case(serialdate.preceding): result = serialdate.getpreviousdayofweek(this.dayofweek, base); break; case(serialdate.nearest): result = serialdate.getnearestdayofweek(this.dayofweek, base); break; case(serialdate.following): result = serialdate.getfollowingdayofweek(this.dayofweek, base); break; default: break; } } return result; } } listado - daydate.java (final) /* ============================================================= * jcommon: biblioteca gratuita clases propósito general para java() * ============================================================= * * () copyright -, object refinery limited colaboradores. … */ package org.jfree.date; import java..serializable; import java.util.*; /** * una clase abstracta que representa fechas inmutables con una precisión * día. implementación asigna cada fecha entero que * representa número ordinal días origen fijo. * * ¿por qué usar java.útil.date? haremos, cuando tenga sentido. ocasiones, * java.util.date puede ser demasiado precisa; representa instante tiempo, * con una precisión / segundo ( fecha depende * zona horaria). ocasiones solo querremos representar día concreto (como * enero ) sin preocuparnos hora del día, * zona horaria otros aspectos. para eso hemos definido serialdate. * * usar daydatefactory.makedate para crear una instancia. * * @author david gilbert * @author robert . martin realizó gran parte refactorización. */ public abstract class daydate implements comparable, serializable { public abstract int getordinalday(); public abstract int getyear(); public abstract month getmonth(); public abstract int getdayofmonth(); protected abstract day getdayofweekforordinalzero(); public daydate plusdays(int days) { return daydatefactory.makedate(getordinalday() + days); } public daydate plusmonths(int months) { int thismonthasordinal = getmonth().toint() - month.january.toint(); int thismonthandyearasordinal = * getyear() + thismonthasordinal; int resultmonthandyearasordinal = thismonthandyearasordinal + months; int resultyear = resultmonthandyearasordinal / ; int resultmonthasordinal = resultmonthandyearasordinal % + month.january.toint(); month resultmonth = month.fromint(resultmonthasordinal); int resultday = correctlastdayofmonth(getdayofmonth(), resultmonth, resultyear); return daydatefactory.makedate(resultday, resultmonth, resultyear); } public daydate plusyears(int years) { int resultyear = getyear() + years; int resultday = correctlastdayofmonth(getdayofmonth(), getmonth(), resultyear); return daydatefactory.makedate(resultday, getmonth(), resultyear); } private int correctlastdayofmonth(int day, month month, int year) { int lastdayofmonth = dateutil.lastdayofmonth(month, year); (day lastdayofmonth) day = lastdayofmonth; return day; } public daydate getpreviousdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.toint() - getdayofweek().toint(); (offsettotarget = ) offsettotarget -= ; return plusdays(offsettotarget); } public daydate getfollowingdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.toint() - getdayofweek().toint(); (offsettotarget <= ) offsettotarget += ; return plusdays(offsettotarget); } public daydate getnearestdayofweek(day targetdayofweek) { int offsettothisweekstarget = targetdayofweek.toint() - getdayofweek().toint(); int offsettofuturetarget = (offsettothisweekstarget + ) % ; int offsettoprevioustarget = offsettofuturetarget - ; (offsettofuturetarget ) return plusdays(offsettoprevioustarget); else return plusdays(offsettofuturetarget); } public daydate getendofmonth() { month month = getmonth(); int year = getyear(); int lastday = dateutil.lastdayofmonth(month, year); return daydatefactory.makedate(lastday, month, year); } public date todate() { final calendar calendar = calendar.getinstance(); int ordinalmonth = getmonth().toint() - month.january.toint(); calendar.set(getyear(), ordinalmonth, getdayofmonth(), , , ); return calendar.gettime(); } public string tostring() { return string.format(“%-%-%”, getdayofmonth(), getmonth(), getyear()); } public day getdayofweek() { day startingday = getdayofweekforordinalzero(); int startingoffset = startingday.toint() - day.sunday.toint(); int ordinalofdayofweek = (getordinalday() + startingoffset) % ; return day.fromint(ordinalofdayofweek + day.sunday.toint()); } public int dayssince(daydate date) { return getordinalday() - date.getordinalday(); } public boolean ison(daydate other) { return getordinalday() == other.getordinalday(); } public boolean isbefore(daydate other) { return getordinalday() < other.getordinalday(); } public boolean isonorbefore(daydate other) { return getordinalday() <= other.getordinalday(); } public boolean isafter(daydate other) { return getordinalday() other.getordinalday(); } public boolean isonorafter(daydate other) { return getordinalday() = other.getordinalday(); } public boolean isinrange(daydate , daydate ) { return isinrange(, , dateinterval.closed); } public boolean isinrange(daydate , daydate , dateinterval interval) { int left = math.min(.getordinalday(), .getordinalday()); int right = math.max(.getordinalday(), .getordinalday()); return interval.isin(getordinalday(), left, right); } } listado - month.java (final) package org.jfree.date; import java.text.dateformatsymbols; public enum month { january(), february(), march(), april(), may(), june(), july(), august(), september(), october(),november(),december(); private static dateformatsymbols dateformatsymbols = new dateformatsymbols(); private static final int[] last_day_of_month = {, , , , , , , , , , , , }; private int index; month(int index) { this.index = index; } public static month fromint(int monthindex) { for (month : month.values()) { (.index == monthindex) return ; } throw new illegalargumentexception(“invalid month index ” + monthindex); } public int lastday() { return last_day_of_month[index]; } public int quarter() { return + (index - ) / ; } public string tostring() { return dateformatsymbols.getmonths()[index - ]; } public string toshortstring() { return dateformatsymbols.getshortmonths()[index - ]; } public static month parse(string ) { = .trim(); for (month : month.values()) (.matches()) return ; try { return fromint(integer.parseint()); } catch (numberformatexception ) {} throw new illegalargumentexception(“invalid month ” + ); } private boolean matches(string ) { return .equalsignorecase(tostring()) || .equalsignorecase(toshortstring()); } public int toint() { return index; } } listado - day.java (final) package org.jfree.date; import java.util.calendar; import java.text.dateformatsymbols; public enum day { monday(calendar.monday), tuesday(calendar.tuesday), wednesday(calendar.wednesday), thursday(calendar.thursday), friday(calendar.friday), saturday(calendar.saturday), sunday(calendar.sunday); private final int index; private static dateformatsymbols datesymbols = new dateformatsymbols(); day(int day) { index = day; } public static day fromint(int index) throws illegalargumentexception { for (day : day.values()) (.index == index) return ; throw new illegalargumentexception( string.format(“illegal day index: %.”, index)); } public static day parse(string ) throws illegalargumentexception { string[] shortweekdaynames = datesymbols.getshortweekdays(); string[] weekdaynames = datesymbols.getweekdays(); = .trim(); for (day day : day.values()) { (.equalsignorecase(shortweekdaynames[day.index]) || .equalsignorecase(weekdaynames[day.index])) { return day; } } throw new illegalargumentexception( string.format(“% not valid weekday string”, )); } public string tostring() { return datesymbols.getweekdays()[index]; } public int toint() { return index; } } listado - dateinterval.java (final) package org.jfree.date; public enum dateinterval { open { public boolean isin(int , int left, int right) { return left && < right; } }, closed_left { public boolean isin(int , int left, int right) { return = left && < right; } }, closed_right { public boolean isin(int , int left, int right) { return left && <= right; } }, closed { public boolean isin(int , int left, int right) { return = left && <= right; } }; public abstract boolean isin(int , int left, int right); } listado - weekinmonth.java (final) package org.jfree.date; public enum weekinmonth { first(), second(), third(), fourth(), last(); private final int index; weekinmonth(int index) { this.index = index; } public int toint() { return index; } } listado - weekdayrange.java (final) package org.jfree.date; public enum weekdayrange { last, nearest, next } listado - dateutil.java (final) package org.jfree.date; import java.text.dateformatsymbols; public class dateutil { private static dateformatsymbols dateformatsymbols = new dateformatsymbols(); public static string[] getmonthnames() { return dateformatsymbols.getmonths(); } public static boolean isleapyear(int year) { boolean fourth = year % == ; boolean hundredth = year % == ; boolean fourhundredth = year % == ; return fourth && (!hundredth || fourhundredth); } public static int lastdayofmonth(month month, int year) { (month == month.february && isleapyear(year)) return month.lastday() + ; else return month.lastday(); } public static int leapyearcount(int year) { int leap = (year - ) / ; int leap = (year - ) / ; int leap = (year - ) / ; return leap - leap + leap; } } listado - daydatefactory.java (final) package org.jfree.date; public abstract class daydatefactory { private static daydatefactory factory = new spreadsheetdatefactory(); public static void setinstance(daydatefactory factory) { daydatefactory.factory = factory; } protected abstract daydate _makedate(int ordinal); protected abstract daydate _makedate(int day, month month, int year); protected abstract daydate _makedate(int day, int month, int year); protected abstract daydate _makedate(java.util.date date); protected abstract int _getminimumyear(); protected abstract int _getmaximumyear(); public static daydate makedate(int ordinal) { return factory._makedate(ordinal); } public static daydate makedate(int day, month month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(int day, int month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(java.util.date date) { return factory._makedate(date); } public static int getminimumyear() { return factory._getminimumyear(); } public static int getmaximumyear() { return factory._getmaximumyear(); } } listado - spreadsheetdatefactory.java (final) package org.jfree.date; import java.util.*; public class spreadsheetdatefactory extends daydatefactory { public daydate _makedate(int ordinal) { return new spreadsheetdate(ordinal); } public daydate _makedate(int day, month month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(int day, int month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(date date) { final gregoriancalendar calendar = new gregoriancalendar(); calendar.settime(date); return new spreadsheetdate( calendar.get(calendar.date), month.fromint(calendar.get(calendar.month) + ), calendar.get(calendar.year)); } protected int _getminimumyear() { return spreadsheetdate.minimum_year_supported; } protected int _getmaximumyear() { return spreadsheetdate.maximum_year_supported; } } listado - spreadsheetdate.java (final) /* ============================================================== * jcommon: biblioteca gratuita clases propósito general para java() * ============================================================== * * () copyright -, object refinery limited colaboradores. * … * */ package org.jfree.date; import static org.jfree.date.month.february; import java.util.*; /** * representa una fecha con entero, forma similar * implementación microsoft excel. intervalo fechas admitido * del -ene- -dic-. * </ * recuerde que excel tiene error que reconoce año * como bisiesto cuando realidad . encontrará más * información sitio microsoft, artículo : * </ * http://support.microsoft.com/support//articles///.asp * </ * excel usa como convención que -ene- = . esta clase usa * convención que -ene- = . * como resultado, número día esta clase será diferente * excel para enero febrero … pero excel añade día * más (-feb- que realidad existe) partir ahí * los números los días coinciden. * * @author david gilbert */ public class spreadsheetdate extends daydate { public static final int earliest_date_ordinal = ; // // public static final int latest_date_ordinal = ; // // public static final int minimum_year_supported = ; public static final int maximum_year_supported = ; static final int[] aggregate_days_to_end_of_preceding_month = {, , , , , , , , , , , , , }; static final int[] leap_year_aggregate_days_to_end_of_preceding_month = {, , , , , , , , , , , , , }; private int ordinalday; private int day; private month month; private int year; public spreadsheetdate(int day, month month, int year) { (year < minimum_year_supported || year maximum_year_supported) throw new illegalargumentexception( “the ‘year’ argument must range ” + minimum_year_supported + “ ” + maximum_year_supported + “.”); (day < || day dateutil.lastdayofmonth(month, year)) throw new illegalargumentexception(“invalid ‘day’ argument.”); this.year = year; this.month = month; this.day = day; ordinalday = calcordinal(day, month, year); } public spreadsheetdate(int day, int month, int year) { this(day, month.fromint(month), year); } public spreadsheetdate(int serial) { (serial < earliest_date_ordinal || serial latest_date_ordinal) throw new illegalargumentexception( “spreadsheetdate: serial must range .”); ordinalday = serial; calcdaymonthyear(); } public int getordinalday() { return ordinalday; } public int getyear() { return year; } public month getmonth() { return month; } public int getdayofmonth() { return day; } protected day getdayofweekforordinalzero() {return day.saturday;} public boolean equals(object object) { (!(object instanceof daydate)) return false; daydate date = (daydate) object; return date.getordinalday() == getordinalday(); } public int hashcode() { return getordinalday(); } public int compareto(object other) { return dayssince((daydate) other); } private int calcordinal(int day, month month, int year) { int leapdaysforyear = dateutil.leapyearcount(year - ); int daysuptoyear = (year - minimum_year_supported) * + leapdaysforyear; int daysuptomonth = aggregate_days_to_end_of_preceding_month[month.toint()]; (dateutil.isleapyear(year) && month.toint() february.toint()) daysuptomonth++; int daysinmonth = day - ; return daysuptoyear + daysuptomonth + daysinmonth + earliest_date_ordinal; } private void calcdaymonthyear() { int days = ordinalday - earliest_date_ordinal; int overestimatedyear = minimum_year_supported + days / ; int nonleapdays = days - dateutil.leapyearcount(overestimatedyear); int underestimatedyear = minimum_year_supported + nonleapdays / ; year = huntforyearcontaining(ordinalday, underestimatedyear); int firstordinalofyear = firstordinalofyear(year); month = huntformonthcontaining(ordinalday, firstordinalofyear); day = ordinalday - firstordinalofyear - daysbeforethismonth(month.toint()); } private month huntformonthcontaining(int anordinal, int firstordinalofyear) { int daysintothisyear = anordinal - firstordinalofyear; int amonth = ; while (daysbeforethismonth(amonth) < daysintothisyear) amonth++; return month.fromint(amonth - ); } private int daysbeforethismonth(int amonth) { (dateutil.isleapyear(year)) return leap_year_aggregate_days_to_end_of_preceding_month[amonth] - ; else return aggregate_days_to_end_of_preceding_month[amonth] - ; } private int huntforyearcontaining(int anordinalday, int startingyear) { int ayear = startingyear; while (firstordinalofyear(ayear) <= anordinalday) ayear++; return ayear - ; } private int firstordinalofyear(int year) { return calcordinal(, month.january, year); } public static daydate createinstance(date date) { gregoriancalendar calendar = new gregoriancalendar(); calendar.settime(date); return new spreadsheetdate(calendar.get(calendar.date), month.fromint(calendar.get(calendar.month) + ), calendar.get(calendar.year)); } } , mientras asistía conferencia agile denver (..), elisabeth hedrickson [] dio una pulsera verde parecida que lance armstrong popularizó hace unos años. ésta leía test obsessed (obsesionado por las pruebas). puse lucí con orgullo. desde que aprendí tdd kent beck , sin duda desarrollo controlado por pruebas obsesionado. pero sucedió algo extraño. podía quitar pulsera. porque hubiera quedado físicamente pegada, sino porque estaba moralmente pegada. pulsera resumía ética profesional. era indicador visible compromiso por crear mejor código posible. hubiera quitado habría traicionado esa ética ese compromiso. todavía llevo muñeca. cuando escribo código, veo ahí. recordatorio constante promesa que hice escribir código limpio. cecil “uncle bob” martin (palo alto california, estados unidos, ). prestigioso desarrollador software desde consultor internacional desde . fundador presidente object mentor, inc., equipo experimentados consultores que ayudan clientes todo mundo diferentes campos programación como ++, java, #, ruby, programación orientada objetos (poo), patrones diseño, uml, metodologías ágiles programación extreme. [] [beck]. << [] cuando ignaz semmelweis recomendó que los médicos lavaran las manos, propuesta fue rechazada aludiendo que los doctores estaban demasiado ocupados para hacerlo entre paciente paciente. << [] http:// << [] [knuth]. << [] una adaptación del mensaje despedida robert stephenson smyth baden-powell los scouts: «intentad dejar este mundo poco mejor como encontrasteis…». << [] como veremos más adelante, aunque contenedor sea una lista , conviene codificar tipo contenedor nombre. << [] imagine que crea una variable con nombre klass sólo porque nombre class usado otro elemento. << [] uncle bob solía hacerlo ++ pero abandonado esta práctica que necesario los ide modernos. << [] http://java.sun.com/products/javabeans/docs/spec.html. << [] una herramienta pruebas código abierto ( << [] una herramienta código abierto para probar unidades para java ( ). << [] pregunté kent todavía conservaba una copia, pero encontró. busqué mis viejos ordenadores, pero nada. solamente conserva recuerdo aquél programa. << [] lenguaje logo usaba palabra clave igual que ruby python usaban def . por tanto, todas las funciones comenzaban por , que tenía efecto interesante cómo diseñaban. << [] [], . . << [] , por supuesto, incluyen cadenas /else. << [] . http://.wikipedia.org/wiki/single_responsibility_principle . http:// << [] . http://.wikipedia.org/wiki/open/closed_principle . http:// << [] [gof]. << [] terminé refactorización módulo que usaba forma dinámica. conseguí convertir módulo outputstream campo clase las invocaciones writefield formato monódico. resultado fue mucho más limpio. << [] existen algunos que creen que pueden evitar volver compilar implementar, nos hemos encargado ellos. << [] ejemplo principio abierto/cerrado (ocp) [ppp]. << [] principio dry. [prag]. << [] []. << [] [], . . << [] tendencia actual los ide comprobar ortografía los comentarios será bálsamo para los que tenemos que leer gran cantidad código. << [] cuadro muestra sigma/ por encima debajo media. asumo que distribución longitud archivos normal, por que desviación estándar matemáticamente precisa. pero aquí objetivo precisión, sino sensación. << [] contrario que sucede lenguajes como pascal, ++ que obligan definir, menos declarar, las funciones antes usarlas. << [] ¿ quien voy engañar? sigo siendo programador lenguajes ensamblado. este caso, hábito hace monje. << [] siempre existe una solución conocida por los diseñadores orientados objetos con experiencia: visitor entrega dual, por ejemplo. pero son técnicas costosas suelen devolver estructura programa por procedimientos. << [] http://.wikipedia.org/wiki/ley_de_demeter. << [] estructura apache. << [] ocasiones denomina feature envy (envidia las características), [refactoring]. << [] [martin]. << [] [becktdd], . -. << [] véase patrón del adaptador [gof]. << [] más información respecto [welc]. << [] professionalism and test-driven development , robert . martin, object mentor, ieee software, mayo/junio (vol. , . ) . - http://doi.ieeecomputersociety.org/./.. << [] http://fitnesse.org/fitnesse.acceptancetestpatterns. << [] véase apartado sobre asignaciones mentales del capítulo . << [] véase entrada dave astel: http:// << [] [rspec]. << [] [gof]. << [] ¡cíñase código! << [] materiales formación object mentor. << [] [rdd]. << [] encontrará más información sobre este principio [ppp]. << [] [knuth]. << [] [ppp]. << [] [ppp]. << [] [mezzaros]. << [] [gof]. << [] véase, por ejemplo, [fowler]. << [] véase [spring], también existe una estructura spring.net. << [] olvide que creación instancias/evaluación tardía sólo una optimización, puede que prematura. << [] sistema administración base datos. << [] consulte [aosd] necesita información general sobre aspectos [aspectj] [colyer] para información concreta aspectj. << [] necesita modificación manual del código fuente destino. << [] véase [cglib], [asm] [javassist]. << [] necesita ejemplos más detallados api proxy ejemplos uso, consulte [goetz]. << [] aop suele confundir con técnicas empleadas para implementarlo, como intercepción envoltorio métodos través proxies . verdadero valor sistema aop capacidad para especificar comportamientos del sistema forma concisa modular. << [] véase [spring] [jboss]. java puro significa sin aspectj. << [] adaptado =introtospring. << [] [gof]. << [] ejemplo puede simplificar mediante mecanismos que usen convenciones anotaciones java para reducir cantidad necesaria lógica conexión explícita. << [] adaptado http:// java-persistence-api.html. << [] véase [aspectj] [colyer]. << [] confundir con práctica diseño anticipado. bduf práctica diseñar todo por adelantado antes implementar nada. << [] existe una cantidad significativa exploración iterativa detalles análisis, incluso una vez iniciada construcción. << [] término fue empleado por primera vez por [kolence]. << [] trabajo [alexander] sido una gran influencia para comunidad software . << [] véase, por ejemplo, [dsl]. [jmock] buen ejemplo api java que crea dsl. << [] [xpe]. << [] [gof]. << [] correspondencia privada. << [] rayos cósmicos, repeticiones, etc. << [] véase apéndice . << [] véase apéndice . << [] [ppp]. << [] véase apéndice . << [] [prag]. << [] [lea]. << [] http://.wikipedia.org/wiki/producer-consumer. << [] http://.wikipedia.org/wiki/readers-writers_problem. << [] http://.wikipedia.org/wiki/problema_de_la_cena_de_los_filósofos. << [] véase apéndice . << [] una sección crítica cualquier sección código que debe protegerse usos simultáneos por parte del programa para que sea correcta. << [] véase apéndice . << [] véase apéndice . << [] ¿sabía que modelo procesos java garantiza procesamiento preventivo? los modernos hacen, modo que obtiene forma gratuita. obstante, mvj garantiza. << [] estrictamente caso. como mvj garantiza los procesos preventivos, determinado algoritmo puede que siempre funcione que prevea los procesos. contrario también posible, pero por distintos motivos. << [] https:// lang=&communityuuid=---bace-. << [] hace poco modifiqué este módulo para ruby. tenía una séptima parte del tamaño original una mejor estructura. << [] para evitar este tipo sorpresas, añadí una nueva prueba unidad que invocaba todas las pruebas fitnesse. << [] junit pocket guide , kent beck, ’reilly. . . . << [] véase capítulo . << [] una solución mejor sería que javadoc presentara todos los comentarios con formato previo, para que tengan mismo aspecto código documento. << [] algunos revisores este texto comparten esta decisión. sostienen que una estructura código abierto más recomendable ejercer control manual sobre serie para que los cambios mínimos del software invaliden las fechas señalizadas antiguas. parece justo. sin embargo, menos fallo, aunque sea inconveniente, tiene motivo evidente. por otra parte, autor clase olvida actualizar , modo fallo será indefinido puede que silencioso. creo que moraleja que debe esperar deserializar entre versiones. << [] [gof]. << [] ibid. << [] ibid. << [] [simmons], . . << [] [refactoring]. << [] [beck]. << [] [refactoring]. << [] http://.wikipedia.org/wiki/principio_de_la_mínima_sorpresa << [] [prag]. << [] [gof]. << [] [gof]. << [] [refactoring]. << [] concreto, principio responsabilidad única, principio abierto/cerrado principio cierre común. véase [ppp]. << [] [beck], . . << [] [beck]. << [] distinto saber cómo funciona código saber algoritmo encargará realizar tarea para que necesita. habitual desconocer algoritmo adecuado. desconocer que hace código indolencia. << [] mejor todavía, una clase money que use enteros. << [] [prag]. . . << [] véase cita ward cunningham del capítulo . << [] [ddd]. << [] puede comprobar personalmente código antes después, revisar las versiones con sin subprocesos, que veremos apartado posterior. << [] una comparación simplificada, pero para los objetivos este ejercicio modelo válido. << [] hecho, interfaz iterator incompatible con subprocesos por naturaleza. diseñó para usar varios subprocesos, modo que debería sorprenderle. << [] por ejemplo, alguien añade resultado depuración problema desaparece. código depuración corrige problema, pero permanece sistema. << [] siglas there ain’ such thing free lunch (todo tiene precio). << [] http:// << [] véase [lea] . . << [] http:// <<