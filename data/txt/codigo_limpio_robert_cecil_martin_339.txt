prueba, vemos que  getFollowingDayOfWeek  devuelve el 25 de diciembre como siguiente sábado después del 25 de diciembre, un error evidente [G3], [T1]. Vemos el problema en la línea 685. Es un error de condición de límite típico [T5]. Debería ser lo siguiente: 685  if (baseDOW >= targetWeekday) { Conviene destacar que esta función sufrió una reparación anterior. El historial de cambios (línea 43) muestra que se corrigieron los errores en getPreviousDayOfWeek ,  getFollowingDayOfWeek  y  getNearestDayOfWeek [T6]. La prueba de unidad  testGetNearestDayOfWeek  (línea 329), que prueba el método  getNearestDayOfWeek  (línea 705), inicialmente no era tan extensa y completa. Añadí multitud de casos de prueba ya que los iniciales no se superaban [T6]. Puede ver el patrón de fallos si se fija en los casos de prueba comentados. El patrón es revelador [T7]. Muestra que el algoritmo falla si el día más próximo es de una fecha futura. Evidentemente se trata de algún tipo de error de condición de límite [T5]. El patrón de alcance de las pruebas generado por Clover también es interesante [T8]. La línea 719 nunca se ejecuta, lo que significa que la instrucción  if  de la línea 718 siempre es  false , pero si nos fijamos en el código, indica que debe ser  true . La variable  adjust  siempre es negativa y no puede ser mayor o igual a 4, por lo que el algoritmo es incorrecto. A continuación se muestra el algoritmo correcto: int delta = targetDOW - base.getDayOfWeek(); int positiveDelta = delta + 7; int adjust = positiveDelta % 7; if (adjust > 3) adjust -= 7; return SerialDate.addDays (adjust, base); Por último, las pruebas de la líneas 417 y 429 se pueden superar si se genera  IllegalArgumentException  en lugar de devolver una cadena de error desde  weekInMonthToString  y  relativeToString . Con estos cambios, todas las pruebas de unidad se superan y creo que ahora  SerialDate  funciona. Llega el momento de hacer que sea correcta. 340