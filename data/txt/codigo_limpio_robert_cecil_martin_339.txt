prueba, vemos que getfollowingdayofweek devuelve el 25 de diciembre como siguiente sábado después del 25 de diciembre, un error evidente [g3], [t1]. vemos el problema en la línea 685. es un error de condición de límite típico [t5]. debería ser lo siguiente: 685 if (basedow >= targetweekday) { conviene destacar que esta función sufrió una reparación anterior. el historial de cambios (línea 43) muestra que se corrigieron los errores en getpreviousdayofweek , getfollowingdayofweek y getnearestdayofweek [t6]. la prueba de unidad testgetnearestdayofweek (línea 329), que prueba el método getnearestdayofweek (línea 705), inicialmente no era tan extensa y completa. añadí multitud de casos de prueba ya que los iniciales no se superaban [t6]. puede ver el patrón de fallos si se fija en los casos de prueba comentados. el patrón es revelador [t7]. muestra que el algoritmo falla si el día más próximo es de una fecha futura. evidentemente se trata de algún tipo de error de condición de límite [t5]. el patrón de alcance de las pruebas generado por clover también es interesante [t8]. la línea 719 nunca se ejecuta, lo que significa que la instrucción if de la línea 718 siempre es false , pero si nos fijamos en el código, indica que debe ser true . la variable adjust siempre es negativa y no puede ser mayor o igual a 4, por lo que el algoritmo es incorrecto. a continuación se muestra el algoritmo correcto: int delta = targetdow - base.getdayofweek(); int positivedelta = delta + 7; int adjust = positivedelta % 7; if (adjust > 3) adjust -= 7; return serialdate.adddays (adjust, base); por último, las pruebas de la líneas 417 y 429 se pueden superar si se genera illegalargumentexception en lugar de devolver una cadena de error desde weekinmonthtostring y relativetostring . con estos cambios, todas las pruebas de unidad se superan y creo que ahora serialdate funciona. llega el momento de hacer que sea correcta. 340