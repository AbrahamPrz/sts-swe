return fexpected.substring(fexpected.length() - fsuffix + 1, end) + (fexpected.length() - fsuffix + 1 < fexpected.length() - fcontextlength ? ellipsis : “”); } private boolean arestringsequal() { return fexpected.equals(factual); } } puede que tenga varias quejas sobre el módulo. incluye expresiones extensas y extraños elementos +1 . pero en general, está bastante bien. después de todo, podría haber sido como el listado 15-3. listado 15-3 comparisoncompator.java (defactorizado) package junit.framework; public class comparisoncompactor { private int ctxt; private string s1; private string s2; private int pfx; private int sfx; public comparisoncompactor(int ctxt, string s1, string s2) { this.ctxt = ctxt; this.s1 = s1; this.s2 = s2; } public string compact(string msg) { if (s1 == null || s2 == null || s1.equals(s2)) return assert.format(msg, s1, s2); pfx = 0; for (; pfx < math.min(s1.length(), s2.length()); pfx++) { if (s1.charat(pfx) != s2.charat(pfx)) break; } int sfx1 = s1.length() - 1; int sfx2 = s2.length() - 1; for (; sfx2 >= pfx && sfx1 >= pfx; sfx2--, sfx1--) { if (s1.charat(sfx1) != s2.charat(sfx2)) break; } sfx = s1.length() - sfx1; string cmp1 = compactstring(s1); string cmp2 = compactstring(s2); return assert.format(msg, cmp1, cmp2); 326