probamos lo siguiente: @Test public void testLogAddAppender() { Logger logger = Logger.getLogger(“MyLogger”); logger.removeAllAppenders(); logger.addAppender(new ConsoleAppender( new PatternLayout(“%p %t %m%n”), ConsoleAppender.SYSTEM_OUT)); logger.info(“hello”); } Funciona; en la consola aparece un mensaje con la palabra  hello . Resulta extraño tener que indicarle a  ConsoleAppender  que escriba en la consola. Al eliminar el argumento  ConsoleAppender.SystemOut , vemos que hello  sigue impreso. Pero al eliminar  PatternLayout , de nuevo vemos la queja de la falta de un flujo de salida. Es un comportamiento muy extraño. Si nos fijamos en la documentación, vemos que el constructor ConsoleAppender  predeterminado no está configurado, lo que no parece demasiado obvio ni útil. Parece más bien un error o una incoherencia de log4j . Tras nuevas búsquedas en Google, investigaciones y pruebas, conseguimos el Listado 8-1. Hemos descubierto cómo funciona  log4j  y hemos codificado esos conocimientos en un grupo de sencillas pruebas de unidad. Listado 8-1 LogTest.java. public class LogTest ( private Logger logger; @Before public void initialize() { logger = Logger.getLogger(“logger”); logger.removeAllAppenders(); Logger.getRootLogger().removeAllAppenders(); } @Test public void basicLogger() { BasicConfigurator.configure(); logger.info(“basicLogger”); } 164