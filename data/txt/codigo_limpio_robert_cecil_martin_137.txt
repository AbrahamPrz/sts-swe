Rectangle r = (Rectangle)shape; return r.height * r.width; } else if (shape instanceof Circle) { Circle c = (Circle)shape; return PI * c.radius * c.radius; } throw new NoSuchShapeException(); } } Los programadores orientados a objetos se quejarán de que es un ejemplo de procedimiento, y tienen razón. Imagine qué pasaría si añadimos la función perimeter()  a  Geometry . ¡Las clases de formas no se verían afectadas! ¡Y las demás clases que dependieran de las formas tampoco! Por otra parte, si añado una nueva forma, tendría que cambiar todas las funciones de  Geometry . Vuélvalo a leer. Comprobará que las dos condiciones son diametralmente opuestas. Fíjese ahora en la solución orientada a objetos del Listado 6-6. Aquí, el método  area()  es polimórfico. No se necesita una clase  Geometry . Por tanto, si añado una nueva forma, ninguna de las funciones existentes se ven afectadas, pero si añado otra función, habrá que cambiar todas las formas [29] . Listado 6-6 Formas polimórficas. public class Square implements Shape { private Point topLeft; private double side; public double area() { return side*side; } public class Rectangle implements Shape { private Point topLeft; private double height; private double width; public double area() { return height * width; } } public class Circle implements Shape { private Point center; 138