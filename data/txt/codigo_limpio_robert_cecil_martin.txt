cada año, se invierten innumerables horas y se pierden numerosos recursos debido a código mal escrito, ralentizando el desarrollo, disminuyendo la productividad, generando graves fallos e incluso pudiendo acabar con la organización o empresa. el reconocido experto de software robert c. martin, junto con sus colegas de object mentor, nos presentan sus óptimas técnicas y metodologías ágiles para limpiar el código sobre la marcha y crearlo de forma correcta, de este modo mejorará como programador. esta obra se divide en tres partes. la primera describe los principios, patrones y prácticas para crear código limpio. la segunda incluye varios casos de estudio cuya complejidad va aumentando. cada ejemplo es un ejercicio de limpieza y transformación de código con problemas. la tercera parte del libro contiene una lista de heurística y síntomas de código erróneo (smells) confeccionada al crear los casos prácticos. el resultado es una base de conocimientos que describe cómo pensamos cuando creamos, leemos y limpiamos código. imprescindible para cualquier desarrollador, ingeniero de software, director de proyectos, jefe de equipo o analista de sistemas interesado en crear código de mejor calidad. ¡el libro que todo programador debe leer! 2robert cecil martin código limpio manual de estilo para el desarrollo ágil de software epub r1.1 xcuidi 21.03.2018 3título original: clean code: a handbook of agile software craftsmanship robert cecil martin, 2009 traducción: josé luis gómez celador ilustraciones: jeniffer kohnke & angela brooks editor digital: xcuidi colaborador: mario j. c. (pdf-español) epub base r1.2 este libro se ha maquetado siguiendo los estándares de calidad de www.epublibre.org. la página, y sus editores, no obtienen ningún tipo de beneficio económico por ello. si ha llegado a tu poder desde otra web debes saber que seguramente sus propietarios sí obtengan ingresos publicitarios mediante archivos como este 4para ann marie: el verdadero amor de mi vida. 5agradecimientos me gustaría dar las gracias a mis dos artistas, jeniffer kohnke y angela brooks. jennifer es la encargada de las impresionantes ilustraciones del inicio de cada capítulo y también de los retratos de kent beck, ward cunningham, bjarne stroustrup, ron jeffries, grady booch, dave thomas, michael feathers y el mío propio. angela se encarga de las ilustraciones internas de los capítulos. ha realizado muchos dibujos para mí en los últimos años, incluidos muchos de los del libro agile software development: principles, patterns, and practices . también es mi primogénita. un agradecimiento especial a los revisores bob bogetti, george bullock, jeffrey overbey y especialmente matt heusser. han sido increíbles. han sido inmisericordes. han sido minuciosos. me han forzado al máximo para realizar las mejoras necesarias. gracias a mi editor, chris guzikowski, por su apoyo, aliento y amistad. gracias a todo el personal de la editorial, incluida raina chrobak, que se encargó de que fuera honesto y cumpliera los plazos. gracias a micah martin y a todos los de 8th light (www.8thlight.com) por sus críticas y su apoyo. gracias a todos los object mentor, pasados, presentes y futuros, incluidos bob koss, michael feathers, michael hill, erik meade, jeff langr, pascal roy, david farber, brett schuchert, dean wampler, tim ottinger, dave thomas, james grenning, brian button, ron jeffries, lowell lindstrom, angelique martin, cindy sprague, libby ottinger, joleen craig, janice 6brown, susan rosso y el resto. gracias jim newkirk, mi amigo y socio, que me ha enseñado más de lo que cree. mi agradecimiento a kent beck, martin fowler, ward cunningham, bjarne stroustrup, grady booch y todos mis mentores, compatriotas y colegas. gracias a john vlissides por estar ahí cuando lo necesitaba. gracias a todos los de zebra por permitirme despotricar sobre la extensión que debe tener una función. y, por último, darle las gracias por leer estos agradecimientos. 7prólogo una de nuestras golosinas preferidas en dinamarca es ga-jol , con un fuerte sabor a regaliz, que constituye un complemento perfecto para nuestro húmedo y frío clima. parte del encanto de ga-jol para los daneses es la frase que suele incluir en el envoltorio. esta mañana compré un paquete de dos y me encontré con este antiguo dicho danés: ærlighed i små ting er ikke nogen lille ting. «la honestidad por las cosas pequeñas no es algo menor». perfecto para que lo que pensaba escribir. las cosas pequeñas importan. este libro trata sobre humildes preocupaciones cuyo valor dista mucho de ser menor. 8dios está en los detalles , afirmó el arquitecto ludwig mies van der rohe. esta cita recuerda argumentos contemporáneos sobre el papel de la arquitectura en el desarrollo de software , en especial en el universo ágil. bob y yo hemos tenido esta conversación muchas veces. y sí, mies van der rohe se fijaba en la utilidad y la forma atemporal de la construcción que subyace a las grandes creaciones arquitectónicas. por otra parte, seleccionaba personalmente los pomos de todas las puertas de todas las casas que diseñaba. ¿por qué? porque las cosas pequeñas importan. en nuestro interminable debate sobre tdd, bob y yo coincidimos en que la arquitectura del software desempeña una importante labor en el desarrollo, aunque tenemos diferentes visiones de lo que esto significa. estas diferencias carecen de importancia, ya que podemos aceptar que los profesionales responsables dedican parte de su tiempo a planificar un proyecto antes de comenzarlo. las nociones de diseño controlado únicamente por pruebas y el código, propias de finales de la década de 1990, ya no son válidas. y la atención al detalle es un pilar fundamental de los profesionales, casi como cualquier visión. por un lado, la práctica en los detalles otorga dominio a los profesionales, y aumenta su confianza para la práctica a mayor escala. por otra parte, el más mínimo fallo de construcción, una puerta que no cierre bien o un baldosín mal colocado, acaba con el encanto del todo. de eso se trata el código limpio. pero la arquitectura es sólo una metáfora del desarrollo de software y en concreto de la parte del software que ofrece el producto inicial, de la misma forma que un arquitecto entrega un edificio inmaculado. hoy en día, el objetivo es comercializar rápidamente los productos. queremos que las fábricas produzcan software a pleno rendimiento. se trata de fábricas humanas, programadores que piensan, que sienten y que trabajan para crear un producto. la metáfora de la manufacturación es incluso más evidente en este pensamiento. los aspectos productivos de las fábricas de automóviles japonesas fueron una gran inspiración para serum. pero incluso en la industria automovilística, gran parte del trabajo no radica en la fabricación sino en el mantenimiento, o más bien en cómo evitarlo. en el software , el 80 por 100 o más de lo que hacemos se denomina cuantitativamente mantenimiento, el acto de reparar. en lugar de optar por la 9típica costumbre occidental de crear software de calidad, debemos pensar como reparadores o mecánicos. ¿qué piensan los directores japoneses de todo esto? en 1951, un enfoque de calidad denominado tpm ( total productive maintenance o mantenimiento productivo total) apareció en escena. se centraba en el mantenimiento y no en la producción. uno de los pilares de tpm es el conjunto de principios denominados 5s, una serie de disciplinas. estos principios 5s son en realidad la base lean, otro conocido término en la escena occidental, y cada vez más presente en el mundo del software . estos principios no son opcionales. como indica uncle bob, la práctica del software correcto requiere disciplina. no siempre se trata de hacer, de producir a la velocidad óptima. la filosofía 5s incluye estos conceptos: seiri u organización : es fundamental saber dónde están las cosas, mediante enfoques como el uso de nombres correctos. ¿cree que los nombres de los identificadores no son relevantes? lea los siguientes capítulos. seiton o sistematización : existe un antiguo dicho norteamericano: un sitio para cada cosa y cada cosa en su sitio. un fragmento de código debe estar donde esperamos encontrarlo; en caso contrario, refactorice hasta conseguirlo. seiso o limpieza : mantenga limpio el lugar de trabajo. ¿qué dicen los autores sobre inundar el código de comentarios y líneas que capturan historias o deseos futuros? elimínelos. seiketsu o estandarización : el grupo decide cómo mantener limpio el lugar de trabajo. ¿cree que este libro habla sobre tener un estilo de código coherente y una serie de prácticas dentro del grupo? ¿de dónde provienen esos estándares? siga leyendo. shutsuke o disciplina : significa ser disciplinado en la aplicación de las prácticas y reflejarlas en el trabajo y aceptar los cambios. si acepta el reto, ha leído bien, el reto, de leer y llevar a la práctica este libro, podrá comprender y apreciar el último punto. aquí nos acercamos a la 10raíz de la profesionalidad responsable de una profesión que debería preocuparse del ciclo vital de un producto. al igual que mantenemos coches y otras máquinas, el mantenimiento divisible, esperar a que surjan los errores, es la excepción. por el contrario, ascendemos un nivel: inspeccionamos diariamente las máquinas y arreglamos los componentes gastados antes de que se rompan, o cambiamos el aceite cada varios miles de kilómetros para evitar problemas. en el código, debemos refactorizar sin compasión. puede ascender otro nivel más, como hizo el movimiento tpm hace 50 años: crear máquinas que se pueden mantener mejor. crear código legible es tan importante como crear código ejecutable. la práctica definitiva, que apareció en los círculos tpm en 1960, es la que se centra en introducir nuevas máquinas o sustituir las antiguas. como fred brooks nos advirtió, deberíamos rehacer el software cada siete años para eliminar los problemas latentes. tendríamos que actualizar este plazo por semanas, días e incluso horas en lugar de años. ahí es donde se encuentra el detalle. el detalle tiene un gran poder, y es un enfoque vital humilde y profundo, como es de esperar de cualquier enfoque de origen japonés. pero no es sólo la visión oriental de la vida; también lo encontramos en el pueblo norteamericano. la cita seiton anterior proviene de la pluma de un ministro de ohio que, literalmente, consideraba la limpieza como un remedio para todas las formas del mal. ¿y seiso ? la limpieza es la pureza . aunque una casa sea bella, el mobiliario inadecuado acaba con su encanto. ¿y la opinión de shutsuke al respecto? el que confíe en lo pequeño confiará en lo superior . ¿y la predisposición a refactorizar en el momento adecuado, reforzando nuestra posición para las posteriores grandes decisiones, en lugar de dejarlo pasar? una puntada a tiempo ahorra ciento. al que madruga, dios le ayuda. no dejes para mañana lo que puedas hacer hoy (éste era el sentido original de la frase «en el momento adecuado» de lean hasta que cayó en manos de consultores de software ). ¿y sobre calibrar la importancia de los pequeños esfuerzos individuales en un todo mayor? de pequeñas semillas crecen grandes árboles . ¿y la integración de sencillas tareas preventivas en la vida diaria? más vale prevenir que curar . el código limpio honra las raíces de la sabiduría popular, de antes o de ahora, y se puede aplicar con atención al detalle. 11incluso en la literatura arquitectónica encontramos ejemplos de estos detalles. piense en los pomos de mies van der rohe. eso es seiri . es la atención a todos los nombres de variables. debe bautizar a una variable con el mismo cuidado como si fuera su primogénito. y como todo sabemos, este cuidado no acaba nunca. el arquitecto christopher alexander, padre de patrones y lenguajes de patrones, considera todo acto de diseño como un pequeño acto local de reparación, y considera la maestría de la estructura como competencia única del arquitecto; las formas mayores se ceden a los patrones y su aplicación a los habitantes. el diseño es interminable no sólo al añadir una nueva habitación a una casa, sino al prestar atención a la pintura, a cambiar las alfombras o a instalar un nuevo fregadero en la cocina. otras artes muestran sentimientos análogos. en nuestra búsqueda por la importancia de los detalles, nos topamos con el autor francés del siglo xix gustav flaubert. el poeta francés paul valery afirma que un poema no se acaba nunca y que tiene que retocarse continuamente, y que dejar de trabajar en el poema es señal de abandono. tal preocupación por el detalle es común en todas las empresas de excelencia. puede que esto no sea nada nuevo, pero al leer este libro sentirá la necesidad de adoptar disciplinas rechazadas en su momento por apatía o por un deseo de espontaneidad o una simple respuesta al cambio. desafortunadamente, no solemos considerar estas preocupaciones la clave del arte de la programación. renunciamos pronto a nuestro código, no porque lo hayamos completado, sino porque nuestro sistema de valores se centra en el futuro más que en la sustancia de nuestros productos. esto tiene un precio final: hierba mala nunca muere . la investigación, ni en el mundo industrial ni en el académico, se reduce a mantener limpio el código. cuando trabajaba en la organización bell labs software production research (sin duda de producción) comprobamos que un estilo de sangrado coherente era uno de los mayores indicadores estadísticamente significativos de una baja densidad de errores. queremos que una arquitectura, un lenguaje de programación u otra noción superior sea el motivo de la calidad; como seres cuya supuesta profesionalidad se debe al dominio de herramientas y métodos de diseño, nos sentimos insultados por el valor que los programadores añaden con tan sólo aplicar un estilo de sangrado coherente. 12para citar mi propio libro de hace 17 años, dicho estilo distingue la excelencia de la simple competencia. la visión japonesa comprende el verdadero valor del trabajador cotidiano y, en especial, de los sistemas de desarrollo que dependen de las sencillas acciones diarias de tales trabajadores. la calidad es el resultado de un millón de acciones cuidadosas, no de un método magnífico caído del cielo. que dichas acciones sean simples no significa que sean simplistas, y mucho menos que sean sencillas. son la base de la grandeza y, cada vez más, de cualquier empresa humana. ignorarlas no es humano en absoluto. evidentemente, todavía defiendo el pensamiento global, en especial el valor de los enfoques arquitectónicos cimentados en el conocimiento de los dominios y la capacidad de uso del software . este libro no versa sobre esto, al menos no de forma evidente. este libro transmite un mensaje más sutil cuya profundidad no debe menospreciarse. coincide con la visión de gente como peter sommerlad, kevlin henney y giovanni asproni, cuyos mantras son «el código es el diseño» y «código simple». aunque debemos recordar que la interfaz es el programa y que sus estructuras dicen mucho sobre la propia estructura del programa, es fundamental adoptar de forma continuada la humilde posición de que el diseño vive en el código. y aunque los cambios y la metáfora de la fábrica supongan costes, los cambios de diseño suponen valor. debemos considerar al código como la articulación de los esfuerzos de diseño, visto como un proceso, no como algo estático. es en el código donde se desarrollan los conceptos arquitectónicos de conexión y cohesión. si escucha a larry constantine describir la conexión y la cohesión, lo hace en términos del código, no desde conceptos abstractos propios de uml. en su ensayo abstraction descant , richard gabriel afirma que la abstracción es el mal. el código es el remedio al mal y el código limpio puede que sea divino. volviendo a mi caja de ga-jol , considero importante recordar que la sabiduría danesa nos recomienda no sólo prestar atención a las pequeñas cosas, sino también ser honestos con ellas. esto significa ser honesto con el código, con nuestros colegas sobre el estado del código y, en especial, con nosotros mismos. ¿hemos hecho todo lo posible para dejar las cosas mejor que como las encontramos? ¿hemos refactorizado el código antes de terminarlo? no se trata de preocupaciones periféricas, sino que se encuentran 13en la base misma de los valores agile. en serum se recomienda que la refactorización sea parte del concepto de terminado. ni la arquitectura ni el código limpio insisten en la perfección, sino en la honestidad y en hacerlo lo mejor posible. errar es humano; perdonar es divino . en serum, todo lo hacemos de forma visible. aireamos los trapos sucios. somos honestos sobre el estado de nuestro código ya que nunca es perfecto. nos hemos hecho más humanos, más merecedores de lo divino y estamos más próximos a la grandeza de los detalles. en nuestra profesión, necesitamos desesperadamente toda la ayuda posible. si un suelo seco reduce el riesgo de resbalones y las herramientas bien organizadas aumentan la productividad, es nuestra meta. y en cuanto al libro, es la mejor aplicación pragmática de los principios lean de software que he visto nunca en formato impreso. no esperaba menos de este grupo de individuos que durante años se han esforzado no sólo por mejorar sino en ofrecer sus conocimientos a la industria mediante obras como la que ahora tiene entre manos. hace que el mundo sea un poco mejor que antes de que uncle bob me enviara el manuscrito. y tras completar este ejercicio, me dispongo a limpiar mi escritorio. james o. coplien mørdrup, dinamarca 14introducción reproducido con permiso de thom holwerda. http://www.osnews.com/story/19266/wtfs_m. © 2008 focus shift. ¿qué puerta representa su código? ¿qué puerta representa a su equipo o a su 15empresa? ¿por qué estamos en esa habitación? ¿es una sencilla revisión del código o hemos detectado un sinfín de problemas terribles? ¿depuramos presas del pánico el código que pensábamos que funcionaba? ¿los clientes huyen despavoridos y los directores nos pisan los talones? ¿cómo asegurarnos de que abrimos la puerta correcta cuando las cosas se ponen feas? la respuesta: la maestría . la maestría se consigue de dos formas: conocimientos y trabajo. debe adquirir el conocimiento de los principios, patrones, prácticas y heurística propios de un maestro, y dominar dichos conocimientos a través de la práctica. puedo enseñarle la teoría de montar en bicicleta. de hecho, los conceptos matemáticos clásicos son muy sencillos. gravedad, fricción, velocidad angular, centro de masa, etc., se pueden demostrar en menos de una página repleta de ecuaciones. con esas fórmulas, puedo demostrar que montar en bicicleta es práctico y proporcionarle los conocimientos necesarios para conseguirlo. pero la primera vez que se monte en una bici se caerá al suelo. el diseño de código no es diferente. podríamos enumerar todos los principios del código limpio y confiar en que se encargue del resto (es decir, dejar que se cayera de la bici) pero entonces la pregunta sería qué clase de profesores somos y qué clase de alumno sería. no. así no funciona este libro. aprender a crear código limpio es complicado . requiere algo más que conocer principios y patrones. tiene que sudar. debe practicarlo y fallar. debe ver cómo otros practican y fallan. debe observar cómo se caen y recuperan el paso. debe ver cómo agonizan en cada decisión y el precio que pagan por tomar decisiones equivocadas. para leer este libro, prepárese a trabajar duro. no es un libro que se pueda leer en un avión y terminarlo antes de aterrizar. este libro le hará trabajar, y mucho. ¿y qué tipo de trabajo? tendrá que leer código, en abundancia. y se le pedirá que piense en qué acierta el código y en qué falla. se le pedirá que siga nuestras descripciones mientras despedazamos módulos y los volvemos a ensamblar. para ello necesitará tiempo y esfuerzo, pero creemos que merece la pena. hemos dividido el libro en tres partes. los primeros capítulos describen 16los principios, patrones y prácticas para crear código limpio. incluyen abundante código y resultan difíciles de leer. sirven como preparación a la segunda parte. si abandona tras leer la primera sección, que tenga buena suerte. la segunda parte del libro es la más difícil. incluye varios casos de estudio cuya complejidad va aumentando. cada ejemplo es un ejercicio de limpieza de código, transformar código con problemas para que tenga menos problemas. el detalle de esta parte es abundante . tendrá que alternar entre el texto y los listados de código. tendrá que analizar y entender el código, y comprender el razonamiento de cada cambio realizado. piense en que esta parte le llevará varios días . la tercera parte del libro es un único capítulo que contiene una lista de heurística y síntomas de código erróneo ( smells ) confeccionada al crear los casos prácticos. al analizar y limpiar el código de los ejemplos, documentamos el motivo de todas nuestras acciones como heurística o síntoma. intentamos comprender nuestras reacciones al código que leíamos y modificábamos, y nos esforzamos por capturar las sensaciones que tuvimos y las decisiones que adoptamos. el resultado es una base de conocimientos que describe cómo pensamos cuando creamos, leemos y limpiamos código. esta base de conocimientos no le servirá de mucho si no lee atentamente los casos de la segunda parte del libro. en esos capítulos hemos anotado con precisión todos los cambios realizados con referencias a la heurística. estas referencias se muestran entre corchetes, como [h22]. de este modo puede ver el contexto en el que se ha aplicado y creado dicha heurística. no importa tanto el propio valor de las heurísticas sino la relación entre ellas y las decisiones adoptadas al limpiar el código en los ejemplos . si lee la primera y la tercera parte y se salta los casos prácticos, habrá leído otro libro distinto sobre cómo crear código correcto, pero si dedica tiempo a analizar los casos, sigue todos y cada uno de los pasos, cada una de las decisiones, si se pone en nuestro lugar y se obliga a pensar tal y como lo hicimos nosotros, entonces comprenderá mucho mejor todos los principios, patrones, prácticas y heurística. ya no será un conocimiento superficial. se convertirá en algo profundo. lo integrará de la misma forma que una bicicleta se convierte en una extensión propia una vez dominada la forma de 17montar. 18sobre la imagen de cubierta la imagen de la portada es m104: la galaxia del sombrero. m104 se encuentra en virgo, a unos 30 millones de años luz, y su núcleo es un súper agujero negro que pesa aproximadamente mil millones de masas solares. ¿la imagen le recuerda la explosión de la luna praxis de klingon? recuerdo la escena de star trek vi en la que se mostraba un anillo de restos flotando tras la explosión. tras esa escena, el anillo se ha convertido en un elemento habitual de las explosiones de ciencia ficción. incluso se añadió a la explosión de alderaan en ediciones posteriores de la primera película de la guerra de las galaxias. ¿qué provocó la formación de este anillo alrededor de m104? ¿por qué tiene un centro de tales dimensiones y un núcleo tan brillante y diminuto? parece como si el agujero negro central hubiera provocado un orificio de 30 000 años luz en el centro de la galaxia. la desgracia caería sobre las civilizaciones que se encontraran en el camino de este desastre cósmico. los súper agujeros negros desayunan estrellas y convierten parte de su masa en energía. e=mc 2 puede bastar, pero cuando m es una masa estelar hay que tener cuidado. ¿cuántas estrellas habrá engullido este monstruo antes de saciar su apetito? el tamaño del vacío central podría ser una pista. la imagen de m104 de la portada es una combinación de la famosa fotografía del hubble (imagen superior) y la reciente imagen de infrarrojos del observatorio orbital spitzer (inferior). esta última muestra claramente la forma de anillo de la galaxia. a la luz, sólo vemos el borde frontal de la silueta del anillo. 19imagen de portada: © spitzet space telescope. la masa central oculta el resto. pero en la imagen de infrarrojos, las partículas calientes del anillo brillan a través de la masa central. las dos imágenes combinadas nos ofrecen una vista desconocida hasta ahora e implican que hace tiempo era un auténtico infierno activo. 201 código limpio está leyendo este libro por dos motivos. por un lado, es programador. por otro, quiere ser mejor programador. perfecto. necesitamos mejores 21programadores. este libro trata sobre programación correcta. está repleto de código. lo analizaremos desde todas las direcciones. desde arriba, desde abajo y desde dentro. cuando terminemos, sabremos mucho sobre código y, en especial sabremos distinguir entre código correcto e incorrecto. sabremos cómo escribir código correcto y cómo transformar código incorrecto en código correcto. hágase el código se podría afirmar que un libro sobre código es algo obsoleto, que el código ya no es el problema y que deberíamos centrarnos en modelos y requisitos. hay quienes sugieren que el final del código está próximo. que los programadores ya no serán necesarios porque los empresarios generarán programas a partir de especificaciones. no es cierto. el código nunca desaparecerá, ya que representa los detalles de los requisitos. en algún nivel, dichos detalles no se pueden ignorar ni abstraer; deben especificarse, y para especificar requisitos de forma que un equipo pueda ejecutarlos se necesita la programación. dicha especificación es el código. espero que el nivel de abstracción de nuestros lenguajes siga aumentando. también espero que aumente el número de lenguajes específicos de dominios. será algo positivo, pero no eliminará el código. de hecho, todas las especificaciones creadas en estos lenguajes de nivel superior y específicos de los dominios serán código, y tendrá que ser riguroso, preciso, formal y detallado para que un equipo pueda entenderlo y ejecutarlo. el que piense que el código va a desaparecer es como el matemático que espera que un día las matemáticas no sean formales. esperan descubrir una forma de crear máquinas que hagan lo que queramos en lugar de lo que digamos. esas máquinas tendrían que entendernos de tal forma que puedan traducir necesidades ambiguas en programas perfectamente ejecutados que satisfagan dichas necesidades a la perfección. esto nunca sucederá. ni siquiera los humanos, con toda su intuición y 22creatividad, han sido capaces de crear sistemas satisfactorios a partir de las sensaciones de sus clientes. en realidad, si la disciplina de la especificación de requisitos nos ha enseñado algo es que los requisitos bien especificados son tan formales como el código y que pueden actuar como pruebas ejecutables de dicho código. recuerde que el código es básicamente el lenguaje en el que expresamos los requisitos en última instancia. podemos crear lenguajes que se asemejen a dichos requisitos. podemos crear herramientas que nos permitan analizar y combinar dichos requisitos en estructuras formales, pero nunca eliminaremos la precisión necesaria; por ello, siempre habrá código. código incorrecto recientemente leí el prólogo del libro implementation pattern [1] de kent beck, donde afirmaba que «…este libro se basa en una frágil premisa: que el código correcto es relevante…». ¿una frágil premisa? en absoluto. considero que es una de las más robustas, admitidas e importantes de nuestro sector (y creo que kent lo sabe). sabemos que el código correcto es relevante porque durante mucho tiempo hemos tenido que sufrir su ausencia. sé de una empresa que, a finales de la década de 1980, creó una magnífica aplicación, muy popular y que muchos profesionales compraron y utilizaron. pero los ciclos de publicación empezaron a distanciarse. no se corrigieron los errores entre una versión y la siguiente. crecieron los tiempos de carga y aumentaron los fallos. todavía recuerdo el día en que apagué el producto y nunca más lo volví a usar. poco después, la empresa desapareció. 23dos décadas después conocí a uno de los empleados de la empresa y le pregunté sobre lo que había pasado. la respuesta confirmó mis temores. habían comercializado el producto antes de tiempo con graves fallos en el código. al añadir nuevas funciones, el código empeoró hasta que ya no pudieron controlarlo. el código incorrecto fue el motivo del fin de la empresa . ¿en alguna ocasión el código incorrecto le ha supuesto un obstáculo? si es programador seguramente sí. de hecho, tenemos una palabra que lo describe: sortear . tenemos que sortear el código incorrecto. nos arrastramos por una maraña de zarzas y trampas ocultas. intentamos buscar el camino, una pista de lo que está pasando, pero lo único que vemos es más y más código sin sentido. sin duda el código incorrecto le ha supuesto un obstáculo. entonces, ¿por qué lo escribió? ¿tenía prisa? ¿plazos de entrega? seguramente. puede que pensara que no tenía tiempo para hacer un buen trabajo; que su jefe se enfadaría si necesitaba tiempo para limpiar su código. o puede que estuviera cansado de trabajar en ese programa y quisiera acabar cuanto antes. o que viera el trabajo pendiente y tuviera que acabar con un módulo para pasar al siguiente. a todos nos ha pasado. todos hemos visto el lío en el que estábamos y hemos optado por dejarlo para otro día. todos hemos sentido el alivio de ver cómo un programa incorrecto funcionaba y hemos decidido que un mal programa que funciona es mejor que nada. todos hemos dicho que lo solucionaríamos después. evidentemente, por aquel entonces, no conocíamos la ley de leblanc: después es igual a nunca . el coste total de un desastre si es programador desde hace dos o tres años, probablemente haya sufrido los desastres cometidos por otros en el código. si tiene más experiencia, lo habrá sufrido en mayor medida. el grado de sufrimiento puede ser significativo. en un periodo de un año o dos, los equipos que avancen rápidamente al inicio de 24un proyecto pueden acabar a paso de tortuga. cada cambio en el código afecta a dos o tres partes del mismo. ningún cambio es trivial. para ampliar o modificar el sistema es necesario comprender todos los detalles, efectos y consecuencias, para de ese modo poder añadir nuevos detalles, efectos y consecuencias. con el tiempo, el desastre aumenta de tal modo que no se puede remediar. es imposible. al aumentar este desastre, la productividad del equipo disminuye y acaba por desaparecer. al reducirse la productividad, el director hace lo único que puede: ampliar la plantilla del proyecto con la esperanza de aumentar la productividad. pero esa nueva plantilla no conoce el diseño del sistema. no conocen la diferencia entre un cambio adecuado al objetivo de diseño y otro que lo destroce. por tanto, todos se encuentran sometidos a una gran presión para aumentar la productividad. por ello, cometen más errores, aumenta el desastre y la productividad se acerca a cero cada vez más (véase la figura 1.1). figura 1.1. productividad frente a tiempo. el gran cambio de diseño en última instancia, el equipo se rebela. informan al director que no pueden seguir trabajando con ese código. exigen un cambio de diseño. la dirección no requiere invertir en un cambio de diseño del proyecto, pero no puede ignorar el bajo nivel de productividad. 25acaba por ceder a las exigencias de los programadores y autoriza el gran cambio de diseño. se selecciona un nuevo equipo. todos quieren formar parte del nuevo equipo por ser un lienzo en blanco. pueden empezar de cero y crear algo realmente bello, pero sólo los mejores serán elegidos para el nuevo equipo. los demás deben continuar con el mantenimiento del sistema actual. ahora los dos equipos compiten. el nuevo debe crear un sistema que haga lo que el antiguo no puede. además, deben asumir los cambios que continuamente se aplican al sistema antiguo. la dirección no sustituirá el sistema antiguo hasta que el nuevo sea capaz de hacer todo lo que hace el antiguo. esta competición puede durar mucho tiempo. conozco casos de casi 10 años. y cuando acaba, los miembros originales del equipo nuevo han desaparecido y los miembros actuales exigen un cambio de diseño del nuevo sistema porque es un desastre. si ha experimentado alguna fase de esta historia, ya sabrá que dedicar tiempo a que el código sea correcto no sólo es rentable, es una cuestión de supervivencia profesional. actitud ¿alguna vez ha tenido que superar un desastre tan grave que ha tardado semanas en lo que normalmente hubiera tardado horas? ¿ha visto un cambio que debería haberse realizado en una línea, aplicado en cientos de módulos distintos? son síntomas demasiado habituales. ¿por qué sucede en el código? ¿por qué el código de calidad se transforma tan rápidamente en código incorrecto? hay muchas explicaciones. nos quejamos de que los requisitos cambian de forma que comprometen el diseño original, de que los plazos de entrega son demasiado exigentes para hacer las cosas bien. culpamos a directores incompetentes, a usuarios intolerantes y a comerciales sin sentido. pero la culpa, querido dilbert, es nuestra. no somos profesionales. puede que resulte duro escucharlo. ¿cómo es posible que seamos responsables de tales desastres? ¿qué pasa con los requisitos? ¿y los plazos de entrega? ¿y los directores incompetentes y los comerciales sin sentido? 26¿no es también culpa suya? no. los directores y los comerciales nos exigen la información que necesitan para realizar sus promesas y compromisos, e incluso cuando no recurren a nosotros, no debemos tener miedo a decirles lo que pensamos. los usuarios acuden a nosotros para validar la forma de encajar los requisitos en el sistema. los directores de proyectos acuden a nosotros para determinar los objetivos. somos cómplices en la programación del proyecto y compartimos gran parte de la responsabilidad de los fallos, en especial si tienen que ver con código incorrecto. seguramente piense que, si no hace lo que su jefe le dice, le despedirán. es improbable. muchos jefes sólo quieren la verdad, aunque lo disimulen. muchos quieren código correcto, aunque estén obsesionados con los objetivos. pueden defender apasionadamente los objetivos y los requisitos, pero es su trabajo. el nuestro es defender el código con la misma intensidad. para resumir, imagine que es médico y un paciente le exige que no se lave las manos antes de una operación porque se pierde demasiado tiempo [2] . en este caso, el paciente es el jefe, pero el médico debe negarse a lo que pide. ¿por qué? porque el médico sabe más que el paciente sobre los riesgos de infecciones. no sería profesional (incluso sería ilegal) que el médico cediera a las exigencias del paciente. tampoco sería profesional que los programadores cedieran a la voluntad de los jefes que no entienden los riesgos de un posible desastre. el enigma los programadores se enfrentan a un enigma de valores básicos. los que tienen años de experiencia saben que un desastre ralentiza su trabajo, y aun así todos los programadores sienten la presión de cometer errores para poder cumplir los plazos de entrega. en definitiva, no toman el tiempo necesario para avanzar. los verdaderos profesionales saben que la segunda parte del enigma no es cierta. no se cumple un plazo de entrega cometiendo un error. de hecho, el error nos ralentiza de forma inmediata y hace que no lleguemos al plazo de entrega. la única forma de cumplirlo, la única forma de avanzar, es intentar 27que el código siempre sea limpio. ¿el arte del código limpio? imagine que cree que el código incorrecto es un obstáculo significativo. imagine que acepta que la única forma de avanzar es mantener el código limpio. entonces se preguntará cómo crear código limpio. no tiene sentido intentar crearlo si no sabe lo que es. la mala noticia es que crear código limpio es como pintar un cuadro. muchos sabemos si un cuadro se ha pintado bien o no, pero poder reconocer la calidad de una obra no significa que sepamos pintar. por ello, reconocer código limpio no significa que sepamos cómo crearlo. para crearlo se requiere el uso disciplinado de miles de técnicas aplicadas mediante un detallado sentido de la «corrección». este sentido del código es la clave. algunos nacen con este sentido. otros han de luchar para conseguirlo. no sólo permite distinguir entre código correcto e incorrecto, sino que también muestra la estrategia para aplicar nuestra disciplina y transformar código incorrecto en código correcto. un programador sin este sentido puede reconocer el desastre cometido en un módulo, pero no saber cómo solucionarlo. un programador con este sentido verá las posibles opciones y elegirá la variante óptima para definir una secuencia de cambios. en definitiva, un programador que cree código limpio es un artista que puede transformar un lienzo en blanco en un sistema de código elegante. concepto de código limpio existen tantas definiciones como programadores. por ello, he consultado la opinión de conocidos y experimentados programadores. bjarne stroustrup, inventor de c++ y autor de the c++ programming language 28me gusta que mi código sea elegante y eficaz. la lógica debe ser directa para evitar errores ocultos, las dependencias deben ser mínimas para facilitar el mantenimiento, el procesamiento de errores completo y sujeto a una estrategia articulada, y el rendimiento debe ser óptimo para que los usuarios no tiendan a estropear el código con optimizaciones sin sentido. el código limpio hace bien una cosa. bjarne usa la palabra «elegante». menuda palabra. según el diccionario, «elegante» significa « dotado de gracia, nobleza y sencillez ». aparentemente bjarne piensa que el código limpio es un placer a la hora de leerlo. su lectura debe hacernos sonreír, como una caja de música o un coche bien diseñado. bjarne también menciona la eficacia, en dos ocasiones . no debería sorprendemos viniendo del inventor de c++; pero considero que hay algo más que el mero deseo de velocidad. los ciclos malgastados no son elegantes, no son un placer. y fíjese en la palabra empleada por bjarne para describir la consecuencia de esta falta de elegancia. usa tiendan . una gran verdad. el código incorrecto tiende a aumentar el desastre. cuando otros cambian código incorrecto, tienden a empeorarlo. dave thomas y andy hunt lo expresan de forma diferente. usan la metáfora de las ventanas rotas [3] . un edificio con ventanas rotas parece abandonado. y hace que otros lo abandonen. dejan que se rompan otras ventanas. e incluso las rompen a propósito. la fachada se ensucia con pintadas y se acumula la basura. una ventana rota inicia el proceso de la decadencia. bjarne también menciona que el procesamiento de errores debe ser completo, lo que se relaciona con la disciplina de prestar atención a los detalles. el procesamiento de errores abreviado es una forma de ignorar los detalles. otras son las fugas de memoria, las condiciones de carrera o el uso 29incoherente de los nombres. en definitiva, el código limpio muestra gran atención al detalle. bjarne termina afirmando que el código limpio hace una cosa bien . no es accidental que existan tantos principios de diseño de software que se puedan reducir a esta sencilla máxima. muchos escritores han tratado de comunicar este pensamiento. el código incorrecto intenta hacer demasiadas cosas y su cometido es ambiguo y enrevesado. el código limpio es concreto . cada función, cada clase y cada módulo muestran una única actitud que se mantiene invariable y no se contamina por los detalles circundantes. grady booch, autor de object oriented analysis and design with applications el código limpio es simple y directo. el código limpio se lee como un texto bien escrito. el código limpio no oculta la intención del diseñador, sino que muestra nítidas abstracciones y líneas directas de control. grady mantiene las mismas ideas que bjarne, pero adopta una perspectiva de legibilidad . me gusta especialmente que el código limpio se pueda leer como un texto bien escrito. piense en un buen libro. recordará que las palabras desaparecen y se sustituyen por imágenes, como ver una película. mejor todavía. es ver los caracteres, escuchar los sonidos, experimentar las sensaciones. leer código limpio nunca será como leer el señor de los anillos . pero esta metáfora literaria no es incorrecta. como una buena novela, el código limpio debe mostrar de forma clara el suspense del problema que hay que resolver. debe llevar ese suspense hasta un punto álgido para después demostrar al lector que los problemas y el suspense se han solucionado de forma evidente. 30la frase «nítida abstracción» de grady es un oxímoron fascinante. nítido es casi un sinónimo de concreto, con un potente mensaje. el código debe ser específico y no especulativo. sólo debe incluir lo necesario. nuestros lectores deben percibir que hemos tomado decisiones. «big» dave thomas, fundador de oti, el padrino de la estrategia eclipse el código limpio se puede leer y mejorar por parte de un programador que no sea su autor original. tiene pruebas de unidad y de aceptación. tiene nombres con sentido. ofrece una y no varias formas de hacer algo. sus dependencias son mínimas, se definen de forma explícita y ofrece una api clara y mínima. el código debe ser culto en función del lenguaje, ya que no toda la información necesaria se puede expresar de forma clara en el código. big dave comparte el deseo de grady de la legibilidad, pero con una importante variante. dave afirma que el código limpio facilita las labores de mejora de otros . puede parecer evidente pero no debemos excedernos. después de todo, existe una diferencia entre el código fácil de leer y el código fácil de cambiar. dave vincula la limpieza a las pruebas. hace 10 años esto hubiera provocado cierta controversia. pero la disciplina del desarrollo controlado por pruebas ha tenido un gran impacto en nuestro sector y se ha convertido en uno de sus pilares. dave tiene razón. el código, sin pruebas, no es limpio. independientemente de su elegancia, legibilidad y accesibilidad, si no tiene pruebas, no será limpio. dave usa dos veces la palabra mínimo . valora el código de tamaño 31reducido, una opinión habitual en la literatura de software desde su concepción. cuanto más pequeño, mejor. también afirma que el código debe ser culto , una referencia indirecta a la programación de knuth [4] y que en definitiva indica que el código debe redactarse de una forma legible para los humanos. michael feathers, autor de working effectively with legacy code podría enumerar todas las cualidades del código limpio, pero hay una principal que engloba a todas ellas. el código limpio siempre parece que ha sido escrito por alguien a quien le importa. no hay nada evidente que hacer para mejorarlo. el autor del código pensó en todos los aspectos posibles y si intentamos imaginar alguna mejora, volvemos al punto de partida y sólo nos queda disfrutar del código que alguien a quien le importa realmente nos ha proporcionado. una palabra; dar importancia. es el verdadero tema de este libro, que incluso podría usar el subtítulo « cómo dar importancia al código ». michael ha acertado de pleno. el código limpio es aquél al que se le ha dado importancia. alguien ha dedicado su tiempo para que sea sencillo y ha prestado atención a los detalles. se ha preocupado. ron jeffries, autor de extreme programming installed y extreme programming adventures in c# 32ron comenzó su carrera como programador con fortran en strategic air command y ha escrito código para la práctica totalidad de lenguajes y equipos. merece la pena fijarse en sus palabras: en los últimos años, comencé y prácticamente terminé con las reglas de código simple de beck. en orden de prioridad, el código simple: ejecuta todas las pruebas. no contiene duplicados. expresa todos los conceptos de diseño del sistema. minimiza el número de entidades como clases, métodos, funciones y similares. de todos ellos, me quedo con la duplicación. cuando algo se repite una y otra vez, es una señal de que tenemos una idea que no acabamos de representar correctamente en el código. intento determinar cuál es y, después, expresar esa idea con mayor claridad. para mí, la expresividad debe incluir nombres con sentido y estoy dispuesto a cambiar los nombres de las cosas varias veces. con las modernas herramientas de creación de código como eclipse, el cambio de nombres es muy sencillo, por lo que no me supone problema alguno. la expresividad va más allá de los nombres. también me fijo si un objeto o un método hacen más de una cosa. si se trata de un objeto, probablemente tenga que dividirse en dos o más. si se trata de un método, siempre recurro a la refactorización de extracción de métodos para generar un método que exprese con mayor claridad su cometido y varios métodos secundarios que expliquen cómo lo hace. la duplicación y la expresividad son dos factores que permiten mejorar considerablemente código que no sea limpio. sin embargo, 33existe otra cosa que también hago conscientemente, aunque sea más difícil de explicar. tras años en este trabajo, creo que todos los programas están formados de elementos muy similares. un ejemplo es la búsqueda de elementos en una colección. independientemente de que sea una base de datos de registros de empleados o un mapa de claves y valores, o una matriz de elementos, por lo general tenemos que buscar un elemento concreto de esa colección. cuando esto sucede, suelo incluir esa implementación concreta en un método o una clase más abstractos. de ese modo disfruto de una serie de interesantes ventajas. puedo implementar la funcionalidad con algo sencillo, como un mapa hash, por ejemplo, pero como ahora todas las referencias a la búsqueda se ocultan en mi pequeña abstracción, puedo modificar la implementación siempre que desee. puedo avanzar rápidamente al tiempo que conservo la posibilidad de realizar cambios posteriores. además, la abstracción de la colección suele captar mi atención en lo que realmente sucede e impide que implemente comportamientos de colecciones arbitrarias si lo que realmente necesito es una forma sencilla de localizar un elemento. reducir los duplicados, maximizar la expresividad y diseñar sencillas abstracciones en las fases iniciales. para mí, es lo que hace que el código sea limpio. en estos breves párrafos, ron resume el contenido de este libro. nada de duplicados, un objetivo, expresividad y pequeñas abstracciones. todo está ahí. ward cunningham, inventor de wiki, fit, y uno de los inventores de la programación extreme. uno de los impulsores de los patrones de diseño. una de las mentes tras smalltalk y la programación orientada a objetos. el padrino de todos a los que les importa el código. 34sabemos que estamos trabajando con código limpio cuando cada rutina que leemos resulta ser lo que esperábamos. se puede denominar código atractivo cuando el código hace que parezca que el lenguaje se ha creado para el problema en cuestión. este tipo de afirmaciones son características de ward. las leemos, asentimos y pasamos a la siguiente. es tan razonable y evidente que apenas parece profundo. incluso podemos pensar que es lo que esperábamos. pero preste atención. «… resulta ser lo que esperábamos». ¿cuándo fue la última vez que vio un módulo que fuera más o menos lo que esperaba? ¿lo habitual no es ver módulos complicados y enrevesados? ¿no es esta falta de concreción lo habitual? ¿no está acostumbrado a intentar extraer el razonamiento de un sistema para llegar al módulo que está leyendo? ¿cuándo fue la última vez que leyó un código y asintió como seguramente haya hecho al leer la afirmación de ward? ward espera que al leer código limpio no le sorprenda. de hecho, ni siquiera tendrá que esforzarse. lo leerá y será prácticamente lo que esperaba. será evidente, sencillo y atractivo. cada módulo prepara el camino del siguiente. cada uno indica cómo se escribirá el siguiente. los programas limpios están tan bien escritos que ni siquiera se dará cuenta. el diseñador consigue simplificarlo todo enormemente, como sucede con todos los diseños excepcionales. ¿y la noción de atractivo de ward? todos hemos criticado que nuestros lenguajes no se hayan diseñado para nuestros problemas. pero la afirmación de ward hace que ahora la responsabilidad sea nuestra. afirma que el código atractivo hace que el lenguaje parezca creado para el problema . por tanto, somos responsables de que el lenguaje parezca sencillo. no es el lenguaje el que hace que los programas parezcan sencillos, sino el programador que consigue que el lenguaje lo parezca. 35escuelas de pensamiento ¿y yo (uncle bob)? ¿qué es para mí el código limpio? en este libro le contaremos, con todo detalle, lo que yo y mis colegas pensamos del código limpio. le contaremos lo que pensamos que hace que un nombre de variable, una función o una clase sean limpias. presentaremos estas opiniones de forma absoluta, sin disculparnos. en este punto de nuestra carrera, ya son absolutas. son nuestra escuela de pensamiento del código limpio. los especialistas de las artes marciales no se ponen de acuerdo sobre cuál es la mejor de todas, ni siquiera sobre cuál es la mejor técnica de un arte marcial. es habitual que los maestros de las artes marciales creen sus propias escuelas de pensamiento y los alumnos aprendan de ellos. de esta forma nació gracie jiu jitsu , creada e impartida por la familia gracie en brasil; hakkoryu jiu jitsu , fundada e impartida por okuyama ryuho en tokio o jeet kune do , fundada e impartida por bruce lee en estados unidos. los alumnos de estas disciplinas se sumergen en las enseñanzas del fundador. se dedican a aprender lo que su maestro les enseña y suelen excluir las enseñanzas de otros maestros. después, cuando han mejorado su arte, pueden convertirse en alumnos de otro maestro diferente para ampliar sus conocimientos y su experiencia. algunos seguirán mejorando sus habilidades, descubriendo nuevas técnicas y fundando sus propias escuelas. ninguna de estas escuelas tiene la razón absoluta pero dentro de cada una actuamos como si las enseñanzas y las técnicas fueran correctas. después de todo, existe una forma correcta de practicar hakkoryu jiu jitsu o jeet kune do, pero esta corrección dentro de una escuela determinada no anula las enseñanzas de otra diferente. 36imagine que este libro es una descripción de la escuela de mentores del código limpio . las técnicas y enseñanzas impartidas son la forma en la que practicamos nuestro arte. podemos afirmar que, si sigue nuestras enseñanzas, disfrutará de lo que hemos disfrutado nosotros, y aprenderá a crear código limpio y profesional. pero no cometa el error de pensar que somos los únicos que tenemos razón. existen otras escuelas y otros maestros tan profesionales como nosotros, y su labor es aprender de ellos también. de hecho, muchas de las recomendaciones del libro son controvertidas, seguramente no esté de acuerdo con muchas de ellas y puede que rechace algunas de forma definitiva. es correcto. no somos la autoridad final. pero, por otra parte, las recomendaciones del libro son algo en lo que hemos pensado mucho. las hemos aprendido tras décadas de experiencia y ensayo y error. por lo tanto, esté o no de acuerdo, sería una lástima que no apreciara, y respetara, nuestro punto de vista. somos autores el campo @author de un javadoc indica quiénes somos. somos autores. y los autores tienen lectores. de hecho, los autores son responsables de comunicarse correctamente con sus lectores. la próxima vez que escriba una línea de código, recuerde que es un autor y que escribe para que sus lectores juzguen su esfuerzo. seguramente se pregunte qué cantidad de código se lee realmente y si la mayor parte del esfuerzo no se concentra en crearlo. ¿alguna vez ha reproducido una sesión de edición? en las décadas de 1980 y 1990 teníamos editores como emacs que controlaban cada pulsación de tecla. se podía trabajar durante una hora y después reproducir la sesión de edición completa como una película a alta velocidad. cuando lo hice, los resultados fueron fascinantes. la mayor parte de la reproducción eran desplazamientos entre módulos. bob accede al módulo. se desplaza hasta la función que tiene que cambiar. 37se detiene y piensa en las posibles opciones. oh, vuelve al inicio del módulo para comprobar la inicialización de una variable. ahora vuelve a bajar y comienza a escribir. vaya, borra lo que había escrito. vuelve a escribirlo. lo vuelve a borrar. escribe algo diferente pero también lo borra. se desplaza a otra función que invoca la función que está modificando para comprobar cómo se invoca. vuelve a subir y escribe el mismo código que acaba de borrar. se detiene. vuelve a borrar el código. abre otra ventana y examina las subclases. ¿se ha reemplazado esa función? … se hace una idea. en realidad, la proporción entre tiempo dedicado a leer frente a tiempo dedicado a escribir es de más de 10:1. constantemente tenemos que leer código antiguo como parte del esfuerzo de crear código nuevo. al ser una proporción tan elevada, queremos que la lectura del código sea sencilla, aunque eso complique su creación. evidentemente, no se puede escribir código sin leerlo, de modo que si es más fácil de leer será más fácil de escribir . es una lógica sin escapatoria. no se puede escribir código si no se puede leer el código circundante. el código que intente escribir hoy será fácil o difícil de escribir en función de lo fácil o difícil de leer que sea el código circundante. si quiere avanzar rápidamente, terminar cuanto antes y que su código sea fácil de escribir, haga que sea fácil de leer. la regla del boy scout 38no basta con escribir código correctamente. el código debe limpiarse con el tiempo. todos hemos visto que el código se corrompe con el tiempo, de modo que debemos adoptar un papel activo para evitarlo. los boy scouts norteamericanos tienen una sencilla regla que podemos aplicar a nuestra profesión: dejar el campamento más limpio de lo que se ha encontrado [5] . si todos entregamos el código más limpio de lo que lo hemos recibido, no se corromperá. no hace falta que la limpieza sea masiva. cambie el nombre de una variable, divida una función demasiado extensa, elimine elementos duplicados, simplifique una instrucción if compuesta. ¿se imagina trabajar en un proyecto en el que el código mejorara con el tiempo? ¿cree que hay otras opciones que puedan considerarse profesionales? de hecho, ¿la mejora continuada no es una parte intrínseca de la profesionalidad? precuela y principios en muchos aspectos, este libro es una «precuela» de otro que escribí en 2002 titulado agile software development: principles, patterns, and practices (ppp). el libro ppp trata sobre los principios del diseño orientado a objetos y muchas de las técnicas empleadas por desarrolladores profesionales. si no ha leído ppp, comprobará que continúa la historia contada en este libro. si lo ha leído, encontrará muchas de las sensaciones de ese libro reproducidas en éste a nivel del código. en este libro encontrará referencias esporádicas a distintos principios de diseño como srp ( single responsibility principle o principio de responsabilidad única), ocp ( open closed principle o principio abierto/cerrado) y dip ( dependency inversion principle o principio de inversión de dependencias) entre otros. todos estos principios se describen detalladamente en ppp. 39conclusión los libros sobre arte no le prometen que se convertirá en artista. solamente pueden mostrarle herramientas, técnicas y procesos de pensamiento que otros artistas hayan utilizado. del mismo modo, este libro no puede prometer que se convierta en un buen programador, que tenga sentido del código. sólo puede mostrarle los procesos de pensamiento de buenos programadores y los trucos, técnicas y herramientas que emplean. al igual que un libro sobre arte, este libro está repleto de detalles. encontrará mucho código. verá código correcto y código incorrecto. verá código incorrecto transformado en código correcto. verá listas de heurística, disciplinas y técnicas. verá un ejemplo tras otro. y después de todo, será responsabilidad suya. ¿recuerda el chiste sobre el violinista que se pierde camino de un concierto? se cruza con un anciano y le pregunta cómo llegar al teatro real. el anciano mira al violinista y al violín que lleva bajo el brazo y le responde: «practique joven, practique». bibliografía [beck07] : implementation patterns , kent beck, addison-wesley, 2007. [knuth92] : literate programming , donald e. knuth, center for the study of language and information, leland stanford junior university, 1992. 402 nombres con sentido por tim ottinger introducción en el software , los nombres son omnipresentes. aparecen en variables, 41funciones, argumentos, clases y paquetes. asignamos nombres a archivos y a directorios, a archivos jar, war y ear. usamos nombres constantemente. por ello, debemos hacerlo bien. a continuación, veremos algunas reglas básicas para crear nombres correctos. usar nombres que revelen las intenciones es fácil afirmar que los nombres deben revelar nuestras intenciones. lo que queremos recalcar es la importancia de hacerlo. elegir nombres correctos lleva tiempo, pero también ahorra trabajo. por ello, preste atención a los nombres y cámbielos cuando encuentre otros mejores. todo el que lea su código se lo agradecerá. el nombre de una variable, función o clase debe responder una serie de cuestiones básicas. debe indicar por qué existe, qué hace y cómo se usa. si un nombre requiere un comentario, significa que no revela su cometido. int d; // tiempo transcurrido en días el nombre d no revela nada. no evoca una sensación de tiempo transcurrido, ni de días. debe elegir un nombre que especifique lo que se mide y la unidad de dicha medida: int elapsedtimeindays; int dayssincecreation; int dayssincemodification; int fileageindays; la elección de nombres que revelen intenciones facilita considerablemente la comprensión y la modificación del código. ¿para qué sirve el siguiente código? public list<int[]> getthem() { list<int[]> list1 = new arraylist<int[]>(); for (int[] x : thelist) if (x[0] == 4) list1.add(x); return list1; } ¿por qué es complicado saber la función de este código? no hay expresiones complejas. los espacios y el sangrado son razonables. sólo hay tres variables y dos constantes. ni siquiera contiene clases complejas o 42métodos polimórficos, sólo una lista de matrices (o eso parece). el problema no es la simplicidad del código sino su carácter implícito : el grado en el que el contexto no es explícito en el propio código. implícitamente, el código requiere que sepamos las respuestas a las siguientes preguntas: ¿qué contiene thelist ? ¿qué significado tiene el subíndice cero de un elemento de thelist ? ¿qué importancia tiene el valor 4 ? ¿cómo se usa la lista devuelta? las respuestas a estas preguntas no se encuentran en el código, pero se podrían haber incluido. imagine que trabaja en un juego de buscar minas. el tablero es una lista de celdas llamada thelist . cambiemos el nombre por gameboard . cada celda del teclado se representa por medio de una matriz. el subíndice cero es la ubicación de un valor de estado que, cuando es 4 , significa que se ha detectado. al asignar nombres a estos conceptos mejoramos considerablemente el código: public list<int[]> getflaggedcells() { list<int[]> flaggedcells = new arraylist<int[]>(); for (int[] cell : gameboard) if (cell[status_value] == flagged) flaggedcells.add(cell); return flaggedcells; } la simplicidad del código no ha cambiado. sigue teniendo los mismos operadores y constantes y el mismo número de niveles anidados, pero ahora es mucho más explícito. podemos crear una sencilla clase para celdas en lugar de usar una matriz de elementos int . puede incluir una función que revele el objetivo (con el nombre isflagged ) para ocultar los números. el resultado es una nueva versión de la función: public list<cell> getflaggedcells() { list<cell> flaggedcells = new arraylist<cell>(); for (cell cell : gameboard) if (cell.isflagged()) flaggedcells.add(cell); 43return flaggedcells; } con estos sencillos cambios de nombre, es fácil saber qué sucede. es la ventaja de seleccionar nombres adecuados. evitar la desinformación los programadores deben evitar dejar pistas falsas que dificulten el significado del código. debemos evitar palabras cuyo significado se aleje del que pretendemos. por ejemplo, hp , aix y sco son nombres de variables pobres ya que son los nombres de plataformas o variantes de unix. aunque se trate del código de una hipotenusa y hp parezca la abreviatura correcta, puede no serlo. no haga referencia a un grupo de cuentas como accountlist a menos que realmente sea una lista ( list ). la palabra lista tiene un significado concreto para los programadores. si el contenedor de las cuentas no es realmente una lista, puede provocar falsas conclusiones [6] . por tanto, resulta más adecuado usar accountgroup , bunchofaccounts o simplemente accounts . evite usar nombres con variaciones mínimas. ¿cuánto se tarda en apreciar la sutil diferencia entre xyzcontrollerforefficienthandlingofstrings y xyzcontrollerforefficientstorageofstrings en un módulo? ambas palabras tienen una forma similar. la ortografía similar de conceptos parecidos es información; el uso de ortografía incoherente es desinformación. en los entornos modernos de java, el código se completa de forma automática. escribimos varios caracteres de un nombre y pulsamos varias teclas para obtener una lista de posibles opciones de un nombre. es muy útil si los nombres de elementos similares se ordenan alfabéticamente de forma conjunta y si las diferencias son muy evidentes, ya que es probable que el programador elija un objeto por nombre sin fijarse en los comentarios o la lista de métodos proporcionados por una clase. 44un ejemplo de nombre desinformativo sería el uso de la l minúscula o la o mayúscula como nombres de variables, sobre todo combinados. el problema, evidentemente, es que se parecen a las constantes 1 y 0 respectivamente: int a = l; if ( o == l ) a = o1; else l = 01; el lector puede pensar que es una invención, pero hemos visto código con abundancia de estos elementos. en un caso, el autor del código, sugirió usar una fuente distinta para que las diferencias fueran más evidentes, una solución que se hubiera transmitido a todos los futuros programadores como tradición oral o en un documento escrito. el problema se resolvió con carácter definitivo y sin necesidad de crear nuevos productos, con tan sólo cambiar los nombres. realizar distinciones con sentido los programadores se crean un problema al crear código únicamente dirigido a un compilador o intérprete. por ejemplo, como se puede usar el mismo nombre para hacer referencia a dos elementos distintos en el mismo ámbito, puede verse tentado a cambiar un nombre de forma arbitraria. en ocasiones se hace escribiéndolo incorrectamente, lo que provoca que los errores ortográficos impidan la compilación [7] . no basta con añadir series de números o palabras adicionales, aunque eso satisfaga al compilador. si los nombres tienen que ser distintos, también deben tener un significado diferente. los nombres de series numéricas ( a1 , a2 … an ) son lo contrario a los nombres intencionados. no desinforman, simplemente no ofrecen información; son una pista sobre la intención del autor. fíjese en lo siguiente: 45public static void copychars(char a1[], char a2[]) { for (int i = 0; i < a1.length; i++) { a2[i] = a1[i]; } } esta función se lee mejor cuando se usa source y destination como nombres de argumentos. las palabras adicionales son otra distinción sin sentido. imagine que tiene la clase product. si tiene otra clase con el nombre productinfo o productdata , habrá creado nombres distintos, pero con el mismo significado. info y data son palabras adicionales, como a , an y the . no es incorrecto usar prefijos como a y the mientras la distinción tenga sentido. imagine que usa a para variables locales y for para argumentos de funciones [8] . el problema aparece cuando decide invocar la variable thezork porque ya tiene otra variable con el nombre zork . las palabras adicionales son redundantes. la palabra variable no debe incluirse nunca en el nombre de una variable. la palabra table no debe incluirse nunca en el nombre de una tabla. ¿es mejor namestring que name ? ¿podría ser name un número de coma flotante? en caso afirmativo, incumple la regla anterior sobre desinformación. imagine que encuentra una clase con el nombre customer y otra con el nombre customerobject . ¿cuál sería la distinción? ¿cuál representa mejor el historial de pagos de un cliente? existe una aplicación que lo ilustra. hemos cambiado los nombres para proteger al culpable. veamos el error exacto: getactiveaccount(); getactiveaccounts(); getactiveaccountinfo(); ¿cómo saben los programadores de este proyecto qué función deben invocar? en ausencia de convenciones concretas, la variable moneyamount no se distingue de money , customerinfo no se distingue de customer , accountdata no se distingue de account y themessage no se distingue de message . debe diferenciar los nombres de forma que el lector aprecie las diferencias. 46usar nombres que se puedan pronunciar a los humanos se nos dan bien las palabras. gran parte de nuestro cerebro se dedica al concepto de palabras. y, por definición, las palabras son pronunciables. sería una pena malgastar esa parte de nuestro cerebro dedicada al lenguaje hablado. por tanto, cree nombres pronunciables. si no lo puede pronunciar, no podrá explicarlo sin parecer tonto. es un factor importante, ya que la programación es una actividad social. conozco una empresa que usa genymdhms (fecha de generación, año, mes, día, hora, minuto y segundo) y lo pronuncian tal cual. yo tengo la costumbre de pronunciar todo tal y como lo veo escrito, de forma que muchos analistas y diseñadores acabaron por llamarme algo como «genimedemes». era un chiste y nos parecía divertido, pero en realidad estábamos tolerando el uso de nombres pobres. teníamos que explicar las variables a los nuevos programadores y cuando las pronunciaban, usaban palabras inventadas en lugar de nombres correctos. compare: class dtarcrd102 { private date genymdhms; private date modymdhms; private final string pszqint = “102”; /*… */ }; con: class customer { private date generationtimestamp; private date modificationtimestamp; private final string recordid = “102”; /*… */ }; ahora se puede mantener una conversación inteligente: «eh, mikey, fíjate en este registro. la marca de tiempo de generación es para mañana. ¿cómo es posible?» usar nombres que se puedan buscar 47los nombres de una letra y las constantes numéricas tienen un problema: no son fáciles de localizar en el texto. se puede detectar max_classes_per_student , pero el número 7 resulta más complicado. las búsquedas pueden devolver el dígito como parte de nombres de archivo, otras definiciones de constantes o expresiones en las que se use con otra intención. mucho peor si la constante es un número extenso y alguien ha intercambiado los dígitos, lo que genera un error inmediato y no aparece en la búsqueda. del mismo modo, el nombre e es una opción muy pobre para variables que el programador tenga que buscar. es la letra más usada en inglés y aparece en la práctica totalidad de los textos de un programa. a este respecto, los nombres extensos superan a los breves y cualquier nombre que se pueda buscar supera a una constante en el código. personalmente prefiero nombres de una letra que sólo se puedan usar como variables locales dentro de métodos breves. la longitud de un nombre debe corresponderse al tamaño de su ámbito [n5]. si una variable o constante se usa en varios puntos del código, debe asignarle un nombre que se pueda buscar. compare: for (int j=0; j<34; j++) { s += (t[j]*4)/5; } con: int realdaysperidealday = 4; const int work_days_per_week = 5; int sum = 0; for (int j = 0; j < number_of_tasks; j++) { int realtaskdays = taskestimate[j] * realdaysperidealday; int realtaskweeks = (realdays / work_days_per_week); sum += realtaskweeks; } en este ejemplo, sum no es un nombre especialmente útil, pero al menos se puede buscar. se usa una función más extensa, pero comprobará que resulta mucho más fácil buscar work_days_per_week que todas las instancias de 5 y filtrar la lista a los casos con el significado adecuado. evitar codificaciones 48ya tenemos suficientes codificaciones como para tener que añadir otras nuevas. al codificar información de tipos o ámbitos en un nombre se dificulta la descodificación. no parece razonable que todos los nuevos empleados tengan que aprender otro lenguaje de codificación además del código con el que van a trabajar. es una carga mental innecesaria a la hora de intentar solucionar un problema. los nombres codificados resultan impronunciables y suelen escribirse de forma incorrecta. notación húngara antiguamente, cuando trabajábamos con lenguajes en los que la longitud de los nombres era un reto, incumplíamos esta regla a nuestro pesar. fortran forzaba las codificaciones convirtiendo la primera letra de un tipo en código. en sus primeras versiones, basic sólo se permitía una letra y un dígito. la notación húngara (hn) lo llevó a un nuevo nivel. hn se consideraba muy importante en el api c de windows, donde todo era un control entero, un puntero long , un puntero void o una de varias implementaciones de string (con diferentes usos y atributos). por aquel entonces, el compilador no comprobaba los tipos, de modo que los programadores tenían que recordarlos. en los lenguajes modernos disponemos de sistemas de tipos más completos y los compiladores recuerdan los tipos y los aplican. es más, existe una tendencia a usar clases y funciones más breves para que los usuarios aprecien la declaración de las variables que usan. los programadores de java no tienen que codificar tipos. los objetos son de tipos fuertes y los entornos de edición han avanzado tanto que detectan un error de tipo antes de ejecutar la compilación. por ello, en la actualidad hn y otras formas de codificación de tipos no son más que un impedimento. hacen que sea más complicado cambiar el nombre o el tipo de una variable o clase. dificultan la legibilidad del código y pueden hacer que el sistema de codificación confunda al lector: phonenumber phonestring; // el nombre no cambia cuando cambia el tipo 49prefijos de miembros tampoco es necesario añadir m_ como prefijo a los nombres de variables. las clases y funciones tienen el tamaño necesario para no tener que hacerlo, y debe usar un entorno de edición que resalte o coloree los miembros para distinguirlos. public class part { private string m_dsc; // la descripción textual void setname(string name) { m_dsc = name; } } public class part { string description; void setdescription(string description) { this.description = description; } } además, los usuarios aprenden rápidamente a ignorar el prefijo (o sufijo) y fijarse en la parte con sentido del nombre. cuanto más código leemos, menos nos fijamos en los prefijos. en última instancia, los prefijos son un indicio de código antiguo. interfaces e implementaciones existe un caso especial para usar codificaciones. imagine por ejemplo que crea una factoría abstracta para crear formas. esta factoría será una interfaz y se implementará por medio de una clase concreta. ¿qué nombres debe asignar? ¿ ishapefactory y shapefactory ? prefiero las interfaces sin adornos. la i inicial, tan habitual en los archivos de legado actuales es, en el mejor de los casos, una distracción, y en el peor, un exceso de información. no quiero que mis usuarios sepan que se trata de una interfaz, solamente que se trata de shapefactory . si tengo que codificar la interfaz o la implementación, opto por ésta última. es mejor usar shapefactoryimp o incluso cshapefactory , que codificar la interfaz. 50evitar asignaciones mentales los lectores no tienen que traducir mentalmente sus nombres en otros que ya conocen. este problema suele aparecer al elegir entre no usar términos de dominio de problemas o de soluciones. es un problema de los nombres de variables de una sola letra. un contador de bucles se podría bautizar como i , j o k (pero nunca l ) si su ámbito es muy reducido y no hay conflictos con otros nombres, ya que los nombres de una letra son tradicionales en contadores de bucles. sin embargo, en otros contextos, un nombre de una letra es una opción muy pobre: es como un marcador de posición que el lector debe asignar mentalmente a un concepto real. no hay peor motivo para usar el nombre c que a y b ya estén seleccionados. por lo general, los programadores son gente inteligente. a la gente inteligente le gusta presumir de sus habilidades mentales. si puede recordar que r es la versión en minúscula de una url sin el host y el sistema, debe ser muy listo. una diferencia entre un programador inteligente y un programador profesional es que este último sabe que la claridad es lo que importa . los profesionales usan sus poderes para hacer el bien y crean código que otros puedan entender. nombres de clases las clases y los objetos deben tener nombres o frases de nombre como customer , wikipage , account y addressparser . evite palabras como manager , processor , data , o info en el nombre de una clase. el nombre de una clase no debe ser un verbo. nombres de métodos 51los métodos deben tener nombres de verbo como postpayment , deletepage o save . los métodos de acceso, de modificación y los predicados deben tener como nombre su valor y usar como prefijo get , set e is de acuerdo al estándar de javabean [9] . string name = employee.getname(); customer.setname(“mike”); if (paycheck.isposted())… al sobrecargar constructores, use métodos de factoría estáticos con nombres que describan los argumentos. por ejemplo: complex fulcrumpoint = complex.fromrealnumber(23.0); es mejor que: complex fulcrumpoint = new complex(23.0); refuerce su uso convirtiendo en privados sus constructores correspondientes. no se exceda con el atractivo si los nombres son demasiado inteligentes, sólo los recordarán los que compartan el sentido del humor de su autor, y sólo mientras se acuerden del chiste. ¿sabrán qué significa la función holyhandgrenade ? sin duda es atractiva, pero en este caso puede que deleteitems fuera más indicado. opte por la claridad antes que por el entretenimiento. en el código, el atractivo suele aparecer como formas coloquiales o jergas. por ejemplo, no use whack() en lugar de kill() . no recurra a bromas culturales como eatmyshorts() si quiere decir abort() . diga lo que piense. piense lo que diga. una palabra por concepto elija una palabra por cada concepto abstracto y manténgala. por ejemplo, 52resulta confuso usar fetch , retrieve y get como métodos equivalentes de clases distintas. ¿cómo va a recordar qué método se corresponde a cada clase? desafortunadamente, tendrá que recordar qué empresa, grupo o individuo ha creado la biblioteca o clase en cuestión para recordar qué término se ha empleado. en caso contrario, perderá mucho tiempo buscando en encabezados y fragmentos de código. los entornos de edición modernos como eclipse e intellij ofrecen pistas sensibles al contexto, como la lista de métodos que puede invocar en un determinado objeto. pero esta lista no suele incluir los comentarios de nombres de funciones y listas de parámetros. tendrá suerte si muestra los nombres de parámetros de las declaraciones de funciones. los nombres de funciones deben ser independientes y coherentes para que pueda elegir el método correcto sin necesidad de búsquedas adicionales. del mismo modo, resulta confuso tener un controlador, un administrador y un control en la misma base de código. ¿cuál es la diferencia entre devicemanager y protocolcontroller ? ¿por qué no son los dos controladores o administradores? ¿son controladores? el nombre hace que espere que dos objetos tengan un tipo diferente y clases diferentes. un léxico coherente es una gran ventaja para los programadores que tengan que usar su código. no haga juegos de palabras evite usar la misma palabra con dos fines distintos. suele hacerse en juegos de palabras. si aplica la regla de una palabra por conceptos, acabará con muchas clases que por ejemplo tengan un método add . mientras las listas de parámetros y los valores devueltos de los distintos métodos add sean semánticamente equivalentes, no hay problema. sin embargo, alguien puede decidir usar la palabra add por motivos de coherencia, aunque no sea en el mismo sentido. imagine que hay varias clases en las que add crea un nuevo valor sumando o concatenando dos valores existentes. imagine ahora que crea una nueva clase con un método 53que añada su parámetro a una colección. ¿este método debe tener el método add ? parece coherente ya que hay otros muchos métodos add , pero en este caso hay una diferencia semántica, de modo que debemos usar un nombre como insert o append . llamar add al nuevo método sería un juego de palabras. nuestro objetivo, como autores, es facilitar la comprensión del código. queremos que el código sea algo rápido, no un estudio exhaustivo. queremos usar un modelo en el que el autor sea el responsable de transmitir el significado, no un modelo académico que exija investigar el significado mostrado. usar nombres de dominios de soluciones recuerde que los lectores de su código serán programadores. por ello, use términos informáticos, algoritmos, nombres de patrones, términos matemáticos y demás. no conviene extraer todos los nombres del dominio de problemas ya que no queremos que nuestros colegas tengan que preguntar el significado de cada nombre en especial cuando ya conocen el concepto bajo otro nombre diferente. el nombre accountvisitor tiene mucho significado para un programador familiarizado con el patrón visitor . ¿qué programador no sabe lo que es jobqueue ? hay cientos de cosas técnicas que los programadores tienen que hacer y elegir nombres técnicos para dichas cosas suele ser lo más adecuado. usar nombres de dominios de problemas cuando no exista un término de programación para lo que esté haciendo, use el nombre del dominio de problemas. al menos el programador que mantenga su código podrá preguntar el significado a un experto en dominios. separar los conceptos de dominio de soluciones y de problemas es parte del trabajo de un buen programador y diseñador. el código que tenga más relación con los conceptos del dominio de problemas tendrá nombres 54extraídos de dicho dominio. añadir contexto con sentido algunos nombres tienen significado por sí mismos, pero la mayoría no. por ello, debe incluirlos en un contexto, en clases, funciones y espacios de nombres con nombres adecuados. cuando todo lo demás falle, pueden usarse prefijos como último recurso. imagine que tiene las variables firstname , lastname , street , housenumber , city , state y z ipcode . si las combina, es evidente que forman una dirección. pero si la variable state se usa de forma aislada en un método, ¿sabría que forma parte de una dirección? puede añadir contexto por medio de prefijos: addrfirstname , addrlastname , addrstate , etc. al menos los lectores comprenderán que estas variables forman parte de una estructura mayor. evidentemente, es mejor crear la clase address . de ese modo, incluso el compilador sabrá que las variables pertenecen a un concepto más amplio. fíjese en el método del listado 2-1. ¿las variables necesitan un contexto con más sentido? el nombre de la función sólo ofrece parte del contexto, el resto se obtiene del algoritmo. tras leer la función, verá que las tres variables number , verb y pluralmodifier forman parte del mensaje guess statistics . desafortunadamente, es necesario inferir el contexto. al leer el método, el significado de las variables no es evidente. listado 2-1 variables en un contexto ambiguo. private void printguessstatistics(char candidate, int count) { string number; string verb; string pluralmodifier; if (count == 0) { number = “no”; verb = “are”; pluralmodifier = “s”; } else if (count == 1) { number = “1”; 55verb = “is”; pluralmodifier = “”; } else { number = integer.tostring(count); verb = “are”; pluralmodifier = “s”; } string guessmessage = string.format( “there %s %s %s%s”, verb, number, candidate, pluralmodifier ); print(guessmessage); } la función es demasiado extensa y las variables aparecen por todas partes. para dividir la función en fragmentos más reducidos necesitamos crear una clase guessstatisticsmessage y convertir a las tres variables en campos de la misma. de este modo contamos con un contexto más obvio para las tres variables. forman parte sin duda de guessstatisticsmessage . la mejora del contexto también permite que el algoritmo sea más limpio y se divida en funciones más reducidas (véase el listado 2-2). listado 2-2 variables con un contexto. public class guessstatisticsmessage ( private string number; private string verb; private string pluralmodifier; public string make(char candidate, int count) { createpluraldependentmessageparts(count); return string.format( “there %s %s %s%s, verb, number, candidate, pluralmodifier); } private void createpluraldependentmessageparts(int count) { if (count == 0) { therearenoletters(); } else if (cout == 1) { thereisoneletter(); } else { therearemanyletters(count); } } private void therearemanyletters(int count) { number = “1”; 56verb = “is”; pluralmodifier = “”; } private void thereisoneletter() { number = “1”; verb = “is”; pluralmodifier = “”; } private void therearenoletters() { number = “no”; verb = “are”; pluralmodifier = “s”; } } no añadir contextos innecesarios en la aplicación imaginaria gas station deluxe, no es aconsejable usar el prefijo gsd en todas las clases. es trabajar contra las herramientas proporcionadas. introduzca g y pulse la tecla de finalización para acceder a una lista interminable de todas las clases del sistema. ¿es lo correcto? ¿por qué dificultar la ayuda del ide? del mismo modo, imagine que ha creado la clase mailingaddress en un módulo de contabilidad de gsd , con el nombre gsdaccountaddress . después, necesita una dirección de correo para la aplicación de contacto con el cliente. ¿usará gsdaccountaddress ? ¿le parece el nombre correcto? 10 de los 17 caracteres son redundantes o irrelevantes. los nombres breves suelen ser más adecuados que los extensos, siempre que sean claros. no añada más contexto del necesario a un nombre. los nombres accountaddress y customeraddress son perfectos para instancias de la clase address pero no sirven como nombres de clase. address sirve como nombre de clase. para distinguir entre direcciones mac, direcciones de puertos y direcciones web, podría usar postaladdress , mac y uri . los nombres resultantes son más precisos, el objetivo de cualquier nombre. 57conclusión lo más complicado a la hora de elegir un buen nombre es que requiere habilidad descriptiva y acervo cultural. es un problema de formación más que técnico, empresarial o administrativo. como resultado, mucha gente del sector no aprende a hacerlo bien. la gente teme que al cambiar los nombres otros programadores se quejen. nosotros no compartimos ese temor y agradecemos los cambios de nombre (siempre que sean a mejor). en muchos casos no memorizamos los nombres de clases y métodos. usamos herramientas modernas para estos detalles y así poder centrarnos en si el código se lee como frases o párrafos, o al menos como tablas y estructuras de datos (una frase no siempre es la mejor forma de mostrar datos). seguramente acabará sorprendiendo a alguien cuando cambie los nombres, como puede suceder con cualquier otra mejora del código. no deje que le detenga. aplique estas reglas y compruebe si mejora o no la legibilidad de su código. si es el encargado de mantener código de terceros, use herramientas para solucionar estos problemas. obtendrá recompensas a corto y largo plazo. 583 funciones 59en los inicios de la programación, creábamos sistemas a partir de rutinas y subrutinas. después, en la época de fortran y pl/1, creábamos nuestros sistemas con programas, subprogramas y funciones. en la actualidad, sólo las funciones han sobrevivido. son la primera línea organizativa en cualquier programa. en este capítulo veremos cómo crearlas. fíjese en el código del listado 3-1. es complicado encontrar una función extensa en fitnesse [10] , pero acabé encontrando ésta. no sólo es extensa, sino que también contiene código duplicado, muchas cadenas y tipos de datos extraños, además de api poco habituales y nada evidentes. intente 60comprenderlo en los próximos tres minutos. listado 3-1 htmlutil.java (fitnesse 20070619). public static string testablehtml { pagedata pagedata, boolean includesuitesetup } throws exception { wikipage wikipage = pagedata.getwikipage(); stringbuffer buffer = new stringbuffer(); if (pagedata.hasattribute(“test”)) { if (includesuitesetup) { wikipage suitesetup = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_setup_name, wikipage ); if (suitesetup != null) { wikipagepath pagepath = suitesetup.getpagecrawler().getfullpath (suitesetup); string pagepathname = pathparser.render(pagepath); buffer.append(“!include -setup .”) .append(pagepathname) .append(“\n”); } } wikipage setup = pagecrawlerimpl.getinheritedpage(“setup”, wikipage); if (setup != null) { wikipagepath setuppath = wikipage.getpagecrawler().getfullpath(setup); string setuppathname = pathparser.render(setuppath); buffer.append(“!include -setup .”) .append(setuppathname) .append(“\n”); } } buffer.append(pagedata.getcontent()); if (pagedata.hasattribute(“test”)) { wikipage teardown = pagecrawlerimpl.getinheritedpage(“teardown”, wikipage); if (teardown != null) { wikipagepath teardownpath = wikipage.getpagecrawler().getfullpath(teardown); string teardownpathname = pathparser.render(teardownpath); buffer.append(“\n”) .append(“!include -teardown .”) .append(teardownpathname) .append(“\n”); } if (includesuitesetup) { 61wikipage suiteteardown = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_teardown_name, wikipage ); if (suiteteardown != null) { wikipagepath pagepath = suiteteardown.getpagecrawler().getfullpath (suiteteardown); string pagepathname = pathparser.render(pagepath); buffer.append(“!include -teardown .”) .append(pagepathname) .append(“\n”); } } } pagedata.setcontent(buffer.tostring()); return pagedata.gethtml(); } ¿tras tres minutos entiende la función? seguramente no. pasan demasiadas cosas y hay demasiados niveles de abstracción diferentes. hay cadenas extrañas e invocaciones de funciones mezcladas en instrucciones if doblemente anidadas controladas por indicadores. sin embargo, con sencillas extracciones de código, algún cambio de nombres y cierta reestructuración, pude capturar la intención de la función en las nueve líneas del listado 3-2. compruebe si ahora la entiende. listado 3-2 htmlutil.java (refactorización). public static string renderpagewithsetupsandteardowns( pagedata pagedata, boolean issuite ) throws exception { boolean istestpage = pagedata.hasattribute(“test”); if (istestpage) { wikipage testpage = pagedata.getwikipage(); stringbuffer newpagecontent = new stringbuffer(); includesetuppages (testpage, newpagecontent, issuite); newpagecontent.append(pagedata.getcontent()); includeteardownpages(testpage, newpagecontent, issuite); pagedata.setcontent(newpagecontent.tostring()); } return pagedata.gethtml(); } a menos que sea un alumno de fitnesse, seguramente no entienda los 62detalles. entenderá que la función se encarga de añadir páginas de configuración y detalles en una página de prueba, que después muestra en html. si está familiarizado con junit [11] , verá que esta función pertenece a algún tipo de estructura de pruebas basada en la web y, evidentemente, es correcto. resulta sencillo adivinar esta información del listado 3-2 pero no del listado 3-1. ¿qué tiene la función del listado 3-2 para que resulte sencilla de leer y entender? ¿qué hay que hacer para que una función transmita su intención? ¿qué atributos podemos asignar a nuestras funciones para que el lector pueda intuir el tipo de programa al que pertenecen? tamaño reducido la primera regla de las funciones es que deben ser de tamaño reducido. la segunda es que deben ser todavía más reducidas . no es una afirmación que pueda justificar. no puedo mostrar referencias a estudios que demuestren que las funciones muy reducidas sean mejores. lo que sí puedo afirmar es que durante casi cuatro décadas he creado funciones de diferentes tamaños. he creado monstruos de casi 3000 líneas y otras muchas funciones de entre 100 y 300 líneas. también he creado funciones de 20 a 30 líneas de longitud. esta experiencia me ha demostrado, mediante ensayo y error, que las funciones deben ser muy reducidas. en la década de 1980 se decía que una función no debía superar el tamaño de una pantalla. por aquel entonces, las pantallas vt100 tenían 24 líneas por 80 columnas, y nuestros editores usaban 4 líneas para tareas administrativas. en la actualidad, con una fuente mínima y un monitor de gran tamaño, se pueden encajar 150 caracteres por línea y 100 líneas o más en una pantalla. las líneas no deben tener 150 caracteres. las funciones no deben tener 100 líneas de longitud. las funciones deben tener una longitud aproximada de 20 líneas. ¿qué tamaño mínimo debe tener una función? en 1999 visité a kent beck en su casa de oregon. nos sentamos y comenzamos a programar. me enseñó un atractivo programa de java/swing que había llamado sparkle . generaba un efecto visual en pantalla, similar a la varita mágica del hada de 63cenicienta. al mover el ratón, salían estrellitas del cursor, y descendían a la parte inferior de la pantalla en un campo gravitatorio simulado. cuando kent me enseñó el código, me sorprendió la brevedad de las funciones. estaba acostumbrado a ver programas de swing con funciones que ocupaban kilómetros de espacio vertical. en este programa, las funciones tenían dos, tres o cuatro líneas de longitud. todas eran obvias. todas contaban una historia y cada una llevaba a la siguiente en un orden atractivo. ¡así de breves deberían ser todas las funciones! [12] ¿qué tamaño mínimo deben tener sus funciones? deberían ser más breves que las del listado 3-2. de hecho, el listado 3-2 debería reducirse como el listado 3-3. listado 3-3 htmlutil.java (nueva refactorización). public static string renderpagewithsetupsandteardowns( pagedata pagedata, boolean issuite) throws exception { if (istestpage(pagedata)) includesetupandteardownpages(pagedata, issuite); return pagedata.gethtml(); } bloques y sangrado esto implica que los bloques en instrucciones if , else , while y similares deben tener una línea de longitud que, seguramente, sea la invocación de una función. de esta forma, no sólo se reduce el tamaño de la función, sino que también se añade valor documental ya que la función invocada desde el bloque puede tener un nombre descriptivo. también implica que las funciones no deben tener un tamaño excesivo que albergue estructuras anidadas. por tanto, el nivel de sangrado de una función no debe ser mayor de uno o dos. evidentemente, de esta forma las funciones son más fáciles de leer y entender. hacer una cosa 64es evidente que el listado 3-1 hace más de una cosa. crea búferes, obtiene páginas, busca páginas heredadas, añade cadenas antiguas y genera html. el listado 3-1 está muy ocupado realizando varias tareas. por su parte, el listado 3-3 sólo hace una cosa: incluye configuraciones y detalles en páginas de prueba. el siguiente consejo lleva vigente, de una u otra forma, durante más de 30 años: las funciones sólo deben hacer una cosa. deben hacerlo bien y debe ser lo único que hagan. el problema de esta afirmación es saber qué es una cosa. ¿el listado 3-3 hace una cosa? se podría pensar que hace tres: 1 . determinar si la página es una página de prueba. 2 . en caso afirmativo, incluir configuraciones y detalles. 3 . representar la página en html. ¿cuál será de las tres? ¿la función hace una o tres cosas? los tres pasos de la función se encuentran un nivel de abstracción por debajo del nombre de la función. podemos describir la función como un breve párrafo to (para) [13] : para renderpagewithsetupsandteardowns , comprobamos si la página es de prueba y, en caso afirmativo, incluimos las configuraciones y los detalles. en ambos casos, la representamos en html. si una función sólo realiza los pasos situados un nivel por debajo del nombre de la función, entonces hace una cosa. en definitiva, creamos funciones para descomponer conceptos más amplios (es decir, el nombre de 65la función) en un conjunto de pasos en el siguiente nivel de abstracción. es evidente que el listado 3-1 contiene pasos en distintos niveles de abstracción, por lo que es obvio que hace más de una cosa. incluso el listado 3-2 tiene tres niveles de abstracción, como ha demostrado la capacidad de reducirlo, pero sería complicado reducir con sentido el listado 3-3. podríamos extraer la instrucción if en la función includesetupsandteardownsiftestpage , pero sólo reduciríamos el código sin cambiar el nivel de abstracción. por ello, otra forma de saber que una función hace más de una cosa es extraer otra función de la misma con un nombre que no sea una reducción de su implementación [g34]. secciones en funciones fíjese en el listado 4-7. verá que la función generateprimes se divide en secciones como declaraciones, inicializaciones y filtros. es un síntoma evidente de que hace más de una cosa. las funciones que hacen una sola cosa no se pueden dividir en secciones. un nivel de abstracción por función para que las funciones realicen «una cosa», asegúrese de que las instrucciones de la función se encuentran en el mismo nivel de abstracción. el listado 3-1 incumple esta regla. incluye conceptos a un elevado nivel de abstracción, como gethtml(); otros se encuentran en un nivel intermedio, como stringpagepathname = pathparser.render(pagepath) y hay otros en un nivel especialmente bajo, como .append(“\n”). la mezcla de niveles de abstracción en una función siempre resulta confusa. los lectores no sabrán si una determinada expresión es un concepto esencial o un detalle. peor todavía, si se mezclan detalles con conceptos esenciales, aumentarán los detalles dentro de la función. 66leer código de arriba a abajo: la regla descendente el objetivo es que el código se lea como un texto de arriba a abajo [14] . queremos que tras todas las funciones aparezcan las del siguiente nivel de abstracción para poder leer el programa, descendiendo un nivel de abstracción por vez mientras leemos la lista de funciones. es lo que denomino la regla descendente. para decirlo de otra forma, queremos leer el programa como si fuera un conjunto de párrafos to , en el que cada uno describe el nivel actual de abstracción y hace referencia a los párrafos to posteriores en el siguiente nivel. para incluir configuraciones y detalles, incluimos configuraciones, después del contenido de la página de prueba, y por último los detalles. para incluir las configuraciones, incluimos la configuración de suite si se trata de una suite , y después la configuración convencional. para incluir la configuración de suite ; buscamos la jerarquía principal de la página suitesetup y añadimos una instrucción include con la ruta de dicha página. para buscar la jerarquía principal… a los programadores les resulta complicado aprender esta regla y crear funciones en un único nivel de abstracción, pero es un truco importante. es la clave para reducir la longitud de las funciones y garantizar que sólo hagan una cosa. al conseguir que el código se lea de arriba a abajo, se mantiene la coherencia de los niveles de abstracción. fíjese en el listado 3-7 del final del capítulo. muestra la función testablehtml modificada de acuerdo a estos principios. cada función presenta a la siguiente y se mantiene en un nivel de abstracción coherente. instrucciones switch 67es complicado usar una instrucción switch de tamaño reducido [15] . aunque sólo tenga dos casos, es mayor de lo que un bloque o función debería ser. también es complicado crear una instrucción switch que haga una sola cosa. por su naturaleza, las instrucciones switch siempre hacen n cosas. desafortunadamente, no siempre podemos evitar las instrucciones switch pero podemos asegurarnos de incluirlas en una clase de nivel inferior y de no repetirlas. para ello, evidentemente, recurrimos al polimorfismo. fíjese en el listado 3-4. muestra una de las operaciones que pueden depender del tipo de empleado. listado 3-4 payroll.java. public money calculatepay(employee e) throws invalidemployeetype ( switch (e.type) { case commissioned: return calculatecommissionedpay(e); case hourly: return calculatehourlypay(e); case salaried: return calculatesalariedpay(e); default: throw new invalidemployeetype(e.type); } } esta función tiene varios problemas. por un lado, es de gran tamaño y cuando se añadan nuevos tipos de empleado, aumentará más. por otra parte, hace más de una cosa. también incumple el principio de responsabilidad única ( single responsibility principie o srp) [16] ya que hay más de un motivo para cambiarla. además, incumple el principio de abierto/cerrado ( open closed principle u ocp) [17] , ya que debe cambiar cuando se añadan nuevos tipos, pero posiblemente el peor de los problemas es que hay un número ilimitado de funciones que tienen la misma estructura. por ejemplo, podríamos tener: ispayday(employee e, date date), o 68deliverpay(employee e, date date), o muchas otras, todas con la misma estructura. la solución al problema (véase el listado 3-5) consiste en ocultar la instrucción switch en una factoría abstracta [18] e impedir que nadie la vea. la factoría usa la instrucción switch para crear las instancias adecuadas de los derivados de employee y las distintas funciones, como calculatepay , ispayday y deliverpay , se entregarán de forma polimórfica a través de la interfaz employee . listado 3-5 employee y factory. public abstract class employee { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } public interface employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype; } public class employeefactoryimpl implements employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype { switch (r.type) { case commissioned: return new commissionedemployee(r); case hourly: return new hourlyemployee(r); case salaried: return new salariedemployee(r); default: throw new invalidemployeetype(r.type); } } } mi regla general para las instrucciones switch es que se pueden tolerar si sólo aparecen una vez, se usan para crear objetos polimórficos y se ocultan tras una relación de herencia para que el resto del sistema no las pueda ver [g23]. evidentemente, cada caso es diferente y en ocasiones se puede 69incumplir una o varias partes de esta regla. usar nombres descriptivos en el listado 3-7, hemos cambiado el nombre de la función de ejemplo de testablehtml a setupteardownincluder.render . es un nombre más apropiado ya que describe mejor el cometido de la función. también hemos asignado a los métodos privados un nombre descriptivo como istestable o includesetupandteardownpages . no hay que olvidar el valor de los nombres correctos. recuerde el principio de ward: «sabemos que trabajamos con código limpio cuando cada rutina es más o menos lo que esperábamos». para alcanzar este principio, gran parte del esfuerzo se basa en seleccionar nombres adecuados para pequeñas funciones que hacen una cosa. cuanto más reducida y concreta sea una función, más sencillo será elegir un nombre descriptivo. no tema los nombres extensos. un nombre descriptivo extenso es mucho mejor que uno breve pero enigmático. use una convención de nombres que permita leer varias palabras en los nombres de las funciones y use esas palabras para asignar a la función un nombre que describa su cometido. no tema dedicar tiempo a elegir un buen nombre. de hecho, debería probar con varios nombres y leer el código con todos ellos. los ide modernos como eclipse o intellij facilitan el cambio de nombres. use uno de estos ide y experimente con diferentes nombres hasta que encuentre uno que sea lo bastante descriptivo. la elección de nombres descriptivos clarifica el diseño de los módulos y le permite mejorarlos. no es extraño que la búsqueda de nombres adecuados genere una reestructuración favorable del código. sea coherente con los nombres. use las mismas frases, sustantivos y verbos en los nombres de función que elija para los módulos. pruebe, por ejemplo, con includesetupandteardownpages , includesetuppages , includesuitesetuppage e includesetuppage . la estructura similar de estos nombres permite que la secuencia cuente una historia. en realidad, si ve la secuencia anterior, seguramente se pregunte qué ha pasado con 70includeteardownpages , includesuiteteardownpage e includeteardownpage . argumentos de funciones el número ideal de argumentos para una función es cero. después uno (monádico) y dos (diádico). siempre que sea posible, evite la presencia de tres argumentos (triádico). más de tres argumentos (poliádico) requiere una justificación especial y no es muy habitual. los argumentos son complejos ya que requieren un gran poder conceptual. por ello suelo evitarlos en los ejemplos. fíjese en stringbuffer . podríamos haberlo pasado como argumento en lugar de como variable de instancia, pero los lectores habrían tenido que interpretarlo cada vez que lo vieran. al leer la historia que cuenta el módulo, includesetuppage() es más sencillo de interpretar que includesetuppageinto(newpagecontent) . el argumento se encuentra en un nivel de abstracción diferente que el nombre de la función y nos obliga a conocer un detalle ( stringbuffer ) que no es especialmente importante en ese momento. los argumentos son todavía más complicados desde un punto de vista de pruebas. imagine la dificultad de crear todos los casos de prueba para garantizar el funcionamiento de las distintas combinaciones de argumentos. si no hay argumentos, todo es más sencillo. si hay uno, no es demasiado difícil. con dos argumentos el problema es más complejo. con más de dos argumentos, probar cada combinación de valores adecuados es todo un reto. los argumentos de salida son más difíciles de entender que los de entrada. al leer una función, estamos acostumbrados al concepto de información añadida 71a la función a través de argumentos y extraída a través de un valor devuelto. no esperamos que la información se devuelva a través de los argumentos. por ello, los argumentos de salida suelen obligamos a realizar una comprobación doble. un argumento de salida es la mejor opción, después de la ausencia de argumentos. setupteardownincluder.render(pagedata) se entiende bien. evidentemente, vamos a representar los datos en el objeto pagedata . formas monádicas habituales hay dos motivos principales para pasar un solo argumento a una función. puede que realice una pregunta sobre el argumento, como en boolean fileexists(“myfile”), o que procese el argumento, lo transforme en otra cosa y lo devuelva. por ejemplo, inputstream fileopen(“myfile”) transforma un nombre de archivo string en un valor devuelto inputstream . los usuarios esperan estos dos usos cuando ven una función. debe elegir nombres que realicen la distinción con claridad y usar siempre ambas formas en un contexto coherente (consulte el apartado sobre separación de consultas de comandos). una forma menos habitual pero muy útil para un argumento es un evento. en esta forma, hay argumento de entrada pero no de salida. el programa debe interpretar la invocación de la función como evento y usar el argumento para alterar el estado del sistema, por ejemplo, void passwordattemptfailedntimes(int attempts) . use esta forma con precaución. debe ser claro para el lector que se trata de un evento. elija nombres y contextos con atención. intente evitar funciones monádicas que no tengan estas formas, por ejemplo, void includesetuppageinto(stringbuffer pagetext) . el uso de un argumento de salida en lugar de un valor devuelto para realizar transformaciones resulta confuso. si una función va a transformar su argumento de entrada, la transformación debe aparecer como valor devuelto. sin duda stringbuffertransform(stringbuffer in) es mejor que void 72transform(stringbuffer out) , aunque la implementación del primer caso devuelva solamente el argumento de entrada. al menos se ajusta a la forma de la transformación. argumentos de indicador los argumentos de indicador son horribles. pasar un valor booleano a una función es una práctica totalmente desaconsejable. complica inmediatamente la firma del método e indica que la función hace más de una cosa. hace algo si el indicador es true y otra cosa diferente si es false . en el listado 3-7 no se puede evitar, porque los invocadores ya pasan el indicador y el objetivo era limitar el ámbito a la función y después, pero la invocación de render (true) es confusa para el lector. si se desplaza el ratón sobre la invocación vemos que render (boolean issuite) puede ayudar, pero no demasiado. tendremos que dividir la función en dos: renderforsuite() y renderforsingletest() . funciones diádicas una función con dos argumentos es más difícil de entender que una función monádica. por ejemplo writefield(name) es más fácil de entender que writefield (outputstream, name) [19] . aunque en ambos casos el significado es evidente, la primera se capta mejor visualmente. la segunda requiere una breve pausa hasta que ignoramos el segundo parámetro, lo que en última instancia genera problemas ya que no debemos ignorar esa parte del código. las partes que ignoramos son las que esconden los errores. pero en ocasiones se necesitan dos argumentos. por ejemplo. point p = new point(0,0); es totalmente razonable. los puntos cartesianos suelen adoptar dos argumentos. de hecho, sería muy sorprendente ver point(0) . sin embargo, en este caso ambos argumentos son componentes ordenados de un mismo valor, mientras que outputstream y name carecen de una cohesión o un orden natural. 73incluso funciones diádicas evidentes como assertequals(expected, actual) resultan problemáticas. ¿cuántas veces ha incluido el valor real en su posición esperada? los dos argumentos carecen de un orden natural. el orden real y esperado es una convención que se adquiere gracias a la práctica. las combinaciones diádicas no son el mal en persona y tendrá que usarlas. sin embargo, recuerde que tienen un precio y que debe aprovechar los mecanismos disponibles para convertirlas en unitarias. por ejemplo, puede hacer que el método writefield sea un miembro de outputstream para poder usar outputstream.writefield(name) , o podría convertir outputstream en una variable miembro de la clase actual para no tener que pasarla. incluso podría extraer una nueva clase como fieldwriter que usara outputstream en su constructor y tuviera un método write . triadas las funciones que aceptan tres argumentos son sin duda mucho más difíciles de entender que las de dos. los problemas a la hora de ordenar, ignorar o detenerse en los argumentos se duplican. piense atentamente antes de crear una triada. por ejemplo, fíjese en la sobrecarga de assertequals que acepta tres argumentos: assertequals(message, expected, actual) . ¿cuántas veces lee el mensaje y piensa que es lo esperado? he visto esta triada en concreto muchas veces. de hecho, siempre que la veo, tengo que repasarla antes de ignorar el mensaje. por otra parte, hay otra triada que no es tan negativa: assertequals(1.0, amount, .001) . aunque también exija doble atención, merece la pena. conviene recordar siempre que la igualdad de los valores de coma flotante es algo relativo. objeto de argumento cuando una función parece necesitar dos o más argumentos, es probable que 74alguno de ellos se incluya en una clase propia. fíjese en la diferencia entre las dos siguientes declaraciones: circle makecircle (double x, double y, double radius); circle makecircle(point center, double radius); la reducción del número de argumentos mediante la creación de objetos puede parecer una trampa pero no lo es. cuando se pasan grupos de variables de forma conjunta, como x e y en el ejemplo anterior, es probable que formen parte de un concepto que se merece un nombre propio. listas de argumentos en ocasiones tendremos que pasar un número variable de argumentos a una función. fíjese en el método string.format : string.format (“%s worked %.2f hours.”, name, hours); si los argumentos variables se procesan de la misma forma, como en el ejemplo anterior, serán equivalentes a un único argumento de tipo list . por tanto, string.format es en realidad diádico. de hecho, la siguiente declaración de string.format es claramente diádica. public string format(string format, object… args) así pues, se aplican las mismas reglas. las funciones que aceptan argumentos variables pueden ser monádicas, diádicas o incluso triádicas, pero sería un error asignar más argumentos. void monad(integer… args); void dyad(string name, integer… args); void triad(string name, int count, integer… args); verbos y palabras clave la selección de nombres correctos para una función mejora la explicación de su cometido, así como el orden y el cometido de los argumentos. en formato monádico, la función y el argumento deben formar un par de verbo y sustantivo. por ejemplo, write(name) resulta muy evocador. sea lo que sea name , sin duda se escribe (write) . 75un nombre más acertado podría ser writefield(name) , que nos dice que name es un campo (field) . éste es un ejemplo de palabra clave como nombre de función. con este formato codificamos los nombres de los argumentos en el nombre de la función. por ejemplo, assertequals se podría haber escrito como assertexpectedequalsactual(expected, actual) , lo que mitiga el problema de tener que recordar el orden de los argumentos. sin efectos secundarios los efectos secundarios son mentiras. su función promete hacer una cosa, pero también hace otras cosas ocultas. en ocasiones realiza cambios inesperados en las variables de su propia clase. en ocasiones las convierte en las variables pasadas a la función o a elementos globales del sistema. en cualquier caso, se comete un engaño que suele provocar extrañas combinaciones temporales y dependencias de orden. fíjese en la función del listado 3-6, aparentemente inofensiva. usa un algoritmo estándar para comparar username con password . devuelve true si coinciden y false si hay algún problema, pero también hay un efecto secundario. ¿lo detecta? listado 3-6 uservalidator.java. public class uservalidator { private cryptographer cryptographer; public boolean checkpassword(string username, string password) { user user = usergateway.findbyname(username); if (user != user.null) { string codedphrase = user.getphraseencodedbypassword(); string phrase = cryptographer.decrypt(codedphrase, password); if (“valid password”.equals(phrase)){ session.initialize(); return true; } } return false; } 76} el efecto secundario es la invocación de session.initialize() . la función checkpassword , por su nombre, afirma comprobar la contraseña. el nombre no implica que inicialice la sesión. por tanto, un invocador que se crea lo que dice el nombre de la función se arriesga a borrar los datos de sesión actuales cuando decida comprobar la validez del usuario. este efecto secundario genera una combinación temporal. es decir, sólo se puede invocar checkpassword en determinados momentos (cuando se pueda inicializar la sesión). si no se invoca en orden, se pueden perder los datos de la sesión. las combinaciones temporales son confusas, en especial cuando se ocultan como efecto secundario. si tiene que realizar una combinación temporal, hágalo de forma clara en el nombre de la función. en este caso, podríamos cambiar el nombre de la función por checkpasswordandinitializesession , pero incumpliría la norma de hacer una sola cosa. argumentos de salida los argumentos suelen interpretarse como entradas de una función. si lleva varios años programando, estoy seguro de que habrá visto un argumento que en vez de ser de entrada era de salida. por ejemplo; appendfooter(s); ¿está función añade s al final de algo? ¿o añade el final de algo a s ? ¿ s es una entrada o una salida? lo sabemos al ver la firma de la función: public void appendfooter(stringbuffer report) esto lo aclara todo, pero para ello hay que comprobar la declaración de la función. todo lo que le obligue a comprobar la firma de la función es un esfuerzo doble. es una pausa cognitiva y debe evitarse. antes de la programación orientada a objetos, era necesario tener argumentos de salida. sin embargo, gran parte de su necesidad desaparece en los lenguajes orientados a objetos, pensados para actuar como argumento de salida. es decir, sería más indicado invocar appendfooter como report.appendfooter();. por lo general, los argumentos de salida deben evitarse. si su función 77tiene que cambiar el estado de un elemento, haga que cambie el estado de su objeto contenedor. separación de consultas de comando las funciones deben hacer algo o responder a algo, pero no ambas cosas. su función debe cambiar el estado de un objeto o devolver información sobre el mismo, pero ambas operaciones causan confusión. fíjese en la siguiente función: public boolean set(string attribute, string value); esta función establece el valor de un atributo y devuelve true en caso de éxito o false si el atributo no existe. esto provoca la presencia de una extraña instrucción como la siguiente: if (set(“username”, “unclebob”))… imagínelo desde el punto de vista del lector. ¿qué significa? ¿pregunta si el atributo « username » se ha establecido antes en « unclebob », o si el atributo «username» se ha establecido correctamente en « unclebob »? es complicado saberlo por la invocación ya que no es evidente si set es un verbo o un adjetivo. el autor pretendía que set fuera un verbo, pero el contexto de la instrucción if parece un adjetivo. la instrucción se lee como «si el atributo username se ha establecido previamente en unclebob », no como «establecer el atributo username en unclebob y si funciona, entonces…». podríamos solucionarlo si cambiamos el nombre de la función set por setandcheckifexists , pero no mejoraría la legibilidad de la instrucción if . la verdadera solución es separar el comando de la consulta para evitar la ambigüedad. if (attributeexists(“username”)) { setattribute(“username”, “unclebob”); … } 78mejor excepciones que devolver códigos de error devolver códigos de error de funciones de comando es un sutil incumplimiento de la separación de comandos de consulta. hace que los comandos usados asciendan a expresiones en los predicados de las instrucciones if . if (deletepage(page) == e_ok) no padece la confusión entre verbo y adjetivo, pero genera estructuras anidadas. al devolver un código de error se crea un problema: el invocador debe procesar el error de forma inmediata. if (deletepage(page) == e_ok) { if (registry.deletereference(page.name) == e_ok) { if (configkeys.deletekey(page.name.makekey()) == e_ok) { logger.log(“page deleted”); } else { logger.log(“configkey not deleted”); } } else { logger.log(“deletereference from registry failed”); } } else { logger.log(“delete failed”); return e_error; } por otra parte, si usa excepciones en lugar de códigos de error, el código de procesamiento del error se puede separar del código de ruta y se puede simplificar: try { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } catch (exception e) { logger.log(e.getmessage()); } extraer bloques try/catch los bloques try/catch no son atractivos por naturaleza. confunden la estructura del código y mezclan el procesamiento de errores con el normal. 79por ello, conviene extraer el cuerpo de los bloques try y catch en funciones individuales. public void delete(page page) { try { deletepageandallreferences(page); } catch (exception e) { logerror(e); } } private void deletepageandallreferences(page page) throws exception { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } private void logerror(exception e) { logger.log(e.getmessage()); } en este caso, la función delete es de procesamiento de errores. es fácil de entender e ignorar. la función deletepageandallreferences es para los procesos de borrar una página. el procesamiento de errores se puede ignorar. de este modo, la separación facilita la comprensión y la modificación del código. el procesamiento de errores es una cosa las funciones sólo deben hacer una cosa y el procesamiento de errores es un ejemplo. por tanto, una función que procese errores no debe hacer nada más. esto implica (como en el ejemplo anterior) que, si una función incluye la palabra clave try , debe ser la primera de la función y que no debe haber nada más después de los bloques catch/finally . el imán de dependencias error.java la devolución de códigos de error suele implicar que existe una clase o enumeración en la que se definen los códigos de error. public enum error { 80ok, invalid, no_such, locked, out_of_resources, waiting_for_event; } clases como ésta son un imán para las dependencias ; otras muchas clases deben importarlas y usarlas. por ello, cuando cambia la enumeración error , es necesario volver a compilar e implementar dichas clases [20] . esto añade presión a la clase error . los programadores no quieren añadir nuevos errores porque tendrán que volver a generar e implementarlo todo. por ello, reutilizan códigos de error antiguos en lugar de añadir otros nuevos. al usar excepciones en lugar de códigos de error, las nuevas excepciones son derivaciones de la clase de la excepción. se pueden añadir sin necesidad de volver a compilar o implementar [21] . no repetirse [22] fíjese de nuevo en el listado 3-1; verá que hay un algoritmo que se repite cuatro veces, en los casos setup , suitesetup , teardown y suiteteardown . no es fácil detectar esta repetición ya que las cuatro instancias se mezclan con otro código, pero la duplicación es un problema ya que aumenta el tamaño del código y requerirá una modificación cuádruple si alguna vez cambia el algoritmo. también se cuadriplica el riesgo de errores. esta duplicación se remedia gracias al método include del listado 3-7. vuelva a leer el código y fíjese en cómo se ha mejorado la legibilidad del código reduciendo la duplicación. la duplicación puede ser la raíz de todos los problemas del software . existen numerosos principios y prácticas para controlarla o eliminarla. imagine que todas las formas normales de la base de datos de codd sirvieran 81para eliminar la duplicación de datos. imagine también cómo la programación orientada a objetos concentra el código en clases base que en otros casos serian redundantes. la programación estructurada, la programación orientada a aspecto y la orientada a componentes son, en parte, estrategias para eliminar duplicados. parece que, desde la aparición de las subrutinas, las innovaciones en desarrollo de software han sido un intento continuado por eliminar la duplicación de nuestro código fuente. programación estructurada algunos programadores siguen las reglas de programación estructurada de edsger dijkstra [23] . dijkstra afirma que todas las funciones y todos los bloques de una función deben tener una entrada y una salida. estas reglas implican que sólo debe haber una instrucción return en una función, que no debe haber instrucciones break o continue en un bucle y nunca, bajo ningún concepto, debe haber instrucciones goto . aunque apreciemos los objetivos y disciplinas de la programación estructurada, no sirven de mucho cuando las funciones son de reducido tamaño. su verdadero beneficio se aprecia en funciones de gran tamaño. por tanto, si sus funciones son de tamaño reducido, una instrucción return , break o continue no hará daño alguno y en ocasiones puede resultar más expresiva que la regla de una entrada y una salida. por otra parte, goto sólo tiene sentido en funciones de gran tamaño y debe evitarse. cómo crear este tipo de funciones la creación de software es como cualquier otro proceso creativo. al escribir un informe o un artículo, primero se estructuran las ideas y después el mensaje hasta que se lea bien. el primer borrador puede estar desorganizado, de modo que lo retoca y mejora hasta que se lea de la forma adecuada. cuando creo funciones, suelen ser extensas y complicadas, con abundancia de sangrados y bucles anidados. con extensas listas de 82argumentos, nombres arbitrarios y código duplicado, pero también cuento con una serie de pruebas de unidad que abarcan todas y cada una de las líneas de código. por tanto, retoco el código, divido las funciones, cambio los nombres y elimino los duplicados. reduzco los métodos y los reordeno. en ocasiones, elimino clases enteras, mientras mantengo las pruebas. al final, consigo funciones que cumplen las reglas detalladas en este capítulo. no las escribo al comenzar y dudo que nadie pueda hacerlo. conclusión todo sistema se crea a partir de un lenguaje específico del dominio diseñado por los programadores para describir dicho sistema. las funciones son los verbos del lenguaje y las clases los sustantivos. no es volver a la noción de que los sustantivos y verbos de un documento de requisitos son las clases y funciones de un sistema. es una verdad mucho más antigua. el arte de la programación es, y ha sido siempre, el arte del diseño del lenguaje. los programadores experimentados piensan en los sistemas como en historias que contar, no como en programas que escribir. recurren a las prestaciones del lenguaje de programación seleccionado para crear un lenguaje expresivo mejor y más completo que poder usar para contar esa historia. parte de ese lenguaje es la jerarquía de funciones que describen las acciones que se pueden realizar en el sistema. dichas acciones se crean para usar el lenguaje de dominio concreto que definen para contar su pequeña parte de la historia. en este capítulo hemos visto la mecánica de la creación de funciones correctas. si aplica estas reglas, sus funciones serán breves, con nombres correctos, y bien organizadas, pero no olvide que su verdadero objetivo es contar la historia del sistema y que las funciones que escriba deben encajar en un lenguaje claro y preciso que le sirva para contar esa historia. setupteardownincluder 83listado 3-7 setupteardownincluder.java. package fitnesse.html; import fitnesse.responders.run.suiteresponder; import fitnesse.wiki.*; public class setupteardownincluder { private pagedata pagedata; private boolean issuite; private wikipage testpage; private stringbuffer newpagecontent; private pagecrawler pagecrawler; public static string render(pagedata pagedata) throws exception { return render(pagedata, false); } public static string render(pagedata pagedata, boolean issuite) throws exception { return new setupteardownincluder(pagedata).render(issuite); } private setupteardownincluder(pagedata pagedata) { this.pagedata = pagedata; testpage = pagedata.getwikipage(); pagecrawler = testpage.getpagecrawler(); newpagecontent = new stringbuffer(); } private string render(boolean issuite) throws exception { this.issuite = issuite; if (istestpage()) includesetupandteardownpages(); return pagedata.gethtml(); } private boolean istestpage() throws exception { return pagedata.hasattribute(“test”); } private void includesetupandteardownpages() throws exception { includesetuppages(); includepagecontent(); includeteardownpages(); updatepagecontent(); } private void includesetuppages() throws exception { if (issuite) includesuitesetuppage(); includesetuppage(); } 84private void includesuitesetuppage() throws exception { include(suiteresponder.suite_setup_name, “-setup”); } private void includesetuppage() throws exception { include(“setup”, “-setup”); } private void includepagecontent() throws exception { newpagecontent.append(pagedata.getcontent()); } private void includeteardownpages() throws exception { includeteardownpage(); if (issuite) includesuiteteardownpage(); } private void includeteardownpage() throws exception { include(“teardown”, “-teardown”); } private void includesuiteteardownpage() throws exception { include(suiteresponder.suite_teardown_name, “-teardown”); } private void updatepagecontent() throws exception { pagedata.setcontent(newpagecontent.tostring()); } private void include(string pagename, string arg) throws exception ( wikipage inheritedpage = findinheritedpage(pagename); if (inheritedpage != null) { string pagepathname = getpathnameforpage(inheritedpage); buildincludedirective(pagepathname, arg); } } private wikipage findinheritedpage(string pagename) throws exception { return pagecrawlerimpl.getinheritedpage(pagename, testpage); } private string getpathnameforpage(wikipage page) throws exception { wikipagepath pagepath = pagecrawler.getfullpath(page); return pathparser.render(pagepath); } private void buildincludedirective(string pagepathname, string arg) { newpagecontent .append(“\n!include ”) .append(arg) .append(“ .”) .append(pagepathname) .append(“\n”); } 85} bibliografía [kp78] : kernighan and plaugher, the elements of programming style , 2d. ed., mcgraw-hill, 1978. [ppp02] : robert c. martin, agile software development: principles, patterns, and practices, prentice hall, 2002. [gof] : design patterns: elements of reusable object oriented software, gamma et al., addison wesley, 1996. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. [sp72] : structured programming , o. j. dahl, e. w. dijkstra, c. a. r. hoare, academic press, london, 1972. 864 comentarios «no comente el código incorrecto, reescríbalo». brian w. kernighan y p. j. plaugher [24] no hay nada más útil que un comentario bien colocado. no hay nada que colapse más un módulo que comentarios dogmáticos innecesarios. no hay nada más dañino que un comentario antiguo que propague mentiras y desinformación. los comentarios no son como la lista de schindler. no son pura bondad. de hecho, en el mejor de los casos, son un mal necesario. si los lenguajes de 87programación fueran más expresivos o si pudiéramos dominarlos para expresar nuestras intenciones, no necesitaríamos demasiados comentarios, puede que incluso ninguno. el uso correcto de los comentarios permite compensar nuestra incapacidad para expresarnos en el código. he usado la palabra incapacidad, a propósito. los comentarios siempre son fallos. debemos usarlos porque no siempre sabemos cómo expresarnos sin ellos pero su uso no es motivo de celebración. cuando tenga que escribir un comentario, piense si no existe otra forma de expresarse en el código. siempre que se exprese en el código, debe felicitarse. siempre que escriba un comentario, debe hacer un gesto de desaprobación y sentir su incapacidad para expresarse. ¿por qué estoy en contra de los comentarios? porque mienten. no siempre y no siempre intencionadamente, pero lo hacen. cuando más antiguo es un comentario y más se aleja del código que describe, mayor es la probabilidad de que sea equivocado. el motivo es sencillo. los programadores no los pueden mantener. el código cambia y evoluciona. los fragmentos cambian de lugar, se bifurcan, se reproducen y se vuelven a combinar para crear quimeras. desafortunadamente, los comentarios no siempre siguen el ritmo, no siempre pueden hacerlo y suelen separarse del código que describen y se convierten en huérfanos sin precisión alguna. por ejemplo, fíjese en lo que sucede con este comentario y la línea que pretendía describir: mockrequest request; private final string http_date_regexp = “[smtwf][a-z]{2}\\,\\s[0-9]{2}\\s[jfmasond][a-z]{2}\\s” + “[0-9]{4}\\s[0-9]{2}\\:[0-9]{2}\\:[0-9]{2}\\sgmt”; private response response; private fitnessecontext context; private fileresponder responder; private locale savelocale; // ejemplo: «tue, 02 apr 2003 22:18:49 gmt» seguramente se añadieron después otras variables de instancia entre la constante http_date_regexp y su comentario explicativo. se podría afirmar que los programadores deben ser lo bastante disciplinados como para mantener los comentarios actualizados, relevantes y precisos. de acuerdo, debería, pero esa energía debería invertirse en crear 88código claro y expresivo que no necesite comentario alguno. los comentarios imprecisos son mucho peor que la ausencia de comentarios. suelen confundir al usuario. generan expectativas que nunca se cumplen. definen reglas que no deben seguirse en absoluto. la verdad sólo se encuentra en un punto: el código. sólo el código puede contar lo que hace. es la única fuente de información precisa. por tanto, aunque los comentarios sean necesarios en ocasiones, dedicaremos nuestra energía a minimizarlos. los comentarios no compensan el código incorrecto una de las principales motivaciones para crear comentarios es el código incorrecto. creamos un módulo y sabemos que es confuso y está desorganizado. sabemos que es un desastre y entonces decidimos comentarlo. error. mejor límpielo. el código claro y expresivo sin apenas comentarios es muy superior al código enrevesado y complejo con multitud de comentarios. en lugar de perder tiempo escribiendo comentarios que expliquen el desastre cometido, dedíquelo a solucionarlo. explicarse en el código en ocasiones, el código es un pobre vehículo de expresión. desafortunadamente, muchos programadores lo entienden como que el código no es un buen medio de expresión. esto es falso. ¿qué prefiere ver? esto: // comprobar si el empleado tiene derecho a todos los beneficios if ((employee.flags & hourly_flag) && (employee.age > 65)) o esto otro: if (employee.iseligibleforfullbenefits()) apenas se tardan unos segundos en explicar nuestras intenciones en el código. en muchos casos, basta con crear una función que diga lo mismo que 89el comentario que pensaba escribir. comentarios de calidad algunos comentarios son necesarios o beneficiosos. veremos algunos de los que considero válidos. no obstante, recuerde que el único comentario realmente bueno es el que no tiene que escribir. comentarios legales en ocasiones, nuestros estándares corporativos de creación de código nos obligan a crear determinados comentarios por motivos legales. por ejemplo, los comentarios de derechos de autor son necesarios y deben incluirse al inicio de cada archivo. el siguiente encabezado de comentario se incluye de forma estándar al inicio de todos los archivos fuente de fitnesse. nuestro ide evita que este comentario parezca sobrante replegándolo de forma automática. // copyright (c) 2003,2004,2005 de object mentor, inc. todos los derechos reservados. // publicado bajo las condiciones de la licencia pública general gnu versión 2 o posterior. este tipo de comentarios no deben ser contratos ni tomos legales. siempre que sea posible, haga referencia a una licencia estándar o a otro documento externo en lugar de incluir todos los términos y condiciones en el comentario. comentarios informativos en ocasiones es útil proporcionar información básica con un comentario. por ejemplo, el siguiente comentario explica el valor devuelto por un método abstracto: // devuelve una instancia del elemento responder probado. protected abstract responder responderinstance(); estos comentarios pueden ser útiles, pero es mejor usar el nombre de la función para transmitir la información siempre que sea posible. por ejemplo, 90en este caso el comentario sería redundante si cambiamos el nombre de la función por responderbeingtested. veamos un ejemplo mejor: // el formato coincide con kk:mm:ss eee, mmm dd, yyyy pattern timematcher = pattern.compile( “\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*”); en este caso, el comentario nos indica que la expresión regular debe coincidir con una fecha y una hora con el formato aplicado por la función simpledateformat.format con la cadena de formato especificada. hubiera resultado mejor y más claro si el código se hubiera cambiado a una clase especial que convirtiera los formatos de fechas y horas. de ese modo el comentario habría sido superfluo. explicar la intención en ocasiones, un comentario es algo más que información útil sobre la implementación y proporciona la intención de una decisión. en el siguiente caso, vemos una interesante decisión documentada por un comentario. al comparar dos objetos, el autor decidió ordenar los objetos de su clase por encima de los objetos de otra. public int compareto(object o) { if (o instanceof wikipagepath) { wikipagepath p = (wikipagepath) o; string compressedname = stringutil.join(names, “”); string compressedargumentname = stringutil.join(p.names, “”); return compressedname.compareto(compressedargumentname); } return 1; // somos mayores porque somos el tipo correcto. } veamos otro ejemplo mejor. puede que no esté de acuerdo con la solución del programador, pero al menos sabe lo que intentaba hacer. public void testconcurrentaddwidgets() throws exception { widgetbuilder widgetbuilder = new widgetbuilder(new class[](boldwidget.class)); string text = “‘‘‘bold text’’’”; parentwidget parent = new boldwidget(new mockwidgetroot(), “‘‘‘bold text’’’”); atomicboolean failflag = new atomicboolean(); failflag.set(false); 91//nuestro mejor intento de obtener una condición de carrera //creando un gran número de procesos. for (int i = 0; i < 25000; i++) { widgetbuilderthread widgetbuiiderthread = new widgetbuilderthread(widgetbuilder, text, parent, failflag); thread thread = new thread(widgetbuilderthread); thread.start(); } assertequals(false, failflag.get()); } clarificación en ocasiones, basta con traducir el significado de un argumento o valor devuelto en algo más legible. por lo general, conviene buscar la forma de que el argumento o el valor devuelto sean claros por sí mismos; pero cuando forma parte de una biblioteca estándar o de código que no se puede alterar, un comentario aclarativo puede ser muy útil. public void testcompareto() throws exception { wikipagepath a = pathparser.parse(“pagea”); wikipagepath ab = pathparser.parse(“pagea.pageb”); wikipagepath b = pathparser.parse(“pageb”); wikipagepath aa = pathparser.parse(“pagea.pagea”); wikipagepath bb = pathparser.parse(“pageb.pageb”); wikipagepath ba = pathparser.parse(“pageb.pagea”); asserttrue(a.compareto(a) == 0); // a == a asserttrue(a.compareto(b) != 0); // a != b asserttrue(ab.compareto(ab) == 0); // ab == ab asserttrue(a.compareto(b) == -1); // a < b asserttrue(aa.compareto(ab) == -1); // aa < ab asserttrue(ba.compareto(bb) == -1); // ba < bb asserttrue(b.compareto(a) == 1); // b > a asserttrue(ab.compareto (aa) == 1); // ab > aa asserttrue(bb.compareto(ba) == 1); // bb > ba } pero también existe el riesgo de que un comentario aclarativo sea incorrecto. en el ejemplo anterior, compruebe lo difícil que resulta comprobar si los comentarios son correctos. esto explica por qué la clarificación es necesaria y también arriesgada. por ello, antes de escribir estos comentarios, asegúrese de que no hay una solución mejor y también de que sean precisos. 92advertir de las consecuencias en ocasiones es muy útil advertir a otros programadores de determinadas consecuencias. por ejemplo, el siguiente comentario explica por qué un determinado caso de prueba está desactivado: // no ejecutar a menos // que le sobre tiempo. public void _testwithreallybigfile() { writelinestofile(10000000); response.setbody(testfile); response.readytosend(this); string responsestring = output.tostring(); assertsubstring(“content-length: 1000000000”, responsestring); asserttrue(bytessent > 1000000000); } en la actualidad, evidentemente, desactivaríamos la prueba por medio del atributo @ignore con la correspondiente cadena explicativa: @ignore(“takes too long to run”) , pero antes de la aparición de junit 4, era habitual añadir un guion bajo delante del nombre del método. el comentario realizaba su cometido. veamos otro ejemplo: public static simpledateformat makestandardhttpdateformat() { //simpledataformat no es compatible con procesos, //por lo que debe crear cada instancia de forma independiente. simpledateformat df = new simpledateformat(“eee, dd mmm yyyy hh:mm:ss z”); df.settimezone (timezone.gettimezone (“gmt”)); return df; } seguramente conozca soluciones mejores para este problema. estoy de acuerdo, pero el comentario es perfectamente razonable. evita que un programador use un inicializador estático por motivos de eficacia. comentarios todo en ocasiones conviene usar notas con forma de comentarios //todo . en el 93siguiente caso, el comentario todo explica por qué la función tiene una implementación incorrecta y cuál debe ser su futuro. // todo-mdm no son necesarios // esperamos que desaparezca en el modelo definitivo protected versioninfo makeversion() throws exception { return null; } todo son tareas que el programador piensa que debería haber hecho pero que no es así. pueden ser un recordatorio para eliminar una función obsoleta o una petición para resolver un problema. pueden ser una solicitud para buscar un nombre más adecuado o para realizar un cambio que dependa de un evento planeado. sea lo que sea, no es excusa para mantener código incorrecto en el sistema. en la actualidad, muchos ide cuentan con funciones especiales para localizar comentarios todo , por lo que seguramente no se pierda. sin embargo, no colapse el código con estos comentarios. examínelos y elimine todos los que pueda. amplificación se puede usar un comentario para amplificar la importancia de algo que, en caso contrario, parecería irrelevante. string listitemcontent = match.group(3).trim(); // el recorte es importante. elimina los espacios iniciales // que harían que el elemento se reconociera como // otra lista. new listitemwidget(this, listitemcontent, this.level + 1); return buildlist(text.substring(match.end())); javadoc en api públicas no hay nada más útil y satisfactorio que una api pública bien descrita. los javadoc de la biblioteca estándar de java son un ejemplo. sería muy complicado crear programas de java sin ellos. si usa una api pública, debe crear javadoc de calidad para la misma, pero recuerde el siguiente consejo a lo largo del capítulo: los javadoc pueden ser 94tan ambiguos, amplios y descorteses como cualquier otro tipo de documento. comentarios incorrectos muchos comentarios pertenecen a esta categoría. suelen ser excusas de código pobre o justificaciones de decisiones insuficientes, algo así como si el programador se hablara a sí mismo. balbucear añadir un comentario sin razón o porque el proceso lo requiere es un error. si decide escribir un comentario, tómese el tiempo necesario para asegurarse de que sea el mejor que puede redactar. el siguiente ejemplo es de fitnesse, donde un comentario sin duda sería de utilidad, pero el autor tenía prisa o no prestó demasiada atención. su balbuceo generó un enigma: public void loadproperties() { try { string propertiespath = propertieslocation + “/” + properties_file; fileinputstream propertiesstream = new fileinputstream(propertiespath); loadedproperties.load(propertiesstream); } catch(ioexception e) { // si no hay archivos de propiedades significan que cargan las predeterminadas } } ¿qué significa el comentario del bloque catch ? seguro que algo para el autor, pero el significado no está claro. aparentemente, si se genera ioexception , significa que no hay archivo de propiedades y, en ese caso, se cargan los valores predeterminados. ¿pero quién carga los valores predeterminados? ¿se cargan antes de la invocación de loadproperties.load o loadproperties.load captura la excepción, carga los valores predeterminados y después nos pasa la excepción para que la ignoremos? ¿o será que loadproperties.load carga todos los valores 95predeterminados antes de intentar abrir el archivo? ¿intentaba el autor consolarse por dejar el bloque catch vacío? ésta es la posibilidad más temida, ¿se estaba diciendo que volviera más tarde para crear el código para cargar los valores predeterminados? nuestro único recurso es examinar el código en otras partes del sistema para determinar qué sucede. cualquier comentario que le obligue a buscar su significado en otro módulo ha fallado en su intento de comunicación y no merece los bits que consume. comentarios redundantes el listado 4-1 muestra una sencilla función con un comentario de encabezado totalmente redundante. seguramente se tarde más en leer que el propio código. listado 4-1 waitforclose. // método de utilidad devuelto cuando this.closed es true. genera una excepción // si se alcanza el tiempo de espera. public synchronized void waitforclose(final long timeoutmillis) throws exception { if (!closed) { wait(timeoutmillis); if(!closed) throw new exception (“mockresponsesender could not be closed”); } } ¿para qué sirve este comentario? no es más informativo que el código. no lo justifica ni transmite la intención ni la lógica. no es más fácil de leer que el código. de hecho, es menos preciso y obliga al lector a aceptar la falta de precisión en lugar de a entenderlo. es como un vendedor de coches de segunda menos que le asegura que no hace falta revisar el motor. fíjese ahora en la legión de javadoc inútiles y redundantes del listado 4- 2, obtenido de tomcat. estos comentarios únicamente ensucian y oscurecen el código. no tienen ninguna función documental. para empeorar las cosas, 96sólo le mostramos algunos. el módulo tiene muchos más. listado 4-2 containerbase.java (tomcat). public abstract class containerbase implements container, lifecycle, pipeline, mbeanregistration, serializable { /** * retardo del procesador para este componente. */ protected int backgroundprocessordelay = -1; /** * compatibilidad con eventos de ciclo vital de este componente. */ protected lifecyclesupport lifecycle = new lifecyclesupport(this); /** * escuchadores de eventos de contenedor de este contenedor. */ protected arraylist listeners = new arraylist(); /** * implementación loader a la que se asocia este contenedor. */ protected loader loader = null; /** * implementación logger a la que se asocia este contenedor. */ protected log logger = null; /** * nombre de registrador asociado. */ protected string logname = null; /** * implementación manager a la que se asocia este contenedor. */ protected manager manager = null; /** * clúster al que se asocia este contenedor. */ protected cluster cluster = null; /** * nombre legible de este contenedor. 97*/ protected string name = null; /** * contenedor principal de este contenedor. */ protected container parent = null; /** * cargador de clase principal que configurar al instalar un elemento * loader. */ protected classloader parentclassloader = null; /** * objeto pipeline al que se asocia este contenedor. */ protected pipeline pipeline = new standardpipeline(this); /** * objeto realm al que se asocia este contenedor. */ protected realm realm = null; /** * objeto dircontext de recursos al que se asocia este contenedor. */ protected dircontext resources = null; comentarios confusos en ocasiones, a pesar de las buenas intenciones, un programador realiza una afirmación en sus comentarios que no es del todo precisa. fíjese otra vez en el comentario redundante y confuso del listado 4-1. ¿sabe por qué es confuso? el método no devuelve nada cuando this.closed se convierte en true . devuelve algo si this.closed es true ; en caso contrario, espera y genera una excepción si this.closed no es true . este sutil fragmento, oculto en un comentario más difícil de leer que el cuerpo del código, puede hacer que otro programador invoque la función con la esperanza de que devuelva algo cuando this.closed sea true . ese pobre programador se encontrará en una sesión de depuración intentando determinar por qué el código se ejecuta tan lentamente. 98comentarios obligatorios es una locura tener una regla que afirme que todas las funciones deben tener un javadoc o que todas las variables deben tener un comentario. este tipo de comentarios ensucian el código y generan confusión y desorganización. por ejemplo, los javadoc obligatorios para todas las funciones crean abominaciones como el listado 4-3. no sirven de nada, complican el código y constituyen posibles engaños y desorientaciones. listado 4-3 /** * * @param title el título del cd * @param author el autor del cd * @param tracks el número de pistas del cd * @param durationinminutes la duración del cd en minutos */ public void addcd(string title, string author, int tracks, int durationinminutes) { cd cd = new cd(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = duration; cdlist.add(cd); } comentarios periódicos en ocasiones, se añade un comentario al inicio de un módulo cada vez que se edita. estos comentarios acumulan una especie de registro de todos los cambios realizados. he visto módulos con decenas de páginas con estas entradas. * cambios (11-oct-2001) * ----------------------------- * 11-oct- 2001 : reorganización de la clase y cambio a un nuevo paquete * com.jrefinery.date (dg); * 05-nov- 2001 : se añade un método getdescription() y se elimina la clase notabledate (dg); 99* 12-nov- 2001 : ibd requiere el método setdescription(), una vez eliminada la clase notabledate * (dg); se cambian getpreviousdayofweek(), getfollowingdayofweek() * y getnearestdayofweek() para corregir errores (dg); * 05-dic- 2001 : error corregido en la clase spreadsheetdate (dg); * 29-may- 2002 : se transfieren todas las constantes de mes a una interfaz * independiente (monthconstants) (dg); * 27-ago- 2002 : error corregido en el método addmonths(), gracias a nálevka petr (dg); * 03-oct- 2002 : errores indicados por checkstyle (dg) corregidos; * 13-mar- 2003 : implementación de serializable (dg); * 29-may- 2003 : error corregido en el método addmonths (dg); * 04-sep- 2003 : implementación de comparable. actualización de los javadoc isinrange (dg); * 05-ene- 2005 : error corregido en el método addyears() (1096202) (dg); hace tiempo hubo una buena razón para crear y mantener estas entradas de registro al inicio de cada módulo. carecíamos de sistemas de control de código fuente que se encargaran de ello, pero en la actualidad, estas entradas son elementos sobrantes que complican los módulos. debe eliminarlas totalmente. comentarios sobrantes en ocasiones vemos comentarios que simplemente sobran. restan importancia a lo evidente y no ofrecen información nueva. /** * constructor predeterminado. */ protected annualdaterule() { } ¿en serio? ¿y este otro?: /** día del mes. */ private int dayofmonth; y aquí el parangón de la redundancia: /** * devuelve el día del mes. 100* * @return el día del mes. */ public int getdayofmonth() { return dayofmonth; } estos comentarios son tan inservibles que aprendemos a ignorarlos. al leer el código, la vista los salta. con el tiempo, los comentarios empiezan a mentir cuando cambia el código que les rodea. el primer comentario del listado 4-4 parece correcto [25] . explica por qué se ignora el bloque catch , pero el segundo comentario sobra. parece que el programador estaba tan frustrado con crear bloques try/catch en la función que necesitaba explotar. listado 4-4 startsending. private void startsending() { try { dosending(); } catch(socketexception e) { // normal, alguien ha detenido la solicitud. } catch(exception e) { try { response.add(errorresponder.makeexceptionstring(e)); response.closeall(); } catch(exception e1) { //¡un respiro! } } } en lugar de explotar en un comentario sin sentido, el programador debería haber sabido que su frustración se podría aliviar mejorando la estructura del código. tendría que haber centrado su energía en extraer el último bloque try/catch en una función independiente, como muestra el 101listado 4-5. listado 4-5 startsending (refactorizado). private void startsending() { try { dosending(); } catch(socketexception e) { // normal. alguien ha detenido la solicitud. } catch(exception e) { addexceptionandcloseresponse(e); } } private void addexceptionandcloseresponse(exception e) { try { response.add(errorresponder.makeexceptionstring(e)); response.closeall(); } catch(exception e1) { } } cambie la tentación de crear elementos sobrantes por la determinación de limpiar su código. mejorará como programador y será más fácil. comentarios sobrantes espeluznantes los javadoc también pueden ser innecesarios. ¿para qué sirven los siguientes javadoc (de una conocida biblioteca) de código abierto? la respuesta: para nada. son comentarios redundantes creados en un intento equivocado de redactar documentación. /** el nombre. */ private string name; /** la versión. */ 102private string version; /** el licencename. */ private string licencename; /** la versión. */ private string info; vuelva a leer los comentarios. ¿detecta el error de corta y pega? si los autores no prestan atención al escribir sus comentarios (o al pegarlos), ¿por qué se espera que sean de utilidad para los lectores? no usar comentarios si se puede usar una función o una variable fíjese en el siguiente código: // ¿el módulo de la lista global <mod> depende del // subsistema del que formamos parte? if (smodule.getdependsubsystems().contains(subsysmod.getsubsystem())) se podría cambiar sin el comentario de esta forma: arraylist moduledependees = smodule.getdependsubsystems(); string oursubsystem = subsysmod.getsubsystem(); if (moduledependees.contains(oursubsystem)) el autor del código original seguramente escribió primero el comentario (improbable) y después el código para ajustarlo al comentario. sin embargo, el autor tendría que haber refactorizado el código, como hice yo, para poder eliminar el comentario. marcadores de posición en ocasiones los programadores marcan una determinada posición en un archivo. por ejemplo, recientemente encontré esto en un programa: // acciones ////////////////////////////////// son escasas las ocasiones en las que tiene sentido agrupar funciones bajo esta estructura. por lo general, debe eliminarse, sobre todo la molesta hilera de barras al final. piénselo de esta forma. estas estructuras son atractivas si no las usa demasiado. por ello, úselas esporádicamente y sólo cuando el beneficio sea 103significativo. si las usa en exceso, acabarán por ser ignoradas. comentarios de llave de cierre en ocasiones, los programadores incluyen comentarios especiales en llaves de cierre, como en el listado 4-6. aunque pueda tener sentido en funciones extensas con estructuras anidadas, únicamente estorba a las funciones encapsuladas y de pequeño tamaño que nos gustan. por ello, si siente el deseo de marcar sus llaves de cierre, pruebe a reducir el tamaño de sus funciones. listado 4-6 wc.java. public class wc { public static void main(string[] args) { bufferedreader in = new bufferedreader(new inputstreamreader(system.in)); string line; int linecount = 0; int charcount = 0; int wordcount = 0; try { while ((line = in.readline()) != null) { linecount++; charcount += line.length(); string words[] = line.split(“\\w”); wordcount += words.length; } //while system.out.println(“wordcount = ” + wordcount); system.out.println(“linecount = ” + linecount); system.out.println(“charcount = ” + charcount); } // try catch (ioexception e) { system.err.println(“error: ” + e.getmessage()); } //catch } //main } asignaciones y menciones /* añadido por rick */ los sistemas de control de código fuente recuerdan a la perfección quién ha añadido qué y cuándo. no es necesario plagar el código con pequeñas 104menciones. puede pensar que estos comentarios son útiles y que ayudan a otros a hablar sobre el código, pero en realidad sobreviven durante años y cada vez son menos precisos y relevantes. el sistema de control de código fuente es el punto idóneo para este tipo de información. código comentado no hay nada más odioso que el código comentado. ¡no lo haga! inputstreamresponse response = new inputstreamresponse(); response.setbody(formatter.getresultstream(), formatter.getbytecount()); // inputstream resultsstream = formatter.getresultstream(); // streamreader reader = new streamreader(resultsstream); // response.setcontent(reader.read(formatter.getbytecount())); los lectores que vean código comentado no tendrán el valor de borrarlo. pensarán que está ahí por algo y que es demasiado importante para borrarlo. por ello, el código comentado se acumula como los sedimentos en una botella de vino malo. fíjese en este fragmento de apache commons: this.bytepos = writebytes(pngidbytes, 0); //hdrpos = bytepos; writeheader(); writeresolution(); //datapos = bytepos; if (writeimagedata()) { writeend(); this.pngbytes = resizebytearray(this.pngbytes, this.maxpos); } else { this.pngbytes = null; } return this.pngbytes; ¿por qué hay dos líneas comentadas? ¿son importantes? ¿se han conservado como recordatorio de un cambio inminente o es algo que alguien comentó hace años y no se ha preocupado de limpiar? hubo una época, en la década de 1960, en la que el código comentado pudo ser útil, pero hace tiempo que contamos con buenos sistemas de control de código fuente, sistemas que recuerdan el código por nosotros. ya no tenemos que comentarlo. elimínelo. no lo perderá. se lo aseguro. 105comentarios html el html en comentarios de código fuente es una aberración, como puede apreciar en el siguiente fragmento. dificulta la lectura de los comentarios donde debería ser más fácil; el editor o ide. si los comentarios se van a extraer con una herramienta (como javadoc) para mostrarlos en una página web, debe ser responsabilidad de dicha herramienta y no del programador el adornar los comentarios con el correspondiente html. /** * tarea para ejecutar pruebas de aceptación. * esta tarea ejecuta pruebas de aceptación y publica los resultados. * <p/> * <pre> * uso: * &lt;taskdef name=&quot;execute-fitnesse-tests&quot; * classname=&quot;fitnesse.ant.executefitnesseteststask&quot; * classpathref=&quot;classpath&quot; /&gt; * or * &lt;taskdef classpathref=&quot;classpath&quot; * resource=&quot;tasks.properties&quot; /&gt; * <p/> * &lt;execute-fitnesse-tests * suitepage=&quot;fitnesse.suiteacceptancetests&quot; * fitnesseport=&quot;8082&quot; * resultsdir=&quot;$(results.dir)&quot; * resultshtmlpage=&quot;fit-results.html&quot; * classpathref=&quot;classpath&quot; /&gt; * </pre> */ información no local si tiene que escribir un comentario, asegúrese de que describa el código que le rodea. no ofrezca información global del sistema en el contexto de un comentario local. fíjese en el siguiente comentario javadoc. aparte de su terrible redundancia, también ofrece información sobre el puerto predeterminado y la función no tiene control alguno sobre el puerto predeterminado. el comentario no describe la función sino otra parte distinta 106del sistema. evidentemente, no hay garantías de que el comentario cambie cuando lo haga el código que contiene el valor predeterminado. /** * puerto para ejecutar fitnesse. el predeterminado es <b>8082</b>. * * @param fitnesseport */ public void setfitnesseport(int fitnesseport) { this.fitnesseport = fitnesseport; } demasiada información no incluya en sus comentarios interesantes reflexiones históricas ni irrelevantes descripciones de detalles. el siguiente comentario se ha extraído de un módulo diseñado para probar que una función puede codificar y descodificar base64. aparte del número rfc, el lector de este código no necesita la información obsoleta que contiene el comentario. /* rfc 2045 - extensiones multipropósito de correo de internet (mime) primera parte: formato del cuerpo de los mensajes de internet sección 6.8. codificación de transferencia de contenidos base64 el proceso de codificación representa grupos de 24 bits de la entrada como cadenas de salida de 4 caracteres codificados. procediendo de izquierda a derecha, se forma un grupo de 24 bits de entrada concatenando 3 grupos de 8 bits de entrada. estos 24 bits se tratan como 4 grupos concatenados de 6 bits, cada uno de los cuales se traduce en un solo dígito del alfabeto base64. cuando se codifica un flujo de bits mediante la codificación base64, el flujo de bits se debe considerar ordenado con el bit más significativo primero. esto es, el primer bit del flujo será el bit de orden más alto en el primer byte de 8 bits, y el octavo bit será el de orden más bajo en el primer byte de 8 bits, y así sucesivamente. */ conexiones no evidentes la conexión entre un comentario y el código que describe debe ser evidente. si se ha preocupado de escribir un comentario, lo mínimo es que el lector que lo vea entienda a qué se refiere. fíjese en este comentario obtenido de apache commons: 107/* * comienza con una matriz de tamaño suficiente para albergar todos los pixeles * (más bytes de filtro), y 200 bytes adicionales para la información de encabezado */ this.pngbytes = new byte[((this.width + 1) * this.height * 3) + 200]; ¿qué es un byte de filtro? ¿está relacionado con +1 ? ¿o con *3 ? ¿con ambos? ¿es un pixel un byte ? ¿por qué 200? la función de un comentario es explicar código que no se explica por sí mismo. es una lástima que un comentario requiera su propia explicación. encabezados de función las funciones breves apenas requieren explicación. un nombre bien elegido para una función que hace una cosa suele ser mejor que un encabezado de comentario. javadocs en código no público a pesar de la utilidad de los javadoc para las api públicas, no sirven para código no dirigido a consumo público. la generación de páginas javadoc para clases y funciones de un sistema no suele ser útil y la formalidad adicional de los comentarios javadoc no es más que una distracción. ejemplo escribí el módulo del listado 4-7 para la primera versión de xp immersion . debía ser un ejemplo de estilo incorrecto de creación de código y comentarios. después, kent beck refactorizó este código en algo mucho más atractivo delante de varios alumnos. posteriormente, adapté el ejemplo para mi libro agile software development, principles, patterns, and practices y para el primero de mis artículos craftsman publicados en la revista software development . lo que me fascina de este módulo es que hubo un tiempo en que muchos 108lo hubiéramos considerado bien documentado. ahora vemos que es un auténtico desastre. a ver cuántos problemas detecta en los comentarios. listado 4-7 generateprimes.java. /** * esta clase genera números primos hasta la cantidad máxima especificada por el * usuario. el algoritmo usado es la criba de eratóstenes. * <p> * eratóstenes de cirene, 276 a. c., cirene, libia - * 194 a. c., alejandría. el primer hombre en calcular la * circunferencia de la tierra. también trabajó con calendarios * con años bisiestos y fue responsable de la biblioteca de alejandría. * <p> * el algoritmo es muy simple. dada una matriz de enteros * empezando por el 2, se tachan todos los múltiplos de 2. se busca el siguiente * entero sin tachar y se tachan todos sus múltiplos. * repetir hasta superar la raíz cuadrada del valor * máximo. * * ©author alphonse * ©version 13 feb 2002 atp */ import java.util.*; public class generateprimes { /** * @param maxvalue es el límite de generación. */ public static int[] generateprimes(int maxvalue) { if (maxvalue >= 2) //el único caso válido { // declaraciones int s = maxvalue + 1; // tamaño de la matriz boolean[] f = new boolean[s]; int i; // inicializar la matriz en true. for (i = 0; i < s; i++) f[i] = true; // eliminar los números no primos conocidos f[0] = f[1] = false; // cribar int j; 109for (i = 2; i < math.sqrt(s) + 1; i++) { if (f[i]) // si no está tachado, tachar sus múltiplos. { for (j = 2 * i; j < s; j += i) f[j] = false; // el múltiplo no es primo } } // ¿cuántos primos hay? int count = 0; for (i = 0; i < s; i++) { if (f[i]) count++; // contador. } int[] primes = new int[count]; // enviar primos al resultado for (i = 0, j = 0; i < s; i++) { if (f[i]) // si es primo primes[j++] = i; } return primes; // devolver los primos } else // maxvalue < 2 return new int[0]; // devolver matriz null si la entrada no es correcta. } } en el listado 4-8 puede ver una versión refactorizada del mismo módulo. se ha limitado considerablemente el uso de comentarios. hay sólo dos en todo el módulo y ambos claramente descriptivos. listado 4-8 primegenerator.java (refactorizado). /** * esta clase genera números primos hasta la cantidad máxima especificada por el * usuario. el algoritmo usado es la criba de eratóstenes. dada una matriz de enteros * empezando por el 2: buscar el primer entero sin tachar y tachar todos sus * múltiplos. repetir hasta que no haya más múltiplos en la matriz. */ public class primegenerator { 110private static boolean[] crossedout; private static int[] result; public static int[] generateprimes(int maxvalue) { if (maxvalue < 2) return new int[0]; else { uncrossintegersupto(maxvalue); crossoutmultiples(); putuncrossedintegersintoresult(); return result; } } private static void uncrossintegersupto(int maxvalue) { crossedout = new boolean[maxvalue + 1]; for (int i = 2; i < crossedout.length; i++) crossedout[i] = false; } private static void crossoutmultiples() { int limit = determineiterationlimit(); for (int i = 2; i <= limit; i++) if (notcrossed(i)) crossoutmultiplesof(i); } private static int determineiterationlimit() { // cada múltiplo en la matriz tiene un factor primordial que // es menor o igual que la raíz del tamaño de la matriz, // entonces no tenemos que tachar múltiplos de números // más grande que esa raíz. double iterationlimit = math.sqrt(crossedout.length); return (int) iterationlimit; } private static void crossoutmultiplesof (int i) { for (int multiple = 2 * i; multiple < crossedout.length; multiple += i) crossedout[multiple] = true; } private static boolean notcrossed(int i) { return crossedout[i] == false; } private static void putuncrossedintegersintoresult() 111{ result = new int[numberofuncrossedintegers()]; for (int j = 0, i = 2; i < crossedout.length; i++) if (notcrossed(i)) result[j++] = i; } private static int numberofuncrossedintegers() { int count = 0; for (int i = 2; i < crossedout.length; i++) if (notcrossed(i)) count++; return count; } } se podría decir que el primer comentario es redundante ya que es muy similar a la función generateprimes , pero creo que muestra mejor el algoritmo al lector, motivo por el que lo he mantenido. el segundo argumento es sin duda necesario. explica la lógica del uso de la raíz cuadrada como límite del bucle. no encontré otro nombre de variable más sencillo ni otra estructura de código que lo aclarara más. por otra parte, el uso de la raíz cuadrada podría resultar presuntuoso. ¿realmente se ahorra tanto tiempo limitando la iteración a la raíz cuadrada? ¿el cálculo de la raíz cuadrada llevaría más tiempo del que se ahorra? conviene analizarlo. el uso de la raíz cuadrada como límite de iteración satisface al viejo hacker de c y de lenguajes de ensamblado de mi interior, pero no estoy convencido de que merezca el tiempo y el esfuerzo que los demás puedan dedicar a entenderlo. bibliografía [kp78] : kernighan and plaugher, the elements of programming style , 2d. ed., mcgraw-hill, 1978. 1125 formato cuando los usuarios miran entre bastidores, queremos que queden 113impresionados por el atractivo, la coherencia y la atención al detalle que perciben. queremos que el orden les sorprenda, que abran los ojos con asombro cuando se desplacen por los módulos. queremos que aprecien que se trata de un trabajo de profesionales. si ven una masa amorfa de código que parece escrito por un grupo de marineros borrachos, es probable que piensen que sucederá lo mismo en otros aspectos del proyecto. debe preocuparse por el formato de su código. debe elegir una serie de reglas sencillas que controlen el formato del código y después aplicarlas de forma coherente. si trabaja en equipo, debe acordar una serie de reglas que todos los miembros deben cumplir. también es muy útil usar una herramienta automatizada que se encargue de aplicar las reglas. la función del formato en primer lugar, debe ser claro. el formato de código es importante, demasiado importante como para ignorarlo y también demasiado importante como para tratarlo de forma religiosa. el formato del código se basa en la comunicación y la comunicación debe ser el principal pilar de un desarrollador profesional. puede que piense que conseguir que algo funcione es la principal preocupación de un programador profesional. espero que este libro le haga cambiar de idea. la funcionalidad que cree hoy es muy probable que cambie en la siguiente versión, pero la legibilidad de su código afectará profundamente a todos los cambios que realice. el estilo del código y su legibilidad establecen los precedentes que afectan a la capacidad de mantenimiento y ampliación mucho después de que el código cambie. su estilo y su disciplina sobrevivirán, aunque el código no lo haga. veamos qué aspectos del formato nos permiten comunicarnos mejor. formato vertical comencemos por el tamaño vertical. ¿qué tamaño debe tener un archivo 114fuente? en java, el tamaño de los archivos está relacionado con el tamaño de las clases, como veremos más adelante. por el momento, nos detendremos en el tamaño de los archivos. ¿qué tamaño tienen la mayoría de archivos fuente de java? existe una amplia gama de tamaños e importantes diferencias de estilo, como se aprecia en la figura 5.1. figura 5.1. escala log de distribuciones de longitud de archivos (altura del cuadro = sigma). se describen siete proyectos: junit, fitnesse, testng, time and money, jdepend, ant y tomcat. las líneas que cruzan los cuadros muestran la longitud máxima y mínima de cada proyecto. el cuadro muestra aproximadamente un tercio (una desviación estándar [26] ) de los archivos. la parte central del cuadro es la media. por tanto, el tamaño de archivo medio del proyecto fitnesse es de 65 líneas y un tercio de los archivos ocupan entre 40 y 100+ líneas. el mayor archivo de fitnesse tiene unas 400 líneas y el de menor tamaño, 6. es una escala de registro, de modo que la pequeña diferencia de posición vertical supone una gran diferencia en tamaño absoluto. junit, fitnesse y time and money tienen archivos relativamente pequeños. ninguno supera las 500 líneas y la mayoría tienen menos de 200. tomcat y ant, por su parte, tienen archivos con varios miles de líneas de 115longitud y más de la mitad superan las 200. ¿qué significa todo esto? aparentemente se pueden crear sistemas (fitnesse se aproxima a las 50 000 líneas) a partir de archivos de unas 200 líneas de longitud, con un límite máximo de 500. aunque no debería ser una regla, es un intervalo aconsejable. los archivos de pequeño tamaño se entienden mejor que los grandes. la metáfora del periódico piense en un artículo de periódico bien escrito. en la parte superior espera un titular que indique de qué se trata la historia y le permita determinar si quiere leerlo o no. el primer párrafo ofrece una sinopsis de la historia, oculta los detalles y muestra conceptos generales. al avanzar la lectura, aumentan los detalles junto con todas las fechas, nombres, citas y otros elementos. un archivo de código debe ser como un artículo de periódico. el nombre debe ser sencillo pero claro. por sí mismo, debe bastar para indicarnos si estamos o no en el módulo correcto. los elementos superiores del archivo deben proporcionar conceptos y algoritmos de nivel superior. los detalles deben aumentar según avanzamos, hasta que en la parte final encontremos las funciones de nivel inferior del archivo. un periódico se compone de varios artículos, algunos muy reducidos y otros de gran tamaño. no hay muchos que ocupen toda la página con texto, para que el periódico sea manejable. si el periódico fuera un único y extenso texto con una aglomeración desorganizada de hechos, fechas y nombres, no lo leeríamos. apertura vertical entre conceptos la práctica totalidad del código se lee de izquierda a derecha y de arriba a abajo. cada línea representa una expresión o una cláusula, y cada grupo de líneas representa un pensamiento completo. estos pensamientos deben separarse mediante líneas en blanco. fíjese en el listado 5-1. hay líneas en blanco que separan la declaración 116del paquete, las importaciones y las funciones. es una regla muy sencilla con un profundo efecto en el diseño visual del código. cada línea en blanco es una pista visual que identifica un nuevo concepto independiente. al avanzar por el listado, la vista se fija en la primera línea que aparece tras una línea en blanco. listado 5-1 boldwidget.java package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = “‘‘‘.+?’’’”; private static final pattern pattern = pattern.compile (“‘‘‘(.+?)’’’”, pattern.multiline + pattern.dotall ); public boldwidget(parentwidget parent, string text) throws exception { super(parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group(1)); } public string render() throws exception { stringbuffer html = new stringbuffer(“<b>”); html.append(childhtml()).append (“</b>”); return html.tostring(); } } si eliminamos las líneas en blanco, como en el listado 5-2, se oscurece la legibilidad del código. listado 5-2 boldwidget.java package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = “‘‘‘.+?’’’”; private static final pattern pattern = pattern.compile(“‘‘‘(.+?)’’’”, pattern.multiline + pattern.dotall); public boldwidget(parentwidget parent, string text) throws exception { 117super(parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group(1));} public string render() throws exception { stringbuffer html = new stringbuffer(“<b>”); html.append(childhtml()).append(“</b>”); return html.tostring(); } } este efecto aumenta todavía más si no centramos la vista. en el primer ejemplo, los distintos grupos de líneas saltan a la vista, mientras que en el segundo es una mezcla amorfa. la diferencia entre ambos listados es una ligera apertura vertical. densidad vertical si la apertura separa los conceptos, la densidad vertical implica asociaciones. por tanto, las líneas de código con una relación directa deben aparecer verticalmente densas. fíjese en cómo los comentarios sin sentido del listado 5-3 anulan la asociación entre las dos variables de instancia. listado 5-3 public class reporterconfig { /** * nombre de clase del escuchador */ private string m_classname; /** * propiedades del escuchador */ private list<property> m_properties = new arraylist<property>(); public void addproperty(property property) { m_properties.add(property); } el listado 5-4 es mucho más fácil de leer. lo apreciamos a simple vista o al menos yo lo hago. al mirarlo, veo que es una clase con dos variables y un método, sin tener que mover la cabeza ni la vista. el listado anterior nos 118obliga a forzar la vista y a mover la cabeza para alcanzar el mismo nivel de comprensión. listado 5-4 public class reporterconfig { private string m_classname; private list<property> m_properties = new arraylist<property>(); public void addproperty(property property) { m_properties.add(property); } distancia vertical ¿alguna vez ha tenido que recorrer una clase, saltando de una función a otra, desplazándose por el código para intentar adivinar la relación y el funcionamiento de las funciones, y acabar totalmente confundido? ¿alguna vez ha escudriñado la cadena de herencia buscando la definición de una variable o función? resulta frustrante porque intenta comprender lo que hace el sistema, pero pierde el tiempo y su energía mental en intentar localizar y recordar sus elementos. los conceptos relacionados entre sí deben mantenerse juntos verticalmente [g10]. esta regla no funciona con conceptos de archivos independientes. por lo tanto, no debe separar conceptos relacionados en archivos independientes a menos que tenga un motivo de peso. de hecho, es uno de los motivos por los que se debe evitar el uso de variables protegidas. para los conceptos relacionados que pertenecen al mismo archivo, su separación vertical debe medir su importancia con respecto a la legibilidad del otro. debe evitar que el lector deambule entre archivos y clases. declaraciones de variables las variables deben declararse de la forma más aproximada a su uso. como las funciones son muy breves, las variables locales deben aparecer en la parte superior de cada función, como en este ejemplo de junit4.3.1. 119private static void readpreferences() { inputstream is = null; try { is = new fileinputstream(getpreferencesfile()); setpreferences(new properties(getpreferences())); getpreferences().load(is); } catch (ioexception e) { try { if (is != null) is.close(); } catch (ioexception e1) { } } } las variables de control de bucles deben declararse en la instrucción del bucle, como en esta pequeña función del mismo código fuente: public int counttestcases() { int count= 0; for ( test each : tests) count += each.counttestcases(); return count; } en casos excepcionales, una variable puede declararse en la parte superior de un bloque o antes de un bucle en una función extensa. puede ver este tipo de variable en la siguiente función de testng. … for (xmltest test: m_suite.gettests()) { testrunner tr = m_runnerfactory.newtestrunner(this, test); tr.addlistener(m_textreporter); m_testrunners.add(tr); invoker = tr.getinvoker(); for (itestngmethod m : tr.getbeforesuitemethods()) { beforesuitemethods.put(m.getmethod(), m); } for (itestngmethod m : tr.getaftersuitemethods()) { aftersuitemethods.put(m.getmethod(), m); } } … variables de instancia las variables de instancia, por su parte, deben declararse en la parte superior de la clase. esto no debe aumentar la distancia vertical de las variables, ya 120que en una clase bien diseñada se usan en muchos sino en todos sus métodos. existen discrepancias sobre la ubicación de las variables de instancia. en c++ suele aplicarse la denominada regla de las tijeras, que sitúa todas las variables de instancia en la parte inferior. en java, sin embargo, es habitual ubicarlas en la parte superior de la clase. no veo motivos para no hacerlo. lo importante es declarar las variables de instancia en un punto conocido para que todo el mundo sepa dónde buscarlas. fíjese en el extraño caso de la clase testsuite de junit 4.3.1. he atenuado considerablemente esta clase para ilustrar este concepto. si se fija en la mitad del listado, verá dos variables de instancia declaradas. resultaría complicado ocultarlas en un punto mejor. cualquiera que lea este código tendría que toparse con las declaraciones por casualidad (como me pasó a mí). public class testsuite implements test { static public test createtest(class<? extends testcase> theclass, string name) { … } public static constructor<? extends testcase> gettestconstructor(class<? extends testcase> theclass) throws nosuchmethodexception { … } public static test warning(final string message) { … } private static string exceptiontostring(throwable t) { … } private string fname; private vector<test> ftests = new vector<test>(10); public testsuite() { } public testsuite(final class<? extends testcase> theclass) { … } public testsuite(class<? extends testcase> theclass, string name) { … } 121… … … … } funciones dependientes si una función invoca otra, deben estar verticalmente próximas, y la función de invocación debe estar por encima de la invocada siempre que sea posible. de este modo el programa fluye con normalidad. si la convención se sigue de forma fiable, los lectores sabrán que las definiciones de función aparecen después de su uso. fíjese en el fragmento de fitnesse del listado 5-5. la función superior invoca las situadas por debajo que, a su vez, invocan a las siguientes. esto facilita la detección de las funciones invocadas y mejora considerablemente la legibilidad del módulo completo. listado 5-5 wikipageresponder.java. public class wikipageresponder implements secureresponder { protected wikipage page; protected pagedata pagedata; protected string pagetitle; protected request request; protected pagecrawler crawler; public response makeresponse(fitnessecontext context, request request) throws exception { string pagename = getpagenameordefault(request, “frontpage”); loadpage(pagename, context); if (page == null) return notfoundresponse(context, request); else return makepageresponse(context); } private string getpagenameordefault(request request, string defaultpagename) { string pagename = request.getresource(); if (stringutil.isblank(pagename)) pagename = defaultpagename; return pagename; } protected void loadpage(string resource, fitnessecontext context) throws exception { wikipagepath path = pathparser.parse(resource); 122crawler = context.root.getpagecrawler(); crawler.setdeadendstrategy(new virtualenabledpagecrawler()); page = crawler.getpage(context.root, path); if (page != null) pagedata = page.getdata(); } private response notfoundresponse(fitnessecontext context, request request) throws exception { return new notfoundresponder().makeresponse(context, request); } private simpleresponse makepageresponse(fitnessecontext context) throws exception { pagetitle = pathparser.render(crawler.getfullpath(page)); string html = makehtml(context); simpleresponse response = new simpleresponse(); response.setmaxage(0); response.setcontent(html); return response; } … además, este fragmento es un buen ejemplo de ubicación de constantes en un nivel correcto [g35]. la constante frontpage se podría haber ocultado en la función getpagenameordefault , pero eso habría ocultado una constante conocida y esperada en una función de nivel inferior de forma incorrecta. es mejor pasar la constante desde un punto en el que tiene sentido a la posición en la que realmente se usa. afinidad conceptual determinados conceptos de código deben estar próximos a otros. tienen una afinidad conceptual concreta. cuanto mayor sea esta afinidad, menor distancia vertical debe existir entre ellos. como hemos visto, esta afinidad se puede basar en una dependencia directa, como cuando una función invoca a otra, o cuando usa una variable. pero hay otras causas de afinidad. puede generarse porque un grupo de funciones realice una operación similar. fíjese en este fragmento de código de junit 4.3.1: public class assert { static public void asserttrue(string message, boolean condition) { 123if (!condition) fail(message); } static public void asserttrue(boolean condition) { asserttrue (null, condition); } static public void assertfalse(string message, boolean condition) { asserttrue(message, !condition); } static public void assertfalse(boolean condition) { assertfalse(null, condition); } … estas funciones tienen una elevada afinidad conceptual ya que comparten un sistema de nombres común y realizan variantes de la misma tarea básica. el hecho de que se invoquen unas a otras es secundario. aunque no lo hicieran, deberían seguir estando próximas entre ellas. orden vertical por lo general, las dependencias de invocaciones de funciones deben apuntar hacia abajo. es decir, la función invocada debe situarse por debajo de la que realice la invocación [27] . esto genera un agradable flujo en el código fuente, de los niveles superiores a los inferiores. como sucede en los artículos del periódico, esperamos que los conceptos más importantes aparezcan antes y que se expresen con la menor cantidad de detalles sobrantes. esperamos que los detalles de nivel inferior sean los últimos. de este modo, podemos ojear los archivos de código y captar el mensaje en las primeras funciones sin necesidad de sumergirnos en los detalles. el listado 5-5 se organiza de esta forma. puede que otros ejemplos mejores sean los listados 15-5 y 3-7. formato horizontal 124¿qué ancho debe tener una línea? para responderlo, fíjese en la anchura de las líneas de un programa convencional. de nuevo, examinamos siete proyectos diferentes. en la figura 5.2 puede ver la distribución de longitud de todos ellos. la regularidad es impresionante, en especial en tomo a los 45 caracteres. de hecho, los tamaños entre 20 y 60 representan un uno por cien del número total de líneas. ¡eso es un 40 por 100! puede que otro 30 por 100 sea menos de 10 caracteres de ancho. recuerde que es una escala de registro, de modo que la apariencia lineal es muy significativa. es evidente que los programadores prefieren líneas menos anchas. figura 5.2. distribución de anchura de líneas en java. esto sugiere que debemos intentar reducir las líneas de código. el antiguo límite hollerith de 80 es un tanto arbitrario y no me opongo a líneas que tienen 100 o incluso 120, pero no más. como norma, no debe tener que desplazarse hacia la derecha. los monitores modernos son más anchos y los programadores noveles pueden reducir la fuente para encajar hasta 200 caracteres en la pantalla. no lo haga. mi límite personal es de 120. apertura y densidad horizontal 125usamos el espacio en blanco horizontal para asociar elementos directamente relacionados y separar otros con una relación menos estrecha. fíjese en la siguiente función: private void measureline(string line) { linecount++; int linesize = line.length(); totalchars += linesize; linewidthhistogram.addline(linesize, linecount); recordwidestline(linesize); } hemos rodeado los operadores de asignación con espacios en blanco para destacarlos. las instrucciones de asignación tienen dos elementos principales: el lado izquierdo y el derecho. los espacios acentúan esta separación. por otra parte, no hemos incluido espacios entre los nombres de las funciones y el paréntesis de apertura, ya que la función y sus argumentos están estrechamente relacionados. su separación los desconectaría. separo los argumentos en los paréntesis de invocación de la función para acentuar la coma e indicar que los argumentos son independientes. el espacio en blanco también se usa para acentuar la precedencia de los operadores: public class quadratic { public static double root1(double a, double b, double c) { double determinant = determinant(a, b, c); return (-b + math.sqrt(determinant)) / (2*a); } public static double root2(int a, int b, int c) { double determinant = determinant(a, b, c); return (-b - math.sqrt(determinant)) / (2*a); } private static double determinant(double a, double b, double c) { return b*b - 4*a*c; } } fíjese en lo bien que se leen las ecuaciones. los factores carecen de espacios en blanco ya que tienen una mayor precedencia. los términos se separan mediante espacios en blanco ya que la suma y la resta son de precedencia inferior. desafortunadamente, muchas herramientas de formato de código ignoran la precedencia de los operadores e imponen un espaciado uniforme. por ello, separaciones sutiles como las anteriores suelen perderse tras modificar el 126formato del código. alineación horizontal cuando era programador de lenguajes de ensamblado [28] , usaba la alineación horizontal para acentuar determinadas estructuras. cuando comencé a programar en c, c++ y java, seguía intentando alinear los nombres de variables en un conjunto de declaraciones o todos los valores en un grupo de instrucciones de asignación. el aspecto de mi código era el siguiente: public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long requestprogress; private long requestparsingdeadline; private boolean haserror; public fitnesseexpediter( socket s, fitnessecontext context) throws exception { this.context = context; socket = s; input = s.getinputstream(); output = s.getoutputstream(); requestparsingtimelimit = 10000; } sin embargo, este tipo de alineación no es útil. parece enfatizar los elementos incorrectos y aleja la vista de la verdadera intención. por ejemplo, en la lista anterior de declaraciones, nos vemos tentados a leer la lista de nombres de variables sin fijarnos en sus tipos. del mismo modo, en la lista de instrucciones de asignación, nos fijamos en los valores sin ver el operador. para empeorarlo todo, las herramientas automáticas de formato suelen eliminar este tipo de alineación. por tanto, al final, ya no lo uso. ahora prefiero declaraciones y asignaciones sin alinear, como se muestra a 127continuación, ya que resaltan una deficiencia importante. si tengo listas extensas que deben alinearse, el problema es la longitud de las listas, no la falta de alineación. la longitud de la siguiente lista de declaraciones de fitnesseexpediter sugiere que esta clase debe dividirse. public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long request progress; private long requestparsingdeadline; private boolean haserror; public fitnesseexpediter(socket s, fitnessecontext context) throws exception { this.context = context; socket = s; input = s.getinputstream(); output = s.getoutputstream(); requestparsingtimelimit = 10000; } sangrado un archivo de código es una jerarquía más que un contorno. incluye información que pertenece a la totalidad del archivo, a sus clases individuales, a los métodos de las clases, a los bloques de los métodos y a los bloques de los bloques. cada nivel de esta jerarquía es un ámbito en el que se pueden declarar nombres y en el que se interpretan declaraciones e instrucciones ejecutables. para que esta jerarquía de ámbitos sea visible, sangramos las líneas de código fuente de acuerdo a su posición en la jerarquía. las instrucciones al nivel del archivo, como las declaraciones de clases, no se sangran. los métodos de una clase se sangran un nivel a la derecha de la clase. las implementaciones de dichos métodos se implementan un nivel a la derecha de la declaración de los métodos. las implementaciones de bloques se 128implementan un nivel a la derecha de su bloque contenedor y así sucesivamente. los programadores dependen de este sistema de sangrado. alinean visualmente las líneas a la izquierda para ver el ámbito al que pertenece. de este modo pueden acceder rápidamente a los ámbitos, como por ejemplo a implementaciones de instrucciones if o while , que no son relevantes para la situación actual. buscan en la izquierda nuevas declaraciones de métodos, variables e incluso clases. sin el sangrado, los programas serian prácticamente ilegibles. fíjese en los siguientes programas, sintáctica y semánticamente idénticos: public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket s) { serve(s, 10000); } public void serve(socket s, long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(s, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch(exception e) { e.printstacktrace(); } } } public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket s) { serve (s, 10000); } public void serve(socket s, long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(s, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch (exception e) { e.printstacktrace(); } } } a la vista puede incluso apreciar la estructura del archivo sangrado. detectamos inmediatamente las variables, constructores y métodos de acceso. en cuestión de segundos vemos que es una especie de interfaz de conexión, 129con un tiempo de espera. la versión sin sangrar, por su parte, es prácticamente impenetrable. romper el sangrado en ocasiones tenemos la tentación de romper la regla de sangrado con instrucciones if breves, bucles while breves o funciones breves. siempre que he sucumbido a esta tentación, he acabado por volver a aplicar el sangrado. por ello, evito replegar ámbitos a una línea, como en este ejemplo: public class commentwidget extends textwidget { public static final string regexp = “^#[^\r\n]*(?:(?:\r\n)|\n|\r)?”; public commentwidget(parentwidget parent, string text){super (parent, text);} public string render() throws exception { return “”; } } prefiero desplegar y sangrar los ámbitos: public class commentwidget extends textwidget { public static final string regexp = “^#[^\r\n]*(?:(?:\r\n)|\n|\r)?”; public commentwidget(parentwidget parent, string text) { super(parent, text); } public string render() throws exception { return “”; } } ámbitos ficticios en ocasiones, el cuerpo de una instrucción while o for es ficticio, como se muestra a continuación. no me gustan estas estructuras y prefiero evitarlas. en caso de no poder hacerlo, me aseguro de sangrar el cuerpo ficticio y de incluirlo entre paréntesis. no sabría decir cuántas veces me ha engañado un punto y coma situado al final de un bucle while en la misma línea. a menos que lo haga visible y lo sangre en una línea propia, es difícil de ver. while (dis.read(buf, 0, readbuffersize) != -1) ; 130reglas de equipo todo programador tiene sus reglas de formato preferidas, pero si forma parte de un equipo, el equipo manda. un equipo de programadores debe acordar un único estilo de formato y todos los integrantes del equipo deben aplicarlo. el objetivo es que el software tenga un estilo coherente. no queremos que parezca escrito por individuos enfrentados. cuando comencé el proyecto fitnesse en 2002, me reuní con el equipo para definir un estilo de código. tardamos 10 minutos. decidimos dónde añadir las llaves, qué tamaño de sangrado utilizar, los nombres de clases, variables y métodos, y demás. tras ello, codificamos las reglas en el ide y las cumplimos desde entonces. no son las reglas que prefiero, son las que el equipo decidió. y como miembro de ese equipo, las apliqué cuando creamos el código del proyecto fitnesse. recuerde que un buen sistema de software se compone de una serie de documentos que se leen fácilmente. deben tener un estilo coherente y dinámico. el lector debe confiar en que los formatos que ve en nuestro archivo de código significarán lo mismo para otros. lo último que queremos es aumentar la complejidad del código creando una mezcla de estilos diferentes. reglas de formato de uncle bob las reglas que uso personalmente son sencillas y se ilustran en el código del listado 5-6. considérelo un ejemplo de documento estándar de código óptimo. listado 5-6 131codeanalyzer.java. public class codeanalyzer implements javafileanalysis { private int linecount; private int maxlinewidth; private int widestlinenumber; private linewidthhistogram linewidthhistogram; private int totalchars; public codeanalyzer() { linewidthhistogram = new linewidthhistogram(); } public static list<file> findjavafiles(file parentdirectory) { list<file> files = new arraylist<file>(); findjavafiles(parentdirectory, files); return files; } private static void findjavafiles(file parentdirectory, list<file> files) { for (file file : parentdirectory.listfiles()) { if (file.getname().endswith(“.java”)) files.add(file); else if (file.isdirectory()) findjavafiles(file, files); } } public void analyzefile(file javafile) throws exception { bufferedreader br = new bufferedreader(new filereader(javafile)); string line; while ((line = br.readline()) != null) measureline(line); } private void measureline(string line) { linecount++; int linesize = line.length(); totalchars += linesize; linewidthhistogram.addline(linesize, linecount); recordwidestline(linesize); } private void recordwidestline(int linesize) { if (linesize > maxlinewidth) { maxlinewidth = linesize; widestlinenumber = linecount; } } public int getlinecount() { return linecount; } 132public int getmaxlinewidth() { return maxlinewidth; } public int getwidestlinenumber() { return widestlinenumber; } public linewidthhistogram getlinewidthhistogram() { return linewidthhistogram; } public double getmeanlinewidth() { return (double)totalchars/linecount; } public int getmedianlinewidth() { integer[] sortedwidths = getsortedwidths(); int cumulativelinecount = 0; for (int width : sortedwidths) { cumulativelinecount += linecountforwidth(width); if (cumulativelinecount > linecount/2) return width; } throw new error (“cannot get here”); } private int linecountforwidth(int width) { return linewidthhistogram.getlinesforwidth(width).size(); } private integer[] getsortedwidths() { set<integer> widths = linewidthhistogram.getwidths(); integer[] sortedwidths = (widths.toarray(new integer[0])); arrays.sort(sortedwidths); return sortedwidths; } } 1336 objetos y estructuras de datos 134hay una razón para que las variables sean privadas. no queremos que nadie más dependa de ellas. queremos poder cambiar su tipo o implementación cuando deseemos. entonces, ¿por qué tantos programadores añaden automáticamente métodos de establecimiento y recuperación que muestran sus variables privadas como si fueran públicas? abstracción de datos fíjese en la diferencia entre los listados 6-1 y 6-2. ambos representan los datos de un punto cartesiano, pero uno muestra su implementación y otro la oculta totalmente. listado 6-1 punto concreto. public class point { public double x; public double y; } listado 6-2 punto abstracto. public interface point { double getx(); double gety(); void setcartesian(double x, double y); double getr(); double gettheta(); void set polar(double r, double theta); } lo mejor del listado 6-2 es que no hay forma de saber si la implementación está en coordenadas rectangulares o polares. ¡puede que en ninguna! y aun así la interfaz representa sin lugar a dudas una estructura de datos. pero representa algo más que una estructura de datos. los métodos refuerzan una política de acceso. puede leer las coordenadas de forma 135independiente, pero debe establecerlas de forma conjunta como operación atómica. el listado 6-1, por su parte, se implementa claramente en coordenadas rectangulares y nos obliga a manipularlas de forma independiente, lo que muestra la implementación. de hecho, la mostraría igualmente, aunque las variables fueran privadas y usáramos métodos variables de establecimiento y recuperación. para ocultar la implementación no basta con añadir una capa de funciones entre las variables. se basa en la abstracción. una clase no fuerza sus variables a través de métodos de establecimiento y recuperación. por el contrario, muestra interfaces abstractas que permiten a sus usuarios manipular la esencia de los datos sin necesidad de conocer su implementación. fíjese en los listados 6-3 y 6-4. el primero usa términos concretos para indicar el nivel de combustible de un vehículo mientras que el segundo lo hace con la abstracción del porcentaje. en el caso concreto, podemos estar seguros de que se trata de métodos de acceso de variables. en el caso abstracto, desconocemos la forma de los datos. listado 6-3 vehículo concreto. public interface vehicle { double getfueltankcapacityingallons(); double getgallonsofgasoline(); } listado 6-4 vehículo abstracto. public interface vehicle { double getpercentfuelremaining(); } en ambos casos, la segunda opción es preferible. no queremos mostrar los detalles de los datos, sino expresarlos en términos abstractos. esto no se consigue simplemente mediante interfaces o métodos de establecimiento y recuperación. hay que meditar seriamente la forma óptima de representar los datos que contiene un objeto. la peor opción es añadir métodos de 136establecimiento y recuperación a ciegas. antisimetría de datos y objetos estos dos ejemplos ilustran la diferencia entre objetos y estructuras de datos. los objetos ocultan sus datos tras abstracciones y muestran funciones que operan en dichos datos. la estructura de datos muestra sus datos y carece de funciones con significado. vuelva a leerlos. fíjese en la naturaleza complementaria de las dos definiciones. son virtualmente opuestas. puede parecer una diferencia menor, pero tiene importantes implicaciones. fíjese en el ejemplo del listado 6-5. la clase geometry opera en las tres clases de formas, que son sencillas estructuras de datos sin comportamiento. todo el comportamiento se encuentra en la clase geometry. listado 6-5 forma mediante procedimientos. public class square { public point topleft; public double side; } public class rectangle { public point topleft; public double height; public double width; } public class circle { public point center; public double radius; } public class geometry { public final double pi = 3.141592653589793; public double area(object shape) throws nosuchshapeexception { if (shape instanceof square) { square s = (square)shape; return s.side * s.side; } else if (shape instanceof rectangle) { 137rectangle r = (rectangle)shape; return r.height * r.width; } else if (shape instanceof circle) { circle c = (circle)shape; return pi * c.radius * c.radius; } throw new nosuchshapeexception(); } } los programadores orientados a objetos se quejarán de que es un ejemplo de procedimiento, y tienen razón. imagine qué pasaría si añadimos la función perimeter() a geometry . ¡las clases de formas no se verían afectadas! ¡y las demás clases que dependieran de las formas tampoco! por otra parte, si añado una nueva forma, tendría que cambiar todas las funciones de geometry . vuélvalo a leer. comprobará que las dos condiciones son diametralmente opuestas. fíjese ahora en la solución orientada a objetos del listado 6-6. aquí, el método area() es polimórfico. no se necesita una clase geometry . por tanto, si añado una nueva forma, ninguna de las funciones existentes se ven afectadas, pero si añado otra función, habrá que cambiar todas las formas [29] . listado 6-6 formas polimórficas. public class square implements shape { private point topleft; private double side; public double area() { return side*side; } public class rectangle implements shape { private point topleft; private double height; private double width; public double area() { return height * width; } } public class circle implements shape { private point center; 138private double radius; public final double pi = 3.141592653589793; public double area() { return pi * radius * radius; } } de nuevo, vemos la naturaleza complementaria de estas dos definiciones; totalmente contrarias. esto ilustra la dicotomía fundamental entre objetos y estructuras de datos: el código por procedimientos (el que usa estructuras de datos) facilita la inclusión de nuevas funciones sin modificar las estructuras de datos existentes. el código orientado a objetos, por su parte, facilita la inclusión de nuevas clases sin cambiar las funciones existentes. el complemento también es cierto: el código por procedimientos dificulta la inclusión de nuevas estructuras de datos ya que es necesario cambiar todas las funciones. el código orientado a objetos dificulta la inclusión de nuevas funciones ya que es necesario cambiar todas las clases. por tanto, lo que es difícil para la programación orientada a objetos es fácil para los procedimientos, y viceversa. en cualquier sistema complejo habrá ocasiones en las que queramos añadir nuevos tipos de datos en lugar de nuevas funciones. en dichos casos, los objetos y la programación orientada a objetos es lo más adecuado. por otra parte, en ocasiones tendremos que añadir nuevas funciones en lugar de tipos de datos, para lo que resulta más adecuado usar código por procedimientos y estructuras de datos. los programadores experimentados saben que la idea de que todo es un objeto es un mito. en ocasiones solamente queremos sencillas estructuras de datos con procedimientos que operen en las mismas. 139la ley de demeter existe una conocida heurística denominada ley de demeter [30] que afirma que un módulo no debe conocer los entresijos de los objetos que manipula. como vimos en el apartado anterior, los objetos ocultan sus datos y muestran operaciones, lo que significa que un objeto no debe mostrar su estructura interna a través de métodos de acceso ya que, si lo hace, mostraría, no ocultaría, su estructura interna. en concreto, la ley de demeter afirma que un método de una clase c sólo debe invocar los métodos de: c . un objeto creado por f . un objeto pasado como argumento a f . un objeto en una variable de instancia de c . el método no debe invocar métodos de objetos devueltos por ninguna de las funciones permitidas. es decir, no hable con desconocidos, sólo con amigos. el siguiente código [31] parece incumplir la ley de demeter (entre otras cosas) ya que invoca la función getscratchdir() en el valor devuelto de getoptions() y después invoca getabsolutepath() en el valor devuelto de getscratchdir() . final string outputdir = ctxt.getoptions().getscratchdir().getabsolutepath(); choque de trenes ese tipo de código suele denominarse choque de trenes ya que se asemeja a un grupo de vagones de tren. estas cadenas de invocaciones suelen considerarse un estilo descuidado y deben evitarse [g36]. conviene dividirlas de esta forma: options opts = ctxt.getoptions(); file scratchdir = opts.getscratchdir(); 140final string outputdir = scratchdir.getabsolutepath(); ¿incumplen estos dos fragmentos de código la ley de demeter? sin duda el módulo contenedor sabe que el objeto ctxt contiene opciones, que contienen un directorio scratch , que tiene una ruta absoluta. la función sabe demasiado. la función que realiza la invocación sabe cómo desplazarse por numerosos objetos diferentes. si incumple o no la ley de demeter depende de si ctxt , options y scratchdir son objetos o estructuras de datos. si son objetos, debería ocultarse su estructura interna, no mostrarse, y conocer sus detalles internos sería un claro incumplimiento de la ley de demeter. por otra parte, si ctxt , options y scratchdir son simples estructuras de datos, mostrarán su estructura interna con naturalidad y la ley de demeter no se aplica. el uso de funciones de acceso complica el problema. si el código se hubiera escrito de esta otra forma, probablemente no nos preocuparíamos de si se incumple la ley de demeter o no. final string outputdir = ctxt.options.scratchdir.absolutepath; el problema sería menos confuso si las estructuras de datos tuvieran variables públicas y no funciones, y los objetos tuvieran variables privadas y funciones públicas. sin embargo, existen estructuras y estándares (como los bean ) que exigen que incluso una sencilla estructura de datos tenga elementos de acceso y mutación. híbridos esta confusión genera ocasionalmente desafortunadas estructuras híbridas mitad objeto y mitad estructura de datos. tienen funciones que realizan tareas significativas y también variables públicas o método públicos de acceso y mutación que hacen que las variables privadas sean públicas, y tientan a otras funciones externas a usar dichas variables de la misma forma que un programa por procedimientos usaría una estructura de datos [32] . estos 141híbridos dificultan la inclusión de nuevas funciones y también de nuevas estructuras de datos. son lo peor de ambos mundos. evítelos. indican un diseño descuidado cuyos autores dudan, o peor todavía, desconocen, si necesitan protegerse de funciones o tipos. ocultar la estructura ¿qué pasaría si ctxt , options y scratchdir fueran objetos con un comportamiento real? como los objetos deben ocultar su estructura interna, no podríamos desplazarnos por los mismos. entonces, ¿cómo obtendríamos la ruta absoluta del directorio scratch ? ctxt.getabsolutepathofscratchdirectoryoption(); o ctxt.getscratchdirectoryoption().getabsolutepath() la primera opción provocaría una explosión de métodos en el objeto ctxt . la segunda asume que getscratchdirectoryoption() devuelve una estructura de datos, no un objeto. ninguna de las opciones parece correcta. si ctxt es un objeto, deberíamos indicarle que hiciera algo, no preguntar sobre sus detalles internos. entonces, ¿para qué queremos la ruta absoluta del directorio scratch ? ¿cómo vamos a usarla? fíjese en este código del mismo módulo (muchas líneas después): string outfile = outputdir + “/” + classname.replace(‘.’, ‘/’) + “.class”; fileoutputstream fout = new fileoutputstream(outfile); bufferedoutputstream bos = new bufferedoutputstream(fout); la mezcla de distintos niveles de detalle [g34][g6] es preocupante. puntos, guiones, extensiones de archivo y objetos file no deben mezclarse de esta forma, junto al código contenedor. si lo ignoramos, vemos que la intención de obtener la ruta absoluta del directorio scratch es crear un archivo de borrador de un nombre concreto. ¿y si le dijéramos al objeto ctxt que hiciera esto? bufferedoutputstream bos = ctxt.createscratchfilestream(classfilename); parece algo razonable para un objeto. permite a ctxt ocultar sus detalles internos e impide que la función actual incumpla la ley de demeter y se 142desplace por objetos que no debería conocer. objetos de transferencia de datos la quintaesencia de una estructura de datos es una clase con variables públicas y sin funciones. en ocasiones se denomina objeto de transferencia de datos ( data transfer object u otd). los otd son estructuras muy útiles, en especial para comunicarse con bases de datos o analizar mensajes de conexiones, etc. suelen ser los primeros de una serie de fases de traducción que convierten datos sin procesar en objetos en el código de la aplicación. más común es la forma de bean mostrada en el listado 6-7. los bean tienen variables privadas manipuladas por métodos de establecimiento y recuperación. la cuasi-encapsulación de bean hace que algunos puristas de la programación orientada a objetos se sientan mejor pero no ofrece ningún otro beneficio. listado 6-7 address.java public class address { private string street; private string streetextra; private string city; private string state; private string zip; public address(string street, string streetextra, string city, string state, string zip) { this.street = street; this.streetextra = streetextra; this.city = city; this.state = state; this.zip = zip; } public string getstreet() { return street; } public string getstreetextra() { return streetextra; } 143public string getcity() { return city; } public string getstate() { return getstate; } public string getzip() { return zip; } } registro activo los registros activos son una forma especial de otd. son estructuras de datos con variables públicas (o de acceso por bean) pero suelen tener métodos de navegación como save y find . por lo general, estos registros activos son traducciones directas de tablas de base de datos u otros orígenes de datos. desafortunadamente, muchos programadores intentan procesar estas estructuras de datos como si fueran objetos y les añaden métodos de reglas empresariales. es algo extraño ya que crea un híbrido entre una estructura de datos y un objeto. la solución, evidentemente, consiste en considerar al registro activo una estructura de datos y crear objetos independientes que contengan las reglas empresariales y que oculten sus datos internos (que probablemente sean instancias del propio registro activo). conclusión los objetos muestran comportamiento y ocultan datos. esto facilita la inclusión de nuevos tipos de objetos sin necesidad de cambiar los comportamientos existentes. también dificulta la inclusión de nuevos comportamientos en objetos existentes. las estructuras de datos muestran datos y carecen de comportamiento significativo. esto facilita la inclusión de nuevos comportamientos en las estructuras de datos existentes, pero dificulta la inclusión de nuevas estructuras de datos en funciones existentes. 144en un sistema, en ocasiones necesitaremos la flexibilidad de añadir nuevos tipos de datos, por lo que preferimos objetos para esa parte del sistema. en otros casos, querremos añadir nuevos comportamientos, para lo que preferimos tipos de datos y procedimientos en esa parte del sistema. los buenos programadores de software entienden estos problemas sin prejuicios y eligen el enfoque más adecuado para cada tarea concreta. bibliografía [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. 1457 procesar errores por michael feathers le parecerá extraño encontrar una sección de control de errores en un libro sobre código limpio. el control de errores es algo que todos tenemos que hacer al programar. las entradas pueden ser incorrectas y los dispositivos pueden fallar, y cuando lo hacen, los programadores somos responsables de comprobar que el código hace lo que debe hacer. no obstante, la conexión con el código limpio debe ser evidente. muchas bases de código están totalmente dominadas por el control de errores. cuando digo que están dominadas, no quiero decir que únicamente realicen control de 146código, sino que es prácticamente imposible ver lo que el código hace debido a todo ese control de errores. el control de errores es importante, pero si oscurece la lógica, es incorrecto . en este capítulo detallaremos diversas técnicas y consideraciones que puede usar para crear código limpio y robusto, código que procese los errores con elegancia y estilo. usar excepciones en lugar de códigos devueltos en el pasado, muchos lenguajes carecían de excepciones. las técnicas para procesar e informar de errores eran limitadas. se definía un indicador de error o se devolvía un código de error que el invocador podía comprobar. el código del listado 7-1 ilustra estos enfoques. listado 7-1 devicecontroller.java. public class devicecontroller { … public void sendshutdown() { devicehandle handle = gethandle(dev1); // comprobar el estado del dispositivo if (handle != devicehandle.invalid) { // guardar el estado del dispositivo en el campo de registro retrievedevicerecord(handle); // si no está suspendido, cerrarlo if { record.getstatus() != device_suspended) { pausedevice(handle); cleardeviceworkqueue(handle); closedevice(handle); } else { logger.log(“device suspended. unable to shut down”); } } else { logger.log(“invalid handle for: ” + dev1.tostring()); } } … } el problema de estos enfoques es que confunden al invocador. el invocador debe comprobar inmediatamente los errores después de la 147invocación. desafortunadamente, es algo que se suele olvidar. por ello, es más recomendable generar una excepción al detectar un error. el código de invocación es más limpio. su lógica no se oscurece por el control de errores. el listado 7-2 muestra el código tras generar una excepción en los métodos que pueden detectar errores. listado 7-2 devicecontroller.java (con excepciones). public class devicecontroller { … public void sendshutdown() { try { trytoshutdown(); } catch (deviceshutdownerror e) { logger.log(e); } } private void trytoshutdown() throws deviceshutdownerror { devicehandle handle = gethandle(dev1); devicerecord record = retrievedevicerecord(handle); pausedevice(handle); cleardeviceworkqueue(handle); closedevice(handle); } private devicehandle gethandle(deviceid id) { … throw new deviceshutdownerror(“invalid handle for: ” - id.tostring()); … } … } comprobará que es mucho más limpio. no es cuestión de estética. el código es mejor porque se solventan dos preocupaciones: el algoritmo para apagar el dispositivo y el control de errores ahora se encuentran separados. puede ver cada uno de ellos y entenderlos de forma independiente. crear primero la instrucción try-catch-finally 148uno de los aspectos más interesantes de las excepciones es que definen un ámbito en el programa. al ejecutar código en la parte try de una instrucción try-catch-finally , indicamos que la ejecución se puede cancelar en cualquier momento y después retomar en catch . los bloques try son como las transacciones, catch debe salir del programa en un estado coherente, independientemente de lo que suceda en try . por este motivo, es aconsejable iniciar con una instrucción try-catch- finally el código que genere excepciones. de este modo define lo que debe esperar el usuario del código, independientemente de que se produzca un error en el código ejecutado en la cláusula try . veamos un ejemplo. imagine que tiene que crear un código que acceda a un archivo y lea objetos serializados. comenzamos con una prueba de unidad que muestra que obtendremos una excepción cuando el archivo no exista: @test(expected = storageexception.class) public void retrievesectionshouldthrowoninvalidfilename() { sectionstore.retrievesection(“invalid - file”); } la prueba nos lleva a crear lo siguiente: public list<recordedgrip> retrievesection(string sectionname) { // se devuelve un resultado ficticio hasta tener una implementación real return new arraylist<recordedgrip>(); } nuestra prueba falla ya que no genera una excepción. tras ello, cambiamos la implementación para que intente acceder a un archivo no válido. esta operación genera una excepción: public list<recordedgrip> retrievesection (string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname) } catch (exception e) { throw new storageexception(“retrieval error”, e); } return new arraylist<recordedgrip>(); } ahora la prueba es correcta ya que capturamos la excepción y ya podemos refactorizar. podemos reducir el tipo de la excepción capturada para que coincida con el tipo generado desde el constructor fileinputstream: 149filenotfoundexception : public list<recordedgrip> retrievesection(string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname); stream.close(); } catch (filenotfoundexception e) { throw new storageexception(“retrieval error”, e); } return new arraylist<recordedgrip>(); } ahora que hemos definido el ámbito con una estructura try-catch , podemos usar tdd para diseñar el resto de la lógica necesaria. dicha lógica se añade entre la creación de fileinputstream y el cierre, y podemos pretender que no pasa nada incorrecto. intente crear pruebas que fuercen las excepciones, para después añadir al controlador un comportamiento que satisfaga dichas pruebas. de este modo primero creará el ámbito de transacción del bloque try y podrá mantener la naturaleza de transacción del ámbito. usar excepciones sin comprobar el debate ha terminado. durante años, los programadores de java han debatido las ventajas y los problemas de las excepciones comprobadas. cuando aparecieron en la primera versión de java, parecían una gran idea. la firma de todos los métodos enumeraría todas las excepciones que se podían pasar a su invocador. es más, estas excepciones formaban parte del tipo del método. el código no se compilaría si la firma no coincidía con lo que el código iba a hacer. en aquel momento, pensábamos que las excepciones comprobadas eran una gran idea y sí, ofrecían ciertas ventajas. sin embargo, ahora es evidente que no se necesitan para crear software robusto. c# carece de excepciones comprobadas y, a pesar de los intentos, c++ tampoco, como sucede en python o ruby. y en todos estos lenguajes se puede crear software robusto. por ello, debemos decidir si las excepciones comprobadas valen su precio. ¿qué precio? el precio de las excepciones comprobadas es un 150incumplimiento del principio abierto/cerrado [33] . si genera una excepción comprobada desde un método de su código y la cláusula catch se encuentra tres niveles por debajo, debe declarar dicha excepción en la firma de todos los métodos comprendidos entre su posición y catch . esto significa que un cambio en un nivel inferior del software puede forzar cambios de firma en muchos niveles superiores. será necesario volver a generar e implementar los módulos cambiados, aunque no cambien los elementos a los que hacen referencia. piense en la jerarquía de invocación de un sistema. las funciones de la parte superior invocan a las funciones situadas debajo, que invocan a otras funciones inferiores y así sucesivamente. imagine que una de las funciones de nivel inferior se modifica de forma que debe generar una excepción. si la excepción se comprueba, la firma de la función tendrá que añadir una cláusula throws . pero esto significa que todas las funciones que invoquen nuestra función modificada también tendrán que cambiarse para capturar la nueva excepción o para añadir la correspondiente cláusula throws en su firma. y así indefinidamente. el resultado final es una cascada de cambios que pasan desde los niveles inferiores del software hasta los superiores. la encapsulación se rompe ya que todas las funciones en la ruta de throw deben conocer detalles de la excepción de nivel inferior. como el cometido de las excepciones es permitimos procesar errores a distancia, es una lástima que las excepciones comprobadas rompan la encapsulación de esta forma. las excepciones comprobadas pueden ser útiles si tiene que crear una biblioteca crítica: tendrá que capturarlas. pero en el desarrollo de aplicaciones generales, los costes de dependencia superan las ventajas. ofrecer contexto junto a las excepciones las excepciones que genere deben proporcionar el contexto adecuado para determinar el origen y la ubicación de un error. en java, puede obtener un rastreo de pila de cualquier excepción; sin embargo, no le indicará el cometido de la función fallida. redacte mensajes de error informativos y páselos junto a sus 151excepciones. mencione la operación fallida y el tipo de fallo. si guarda registros en su aplicación, incluya información suficiente para poder registrar el error en la cláusula catch . definir clases de excepción de acuerdo a las necesidades del invocador existen varias formas de clasificar los errores. podemos hacerlo por origen (¿provienen de uno u otro componente?) o por tipo (¿son fallos del dispositivo, de la red o errores de programación?). sin embargo, al definir clases de excepción en una aplicación, debemos preocuparnos principalmente en cómo se capturan . veamos un pobre ejemplo de clasificación de excepciones. es una instrucción try-catch-finally de la invocación de una biblioteca de terceros. abarca todas las excepciones que las invocaciones pueden generar: acmeport port = new acmeport(12); try { port.open(); } catch (deviceresponseexception e) { reportporterror(e); logger.log{“device response exception”, e); } catch (atm1212unlockedexception e) { reportporterror(e); logger.log(“unlock exception”, e); } catch (gmxerror e) { reportporterror(e); logger.log(“device response exception”); } finally { … } esta instrucción contiene elementos duplicados, algo que no debería sorprendernos. en muchos casos de control de excepciones, el trabajo que realizamos es relativamente estándar independientemente de la causa real. debemos registrar un error y asegurarnos de poder continuar. en este caso, como sabemos que el trabajo es el mismo independientemente de la excepción, podemos simplificar el código si incluimos la api invocada y nos aseguramos de que devuelve un tipo de 152excepción común: localport port = new localport(12); try { port.open(); } catch (portdevicefailure e) { reporterror(e); logger.log(e.getmessage(), e); } finally { … } nuestra clase localport es un simple envoltorio que captura y traduce excepciones generadas por la clase acmeport : public class localport { private acmeport innerport; public localport(int portnumber) { innerport = new acmeport(portnumber); } public void open() { try { innerport.open(); } catch (deviceresponseexception e) { throw new portdevicefailure(e); } catch (atm1212unlockedexception e) { throw new portdevicefailure(e); } catch (gmxerror e) { throw new portdevicefailure(e); } } … } los envoltorios como el definido para acmeport pueden ser muy útiles. de hecho, es recomendable envolver api de terceros. al hacerlo, se minimizan las dependencias: puede cambiar a otra biblioteca diferente sin apenas problemas y el envoltorio también facilita imitar invocaciones de terceros cuando se prueba el código. una última ventaja es que no estamos limitados a las decisiones de diseño de api de un determinado fabricante. puede definir una api que le resulte cómoda. en el ejemplo anterior, definimos un único tipo de excepción para el fallo de puertos y podemos escribir un código mucho más limpio. a menudo, una única clase de excepción es suficiente para una zona concreta del código. la información enviada con la excepción puede distinguir los errores. use clases diferentes 153sólo para capturar una excepción y permitir el paso de otra distinta. definir el flujo normal si sigue los consejos de apartados anteriores, realizará una importante separación entre la lógica empresarial y el control de errores. la mayoría de su código parecerá un algoritmo limpio y sin adornos. sin embargo, el proceso desplaza la detección de errores hacia los bordes del programa. debe envolver api externas para poder generar sus propias excepciones y definir un controlador por encima del código para poder procesar cálculos cancelados. en muchos casos es el enfoque más acertado, pero en ocasiones conviene no cancelar. veamos un ejemplo, un código extraño que suma gastos en una aplicación de facturación: try { mealexpenses expenses = expensereportdao.getmeals(employee.getid()); m_total += expenses.gettotal(); } catch(mealexpensesnotfound e) { m_total += getmealperdiem(); } en esta empresa, si las comidas son gastos, pasan a formar parte del total. si no lo son, los trabajadores reciben una cantidad diaria para la comida. la excepción entorpece la lógica. sería más adecuado no tener que procesar el caso especial y el código sería mucho más sencillo: mealexpenses expenses = expensereportdao.getmeals(employee.getid()); m_total += expenses.gettotal(); ¿de verdad que el código puede ser tan simple? pues sí. podemos cambiar expensereportdao para que siempre devuelva un objeto mealexpense . si no hay gastos de comida, devuelve un objeto mealexpense que devuelve la dieta diaria como total: public class perdiemmealexpenses implements mealexpenses { public int gettotal() { // devolver la dieta diaria predeterminada 154} } es lo que se denomina patrón de caso especial [fowler]. se crea una clase o se configura un objeto que procese un caso especial. al hacerlo, el código cliente no tiene que procesar comportamientos excepcionales. dichos comportamientos se encapsulan en un objeto de caso especial. no devolver null creo que toda descripción del control de errores debe mencionar los elementos proclives a errores. el primero es devolver null. he perdido la cuenta de la cantidad de aplicaciones en que las que línea sí y línea también se comprueba null: public void registeritem(item item) { if (item != null) { itemregistry registry = peristentstore.getitemregistry(); if (registry != null) { item existing = registry.getitem(item.getid()); if (existing.getbillingperiod().hasretailowner()) { existing.register(item); } } } } si trabaja en una base de código como ésta, puede que no le parezca tan mala, pero lo es. al devolver null , básicamente nos creamos trabajo y generamos problemas para los invocadores. basta con que falte una comprobación de null para que la aplicación pierda el control. ¿se ha fijado en que no hay una comprobación de null en la segunda línea de la instrucción if anidada? ¿qué sucedería en tiempo de ejecución si persistentstore fuera null ? se generaría nullpointerexception en tiempo de ejecución y se capturaría nullpointerexception en el nivel superior o no. en ambos casos es incorrecto. ¿qué debería hace como respuesta a la generación de nullpointerexception desde el interior de su aplicación? se puede afirmar que el problema de este código es la ausencia de una comprobación de null pero en realidad el problema es su exceso. si 155siente la tentación de devolver null desde un método, pruebe a generar una excepción o a devolver un objeto de caso especial. si invoca un método que devuelva null desde una api de terceros, envuélvalo en un método que genere una excepción o devuelva un objeto de caso especial. en muchos casos, los objetos de caso especial son un remedio sencillo. imagine que tiene el siguiente código: list<employee> employees = getemployees(); if (employees != null) { for(employee e : employees) { totalpay += e.getpay(); } } ahora, getemployees puede devolver null , ¿pero es necesario? si cambiamos getemployee para que devuelva una lista vacía, podremos limpiar el código: list<employee> employees = getemployees(); for(employee e : employees) { totalpay += e.getpay(); } afortunadamente, java dispone de collections.emptylist() y devuelve una lista inmutable predefinida que podemos usar para este cometido: public list<employee> getemployees() { if (… there are no employees …) return collections.emptylist(); } si usa este tipo de código, minimizará la presencia de nullpointerexception y su código será más limpio. no pasar null devolver null desde métodos es incorrecto, pero es peor pasar null a métodos. a menos que trabaje con una api que espere que pase null , debe evitarlo siempre que sea posible. veamos otro ejemplo, un sencillo método que calcula una métrica para dos puntos: public class metricscalculator 156{ public double xprojection(point p1, point p2) { return (p2.x – p1.x) * 1.5; } … } ¿qué sucede cuando alguien pasa null como argumento? calculator.xprojection(null, new point (12, 13)); se genera nullpointerexception , evidentemente. ¿cómo solucionarlo? podríamos crear un nuevo tipo de excepción y generarla: public class metricscalculator { public double xprojection(point p1, point p2) { if (p1==null || p2==null) { throw invalidargumentexception( “invalid argument for metricscalculator.xprojection”); } return (p2.x – p1.x) * 1.5; } } } ¿mejor? puede que sea mejor que una excepción de puntero nulo, pero recuerde que debe definir un controlador para invalidargumentexception . ¿qué debe hacer el controlador? ¿hay alguna forma correcta de hacerlo? existe otra alternativa, usar un grupo de afirmaciones: public class metricscalculator ( public double xprojection{point p1, point p2) { assert p1 != null : “p1 should not be null”; assert p2 != null : “p2 should not be null”; return (p2.x - pl.x) * 1.5; } } es documentación correcta pero no soluciona el problema. si alguien pasa null , seguirá produciéndose un error de tiempo de ejecución. en la mayoría de lenguajes de programación no hay una forma correcta de procesar un null pasado por accidente. como éste es el caso, el enfoque racional es impedir que se pase null de forma predeterminada. si lo hace, puede diseñar código sabiendo que null en una lista de argumentos indica un problema y los errores serán menores. 157conclusión el código limpio es legible pero también debe ser robusto. no son objetivos opuestos. podemos crear código limpio y robusto si consideramos el control de errores una preocupación diferente, algo que vemos de forma independiente desde nuestra lógica principal. si somos capaces de lograrlo, razonaremos de forma independiente y podemos aumentar la capacidad de mantenimiento de nuestro código. bibliografía [martin] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. 1588 límites por james grenning no es habitual que controlemos todo el software de nuestros sistemas. en ocasiones, adquirimos paquetes de terceros o usamos código abierto. en otros casos, dependemos de equipos de nuestra propia empresa para producir 159componentes o subsistemas que utilizamos. de algún modo debemos integrar este código externo con el nuestro. en este capítulo veremos prácticas y técnicas para definir con claridad los límites de nuestro software . utilizar código de terceros existe una tensión natural entre el proveedor de una interfaz y el usuario de la misma. los proveedores de paquetes y estructuras de terceros abogan por una capacidad de aplicación global para poder trabajar en diversos entornos y atraer a un público más amplio. los usuarios, por su parte, desean una interfaz centrada en sus necesidades concretas. esta tensión puede provocar problemas en los límites de nuestros sistemas. analicemos java.util.map como ejemplo. como puede apreciar en la siguiente lista. map tiene una amplia interfaz con numerosas prestaciones. esta potencia y flexibilidad es muy útil, pero también puede ser un problema. por ejemplo, nuestra aplicación puede generar un map y compartirlo. nuestra intención puede que sea que ninguno de los receptores del mapa borre sus elementos. pero en la parte superior de la lista encontramos el método clear() . cualquier usuario del mapa puede borrarlo. o puede que nuestra convención de diseño determine que sólo se puedan almacenar objetos concretos en el mapa, pero map no limita de forma fiable los tipos de objetos que admite. cualquier usuario puede añadir elementos de cualquier tipo a cualquier mapa. clear() void - map containskey (object key) boolean - map containsvalue (object value) boolean - map entryset() set - map equals(object o) boolean - map get(object key) object - map getclass() class<? extends object> - object hashcode() int - map isempty() boolean - map keyset() set - map notify() void - object 160notifyall() void - object put(object key, object value) object - map putall(map t) void - map remove(object key) object - map size() int - map tostring() string - object values() collection - map wait() void - object wait(long timeout) void - object wait(long timeout, int nanos) void - object figura 8.1. los métodos de map si nuestra aplicación necesita un mapa de sensor , comprobará que los sensores se definen de esta forma: map sensors = new hashmap(); tras ello, cuando otra parte del código necesite acceder a sensor, vemos este código: sensor s = (sensor)sensors.get(sensorid); no lo vemos una sola vez, sino repetidamente a lo largo del código. el cliente de este código es responsable de obtener un objeto de map y convertirlo al tipo correcto. funciona, pero no es código limpio. además, este código no cuenta su historia como debería. la legibilidad del código se podría mejorar mediante el uso de genéricos, como se indica a continuación: map<sensor> sensors = new hashmap<sensor>(); … sensor s = sensors.get(sensorid); sin embargo, esto no soluciona el problema de que map<sensor> ofrezca más prestaciones de las que necesitamos o deseamos. al pasar una instancia de map<sensor> en el sistema, significa que habrá muchos puntos que corregir si la interfaz de map cambia. seguramente piense que son cambios improbables, pero recuerde que se han producido al añadir compatibilidad con genéricos en java 5. sin duda hemos visto sistemas que impiden el uso de genéricos debido a la gran cantidad de cambios necesarios para compensar el uso liberal de map . una forma más limpia de usar map sería la siguiente. a ningún usuario 161sensor le importa si se usan genéricos o no. esa opción se ha convertido (y siempre debería serlo) en un detalle de implementación. public class sensors { private map sensors = new hashmap(); public sensor getbyid(string id) { return (sensor) sensors.get(id); } //corte } la interfaz en el límite (map) está oculta. ha conseguido evolucionar sin apenas impacto en el resto de la aplicación. el uso de genéricos ya no es un problema ya que la conversión y la administración de tipos se procesa dentro de la clase sensors . esta interfaz también se ha ajustado y limitado a las necesidades de la aplicación. genera código más fácil de entender y con menor probabilidad de errores. la clase sensors puede aplicar las reglas empresariales y de diseño. no sugerimos que se encapsulen de esta forma todos los usos de map, sino que no se pase map (ni otras interfaces en el límite) por el sistema. si usa una interfaz de límite como map , manténgala dentro de la clase o la familia de clases en la que se use. evite devolverla o aceptarla como argumento de api públicas. explorar y aprender límites el código de terceros nos permite obtener mayor funcionalidad en menos tiempo. ¿por dónde empezamos cuando queremos utilizar un paquete de terceros? nuestra labor no es probar el código, pero sí crear pruebas para el código de terceros que utilicemos. imagine que no es evidente cómo usar una biblioteca de terceros. podríamos perder uno o varios días en leer la documentación y decidir cómo usarla. tras ello, podríamos escribir el código para usar el código de terceros y comprobar si se comporta de la forma esperada. no deberíamos sorprendernos por tener que realizar extensas sesiones de depuración intentando localizar errores en nuestro código o en el suyo. 162aprender el código de terceros es complicado, y también integrarlo. hacer ambas cosas al mismo tiempo es el doble de complicado. necesitamos un enfoque diferente. en lugar de experimentar y probar el nuevo material en nuestro código de producción, podríamos crear pruebas que analicen nuestro entendimiento del código de terceros. jim newkirk las denomina pruebas de aprendizaje [34] . en las pruebas de aprendizaje, invocamos la api de terceros como supuestamente la usaríamos en nuestra aplicación. básicamente realizamos experimentos controlados para comprobar si la entendemos. las pruebas se centran en lo que queremos obtener de la api. aprender log4j imagine que desea usar el paquete de apache log4j en lugar de su propio dispositivo de registro personalizado. lo descarga y abre la página inicial de la documentación. sin una lectura exhaustiva, crea el primer caso de prueba con la esperanza de que escriba hello en la consola. @test public void testlogcreate() { logger logger = logger.getlogger(“mylogger”); logger.info(“hello”); } al ejecutarlo, el registrador genera un error que nos indica que necesitamos algo denominado appender . tras investigar, descubrimos que existe un elemento consoleappender . creamos consoleappender y comprobamos si hemos conseguido revelar los secretos del registro en la consola. @test public void testlogaddappender() { logger logger = logger.getlogger (“mylogger”); consoleappender appender = new consoleappender(); logger.addappender(appender); logger.info(“hello”); } en esta ocasión descubrimos que appender carece de flujo de salida, algo extraño, ya que parece lógico que lo tuviera. tras recurrir a google, 163probamos lo siguiente: @test public void testlogaddappender() { logger logger = logger.getlogger(“mylogger”); logger.removeallappenders(); logger.addappender(new consoleappender( new patternlayout(“%p %t %m%n”), consoleappender.system_out)); logger.info(“hello”); } funciona; en la consola aparece un mensaje con la palabra hello . resulta extraño tener que indicarle a consoleappender que escriba en la consola. al eliminar el argumento consoleappender.systemout , vemos que hello sigue impreso. pero al eliminar patternlayout , de nuevo vemos la queja de la falta de un flujo de salida. es un comportamiento muy extraño. si nos fijamos en la documentación, vemos que el constructor consoleappender predeterminado no está configurado, lo que no parece demasiado obvio ni útil. parece más bien un error o una incoherencia de log4j . tras nuevas búsquedas en google, investigaciones y pruebas, conseguimos el listado 8-1. hemos descubierto cómo funciona log4j y hemos codificado esos conocimientos en un grupo de sencillas pruebas de unidad. listado 8-1 logtest.java. public class logtest ( private logger logger; @before public void initialize() { logger = logger.getlogger(“logger”); logger.removeallappenders(); logger.getrootlogger().removeallappenders(); } @test public void basiclogger() { basicconfigurator.configure(); logger.info(“basiclogger”); } 164@test public void addappenderwithstream() { logger.addappender(new consoleappender( new patternlayout (“%p %t %m%n”), consoleappender.system_out)); logger.info(“addappenderwithstream”); } @test public void addappenderwithoutstream() { logger.addappender(new consoleappender( new patternlayout(“%p %t %m%n”))); logger.info(“addappenderwithoutstream”); } } ahora sabemos cómo inicializar un sencillo registrador de consola y encapsular ese conocimiento en nuestra propia clase de registro para que el resto de la aplicación se aísle de la interfaz de límite log4j . las pruebas de aprendizaje son algo más que gratuitas las pruebas de aprendizaje no cuestan nada. de todas formas, hemos tenido que aprender la api y crear las pruebas fue una forma sencilla y aislada de adquirir esos conocimientos. las pruebas de aprendizaje fueron experimentos precisos que permitieron aumentar nuestros conocimientos. las pruebas no sólo son gratuitas, sino también rentables. cuando aparezcan nuevas versiones del paquete de terceros, ejecutamos las pruebas de aprendizaje para comprobar si hay diferencias de comportamiento. las pruebas de aprendizaje demuestran que los paquetes de terceros que usamos funcionan de la forma esperada. una vez integrados, no hay garantía de que el código de terceros sea compatible con nuestras necesidades. los autores originales se verán presionados para cambiar el código y ajustarlo a sus propias necesidades. corregirán errores y añadirán nuevas funciones. en cada versión surgirán nuevos riesgos. si el paquete de terceros cambia de una forma incompatible con nuestras pruebas, lo sabremos al instante. independientemente de que necesite los conocimientos proporcionados por las pruebas de aprendizaje, un límite claro debe estar respaldado por un conjunto de pruebas que ejerciten la interfaz de la misma forma que hace el 165código de producción. sin estas pruebas de límites para facilitar la transición, podríamos conservar la versión antigua más tiempo del necesario. usar código que todavía no existe existe otro tipo de límite, que separa lo conocido de lo desconocido. en ocasiones, nuestro conocimiento del código parece desvanecerse. lo que hay al otro lado del límite es desconocido (al menos por el momento). en ocasiones, decidimos no mirar más allá del límite. hace años formé parte de un equipo de desarrollo de software para un sistema de comunicación por radio. había un subsistema, el transmisor, que apenas conocíamos y cuya interfaz todavía no se había diseñado. como no queríamos quedarnos parados, comenzamos a trabajar alejándonos de la parte desconocida del código. sabíamos perfectamente dónde acababa nuestro mundo y comenzaba el nuevo. mientras avanzábamos, en ocasiones nos topábamos con este límite. aunque la ignorancia ocultaba nuestra visión más allá del límite, sabíamos cómo queríamos que fuera la interfaz. queríamos decirle al transmisor algo como lo siguiente: ajustar el transmisor en la frecuencia proporcionada y emitir una representación analógica de los datos que provienen de este flujo. no sabíamos cómo hacerlo ya que todavía no se había diseñado la api. por ello decidimos determinar después los detalles. para no quedarnos bloqueados, definimos nuestra propia interfaz. le dimos un nombre sencillo, transmitter . le asignamos el método transmit que aceptaba una frecuencia y un flujo de datos. es la interfaz que deseábamos haber tenido. lo mejor de escribir la interfaz que deseábamos haber tenido era que la controlábamos. esto hace que el código cliente sea más legible y se ciña a los objetivos previstos. en la figura 8.1 se aprecia que aislamos las clases 166communicationscontroller de la api del transmisor (que no controlábamos y estaba por definir). al usar nuestra propia interfaz específica de la aplicación, el código de communicationscontroller era limpio y expresivo. una vez definida la api del transmisor, creamos transmitteradapter para reducir las distancias. el adaptador [35] encapsulaba la interacción con la api y ofrecía un único punto en el que evolucionaba. figura 8.1. predicción del transmisor este diseño también nos ofrece un sello [36] en el código para realizar pruebas. con un elemento faketransmitter , podemos probar las clases communicationscontroller . también podemos crear pruebas de límite una vez diseñada la api transmitter para asegurarnos de que la utilizamos correctamente. límites limpios en los límites suceden cosas interesantes. los cambios es una de ellas. los diseños de código correctos acomodan los cambios sin necesidad de grandes modificaciones. cuando usamos código que no controlamos, hay que prestar especial atención a proteger nuestra inversión y asegurarnos de que los cambios futuros no son demasiado costosos. el código en los límites requiere una separación evidente y pruebas que definan expectativas. debemos evitar que el código conozca los detalles de terceros. es más aconsejable depender de algo que controlemos que de algo que no controlemos, y menos todavía si nos controla. los límites de terceros se gestionan gracias a la presencia de 167puntos mínimos en el código que hagan referencia a los mismos. podemos envolverlos como hicimos con map o usar un adaptador para convertir nuestra interfaz perfecta en la interfaz proporcionada. en cualquier caso, el código se lee mejor, promueve el uso coherente e interno en el límite y hay menos puntos de mantenimiento cuando cambie el código de terceros. bibliografía [becktdd] : test driven development , kent beck, addison-wesley, 2003. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison wesley, 19%. [welc] : working effectively with legacy code , addison-wesley, 2004. 1689 pruebas de unidad nuestra profesión ha evolucionado mucho en los últimos 10 años. en 1997 nadie había oído hablar del desarrollo guiado por pruebas (dgp). para la mayoría, las pruebas de unidad eran pequeños fragmentos de código 169desechable que creábamos para asegurarnos de que nuestros programas funcionaban. escribíamos clases y métodos, y después código ad hoc para probarlos, lo que implicaba algún tipo de programa controlador que nos permitiera interactuar manualmente con el programa que habíamos escrito. recuerdo crear un programa de c++ para un sistema incrustado de tiempo real a mediados de la década de 1990. el programa era un sencillo temporizador con la siguiente firma: void timer::schedulecommand(command* thecommand, int milliseconds) la idea era sencilla; el método execute de command se ejecutaba en un nuevo subproceso tras el número especificado de milisegundos. el problema era cómo probarlo. confeccioné un sencillo programa controlador que escuchaba al teclado. cada vez que se introducía un carácter, se programaba un comando que escribía el mismo carácter cinco segundos después. introduje una rítmica melodía en el teclado y esperé a que se reprodujera en pantalla cinco segundos después: «i… want-a-girl… just… like-the-girl-who-marr… ied… dear… old… dad.» incluso tarareé la melodía mientras pulsaba la tecla, y la volví a cantar cuando aparecieron los puntos en la pantalla. ésa fue mi prueba. cuando vi que funcionaba y se lo mostré a mis compañeros, me deshice del código de prueba. como he afirmado, nuestra profesión ha evolucionado mucho. ahora crearía una prueba que garantizara el funcionamiento de hasta el más mínimo detalle del código. aislaría el código del sistema operativo en lugar de invocar las funciones estándar de temporización. las imitaría para tener control total sobre el tiempo. programaría comandos que definieran indicadores booleanos y avanzaría el tiempo, para observar los indicadores y asegurarme de que pasaran de false a true al cambiar el tiempo al valor correcto. cuando superara una serie de pruebas, comprobaría que fueran adecuadas para todo el que tuviera que trabajar con el código. me aseguraría de comprobar las pruebas y el código en el mismo paquete. sí, hemos 170avanzado mucho, pero nos queda mucho por avanzar. los movimientos agile y tdd han animado a muchos programadores a crear pruebas de unidad automatizadas y cada vez son más. pero en esta alocada carrera por añadir pruebas a nuestra disciplina, muchos programadores han pasado por alto dos de los aspectos más sutiles e importantes de diseñar pruebas de calidad. las tres leyes del dgp todos sabemos que el dgp nos pide que primero creemos las pruebas de unidad, antes que el código de producción. pero esa norma es sólo la punta del iceberg. tenga en cuenta las tres siguientes leyes [37] : primera ley : no debe crear código de producción hasta que haya creado una prueba de unidad que falle. segunda ley : no debe crear más de una prueba de unidad que baste como fallida, y no compilar se considera un fallo. tercera ley : no debe crear más código de producción que el necesario para superar la prueba de fallo actual. estas tres leyes generan un ciclo de unos 30 segundos de duración. las pruebas y el código de producción se crean de forma conjunta, las pruebas unos segundos antes que el código. si trabajamos de esta forma, crearemos decenas de pruebas al día, cientos al mes y miles al año. si trabajamos de esta forma, las pruebas abarcarán todos los aspectos de nuestro código de producción. el tamaño de dichas pruebas, que puede ser similar al del código de producción, puede suponer un problema de administración. realizar pruebas limpias hace unos años me pidieron que dirigiera un equipo que había decidido explícitamente que su código de prueba no debía mantenerse con los mismos estándares de calidad que su código de producción. podían incumplir las 171reglas en sus pruebas de unidad. la premisa era «rápido y directo». no era necesario que las variables tuvieran nombres adecuados, ni que las funciones de prueba fueran breves y descriptivas. no era necesario que el código de prueba estuviera bien diseñado. bastaba con que funcionara y abarcara el código de producción. puede que algunos lectores empaticen con esta decisión. puede que en el pasado creara el tipo de pruebas que cree para la clase timer . supone un gran paso crear ese tipo de pruebas desechables a diseñar una suite de pruebas de unidad automatizadas. por ello, como el equipo que dirigía, puede decidir que pruebas incorrectas sea mejor que no tener pruebas. pero el equipo no se daba cuenta que tener pruebas incorrectas era igual o peor que no tener prueba alguna. el problema es que las pruebas deben cambiar de acuerdo a la evolución del código. cuanto menos limpias sean, más difícil es cambiarlas. cuando más enrevesado sea el código de prueba, más probabilidades de que dedique más tiempo a añadir nuevas pruebas a la suite que el empleado en crear el nuevo código de producción. al modificar el código de producción, las pruebas antiguas comienzan a fallar y el desastre impide que las pruebas se superen, por lo que acaban por convertirse en un obstáculo interminable. entre versiones, aumentó el coste de mantener la suite de pruebas de mi equipo. acabó por convertirse en la principal queja entre los desarrolladores. cuando los directores preguntaron sobre este aumento, los desarrolladores culparon a las pruebas. al final, se vieron obligados a descartar la suite de pruebas completa. pero sin una suite de pruebas perdieron la posibilidad de garantizar el funcionamiento esperado de los cambios en el código. sin una suite de pruebas no podían asegurar que los cambios en una parte del sistema no afectaran a otras diferentes. los defectos aumentaron, lo que propició que temieran realizar cambios. dejaron de limpiar su código de producción por miedo a que los cambios fueran dañinos. el código de producción comenzó a corromperse. al final, se quedaron sin pruebas, con un código de producción enmarañado y defectuoso, clientes frustrados y la sensación de que su esfuerzo les había fallado. en cierto modo tenían razón. su esfuerzo les había fallado. pero fue su 172decisión de permitir que las pruebas fueran incorrectas lo que provocó el fallo. si hubieran empleado pruebas limpias, su esfuerzo no habría fallado. puedo afirmarlo con cierta seguridad porque he participado y dirigido muchos equipos que han tenido éxito gracias a pruebas de unidad limpias. la moraleja de la historia es sencilla: el código de prueba es tan importante como el de producción. no es un ciudadano de segunda. requiere concentración, diseño y cuidado. debe ser tan limpio como el código de producción. las pruebas propician posibilidades si sus pruebas no son limpias, las perderá. y sin ellas pierde lo mismo que hace que su código de producción sea flexible. sí, ha leído bien. las pruebas de unidad son las que hacen que el código sea flexible y se pueda mantener y reutilizar. la razón es sencilla. si tiene pruebas, no tendrá miedo a realizar cambios en el código. sin pruebas, cada cambio es un posible error. independientemente de la flexibilidad de su arquitectura, de la división del diseño, sin pruebas tendrá miedo a realizar cambios por la posibilidad de añadir errores no detectados. pero con las pruebas ese miedo desaparece. cuanto mayor sea el alcance de sus pruebas, menos miedo tendrá. podrá modificar el código con total impunidad, aunque su arquitectura no sea la mejor y el diseño sea mediocre. podrá mejorar la arquitectura y el diseño sin miedo alguno. por tanto, disponer de una suite automatizada de pruebas de unidad que cubran el código de producción es la clave para mantener limpio el diseño y la arquitectura. las pruebas proporcionan las posibilidades, ya que permiten el cambio. si sus pruebas no son limpias, la capacidad de modificar el código se verá limitada y perderá la posibilidad de mejorar la estructura de dicho código. cuanto menos limpias sean las pruebas, menos lo será el código. en última instancia perderá las pruebas y el código se corromperá. pruebas limpias 173¿qué hace que una prueba sea limpia? tres elementos: legibilidad, legibilidad y legibilidad. la legibilidad es sin duda más importante en las pruebas de unidad que en el código de producción. ¿qué hace que una prueba sea legible? lo mismo que en el código: claridad, simplicidad y densidad de expresión. en una prueba debe decir mucho con el menor número de expresiones posible. fíjese en el código de fitnesse del listado 9-1. estas tres pruebas son difíciles de entender y sin duda se pueden mejorar. por un lado, hay mucho código duplicado [g5] en las invocaciones repetidas a addpage y assertsubstring . sobre todo, este código se carga con detalles que interfieren con la expresividad de la prueba. listado 9-1 serializedpagerespondertest.java. public void testgetpagehieratchyasxml() throws exception { crawler.addpage(root, pathparser.parse(“pageone”)); crawler.addpage(root, pathparser.parse(“pageone.childone”)); crawler.addpage(root, pathparser.parse(“pagetwo”)); request.setresource(“root”); request.addinput(“type”, “pages”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“<name>pageone</name>”, xml); assertsubstring(“<name>pagetwo</name>”, xml); assertsubstring(“<name>childone</name>”, xml); } public void testgetpagehieratchyasxmldoesntcontainsymboliclinks() throws exception { wikipage pageone = crawler.addpage(root, pathparser.parse(“pageone”)); crawler.addpage(root, pathparser.parse(“pageone.childone”)); crawler.addpage(root, pathparser.parse(“pagetwo”)); pagedata data = pageone.getdata(); wikipageproperties properties = data.getproperties(); 174wikipageproperty symlinks = properties.set(symbolicpage.property_name); symlinks.set(“sympage”, “pagetwo”); pageone.commit(data); request.setresource(“root”); request.addinput(“type”, “pages”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“<name>pageone</name>”, xml); assertsubstring(“<name>pagetwo</name>”, xml); assertsubstring(“<name>childone</name>”, xml); assertnotsubstring(“sympage”, xml); } public void testgetdataashtml() throws exception { crawler.addpage(root, pathparser.parse(“testpageone”), “test page”); request.setresource(“testpageone”); request.addinput(“type”, “data”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“test page”, xml); assertsubstring(“<test”, xml); } fíjese en las invocaciones de pathparser . transforman cadenas en instancias de pagepath usadas por las arañas. esta transformación es totalmente irrelevante para la prueba y únicamente complica su cometido. los detalles circundantes a la creación del respondedor y la obtención y conversión de la respuesta también sobran. también la forma de crear la url de solicitud a partir de un recurso y un argumento (contribuí a crear este código, por lo que tengo todo el derecho a criticarlo). al final, el código no se ha diseñado de forma legible. el lector se ve rodeado de miles de detalles que debe comprender antes de que las pruebas tengan sentido. fíjese ahora en las pruebas mejoradas del listado 9-2. hacen exactamente lo mismo, pero se han refactorizado de forma más clara y 175descriptiva. listado 9-2 serializedpagerespondertest.java (refactorizado) public void testgetpagehierarchyasxml() throws exception { makepages(“pageone”, “pageone.childone”, “pagetwo”); submitrequest(“root”, “type:pages”); assertresponseisxml(); assertresponsecontains( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); } public void testsymboliclinksarenotinxmlpagehierarchy() throws exception { wikipage page = makepage(“pageone”); makepages(“pageone.childone”, “pagetwo”); addlinkto(page, “pagetwo”, “sympage”); submitrequest(“root”, “type:pages”); assertresponseisxml(); assertresponsecontains( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); assertresponsedoesnotcontain(“sympage”); } public void testgetdataasxml() throws exception { makepagewithcontent(“testpageone”, “test page”); submitrequest(“testpageone”, “type:data”); assertresponseisxml(); assertresponsecontains(“test page”, “<test”); } el patrón generar-operar-comprobar [38] es evidente en la estructura de las pruebas. cada una se divide claramente en tres partes. la primera crea los datos de prueba, la segunda opera en dichos datos y la tercera comprueba que la operación devuelva los resultados esperados. comprobará que se ha eliminado gran parte de los detalles molestos. las pruebas son concisas y sólo usan los tipos de datos y funciones que realmente necesitan. todo el que lea estas pruebas sabrá rápidamente para qué sirven y no se perderá entre detalles irrelevantes. 176lenguaje de pruebas específico del dominio las pruebas del listado 9-2 ilustran la creación de un lenguaje específico del dominio para sus pruebas. en lugar de usar las api que los programadores emplean para manipular el sistema, creamos una serie de funciones y utilidades que usan dichas api y que facilitan la escritura y la lectura de las pruebas. estas funciones y utilidades se convierten en una api especializada usada por las pruebas. son un lenguaje de pruebas que los programadores usan personalmente para crear sus pruebas y para ayudar a los que después las lean. esta api de pruebas no se diseña con antelación, sino que evoluciona con la refactorización continuada del código de prueba. al igual que refactorizamos el listado 9-1 en el listado 9-2, los programadores disciplinados refactorizan su código de prueba en versiones más sucintas y expresivas. un estándar dual en un sentido, el equipo que mencionamos antes tenía razón. el código de la api de pruebas tiene un conjunto de estándares de ingeniería diferentes al código de producción. también tiene que ser sencillo, sucinto y expresivo, pero no tan eficaz como el código de producción. después de todo, se ejecuta en un entorno de prueba, no de producción, y cada entorno tiene sus propias necesidades. fíjese en la prueba del listado 9-3. la creé como parte de un prototipo de sistema de control medioambiental. sin entrar en detalles, se aprecia que esta prueba comprueba que la alarma de baja temperatura, el calentador y el fuelle estén activados cuando la temperatura sea demasiado fría. listado 9-3 environmentcontrollertest.java @test public void turnonlotempalarmatthreashold() throws exception { hw.settemp(way_too_cold); 177controller.tic(); asserttrue(hw.heaterstate()); asserttrue(hw.blowerstate()); assertfalse(hw.coolerstate()); assertfalse(hw.hitempalarm()); asserttrue(hw.lotempalarm()); } aquí hay muchos detalles. por ejemplo, ¿para qué sirve la función tic ? de hecho, la ignoraría mientras leemos esta prueba. intente centrarse en saber si está de acuerdo en que el estado final del sistema tiene que ver con que la temperatura sea demasiado baja. al leer la prueba, la vista tiene que cambiar entre el nombre del estado comprobado y el sentido del estado comprobado. vemos heaterstate y después la vista salta a asserttrue . vemos coolerstate y nos fijamos en assertfalse . resulta tedioso y dificulta la lectura de la prueba. he conseguido mejorar la legibilidad de la prueba transformándola en el listado 9-4. listado 9-4 environmentcontrollertest.java (refactorizado) @test public void turnonlotempalarmatthreshold() throws exception { waytoocold(); assertequals(“hbchl”, hw.getstate()); } evidentemente, he ocultado el detalle de la función tic creando una función waytoocold . pero lo importante es la extraña cadena de assertequals . las mayúsculas significan activado y las minúsculas desactivado, y las letras siempre aparece en este orden: {heater, blower, cooler, hi-temp-alarm, lo-temp-alarm} . aunque prácticamente sea un incumplimiento de las reglas de asignación mental [39] , en este caso parece apropiado. una vez que conocemos el significado, la vista pasa por la cadena y podemos interpretar los resultados. la lectura de la prueba es casi un placer. fíjese en el listado 9-5 y compruebe con qué facilidad entiende las pruebas. 178listado 9-5 environmentcontrollertest.java (una selección mayor). @test public void turnoncoolerandbloweriftoohot() throws exception { toohot(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonheaterandbloweriftoocold() throws exception { toocold(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonhitempalarmatthreshold() throws exception { waytoohot(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonlotempalarmatthreshold() throws exception { waytoocold(); assertequals(“hbchl”, hw.getstate()); } la función getstate se reproduce en el listado 9-6. no es un código muy eficaz. para que lo sea, deberíamos haber usado stringbuffer . listado 9-6 mockcontrolhardware.java. public string getstate() { string state = “”; state += heater ? “h” : “h”; state += blower ? “b” : “b”; state += cooler ? “c” : “c”; state += hitempalarm ? “h” : “h”; state += lotempalarm ? “l” : “l”; return state; } stringbuffer es poco atractivo. incluso en código de producción, intento evitarlo si el coste es mínimo, como podría suceder en el listado 9-6. pero esta aplicación es claramente un sistema incrustado en tiempo real y es probable que los recursos del equipo y la memoria estén limitados. sin 179embargo, el entorno de pruebas es improbable que lo esté. es la naturaleza del estándar dual. hay cosas que nunca haría en un entorno de producción totalmente válidas para un entorno de prueba. suelen ser problemas de memoria o eficacia de la cpu, pero nunca problemas de limpieza. una afirmación por prueba existe una escuela de pensamiento [40] que afirma que todas las funciones de prueba de una prueba junit sólo deben tener una instrucción de afirmación. puede parecer una regla draconiana pero la ventaja se aprecia en el listado 9- 5. las pruebas llegan a una misma conclusión, que se entiende de forma rápida y sencilla. ¿pero qué sucede con el listado 9-2? no parece razonable afirmar que el resultado es xml y que contiene determinadas subcadenas. sin embargo, podemos dividir la prueba en dos, cada una con una afirmación concreta, como se muestra en el listado 9-7. listado 9-7 serializedpagerespondertest.java (una sola afirmación). public void testgetpagehierarchyasxml() throws exception { givenpages(“pageone”, “pageone.childone”, “pagetwo”); whenrequestisissued(“root”, “type:pages”); thenresponseshouldbexml(); } public void testgetpagehierarchyhasrighttags() throws exception { givenpages(“pageone”, “pageone.childone”, “pagetwo”); whenrequestisissued(“root”, “type:pages”); thenresponseshouldcontain( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); } he cambiado los nombres de las funciones para usar la convención dado- cuando-entonces [41] . de este modo las pruebas son más fáciles de leer. desafortunadamente, al dividir las pruebas se genera código duplicado. 180podemos eliminar los duplicados por medio del patrón método de plantilla [42] e incluir las partes dado/cuando en la clase base, y las partes entonces en derivaciones diferentes. o podríamos crear una clase de prueba independiente e incluir las partes dado y cuando en la función @before y las partes entonces en cada función @test . pero parece un mecanismo excesivo para un problema tan menor. al final, opto por las afirmaciones múltiples del listado 9-2. considero que la regla de una sola afirmación es una directriz adecuada [43] . siempre intento crear un lenguaje de pruebas específico del dominio que la complemente, como en el listado 9-5, pero no rechazo incluir más de una afirmación en una prueba. creo que lo mejor que podemos decir es que el número de afirmaciones de una prueba debe ser mínimo. un solo concepto por prueba puede que una regla más indicada sea probar un único concepto en cada función de prueba. no queremos extensas funciones que prueben una cosa diferente tras otra, como sucede en el listado 9-8. esta prueba debería dividirse en tres diferentes que probaran tres cosas distintas. al combinarlas en la misma función se obliga al lector a determinar por qué cada sección se ubica en ese punto y qué prueba dicha sección. listado 9-8 /** * varias pruebas para el método addmonths(). */ public void testaddmonths() { serialdate d1 = serialdate.createinstance(31, 5, 2004); serialdate d2 = serialdate.addmonths(1, d1); assertequals(30, d2.getdayofmonth()); assertequals(6, d2.getmonth()); assertequals(2004, d2.getyyyy()); serialdate d3 = serialdate.addmonths(2, d1); assertequals(31, d3.getdayofmonth()); assertequals(7, d3.getmonth()); assertequals(2004, d3.getyyyy()); 181serialdate d4 = serialdate.addmonths(1, serialdate.addmonths(1, d1)); assertequals(30, d4.getdayofmonth()); assertequals(7, d4.getmonth()); assertequals(2004, d4.getyyyy()); } las tres funciones deberían ser las siguientes: dado el último día de un mes con 31 días (como mayo): 1 . cuando se añade un mes, si el último día de ese mes es el 30 (como en junio), entonces la fecha debe ser el día 30 de ese mes, no el 31. 2 . cuando se añaden dos meses a esa fecha, si el último mes tiene 31 días, entonces la fecha debe ser el día 31. dado el último día de un mes con 30 días (como junio): 1 . cuando se añade, si el último día de ese mes tiene 31 días, entonces la fecha debe ser el 30, no el 31. expresado de esta forma, se aprecia que existe una regla general entre las distintas pruebas. al incrementar el mes, la fecha no puede ser mayor que su último día. esto implica que al incrementar el mes en el 28 de febrero debe generarse el 28 de marzo. falta esa prueba y convendría que la escribiéramos. así pues, no son las múltiples afirmaciones del listado 9-8 las causantes del problema, sino el hecho de que se prueba más de un concepto. probablemente la regla óptima sea minimizar el número de activos por concepto y probar un solo concepto por función de prueba. f.i.r.s.t. [44] las pruebas limpias siguen otras cinco reglas, cuyas iniciales forman las siglas first en inglés: rapidez ( fast ): las reglas deben ser rápidas y ejecutarse de forma rápida. si lo hacen lentamente, no las ejecutará con frecuencia. al no hacerlo, no detectará los problemas con la suficiente antelación como para solucionarlos. no se sentirá con libertad para limpiar el código, que acabará corrompiéndose. 182independencia ( independent ): las pruebas no deben depender entre ellas. una prueba no debe establecer condiciones para la siguiente. debe poder ejecutar cada prueba de forma independiente y en el orden que desee. si las pruebas dependen unas de otras, la primera que falle provocará una sucesión de fallos, dificultará el diagnóstico y ocultará efectos posteriores. repetición ( repeatable ): las pruebas deben poder repetirse en cualquier entorno. debe poder ejecutarlas en el entorno de producción, en el de calidad y en su portátil de camino a casa en un tren sin red. si no puede repetir las pruebas en cualquier entorno, siempre tendrá una excusa de su fallo. también verá que no puede ejecutar las pruebas si el entorno no está disponible. validación automática ( self-validating ): las pruebas deben tener un resultado booleano: o aciertan o fallan. no debe tener que leer un extenso archivo de registro para saber si una prueba ha acertado, ni comparar manualmente dos archivos de texto distintos para ello. si las pruebas no se validan automáticamente, el fallo puede ser subjetivo y la ejecución de las pruebas puede requerir una extensa evaluación manual. puntualidad ( timely ): las pruebas deben crearse en el momento preciso: antes del código de producción que hace que acierten. si crea las pruebas después del código de producción, puede que resulte difícil probarlo. puede decidir qué parte del código de producción sea demasiado difícil de probar. no diseñe código de producción que no se pueda probar. conclusión apenas hemos abordado la superficie de este tema. de hecho, se podría crear un libro entero sobre pruebas limpias. las pruebas son tan importantes para la salud de un proyecto como el código de producción. puede que incluso más, ya que conservan y mejoran la flexibilidad, capacidad de mantenimiento y reutilización del código de producción. por ello, intente que sean limpias. trabaje para que resulten expresivas y concisas. invente api de prueba que actúen como lenguaje específico del dominio que le ayude a crear las pruebas. si deja que las pruebas se corrompan, sucederá lo mismo con el código de 183producción. mantenga limpias las pruebas. bibliografía [rspec] : rspec: behavior driven development for ruby programmers , aslak hellesay, david chelimsky, pragmatic bookshelf, 2008. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 18410 clases con jeff langr hasta ahora nos hemos centrado en escribir bien líneas y bloques de código. nos hemos adentrado en la correcta composición de las funciones y en su interrelación. pero a pesar de la atención dedicada a la expresividad de las instrucciones y las funciones, no tendremos código limpio hasta que nos fijemos en los niveles superiores de su organización. hablemos sobre clases. 185organización de clases de acuerdo a la convención estándar de java, una clase debe comenzar con una lista de variables. las constantes estáticas públicas, si existen, deben aparecer primero. tras ello, las variables estáticas privadas y después las variables de instancia privadas. no suele ser necesario usar variables públicas. las funciones públicas deben seguir a la lista de variables. incluimos las utilidades públicas invocadas por una función pública tras la propia función pública. este sistema cumple la regla descendente y permite que el programa se lea como un artículo de periódico. encapsulación queremos que nuestras variables y funciones de utilidad sean privadas, pero no es imprescindible. en ocasiones podemos proteger una variable o función de utilidad para que sea accesible para una prueba. las reglas mandan. si una regla del mismo paquete tiene que invocar una función o acceder a una variable, hacemos que tenga ámbito protected o de paquete. sin embargo, primero veremos una forma de mantener la privacidad. la relajación de la encapsulación siempre es un último resorte. las clases deben ser de tamaño reducido la primera regla de las clases es que deben ser de tamaño reducido. la segunda regla es que deben ser todavía más reducidas. no, no vamos a repetir el mismo texto en el capítulo sobre las funciones, pero como sucede con las funciones, el tamaño reducido es lo principal a la hora de diseñar una clase. y la pregunta inmediata es qué nivel de reducción. con las funciones medimos el tamaño contando líneas físicas. con las clases usamos otra medida distinta: las responsabilidades [45] . el listado 10-1 muestra una clase, superdashboard , que muestra 70 186métodos públicos. muchos programadores estarán de acuerdo en que es un tamaño excesivo. algunos denominarían a superdashboard una clase dios. listado 10-1 demasiadas responsabilidades. public class superdashboard extends jframe implements metadatauser public string getcustomizerlanguagepath() public void setsystemconfigpath(string systemconfigpath) public string getsystemconfigdocument() public void setsystemconfigdocument(string systemconfigdocument) public boolean getgurustate() public boolean getnovicestate() public boolean getopensourcestate() public void showobject(metaobject object) public void showprogress(string s) public boolean ismetadatadirty() public void setismetadatadirty(boolean ismetadatadirty) public component getlastfocusedcomponent() public void setlastfocused(component lastfocused) public void setmouseselectstate(boolean ismouseselected) public boolean ismouseselected() public languagemanager getlanguagemanager() public project getproject() public project getfirstproject() public project getlastproject() public string getnewprojectname() public void setcomponentsizes(dimension dim) public string getcurrentdir() public void setcurrentdir(string newdir) public void updatestatus(int dotpos, int markpos) public class[] getdatabaseclasses() public metadatafeeder getmetadatafeeder() public void addproject(project project) public boolean setcurrentproject(project project) public boolean removeproject(project project) public metaprojectheader getprogrammetadata() public void resetdashboard() public project loadproject(string filename, string projectname) public void setcansavemetadata(boolean cansave) public metaobject getselectedobject() public void deselectobjects() public void setproject(project project) public void editoraction(string actionname, actionevent event) public void setmode(int mode) public filemanager getfilemanager() public void setfilemanager(filemanager filemanager) public configmanager getconfigmanager() public void setconfigmanager(configmanager configmanager) public classloader getclassloader() 187public void setclassloader(classloader classloader) public properties getprops() public string getuserhome() public string getbasedir() public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() public metaobject pasting( metaobject target, metaobject pasted, metaproject project) public void processmenuitems(metaobject metaobject) public void processmenuseparators(metaobject metaobject) public void processtabpages(metaobject metaobject) public void processplacement(metaobject object) public void processcreatelayout(metaobject object) public void updatedisplaylayer(metaobject object, int layerindex) public void propertyeditedrepaint(metaobject object) public void processdeleteobject(metaobject object) public boolean getattachedtodesigner() public void processprojectchangedstate(boolean hasprojectchanged) public void processobjectnamechanged(metaobject object) public void runproject() public void setallowdragging(boolean allowdragging) public boolean allowdragging() public boolean iscustomizing() public void settitle(string title) public idemenubar getidemenubar() public void showhelper(metaobject metaobject, string propertyname) //… y otros muchos métodos no públicos… } ¿y si superdashboard sólo incluyera los métodos mostrados en el listado 10-2? listado 10-2 ¿suficientemente reducido? public class superdashboard extends jframe implements metadatauser public component getlastfocusedcomponent() public void setlastfocused(component lastfocused) public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() } cinco métodos no es demasiado, ¿verdad? en este caso sí ya que a pesar del reducido número de métodos, superdashboard también tiene demasiadas responsabilidades. el nombre de una clase debe describir las responsabilidades que 188desempeña. de hecho, el nombre es la primera forma para determinar el tamaño de una clase. si no podemos derivar un nombre conciso para una clase, seguramente sea demasiado extenso. cuanto más ambiguo sea el nombre de la clase, más probabilidades hay de que tenga demasiadas responsabilidades. por ejemplo, los nombres de clase con palabras como processor , manager o super suelen indicar una desafortunada acumulación de responsabilidades. también debemos ser capaces de escribir una breve descripción de la clase en unas 25 palabras, sin usar las palabras « si », « o », « y » o « pero ». ¿cómo describiríamos superdashboard ?: superdashboard permite acceder al componente con el enfoque y nos permite controlar los números de versión y producto. el primer y indica que superdashboard tiene demasiadas responsabilidades. el principio de responsabilidad única el principio de responsabilidad única ( single responsibility principle , srp) [46] indica que una clase o módulo debe tener uno y sólo un motivo para cambiar. este principio nos indica la definición de responsabilidad y una directriz para el tamaño de la clase. las clases sólo deben tener una responsabilidad, un motivo para cambiar. la clase superdashboard aparentemente reducida del listado 10-2 tiene dos motivos para cambiar. primero, controla información de versión que supuestamente debe actualizarse cada vez que se comercialice el software . por otra parte, gestiona componentes de java swing (un derivado de jframe, la representación swing de una ventana de igu de nivel superior). sin duda, querremos cambiar el número de versión si cambiamos el código swing, pero lo contrario no es necesario: podríamos cambiar la información de versión en función de los cambios de otro código del sistema. la identificación de responsabilidades (los motivos del cambio) nos permite reconocer y mejorar las abstracciones en nuestro código. podemos extraer los tres métodos de superdashboard relacionados con la información de versiones en una clase independiente como version (véase el listado 10-3.) la clase version es una construcción 189que se puede reutilizar en otras aplicaciones. listado 10-3 una clase con una única responsabilidad. public class version { public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() } srp es uno de los conceptos más importantes del diseño orientado a objetos y también uno de los más sencillos de entender y cumplir, pero también es uno de los que más se abusa al diseñar clases. habitualmente nos encontramos clases que hacen demasiadas cosas. ¿por qué? crear software que funcione y crear software limpio son dos actividades diferentes. muchos tenemos un cerebro limitado, de modo que nos centramos en que el código funcione más que en su organización y limpieza. es algo totalmente válido. mantener objetivos separados es tan importante en nuestras actividades de programación como en nuestros programas. el problema es que muchos creemos que hemos terminado cuando el programa funciona. no cambiamos al otro objetivo de organización y limpieza. pasamos al siguiente problema en lugar de retroceder y dividir las clases en unidades independientes con una única responsabilidad. al mismo tiempo, muchos programadores temen que un elevado número de pequeñas clases con un único propósito dificulten la comprensión del conjunto. les preocupa que tengan que desplazarse entre las clases para determinar cómo funciona un aspecto concreto. sin embargo, un sistema con muchas clases reducidas no tiene más elementos móviles que un sistema con algunas clases enormes. en ambos hay que entender lo mismo. la pregunta es si quiere organizar sus herramientas en cajas con muchos pequeños cajones que contengan componentes bien definidos y etiquetados, o usar varios cajones grandes en los que mezcle todo. todos los sistemas tienen una gran lógica y complejidad. el objetivo principal para gestionar dicha complejidad es organizarla para que un programador sepa dónde buscar y comprenda la complejidad directamente afectada en cada momento concreto. por el contrario, un sistema con clases 190multipropósito de mayor tamaño nos obliga a buscar entre numerosos elementos que no siempre necesitamos conocer. para reformular los puntos anteriores, diremos que los sistemas deben estar formados por muchas claves reducidas, no por algunas de gran tamaño. cada clase reducida encapsula una única responsabilidad, tiene un solo motivo para cambiar y colabora con algunas otras para obtener los comportamientos deseados del sistema. cohesión las clases deben tener un número reducido de variables de instancia. los métodos de una clase deben manipular una o varias de dichas variables. por lo general, cuantas más variables manipule un método, más cohesión tendrá con su clase. una clase en la que cada variable se usa en cada método tiene una cohesión máxima. por lo general, no es recomendable ni posible crear este tipo de clases pero queremos que la cohesión de nuestras clases sea elevada. si lo logramos, significa que los métodos y variables de la clase dependen unos de otros y actúan como un todo lógico. fíjese en la implementación de stack en el listado 10-4. es una clase muy consistente. de los tres métodos, sólo size() no usa ambas variables. listado 10-4 stack.java, una clase consistente. public class stack { private int topofstack = 0; list<integer> elements = new linkedlist<integer>(); public int size() { return topofstack; } public void push(int element) { topofstack++; elements.add(element); } public int pop() throws poppedwhenempty { 191if (topofstack == 0) throw new poppedwhenempty(); int element = elements.get(--topofstack); elements.remove(topofstack); return element; } } la estrategia de reducir el tamaño de las funciones y de las listas de parámetros suele provocar la proliferación de variables de instancia usadas por un subconjunto de los métodos. si esto sucede, siempre existe al menos una clase que intenta huir de la clase de mayor tamaño. debe intentar separar las variables y métodos en dos o más clases para que las nuevas sean más consistentes. mantener resultados consistentes en muchas clases de tamaño reducido la división de grandes funciones en otras más pequeñas aumenta la proliferación de clases. imagine una gran función con numerosas variables declaradas. imagine que desea extraer una pequeña parte de esa función en otra independiente. sin embargo, el código que extrae usa cuatro de las variables declaradas en la función. ¿debe pasar las cuatro variables como argumentos a la nueva función? en absoluto. si ascendemos estas cuatro variables a variables de instancia de la clase, podremos extraer el código sin pasar las variables. resultaría más sencillo dividir la función en pequeños fragmentos. desafortunadamente, eso significaría que nuestras clases perderían cohesión ya que acumularían más y más variables de instancia que sólo existen para que otras funciones las compartan. pero un momento. si apenas existen funciones que compartan determinadas variables, ¿no son entonces una clase con derecho propio? por supuesto. cuando las clases pierdan cohesión, divídalas. por tanto, dividir una gran función en otras más reducidas también nos permite dividir varias clases más reducidas. de este modo mejora la organización del programa y su estructura resulta más transparente. como ejemplo, usaremos un ejemplo obtenido del libro de knuth literate 192programming [47] . el listado 10-5 muestra una traducción a java del programa printprimes de knuth. para hacerle justicia, no es el programa que creó sino el resultado generado por su herramienta web. lo usamos aquí por ser un magnífico punto de partida para dividir una función de gran tamaño en varias funciones y clases más reducidas. listado 10-5 printprimes.java package literateprimes; public class printprimes { public static void main(string[] args) { final int m = 1000; final int rr = 50; final int cc = 4; final int ww = 10; final int ordmax = 30; int p[] = new int[m + 1]; int pagenumber; int pageoffset; int rowoffset; int c; int j; int k; boolean jprime; int ord; int square; int n; int mult[] = new int[ordmax + 1]; j = 1; k = 1; p[1] = 2; ord = 2; square = 9; while (k < m) { do { j = j + 2; if (j == square) { ord = ord + 1; square = p[ord] * p[ord]; mult[ord - 1] = j; } n = 2; jprime = true; while (n < ord && jprime) { while (mult[n] < j) 193mult[n] = mult[n] + p[n] + p[n]; if (mult[n] == j) jprime = false; n = n + 1; } } while (!jprime); k = k + 1; p[k] = j; } { pagenumber = 1; pageoffset = 1; while (pageoffset <= m) { system.out.println(“the first ” + m + “ prime numbers --- page ” + pagenumber); system.out.println(“”); for (rowoffset = pageoffset; rowoffset < pageoffset + rr; rowoffset++) { for (c = 0; c < cc;c++) if (rowoffset + c * rr <= m) system.out.format(“%10d”, p[rowoffset + c * rr]); system.out.println(“”); } system.out.println(“\f”); pagenumber = pagenumber + 1; pageoffset = pageoffset + rr * cc; } } } } este programa, escrito como una sola función, es un desastre. el sangrado de su estructura es excesivo y hay demasiadas variables extrañas. como mínimo, la función debería dividirse en otras más pequeñas. los listados del 10-6 al 10-8 muestran la división del código del listado 10-5 en clases y funciones de menor tamaño, además de los nombres elegidos para dichas clases, funciones y variables. listado 10-6 primeprinter.java (refactorizado) package literateprimes; public class primeprinter ( public static void main(string[] args) { final int number_of_prime5 = 1000; int[] primes = primegenerator.generate(number_of_primes); final int rows_per_page = 50; 194final int columns_per_page = 4; rowcolumnpageprinter tableprinter = new rowcolumnpageprinter(rows_per_page, columns_per_page, “the first ” + number_of_primes + “ prime numbers”); tableprinter.print(primes); } } listado 10-7 rowcolumnpageprinter.java. package literateprimes; import java.io.printstream; public class rowcolumnpageprinter { private int rowsperpage; private int columnsperpage; private int numbersperpage; private string pageheader; private printstream printstream; public rowcolumnpageprinter(int rowsperpage, int columnsperpage, string pageheader) { this.rowsperpage = rowsperpage; this.columnsperpage = columnsperpage; this.pageheader = pageheader; numbersperpage = rowsperpage * columnsperpage; printstream = system.out; } public void print(int data[]) { int pagenumber = 1; for (int firstindexonpage = 0; firstindexonpage < data.length; firstindexonpage += numbersperpage) { int lastindexonpage = math.min(firstindexonpage + numbersperpage - 1, data.length - 1); printpageheader(pageheader, pagenumber); printpage(firstindexonpage, lastindexonpage, data); printstream.println(“\f”); pagenumber++; } } private void printpage (int firstindexonpage, int lastindexonpage, int[] data) { 195int firstindexoflastrowonpage = firstindexonpage + rowsperpage - 1; for (int firstindexinrow = firstindexonpage; firstindexinrow <= firstindexoflastrowonpage; firstindexinrow++) { printrow(firstindexinrow, lastindexonpage, data); printstream.println(“”); } } private void printrow(int firstindexinrow, int lastindexonpage, int[] data) { for (int column = 0; column < columnsperpage; column++) { int index = firstindexinrow + column * rowsperpage; if (index <= lastindexonpage) printstream.format(“%10d”, data[index]); } } private void printpageheader(string pageheader, int pagenumber) { printstream.println(pageheader + “ --- page ” + pagenumber); printstream.println(“”); } public void setoutput(printstream printstream) { this.printstream = printstream; } } listado 10-8 primegenerator.java package literateprimes; import java.util.arraylist; public class primegenerator { private static int[] primes; private static arraylist<integer> multiplesofprimefactors; protected static int[] generate(int n) { primes = new int[n]; multiplesofprimefactors = new arraylist<integer>(); set2asfirstprime(); checkoddnumbersforsubsequentprimes(); return primes; } private static void set2asfirtsprime() { primes[0] = 2; multiplesofprimefactors.add(2); 196} private static void checkoddnumbersforsubsequentprimes() { int primeindex = 1; for (int candidate = 3; primeindex < primes.length; candidate += 2) { if (isprime(candidate)) primes[primeindex++] = candidate; } } private static boolean isprime(int candidate) { if (isleastrelevantmultipleofnextlargerprimefactor(candidate)) { multiplesofprimefactors.add(candidate); return false; } return isnotmultipleofanypreviousprimefactor(candidate); } private static boolean isleastrelevantmultipleofnextlargerprimefactor(int candidate) { int nextlargerprimefactor = primes[multiplesofprimefactors.size()]; int leastrelevantmultiple = nextlargerprimefactor * nextlargerprimefactor; return candidate == leastrelevantmultiple; } private static boolean isnotmultipleofanypreviousprimefactor(int candidate) { for (int n = 1; n < multiplesofprimefactors.size(); n++) { if (ismultipleofnthprimefactor(candidate, n)) return false; } return true; } private static boolean ismultipleofnthprimefactor(int candidate, int n) { return candidate == smallestoddnthmultiplenotlessthancandidate(candidate, n); } private static int smallestoddnthmultiplenotlessthancandidate(int candidate, int n) { int multiple = multiplesofprimefactors.get(n); while (multiple < candidate) multiple += 2 * primes[n]; multiplesofprimefactors.set(n, multiple); return multiple; } } lo primero que apreciará es que ha aumentado la longitud del programa, 197de una a casi tres páginas. este aumento se debe a varios motivos. en primer lugar, el programa refactorizado usa nombres de variable más extensos y descriptivos. por otra parte, usa declaraciones de funciones y clases como comentarios del código. por último, usamos espacios en blanco y técnicas de formato para mantener la legibilidad. el programa se ha dividido en tres responsabilidades principales. la parte principal se incluye en la clase primeprinter , responsable de controlar el entorno de ejecución. cambia si se modifica el método de invocación. por ejemplo, si este programa se convierte en un servicio soa, es la clase que se verá afectada. rowcolumnpageprinter sabe cómo aplicar formato a una lista de números con una determinada cantidad de filas y columnas. si es necesario cambiar el formato del resultado, es la clase que se verá afectada. la clase primegenerator sabe cómo generar una lista de números primos. no se creará una instancia como objeto. la clase es sólo un ámbito útil en el que declarar y ocultar sus variables. esta clase cambia si se modifica el algoritmo para calcular números primos. no hemos reescrito el programa. no hemos empezado de cero y los hemos vuelto a diseñar. en realidad, si se fija atentamente en los dos programas, verá que usan los mismos algoritmos y mecanismos. el cambio se ha realizado creando una suite de pruebas que verifican el comportamiento preciso del primer programa. tras ello, se aplican numerosos cambios mínimos, de uno en uno. tras cada cambio, se ejecuta el programa para garantizar que el comportamiento no varía. paso a paso, el primer programa se limpia y se transforma en el segundo. organizar los cambios en muchos sistemas, el cambio es continuo. cada cambio supone un riesgo de que el resto del sistema no funcione de la forma esperada. en un sistema limpio organizamos las clases para reducir los riesgos de los cambios. la clase sql del listado 10-9 se usa para generar cadenas sql de forma correcta con los metadatos adecuados. es un trabajo continuo y, como tal, no 198admite funciones sql como instrucciones update . cuando la clase sql tenga que admitir una instrucción update , tendremos que abrirla para realizar modificaciones. el problema de abrir una clase es el riesgo que conlleva. cualquier modificación puede afectar a otro código de la clase. debe probarse concienzudamente. listado 10-9 clase que debemos abrir para realizar cambios. public class sql { public sql(string table, column[] columns) public string create() public string insert(object[] fields) public string selectall() public string findbykey(string keycolumn, string keyvalue) public string select(column column, string pattern) public string select(criteria criteria) public string preparedinsert() private string columnlist(column[] columns) private string valueslist(object[] fields, final column[] columns) private string selectwithcriteria(string criteria) private string placeholderlist(column[] columns) } la clase sql debe cambiar al añadir un nuevo tipo de instrucción. también debe cambiar cuando variemos los detalles de un tipo de instrucción concreto; por ejemplo, si tenemos que modificar la funcionalidad select para admitir selecciones secundarias. estos dos motivos de cambio significan que la clase sql incumple srp. podemos detectar este incumplimiento desde un punto de vista organizativo. el método outline de sql muestra que hay métodos privados, como selectwithcriteria , que parecen relacionarse únicamente con instrucciones select . el comportamiento de métodos privados aplicados a un pequeño subconjunto de una clase puede ser una heurística útil para detectar zonas que mejorar. sin embargo, la verdadera razón debe ser el cambio del sistema. si la clase sql se considera totalmente lógica, no debemos preocuparnos por separar las responsabilidades. si no necesitamos funcionalidad de actualización en el futuro, podemos olvidarnos de sql . pero si tenemos que 199abrir una clase, debemos corregir el diseño. ¿y si optamos por una solución como la del listado 10-10? los métodos públicos de interfaz definidos en sql en el listado 10-9 se refactorizan en sus propias variantes de la clase sql . los métodos privados, como valueslist , se mueven directamente a las posiciones necesarias. el comportamiento privado se reduce a un par de clases de utilidad: where y columnlist . listado 10-10 un grupo de clases cerradas. abstract public class sql { public sql(string table, column[] columns) abstract public string generate(); } public class createsql extends sql { public createsql(string table, column[] columns) @override public string generate() } public class selectsql extends sql { public selectsql(string table, column[] columns) @override public string generate() } public class insertsql extends sql { public selectsql(string table, column[] columns, object[] fields) @override public string generate() private string valueslist(object[] fields, final column[] columns) } public class selectwithcriteriasql extends sql { public selectwithcriteriasql( string table, column[] columns, criteria criteria) @override public string generate() } public class selectwithmatchsql extends sql { public selectwithmatchsql( string table, column[] columns, column column, string pattern) @override public string generate() } public class findbykeysql extends sql { public findbykeysql( string table, column[] columns, string keycolumn, string keyvalue) @override public string generate() } 200public class preparedinsertsql extends sql { public preparedinsertsql(string table, column[] columns) @override public string generate() private string placeholderlist(column[] columns) } public class where { public where(string criteria) public string generate() } public class columnlist { public columnlist(column[] columns) public string generate() } el código de cada clase se simplifica enormemente. el tiempo necesario para entender las clases se reduce al mínimo. el riesgo de que una función afecte a otra desaparece casi por completo. desde el punto de vista de las pruebas, resulta más sencillo probar la lógica de esta solución, ya que las clases se aíslan unas de otras. además, cuando llegue el momento de añadir las instrucciones update , no cambia ninguna de las clases existentes. añadimos la lógica para generar instrucciones update a una nueva subclase de sql , updatesql . este cambio no afecta a otro código del sistema. nuestra lógica sql reestructurada representa lo mejor de ambos mundos. cumple con srp y también con otro principio clave del diseño de clases orientadas a objetos, denominado principio abierto/cerrado [48] : las clases deben abrirse para su ampliación para cerrarse para su modificación. la nueva clase sql se abre a nuevas funcionalidades mediante la creación de subclases pero podemos realizar estos cambios y mantener cerradas las demás clases. basta con añadir nuestra clase updatesql . debemos estructurar nuestros sistemas para ensuciarlos lo menos posible cuando los actualicemos con nuevas funciones o cambios. en un sistema ideal, incorporamos nuevas funciones ampliándolo, no modificando el código existente. aislarnos de los cambios 201las necesidades cambiarán y también lo hará el código. en la programación orientada a objetos aprendemos que hay clases concretas que contienen detalles de implementación (el código) y clases abstractas que sólo representan conceptos. una clase cliente que dependa de detalles concretos está en peligro si dichos detalles cambian. podemos recurrir a interfaces y clases abstractas para aislar el impacto de dichos detalles. las dependencias de detalles de concretos crean retos para nuestro sistema. si tenemos que crear la clase portfolio y ésta depende de una api tokyostockexchange externa para obtener su valor, nuestros casos de prueba se verán afectados por la volatilidad de esta búsqueda. resulta complicado crear una prueba cuando se obtiene una respuesta diferente cada cinco minutos. en lugar de diseñar portfolio para que dependa directamente de tokyostockexchange , creamos una interfaz, stockexchange , que declara un único método: public interface stockexchange { money currentprice(string symbol); } diseñamos tokyostockexchange para implementar esta interfaz. también nos aseguramos de que el constructor de portfolio adopte como argumento una referencia a stockexchange: public portfolio { private stockexchange exchange; public portfolio(stockexchange exchange) { this.exchange = exchange; } //… } ahora la prueba puede crear una implementación de la interfaz stockexchange que emule tokyostockexchange . esta implementación de prueba fijará el valor actual del símbolo que usemos en la prueba. si nuestra prueba demuestra la adquisición de cinco acciones de microsoft para nuestra cartera de valores, diseñe el código de la implementación de prueba para que siempre devuelva 100 dólares por acción de microsoft. nuestra implementación de prueba de la interfaz stockexchange se reduce a una sencilla búsqueda de tabla. de este modo 202podemos crear una prueba que espere un valor de cartera total de 500 dólares: public class portfoliotest { private fixedstockexchangestub exchange; private portfolio portfolio; @before protected void setup() throws exception { exchange = new fixedstockexchangestub(); exchange.fix(“msft”, 100); portfolio = new portfolio(exchange); } @test public void givenfivemsfttotalshouldbe500() throws exception { portfolio.add(5, “msft”); assert.assertequals(500, portfolio.value()); } } si diseccionamos un sistema para poder probarlo de esta forma, resultará más flexible y se podrá reutilizar. la ausencia de conexiones significa que los elementos del sistema se aíslan entre ellos y de otros cambios. este aislamiento hace que comprendamos mejor los elementos del sistema. al minimizar las conexiones de esta forma, nuestras clases cumplen otro principio de diseño: dependency inversion principle (dip) o principio de inversión de dependencias [49] . básicamente afirma que nuestras clases deben depender de abstracciones, no de detalles concretos. en lugar de depender de los detalles de implementación de la clase tokyostockexchange , nuestra clase portfolio depende de la interfaz stockexchange , que representa el concepto abstracto de solicitar el precio actual de una acción. esta abstracción aísla todos los datos concretos de la obtención de dicho precio, incluyendo de dónde se obtiene. bibliografía [rdd] : object design: roles, responsibilities, and collaborations , rebecca wirfs-brock et al., addison-wesley, 2002. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. 203[knuth92] : literate programming , donald e. knuth, center for the study of language and information, leland stanford junior university, 1992. 20411 sistemas por el dr. kevin dean wampler 205«la complejidad es letal. acaba con los desarrolladores y dificulta la planificación, generación y pruebas de los productos». —ray ozzie, cto, microsoft corporation cómo construir una ciudad ¿podría encargarse de todos los detalles por su cuenta? seguramente no. incluso la gestión de una ciudad existente sería demasiado para una sola persona. y aun así, las ciudades funcionan (en la mayoría de los casos). funcionan porque tienen equipos que controlan partes concretas de la ciudad, el alcantarillado, la red eléctrica, el tráfico, la seguridad, las normativas 206urbanísticas, etc. algunos se encargan de aspectos generales y otros se centran en los detalles. las ciudades también funcionan porque disponen de evolucionados niveles de abstracción y modularidad que permiten a individuos y componentes trabajar de forma eficaz, sin necesidad de entender el trasfondo general. aunque los equipos de software se suelen organizar de esta forma, los sistemas en los que trabajan no suelen contar con la misma separación de aspectos y niveles de abstracción. en este capítulo veremos cómo mantener la limpieza en niveles superiores de abstracción, en el sistema. separar la construcción de un sistema de su uso en primer lugar, recuerde que la construcción es un proceso muy diferente al uso. mientras escribo estas líneas, a través de la ventana veo un nuevo hotel en construcción en chicago. hoy instalarán una gran grúa. todos los obreros llevan casco. dentro de un año habrán acabado el hotel. la grúa desaparecerá. el edificio estará terminado, con su reluciente fachada de cristal y su atractiva decoración. la gente que trabajará en él también será diferente. los sistemas de software deben separar el proceso de inicio, en el que se crean los objetos de la aplicación y se conectan las dependencias, de la lógica de ejecución que toma el testigo tras el inicio. el proceso de inicio es un aspecto que toda aplicación debe abordar. es el primero que veremos en este capítulo. la separación de aspectos es una de las técnicas de diseño más antiguas e importantes de nuestra profesión. desafortunadamente, muchas aplicaciones no lo hacen. el código del proceso de inicio se mezcla con la lógica de tiempo de ejecución. veamos un ejemplo típico: public service getservice() { if (service == null) service = new myserviceimpl (…); //¿lo bastante predeterminado para la 207mayoría de los casos? return service; } es la técnica de inicialización/evaluación tardía y tiene sus méritos. no incurrimos en la sobrecarga de la construcción a menos que usemos el objeto realmente, y como resultado el tiempo de inicio se puede acelerar. también evitamos que se devuelva null . sin embargo, ahora tenemos una dependencia en myserviceimpl y todo lo que su constructor requiere (que he omitido). no podemos compilar sin resolver estas dependencias, aunque nunca usemos un objeto de este tipo en tiempo de ejecución. las pruebas también pueden ser un problema. si myserviceimpl es un objeto pesado, tendremos que asegurarnos de asignar el correspondiente test double [50] u objeto simulado al campo de servicio antes de invocar este método en las pruebas de unidad. como la lógica de la construcción se mezcla con el procesamiento normal de tiempo de ejecución, debemos probar todas las rutas de ejecución (como la prueba null y su bloque). al contar con ambas responsabilidades, el método hace más de una cosa, por lo que se incumple el principio de responsabilidad única. lo peor de todo es que no sabemos si myserviceimpl es el objeto correcto en todos los casos. ¿por qué la clase con este método tiene que conocer el contexto global? ¿podemos saber realmente cuál es el objeto correcto que usar aquí? ¿es posible que un mismo tipo sea el correcto para todos los contextos posibles? un caso de inicialización tardía no es un problema serio. sin embargo, suele haber muchos casos de este tipo de configuración en las aplicaciones. por tanto, la estrategia de configuración global (si existe) se disemina por la aplicación, sin apenas modularidad y con una significativa duplicación. si somos diligentes sobre el diseño de sistemas robustos y bien formados, no debemos permitir fallos de modularidad. el proceso de inicio de la construcción y conexión de objetos no es una excepción. debemos modularizar este proceso y asegurarnos de contar con una estrategia global y coherente para resolver las dependencias principales. 208separar main una forma de separar la construcción del uso consiste en trasladar todos los aspectos de la construcción a main o a módulos invocados por main , y diseñar el resto del sistema suponiendo que todos los objetos se han creado y conectado correctamente (véase la figura 11.1). el flujo de control es fácil de seguir. la función main crea los objetos necesarios para el sistema, los pasa a la aplicación y ésta los utiliza. verá que las flechas de dependencia atraviesan la barrera entre main y la aplicación. todas van en la misma dirección, alejándose de main , lo que significa que la aplicación no tiene conocimiento de main ni del proceso de construcción. simplemente espera que todo se haya construido correctamente. figura 11.1. separación de la construcción en main() . factorías en ocasiones, la aplicación tendrá que ser responsable de la creación de un objeto. por ejemplo, en un sistema de procesamiento de pedidos, la aplicación debe crear las instancias lineitem que añadir a order . en este caso, podemos usar el patrón de factoría abstracta [51] para que la aplicación controle cuándo crear lineitem , pero mantener los detalles de dicha construcción separados del código de la aplicación (véase la figura 11.2). 209de nuevo vemos que todas las dependencias se desplazan desde main a la aplicación orderprocessing , lo que significa que la aplicación se desconecta de los detalles de creación de lineitem . esta capacidad se incluye en lineitemfactoryimplementation , en el extremo main de la línea. y sin embargo, la aplicación tiene control total sobre cuándo se crean las instancias lineitem e incluso puede proporcionar argumentos de constructor específicos de la aplicación. figura 11.2. separación de la construcción con una factoría. inyectar dependencias un potente mecanismo para separar la construcción del uso es la inyección de dependencias, la aplicación de inversión de control ( inversion of control o ioc) a la administración de dependencias [52] . la inversión de control pasa responsabilidades secundarias de un objeto a otros dedicados a ese cometido, por lo que admite el principio de responsabilidad única. en el contexto de la administración de dependencias, un objeto no debe ser responsable de instanciar dependencias, sino que debe delegar esta responsabilidad en otro mecanismo autorizado, de modo que se invierte el control. como la configuración es un aspecto global, este mecanismo autorizado suele ser la 210rutina main o un contenedor de propósito especial. las búsquedas jndi son una implementación parcial de la inyección de dependencias, en las que un objeto solicita a un servidor de directorios un servicio que coincida con un nombre concreto. myservice myservice = (myservice)(jndicontext.lookup(“nameofmyservice”)); el objeto invocador no controla el tipo de objeto devuelto (siempre que implemente la interfaz correcta, evidentemente), pero es el que resuelve la dependencia de forma activa. la verdadera inyección de dependencias va un paso más allá. la clase no hace nada directamente para resolver sus dependencias, es totalmente pasiva. por el contrario, ofrece métodos de establecimiento o argumentos de constructor (o ambos) que se usan para inyectar las dependencias. en el proceso de construcción, el contenedor de inyección de dependencias crea instancias de los objetos necesarios (normalmente bajo demanda) y usa los argumentos de constructor o métodos de establecimiento proporcionados para conectar las dependencias. los objetos dependientes empleados suelen especificarse a través de un archivo de configuración o mediante programación en un módulo de construcción de propósito especial. la estructura spring proporciona el contenedor de inyección de dependencias más conocido para java [53] . los objetos que se van a conectar se definen en un archivo de configuración xml y después se solicitan objetos concretos por nombre en código de java. veremos un ejemplo en breve. ¿y qué sucede con las virtudes de la inicialización tardía? en ocasiones es útil con la inyección de dependencias. por un lado, muchos contenedores de inyección de dependencias no crean un objeto hasta que es necesario. por otra parte, muchos de estos contenedores cuentan con mecanismos para invocar factorías o crear proxies que se pueden usar para evaluación tardía y optimizaciones similares [54] . evolucionar las ciudades nacen de pueblos, que nacen de asentamientos. inicialmente, los 211caminos son estrechos y prácticamente inexistentes, después se asfaltan y aumentan de tamaño. los pequeños edificios y solares vacíos se llenan de otros mayores que acaban convirtiéndose en rascacielos. al principio no hay servicios, electricidad, agua, alcantarillado o internet (¡vaya!). estos servicios se añaden cuando aumenta la densidad de población. este crecimiento no es fácil. cuántas veces mientras conduce por una carretera llena de baches y ve una señal de obras no se ha preguntado por qué no la hicieron más ancha desde un principio. no se podía haber hecho de otra forma. ¿quién puede justificar el gasto en una autopista de seis carriles que atraviese un pequeño pueblo como anticipación a un supuesto crecimiento? ¿quién querría una autopista así en su ciudad? conseguir sistemas perfectos a la primera es un mito. por el contrario, debemos implementar hoy, y refactorizar y ampliar mañana. es la esencia de la agilidad iterativa e incremental. el desarrollo controlado por pruebas, la refactorización y el código limpio que generan hace que funcione a nivel del código. ¿pero qué sucede en el nivel del sistema? ¿la arquitectura del sistema no requiere una planificación previa? sin duda no puede aumentar incrementalmente algo sencillo a algo complejo, ¿o sí? los sistemas de software son únicos si los comparamos con los sistemas físicos. sus arquitecturas pueden crecer incrementalmente, si mantenemos la correcta separación de los aspectos. la naturaleza efímera de los sistemas de software hace que sea posible, como veremos. primero nos centraremos en una arquitectura que no separa correctamente los aspectos. las arquitecturas ejb1 y ejb2 originales no separaban correctamente los aspectos y por tanto imponían barreras innecesarias al crecimiento orgánico. imagine un bean de entidad para una clase bank persistente. un bean de entidad es una representación en memoria de datos relacionales, es decir, una fila de una tabla. primero, debe definir una interfaz local (en proceso) o remota (mvj 212independiente), que los clientes usen. el listado 1-1 muestra una posible interfaz local: listado 11-1 una interfaz local ejb2 para el ejb bank. package com.example.banking; import java.util.collections; import javax.ejb.*; public interface banklocal extends java.ejb.ejblocalobject { string getstreetaddrl{} throws ejbexception; string getstreetaddr2{} throws ejbexception; string getcity() throws ejbexception; string getstate() throws ejbexception; string getzipcode() throws ejbexception; void setstreetaddr1(string street1) throws ejbexception; void setstreetaddr2(string street2) throws ejbexception; void setcity(string city) throws ejbexception; void setstate(string state) throws ejbexception; void setzipcode(string zip) throws ejbexception; collection getaccounts() throws ejbexception; void setaccounts(collection accounts) throws ejbexception; void addaccount(accountdto accountdto) throws ejbexception; } mostramos diversos atributos de la dirección de bank y una colección de cuentas del banco, cuyos datos se procesarán por un ejb account diferente. el listado 11-2 muestra la correspondiente clase de implementación del bean bank . listado 11-2 implementación del bean de entidad ejb2. package com.example.banking; import java.util.collections; import javax.ejb.*; public abstract class bank implements javax.ejb.entitybean { // lógica empresarial… public abstract string getstreeraddr1(); public abstract string getstreetaddr2(); public abstract string getcity(); public abstract string getstate(); public abstract string getzipcode(); public abstract void setstreetaddr1(string street1); 213public abstract void setstreetaddr2(string street2); public abstract void setcity(string city); public abstract void setstate(string state); public abstract void setzipcode(string zip); public abstract collection getaccounts(); public abstract void setaccounts(collection accounts); public void addaccount(accountpto accountdto) { initialcontext context = new initialcontext(); accounthomelocal accounthome = context.lookup(“accounthomelocal”); accountlocal account = accounthome.create(accountdto); collection accounts = getaccounts(); accounts.add(account); } // lógica del contenedor ejb public abstract void setid(integer id); public abstract integer getid(); public integer ejbcreate(integer id) {…} public void ejbpostcreate(integer id) {…} // el resto tendría que implementarse pero se deja vacío: public void setentitycontext(entitycontext ctxt) {} public void unsetentitycontext() {} public void ejbactivate() {} public void ejbpassivate() {} public void ejbload() {} public void ejbstore() {} public void ejbremove() {} } no mostramos la correspondiente interfaz localhome , básicamente una factoría usada para crear objetos, no los métodos de consulta bank que pueda añadir. por último, debemos crear uno o varios descriptores de implementación xml que especifiquen los detalles de asignación relacional de objetos en un almacén persistente, el comportamiento deseado de la transacción, limitaciones de seguridad y demás. la lógica empresarial está directamente conectada al contenedor de la aplicación ejb2. debe crear subclases de tipos de contenedor y proporcionar los métodos de ciclo vital necesarios para el contenedor. debido a esta conexión al contenedor pesado, las pruebas de unidad aisladas son complicadas. es necesario imitar el contenedor, algo difícil, o perder demasiado tiempo en la implementación de ejb y pruebas en un servidor real. la reutilización fuera de la arquitectura ejb2 es imposible, debido a esta estrecha conexión. por último, incluso la programación orientada a objetos se ve afectada. un bean no se puede heredar de otro. fíjese en la lógica para 214añadir una nueva cuenta. en bean ejb2 es habitual definir objetos de transferencia de datos ( data transfer objects o dto), estructuras sin comportamiento. esto suele generar tipos redundantes con los mismos datos y requiere código predefinido para copiar datos entre objetos. aspectos transversales la arquitectura ejb2 se acerca a la verdadera separación de aspectos en determinados aspectos. por ejemplo, los comportamientos transaccionales, de seguridad y comportamiento deseados se declaran en los descriptores de implementación, independientemente del código fuente. aspectos como la persistencia suelen cruzar los límites de objeto naturales de un dominio. por lo general intentará mantener todos sus objetos mediante la misma estrategia, por ejemplo con un determinado dbms [55] y no archivos planos, usando determinadas convenciones de nomenclatura para tablas y columnas, una semántica transaccional coherente, etc. en principio, puede razonar su estrategia de persistencia de una forma modular y encapsulada, pero en la práctica tendrá que distribuir el mismo código que implemente la estrategia de persistencia entre varios objetos. usamos el término transversales para este tipo de aspectos. de nuevo, la estructura de persistencia podría ser modular y la lógica de dominios, aislada, también. el problema es la intersección entre ambos dominios. de hecho, la forma en que la arquitectura ejb procesa persistencia, seguridad y transacciones es una programación orientada a aspectos ( aspect oriented programming o aop) [56] anticipada, un enfoque de carácter general para restaurar la modularidad en aspectos transversales. en aop, construcciones modulares denominadas aspectos especifican qué puntos del sistema deben modificar su comportamiento de forma coherente para admitir un determinado aspecto. esta especificación se realiza mediante un sucinto mecanismo de declaración o programación. si usamos la persistencia como ejemplo, podría declarar qué objetos y atributos (o patrones) deben conservarse y después delegar las tareas de persistencia a su estructura de persistencia. las modificaciones de 215comportamiento no son invasivas [57] para el código de destino. veamos tres aspectos o mecanismos similares en java. proxies de java los proxies de java son útiles en casos sencillos, como envolver invocaciones de métodos en objetos o clases concretas. sin embargo, los proxies dinámicos proporcionados en el jdk sólo funcionan con interfaces. para aplicarlos a clases, debe usar una biblioteca de manipulación de código de bytes , como cglib, asm o javassist [58] . el listado 11-3 muestra la estructura de un proxy jdk para ofrecer asistencia de persistencia a nuestra aplicación bank; únicamente abarca los métodos para obtener y establecer la lista de cuentas. listado 11-3 ejemplo de proxy del jdk. // bank.java (eliminando nombres de paquetes…) import java.utils.*; // la abstracción de un banco. public interface bank { collection<account> getaccounts(); void setaccounts(collection<accounts> accounts); } // bankimpl.java import java.utils.*; // “plain old java object” pojo que implementa la abstracción. public class bankimpl implements bank { private list<account> accounts; public collection<account> getaccounts() { return accounts; } public void setaccounts(collections<accounts> accounts) { this.accounts = new arraylist<accounts>(); for (account account: accounts) { this.accounts.add(account); } } } 216// bankproxyhandler.java import java.lang.reflect.*; import java.util.*; // «invocationhandler» necesario para la api de proxy. public class bankproxyhandler implements invocationhandler { private bank bank; public bankhandler (bank bank) { this.bank = bank; } // método definido en invocationhandler public object invoke(object proxy, method method, object[] args) throws throwable { string methodname = method.getname(); if (methodname.equals(“getaccounts”)) { bank.setaccounts(getaccountsfromdatabase()); return bank.getaccounts(); } else if (methodname.equals(“setaccounts”)) { bank.setaccounts((collection<account>) args[0]); setaccountstodatabase(bank.getaccounts()); return null; } else { … } } // muchos detalles: protected collection<account> getaccountsfromdatabase() {…} protected void setaccountstodatabase(collection<account> accounts) {…} } //en otra parte… bank bank = (bank) proxy.newproxyinstance( bank.class.getclassloader(), new class[] { bank.class }, new bankproxyhandler(new bankimpl())); definimos la interfaz bank , que envolvemos en el proxy y un pojo ( plain-old object u objeto sencillo de java), bankimpl , que implementa la lógica empresarial (encontrará más información sobre pojo en un apartado posterior). la api proxy requiere un objeto invocationhandler que invocar para implementar las invocaciones de métodos bank realizadas en el proxy. bankproxyhandler usa la api de reflexión de java para asignar las invocaciones de métodos genéricos a los métodos correspondientes de 217bankimpl , y así sucesivamente. el código es abundante y complejo, incluso para este sencillo caso [59] . el uso de una de las bibliotecas de manipulación de bytes es igualmente complicado. el volumen y la complejidad de este código son dos de los inconvenientes de los proxies . dificultan la creación de código limpio. además, los proxies no ofrecen un mecanismo para especificar puntos de ejecución globales del sistema, imprescindibles para una verdadera solución aop [60] . estructuras aop java puras afortunadamente, gran parte del código predefinido de proxy se puede procesar de forma automática mediante herramientas. los proxies se usan internamente en varias estructuras de java como spring aop y jboss aop, para implementar aspectos en java [61] . en spring, se crea la lógica empresarial en forma de pojo, específicos de su dominio. no dependen de estructuras empresariales (ni de otros dominios). por tanto, son conceptualmente más sencillos y más fáciles de probar. su relativa simplicidad garantiza que se implementen correctamente las correspondientes historias y el mantenimiento y evolución del código en historias futuras. la infraestructura necesaria de la aplicación, incluidos aspectos transversales como persistencia, transacciones, seguridad, almacenamiento en caché y recuperación ante fallos, se incorpora por medio de archivos de configuración declarativos o api. en muchos casos, se especifican aspectos de bibliotecas spring o jboss, en los que la estructura controla el uso de proxies de java o bibliotecas de código de bytes de forma transparente al usuario. estas declaraciones controlan el contenedor de inyección de dependencias, que crea instancias de los principales objetos y las conecta bajo demanda. el listado 11-4 muestra un fragmento tipo de un archivo de configuración de spring v2.5, app.xml [62] . 218listado 11-4 archivo de configuración de spring 2.x <beans> … <bean id=“appdatasource” class=“org.apache.commons.dbcp.basicdatasource” destroy-method=“close” p:driverclassname=“com.mysql.jdbc.driver” p:url=“jdbc:mysql://localhost:3306/mydb” p:username=“me”/> <bean id=“bankdataaccessobject” class=“com.example.banking.persistence.bankdataaccessobject” p:datasource-ref=“appdatasource”/> <bean id=“bank” class=“com.example.banking.model.bank” p:dataaccessobject-ref=“bankdataaccessobject”/> … </beans> cada bean es como una parte de una muñeca rusa anidada, con un objeto de domino de un proxy bank (envuelto) por un objeto de acceso a datos ( data accessor object , dao), que también se procesa a través de un proxy por medio de un origen de datos de controlador jdbc (véase la figura 11.3). figura 11.3. la “muñeca rusa” de elementos de decoración. el cliente cree que invoca getaccounts() en un objeto bank , pero en realidad se comunica con el objeto decorator [63] más externo de un grupo, un objeto que amplía el comportamiento básico del pojo bank . podríamos añadir otros objetos de decoración para transacciones, almacenamiento en caché y demás. en la aplicación, bastan unas líneas para solicitar al contenedor de id los objetos de nivel superior del sistema, como se especifica en el archivo xml. 219xmlbeanfactory bf = new xmlbeanfactory(new classpathresource(“app.xml”, getclass())); bank bank = (bank) bf.getbean(“bank”); como apenas se necesitan líneas de código java específico de spring, la aplicación se desconecta casi por completo de spring y desaparecen los problemas de conexión de sistemas como ejb2. aunque xml puede ser difícil de leer [64] , la directiva especificada en estos archivos de configuración es más sencilla que la complicada lógica de proxy y aspectos oculta a la vista y creada de forma automática. es una arquitectura tan atractiva que sistemas como spring modificaron totalmente el estándar ejb para la versión 3. ejb3 sigue el modelo de spring de aspectos transversales admitidos mediante declaraciones con archivos de configuración xml y/o anotaciones de java 5. el listado 11-5 muestra nuestro objeto bank reescrito en ejb3 [65] . listado 11-5 un ejb bank ejb3. package com.example.banking.model; import javax.persistence; import java.util.arraylist; import java.util.collection; @entity @table(name = “banks”) public class bank implements java.io.serializable { @id @generatedvalue(strategy=generationtype.auto) private int id; @embeddable // un objeto en línea en la fila db de bank public class address { protected string streetaddr1; protected string streetaddr2; protected string city; protected string state; protected string zipcode; } @embedded private address address; @onetomany (cascade = cascadetype.all, fetch = fetchtype.eager, mappedby=“bank”) private collection<account> accounts = new arraylist<account>(); 220public int getid() { return id; } public void setid(int id) { this.id = id; } public void addaccount(account account) { account.setbank(this); accounts.add(account); } public collection<account> getaccounts() { return accounts; } public void setaccounts(collection<account> accounts) { this.accounts = accounts; } } este código es mucho más limpio que el código ejb2 original. se conservan algunos detalles de entidades, en las anotaciones. sin embargo, como no hay información fuera de las anotaciones, el código es limpio y fácil de probar, mantener y demás. parte de la información de persistencia de las anotaciones se puede cambiar a descriptores de implementación xml si es necesario, dejando un pojo puro. si los detalles de asignación de persistencia no cambian con frecuencia, muchos equipos pueden optar por mantener las anotaciones pero con menos obstáculos que si usaran ejb2. aspectos de aspectj por último, la herramienta más completa de separación a través de aspectos es el lenguaje aspectj [66] , una extensión de java que ofrece compatibilidad de primer nivel para aspectos como construcciones de modularidad. los enfoques puros de java proporcionados por spring aop y jboss aop son suficientes en el 80-90 por 100 de los casos en los que los aspectos son útiles. sin embargo, aspectj ofrece un conjunto de herramientas avanzadas y completas para la separación de aspectos. el inconveniente de aspectj es la necesidad de adoptar nuevas herramientas y aprender nuevas construcciones 221del lenguaje. los problemas de adopción se han mitigado parcialmente gracias a la introducción de un formato de anotación de aspectj, en el que se usan anotaciones de java 5 para definir aspectos con código puro de java. además, la estructura spring dispone de funciones que facilitan la incorporación de aspectos basados en anotaciones en un equipo con experiencia limitada con aspectj. el análisis completo de aspectj supera los objetivos de este libro. si necesita más información al respecto, consulte [aspectj], [colyer] y [spring]. pruebas de unidad de la arquitectura del sistema la separación a través de enfoques similares a aspectos no se puede menospreciar. si puede crear la lógica de dominios de su aplicación mediante pojo, sin conexión con los aspectos arquitectónicos a nivel del código, entonces se podrá probar realmente la arquitectura. puede evolucionar de simple a sofisticado, de acuerdo a las necesidades, adoptando nuevas tecnologías bajo demanda. no es necesario realizar un buen diseño por adelantado (big design up front [67] , bduf). de hecho, bduf puede ser negativo ya que impide la adaptación al cambio, debido a la resistencia fisiológica a descartar esfuerzos previos y a la forma en que las decisiones arquitectónicas influyen en la concepción posterior del diseño. los arquitectos deben realizar bduf ya que no resulta factible aplicar cambios arquitectónicos radicales a una estructura física una vez avanzada la construcción [68] . aunque el software se rige por una física propia [69] , es económicamente factible realizar cambios radicales si la estructura del software separa sus aspectos de forma eficaz. esto significa que podemos iniciar un proyecto de software con una arquitectura simple pero bien desconectada, y ofrecer historias funcionales de forma rápida, para después aumentar la infraestructura. algunos de los principales sitios web del mundo han alcanzado una gran disponibilidad y rendimiento por medio de sofisticadas técnicas de almacenamiento en caché, seguridad, virtualización y demás, todo ello de forma eficaz y flexible ya que los diseños mínimamente conectados son adecuadamente simples en cada 222nivel de abstracción y ámbito. evidentemente, no quiere decir que acometamos los proyectos sin timón. debemos tener expectativas del ámbito general, objetivos y un programa, así como la estructura general del sistema resultante. sin embargo, debemos mantener la capacidad de cambiar de rumbo en respuesta a las circunstancias. la arquitectura ejb inicial es una de las api conocidas con un exceso de ingeniería y que compromete la separación de aspectos. incluso las api bien diseñadas pueden ser excesivas cuando no resultan necesarias. una api correcta debe desaparecer de la vista en la mayoría de los casos, para que el equipo dedique sus esfuerzos creativos a las historias implementadas. en caso contrario, las limitaciones arquitectónicas impedirán la entrega eficaz de un valor óptimo para el cliente. para recapitular: una arquitectura de sistema óptima se compone de dominios de aspectos modularizados, cada uno implementado con pojo. los distintos dominios se integran mediante aspectos o herramientas similares mínimamente invasivas. al igual que en el código, en esta arquitectura se pueden realizar pruebas. optimizar la toma de decisiones la modularidad y separación de aspectos permite la descentralización de la administración y la toma de decisiones. en un sistema suficientemente amplio, ya sea una ciudad o un proyecto de software , no debe haber una sola persona que adopte todas las decisiones. sabemos que conviene delegar las responsabilidades en las personas más cualificadas. solemos olvidar que también conviene posponer decisiones hasta el último momento. no es falta de responsabilidad; nos permite tomar decisiones con la mejor información posible. una decisión prematura siempre es subjetiva. si decidimos demasiado pronto, tendremos menos información del cliente, reflexión mental sobre el proyecto y experiencia con las opciones de implementación. 223la agilidad que proporciona un sistema pojo con aspectos modularizados nos permite adoptar decisiones óptimas a tiempo, basadas en los conocimientos más recientes. además, se reduce la complejidad de estas decisiones. usar estándares cuando añadan un valor demostrable la construcción de edificios es una maravilla para la vista debido al ritmo empleado (incluso en invierno) y los extraordinarios diseños posibles gracias a la tecnología actual. la construcción es un sector maduro con elementos, métodos y estándares optimizados que han evolucionado bajo presión durante siglos. muchos equipos usaron la arquitectura ejb2 por ser un estándar, aunque hubiera bastado con diseños más ligeros y sencillos. he visto equipos obsesionados con estándares de moda y que se olvidaron de implementar el valor para sus clientes. los estándares facilitan la reutilización de ideas y componentes, reclutan individuos con experiencia, encapsulan buenas ideas y conectan componentes. sin embargo, el proceso de creación de estándares puede tardar demasiado para el sector, y algunos pierden el contacto con las verdaderas necesidades de aquello para los que están dirigidos. los sistemas necesitan lenguajes específicos del dominio la construcción de edificios, como muchos dominios, ha desarrollado un rico lenguaje con vocabularios, frases y patrones [70] que comunican información esencial de forma clara y concisa. en el mundo del software , ha renacido el interés por crear lenguajes específicos del dominio ( domain-specific languages o dsl) [71] , pequeños lenguajes independientes de creación de secuencias de comandos o api de lenguajes estándar que permiten crear 224código que se lea de una forma estructurada, como lo escribiría un experto del dominio. un buen dsl minimiza el vacío de comunicación entre un concepto de dominio y el código que lo implementa, al igual que las prácticas ágiles optimizan la comunicación entre un equipo y los accionistas del proyecto. si tiene que implementar la lógica de dominios en el mismo lenguaje usado por un experto del dominio, hay menos riesgo de traducir incorrectamente el dominio en la implementación. los dsl, si se usan de forma eficaz, aumentan el nivel de abstracción por encima del código y los patrones de diseño. permiten al desarrollador revelar la intención del código en el nivel de abstracción adecuado. los lenguajes específicos del dominio permiten expresar como pojo todos los niveles de abstracción y todos los dominios de la aplicación, desde directivas de nivel superior a los detalles más mínimos. conclusión los sistemas también deben ser limpios. una arquitectura invasiva afecta a la lógica de dominios y a la agilidad. si la lógica de dominios se ve afectada, la calidad se resiente, ya que los errores se ocultan y las historias son más difíciles de implementar. si la agilidad se ve comprometida, la productividad sufre y las ventajas de tdd se pierden. en todos los niveles de abstracción, los objetivos deben ser claros. esto sólo sucede si crea pojo y usa mecanismos similares a aspectos para incorporar otros aspectos de implementación de forma no invasiva. independientemente de que diseñe sistemas o módulos individuales, no olvide usar los elementos más sencillos que funcionen. bibliografía [alexander] : christopher alexander, a timeless way of building , oxford university press, new york, 1979. 225[aosd] : puerto de desarrollo de software orientado a aspectos, http://aosd.net. [asm] : página de asm, http://asm.objectweb.org/. [aspectj] : http: //eclipse.org/aspectj. [cglib] : biblioteca de generación de código, http://cglib.sourceforge.net/. [colyer] : adrian colyer, andy clement, george hurley, mathew webster, eclipse aspectj , person education, inc., upper saddle river, nj, 2005. [dsl] : lenguaje de programación específico del dominio, http://es.wikipedia.org/wiki/lenguaje_espec%c3%adfico_del_dominio. [fowler] : inversión de contenedores de control y el patrón de inyección de dependencias (http://martinfowler.com/articles/injection.html). [goetz] : brian goetz, java theory and practice: decorating with dynamic proxies , http://www.ibm.com/developerworks/java/library/j- jtp08305.html. [javassist] : página de javassist, http://www.csg.is.titech.ac.jp/chiba/javassist/. [jboss] : página de jboss, http: //jboss.org. [jmock] : jmock: una biblioteca de objetos mock ligeros para java, http://jmock.org. [kolence] : kenneth w. kolence, software physics and computer performance measurements, proceedings of the acm annual conference-volume 2, boston, massachusetts, pp. 1024-1040,1972. [spring] : the spring framework , http://www.springframework.org. [mezzaros07] : xunit patterns , gerard mezzaros, addison-wesley, 2007. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 22612 emergencia con jeff langr limpieza a través de diseños emergentes 227imagine que existieran cuatro sencillas reglas para crear diseños de calidad. imagine que siguiéndolas accediera a la estructura y al diseño de su código y facilitara la aplicación de principios como srp y dip. imagine que estas cuatro reglas facilitaran la emergencia de diseños de calidad. muchos consideramos que las cuatro reglas de kent beck de diseño sencillo [72] son fundamentales para crear un software bien diseñado. según kent, un diseño es sencillo si cumple estas cuatro reglas: ejecuta todas las pruebas. no contiene duplicados. expresa la intención del programador. minimiza el número de clases y métodos. describiremos estas reglas en orden de importancia. primera regla del diseño sencillo: ejecutar todas las pruebas en primer lugar, un diseño debe generar un sistema que actúe de la forma prevista. un sistema puede tener un diseño perfecto sobre el papel pero si no existe una forma sencilla de comprobar que realmente funciona de la forma esperada, el esfuerzo sobre el papel es cuestionable. un sistema minuciosamente probado y que supera todas las pruebas en todo momento se denomina sistema testable. es una afirmación obvia, pero importante. los sistemas que no se pueden probar no se pueden verificar, y un sistema que no se puede verificar no debe implementarse. afortunadamente, crear sistemas testables hace que diseñemos clases de tamaño reducido y un solo cometido. resulta más sencillo probar clases que cumplen el srp. cuantas más pruebas diseñemos, más nos acercaremos a elementos más fáciles de probar. por lo tanto, hacer que nuestro sistema se pueda probar nos ayuda a crear mejores diseños. las conexiones rígidas dificultan la creación de pruebas. del mismo modo, cuantas más pruebas creemos, más usaremos principios como dip y 228herramientas con inyección de dependencias, interfaces y abstracción para minimizar dichas conexiones. nuestros diseños mejorarán todavía más. en especial, seguir una sencilla regla que afirme que debemos realizar pruebas y ejecutarlas continuamente afecta el cumplimiento por parte de nuestro sistema de los principales objetivos de la programación orientada a objetos de baja conexión y elevada cohesión. la creación de pruebas conduce a obtener mejores diseños. reglas 2 a 4 del diseño sencillo: refactorizar una vez creadas las pruebas, debemos mantener limpio el código y las clases. para ello, refactorizamos el código progresivamente. tras añadir unas líneas, nos detenemos y reflejamos el nuevo diseño. ¿ha empeorado? en caso afirmativo, lo limpiamos y ejecutamos las pruebas para comprobar que no hay elementos afectados. la presencia de las pruebas hace que perdamos el miedo a limpiar el código y que resulte dañado . en la fase de refactorización, podemos aplicar todos los aspectos del diseño de software correcto. podemos aumentar la cohesión, reducir las conexiones, separar las preocupaciones, modularizar aspectos del sistema, reducir el tamaño de funciones y clases, elegir nombres más adecuados, etc. aquí también aplicamos las tres últimas reglas del diseño correcto: eliminar duplicados, garantizar la capacidad de expresión y minimizar el número de clases y métodos. eliminar duplicados los duplicados son los mayores enemigos de un sistema bien diseñado. suponen un esfuerzo adicional, riesgos añadidos y una complejidad a mayores innecesaria. los duplicados se manifiestan de diversas formas. las líneas de código similar pueden modificarse para que parezcan refactorizadas, y hay otras formas de duplicación como la de implementación. por ejemplo, podríamos tener dos métodos en una clase de colección: 229int size() {} boolean isempty() {} podríamos tener implementaciones separadas para cada método. el método isempty podría controlar un valor booleano y size un contador, o podemos eliminar la duplicación y vincular isempty a la definición de size : boolean isempty() { return 0 == size(); } la creación de un sistema limpio requiere la eliminación de duplicados, aunque sean unas cuantas líneas de código. fíjese en el siguiente ejemplo: public void scaletoonedimension { float desireddimension, float imagedimension) { if (math.abs(desireddimension - imagedimension) < errorthreshold) return; float scalingfactor = desireddimension / imagedimension; scalingfactor = (float)(math.floor(scalingfactor * 100) * 0.01f); renderedop newimage = imageutilities.getscaledimage( image, scalingfactor, scalingfactor); image.dispose(); system.gc(); image = newimage; } public synchronized void rotate(int degrees) { renderedop newimage = imageutilities.getrotatedimage( image, degrees); image.dispose(); system.gc(); image = newimage; } para mantener limpio este sistema, debemos eliminar la pequeña cantidad de duplicación entre los métodos scaletoonedimension y rotate : public void scaletoonedimension ( float desireddimension, float imagedimension) { if (math.abs(desireddimension - imagedimension) < errorthreshold) return; float scalingfactor = desireddimension / imagedimension; scalingfactor = (float)(math.floor(scalingfactor * 100) * 0.01f); replaceimage(imageutilities.getscaledimage( image, scalingfactor, scalingfactor)); } public synchronized void rotate (int degrees) { replaceimage(imageutilities.getrotatedimage(image, degrees)); } private void replaceimage(renderedop newimage) ( 230image.dispose(); system.gc(); image = newimage; } al extraer a este reducido nivel, comenzamos a detectar incumplimientos de srp. por ello, podríamos cambiar un nuevo método extraído a otra clase. esto aumenta su visibilidad. otro miembro del equipo puede ver la necesidad de volver a extraer el nuevo método y usarlo en otro contexto diferente. esta reutilización mínima puede reducir considerablemente la complejidad del sistema. saber cómo lograrlo es fundamental para alcanzar la reutilización a gran escala. el patrón método de plantilla [73] es una técnica muy utilizada para eliminar duplicados de nivel superior. por ejemplo: public class vacationpolicy { public void accrueusdivisionvacation() { // código para calcular las vacaciones en función de las horas trabajadas //… // código para garantizar que las vacaciones cumplen los mínimos legales //… // código para aplicar vacation al registro payroll //… } public void accrueeudivisionvacation() { // código para calcular las vacaciones en función de las horas trabajadas //… // código para garantizar que las vacaciones cumplen los mínimos legales //… // código para aplicar vacation al registro payroll //… } } el código entre accrueusdivisionvacation y accrueeuropeandivisionvacation es prácticamente idéntico, a excepción del cálculo de mínimos legales. esa parte del algoritmo cambia en función del tipo de empleado. podemos eliminar la duplicación evidente si aplicamos el patrón de método de plantilla : abstract public class vacationpolicy { public void accruevacation() { calculatebasevacationhours(); alterforlegalminimums(); applytopayroll(); } 231private void calculatebasevacationhours() { /* … */ }; abstract protected void alterforlegalminimums(); private void applytopayroll(); { /* … */ }; } public class usvacationpolicy extends vacationpolicy { @override protected void alterforlegalminimums() { // lógica específica de ee.uu. } } public class euvacationpolicy extends vacationpolicy { @override protected void alterforlegalminimums() { // lógica específica de la ue. } } las subclases ocupan el vacío generado en el algoritmo accruevacation y solamente proporcionan los datos que no están duplicados. expresividad muchos tenemos experiencia con código enrevesado. muchos lo hemos creado. es fácil crear código que entendamos, ya que durante su creación nos centramos en comprender el problema que intentamos resolver. los encargados de mantener el código no lo comprenderán de la misma forma. el principal coste de un proyecto de software es su mantenimiento a largo plazo. para minimizar los posibles defectos al realizar cambios, es fundamental que comprendamos el funcionamiento del sistema. al aumentar la complejidad de los sistemas, el programador necesita más tiempo para entenderlo y aumentan las posibilidades de errores. por tanto, el código debe expresar con claridad la intención de su autor. cuando más claro sea el código, menos tiempo perderán otros en intentar comprenderlo. esto reduce los defectos y el coste de mantenimiento. puede expresarse si elige nombres adecuados. el objetivo es ver el nombre de una clase y función, y que sus responsabilidades no nos sorprendan. también puede expresarse si reduce el tamaño de funciones y clases. al hacerlo, resulta más sencillo asignarles nombres, crearlas y comprenderlas. 232otra forma de expresarse es usar una nomenclatura estándar. los patrones de diseño, por ejemplo, se basan en la comunicación y en la capacidad de expresión. al usar los nombres de patrones estándar, como command o visitor , en los nombres de las clases que implementan dichos patrones puede describir sucintamente su diseño a otros programadores. las pruebas de unidad bien escritas también son expresivas. uno de los principales objetivos de una prueba es servir de documentación mediante ejemplos. los que lean las pruebas deben entender con facilidad para qué sirve una clase. pero la forma más importante de ser expresivo es la práctica. a menudo, conseguimos que el código funcione y pasamos al siguiente problema sin detenernos en facilitar la lectura del código para otros. no olvide que seguramente sea el próximo que lea el código. por tanto, afronte su creación con orgullo. dedique tiempo a sus funciones y clases. seleccione nombres mejores, divida las funciones extensas en otras más reducidas y cuide su obra. el cuidado es un recurso precioso. clases y métodos mínimos incluso conceptos tan básicos como la eliminación de código duplicado, la expresividad del código y srp pueden exagerarse. en un esfuerzo por reducir el tamaño de clases y métodos, podemos crear demasiadas clases y métodos reducidos. esta regla también sugiere minimizar la cantidad de funciones y clases. una gran cantidad de clases y métodos suele indicar un dogmatismo sin sentido. imagine un estándar de código que insista en la creación de una interfaz para todas las clases, o a programadores que insisten en qué campos y comportamientos siempre deben separarse en clases de datos y clases de comportamiento. este dogma debe evitarse y cambiarse por un enfoque más pragmático. nuestro objetivo es reducir el tamaño general del sistema además del tamaño de clases y funciones, pero recuerde que esta regla es la de menor 233prioridad de las cuatro. por ello, aunque sea importante reducir la cantidad de clases y funciones, es más importante contar con pruebas, eliminar duplicados y expresarse correctamente. conclusión ¿existen prácticas sencillas que puedan reemplazar a la experiencia? por supuesto que no. sin embargo, las prácticas descritas en este capítulo y en el libro son una forma cristalizada de décadas de experiencia de muchos autores. la práctica del diseño correcto anima y permite a los programadores adoptar principios y patrones que en caso contrario tardarían años en aprender. bibliografía [xpe] : extreme programming explained: embrace change , kent beck, addison wesley, 1999. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 23413 concurrencia por brett l. schuchert 235“los objetos son abstracciones de procesamiento. los subprocesos son abstracciones de programaciones”. —james o. coplien [74] la creación de programas concurrentes limpios es complicada, muy complicada. es mucho más sencillo crear código que se ejecute en un mismo proceso. también es fácil crear código de subprocesamiento múltiple que parezca correcto en la superficie pero que esté dañado a niveles más profundos. este código funciona correctamente hasta que el sistema se somete a determinadas presiones. en este capítulo analizaremos la necesidad de la programación concurrente y sus dificultades. tras ello, presentaremos diversas recomendaciones para superar dichas dificultades y crear código concurrente limpio. por último, finalizaremos con los problemas relacionados con la prueba de código concurrente. la concurrencia limpia es un tema complejo, merecedor de un libro propio. aquí, intentaremos ofrecer una visión general, que después ampliaremos en el apéndice a. si simplemente tiene curiosidad por el tema, le bastará con este capítulo. si necesita entender la concurrencia a un nivel más profundo, consulte también el apéndice. ¿por qué concurrencia? la concurrencia es una estrategia de desvinculación. nos permite desvincular lo que se hace de dónde se hace. en aplicación de un solo proceso, el qué y el cuándo están tan firmemente vinculados que el estado de la aplicación se puede determinar analizando la huella de la pila. un programador que depure este tipo de sistemas puede definir un punto de interrupción (o varios) y saber el estado de la aplicación en función del punto al que se llegue. la desvinculación del qué del dónde puede mejorar considerablemente el rendimiento y la estructura de una aplicación. desde un punto de vista estructural, la aplicación parece una serie de equipos colaboradores y no un gran bucle principal. esto puede hacer que el sistema sea más fácil de 236comprender y ofrece diversas formas de separar las preocupaciones. pongamos por caso el modelo servlet estándar de aplicaciones web. estos sistemas se ejecutan bajo un contenedor web o ejb que gestiona parcialmente la concurrencia. los servlet se ejecutan de forma asíncrona cuando se reciben solicitudes web. el programador de los servlet no tiene que gestionar todas las solicitudes entrantes. en principio, la ejecución de cada servlet vive en un mundo propio y se desvincula del resto. evidentemente, si fuera tan sencillo, no necesitaríamos este capítulo. de hecho, la desvinculación proporcionada por los contenedores web dista mucho de ser perfecta. los programadores de servlet deben asegurarse de que sus programas sean correctos. no obstante, las ventajas estructurales del modelo de servlet son significativas. pero la estructura no es el único motivo para adoptar la concurrencia. algunos sistemas tienen limitaciones de tiempo de respuesta y producción que requieren soluciones concurrentes manuales. imagine un dispositivo para añadir información, con un solo proceso, que obtiene datos de distintos sitios web y los combina en un resumen diario. al tener un solo proceso, accede por turnos a cada sitio web y siempre termina uno antes de comenzar el siguiente. su recorrido diario debe ejecutarse en menos de 24 horas. sin embargo, al añadir nuevos sitios web, el tiempo aumenta hasta necesitarse más de 24 horas para recopilar todos los datos. el único proceso implica una prolongada espera para completar la e/s. podríamos mejorar el rendimiento con ayuda de un algoritmo de subprocesamiento múltiple que visite más de un sitio web por vez. imagine un sistema que procesa un usuario por vez y sólo requiere un segundo por cada uno. su capacidad de respuesta es válida para un número reducido de usuarios pero si aumenta, también lo hace el tiempo de respuesta del sistema. ningún usuario querrá esperar a otros 150. podríamos mejorar el tiempo de respuesta de este sistema procesando varios usuarios a la vez. imagine un sistema que interprete grandes conjuntos de datos pero que sólo ofrezca una solución completa tras procesarlos todos. se podría procesar cada conjunto de datos en un equipo distinto, para poder procesarlos todos en paralelo. 237mitos e imprecisiones también existen motivos evidentes para adoptar la concurrencia aunque, como indicamos antes, sea complicada. si no presta la suficiente atención, pueden darse casos desagradables. veamos los mitos e imprecisiones más habituales: la concurrencia siempre mejora el rendimiento : en ocasiones lo hace pero sólo cuando se puede compartir tiempo entre varios procesos o procesadores. ninguna situación es trivial. el diseño no cambia al crear programas concurrentes : de hecho, el diseño de un algoritmo concurrente puede ser muy distinto al de un sistema de un solo proceso. la desvinculación entre el qué y el cuándo suele tener un efecto importante en la estructura del sistema. no es importante entender los problemas de concurrencia al trabajar con un contenedor web o ejb : en realidad, debe saber lo que hace su contenedor y protegerlo de problemas de actualizaciones concurrentes y bloqueo, como veremos después. veamos otros aspectos relacionados con la creación de software concurrente: la concurrencia genera cierta sobrecarga , tanto en rendimiento como en la creación de código adicional. la concurrencia correcta es compleja , incluso para problemas sencillos. los errores de concurrencia no se suelen repetir , de modo que se ignoran [75] en lugar de considerarse verdaderos problemas. la concurrencia suele acarrear un cambio fundamental de la estrategia de diseño . desafíos ¿qué hace que la programación concurrente sea tan complicada? fíjese en la 238siguiente clase: public class x { private int lastidused; public int getnextid() { return ++lastidused; } } imagine que creamos una instancia x , establecemos el campo lastidused en 42 y después compartimos la instancia entre dos procesos. imagine ahora que esos dos procesos invocan el método getnextid() ; hay tres resultados posibles: el primer proceso obtiene el valor 43, el segundo el valor 44 y lastidused es 44. el primer proceso obtiene el valor 44, el segundo el valor 43 y lastidused es 44. el primer proceso obtiene el valor 43, el segundo el valor 43 y lastidused es 43. el sorprendente tercer resultado [76] se produce cuando los dos procesos coinciden. se debe a que pueden adoptar varias rutas posibles en una línea de código de java y algunas generan resultados incorrectos. ¿cuántas rutas distintas existen? para responder, debemos entender lo que hace el compilador justo a tiempo con el código de bytes generado, y lo que el modelo de memoria de java considera atómico. una rápida respuesta, con el código de bytes generado, es que existen 12 870 rutas de ejecución diferentes [77] para los dos procesos ejecutados en el método getnextid . si el tipo de lastidused cambia de int a long , el número de rutas asciende a 2 704 156. evidentemente, muchas generan resultados válidos. el problema es que algunas no lo hacen . principios de defensa de la concurrencia a continuación le mostramos una serie de principios y técnicas para proteger 239a sus sistemas de los problemas del código concurrente. principio de responsabilidad única (srp) srp [78] establece que un método, clase o componente sólo debe tener un motivo para cambiar. el diseño de concurrencia es lo bastante complejo como para ser un motivo de cambio con derecho propio y, por tanto, debe separarse del resto del código. desafortunadamente, es habitual incrustar los detalles de la implementación de concurrencia directamente en otro código de producción. tenga en cuenta los siguientes aspectos: el código relacionado con la concurrencia tiene su propio ciclo de desarrollo , cambios y ajustes. el código relacionado con la concurrencia tiene sus propios desafíos , diferentes y más complicados, que los del código no relacionado con la concurrencia. el número de formas en las que el código incorrecto basado en la concurrencia puede fallar lo complica ya de por sí, sin la carga añadida del código de aplicación circundante. recomendación : separe el código de concurrencia del resto del código [79] . corolario: limitar el ámbito de los datos como hemos visto, dos procesos que modifican el mismo campo u objeto compartido pueden interferir entre ellos y provocar un comportamiento inesperado. una solución consiste en usar la palabra clave synchronized para proteger una sección importante del código que use el objeto compartido, aunque conviene limitar la cantidad de estas secciones. cuantos más puntos actualicen datos compartidos, es más probable que: 240se olvide de proteger uno o varios de esos puntos, y se dañe el código que modifica los datos compartidos. se duplique el esfuerzo necesario para garantizar la protección de todos los elementos (incumplimiento de dry [80] ). resulta complicado determinar el origen de los fallos, que por naturaleza son difíciles de detectar. recomendación : encapsule los datos y limite el acceso a los datos compartidos . corolario: usar copias de datos una forma de evitar datos compartidos es no compartirlos. en algunos casos se pueden copiar objetos y procesarlos como si fueran de sólo lectura. en otros, se pueden copiar objetos, recopilar los resultados de varios procesos en las copias y después combinar los resultados en un mismo proceso. si existe una forma sencilla de evitar los objetos compartidos, el código resultante tendrá menos problemas. puede que le preocupe el coste de la creación de objetos adicionales. merece la pena experimentar y comprobar si es un problema real. no obstante, si el uso de copias de objetos permite al código evitar la sincronización, las ventajas de evitar el bloque compensan la creación adicional y la sobrecarga de la recolección de elementos sin usar. corolario: los procesos deben ser independientes pruebe a crear el código de sus procesos de forma que cada uno sea independiente y no comparta datos con otros. cada uno procesa una solicitud cliente y todos los datos necesarios provienen de un origen sin compartir y se almacenan como variables locales. de este modo, los procesos se comportan como si fueran los únicos del mundo y no existieran requisitos de sincronización. por ejemplo, las subclases de httpservlet reciben toda su información como parámetros pasados en los métodos doget y dopost . esto hace que cada servlet actúe como si dispusiera de su propio equipo. mientras 241el código del servlet sólo use variables locales, es imposible que cause problemas de sincronización. evidentemente, muchas aplicaciones que usan servlet se topan con recursos compartidos como conexiones de base de datos. recomendación : intente dividir los datos en subconjuntos independientes que se puedan procesar en procesos independientes, posiblemente en distintos procesadores . conocer las bibliotecas java 5 ofrece muchas mejoras para el desarrollo concurrente con respecto a versiones anteriores. existen diversos aspectos que tener en cuenta a la hora de crear código de procesos en java 5: usar las colecciones compatibles con procesos proporcionadas. usar la estructura de ejecución de tareas no relacionadas. usar soluciones antibloqueo siempre que sea posible. varias clases de bibliotecas no son compatibles con procesos. colecciones compatibles con procesos en los albores de java, doug lea escribió el conocido libro [81]  concurrent programming in java . al mismo tiempo, desarrolló varias colecciones compatibles con procesos, que posteriormente pasaron a formar parte del jdk en el paquete java.util.concurrent . las colecciones de dicho paquete son compatibles con casos de procesos múltiples y tienen un rendimiento adecuado. de hecho, la implementación concurrenthashmap tiene mejor rendimiento que hashmap en la mayoría de los casos. también permite lecturas y escrituras simultáneas, y dispone de métodos que admiten operaciones de composición habituales que en caso contrario serian incompatibles con subprocesos. si java 5 es su entorno de desarrollo, comience con concurrenthashmap . 242existen otras clases añadidas para admitir diseño avanzado de concurrencia. veamos algunos ejemplos: reentrantlock bloqueo que se puede adquirir en un método y liberar en otro. semaphore una implementación del clásico semáforo, un bloqueo con un contador. countdownlatch bloqueo que espera un número de eventos antes de liberar todos los subprocesos retenidos. de este modo todos tienen la misma oportunidad de iniciarse al mismo tiempo. recomendación : revise las clases de las que disponga. en el caso de java, debe familiarizarse con java.util.concurrent, java.util.concurrent.atomic y java.util.concurrent.locks . conocer los modelos de ejecución existen diversas formas de dividir el comportamiento de una aplicación concurrente. para describirlos debe conocer ciertas definiciones básicas. recursos vinculados recursos de tamaño o número fijo usados en un entorno concurrente, como por ejemplo conexiones de base de datos y búfer de lectura/escritura de tamaño fijo. exclusión mutua sólo un proceso puede acceder a datos o a un recurso compartido por vez. inanición se impide que un proceso o grupo de procesos continúen demasiado tiempo o indefinidamente. por ejemplo, si permite primero la ejecución de los procesos más rápidos, los que se ejecutan durante más tiempo pueden perecer de inanición si los primeros no terminan nunca. bloqueo dos o más procesos esperan a que ambos terminen. cada proceso tiene un recurso y ninguno puede terminar hasta que obtenga el otro recurso. bloqueo procesos bloqueados, intentando realizar su labor pero 243activo estorbándose unos a otros. por motivos de resonancia, los procesos siguen intentando avanzar pero no pueden durante demasiado tiempo, o de forma indefinida. tras mostrar estas definiciones, ya podemos describir los distintos modelos de ejecución empleados en la programación concurrente. productor-consumidor [82] uno o varios procesos productores crean trabajo y lo añaden a un búfer o a una cola. uno o varios procesos consumidores adquieren dicho trabajo de la cola y lo completan. la cola entre productores y consumidores es un recurso vinculado, lo que significa que los productores deben esperar a que se libere espacio en la cola antes de escribir y los consumidores deben esperar hasta que haya algo que consumir en la cola. la coordinación entre productores y consumidores a través de la cola hace que unos emitan señales a otros. los productores escriben en la cola e indican que ya no está vacía. los consumidores leen de la cola e indican que ya no está llena. ambos esperan la notificación para poder continuar. lectores-escritores [83] cuando un recurso compartido actúa básicamente como fuente de información para lectores pero ocasionalmente se actualiza por parte de escritores, la producción es un problema. el énfasis de la producción puede provocar la inanición y la acumulación de información caducada. las actualizaciones pueden afectar a la producción. la coordinación de lectores para que no lean algo que un escritor está actualizando y viceversa es complicada. los escritores tienden a bloquear a los lectores durante periodos prolongados, lo que genera problemas de producción. el desafío consiste en equilibrar las necesidades de ambos para satisfacer un funcionamiento correcto, proporcionar una producción razonable y evitar la inanición. una sencilla estrategia hace que los escritores esperen hasta que deje de haber lectores antes de realizar una actualización. si hay lectores 244continuos, los escritores perecen de inanición. por otra parte, si hay escritores frecuentes y se les asigna prioridad, la producción se ve afectada. determinar el equilibrio y evitar problemas de actualización concurrente es el objetivo de este modelo. la cena de los filósofos [84] imagine varios filósofos sentados alrededor de una mesa redonda. a la izquierda de cada uno hay un tenedor. en el centro de la mesa, una gran fuente de espaguetis. los filósofos pasan el tiempo pensando a menos que tengan hambre. cuando tienen hambre, utilizan los tenedores situados a ambos lados para comer. no pueden comer a menos que tengan dos tenedores. si el filósofo situado a la derecha o izquierda de otros ya tiene uno de los tenedores que necesita, tendrá que esperar a que termine de comer y deje los tenedores. cuando un filósofo termina de comer, vuelve a colocar los tenedores en la mesa hasta que vuelve a tener hambre. cambie los filósofos por procesos y los tenedores por recursos y tendrá un problema habitual en muchas aplicaciones en las que los procesos compiten por recursos. a menos que se diseñen correctamente, los sistemas que compiten de esta forma experimentan problemas de bloqueo, bloqueo mutuo, producción y degradación de la eficacia. la mayoría de problemas de concurrencia que encontrará serán alguna variante de éstos. analice los algoritmos y cree soluciones propias para estar preparado cuando surjan problemas de concurrencia. recomendación : aprenda estos algoritmos básicos y comprenda sus soluciones . dependencias entre métodos sincronizados las dependencias entre métodos sincronizados generan sutiles errores en el código concurrente. java cuenta con synchronized , que protege métodos individuales. no obstante, si hay más de un método sincronizado en la misma clase compartida, puede que su sistema sea incorrecto [85] . 245recomendación : evite usar más de un método en un objeto compartido . en ocasiones tendrá que usar más de un método en un objeto compartido. en ese caso, hay tres formas de crear código correcto: bloqueo basado en clientes : el cliente debe bloquear al servidor antes de invocar el primer método y asegurarse de que el alcance del bloque incluye el código que invoque el último método. bloqueo basado en servidores : debe crear un método en el servidor que bloquee el servidor, invoque todos los métodos y después anule el bloqueo. el cliente debe invocar el nuevo método. servidor adaptado : cree un intermediario que realice el bloque. es un ejemplo de bloqueo basado en servidores en el que el servidor original no se puede modificar. reducir el tamaño de las secciones sincronizadas la palabra clave synchronized presenta un bloqueo. todas las secciones de código protegidas por el mismo bloque sólo tendrán un proceso que las ejecute en un momento dado. los bloqueos son costosos ya que generan retrasos y añaden sobrecarga. por ello, no conviene colapsar el código con instrucciones synchronized . por otra parte, las secciones críticas [86] deben protegerse, de modo que debemos diseñar nuestro código con el menor número posible de secciones críticas. algunos programadores intentan lograrlo ampliando el tamaño de sus secciones críticas. sin embargo, al ampliar la sincronización más allá de la sección crítica mínima aumentan los problemas y afecta negativamente al rendimiento [87] . recomendación : reduzca al máximo el tamaño de las secciones synchronized . crear código de cierre correcto es complicado 246crear un sistema activo y que se ejecute indefinidamente es distinto a crear algo que funcione de forma temporal y después se cierre correctamente. entre los problemas más habituales destacan los bloqueos [88] , con procesos que esperan una señal para continuar que nunca se produce. imagine, por ejemplo, un sistema con un proceso principal que genera varios procesos secundarios y que espera a que todos terminen antes de liberar sus recursos y cerrarse. ¿qué sucede si uno de los procesos secundarios está bloqueado? el principal esperará indefinidamente y el sistema nunca se cerrará. imagine ahora un sistema similar al que se le indica que se cierre. el proceso principal indica a todos los secundarios que abandonen sus tareas y terminen. pero imagine que dos procesos secundarios funcionan como par productor/consumidor y que el productor recibe una señal del principal y se cierra rápidamente. el consumidor espera un mensaje del productor y puede quedar bloqueado en un estado en el que no recibe la señal del principal, lo que también impide que éste finalice. son situaciones habituales. por tanto, si tiene que crear código concurrente con cierres correctos, tendrá que dedicar tiempo a que el cierre se produzca de forma correcta. recomendación : planifique con antelación el proceso de cierre y pruébelo hasta que funcione. le llevará más tiempo del que espera. repase los algoritmos existentes porque será complicado . probar código con procesos demostrar que el código es correcto no resulta práctico. las pruebas no garantizan su corrección. sin embargo, las pruebas adecuadas pueden minimizar los riesgos, en especial en aplicaciones de un solo proceso. cuando hay dos o más procesos que usan el mismo código y trabajan con datos compartidos, la situación se vuelve más compleja. recomendación : cree pruebas que puedan detectar problemas y ejecútelas periódicamente, con distintas configuraciones de programación y del sistema, y cargas. si las pruebas fallan, identifique el fallo. no lo ignore 247porque las pruebas superen una ejecución posterior . hay muchos factores que tener en cuenta. veamos algunas recomendaciones concretas: considere los fallos como posibles problemas de los procesos. consiga que primero funcione el código sin procesos. el código con procesos se debe poder conectar a otros elementos. el código con procesos debe ser modificable. ejecute con más procesos que procesadores. ejecute en diferentes plataformas. diseñe el código para probar y forzar fallos. considerar los fallos como posibles problemas de los procesos el código con procesos hace que fallen elementos que no deberían fallar. muchos desarrolladores desconocen cómo interactúan los procesos con otro tipo de código. los problemas del código con procesos pueden mostrar sus síntomas una vez cada mil o un millón de ejecuciones. los intentos por repetir los sistemas pueden resultar frustrantes, lo que suele provocar que los programadores consideren el fallo como algo aislado. es recomendable asumir que los fallos aislados no existen. cuanto más los ignore, mayor será la cantidad de código que se acumule sobre un enfoque defectuoso. recomendación : no ignore los fallos del sistema como algo aislado . conseguir que primero funcione el código sin procesos puede parecer evidente pero no está de más recordarlo. asegúrese de que el código funciona fuera de sus procesos. por lo general, esto significa crear algunos pojo que los procesos deban invocar. los pojo no son compatibles con los procesos y por tanto se pueden probar fuera de su entorno. conviene 248incluir en los pojo la mayor cantidad posible del sistema. recomendación : no intente identificar fallos de procesos y que no sean de procesos al mismo tiempo. asegúrese de que su código funciona fuera de los procesos . el código con procesos se debe poder conectar a otros elementos cree el código compatible con la concurrencia de forma que se pueda ejecutar en distintas configuraciones: un proceso, varios procesos y variarlo durante la ejecución. el código con procesos interactúa con algo que puede ser real o probado. ejecutar con pruebas dobles ejecutadas de forma rápida, lenta y variable. configurar pruebas que ejecutar en diferentes iteraciones. recomendación : el código con procesos debe poder conectar a otros elementos y ejecutar en distintas configuraciones . el código con procesos debe ser modificable la obtención del equilibrio adecuado de procesos suele requerir operaciones de ensayo y error. en las fases iniciales, compruebe el rendimiento del sistema bajo diferentes configuraciones. permita que se puedan modificar los distintos procesos y también durante la ejecución del sistema. también puede permitir la modificación automática en función de la producción y la utilización del sistema. ejecutar con más procesos que procesadores cuando el sistema cambia de tarea, se producen reacciones. para promover el intercambio de tareas, realice la ejecución con más procesos que procesadores o núcleos. cuanto mayor sea la frecuencia de intercambio de las 249tareas, más probabilidades existen de que el código carezca de una sección crítica o se produzcan bloqueos. ejecutar en diferentes plataformas en 2007 diseñamos un curso sobre programación concurrente, principalmente en os x. la clase se presentó con windows xp ejecutado en una mv. se crearon pruebas para ilustrar condiciones de fallo que fallaban con más frecuencia en os x que en xp. en todos los casos, el código probado era incorrecto. esto refuerza el hecho de que cada sistema operativo tiene una política de procesos diferente que afecta a la ejecución del código. el código con procesos múltiples se comporta de forma distinta en cada entorno [89] . debe ejecutar sus pruebas en todos los entornos de implementación posibles. recomendación : ejecute el código con procesos en todas las plataformas de destino con frecuencia y en las fases iniciales . diseñar el código para probar y forzar fallos es habitual que los fallos del código concurrente se oculten. las pruebas sencillas no suelen mostrarlos. en realidad, suelen ocultarse durante el procesamiento normal. pueden aparecer horas, días o semanas después. la razón de que los problemas de procesos sean infrecuentes, esporádicos y apenas se repitan es que sólo fallan algunas de las miles de rutas posibles que recorren una sección vulnerable. por tanto, la probabilidad de adoptar una ruta fallida es realmente baja, lo que dificulta la detección y la depuración. se preguntará cómo aumentar las posibilidades de capturar estos casos. puede diseñar el código y forzarle a que se ejecute en diferentes órdenes añadiendo métodos como object.wait() , object.sleep() , object.yield() y object.priority() . estos métodos afectan al orden de ejecución y, por tanto, aumentan las posibilidades de detectar un error. resulta más adecuado que el código 250incorrecto falle lo antes posible y con frecuencia. hay dos opciones de instrumentación de código: manual. automática. manual puede añadir invocaciones de wait() , sleep() , yield() y priority() manualmente a su código, en especial si tiene que probar un fragmento especialmente escabroso. veamos un ejemplo: public synchronized string nexturlornull() { if (hasnext()) { string url = urlgenerator.next(); thread.yield(); // se añade para pruebas. updatehasnext(); return url; } return null; } la invocación de yield() cambia la ruta de ejecución adoptada por el código y posiblemente hace que el código falla donde no lo hacía antes. si el código falla, no se debe a la invocación de yield() añadida [90] . se debe a que el código es incorrecto y hemos hecho que el fallo sea más evidente. este enfoque presenta varios problemas: tendrá que buscar manualmente los puntos adecuados donde hacerlo. ¿cómo sabe dónde incluir la invocación y qué tipo de invocación usar? la presencia de este código en un entorno de producción ralentiza innecesariamente el código. es un enfoque que puede o no detectar los fallos; de hecho, no las tiene todas consigo. lo que necesitamos es una forma de hacerlo durante la fase de pruebas, no de producción. también debemos poder mezclar configuraciones entre ejecuciones, lo que aumenta las probabilidades de detectar los errores. 251evidentemente, si dividimos el sistema pojo que no sepa nada los procesos en clases que controlen los procesos, resultará más sencillo ubicar los puntos en los que instrumentar el código. es más, podríamos crear diferentes pruebas que invoquen los pojo bajo distintos regímenes de invocaciones a sleep , yield y demás. automática puede usar herramientas como la estructura orientada a aspectos, cglib o asm para instrumentar su código mediante programación. por ejemplo, podría usar una clase con un único método: public class threadjigglepoint { public static void jiggle() { } } puede añadir invocaciones en distintos puntos del código: public synchronized string nexturlornull() { if(hasnext()) { threadjigglepoint.jiggle(); string url = urlgenerator.next(); threadjigglepoint.jiggle(); updatehasnext(); threadjigglepoint.jiggle(); return url; } return null; } tras ello, use un sencillo aspecto que seleccione aleatoriamente entre no hacer nada, pausar o generar un resultado. imagine que la clase threadjigglepoint tiene dos implementaciones. la primera implementa jiggle para no hacer nada y se usa en producción. la segunda genera un número aleatorio para elegir entre sleep , yield o nada. si ejecuta sus pruebas mil veces con jiggle de forma aleatoria, puede descubrir algunos fallos. si la prueba es satisfactoria, al menos puede felicitarse por haber actuado correctamente. aunque sea un tanto simple, puede resultar una opción razonable en lugar de recurrir a una herramienta más sofisticada. la herramienta contest [91] , desarrollada por ibm, tiene un funcionamiento 252similar pero es más sofisticada. el objetivo es que los procesos del código se ejecuten en distinto orden en momentos diferentes. la combinación de pruebas bien escritas y ejecuciones aleatorias puede aumentar considerablemente la capacidad de detectar errores. recomendación : use estas estrategias para detectar errores . conclusión es complicado conseguir código concurrente correcto. el código sencillo se puede complicar al añadir varios procesos y datos compartidos. si tiene que crear código concurrente, tendrá que hacerlo con rigor o se enfrentará a sutiles y esporádicos fallos. en primer lugar, siga el principio de responsabilidad única. divida su sistema en varios pojo que separen el código compatible con procesos del resto. asegúrese de probar únicamente el código compatible con procesos y nada más, por lo que este código debe ser de tamaño reducido y específico. conozca los orígenes de los problemas de concurrencia: varios procesos que operen en datos compartidos o usen una agrupación de recursos común. los casos de límites, como el cierre correcto o la conclusión de la iteración de un bucle, pueden ser especialmente espinosos. conozca su biblioteca y los algoritmos fundamentales. debe comprender cómo las funciones de la biblioteca permiten resolver problemas similares a los de los algoritmos fundamentales. aprenda a localizar regiones del código que se puedan bloquear y bloquéelas. no bloquee otras regiones que no lo necesiten. evite invocar una sección bloqueada desde otra. para ello debe saber si un elemento está compartido o no. reduzca la cantidad de objetos compartidos y su ámbito. cambie los diseños de los objetos con datos compartidos para acomodar clientes en lugar de obligar a los clientes a gestionar el estado compartido. los problemas se acumularán. los que no aparezcan inicialmente suelen considerarse esporádicos y suelen producirse en la fase de carga o de modo aparentemente aleatorio. por tanto, debe poder ejecutar su código con 253procesos en diferentes configuraciones y plataformas de forma repetida y continua. la capacidad de prueba, algo natural si aplica las tres leyes de tdd, implica cierto nivel de conectividad, lo que ofrece la compatibilidad necesaria para ejecutar código en distintas configuraciones. la probabilidad de detectar errores mejora si se toma el tiempo necesario para instrumentar su código. puede hacerlo manualmente o mediante tecnologías automatizadas. hágalo en las fases iniciales. es aconsejable ejecutar el código basado en procesos durante el mayor tiempo posible antes de pasarlo a producción. si adopta un enfoque limpio, aumentarán las probabilidades de hacerlo de forma correcta. bibliografía [lea99] : concurrent programming in java: design principles and patterns , 2d. ed., doug lea, prentice hall, 1999. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. 25414 refinamiento sucesivo caso práctico de un analizador de argumentos de línea de comandos este capítulo es un caso práctico de refinamiento sucesivo. veremos un 255módulo que comienza correctamente pero no mantiene dicha corrección. tras ello, veremos cómo se refactoriza y se limpia. muchos hemos tenido que analizar argumentos de línea de comando. si no disponemos de una utilidad para ello, recorremos la matriz de cadenas pasadas a la función principal. puede encontrar utilidades de calidad pero ninguna hace exactamente lo que necesitamos. por ello, decidí crear una propia, a la que he denominado args . args es muy fácil de usar. basta crearla con los argumentos de entrada y una cadena de formato, y después consultar a la instancia de args los valores de los argumentos. fíjese en el siguiente ejemplo: listado 14-1 uso de args public static void main(string[] args) { try { args arg = new args(“l,p#,d*”, args); boolean logging = arg.getboolean(‘l’); int port = arg.getint(‘p’); string directory = arg.getstring(‘d’); executeapplication(logging, port, directory); } catch (argsexception e) { system.out.printf(“argument error: %s\n”, e.errormessage()); } } comprobará lo sencillo que es. creamos una instancia de la clase args con dos parámetros. el primero es la cadena de formato o esquema: “l,p#,d*” . define tres argumentos de línea de comandos. el primero, -l , es un argumento booleano. el segundo, -p , es un argumento entero. el tercero, - d , es un argumento de cadena. el segundo parámetro del constructor args es la matriz de argumentos de línea de comandos pasada a main . si el constructor no genera argsexception , la línea de comandos entrante se ha analizado y se puede consultar la instancia args . se usan métodos como getboolean , getinteger y getstring para acceder a los valores de los argumentos por sus nombres. si hay un problema, ya sea en la cadena de formato o en los argumentos de línea de comandos, se genera argsexception . la descripción del error se 256puede recuperar del método errormessage de la excepción. implementación de args el listado 14-2 es la implementación de la clase args . examínela con atención. el estilo y la estructura se han trabajado concienzudamente y espero que los imite. listado 14-2 args.java package com.objectmentor.utilities.args; import static com.objectmentor.utilities.args.argsexception.errorcode.*; import java.util.*; public class args { private map<character, argumentmarshaler> marshalers; private set<character> argsfound; private listiterator<string> currentargument; public args(string schema, string[] args) throws argsexception { marshalers = new hashmap<character, argumentmarshaler>(); argsfound = new hashset<character>(); parseschema(schema); parseargumentstrings(arrays.aslist(args)); } private void parseschema(string schema) throws argsexception { for (string element : schema.split(“,”)) if (element.length() > 0) parseschemaelement(element.trim()); } private void parseschemaelement(string element) throws argsexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(element id); if (elementtail.length() == 0) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail.equals(“*”)) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail.equals(“#”)) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); 257else if (elementtail.equals(“[*]”)) marshalers.put(elementid, new stringarrayargumentmarshaler()); else throw new argsexception(invalid_argument_format, elementid, elementtail); } private void validateschemaelementid(char elementid) throws argsexception { if {!character.isletter(elementid)) throw new argsexception(invalid_argument_name, elementid, null); } private void parseargumentstrings(list<string> argslist) throws argsexception { for (currentargument = argslist.listiterator(); currentargument.hasnext();) { string argstring = currentargument.next(); if (argstring.startswith(“-”)) { parseargumentcharacters(argstring.substring(1)); } else { currentargument.previous(); break; } } } private void parseargumentcharacters(string argchars) throws argsexception { for (int i = 0; i < argchars.length(); i++) parseargumentcharacter(argchars.charat(i)); } private void parseargumentcharacter(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) { throw new argsexception (unexpected_argument, argchar, null); } else { argsfound.add(argchar); try { m.set(currentargument); } catch (argsexception e) { e.seterrorargumentid(argchar); throw e; } } } public boolean has(char arg) { return argsfound.contains(arg); } public int nextargument() { 258return currentargument.nextindex(); } public boolean getboolean(char arg) { return booleanargumentmarshaler.getvalue(marshalers.get(arg)); } public string getstring(char arg) { return stringargumentmarshaler.getvalue(marshalers.get(arg)); } public int getint(char arg) { return integerargumentmarshaler.getvalue (marshalers.get(arg)); } public double getdouble(char arg) { return doubleargumentmarshaler.getvalue(marshalers.get(arg)); } public string[] getstringarray(char arg) { return stringarrayargumentmarshaler.getvalue(marshalers.get(arg)); } } puede leer el código de arriba a abajo sin necesidad de saltar de un punto a otro ni buscar hacia adelante. lo que seguramente busque es la definición de argumentmarshaler , que hemos omitido intencionadamente. tras leer el código, comprenderá la interfaz argumentmarshaler y la función de sus variantes. veamos algunas de ellas (entre los listados 14-3 y 14-6). listado 14-3 argumentmarshaler.java public interface argumentmarshaler { void set(iterator<string> currentargument) throws argsexception; } listado 14-4 booleanargumentmarshaler.java public class booleanargumentmarshaler implements argumentmarshaler { private boolean booleanvalue = false; public void set (iterator<string> currentargument) throws argsexception { booleanvalue = true; } public static boolean getvalue(argumentmarshaler am) { 259if (am != null && am instanceof booleanargumentmarshaler) return ((booleanargumentmarshaler) am).booleanvalue; else return false; } } listado 14-5 stringargumentmarshaler.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class stringargumentmarshaler implements argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { throw new argsexception(missing_string); } } public static string getvalue(argumentmarshaler am) { if (am != null && am instanceof stringargumentmarshaler) return ((stringargumentmarshaler) am).stringvalue; else return “”; } } listado 14-6 integerargumentmarshaler.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class integerargumentmarshaler implements argumentmarshaler { private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); intvalue = integer.parseint(parameter); } catch (nosuchelementexception e) { throw new argsexception(missing_integer); } catch (numberformatexception e) { throw new argsexception(invalid_integer, parameter); } } 260public static int getvalue (argumentmarshaler am) { if (am != null && am instanceof integerargumentmarshaler) return ((integerargumentmarshaler) am).intvalue; else return 0; } } las otras variantes de argumentmarshaler simplemente repiten este patrón en matrices double y string y sólo complicarían el capítulo. puede consultarlas como ejercicio. otro fragmento que puede resultar complicado es la definición de las constantes de código de error, incluidas en la clase argsexception (véase el listado 14-7). listado 14-7 argsexception.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = null; private errorcode errorcode = ok; public argsexception() {} public argsexception(string message) { super(message); } public argsexception(errorcode errorcode) { this.errorcode = errorcode; } public argsexception(errorcode errorcode, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; } public argsexception(errorcode errorcode, char errorargumentid, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; this.errorargumentid = errorargumentid; } public char geterrorargumentid() { return errorargumentid; } public void seterrorargumentid(char errorargumentid) { this.errorargumentid = errorargumentid; 261} public string geterrorparameter() { return errorparameter; } public void seterrorparameter(string errorparameter) { this.errorparameter = errorparameter; } public errorcode geterrorcode() { return errorcode; } public void seterrorcode(errorcode errorcode) { this.errorcode = errorcode; } public string errormessage() { switch (errorcode) { case ok: return “tilt: should not get here.”; case unexpected_argument: return string.format(“argument -%c unexpected.”, errorargumentid); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c.”, errorargumentid); case invalid_argument_name: return string.format(“‘%c’ is not a valid argument name.”, errorargumentid); case invalid_argument_format: return string.format(“‘%s’ is not a valid argument format.”, errorparameter); } return “”; } public enum errorcode { ok, invalid_argument_format, unexpected_argument, invalid_argument_name, missing_string, missing_integer, invalid_integer, missing_double, invalid_double } } 262es sorprendente la cantidad de código necesario para detallar este sencillo concepto. uno de los motivos es el uso de un lenguaje especialmente profuso. java, al ser un lenguaje de tipos estáticos, requiere muchas palabras para satisfacer el sistema de tipos. en lenguajes como ruby, python o smalltalk, este programa es mucho más reducido [92] . vuelva a leer el código. fíjese especialmente en los nombres de los elementos, el tamaño de las funciones y el formato. si tiene experiencia como programador, partes del estilo o la estructura no le convencerán, pero espero que, desde un punto de vista global, considere que el programa está bien escrito y tiene una estructura limpia. por ejemplo, debería ser evidente cómo añadir un nuevo tipo de argumento, como una fecha o un número complejo, y que dicha inclusión apenas requeriría código. en definitiva, bastaría con una nueva variante de argumentmarshaler , una nueva función getxxx y una nueva instrucción case en la función parseschemaelement . también habría un nuevo código argsexception.errorcode y un nuevo mensaje de error. cómo se ha realizado no diseñé este programa de principio a fin en su forma actual y, sobre todo, no espero que pueda crear programas limpios y elegantes a la primera. si algo hemos aprendido en las dos últimas décadas es que la programación es un arte más que una ciencia. para escribir código limpio, primero debe crear código imperfecto y después limpiarlo. no debería sorprenderle. ya lo aprendimos en el colegio cuando los profesores (normalmente en vano) nos obligaban a crear borradores de nuestras redacciones. el proceso, nos decían, era escribir un primer borrador, después otro, y después otros muchos hasta lograr una versión definitiva. para escribir redacciones limpias, el refinamiento debía ser continuado. muchos programadores noveles (como sucede con los alumnos) no siguen este consejo. creen que el objetivo principal es que el programa funcione. una vez que lo consiguen, pasan a la siguiente tarea, y conservan el estado funcional del programa, sea cual sea. los programadores 263experimentados saben que esto es un suicidio profesional. args: el primer borrador el listado 14-8 muestra una versión inicial de la clase args . funciona, pero es un desastre. listado 14-8 args.java (primer borrador) import java.text.parseexception; import java.util.*; public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private map<character, string> stringargs = new hashmap<character, string>(); private map<character, integer> intargs = new hashmap<character, integer>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema. string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { 264} return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)); parsebooleanschemaelement(elementid); else if (isstringschemaelement(elementtail)) parsestringschemaelement(elementid); else if (isintegerschemaelement(elementtail)) { parseintegerschemaelement(elementid); } else { throw new parseexception( string.format(“argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, false); } private void parseintegerschemaelement(char elementid) { intargs.put(elementid, 0); } private void parsestringschemaelement(char elementid) { stringargs.put(elementid, “”); } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } 265private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private boolean isintegerschemaelement(string elementtail) { return elementtail.equals(“#”); } private boolean parsearguments() throws argsexception { for (currentargument = 0; currentargument < args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = errorcode.unexpected_argument; valid = false; } } private boolean setargument(char argchar) throws argsexception { if (isbooleanarg(argchar)) setbooleanarg(argchar, true); else if (isstringarg(argchar)) setstringarg(argchar); else if (isintarg(argchar)) setintarg(argchar); else return false; return true; } private boolean isintarg(char argchar) { return intargs.containskey(argchar); } 266private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.put(argchar, new integer(parameter)); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch (numberformatexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.put(argchar, args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } private boolean isstringarg(char argchar) { return stringargs.containskey(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isbooleanarg(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return "-[" + schema + “]”; else return “”; } 267public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument - %c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“arguments(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } private boolean falseifnull(boolean b) { return b != null && b; } private int zeroifnull(integer i) { return i == null ? 0 : i; } private string blankifnull(string s) { return s = null ? “” : s; } public string getstring(char arg) { return blankifnull(stringargs.get(arg)); } public int getint(char arg) { return zeroifnull(intargs.get(arg)); } public boolean getboolean(char arg) { return falseifnull(booleanargs.get(arg)); } public boolean has(char arg) ( 268return argsfound.contains(arg); } public boolean isvalid() { return valid; } private class argsexception extends exception { } } espero que su reacción inicial ante tal cantidad de código es alegrarse por no haberlo conservado tal cual. si ha sido su reacción, recuerde que será la que tengan otros que lean un borrador de su código. en realidad, primer borrador es lo mejor que se puede decir sobre este código. evidentemente es un trabajo en progreso. la cantidad de variables de instancia es apabullante. cadenas extrañas como « tilt », hashset y treeset , y los bloques try-catch-catch aumentan el desastre. no era mi intención crear este desastre. en realidad, intentaba mantener cierta organización, como demuestra la elección de nombres de funciones y variables, y la estructura del programa. pero es evidente que el problema se me fue de las manos. el desastre aumentó gradualmente. las versiones anteriores no fueron tan malas. por ejemplo, el listado 14-9 muestra una versión inicial en la que sólo funcionaban los argumentos booleanos. listado 14-9 args.java (sólo argumentos booleanos) package com.objectmentor.utilities.getopts; import java.util.*; public class args { private string schema; private string[] args; private boolean valid; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private int numberofarguments = 0; public args(string schema, string[] args) { this.schema = schema; this.args = args; 269valid = parse(); } public boolean isvalid() { return valid; } private boolean parse() { if (schema.length() == 0 && args.length == 0) return true; parseschema(); parsearguments(); return unexpectedarguments.size() == 0; } private boolean parseschema() { for (string element : schema.split(“,”)) { parseschemaelement(element); } return true; } private void parseschemaelement(string element) { if (element.length() == 1) { parsebooleanschemaelement(element); } } private void parsebooleanschemaelement(string element) { char c = element.charat(0); if (character.isletter(c)) { booleanargs.put(c, false); } } private boolean parsearguments() { for (string arg : args) parseargument(arg); return true; } private void parseargument(string arg) { if (arg.startswith(“-”)) parseelement(arg); } private void parseelements(string arg) { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) { if (isboolean(argchar)) { numberofarguments++; setbooleanarg(argchar, true); 270} else unexpectedarguments.add(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return numberofarguments; } public string usage() { if (schema.length() > 0) return “-[”+schema+“]”; else return “”; } public string errormessage() { if (unexpectedarguments.size() > 0) { return unexpectedargumentmessage(); } else return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return booleanargs.get(arg); } } aunque hay motivos para quejarse del código, no es tan malo. es compacto y sencillo, y fácil de entender. sin embargo, en este código se aprecia la semilla del desastre posterior y resulta evidente porqué. la versión posterior sólo tiene dos tipos de argumentos más que ésta: string e integer . la inclusión de sólo dos tipos más tiene un tremendo impacto negativo en el código. lo convierte de algo que sería razonablemente 271mantenible en algo que seguramente esté plagado de errores. añadí los dos tipos de argumento de forma incremental. primero, el argumento string , que genera lo siguiente: listado 14-10 args.java (booleano y string) package com.objectmentor.utilities.getopts; import java.text.parseexception; import java.util.*; public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private map<character, string> stringargs = new hashmap<character, string>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargument = ‘\0’; enum errorcode { ok, missing_string } private errorcode errorcode = errorcode.ok; public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); parsearguments(); return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; 272} private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) parsebooleanschemaelement(elementid); else if (isstringschemaelement(elementtail)) parsestringschemaelement(elementid); } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private void parsestringschemaelement(char elementid) { stringargs.put(elementid, “”); } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, false); } private boolean parsearguments() { for (currentargument = 0; currentargument < args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } 273private void parseelement(char argchar) { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); valid = false; } } private boolean setargument(char argchar) { boolean set = true; if (isboolean(argchar)) setbooleanarg(argchar, true); else if (isstring(argchar)) setstringarg (argchar, “”); else set = false; return set; } private void setstringarg(char argchar, string s) { currentargument++; try { stringargs.put(argchar, args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargument = argchar; errorcode = errorcode.missing_string; } } private boolean isstring(char argchar) { return stringargs.containskey(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return “-[” + schema + “]”; else return “”; } 274public string errormessage() throws exception { if (unexpectedarguments.size() > 0) { return unexpectedargumentmessage(); } else switch (errorcode) { case missing_string: return string.format (“could not find string parameter for -%c.”, errorargument); case ok: throw new exception(“tilt: should not get here.”); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return falseifnull(booleanargs.get(arg)); } private boolean falseifnull(boolean b) { return b == null ? false : b; } public string getstring(char arg) { return blankifnull(stringargs.get(arg)); } private string blankifnull(string s) { return s == null ? “” : s; } public boolean has(char arg) { return argsfound.contains(arg); } public boolean isvalid() { return valid; } } comprobará que empieza a desbocarse. no es terrible pero el desastre se está gestando. basta con incluir el tipo de argumento integer para que resulte fatídico. 275entonces me detuve todavía tenía que añadir otros dos tipos de argumentos y sabía que empeorarían las cosas. si los forzaba, seguramente funcionarían pero provocaría un desastre demasiado complicado de arreglar. si la estructura del código tenía que poder mantenerse, era el momento de corregirla. por ello dejé de añadir elementos y comencé la refactorización. tras añadir los argumentos string e integer , sabía que cada uno necesitaría nuevo código en tres puntos principales. en primer lugar, cada tipo de argumento necesita una forma de analizar su elemento de esquema para poder seleccionar el hashmap de ese tipo. tras ello, sería necesario analizar cada tipo de argumento en las cadenas de línea de comandos y convertirlos en su tipo correcto. por último, cada tipo de argumento necesitaría un método getxxx para poder devolverlo al invocador como su tipo correcto. muchos tipos diferentes y todos con métodos similares, lo que en realidad era una clase. y de este modo nació el concepto de argumentmarshaler . sobre el incrementalismo una de las mejores formas de acabar con un programa es realizar cambios masivos con la intención de mejorarlo. algunos programas nunca se recuperan de estas mejoras. el problema es lo complicado que resulta conseguir que el programa funcione de la misma forma que antes de la mejora. para evitarlo, recurro a la disciplina tdd ( test-driven development o desarrollo guiado por pruebas). una de las doctrinas centrales de este enfoque es mantener la ejecución del sistema en todo momento. es decir, con tdd no puedo realizar cambios que afecten al funcionamiento del sistema. todos los cambios deben mantenerlo como antes de los cambios. para lograrlo, necesito una serie de pruebas automatizadas que ejecutar rápidamente y que verifiquen que el comportamiento del sistema no ha variado. para la clase args , creé una serie de pruebas de unidad y aceptación. las pruebas de unidad se crearon en java y se administraron con junit. las 276pruebas de aceptación se crearon como páginas wiki en fitnesse. podría haber ejecutado estas pruebas en cualquier momento y, si eran satisfactorias, sabría que el sistema funcionaba de la forma especificada. así pues, comencé a realizar pequeños cambios. cada uno desplazaba la estructura del sistema hacia el concepto argumentmarshaler , y cada cambio mantenía el funcionamiento del sistema. el primer cambio realizado fue añadir el esqueleto de argumentmarshaller al final del desastre anterior (véase el listado 14-11). listado 14-11 argumentmarshaller añadido a args.java private class argumentmarshaler { private boolean booleanvalue = false; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } private class booleanargumentmarshaler extends argumentmarshaler { } private class stringargumentmarshaler extends argumentmarshaler { } private class integerargumentmarshaler extends argumentmarshaler { } } evidentemente, esto no afectaría a nada, por lo que realicé la modificación más sencilla posible que afectara a la mínima cantidad de código. cambié hashmap para que los argumentos boolean aceptaran argumentmarshaler . private map<character, argumentmarshaler > booleanargs = new hashmap<character, argumentmarshaler >(); esto afectaba a varias instrucciones que corregí rápidamente. … private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, new booleanargumentmarshaler ()); } … 277private void setbooleanarg(char argchar, boolean value) { booleanargs. get (argchar). setboolean (value); } … public boolean getboolean(char arg) { return falseifnull (booleanargs.get(arg). getboolean() ); } estos cambios se aplican a las zonas que mencionamos antes: parse , set y get para el tipo de argumento. desafortunadamente, aunque sean cambios menores, algunas de las pruebas comenzaron a fallar. si se fija atentamente en getboolean , comprobará que se puede invocar con y pero no existe un argumento y , por lo que booleanargs.get(‘y’) devolverá null y la función generará nullpointerexception . la función falseifnull se usa como protección ante este hecho pero el cambio aplicado hace que la función sea irrelevante. el incrementalismo exigía que esto funcionara antes de realizar otros cambios. la solución no era demasiado complicada; bastaba con cambiar la comprobación de null . ya no era necesario comprobar null en boolean, sino en argumentmarshaller . primero, eliminé la invocación de falseifnull en la función getboolean . ya no servía de nada, por lo que eliminé directamente la función. las pruebas seguían fallando igual, lo que suponía que no había nuevos errores. public boolean getboolean(char arg) { return booleanargs.get(arg).getboolean(); } tras ello, dividí la función en dos líneas y añadí argumentmarshaller a una variable propia: argumentmarshaller . no me preocupaba el extenso nombre de la variable; era redundante y estorbaba a la función, por lo que lo reduje a am [n5]. public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am .getboolean(); } y tras ello añadí la lógica de detección de null . public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); 278return am != null && am.getboolean(); } argumentos de cadena la inclusión de los argumentos string fue similar a la de los argumentos boolean . tuve que cambiar hashmap y conseguir que funcionaran parse , set y get . no deberían producirse sorpresas posteriores a excepción de que la implementación completa se incluía en la clase argumentmarshaller en lugar de distribuirla en variantes. private map<character, argumentmarshaler > stringargs = new hashmap<character, argumentmarshaler >(); … private void parsestringschemaelement(char elementid) { stringargs.put(elementid, new stringargumentmarshaler()); } … private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs. get (argchar). setstring (args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring (char arg) { args.argumentmarshaler am = stringargs.get(arg); return am == null ? “” : am.getstring(); } … private class argumentmarshaler { private boolean booleanvalue = false; private string stringvalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { 279stringvalue = s; } public string getstring() { return stringvalue == null ? “” : stringvalue; } } de nuevo, estos cambios se realizaron individualmente para conservar las pruebas, aunque fallaran. si una prueba fallaba, me aseguraba de que fuera correcta antes de continuar con el siguiente cambio. ya debería reconocer mi intención. tras incluir el comportamiento de señalización en la clase base argumentmarshaler , comencé a transferirlo a las variantes, para de esta forma mantener el funcionamiento mientras cambiaba gradualmente la forma del programa. el siguiente paso consistía en transferir la funcionalidad del argumento int a argumentmarshaler . de nuevo, no hubo sorpresas. private map<character, argumentmarshaler > intargs = new hashmap<character, argumentmarshaler >(); … private void parseintegerschemaelement(char elementid) { intargs.put(elementid, new integerargumentmarshaler() ); } … private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs. get (argchar). setinteger (integer.parseint(parameter)); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch (numberformatexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } … public int getint(char arg) { args.argumentmarshaler am = intargs.get(arg); return am == null ? 0 : am.getinteger(); } 280… private class argumentmarshaler { private boolean booleanvalue = false; private string stringvalue; private int integervalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { stringvalue = s; } public string getstring() { return stringvalue == null ? “” : stringvalue; } public void setinteger(int i) { integervalue = i; } public int getinteger() { return integervalue; } } tras transferir la señalización a argumentmarshaler , comencé a transferir la funcionalidad a las variantes. el primer paso fue pasar la función setboolean a booleanargumentmarshaller y garantizar su correcta invocación. para ello creé un método set abstracto. private abstract class argumentmarshaler { protected boolean booleanvalue = false; private string stringvalue; private int integervalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { stringvalue = s; } public string getstring() { 281return stringvalue == null ? “” : stringvalue; } public void set integer(int i) { integervalue = i; } public int getinteger() { return integervalue; } public abstract void set(string s); } tras ello, implementé el método set en booleanargumentmarshaller . private class booleanargumentmarshaler extends argumentmarshaler { public void set(string s) { booleanvalue = true; } } y por último cambié la invocación de setboolean por la de set . private void setbooleanarg(char argchar, boolean value) { booleanargs.get(argchar). set(“true”) ; } las pruebas seguían siendo satisfactorias. como este cambio hacía que set se implementara en booleanargumentmarshaler , eliminé el método setboolean de la clase base argumentmarshaler . la función abstracta set acepta un argumento string pero la implementación de booleanargumentmarshaler no lo usa. he incluido el argumento porque sabía que stringargumentmarshaler e integerargumentmarshaler lo utilizarían. tras ello, el objetivo era implementar el método get en booleanargumentmarshaler . la implementación de funciones get siempre es escabrosa ya que el tipo devuelto tiene que ser object y en este caso debe convertirse a boolean . public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am != null && (boolean) am. get (); } para compilarlo, añadí la función get a argumentmarshaler . private abstract class argumentmarshaler { … 282public object get() { return null; } } se compila y las pruebas fallan. para que vuelvan a funcionar, basta con convertir get en abstracto e implementarlo en booleanargumentmarshaler . private abstract class argumentmarshaler { protected boolean booleanvalue = false; … public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { public void set (string s) { booleanvalue = true; } public object get() { return booleanvalue; } } de nuevo, las pruebas son satisfactorias. ahora tanto get como set se implementan en booleanargumentmarshaler . esto me permite eliminar la antigua función getboolean de argumentmarshaler , cambiar la variable protegida booleanvalue a booleanargumentmarshaler y convertirla en privada. repetí el mismo patrón de cambios con las cadenas. implementé set y get , eliminé las funciones sin usar y desplacé las variables. private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.get(argchar). set (args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring(char arg) { args.argumentmarshaler am = stringargs.get(arg); return am == null ? “” : (string) am. get (); } 283… private abstract class argumentmarshaler { private int integervalue; public void setinteger(int i) { integervalue = i; } public int getinteger() { return integervalue; } public abstract void set(string s); public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(string s) { booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { public void set(string s){ } public object get() { return null; } } } por último, repetí el proceso con los enteros. resulta más complicado ya que los enteros deben analizarse y la operación de análisis puede generar una 284excepción, pero el resultado es más indicado ya que el concepto de numberformatexception se oculta totalmente en integerargumentmarshaler . private boolean isintarg(char argchar) { return intargs.containskey(argchar); } private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.get(argchar). set (parameter); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( argsexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e ; } } … private void setbooleanarg(char argchar) { try { booleanargs.get(argchar).set(“true”); } catch (argsexception e) { } } … public int getint(char arg) { args.argumentmarshaler am = intargs.get(arg); return am == null ? 0 : (integer) am. get (); } … private abstract class argumentmarshaler { public abstract void set(string s) throws argsexception; public abstract object get(); } … private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception s) { throw new argsexception(); } 285} public object get() { return intvalue; } } evidentemente, las pruebas seguían funcionando. tras ello, me deshice de las distintas asignaciones de la parte superior del algoritmo, lo que hace que el sistema sea mucho más genérico. sin embargo, no las puede eliminar ya que afectaría a la integridad del sistema. en su lugar, añadí un nuevo map para argumentmarshaler y, tras ello, cambié uno a uno los métodos para que usaran la nueva asignación en lugar de las originales. public class args { … private map<character, argumentmarshaler> booleanargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … private void parsebooleanschemaelement(char elementid) { argumentmarshaler m = new booleanargumentmarshaler(); booleanargs.put(elementid, m); marshalers.put(elementid, m); } private void parseintegerschemaelement(char elementid) { argumentmarshaler m = new integerargumentmarshaler(); intargs.put(elementid, m); marshalers.put(elementid, m); } private void parsestringschemaelement(char elementid) { argumentmarshaler m = new stringargumentmarshaler(); stringargs.put(elementid, m); marshalers.put(elementid, m); } las pruebas seguían funcionando. tras ello, cambié isbooleanarg de esto: private boolean isbooleanarg(char argchar) { return booleanargs.containskey(argchar); } a este otro: 286private boolean isbooleanarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof booleanargumentmarshaler; } las pruebas funcionaban, por lo que apliqué el mismo cambio en isintarg e isstringarg . private boolean isintarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof integerargumentmarshaler; } private boolean isstringarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof stringargumentmarshaler; } las pruebas eran correctas, por lo que eliminé las invocaciones duplicadas de marshalers.get : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (isbooleanarg( m )) setbooleanarg(argchar); else if (isstringarg( m )) setstringarg(argchar); else if (isintarg( m )) setintarg(argchar); else return false; return true; } private boolean isintarg ( argumentmarshaler m ) { return m instanceof integerargumentmarshaler; } private boolean isstringarg ( argumentmarshaler m ) { return m instanceof stringargumentmarshaler; } private boolean isbooleanarg ( argumentmarshaler m ) { return m instanceof booleanargumentmarshaler; } los tres argumentos isxxxarg ya no tenían sentido, de modo que los reubiqué: private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if ( m instanceof booleanargumentmarshaler ) setbooleanarg(argchar); 287else if ( m instanceof stringargumentmarshaler ) setstringarg(argchar); else if ( m instanceof integerargumentmarshaler ) setintarg(argchar); else return false; return true; } tras ello, empecé a usar la asignación marshalers en las funciones set , dividiendo el uso de las otras tres asignaciones. comencé por los elementos boolean . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m instanceof booleanargumentmarshaler) setbooleanarg( m ); else if (m instanceof stringargumentmarshaler) setstringarg(argchar); else if (m instanceof integerargumentmarshaler) setintarg(argchar); else return false; return true; } … private void setbooleanarg( argumentmarshaler m ) { try { m .set(“true”); // era: booleanargs.get(argchar).set(“true”); } catch (argsexception e) { } } las pruebas seguían siendo correctas de modo que repetí la operación con las cadenas y los enteros. de esta manera se puede integrar parte del desagradable código de gestión de excepciones en la función setargument . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg( m ); else if (m instanceof integerargumentmarshaler) setintarg( m ); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; 288throw e; } return true; } private void setintarg( argumentmarshaler m ) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; m .set(parameter); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg( argumentmarshaler m ) throws argsexception { currentargument++; try { m .set(args[currentargument]); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } ya podía eliminar las tres asignaciones antiguas. primero, debía cambiar la función getboolean de: public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am != null && (boolean) am.get(); } a: public boolean getboolean(char arg) { args.argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } este último cambio puede parecer sorprendente. ¿por qué de repente decidí enfrentarme a classcastexception ? por tener una serie de pruebas de 289unidad y otra serie independiente de pruebas de aceptación creadas en fitnesse. las pruebas de fitnesse garantizan que si se invoca getboolean en un argumento no booleano, se obtiene false . no sucede lo mismo con las pruebas de unidad. hasta el momento, sólo había ejecutado las pruebas de unidad [93] . este último cambio me permitió extraer otro uso de la asignación boolean: private void parsebooleanschemaelement(char elementid) { argumentmarshaler m = new booleanargumentmarshaler(); booleanargs.put(elementid, m); marshalers.put(elementid, m); } y ahora ya podemos eliminar la asignación boolean. public class args { … private map<character, argumentmarshaler> booleanargs = new hashmap<character, argmentmarshaler>(); private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … tras ello, cambié los argumentos string e integer de la misma forma y limpié los valores boolean . private void parsebooleanschemaelement(char elementid) { marshalers.put(elementid, new booleanargumentmarshaler() ); } private void parseintegerschemaelement(char elementid) { marshalers.put(elementid, new integerargumentmarshaler() ); } private void parsestringschemaelement(char elementid) { marshalers.put(elementid, new stringargumentmarshaler() ); } … public string getstring(char arg) { args.argumentmarshaler am = marshalers .get(arg); try { return am null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } 290public int getint(char arg) { args.argumentmarshaler am = marshalers .get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } … public class args { … private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … seguidamente, dispuse en línea los tres métodos parse ya que no servían para mucho: private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else if (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentmarshaler()); else if (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( “argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } es el momento de ver la estructura completa. el listado 14-12 muestra la clase args actual. listado 14-12 args.java (tras la primera refactorización) package com.objectmentor.utilities.getopts; import java.text.parseexception; import java.util.*; public class args { private string schema; 291private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { } return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else if (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentwarshaler()); else if (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( 292“argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private boolean isintegerschemaelement(string elementtail) { return elementtail.equals(“#”); } private boolean parsearguments() throws argsexception { for (currentargument=0; currentargument<args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = errorcode.unexpected_argument; valid = false; } } private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); try { 293if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } private void setintarg(argumentmarshaler m) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; m.set(parameter); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg(argumentmarshaler m) throws argsexception { currentargument++; try { m.set (args[currentargument]); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } private void setbooleanarg(argumentmarshaler m) { try { m.set(“true”); } catch (argsexception e) { } } public int cardinality() { return argsfound.size(); } public string usage() { 294if (schema.length() > 0) return = “-[” + schema + “]”; else return “”; } public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for {char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { args.argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } public string getstring(char arg) { args.argumentmarshaler am = marshalers.get (arg); try { return am == null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } 295public int getint(char arg) { args.argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } public boolean has(char arg) { return argsfound.contains(arg); } public boolean isvalid() { return valid; } private class argsexception extends exception { } private abstract class argumentmarshaler { public abstract void set(string s) throws argsexception; public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(string s) { booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); 296} catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } } tras todo este esfuerzo, es un tanto decepcionante. la estructura ha mejorado pero todavía hay demasiadas variables en la parte superior; se mantiene un terrible caso de tipos en setargument ; y todas las funciones set . sin mencionar el procesamiento de errores. todavía nos queda mucho trabajo por hacer. mi intención es eliminar el caso de tipos de setargument [g23] y que sólo incluya una invocación a argumentmarshaler.set . para ello, debo desplazar setintarg , setstringarg y setbooleanarg a las correspondientes variantes de argumentmarshaler . pero hay un problema. si se fija atentamente en setintarg , comprobará que usa dos variables de instancia: args y currentarg . para desplazar setintarg hasta booleanargumentmarshaler , tengo que pasar args y currentargs como argumentos de función. muy desagradable [f1]. resultaría más indicado pasar un argumento y no dos. afortunadamente, la solución es sencilla. podemos convertir la matriz args en list y pasar iterator a las funciones set . para el siguiente cambio necesité diez pasos, y superar todas las pruebas tras cada uno. pero sólo mostraremos el resultado. debería determinar la mayoría de estos pequeños pasos. public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private iterator<string> currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private list<string> argslist; 297private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument } public args(string schema. string[] args) throws parseexception { this.schema = schema; argslist = arrays.aslist(args); valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && argslist.size() == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { } return valid; } … private boolean parsearguments() throws argsexception { for (currentargument = argslist.iterator(); currentargument. hasnext() ;) { string arg = currentargument. next() ; parseargument(arg); } return true; } … private void setintarg(argumentmarshaler m) throws argsexception { string parameter = null; try { parameter = currentargument. next() ; m.set(parameter); } catch ( nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg(argumentmarshaler m) throws argsexception { try { m.set (currentargument. next() ); } catch ( nosuchelementexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } 298son pequeños cambios que conservan el funcionamiento de las pruebas. ahora podemos empezar a desplazar las funciones set a las correspondientes variantes. primero, debemos realizar el siguiente cambio en setargument : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } es un cambio importante ya que queremos eliminar totalmente la cadena if-else . por tanto, debemos excluir la condición de error. ya podemos empezar a desplazar las funciones set . la función setbooleanarg es trivial, de modo que la prepararemos en primer lugar. el objetivo es cambiar la función setbooleanarg para redirigirla a booleanargumentmarshaler . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m, currentargument ); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } 299return true; } --- private void setbooleanarg (argumentmarshaler m, iterator<string> currentargument) throws argsexception { try { m.set(“true”); catch (argsexception e) { } } ¿no acabamos de incluir el procesamiento de excepciones? añadir elementos para después excluirlos es habitual en los procesos de refactorización. los pasos reducidos y la necesidad de que las pruebas sigan siendo correctas implican que los elementos cambien de posición. la refactorización es como resolver el cubo de rubik. se necesitan muchos pasos pequeños para lograr un objetivo mayor. cada paso habilita el siguiente. se preguntará por qué pasamos iterator si setbooleanarg no lo necesita. pues porque setintarg y setstringarg sí. y como el objetivo es implementar las tres funciones a través de un método abstracto en argumentmarshaller , es necesario pasarlo a setbooleanarg . ahora setbooleanarg no sirve de nada. si hubiera una función set en argumentmarshaler , podríamos invocarla directamente. es el momento de crear dicha función. el primer paso consiste en añadir el nuevo método abstracto a argumentmarshaler . private abstract class argumentmarshaler { public abstract void set(iterator<string> currentargument) throws argsexception; public abstract void set (string s) throws argsexception; public abstract object get(); } evidentemente, esto afecta a todas las variantes, de modo que implementamos el nuevo método en cada una. private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(iterator<string> currentargument) throws argsexception { booleanvalue = true; } public void set(string s) { 300booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { } public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { } public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } y ahora ya podemos eliminar setbooleanarg : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) m.set (currentargument); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); 301} catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } las pruebas siguen siendo satisfactorias y la función set se implementa en boolean argumentmarshaler . podemos repetir la operación con las cadenas y los enteros. private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) m.set(currentargument); else if (m instanceof stringargumentmarshaler) m.set(currentargument); else if (m instanceof integerargumentmarshaler) m.set(currentargument); } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } --- private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } public void set(string s){ } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { 302private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); set(parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } y el golpe de gracia: se elimina el caso de tipos. private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { m.set(currentargument); return true; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } } ya podemos deshacernos de las funciones de integerargumentmarshaler y limpiar el resto. private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0 public void set (iterator<string> currentargument) throws argsexception { string parameter = null; try { 303parameter = currentargument.next(); intvalue = integer.parseint (parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( numberformatexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } public object get() { return intvalue; } } también podemos convertir argumentmarshaler en una interfaz. private interface argumentmarshaler { void set (iterator<string> currentargument) throws argsexception; object get(); } veamos ahora lo sencillo que resulta añadir un nuevo tipo de argumento a la estructura. apenas necesitaremos cambios y los que apliquemos tendrán que ser aislados. en primer lugar, añadimos un nuevo caso de prueba para comprobar que el argumento double funciona correctamente: public void testsimpledoublepresent() throws exception { args args = new args(“x##”, new string[] {“-x”,“42.3”}); asserttrue(args.isvalid()); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42.3, args.getdouble(‘x’), .001); } limpiamos el código de análisis de esquemas y añadimos la detección ## para el tipo de argumento double . private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (elementtail. length() == 0 ) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail. equals(“*”) ) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail. equals(“#”) ) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); 304else throw new parseexception(string.format( “argument: %c has invalid format: %s.”, elementid, elementtail), 0); } seguidamente, creamos la clase doubleargumentmarshaler . private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_double; throw new argsexception(); } catch (numberformatexception e) { errorparameter = parameter; errorcode = errorcode.invalid_double; throw new argsexception(); } } public object get() { return doublevalue; } } esto nos obliga a añadir un nuevo código de error ( errorcode ). private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } y necesitamos una función getdouble . public double getdouble(char arg) { args.argumentmarshaler am = marshalers.get(arg); try { return am = null ? 0 : (double) am.get(); } catch (exception e) { return 0.0; } } y todas las pruebas son correctas. ha sido sencillo. a continuación comprobamos que el procesamiento de errores funciona correctamente. el siguiente caso de prueba comprueba que se declare un error si se proporciona 305una cadena que no se puede analizar a un argumento ##. public void testinvaliddouble() throws exception { args args = new args(“x##”, new string[] {“-x”, “forty two”}); assertfalse(args.isvalid()); assertequals(0, args.cardinality()); assertfalse(args.has(‘x’)); assertequals(0, args.getint(‘x’)); assertequals(“argument -x expects a double but was ‘forty two’.”, args.errormessage()); } --- public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c”, errorargumentid); } return “”; } y las pruebas son satisfactorias. la siguiente prueba garantiza que se detecte correctamente la ausencia de un argumento double . public void testmissingdouble() throws exception { args args = new args(“x##”, new string[]{"-x"}); assertfalse (args.isvalid()); assertequals(0, args.cardinality()); assertfalse(args.has(‘x’)); assertequals(0.0, args.getdouble(‘x’), 0.01); assertequals(“could not find double parameter for -x.”, args.errormessage()); } es correcto. la incluimos para que el ejemplo resulte más completo. el código de excepciones no es atractivo y no pertenece realmente a la 306clase args . también generamos parseexception , que no nos pertenece. por ello, combinamos todas las excepciones en una única clase argsexception y la incluimos en su propio módulo. public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; public argsexception() {} public argsexception(string message) { super(message); } public enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } } … public class args { … private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private argsexception .errorcode errorcode = argsexception .errorcode.ok; private list<string> argslist; public args(string schema, string[] args) throws argsexception { this.schema = schema; argslist = arrays.aslist(args); valid = parse(); } private boolean parse() throws argsexception { if (schema.length() == 0 && argslist.size() == 0) return true; parseschema(); try { parsearguments(); } catch ( argsexception e) { } return valid; } private boolean parseschema() throws argsexception { … } private void parseschemaelement(string element) throws argsexception { … else throw new argsexception ( string.format(“argument: %c has invalid format: %s.”, elementid, elementtail)); } 307private void validateschemaelementid(char elementid) throws argsexception { if (!character.isletter(elementid)) { throw new argsexception ( “bad character:” + elementid + “in args format: ” + schema); } } … private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = argsexception .errorcode.unexpected_argument; valid = false; } } … private class stringargumentmarshaler implements argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { errorcode = argsexception .errorcode.missing_string; throw new argsexception(); } } public object get() { return stringvalue; } } private class integerargumentmarshaler implements argumentmarshaler { private int intvalue = 0; public void set (iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); intvalue = integer.parseint(parameter); } catch (nosuchelementexception e) { errorcode = argsexception.errorcode.missing_integer; throw new argsexception (); } catch (numberformatexception e) { errorparameter = parameter; errorcode = argsexception .errorcode.invalid_integer; throw new argsexception (); 308} } public object get() { return intvalue; } } private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception e) { errorcode = argsexception .errorcode.missing_double; throw new argsexception(); } catch (numberformatexception e) { errorparameter = parameter; errorcode = argsexception .errorcode.invalid_double; throw new argsexception); } } public object get() { return doublevalue; } } } muy bien. ahora, args solamente genera argsexception . al desplazar argsexception a un módulo propio, podemos añadir a dicho módulo gran parte del código de error y extraerlo del módulo args . es una posición natural y evidente para incluir todo el código y nos permitirá limpiar posteriormente el módulo args . ya hemos separado el código de excepciones y de error del módulo args (véanse los listados del 14-13 al 14-16). para ello realizamos una serie de 30 pasos mínimos y las pruebas fueron satisfactorias entre todos ellos. listado 14-13 argstest.java. package com.objectmentor.utilities.args; import junit.framework.testcase; 309public class argstest extends testcase { public void testcreatewithnoschemaorarguments() throws exception { args args = new args(“”, new string[0]); assertequals(0, args.cardinality()); } public void testwithnoschemabutwithoneargument() throws exception { try { new args(“”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.unexpected_argument, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testwithnoschemabutwithmultiplearguments() throws exception { try { new args(“”, new string[]{“-x”, “-y”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.unexpected_argument, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testnonletterschema() throws exception { try { new args(“*”, new string[]{}); fail(“args constructor should have thrown exception”); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_argument_name, e.geterrorcode()); assertequals(‘*’, e.geterrorargumentid()); } } public void testinvalidargumentformat() throws exception { try { new args(“f~”, new string[]{}); fail(“args constructor should have throws exception”); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_format, e.geterrorcode()); assertequals(‘f’, e.geterrorargumentid()); } } public void testsimplebooleanpresent() throws exception { args args = new args(“x”, new string []{“-x”}); assertequals(1, args.cardinality()); assertequals(true, args.getboolean(‘x’)); 310} public void testsimplestringpresent() throws exception { args args = new args(“x*”, new string[]{“-x”, “param”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(“param”, args.getstring(‘x’)); } public void testmissingstringargument() throws exception { try { new args(“x*”, new string[]{"-x"}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_string, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testspacesinformat() throws exception { args args = new args(“x, y”, new string[]{“-xy”}); assertequals(2, args.cardinality()); asserttrue(args.has(‘x’)); asserttrue(args.has(‘y’)); } public void testsimpleintpresent() throws exception { args args = new args(“x#”, new string[]{“-x”, “42”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42, args.getint(‘x’)); } public void testinvalidinteger() throws exception { try { new args(“x#”, new string[] {“-x”, “forty two”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_integer, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); assertequals(“forty two”, e.geterrorparameter()); } } public void testmissinginteger() throws exception { try { new args(“x#”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_integer, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } 311public void testsimpledoublepresent() throws exception { args args = new args(“x##”, new string[](“-x”, “42.3”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42.3, args.getdouble(‘x’), .001); } public void testinvaliddouble() throws exception { try { new args(“x##”, new string []{“-x”, “forty two”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_double, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); assertequals(“forty two”, e.geterrorparameter()); } } public void testmissingdouble() throws exception { try { new args(“x##”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_double, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } } listado 14-14 argsexceptiontest.java. public class argsexceptiontest extends testcase { public void testunexpectedmessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.unexpected_argument, ‘x’, null); assertequals(“argument -x unexpected.”, e.errormessage()); } public void testmissingstringmessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_string, ‘x’, null); assertequals(“could not find string parameter for –x.”, e.errormessage()); } public void testinvalidintegermessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.invalid_integer, 312‘x’, “forty two”); assertequals(“argument –x expects an integer but was ‘forty two’.”, e.errormessage()); } public void testmissingintegermessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_integer, ‘x’, null); assertequals(“could not find integer parameter for -x.”, e.errormessage()); } public void testinvaliddoublemessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.invalid_double, ‘x’, “forty two”); assertequals(“argument -x expects a double but was ‘forty two’.”, e.errormessage()); } public void testmissingdoublemessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_double, ‘x’, null); assertequals(“could not find double parameter for -x.”, e.errormessage()); } } listado 14-15 argsexception.java. public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; public argsexception() {} public argsexception(string message) {super(message);} public argsexception(errorcode errorcode) { this.errorcode = errorcode; } public argsexception(errorcode errorcode, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; } public argsexception(errorcode errorcode, char errorargumentid, string errorparameter) { this.errorcode = errorcode; 313this.errorparameter = errorparameter; this.errorargumentid = errorargumentid; } public char geterrorargumentid() { return errorargumentid; } public void seterrorargumentid(char errorargumentid) { this.errorargumentid = errorargumentid; } public string geterrorparameter() { return errorparameter; } public void seterrorparameter(string errorparameter) { this.errorparameter = errorparameter; } public errorcode geterrorcode() { return errorcode; } public void seterrorcode(errorcode errorcode) { this.errorcode = errorcode; } public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return string.format(“argument -%c unexpected.”, errorargumentid); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c.”, errorargumentid); } return “”; } public enum errorcode { ok, invalid_format, unexpected_argument, invalid_argument_name, 314missing_string, missing_integer, invalid_integer, missing_double, invalid_double} } listado 14-16 args.java. public class args { private string schema; private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private iterator<string> currentargument; private list<string> argslist; public args(string schema, string[] args) throws argsexception { this.schema = schema; argslist = arrays.aslist(args); parse(); } private void parse() throws argsexception { parseschema(); parsearguments(); } private boolean parseschema() throws argsexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { parseschemaelement(element.trim()); } } return true; } private void parseschemaelement(string element) throws argsexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (elementtail.length() == 0) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail.equals(“*”)) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail.equals(“#”)) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); else throw new argsexception(argsexception.errorcode.invalid_format, elementid, elementtail); } 315private void validateschemaelementid(char elementid) throws argsexception { if (!character.isletter(elementid)) { throw new argsexception(argsexception.errorcode.invalid_argument_name, elementid, null); } } private void parsearguments() throws argsexception { for (currentargument = argslist.iterator(); currentargument.hasnext();) { string arg = currentargument.next(); parseargument(arg); } } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { throw new argsexception(argsexception.errorcode.unexpected_argument, argchar, null); } } private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { m.set(currentargument); return true; } catch (argsexception e) { e.seterrorargumentid(argchar); throw e; } } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return "-[" + schema + “]”; 316else return “”; } public boolean getboolean(char arg) { argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } public string getstring(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } public int getint(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } public double getdouble(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (double) am.get(); } catch (exception e) { return 0.0; } } public boolean has(char arg) { return argsfound.contains(arg); } } la mayoría de los cambios realizados en la clase args han sido eliminaciones. gran parte del código se extrajo de args y se añadió a argsexception . perfecto. también cambiamos todos los elementos argumentmarshaller a sus propios archivos. mejor todavía. 317el diseño de software correcto se basa gran parte en las particiones, en crear zonas adecuadas para incluir distintos tipos de código. esta separación hace que el código sea más fácil de entender y mantener. especialmente interesante es el método errormessage de argsexception . incumple claramente el srp al incluir el formato de mensajes de error en args . args debe centrarse en el procesamiento de argumentos, no en el formato de los mensajes de error. sin embargo, ¿realmente tiene sentido incluir el código de formato de mensajes de error en argsexception ? francamente es un compromiso. los usuarios que no deseen los mensajes de error proporcionados por argsexception tendrán que crear los suyos propios, pero la utilidad de mensajes de error ya preparados es evidente. ya debería haberse dado cuenta de la distancia recorrida con respecto a la solución mostrada al inicio del capítulo. las transformaciones finales puede examinarlas por su cuenta. conclusión no basta con que el código funcione. el código que funciona suele ser incorrecto. los programadores que se conforman con código funcional no se comportan de forma profesional. puede que teman que no tienen tiempo para mejorar la estructura y el diseño del código, pero discrepo. no hay nada que afecte más negativamente a un proyecto de desarrollo que el código incorrecto. los plazos incorrectos se pueden rehacer y los requisitos equivocados se pueden volver a definir. la dinámica incorrecta de un equipo se puede reparar pero el código incorrecto se corrompe y se convierte en una carga que arrastra al equipo completo. he visto equipos dominados por el desastre que han generado y que han dominado su destino. evidentemente, el código incorrecto se puede limpiar pero resulta muy costoso. cuando el código se corrompe los módulos se insinúan unos a otros y generan multitud de dependencias ocultas y entrelazadas. la localización y división de dependencias antiguas es una tarea larga y complicada. por otra parte, resulta relativamente sencillo mantener código limpio. si comete un error en un módulo, es más fácil limpiarlo directamente. mejor todavía, si 318cometió un error hace cinco minutos, es muy fácil limpiarlo ahora. por tanto, la solución consiste en mantener el código limpio y sencillo siempre que se pueda y no dejar que llegue a corromperse. 31915 aspectos internos de junit 320junit es una de las estructuras de java más conocidas. de concepción sencilla, definición precisa y documentación elegante. ¿y su código? en este capítulo analizaremos un ejemplo extraído de la estructura junit. la estructura junit junit ha tenido muchos autores, comenzando por kent beck y eric gamma en un vuelo a atlanta. kent quería aprender java y eric quería saber más sobre la estructura de pruebas smalltalk de kent. “¿hay algo más natural que 321dos fanáticos enciendan sus portátiles y empiecen a escribir código?” [94] tras tres horas de trabajo de altura, habían creado los fundamentos de junit. el módulo que analizaremos es un inteligente fragmento de código que permite identificar errores de comparación de cadenas. el nombre del módulo es comparisoncompactor . dadas dos cadenas diferentes, como abcde y abxde , muestra la diferencia entre ambas generando una cadena como <… b[x]d…> . podríamos explicarlo más, pero los casos de prueba son mejores. fíjese en el listado 15-1 para comprender los requisitos de este módulo. analice la estructura de las pruebas. ¿podrían ser más simples o más evidentes? listado 15-1 comparisoncompactortest.java. package junit.tests.framework; import junit.framework.comparisoncompactor; import junit.framework.testcase; public class comparisoncompactortest extends testcase { public void testmessage() { string failure= new comparisoncompactor(0, “b”, “c”).compact(“a”); asserttrue(“a expected:<[b]> but was:<[c]>”.equals(failure)); } public void teststartsame() { string failure= new comparisoncompactor(1, “ba”, “bc”).compact(null); assertequals(“expected:<b[a]> but was:<b[c]>”, failure); } public void testendsame() { string failure= new comparisoncompactor(1, “ab”, “cb”).compact(null); assertequals(“expected:<[a]b> but was:<[c]b>”, failure); } public void testsame() { string failure= new comparisoncompactor(1, “ab”, “ab”).compact(null); assertequals(“expected:<ab> but was:<ab>”, failure); } public void testnocontextstartandendsame() { string failure= new comparisoncompactor(0, “abc”, “adc”).compact(null); assertequals(“expected:<…[b]…> but was:<…[d]…>”, failure); } 322public void teststartandendcontext() { string failure= new comparisoncompactor(1, “abc”, “adc”).compact(null); assertequals(“expected:<a[b]c> but was:<a[d]c>”, failure); } public void teststartandendcontextwithellipses() { string failure= new comparisoncompactor(1, “abcde”, “abfde”).compact(null); assertequals(“expected:<…b[c]d…> but was:<…b[f]d…>”, failure); } public void testcomparisonerrorstartsamecomplete() { string failure= new comparisoncompactor(2, “ab”, “abc”).compact(null); assertequals(“expected:<ab[]> but was:<ab[c]>”, failure); } public void testcomparisonerrorendsamecomplete() { string failure= new comparisoncompactor(0, “bc”, “abc”).compact(null); assertequals(“expected:<[]…> but was:<[a]…>”, failure); } public void testcomparisonerrorendsamecompletecontext() { string failure= new comparisoncompactor(2, “bc”, “abc”).compact(null); assertequals(“expected:<[]bc> but was:<[a]bc>”, failure); } public void testcomparisonerroroverlapingmatches() { string failure= new comparisoncompactor(0, “abc”, “abbc”).compact(null); assertequals(“expected:<…[]…> but was:<…[b]…>”, failure); } public void testcomparisonerroroverlapingmatchescontext() { string failure= new comparisoncompactor(2, “abc”, “abbc”).compact(null); assertequals(“expected:<ab[]c> but was:<ab[b]c>”, failure); } public void testcomparisonerroroverlapingmatches2() { string failure= new comparisoncompactor(0, “abcdde”, “abcde”).compact(null); assertequals(“expected:<…[d]…> but was:<…[]…>”, failure); } public void testcomparisonerroroverlapingmatches2context() { string failure= new comparisoncompactor(2, “abcdde”, “abcde”).compact(null); assertequals(“expected:<…cd[d]e> but was:<…cd[]e>”, failure); } public void testcomparisonerrorwithactualnull() { string failure= new comparisoncompactor(0, “a”, null).compact(null); assertequals(“expected:<a> but was:<null>”, failure); } public void testcomparisonerrorwithactualnullcontext() { string failure= new comparisoncompactor(2, “a”, null).compact(null); 323assertequals(“expected:<a> but was:<null>”, failure); } public void testcomparisonerrorwithexpectednull() { string failure= new comparisoncompactor(0, null, “a”).compact(null); assertequals(“expected:<null> but was:<a>”, failure); } public void testcomparisonerrorwithexpectednullcontext() { string failure= new comparisoncompactor(2, null, “a”).compact(null); assertequals(“expected:<null> but was:<a>”, failure); } public void testbug609972() { string failure= new comparisoncompactor(10, “s&p500”, “0”).compact(null); assertequals(“expected:<[s&p50]0> but was:<[]0>”, failure); } } realicé un análisis de alcance de código en comparisoncompactor con estas pruebas. el código se cubre en un 100 por 100. cada línea, cada instrucción if y cada bucle for se ejecuta con las pruebas. de este modo sé que el código funciona y sus autores me merecen el mayor de los respetos. el código comparisoncompactor se reproduce en el listado 15-2. examínelo. creo que lo encontrará bien distribuido, razonablemente expresivo y estructuralmente sencillo. cuando termine, lo diseccionaremos. listado 15-2 comparisoncompactor.java (original). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int fcontextlength; private string fexpected; private string factual; private int fprefix; private int fsuffix; public comparisoncompactor(int contextlength, string expected, string actual) { fcontextlength = contextlength; fexpected = expected; 324factual = actual; } public string compact(string message) { if (fexpected == null || factual == null || arestringsequal()) return assert.format(message, fexpected, factual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(fexpected); string actual = compactstring(factual); return assert.format(message, expected, actual); } private string compactstring(string source) { string result = delta_start + source.substring(fprefix, source.length() - fsuffix + 1) + delta_end; if (fprefix > 0) result = computecommonprefix() + result; if (fsuffix > 0) result = result + computecommonsuffix(); return result; } private void findcommonprefix() { fprefix = 0; int end = math.min(fexpected.length(), factual.length()); for (; fprefix < end; fprefix++) { if (fexpected.charat(fprefix) != factual.charat(fprefix)) break; } } private void findcommonsuffix() { int expectedsuffix = fexpected.length() - 1; int actualsuffix = factual.length() - 1; for (; actualsuffix >= fprefix && expectedsuffix >= fprefix; actualsuffix--, expectedsuffix--) { if (fexpected.charat(expectedsuffix) != factual.charat(actualsuffix)) break; } fsuffix = fexpected.length() - expectedsuffix; } private string computecommonprefix() { return (fprefix > fcontextlength ? ellipsis : “”) + fexpected.substring(math.max(0, fprefix - fcontextlength), fprefix); } private string computecommonsuffix() { int end = math.min(fexpected.length() - fsuffix + 1 + fcontextlength, fexpected.length()); 325return fexpected.substring(fexpected.length() - fsuffix + 1, end) + (fexpected.length() - fsuffix + 1 < fexpected.length() - fcontextlength ? ellipsis : “”); } private boolean arestringsequal() { return fexpected.equals(factual); } } puede que tenga varias quejas sobre el módulo. incluye expresiones extensas y extraños elementos +1 . pero en general, está bastante bien. después de todo, podría haber sido como el listado 15-3. listado 15-3 comparisoncompator.java (defactorizado) package junit.framework; public class comparisoncompactor { private int ctxt; private string s1; private string s2; private int pfx; private int sfx; public comparisoncompactor(int ctxt, string s1, string s2) { this.ctxt = ctxt; this.s1 = s1; this.s2 = s2; } public string compact(string msg) { if (s1 == null || s2 == null || s1.equals(s2)) return assert.format(msg, s1, s2); pfx = 0; for (; pfx < math.min(s1.length(), s2.length()); pfx++) { if (s1.charat(pfx) != s2.charat(pfx)) break; } int sfx1 = s1.length() - 1; int sfx2 = s2.length() - 1; for (; sfx2 >= pfx && sfx1 >= pfx; sfx2--, sfx1--) { if (s1.charat(sfx1) != s2.charat(sfx2)) break; } sfx = s1.length() - sfx1; string cmp1 = compactstring(s1); string cmp2 = compactstring(s2); return assert.format(msg, cmp1, cmp2); 326} private string compactstring(string s) { string result = “[” + s.substring(pfx, s.length() - sfx + 1) + “]”; if (pfx > 0) result = (pfx > ctxt ? “…” : “”) + s1.substring(math.max(0, pfx - ctxt), pfx) + result; if (sfx > 0) { int end = math.min(s1.length() - sfx + 1 + ctxt, s1.length()); result = result + (s1.substring(s1.length() - sfx + 1, end) + (s1.length() - sfx + 1 < s1.length() - ctxt ? “…” : “”)); } return result; } } aunque los autores hicieron un buen trabajo con este módulo, la regla del boy scout [95] muestra que podrían haberlo dejado más limpio de lo que se encontró. ¿cómo podemos mejorar el código original del listado 15-2? lo primero que no necesitamos es el prefijo f de las variables miembro [n6]. los entornos actuales hacen que este tipo de código de ámbito sea redundante, por lo que eliminaremos todas las f . private int contextlength; private string expected; private string actual; private int prefix; private int suffix; tras ello, tenemos una condicional sin encapsular al inicio de la función compact [g28]. public string compact(string message) { if (expected == null || actual == null || arestringsequal()) return assert.format(message, expected, actual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } es necesario encapsular esta condicional para que nuestra intención sea más clara. por tanto, extraemos un método que la explique. public string compact(string message) { if ( shouldnotcompact() ) return assert.format(message, expected, actual); 327findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } private boolean shouldnotcompact() { return expected == null || actual == null || arestringsequal(); } en la función compact , this.expected y this.actual no son demasiado relevantes. sucede al cambiar el nombre de fexpected por expected . ¿por qué esta función tiene variables con los mismos nombres que las variables miembro? ¿no representan cosas diferentes?[n4]. los nombres deben ser exclusivos. string compactexpected = compactstring( expected ); string compactactual = compactstring( actual ); los negativos son más difíciles de entender que los positivos [g29]. por ello, invertimos esa instrucción if para cambiar el sentido de la condicional. public string compact(string message) { if ( canbecompacted() ) { findcommonprefix(); findcommonsuffix(); string compactexpected = compactstring(expected); string compactactual = compactstring(actual); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private boolean canbecompacted () { return expected != null && actual != null && !arestringsequal(); } el nombre de la función es extraño [n7]. aunque compacta las cadenas, puede que lo haga si canbecompacted devuelve false . al asignar el nombre compact a esta función se oculta el efecto secundario de la comprobación de errores. además, la función devuelve un mensaje con formato, no sólo las cadenas compactadas. por tanto, el nombre de la función debería ser formatcompactedcomparison . de esta forma, se lee mejor junto al argumento de la función: 328public string formatcompactedcomparison(string message) { el cuerpo de la instrucción if es donde se realiza la verdadera compactación de las cadenas. debemos extraerlo como método con el nombre compactexpectedandactual . sin embargo, queremos que la función formatcompactedcomparison realice todo el formato. la función compact … sólo debe realizar la compactación [g30], de modo que la dividimos de esta forma: … private string compactexpected; private string compactactual; … public string formatcompactedcomparison(string message) { if (canbecompacted()) { compactexpectedandactual(); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private void compactexpectedandactual () { findcommonprefix(); findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } para ello, hemos tenido que ascender compactexpected y compactactual a variables miembro. no me gusta la forma en que las dos últimas líneas de la nueva función devuelven variables pero las dos primeras no lo hacen. no utilizan convenciones coherentes [g11]. debemos cambiar findcommonprefix y findcommonsuffix para que devuelvan los valores de prefijo y sufijo. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonprefix() { int prefix index = 0; int end = math.min(expected.length(), actual.length()); for (; prefix index < end; prefix index ++) { 329if (expected.charat(prefix index ) != actual.charat(prefix index )) break; } return prefixindex; } private int findcommonsuffix() { int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefix index && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix--) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } también debemos cambiar los nombres de las variables miembro para que sean más preciosas [n1], ya que en el fondo son índices. al examinar findcommonsuffix vemos una conexión temporal oculta [g31]; depende de que prefixindex se calcule por findcommonprefix . si estas dos funcione se invocan de forma desordenada, la sesión de depuración posterior sería complicada. por ello, para mostrar esta combinación temporal, haremos que findcommonsuffix acepte prefixindex como argumento. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix( prefixindex ); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonsuffix( int prefixindex ) { int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefixindex && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix--) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } no me convence del todo. el hecho de pasar prefixindex como argumento es un tanto arbitrario [g32]. permite establecer el orden pero no explica la necesidad del mismo. otro programador podría deshacer esta operación ya que no se indica en ningún momento para qué sirve el parámetro. adoptemos un enfoque diferente. 330private void compactexpectedandactual() { findcommonprefixandsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private void findcommonprefixandsuffix () { findcommonprefix(); int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefixindex && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix-- ) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } suffixindex = expected.length() - expectedsuffix; } private void findcommonprefix() { prefixindex = 0; int end = math.min(expected.length(), actual.length()); for (; prefixindex < end; prefixindex++) if (expected.charat(prefixindex) != actual.charat(prefixindex)) break; } devolvemos findcommonprefix y findcommonsuffix a su posición original, cambiamos el nombre de findcommonsuffix por findcommonprefixandsuffix y hacemos que invoque findcommonprefix antes de hacer nada más. de ese modo se establece la naturaleza temporal de ambas funciones de forma más evidente que antes. además, se muestra el mínimo atractivo de findcommonprefixandsuffix , que limpiaremos a continuación: private void findcommonprefixandsuffix() { findcommonprefix(); int suffixlength = 1; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } suffixindex = suffixlength; } private char charfromend(string s, int i) { return s.charat(s.length()-i);} private boolean suffixoverlapsprefix(int suffixlength) { 331return actual.length() - suffixlength < prefixlength || expected.length() - suffixlength < prefixlength; } mucho mejor. muestra que suffixindex es en realidad la longitud del sufijo y que su nombre no es correcto. lo mismo sucede con prefixindex , aunque en ese caso índice y longitud son sinónimos. incluso así, es más coherente usar length . el problema es que la variable suffixindex no es de base cero, sino de base 1 y no es una verdadera longitud. éste es el motivo de la abundancia de +1 en computecommonsuffix [g33]. lo corregimos. en el listado 15-4 puede ver el resultado. listado 15-4 comparisoncompactor.java (versión intermedia). public class comparisoncompactor { … private int suffixlength ; … private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = 0; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } } private char charfromend(string s, int i) { return s.charat(s.length() - i - 1 ); } private boolean suffixoverlapsprefix(int suffixlength) { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } … private string compactstring(string source) { string result = delta_start + source.substring(prefixlength, source.length() - suffixlength ) + delta_end; if (prefixlength > 0) result = computecommonprefix() + result; if ( suffixlength > 0) 332result = result + computecommonsuffix(); return result; } … private string computecommonsuffix() { int end = math.min(expected.length() - suffixlength + contextlength, expected.length() ); return expected.substring(expected.length() - suffixlength , end) + (expected.length() - suffixlength < expected.length() - contextlength ? ellipsis : “”); } cambiamos +1 en computecommonsuffix por un -1 en charfromend, donde tiene sentido, y dos operadores <= en suffixoverlapsprefix , totalmente correctos. de este modo podemos cambiar el nombre de suffixindex por suffixlength , lo que mejora considerablemente la legibilidad del código. pero hay un problema. al comenzar a eliminar los +1 , me fijé en la siguiente línea de compactstring : if (suffixlength > 0) búsquela en el listado 15-4. como ahora suffixlength es una unidad menos que antes, debemos cambiar el operador > por >= . pero eso no tiene sentido. ahora sí. significa que no tenía sentido antes y que seguramente fuera un error. bueno, no del todo. tras un análisis detallado, vemos que ahora la instrucción if impide que se añada un sufijo de longitud cero. antes de realizar el cambio, la instrucción if no funcionaba ya que suffixindex nunca podía ser menos de uno. esto cuestiona ambas instrucciones if en compactstring . parece como si se pudieran eliminar. por ello, las comentamos y ejecutamos las pruebas. satisfactorias. reestructuremos compactstring para eliminar las instrucciones if sobrantes y simplificar la función [g9]. private string compactstring(string source) { return computecommonprefix() + delta_start + source.substring(prefixlength, source.length() - suffixlength) + 333delta_end + computecommonsuffix(); } mucho mejor. ahora vemos que la función compactstring simplemente combina los fragmentos. probablemente lo podríamos limpiar más, en pequeñas operaciones, pero en lugar de desarrollar el resto de los cambios, mostraremos el resultado final en el listado 15-5. listado 15-5 comparisoncompactor.java (versión definitiva). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int contextlength; private string expected; private string actual; private int prefixlength; private int suffixlength; public comparisoncompactor( int contextlength, string expected, string actual ) { this.contextlength = contextlength; this.expected = expected; this.actual = actual; } public string formatcompactedcomparison(string message) { string compactexpected = expected; string compactactual = actual; if (shouldbecompacted()) { findcommonprefixandsuffix(); compactexpected = compact(expected); compactactual = compact(actual); } return assert.format(message, compactexpected, compactactual); } private boolean shouldbecompacted() { return !shouldnotbecompacted(); } private boolean shouldnotbecompacted() { return expected == null || 334actual == null || expected.equals(actual); } private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = 0; for (; !suffixoverlapsprefix(); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength) ) break; } } private char charfromend(string s, int i) { return s.charat(s.length() - i - 1); } private boolean suffixoverlapsprefix() { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } private void findcommonprefix() { prefixlength = 0; int end = math.min(expected.length(), actual.length()); for (; prefixlength < end; prefixlength++) if (expected.charat(prefixlength) != actual.charat(prefixlength)) break; } private string compact(string s) { return new stringbuilder() .append(startingellipsis()) .append(startingcontext()) .append(delta_start) .append(delta(s)) .append(delta_end) .append(endingcontext()) .append(endingellipsis()) .tostring(); } private string startingellipsis() { return prefixlength > contextlength ? ellipsis : “”; } private string startingcontext() { int contextstart = math.max(0, prefixlength - contextlength); int contextend = prefixlength; return expected.substring(contextstart, contextend); } private string delta(string s) { 335int deltastart = prefixlength; int deltaend = s.length() - suffixlength; return s.substring(deltastart, deltaend); } private string endingcontext() { int contextstart = expected.length() - suffixlength; int contextend = math.min(contextstart + contextlength, expected.length()); return expected.substring(contextstart, contextend); } private string endingellipsis() { return (suffixlength > contextlength ? ellipsis : “”); } } bastante atractivo. el módulo se separa en un grupo de funciones de análisis y otro grupo de funciones de síntesis. se ordenan topológicamente para que la definición de cada función aparezca donde realmente se usa. primero se muestran las funciones de análisis y después las de síntesis. si se fija atentamente, verá que he invertido algunas de las decisiones adoptadas inicialmente. por ejemplo, he añadido algunos métodos extraídos a formatcompactedcomparison y he modificado el sentido de la expresión shouldnotbecompacted . es algo habitual. a menudo, un cambio de refactorización lleva a otro que a su vez lleva a deshacer el primero. la refactorización es un proceso iterativo de ensayo y error, e inevitablemente converge en algo que consideramos digno de un profesional. conclusión hemos cumplido la regla del boy scout. hemos dejado este módulo más limpio de como lo encontramos. no es que no estuviera limpio originalmente, ya que el trabajo de sus autores es excelente, pero cualquier módulo se puede mejorar y es nuestra responsabilidad dejar el código más limpio de lo que lo encontramos. 33616 refactorización de serialdate si visita http://www.jfree.org/jcommon/index.php , encontrará la biblioteca jcommon. en su interior incluye el paquete org.jfree.date y, dentro de éste, la clase serialdate . vamos a analizar esta clase. el autor de serialdate es david gilbert. david es un programador experimentado y competente. como veremos, muestra un elevado grado de profesionalidad y disciplina en su código. en lo que a éste respecta, se puede 337considerar de calidad. y voy a despedazarlo. no es un acto de malicia, ni tampoco me creo mejor que david y con el derecho de juzgar su código. de hecho, si leyera algún código que he creado, seguramente tendría que objetar muchos aspectos del mismo. no es un acto de arrogancia. lo que voy a hacer no es más que una revisión profesional, algo con lo que todos deberíamos sentirnos cómodos y algo que deberíamos agradecer si alguien lo hace. a través de las críticas es como podemos aprender, como hacen médicos, pilotos o abogados. y nosotros, como programadores, también tenemos que aprender a hacerlo. otra cosa más sobre david gilbert: es más que un buen programador. david ha tenido el valor y la buena voluntad de ofrecer este código al público gratuitamente, para que cualquiera pueda usarlo y examinarlo. ¡bien hecho! serialdate (véase el listado b-1) es una clase que representa una fecha en java. ¿para qué se necesita una clase que represente una fecha si java ya cuenta con java.util.date y java.util.calendar , entre otras? el autor creó esta clase como respuesta a un problema que yo también he padecido. el comentario de su javadoc inicial (línea 67) lo explica. podríamos cuestionar su intención, pero yo también he sufrido este problema y se agradece una clase sobre fechas en lugar de horas. primero, conseguir que funcione hay varias pruebas de unidad en la clase serialdatetests (véase el listado b-2). todas son satisfactorias. desafortunadamente, un rápido examen demuestra que no comprueban todos los aspectos [t1]. por ejemplo, al realizar una búsqueda de usos en el método monthcodetoquarter (línea 334) se indica que no se usa [f4]. por lo tanto, las pruebas de unidad no lo comprueban. por ello, recurrí a clover para ver el alcance de las pruebas de unidad. clover indicó que las pruebas sólo ejecutan 91 de las 185 instrucciones ejecutables de serialdate (aproximadamente el 50 por 100) [t2]. el mapa de alcance muestra grandes fragmentos de código sin ejecutar desperdigados por la clase. mi objetivo era comprender la clase y refactorizarla, algo que no podía 338lograr sin una cobertura mayor de las pruebas. por ello diseñé mi propia suite de pruebas de unidad independientes (véase el listado b-4). si se fija en las pruebas, comprobará que muchas están comentadas, ya que no se superaron. representan un comportamiento que considero debería incluirse en serialdate . por tanto, al refactorizar serialdate , intentaré que estas pruebas funcionen. incluso con algunas de las pruebas comentadas, el informe de clover indica que ahora ejecutan 170 (el 92 por ciento) de las 185 instrucciones ejecutables. un gran resultado que creo que puedo mejorar. las primeras pruebas comentadas (líneas 23-63) son un tanto pretenciosas. el programa no fue diseñado para superar estas pruebas, pero el comportamiento me parecía evidente [g2]. desconozco por qué se ha creado el método testweekdaycodetostring pero ya que está ahí, parece obvio que no debe distinguir entre mayúsculas y minúsculas. el diseño de las pruebas fue sencillo [t3] y más todavía que fueran satisfactorias; simplemente cambié las líneas 259 y 263 para usar equalsignorecase . comenté las pruebas de las líneas 32 y 45 ya que no estaba seguro de si las abreviaturas tues y thurs se admitían o no. las pruebas de las líneas 153 y 154 no se superaron, aunque deberían haberlo hecho [g2]. podemos corregirlas, junto a las pruebas de las líneas 163 a la 213, si realizamos los siguientes cambios en la función stringtomonthcode . 457 if ((result < 1) || (result > 12)) { result = -1; 458 for (int i = 0; i < monthnames.length; i++) { 459 if (s.equalsignorecase(shortmonthnames[i])) { 460 result = i + 1; 461 break; 462 } 463 if (s.equalsignorecase(monthnames[i])) { 464 result = i + 1; 465 break; 466 } 467 } 468 } la prueba comentada de la línea 318 descubre un error en el método getfollowingdayofweek (línea 672). el 25 de diciembre de 2004 fue sábado y el siguiente sábado fue el 1 de enero de 2005. sin embargo, al ejecutar la 339prueba, vemos que getfollowingdayofweek devuelve el 25 de diciembre como siguiente sábado después del 25 de diciembre, un error evidente [g3], [t1]. vemos el problema en la línea 685. es un error de condición de límite típico [t5]. debería ser lo siguiente: 685 if (basedow >= targetweekday) { conviene destacar que esta función sufrió una reparación anterior. el historial de cambios (línea 43) muestra que se corrigieron los errores en getpreviousdayofweek , getfollowingdayofweek y getnearestdayofweek [t6]. la prueba de unidad testgetnearestdayofweek (línea 329), que prueba el método getnearestdayofweek (línea 705), inicialmente no era tan extensa y completa. añadí multitud de casos de prueba ya que los iniciales no se superaban [t6]. puede ver el patrón de fallos si se fija en los casos de prueba comentados. el patrón es revelador [t7]. muestra que el algoritmo falla si el día más próximo es de una fecha futura. evidentemente se trata de algún tipo de error de condición de límite [t5]. el patrón de alcance de las pruebas generado por clover también es interesante [t8]. la línea 719 nunca se ejecuta, lo que significa que la instrucción if de la línea 718 siempre es false , pero si nos fijamos en el código, indica que debe ser true . la variable adjust siempre es negativa y no puede ser mayor o igual a 4, por lo que el algoritmo es incorrecto. a continuación se muestra el algoritmo correcto: int delta = targetdow - base.getdayofweek(); int positivedelta = delta + 7; int adjust = positivedelta % 7; if (adjust > 3) adjust -= 7; return serialdate.adddays (adjust, base); por último, las pruebas de la líneas 417 y 429 se pueden superar si se genera illegalargumentexception en lugar de devolver una cadena de error desde weekinmonthtostring y relativetostring . con estos cambios, todas las pruebas de unidad se superan y creo que ahora serialdate funciona. llega el momento de hacer que sea correcta. 340hacer que sea correcta describiremos serialdate de arriba a abajo para mejorarla en nuestro recorrido. aunque no lo veamos en este análisis, ejecutaré todas las pruebas de unidad de jcommon , incluida mi prueba de unidad mejorada para serialdate , con todos los cambios efectuados. por ello, tenga la seguridad de que todos los cambios que vea funcionan para jcommon . en la línea 1 vemos abundantes comentarios sobre información de licencia, derechos de autor, autores e historial de cambios. asumo que hay ciertos aspectos legales que mostrar, por lo que los derechos de autor y las licencias deben conservarse. por otra parte, el historial de cambios es una rémora de la década de 1960. ahora tenemos herramientas de control de código fuente que se encargan de ello. hay que eliminar este historial [c1]. la lista de importación que comienza en la línea 61 se puede reducir por medio de java.text.* y java.util.* . [j1] no me convence el formato html del javadoc (línea 67). un archivo fuente con más de un lenguaje me parece un problema. este comentario tiene cuatro lenguajes: java, español, javadoc y html [g1]. con tantos lenguajes se hace difícil mantener la coherencia. por ejemplo, la ubicación de las líneas 71 y 72 se pierde al generar el javadoc y además, ¿quién quiere ver <ul> y <li> en el código fuente? una estrategia más acertada consiste en rodear el comentario con <pre> para que el formato del código fuente se conserve en el javadoc [96] . la línea 86 es la declaración de la clase. ¿por qué se le asigna el nombre serialdate ? ¿qué sentido tiene la palabra serial ? ¿es porque la clase se deriva de serializable ? parece improbable. basta de adivinanzas. sé por qué (o al menos eso creo) se usa la palabra serial . la clave se encuentra en las constantes serial_lower_bound y serial_upper_bound de las líneas 98 y 101. y una clave todavía mejor es el comentario de la línea 830. el nombre de la clase es serialdate ya que se implementa con un número de serie, que parece ser el número de días desde el 30 de diciembre de 1899. 341pero esto supone un problema. por un lado, el término «número de serie» no es realmente correcto. puede ser un detalle menor pero la representación es más un desplazamiento relativo que un número de serie. el término «número de serie» tiene que ver más con marcadores de identificación de productos que con fechas. por ello, no lo considero especialmente descriptivo [n1]. un término más descriptivo sería «ordinal». el segundo problema es más significativo. el nombre serialdate implica una implementación. esta clase es abstracta. no es necesario que implique nada sobre la implementación; de hecho, es aconsejable ocultarla. por ello, creo que el nombre se encuentra en un nivel de abstracción incorrecto [n2]. en mi opinión, el nombre de esta clase debería ser simplemente date . desafortunadamente, hay demasiadas clases con el nombre date en la biblioteca de java, de modo que no es el más adecuado. como esta clase trabaja con días y no horas, podríamos usar day , pero ya se usa en otros muchos puntos. al final, opté por daydate como mejor opción. a partir de ahora, usaremos daydate . recuerde que los listados que va a leer siguen usando serialdate . entiendo porque daydate se hereda de comparable y serializable . ¿pero de monthconstants ? la clase monthconstants (véase el listado b-3) es una serie de constantes finales estáticas que definen los meses. heredar de clases con constantes es un viejo truco que los programadores de java usan para evitar expresiones como monthconstants.january , pero es una mala idea [j2]. monthconstants debería ser una enumeración. public abstract class daydate implements comparable, serializable { public static enum month { january(1), february(2), march(3), april(4), may(5), june(6), july(7), august(8), september(9), october(10), november(11), december(12); 342month(int index) { this.index = index; } public static month make(int monthindex) { for (month m : month.values()) { if (m.index == monthindex) return m; } throw new illegalargumentexception(“invalid month index ” + monthindex); } public final int index; } al cambiar monthconstants por esta enumeración se modifica la clase daydate y todos sus usuarios. tardé una hora en realizar todos los cambios. sin embargo, las funciones que antes aceptaban un valor int para el mes, ahora aceptan un enumerador month . esto significa que podemos deshacernos del método isvalidmonthcode (línea 326) y de la comprobación de errores del código de los meses como en monthcodetoquarter (línea 356) [g5]. tras ello, en la línea 91, tenemos serialversionuid . esta variable se usa para controlar el señalizador. si la cambiamos, con lo que todos los elementos daydate escritos con una versión antigua del software serán ilegibles y se generará invalidclassexception . si no declara la variable serialversionuid , el compilador genera una automáticamente y será diferente cada vez que modifique el módulo. ya sé que todos los documentos recomiendan el control manual de esta variable, pero creo que el control automático de la señalización es más seguro [g4]. después de todo, prefiero depurar una invalidclassexception que el extraño comportamiento que se produciría si me olvido de cambiar serialversionuid . por ello, eliminaré la variable, al menos por ahora [97] . creo que el comentario de la línea 93 es redundante. los comentarios redundantes sólo sirven para acumular mentiras y desinformación [c2]. por ello los eliminaré. los comentarios de las líneas 97 y 100 hablan sobre números de serie, que ya hemos mencionado antes [c1]. las variables que describen son la primera y última fecha posible que daydate puede describir. podríamos hacer que fuera más claro [n1]. 343public static final int earliest_date_ordinal = 2; // 1/1/1900 public static final int latest_date_ordinal = 2958465; // 12/31/9999 desconozco por qué earliest_date_ordinal es 2 en lugar de 0. el comentario de la línea 829 sugiere que tiene que ver con la forma de representar fechas en microsoft excel. hay información mucho más completa en una variante de daydate : spreadsheetdate (véase el listado b-5). el comentario de la línea 71 describe este problema. el problema parece relacionado con la implementación de spreadsheetdate y no con daydate . mi conclusión es que earliest_date_ordinal y latest_date_ordinal no pertenecen a daydate y deberían cambiarse a spreadsheetdate [g6]. de hecho, una búsqueda en el código demuestra que estas variables sólo se usan en spreadsheetdate . ni en daydate , ni en otras clases de la estructura jcommon. por lo tanto, las cambio por spreadsheetdate . las siguientes variables, minimum_year_supported y maximum_year_supported (líneas 104 y 107), constituyen un dilema. parece evidente que si daydate es una clase abstracta que no dice nada sobre implementación, no debería informarnos de un año mínimo o máximo. de nuevo, siento la necesidad de cambiar las variables a spreadsheetdate [g6]. pero una búsqueda rápida de los usuarios de estas variables muestra que otra clase las utiliza: relativedayofweekrule (véase el listado b-6), vemos dicho uso en las líneas 177 y 178, en la función getdate , donde se usan para comprobar que el argumento de getdate sea un año válido. el dilema es que un usuario de una clase abstracta necesita información sobre su implementación. tendremos que proporcionar esta información sin contaminar daydate . por lo general, obtendríamos la información de implementación de una instancia de una variante. sin embargo, la función getdate no recibe una instancia de daydate , aunque sí la devuelve, lo que significa que debe crearla en alguna parte. la solución está en las líneas 187-205. la instancia daydate se crea por medio de una de estas tres funciones: getpreviousdayofweek , getnearestdayofweek o getfollowingdayofweek . si nos fijamos en el 344listado daydate , vemos que estas funciones (líneas 638-724) devuelven una fecha creada por adddays (línea 571), que invoca createinstance (línea 808), que crea spreadsheetdate [g7]. no es recomendable que las clases base conozcan sus variantes. para corregirlo, debemos usar el patrón de factoría abstracta [98] y crear daydatefactory . esta factoría creará las instancias de daydate que necesitamos y también responderá a preguntas sobre la implementación, como las fechas máxima y mínima. public abstract class daydatefactory { private static daydatefactory factory = new spreadsheetdatefactory(); public static void set instance(daydatefactory factory) { daydatefactory.factory = factory; } protected abstract daydate _makedate(int ordinal); protected abstract daydate _makedate(int day, daydate.month month, int year); protected abstract daydate _makedate(int day, int month, int year); protected abstract daydate _makedate(java.util.date date); protected abstract int _getminimumyear(); protected abstract int _getmaximumyear(); public static daydate makedate(int ordinal) { return factory._makedate(ordinal); } public static daydate makedate(int day, daydate.month month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(int day, int month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(java.util.date date) { return factory._makedate(date); } public static int getminimumyear() { return factory._getminimumyear(); } public static int getmaximumyear() { return factory._getmaximumyear(); } } esta clase de factoría sustituye los métodos createinstance por métodos 345makedate , lo que mejora ligeramente los nombres [n1]. de forma predeterminada es spreadsheetdatefactory pero se puede cambiar por otra factoría. los métodos estáticos delegados en métodos abstractos usan una combinación de los patrones de instancia única [99] , decorador [100] y factoría abstracta que considero muy útil. spreadsheetdatefactory tiene este aspecto: public class spreadsheetdatefactory extends daydatefactory { public daydate _makedate(int ordinal) { return new spreadsheetdate(ordinal); } public daydate _makedate(int day, daydate.month month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(int day, int month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(date date) { final gregoriancalendar calendar = new gregoriancalendar(); calendar.settime(date); return new spreadsheetdate( calendar.get(calendar.date), daydate.month.make(calendar.get(calendar.month) + 1), calendar.get(calendar.year)); } protected int _getminimumyear() { return spreadsheetdate.minimum_year_supported; } protected int _getmaximumyear() { return spreadsheetdate.maximum_year_supported; } } como puede apreciar, hemos enviado las variables minimum_year_supported y maximum_year_supported a spreadsheetdate , donde pertenecen [g6]. el siguiente problema de daydate son las constantes de días, comenzando en la línea 109. deberían ser otra enumeración [j3]. ya hemos visto este patrón, de modo que no lo repetiremos. se incluye en los listados definitivos. seguidamente, vemos una serie de tablas que comienzan en last_day_of_month (línea 140). el primer problema con estas tablas es que 346los comentarios que las describen son redundantes [c3]. basta con sus nombres, de modo que eliminamos los comentarios. no hay motivos para que la tabla no sea privada [g8], ya que existe una función estática lastdayofmonth que proporciona los mismos datos. la siguiente tabla, aggregate_days_to_end_of_month , es más misteriosa, ya que no se usa en ninguna parte de la estructura jcommon [g9], de modo que la elimino. lo mismo sucede con leap_year_aggregate_days_to_end_of_month . la siguiente tabla, aggregate_days_to_end_of_preceding_month , sólo se usa en spreadsheetdate (líneas 434 y 473), lo que me hace dudar si transferirla a spreadsheetdate . la razón de no cambiarla es que la tabla no es específica de ninguna implementación concreta [g6]. por otra parte, sólo existe la implementación spreadsheetdate , de modo que la tabla debe acercarse a donde se vaya a usar [g10], para zanjar la duda y ser coherentes [g11], deberíamos privatizar la tabla y mostrarla a través de una función como juliandateoflastdayofmonth . pero nadie parece que la necesita. es más, la tabla se puede cambiar a daydate si una nueva implementación de daydate la necesita. así que la cambiamos. lo mismo sucede con leap_year_aggregate_days_to_end_of_month . tras ello, vemos tres grupos de constantes que se pueden convertir en enumeraciones (líneas 162-205). la primera selecciona una semana de un mes. la transformo en la enumeración weekinmonth . public enum weekinmonth { first(1), second(2), third(3), fourth(4), last(0); public final int index; weekinmonth(int index) { this.index = index; } } el segundo grupo de constantes (líneas 177-187) es más complicado. las constantes include_none, include_first, include_second e include_both se usan para describir si las fechas finales de un intervalo deben incluirse en el mismo. matemáticamente, se describe como intervalo 347abierto, intervalo a medio abrir e intervalo cerrado. creo que resulta más claro con la nomenclatura matemática [n3], de modo que lo cambio por la enumeración dateinterval con los enumeradores closed, closed_left, closed_right y open . el tercer grupo de constantes (líneas 18-205) describen si la búsqueda de un día concreto de la semana devuelve la última instancia, la siguiente o la más próxima. decidir un nombre adecuado es complicado. al final, opté por weekdayrange con los enumeradores last, next y nearest . puede que no esté de acuerdo con los nombres elegidos. para mí tienen sentido. lo importante es que ahora son más fáciles de cambiar [j3]. ya no se pasan como enteros, sino como símbolos. puedo usar la función de cambio de nombre de mi ide para cambiar los nombres o los tipos sin preocuparme de haberme olvidado de un -1 o un 2 en alguna parte del código o de que la declaración de un argumento int no estén bien descrita. el campo de descripción de la línea 208 no parece que se use en ninguna parte. lo elimino junto a sus elementos de acceso y mutación [g9]. también elimino el constructor predeterminado de la línea 213 [g12]. el compilador se encargará de generarlo. podemos ignorar el método isvalidweekdaycode (líneas 216-238) ya que lo eliminamos al crear la enumeración day . llegamos al método stringtoweekdaycode (líneas 242-270). los javadoc que no suponen demasiado para la firma del método sobran [c3], [g12]. el único valor de este javadoc es la descripción del valor devuelto -1 . sin embargo, como cambiamos a la enumeración day , el comentario es en realidad incorrecto [c2]. ahora el método genera illegalargumentexception . por ello, eliminamos el javadoc. también elimino las palabras clave final de argumentos y declaraciones de variables, ya que no parecen servir de mucho [g12]. la eliminación de final no goza de gran aceptación. por ejemplo, robert simmons [101] recomienda «… diseminar final por la totalidad del código». no estoy de acuerdo. creo que existen casos para usar final , por ejemplo como constante ocasional, pero en general, esta palabra clave apenas añade valor y suele ser 348un estorbo. puede que lo piense porque el tipo de errores que puede capturar final ya se capturan en las pruebas de unidad que he creado. las instrucciones if duplicadas [g5] del bucle for (líneas 259 y 263) son irrelevantes, de modo que las conecté en una única instrucción if con el operador || . también usé la enumeración day para dirigir el bucle for y realicé otros cambios estéticos. este método no pertenece realmente a daydate . en realidad es la función de análisis de day . por lo tanto, lo cambié a la enumeración day , lo que hizo que aumentara considerablemente de tamaño. como el concepto de day no depende de daydate , extraje la enumeración day de la clase daydate a un archivo propio [g13]. también cambié la siguiente función, weekdaycodetostring (líneas 272-286) a la enumeración day y le asigné el nombre tostring . public enum day { monday(calendar.monday), tuesday(calendar.tuesday), wednesday(calendar.wednesday), thursday(calendar.thursday), friday(calendar.friday), saturday(calendar.saturday), sunday(calendar.sunday); public final int index; private static dateformatsymbols datesymbols = new dateformatsymbols(); day(int day) { index = day; } public static day make(int index) throws illegalargumentexception { for (day d : day.values()) if (d.index == index) return d; throw new illegalargumentexception( string.format(“illegal day index: %d.”, index)); } public static day parse(string s) throws illegalargumentexception { string[] shortweekdaynames = datesymbols.getshortweekdays(); string[] weekdaynames = datesymbols.getweekdays(); s = s.trim(); for (day day : day.values()) { 349if (s.equalsignorecase(shortweekdaynames[day.index]) || s.equalsignorecase(weekdaynames[day.index])) { return day; } } throw new illegalargumentexception( string.format(“%s is not a valid weekday string”, s)); } public string tostring() { return datesymbols.getweekdays()[index]; } } hay dos funciones getmonths (líneas 288-316). la primera invoca la segunda. la segunda solamente se invoca desde la primera. por ello, las he combinado en una y las he simplificado considerablemente [g9], [g12], [f4]. por último, he cambiado el nombre por otro más descriptivo [n1]. public static string[] getmonthnames() { return dateformatsymbols.getmonths(); } la función isvalidmonthcode (líneas 326-346) es ahora irrelevante gracias a la enumeración month , de modo que la elimino [g9]. la función monthcodetoquarter (líneas 356-375) parece sufrir envidia de las características [102] [g14] y seguramente pertenezca a la enumeración month como método quarter , motivo por el que la sustituyo. public int quarter() { return 1 + (index-1)/3; } de este modo, la enumeración month tiene tamaño suficiente como para estar en una clase propia. la extraigo de daydate para mantener la coherencia con la enumeración day [g11], [g13]. los dos siguientes métodos tienen el nombre monthcodetostring (líneas 377-426). vemos de nuevo que uno invoca al otro con un indicador. no es recomendable pasar un indicador como argumento de una función, en especial si dicho indicador sólo selecciona el formato del resultado [g15]. por tanto, cambio de nombre, simplifico y reestructuro estas funciones y las incluyo en la enumeración month [n1], [n3], [c3], [g14]. public string tostring() { return dateformatsymbols.getmonths()[index - 1]; 350} public string toshortstring() { return dateformatsymbols.getshortmonths()[index – 1]; } el siguiente método es stringtomonthcode (líneas 428-472). lo cambio de nombre, lo paso a la enumeración month y lo simplifico [n1], [n3], [c3], [g14], [g12]. public static month parse(string s) { s = s.trim(); for (month m : month.values()) if (m.matches(s)) return m; try { return make(integer.parseint(s)); } catch (numberformatexception e) {} throw new illegalargumentexception(“invalid month ” + s); } private boolean matches(string a) { return s.equalsignorecase(tostring()) || s.equalsignorecase(toshortstring()); } el método isleapyear (líneas 495-517) se puede modificar para que sea más expresivo [g16]. public static boolean isleapyear(int year) { boolean fourth = year % 4 == 0; boolean hundredth = year % 100 == 0; boolean fourhundredth = year % 400 == 0; return fourth && (!hundredth || fourhundredth); } la siguiente función, leapyearcount (líneas 519-536) no pertenece realmente a daydate . nadie la invoca, excepto los dos métodos de spreadsheetdate , de modo que la desplazo hacia abajo [g6]. la función lastdayofmonth (líneas 538-560) usa la matriz last_day_of_month , que en realidad pertenece a la enumeración month [g17], por lo que la cambio de ubicación. también simplifico la función y aumento su expresividad [g16]. public static int lastdayofmonth(month month, int year) { if (month == month.february && isleapyear(year)) return month.lastday() + 1; else 351return month.lastday(); } ahora empieza a ponerse interesante. la siguiente función es adddays (líneas 562-576). en primer lugar, como opera en las variables de daydate , no debería ser estática [g18]. la cambio por un método de instancia. por otra parte, invoca la función toserial , cuyo nombre deberíamos cambiar por toordinal [n1]. por último, el método se puede simplificar. public daydate adddays(int days) { return daydatefactory.makedate(toordinal() + days); } lo mismo sucede con addmonths (líneas 578-602). debería ser un método de instancia [g18]. el algoritmo es un tanto complicado, de modo que recurro a la explicación de variables temporales [103] [g19] para que sea más transparente. también cambio el nombre del método getyyy por getyear [n1]. public daydate addmonths(int months) { int thismonthasordinal = 12 * getyear() + getmonth().index - 1; int resultmonthasordinal = thismonthasordinal + months; int resultyear = resultmonthasordinal / 12; month resultmonth = month.make(resultmonthasordinal % 12 + 1); int lastdayofresultmonth = lastdayofmonth(resultmonth, resultyear); int resultday = math.min(getdayofmonth(), lastdayofresultmonth); return daydatefactory.makedate(resultday, resultmonth, resultyear); } la función addyears (líneas 604-626) es similar al resto. public daydate plusyears(int years) { int resultyear = getyear() + years; int lastdayofmonthinresultyear = lastdayofmonth(getmonth(), resultyear); int resultday = math.min(getdayofmonth(), lastdayofmonthinresultyear); return daydatefactory.makedate(resultday, getmonth(), resultyear); } hay algo que me preocupa sobre el cambio de estos métodos de estáticos a métodos de instancia. ¿la expresión date.adddays(5) aclara que el objeto date no cambia y que se devuelve una nueva instancia de daydate o se supone, equivocadamente, que se añaden cinco días al objeto date ? pensará que no es un gran problema, pero un fragmento de código como el siguiente puede ser muy engañoso [g20]. daydate date = datefactory.makedate(5, month.december, 1952); date.adddays(7); // desplazar la fecha una semana 352un lector de este código podría aceptar que adddays cambia el objeto date , de modo que necesitamos un nombre que acabe con la ambigüedad [n4]: plusdays y plusmonths . creo que la intención del método se captura correctamente por medio de daydate date = olddate.plusdays(5); mientras que el siguiente no transmite con fluidez al lector que el objeto date ha cambiado: date.plusdays(5); los algoritmos son cada vez más interesantes. getpreviousdayofweek (líneas 628-660) funciona pero es complicado. tras meditar en lo que sucedía [g21], pude simplificarlo y aplicar la explicación de variables temporales [g19] para aclarar su significado. también lo cambié de método estático a método de instancia [g18] y me deshice del método de instancia duplicado [g5] (líneas 997-1008). public daydate getpreviousdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index = getdayofweek().index; if (offsettotarget >= 0) offsettotarget - 7; return plusdays(offsettotarget); } sucede exactamente lo mismo con getfollowingdayofweek (líneas 662-693). public daydate getfollowingdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index - getdayofweek().index; if (offsettotarget <= 0) offsettotarget += 7; return plusdays(offsettotarget); } la siguiente función es getnearestdayofweek (líneas 695-726), que corregimos en un apartado anterior. pero esos cambios no son coherentes con el patrón actual de las dos últimas funciones [g11]. por ello, recurro a la explicación de variables temporales [g19] para aclarar el algoritmo. public daydate getnearestdayofweek(final day targetday) { int offsettothisweekstarget = targetday.index - getdayofweek().index; int offsettofuturetarget = (offsettothisweekstarget + 7) % 7; int offsettoprevioustarget = offsettofuturetarget - 7; if (offsettofuturetarget > 3) 353return plusdays(offsettoprevioustarget); else return plusdays(offsettofuturetarget); } el método getendofcurrentmonth (líneas 728-740) es un tanto extraño ya que es un método de instancia que envidia [g14] a su propia clase aceptado un argumento daydate . lo convierto en un verdadero método de instancia y clarifico algunos de los nombres. public daydate getendofmonth() { month month = getmonth(); int year = getyear(); int lastday = lastdayofmonth(month, year); return daydatefactory.makedate(lastday, month, year); } la refactorización de weekinmonthtostring (líneas 742-761) resultó ser muy interesante. mediante las herramientas de refactorización de mi ide, primero cambié el método a la enumeración weekinmonth creada antes y después cambié el nombre por tostring . tras ello, lo convertí en método de instancia. todas las pruebas fueron correctas (¿adivina hacia dónde nos dirigimos?). seguidamente, eliminé el método. fallaron cinco afirmaciones (líneas 411-415 del listado b-4). cambié estas líneas para usar los nombres de los enumeradores ( first , second , etc.). las pruebas fueron correctas. ¿ve por qué? ¿puede ver también por qué son necesarios estos pasos? la herramienta de refactorización se encargó de que los invocadores anteriores de weekinmonthtostring invocaran ahora tostring en el enumerador weekinmonth ya que todos los enumeradores implementan tostring para devolver sus nombres… desafortunadamente, me pasé de listo. a pesar de la elegancia de la cadena de refactorización, comprobé que los únicos usuarios de esta función eran las pruebas que acababa de modificar, de modo que las eliminé. así pues, tras determinar que sólo las pruebas invocaban relativetostring (líneas 765-781), eliminé directamente la función y sus pruebas. hemos llegado a los métodos abstractos de esta clase abstracta. y el primero es toserial (líneas 838-844). en un apartado anterior cambié el nombre por toordinal . al verlo en este contexto, decidí que el cambio de 354nombre debería ser por getordinalday . el siguiente método abstracto es todate (líneas 838-844). convierte daydate en java.util.date . ¿por qué es abstracto? si analizamos su implementación en spreadsheetdate (líneas 198-207 del listado b-5), vemos que no depende de la implementación de esa clase [g6]. por tanto, lo desplazo hacia arriba. los métodos getyyyy , getmonth y getdayofmonth son evidentemente abstractos. sin embargo, getdayofweek debería ascender desde spreadsheetdate ya que no depende de nada de lo que encontremos en daydate [g6]. ¿o sí? si se fija atentamente (línea 247 del listado b-5), verá que el algoritmo depende implícitamente del origen del día ordinal (es decir, el día de la semana del día 0). por ello, aunque esta función carezca de dependencias físicas que no se puedan cambiar a daydate , cuenta con una dependencia lógica. este tipo de dependencias lógicas me molestan [g22]. si algo lógico depende de la implementación, también debería haber algo físico. además, me parece que el propio algoritmo podría ser genérico y que debería depender en menor medida de la implementación [g6]. por tanto, creé un método abstracto en daydate con el nombre getdayofweekforordinalzero y lo implementé en spreadsheetdate para devolver day.saturday . tras ello, envié el método getdayofweek a daydate y lo cambié para que invocara getordinalday y getdayofweekforordinalzero . public day getdayofweek() { day startingday = getdayofweekforordinalzero(); int startingoffset = startingday.index - day.sunday.index; return day.make((getordinalday() + startingoffset) % 7 + 1); } fíjese en el comentario de las líneas 895-899. ¿necesitamos realmente esta repetición? como de costumbre, eliminé este comentario junto a los demás. el siguiente método es compare (líneas 902-913). de nuevo, es incorrectamente abstracto [g6], por lo que cambio la implementación a daydate . además, el nombre no es descriptivo [n1]. en realidad, este método devuelve la diferencia en días desde el argumento, por lo que cambié el nombre por dayssince . tampoco existían pruebas para este método, de 355modo que las creé. las seis siguientes funciones (líneas 915-980) son métodos abstractos que deben implementarse en daydate , por lo que las extraje de spreadsheetdate . la última función, isinrange (líneas 982-995), también debe extraerse y refactorizarse. la instrucción switch no es agradable [g23] y se puede modificar si enviamos los casos a la enumeración dateinterval . public enum dateinterval { open { public boolean isin(int d, int left, int right) { return d > left && d < right; } }, closed_left { public boolean isin(int d, int left, int right) { return d >= left && d < right; } }, closed_right { public boolean isin(int d, int left, int right) { return d > left && d <= right; } }, closed { public boolean isin(int d, int left, int right) { return d >= left && d <= right; } }; public abstract boolean isin(int d, int left, int right); } public boolean isinrange(daydate d1, daydate d2, dateinterval interval) { int left = math.min(d1.getordinalday(), d2.getordinalday()); int right = math.max(d1.getordinalday(), d2.getordinalday()); return interval.isin(getordinalday(), left, right); } con esto llegamos al final de daydate . realizaremos una nueva pasada por la clase completa para comprobar cómo fluye. primero, el comentario inicial está desfasado, de modo que lo reduzco y lo mejoro [c2]. tras ello, desplazo las enumeraciones restantes a sus propios archivos [g12]. seguidamente, desplazo la variable estática ( dateformatsymbols ) y tres métodos estáticos ( getmonthnames , isleapyear , lastdayofmonth ) a una nueva clase con el nombre dateutil [g6]. 356cambio los métodos abstractos a una posición superior, donde pertenecen [g24]. cambio month.make por month.fromint [n1] y repito la operación con las demás enumeraciones. también creo un método de acceso toint() para todas las enumeraciones y convierto en privado el campo index . se produce una interesante duplicación [g5] en plusyears y plusmonths que conseguí eliminar extrayendo un nuevo método con el nombre correctlastdayofmonth , lo que aclaraba el significado de los tres métodos. me deshice del número mágico 1 [g25] y lo sustituí por month.january.toint() o day.sunday.toint() , según el caso. me detuve en limpiar los algoritmos de spreadsheetdate . el resultado final se puede comprobar en los listados b.7 a b.16. el alcance del código en daydate se ha reducido al 84.9 por 100, no porque se pruebe una cantidad menor de funcionalidad, sino porque la clase se ha reducido tanto que las líneas sin alcance tienen un peso mayor. ahora, en daydate las pruebas se aplican a 45 de las 53 instrucciones ejecutables. las líneas sin alcance son tan triviales que no merece la pena probarlas. conclusión otra vez hemos aplicado la regla del boy scout. hemos entregado el código más limpio de lo que lo recibimos. nos ha llevado tiempo, pero ha merecido la pena. el alcance de las pruebas ha aumentado, hemos corregido algunos errores y hemos aclarado y reducido el tamaño del código. la próxima persona que lo lea seguramente lo encontrará más fácil de leer. y probablemente esa persona sea capaz de limpiarlo algo más de lo que hemos hecho nosotros. bibliografía [gof] : design patterns: elements of reusable object oriented 357software , gamma et al., addison-wesley, 1996. [simmons04] : hardcore java , robert simmons, jr., o’reilly, 2004. [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. [beck97] : smalltalk best practice patterns , kent beck, prentice hall, 1997. 35817 síntomas y heurística en su magnífico libro refactoring [104] , martin fowler identifica diversos síntomas de código ( smells ). la lista que mostramos a continuación incluye muchos de los síntomas de martin y otros propios. también contiene otras perlas y heurística que suelo emplear en mi trabajo. 359para compilar esta lista he examinado diversos programas y los he refactorizado. al aplicar un cambio, me preguntaba el por qué y anotaba el motivo. el resultado es una extensa lista de aspectos que no me «huelen» bien cuando leo código. la lista se debe leer de arriba a abajo, y también se puede usar como referencia. comentarios c1: información inapropiada no es apropiado que un comentario contenga información que se pueda almacenar en otro tipo de sistema como un sistema de control de código fuente, de seguimiento de problemas o de mantenimiento de registros. los historiales de cambios, por ejemplo, abarrotan los archivos de código con abundante texto sin interés alguno. por lo general, metadatos como autores, fechas de modificación, números spr y similares no deben aparecer en los comentarios. los comentarios deben reservarse para notas técnicas sobre el código y el diseño. c2: comentario obsoleto un comentario anticuado, irrelevante e incorrecto es obsoleto. los comentarios envejecen rápidamente. es recomendable no escribir un comentario que vaya a quedar obsoleto. si detecta un comentario obsoleto, conviene actualizarlo o eliminarlo lo antes posible. los comentarios obsoletos tienden a alejarse del código que describían. se convierten en islas de irrelevancia y desorientación en el código. c3: comentario redundante un comentario es redundante si describe algo que ya se define correctamente 360por sí mismo. por ejemplo: i++; // incrementar i otro ejemplo es un javadoc que no dice más (o incluso menos) que la firma de una función: /** * @param sellrequest * @return * @throws managedcomponentexception */ public sellresponse beginsellitem(sellrequest sellrequest) throws managedcomponentexception los comentarios deben comunicar lo que el código no pueda expresar por sí mismo. c4: comentario mal escrito un comentario que merezca la pena escribir merece la pena ser leído. si piensa escribir un comentario, asegúrese de que es el mejor que puede crear. elija las palabras con atención. use gramática y puntuación correctas. no divague. no afirme lo evidente. sea breve. c5: código comentado me molesta ver grandes fragmentos de código comentado. ¿quién sabe qué antigüedad tienen? ¿quién sabe si tiene sentido o no? pero nadie lo borra porque piensa que alguien más lo necesita. ese código se estanca y se corrompe, y cada día que pasa es menos relevante. invoca funciones que ya no existen. usa variables cuyos nombres han cambiado. se rige por convenciones obsoletas. contamina los módulos en los que aparece y distrae a los usuarios que lo leen. el código comentado es una aberración. cuando vea código comentado, elimínelo. no se preocupe, el sistema de control de código fuente lo recordará. si alguien lo necesita, puede consultar una versión anterior. no sufra el código comentado para sobrevivir. 361entorno e1: la generación requiere más de un paso la generación de un proyecto debería ser una operación sencilla. no debería tener que comprobar demasiados elementos del control de código fuente. no debería necesitar una secuencia de antiguos comandos ni secuencias de comandos dependientes del contexto para generar cada elemento. no debería tener que buscar los distintos archivos jar, xml y similares necesarios para el sistema. debería finalizar el sistema con un sencillo comando y después ejecutar otro igual de sencillo para generarlo. svn get mysystem cd mysystem ant all e2: las pruebas requieren más de un paso debería poder ejecutar todas las pruebas de unidad con un solo comando. en el mejor de los casos, debería poder ejecutarlas pulsando un botón de su ide. en el peor, debería poder ejecutar un único comando en una línea de comandos. la capacidad de ejecutar todas las pruebas es tan importante que debe ser algo rápido, sencillo y obvio. funciones f1: demasiados argumentos las funciones deben tener un número reducido de argumentos. lo mejor es que no tengan, seguido de uno, dos y tres argumentos. más de tres ya es cuestionable y debería evitarse (véase el capítulo 3). 362f2: argumentos de salida los argumentos de salida son ilógicos. el lector espera que los argumentos sean entradas, no salidas. si su función tiene que cambiar el estado de algo, haga que cambie el estado del objeto en el que se invoca (véase el capítulo 3). f3: argumentos de indicador los argumentos booleanos declaran abiertamente que la función hace más de una cosa. resultan confusos y deben eliminarse (véase el capítulo 3). f4: función muerta los métodos que nunca se invocan deben descartarse. la presencia de código muerto es innecesaria. no tema eliminar la función. su sistema de control de código fuente la recordará. general g1: varios lenguajes en un archivo de código los modernos entornos de programación actuales permiten incluir varios lenguajes diferentes en el mismo archivo de código. por ejemplo, un archivo de java puede contener fragmentos de xml, html, yaml, javadoc, javascript, y similares. además de html, un archivo jsp podría incluir java, sintaxis de biblioteca de etiquetas, comentarios en español, javadoc, xml, javascript, etc. resulta confuso en el mejor de los casos y un desastre en el peor. lo ideal sería que el archivo de código incluyera un solo lenguaje pero, en realidad, seguramente tendremos que usar más de uno. debemos intentar minimizar la cantidad y el alcance de los lenguajes adicionales en nuestros 363archivos de código. g2: comportamiento evidente no implementado de acuerdo al principio de la mínima sorpresa [105] , una función o clase debe implementar los comportamientos que otro programador esperaría. por ejemplo, imagine una función que traduce el nombre de un día en una enumeración que represente dicho día. day day = daydate.stringtoday(string dayname); esperaríamos que la cadena « monday » se tradujera en day.monday. también esperaríamos la traducción de las abreviaturas habituales y que la función ignorara mayúsculas y minúsculas. cuando un comportamiento obvio no se implementa, los lectores y usuarios del código ya no dependen de su intuición sobre los nombres de las funciones. pierden su confianza en el autor original y se ven obligados a leer los detalles del código. g3: comportamiento incorrecto en los límites parece evidente afirmar que el código debe comportarse de forma correcta. el problema es que no nos damos cuenta de lo complicado que es dicho comportamiento correcto. los programadores suelen crear funciones que esperan que funcionen y confían en su intuición más que en comprobar que el código funciona en todos los casos de límites. no existe sustituto para la meticulosidad. las condiciones de límite, los casos extremos, las excepciones, representan algo que puede confundir a un algoritmo elegante e intuitivo. no dependa de su intuición . busque todas las condiciones de límite y cree pruebas para cada una. g4: medidas de seguridad canceladas chernobyl se derritió porque el director de la central ignoró todos y cada uno de los mecanismos de seguridad. impedían que se realizara un experimento. 364el resultado fue que el experimento no salió bien y el mundo fue testigo de la primera gran catástrofe nuclear para la población. anular las medidas de seguridad es un riesgo. puede que sea necesario ejercer el control manual sobre serialversionuid pero siempre es arriesgado. la desactivación de determinadas advertencias del compilador (o de todas) puede ayudarle a conseguir la generación, pero corre el riesgo de sufrir interminables sesiones de depuración. desactivar las pruebas que fallan y convencerse de que conseguirá que después sean satisfactorias es tan erróneo como pensar que sus tarjetas de crédito son dinero gratuito. g5: duplicación una de las reglas más importantes del libro y que debe tomarse muy en serio. la práctica totalidad de los autores que escriben sobre diseño de software mencionan esta regla. dave thomas y andy hunt la denominaron principio dry [106] ( don't repeat yourself , no repetirse). kent beck la convirtió en uno de los principios fundamentales de la programación extreme y la denominó «una sola vez». ron jeffries sitúa esta regla en segunda posición, por debajo de la consecución satisfactoria de todas las pruebas. siempre que vea duplicados en el código, indican una oportunidad de abstracción fallida. la duplicación podría convertirse en una subrutina o en otra clase. al incluir la duplicación en una abstracción, aumenta el vocabulario del lenguaje del diseño. otros programadores pueden usar sus creaciones abstractas. el código se vuelve más rápido y menos proclive a errores ya que ha aumentado el nivel de abstracción. el caso más evidente de duplicación es la presencia de fragmentos de código idéntico que parecen pegados repetidamente por el programador, sin sentido. conviene reemplazarlos por métodos simples. una forma más sutil es la cadena switch/case o if/else que aparece repetidamente en diversos módulos y que siempre prueba las mismas condiciones. conviene reemplazar estas cadenas por polimorfismo. y más sutiles todavía son los módulos con algoritmos similares pero que no comparten las mismas líneas de código. sigue siendo duplicación y debe 365corregirse por medio del patrón de método de plantilla [107] o estrategia [108] . en realidad, la mayoría de patrones de diseño aparecidos en los últimos 15 años son formas de eliminar la duplicación. las formas normales de codd también son una estrategia para eliminar la duplicación en esquemas de base de datos. incluso la programación orientada a objetos es una estrategia para organizar módulos y eliminar la duplicación. no debería sorprenderle, ya que se trata de programación estructurada. creo que el objetivo es evidente: localice los elementos duplicados y elimínelos siempre que pueda. g6: código en un nivel de abstracción incorrecto es importante crear abstracciones que separen conceptos generales de nivel superior de conceptos detallados de nivel inferior. para ello, en ocasiones creamos clases abstractas que contengan los conceptos de nivel superior y variantes los de nivel inferior. si lo hacemos, debemos asegurarnos de que la separación sea completa. todos los conceptos de nivel inferior deben estar en las variantes y los de nivel superior en la clase base. por ejemplo, constantes, variables o funciones de utilidad que solamente pertenezcan a la implementación detallada no deben aparecer en la clase base. la clase base no debe saber nada al respecto de estos elementos. esta regla también se aplica a archivos fuente, componentes y módulos. el diseño correcto de software requiere la separación de conceptos en distintos niveles y su inclusión en contenedores diferentes. en ocasiones, dichos contenedores son clases base o variantes, y en otros casos son archivos fuente, módulos o componentes. independientemente del caso, la separación debe ser completa. no queremos que conceptos de nivel inferior y superior se mezclen. fíjese en este código: public interface stack { object pop() throws emptyexception; void push(object o) throws fullexception; double percentfull(); class emptyexception extends exception {} class fullexception extends exception {} } la función percentfull se encuentra en el nivel de abstracción 366equivocado. aunque hay implementaciones de stack en las que el concepto de amplitud es razonable, otras no pueden conocer su nivel de amplitud. por tanto, la función debería incluirse en una interfaz derivada como boundedstack . pensará que la implementación podría devolver cero si la pila no tuviera límites. el problema es que no existen pilas totalmente sin límites. no se puede evitar outofmemoryexception mediante la comprobación de stack.percentfull() < 50.0. la implementación de esta función para que devuelva 0 sería una mentira. la moraleja es que no puede mentir o escapar de una abstracción mal ubicada. el aislamiento de abstracciones es una de las operaciones más complicadas para los desarrolladores de software y no se puede corregir cuando se realiza de forma incorrecta. g7: clases base que dependen de sus variantes el motivo más habitual para dividir conceptos en clases base y derivadas es para que los conceptos de nivel superior de la clase base sean independientes de los de nivel inferior de las derivadas. por ello, cuando vemos clases base que mencionan los nombres de sus variantes, se intuye un problema. por lo general, las clases base no deben saber nada sobre su derivadas. evidentemente, hay excepciones. en ocasiones, el número de variantes es fijo y la clase base tiene código que elegir entre las variantes. es muy habitual en implementaciones de equipos con estado finito. sin embargo, en ese caso las variantes y la clase base están íntimamente unidas y siempre se implementan en el mismo archivo jar. en el caso general, deben implementarse en archivos independientes. al implementar variantes y clases base en archivos diferentes y garantizar que los archivos de la clase base desconocen el contenido de los archivos de las variantes podemos implementar nuestros sistemas en componentes discretos e independientes. al modificar dichos componentes, se pueden volver a implementar sin necesidad de implementar de nuevo los componentes base. de este modo se reduce significativamente el impacto del 367cambio y se facilita el mantenimiento de los sistemas. g8: exceso de información los módulos bien definidos tienen interfaces reducidas que nos permiten hacer mucho con poco. los módulos definidos de forma incorrecta tienen interfaces más amplias que nos obligan a usar distintos gestos para realizar operaciones sencillas. una interfaz bien definida no ofrece demasiadas funciones y las conexiones son reducidas. una interfaz definida de forma incorrecta ofrece multitud de funciones que invocar y, por tanto, las conexiones son elevadas. los buenos programadores de software aprenden a limitar la parte de sus clases y módulos que muestran en sus interfaces. cuantos menos métodos tenga una clase, mejor. cuantas menos variables conozca una función, mejor. cuantas menos variables de instancia tenga una clase, mejor. oculte sus datos. oculte sus funciones de utilidad. oculte sus constantes y elementos temporales. no cree clases con multitud de métodos y variables de instancia. no cree multitud de variables y funciones protegidas para sus subclases. concéntrese en crear interfaces concisas y de tamaño reducido. limite la información para reducir las conexiones. g9: código muerto el código muerto es el que no se ejecuta. se encuentra en el cuerpo de una instrucción if que comprueba una condición que no sucede. se encuentra en el bloque catch de una instrucción try que carece de throws . se encuentra en pequeños métodos de utilidad que nunca se invocan o en condiciones switch/case inexistentes. el problema del código muerto es que con el tiempo empieza a oler. cuanto más antiguo es, más profundo el hedor que despide. se debe a que el código muerto no se actualiza al cambiar los diseños. sigue compilándose pero no se rige por nuevas convenciones o reglas. se creó en un momento en el que el sistema era diferente . debe tener un entierro digno. bórrelo del 368sistema. g10: separación vertical variables y funciones deben definirse cerca de donde se utilicen. las variables locales deben declararse por encima de su primer uso y deben tener un reducido ámbito vertical. no deben declararse a cientos de líneas de distancia de su uso. las funciones privadas deben definirse justo debajo de su primer uso. pertenecen al ámbito de la clase completa pero conviene limitar la distancia vertical entre las invocaciones y las definiciones. para localizar una función privada debe bastar con buscar debajo de su primer uso. g11: incoherencia si hace algo de una forma concreta, aplique la misma técnica a operaciones similares. esto entronca con el principio de mínima sorpresa. preste atención a las convenciones que elija y, una vez elegidas, asegúrese de mantenerlas. si en una función concreta usa la variable response para almacenar httpservletresponse , use el mismo nombre de variable en las demás funciones que usen objetos httpservletresponse . si asigna el nombre processverificationrequest a un método, use un nombre similar, como processdeletionrequest , para los métodos que procesen otros tipos de solicitudes. este tipo de coherencia, si se aplica repetidamente, facilita la lectura y modificación del código. g12: desorden ¿para qué sirve un constructor predeterminado sin implementación? únicamente desordena el código y lo inunda de elementos sin sentido. variables sin usar, funciones que nunca se invocan, comentarios que no añaden información, etc. todos estos elementos sobran y deben eliminarse. 369mantenga limpios sus archivos, bien organizados y sin elementos sobrantes. g13: conexiones artificiales los elementos que no dependen unos de otros no deben conectarse de forma artificial. por ejemplo, las enumeraciones generales no deben incluirse en clases más específicas ya que esto obliga a la aplicación a saber más sobre dichas clases. lo mismo sucede con funciones static de propósito general declaradas en clases específicas. por lo general, una conexión artificial es la que se establece entre dos módulos sin un propósito directo. es el resultado de incluir una variable, constante o función en una ubicación temporalmente útil pero inadecuada. es un síntoma de falta de atención. piense en dónde debe declarar sus funciones, constantes y variables. no las deje en el punto más cómodo. g14: envidia de las características uno de los síntomas de martin fowler [109] . los métodos de una clase deben interesarse por las variables y funciones de la clase a la que pertenecen, no por las variables y funciones de otras clases. cuando un método usa elementos de acceso y mutación de otro objeto para manipular los datos de éste, envidia el ámbito de la clase de dicho objeto. desea formar parte de la otra clase para tener acceso directo a las variables que manipula. por ejemplo: public class hourlypaycalculator { public money calculateweeklypay(hourlyemployee e) { int tenthrate = e.gettenthrate().getpennies(); int tenthsworked = e.gettenthsworked(); int straighttime = math.min(400, tenthsworked); int overtime = math.max(0, tenthsworked - straighttime); int straightpay = straighttime * tenthrate; int overtimepay = (int)math.round(overtime*tenthrate*1.5); return new money(straightpay + overtimepay); } } el método calculateweeklypay se acerca al objeto hourlyemployee para 370obtener los datos sobre los que opera. el método calculateweeklypay envidia el ámbito de hourlyemployee . su deseo es formar parte de hourlyemployee . es recomendable suprimir la envidia de características ya que muestra los detalles internos de una clase a otra. sin embargo, en ocasiones es un mal necesario. fíjese en lo siguiente: public class hourlyemployeereport { private hourlyemployee employee; public hourlyemployeereport(hourlyemployee e) { this.employee = e; } string reporthours() { return string.format( “name: %s\thours:%d.%1d\n”, employee.getname(), employee.gettenthsworked()/10, employee.gettenthsworked()%10); } } evidentemente, el método reporthours envidia la clase hourlyemployee . por otra parte, no queremos que hourlyemployee tenga que conocer el formato del informe. al incluir la cadena de formato en la clase hourlyemployee incumpliríamos varios de los principios del diseño orientado a objetos [110] . conectaría hourlyemployee al formato del informe y lo mostraría en los cambios de dicho formato. g15: argumentos de selector no hay nada más abominable que un argumento false aislado al final de la invocación de una función. ¿qué significa? ¿qué cambiaría si fuera true ? no sólo el propósito de un argumento de selector es difícil de recordar, sino que cada argumento de selector combina varias funciones en una. los argumentos de selector son una forma indolente de evitar dividir una función de gran tamaño en otras menores. fíjese en lo siguiente: public int calculateweeklypay(boolean overtime) { int tenthrate = gettenthrate(); int tenthsworked = gettenthsworked(); 371int straighttime = math.min(400, tenthsworked); int overtime = math.max(0, tenthsworked - straighttime); int straightpay = straighttime * tenthrate; double overtimerate = overtime ? 1.5 : 1.0 * tenthrate; int overtimepay = (int)math.round(overtime*overtimerate); return straightpay + overtimepay; } esta función se invoca con true si las horas extras se pagan como hora y media, y con false si se pagan como una hora normal. ya es bastante malo tener que recordar lo que significa calculateweeklypay(false) cada vez que aparezca. pero lo peor de esta función es que el autor ha perdido la oportunidad de crear lo siguiente: public int straightpay() { return gettenthsworked() * gettenthrate(); } public int overtimepay() { int overtimetenths = math.max(0, gettenthsworked() - 400); int overtimepay = overtimebonus(overtimetenths); return straightpay() + overtimepay; } private int overtimebonus(int overtimetenths) { double bonus = 0.5 * gettenthrate() * overtimetenths; return (int) math.round(bonus); } evidentemente, los selectores no deben ser boolean . pueden ser enumeraciones, enteros u otro tipo de argumento que se use para seleccionar el comportamiento de la función. es más recomendable tener varias funciones que pasar código a una función para seleccionar el comportamiento. g16: intención desconocida queremos que el código sea lo más expresivo posible. expresiones extensas, notación húngara y números mágicos distorsionan la intención del autor. por ejemplo, veamos la función overtimepay cómo podría haber aparecido: public int m_otcalc() { return ithswkd * ithsrte + (int) math.round(0.5 * ithsrte * math.max(0/ ithswkd - 400) ); } 372aunque parezca reducida y densa, también es prácticamente impenetrable. es recomendable dedicar tiempo a lograr que la intención de nuestro código sea aparente para nuestros lectores. g17: responsabilidad desubicada una de las principales decisiones de un programador de software es dónde ubicar el código. por ejemplo, dónde incluir la constante pi . ¿en la clase math ? ¿pertenece a la clase trigonometry ? ¿o a la clase circle ? el principio de mínima sorpresa vuelve a aparecer. el código debe ubicarse donde el lector espera encontrarlo. la constante pi debe incluirse junto a la declaración de las funciones trigonométricas. la constante overtime_rate debe declararse en la clase hourlypaycalculator . en ocasiones presumimos de dónde añadimos una determinada funcionalidad. incluimos una función porque nos resulta cómodo pero no porque sea intuitivo para el lector. por ejemplo, puede que tengamos que imprimir un informe con el total de horas que ha trabajado un empleado. podríamos sumar las horas en el código que imprime el informe o intentar mantener un total en el código que acepte horarios de trabajo. una forma de tomar esta decisión consiste en analizar el nombre de las funciones. imagine que el módulo del informe tiene la función gettotalhours . imagine también que el módulo que acepta horarios de trabajo tiene la función savetimecard . ¿cuál de las dos, por nombre, implica que calcula el total? la respuesta es evidente. existen motivos de rendimiento para calcular el total como horarios de trabajo y no como informe impreso. es correcto, pero el nombre de las funciones debería reflejarlo. por ejemplo, debería haber una función computerunningtotalofhours en el módulo de horarios. g18: elementos estáticos incorrectos math.max (double a, double b) es un método estático correcto. no opera 373en una única instancia; de hecho, sería un error tener que usar new math().max(a,b) o incluso a.max(b) . todos los datos que usa max provienen de sus dos argumentos, no de un objeto. además, es prácticamente imposible que queramos que math.max sea polimórfico. sin embargo, en ocasiones creamos funciones estáticas que no deben serlo. fíjese en este ejemplo: hourlypaycalculator.calculatepay(employee, overtimerate). de nuevo, parece una función estática razonable. no opera en un objeto concreto y recibe todos los datos de sus argumentos. sin embargo, existe la posibilidad de que queramos que sea polimórfica. puede que queramos implementar distintos algoritmos para calcular el precio de la hora, como por ejemplo. overtimehourlypaycalculator y straighttimehourlypaycalculator . en este caso, la función no debe ser estática. debería ser una función miembro no estática de employee . por lo general, debe decantarse por métodos no estáticos. en caso de duda, convierta la función en no estática. si realmente quiere que una función sea estática, asegúrese de que nunca querrá que sea polimórfica. g19: usar variables explicativas kent beck escribió sobre este tema en su magnífico libro smalltalk best practice patterns [111] y, más recientemente en implementation patterns [112] . una de las técnicas más completas para que un programa sea legible consiste en dividir los cálculos en valores intermedios almacenados en variables con nombres descriptivos. fíjese en este ejemplo de fitnesse: matcher match = headerpattern.matcher(line); if(match.find()) { string key = match.group(1); string value = match.group(2); headers.put(key.tolowercase(), value); } el simple uso de variables explicativas ilustra con claridad que el primer grupo comparado es la clave y el segundo es el valor . es complicado excederse en esta técnica. por lo general, es mejor tener más variables explicativas que menos. es sorprendente que un módulo opaco 374se vuelva más transparente con tan sólo dividir los cálculos en valores intermedios con los nombres adecuados. g20: los nombres de función deben indicar lo que hacen fíjese en este código: date newdate = date.add(5); ¿intuye que se añaden cinco días a la fecha o son semanas u horas? ¿la instancia date cambia y la función simplemente devuelve un nuevo objeto date sin cambiar el antiguo? por la invocación no podemos saber qué hace la función . si la función añade cinco días a la fecha y después la cambia, el nombre debería ser adddaysto o increasebydays . si, por otra parte, la función devuelve una nueva fecha con cinco días más pero no cambia la instancia date , el nombre debería ser dayslater o dayssince . si tiene que fijarse en la implementación (o documentación) de la función para saber qué hace, tendrá que elegir un nombre más apropiado o modificar la funcionalidad para que se pueda incluir en funciones con nombres más acertados. g21: comprender el algoritmo se crea gran cantidad de código extraño porque los autores no se esfuerzan en comprender el algoritmo. consiguen que algo funcione combinando instrucciones if e indicadores sin pararse a pensar en qué sucede realmente. la programación es una tarea de exploración. creemos que conocemos el algoritmo adecuado para algo pero después lo modificamos y variamos hasta conseguir que funcione . ¿cómo sabemos que funciona ? porque supera los casos de prueba que pensamos. no es un enfoque equivocado. de hecho, suele ser la única forma de conseguir que una función haga lo que pensamos que debe hacer. sin 375embargo, no basta con conseguir que funcione . antes de creer que hemos terminado con una función, asegúrese de entender su funcionamiento. no basta con que supere todas las pruebas. tiene que estar seguro [113] de que la solución es la correcta. por lo general, la forma óptima de saberlo consiste en refactorizar la función en algo tan limpio y expresivo que su funcionamiento sea evidente . g22: convertir dependencias lógicas en físicas si un módulo depende de otro, dicha dependencia debe ser física, no sólo lógica. el módulo dependiente no debe asumir aspectos (es decir, dependencias lógicas) sobre el módulo del que depende. por el contrario, debe solicitar de forma explícita al módulo toda la información de la que depende. por ejemplo, imagine que tiene que crear una función que imprima un informe de las horas trabajadas por cada empleado. la clase hourlyreporter recopila los datos y los pasa a hourlyreportformatter para imprimirlos (véase el listado 17-1). listado 17-1 hourlyreporter.java. public class hourlyreporter { private hourlyreportformatter formatter; private list<lineitem> page; private final int page_size = 55; public hourlyreporter(hourlyreportformatter formatter) { this.formatter = formatter; page = new arraylist<lineitem>(); } public void generatereport(list<hourlyemployee> employees) { for (hourlyemployee e : employees) { addlineitemtopage(e); if (page.size() == page_size) printandclearitemlist(); } if (page.size() > 0) printandclearitemlist(); 376} private void printandclearitemlist() { formatter.format(page); page.clear(); } private void addlineitemtopage(hourlyemployee e) { lineitem item = new lineitem(); item.name = e.getname(); item.hours = e.gettenthsworked() / 10; item.tenths = e.gettenthsworked() % 10; page.add(item); } public class lineitem { public string name; public int hours; public int tenths; } } este código tiene una dependencia lógica que no se ha convertido en física. ¿la detecta? es la constante page_size . ¿para qué necesita hourlyreporter saber el tamaño de la página? el tamaño de la página debe ser responsabilidad de hourlyreportformatter . la declaración de page_size en hourlyreporter representa una responsabilidad desubicada [g17] que hace que hourlyreporter asuma que conoce el tamaño que debe tener la página. esta presunción es una dependencia lógica. hourlyreporter depende de que hourlyreportformatter pueda procesar tamaños de página de hasta 55. si alguna implementación de hourlyreportformatter no puede asumir esos tamaños, se producirá un error. podemos convertir en física esta dependencia si creamos un nuevo método en hourlyreportformatter con el nombre getmaxpagesize() . tras ello, hourlyreporter invoca esta función en lugar de usar la constante page_size . g23: polimorfismo antes que if/else o switch/case puede parecer una sugerencia extraña dado el tema descrito en el capítulo 6. en este capítulo, afirmo que las instrucciones switch son adecuadas en partes del sistema en las que se añadan más funciones nuevas que tipos nuevos. 377por un lado, la mayoría usamos instrucciones switch por ser una solución de fuerza bruta evidente, no por ser la solución perfecta. por tanto, esta heurística nos recuerda que debemos considerar el uso de polimorfismo antes de usar switch . por otra parte, los casos en que las funciones son más volátiles que los tipos son escasos. por tanto, toda instrucción switch es sospechosa. suelo aplicar la siguiente regla de una instrucción switch : no puede haber más de una instrucción  switch  por cada tipo de selección. los casos de esa instrucción  switch  deben crear objetos polimórficos que ocupen el lugar de otras instrucciones  switch  similares en el resto del sistema . g24: seguir las convenciones estándar todos los equipos deben seguir un estándar de diseño de código basado en normas comunes de la industria. este estándar debe especificar aspectos como dónde declarar variables de instancia, cómo asignar nombres a clases, métodos y variables, dónde añadir llaves, etc. el equipo no debe necesitar un documento que describa estas convenciones ya que su código proporciona los ejemplos. todos los miembros del equipo deben seguir estas convenciones, lo que significa que no importa dónde añada cada uno las llaves mientras todos estén de acuerdo en dónde añadirlas. si desea saber qué convenciones aplico, puede verlas en el código refactorizado de los listados b.7 a b.14 del apéndice b. g25: sustituir números mágicos por constantes con nombre es probablemente una de las reglas más antiguas del desarrollo de software . recuerdo haberla leído a finales de la década de 1960 en manuales de cobol, fortran y pl/1. por lo general, no es recomendable incluir números sin procesar en el código; debe ocultarlos tras constantes con 378nombres correctos. por ejemplo, el número 86 400 debe ocultarse tras la constante seconds_per_day . si va a imprimir 55 líneas por página, la constante 55 debe ocultarse tras la constante lines_per_page . algunas constantes son tan fáciles de reconocer que no siempre necesitan una constante con nombre tras la que ocultarse mientras se usen junto a código explicativo. por ejemplo: double mileswalked = feetwalked/5280.0; int dailypay = hourlyrate * 8; double circumference = radius * math.pi * 2; ¿necesitamos realmente las constantes feet_per_mile, work_hours_per_day y two en los ejemplos anteriores? el último caso es absurdo. existen ciertas fórmulas en las que las constantes se escriben mejor como números sin procesar. puede cuestionar el caso de work_hours_per_day ya que las leyes o las convenciones pueden cambiar. por otra parte, esa fórmula se lee perfectamente si se incluye el 8 por lo que no es necesario añadir 17 más. en el caso de feet_per_mile , el número 5280 es una constante tan conocida y exclusiva que los lectores la reconocerán aunque se muestre de forma independiente en una página sin contexto alguno. constantes como 3.141592653589793 también son conocidas y reconocibles. sin embargo, la probabilidad de errores es alta y no conviene mostrarlas tal cual. siempre que alguien ve 3.1415927535890793, sabe que es π, y no se molestan en examinarlo (¿ha visto el error de un dígito?). tampoco queremos que la gente use 3.14, 3.14159, 3.142, y similares. por lo tanto, es una suerte contar con math.pi . el término número mágico no sólo se aplica a números, sino a todo símbolo que tenga un valor que no sea descriptivo por sí mismo. por ejemplo: assertequals(7777, employee.find(“john doe”).employeenumber()); en esta afirmación hay dos números mágicos. el primero es obviamente 7777, aunque no significa que no sea obvio. el segundo es « john doe » y su cometido tampoco está claro. “john doe” es el nombre del empleado #7777 en una conocida base de datos de pruebas creada por nuestro equipo. todo el mundo sabe que al 379conectarse a la base de datos, ya cuenta con varios empleados con sus valores y atributos. además, « john doe » representa el único empleado por horas de la base de datos. por tanto, la prueba debería ser la siguiente: assertequals( hourly_employee_id, employee.find(hourly_employee_name).employeenumber()); g26: precisión esperar que la primera coincidencia de una consulta sea la única es una ingenuidad. el uso de números de coma flotante para representar divisas es casi un delito. evitar bloqueos y/o la administración de transacciones por creer que las actualizaciones concurrentes no son posibles es pura indolencia. declarar una variable como arraylist cuando se necesita list es un exceso de restricciones. crear todas las variables como protected de forma predeterminada es falta de restricciones. al adoptar una decisión en el código, debe hacerlo de forma precisa. debe saber por qué la adopta y cómo afrontará las excepciones. no sea indolente sobre la precisión de sus decisiones. si decide invocar una función que pueda devolver null , asegúrese de comprobar null . si consulta el que considera el único registro de una base de datos, asegúrese de que el código comprueba que no haya otros. si tiene que trabajar con divisas, use enteros [114] y aplique el redondeo correcto. si existe la posibilidad de una actualización concurrente, asegúrese de implementar algún tipo de mecanismo de bloqueo. en el código, la ambigüedad y las imprecisiones son el resultado de desacuerdos o de indolencia. en cualquier caso, elimínelas. g27: estructura sobre convención aplique las decisiones de diseño con estructura y no convenciones. las convenciones de nomenclatura son correctas pero resultan inferiores a estructuras que refuerzan la compatibilidad. por ejemplo, los casos switch con enumeraciones de nombres correctos son inferiores a clases base con 380métodos abstractos. no estamos obligados a implementar siempre la instrucción switch/case de la misma forma, pero las clases base hacen que las clases concretas implementen métodos abstractos. g28: encapsular condicionales la lógica booleana es difícil de entender sin necesidad de verla en el contexto de una instrucción if o while . extraiga funciones que expliquen el cometido de la condicional. por ejemplo: if (shouldbedeleted(timer)) es preferible a if (timer.hasexpired() && !timer.isrecurrent()) g29: evitar condicionales negativas las condicionales negativas son más difíciles de entender que las positivas. por ello, siempre que sea posible, debe expresar las condiciones como positivas. por ejemplo: if (buffer.shouldcompact()) es preferible a if (!buffer.shouldnotcompact()) g30: las funciones sólo deben hacer una cosa es tentador crear funciones con varias secciones que realicen una serie de operaciones. este tipo de funciones hacen más de una cosa y deben convertirse en funciones de menor tamaño, cada una para una cosa . por ejemplo: public void pay() { for (employee e : employees) { if (e.ispayday()) { money pay = e .calculatepay(); e.deliverpay(pay); } } 381} este fragmento de código realiza tres operaciones. itera por todos los empleados, comprueba si cada uno debe recibir su paga y después paga al empleado. se podría reescribir de esta forma: public void pay() { for (employee e : employees) payifnecessary(e); } private void payifnecessary(employee e) { if (e.ispayday()) calculateanddeliverpay(e); } private void calculateanddeliverpay(employee e) { money pay = e.calculatepay(); e.deliverpay(pay); } cada una de estas funciones hace una sola cosa (véase el capítulo 3). g31: conexiones temporales ocultas las conexiones temporales suelen ser necesarias pero no debe ocultar la conexión. estructure los argumentos de sus funciones de modo que el orden de invocación sea evidente. fíjese en lo siguiente: public class moogdiver { gradient gradient; list<spline> splines; public void dive(string reason) { saturategradient(); reticulatesplines(); diveformoog(reason); } … } el orden de las tres funciones es importante. debe saturar el degradado antes de poder entrelazar las tiras, para después continuar. desafortunadamente, el código no aplica esta conexión temporal. otro programador podría invocar reticulatesplines antes de saturategradient , lo que generaría unsaturatedgradientexception . una solución más acertada sería: 382public class moogdiver { gradient gradient; list<spline> splines; public void dive(string reason) { gradient gradient = saturategradient(); list<spline> splines = reticulatesplines(gradient); diveformoog(splines, reason); } … } de este modo se muestra la conexión temporal generando una especie de embudo. cada función genera un resultado que la siguiente necesita de modo que no se pueden invocar en otro orden. puede argumentar que esto aumenta la complejidad de las funciones y tiene razón, pero ese incremento de complejidad sintáctica muestra la verdadera complejidad temporal de la situación. observará que he mantenido las variables de instancia. imagino que son necesarias para los métodos privados de las clases. incluso así, conservo los argumentos para que la conexión temporal sea explícita. g32: evitar la arbitrariedad argumente la estructura de su código y asegúrese de que la estructura del código comunica dicho argumento. si la estructura parece arbitraria, otros se verán con derecho a modificarla. si la estructura parece coherente en la totalidad del sistema, otros la usarán y conservarán la convención. por ejemplo, recientemente repasaba cambios realizados en fitnesse y descubrí lo siguiente: public class aliaslinkwidget extends parentwidget { public static class variableexpandingwidgetroot { … … } el problema es que variableexpandingwidgetroot no debía estar en el ámbito de aliaslinkwidget . es más, otras clases sin relación usaban aliaslinkwidget.variableexpandingwidgetroot y no tenían por qué saber 383nada de aliaslinkwidget . puede que el programador añadiera variableexpandingwidgetroot a aliaswidget por comodidad o que realmente pensara que debía formar parte del ámbito de aliaswidget . independientemente del motivo, el resultado será arbitrario. las clases públicas que no son utilidades de otra clase no deben incluirse en el ámbito de otra clase. la convención es convertirlas en públicas en el nivel superior de su paquete. g33: encapsular condiciones de límite las condiciones de límite son difíciles de controlar. aísle su procesamiento y no permita que se transfieran al resto del código. no necesitamos legiones de +1 y -1 por todas partes. fíjese en este ejemplo de fit: if (level + 1 < tags.length) { parts = new parse(body, tags, level + 1, offset + endtag); body = null; } level+1 aparece dos veces. es una condición de límite que debe encapsularse en una variable con un nombre como nextlevel . int nextlevel = level + 1; if(nextlevel < tags.length) { parts = new parse(body, tags, nextlevel, offset + endtag); body = null; } g34: las funciones sólo deben descender un nivel de abstracción las instrucciones de una función deben crearse en el mismo nivel de abstracción, un nivel por debajo de la operación descrita por el nombre de la función. puede que sea la heurística más difícil de interpretar y aplicar. aunque la idea es simple, como humanos nos cuesta mezclar niveles de abstracción. fíjese en el siguiente código de fitnesse: public string render() throws exception { 384stringbuffer html = new stringbuffer(“<hr”); if(size > 0) html.append(“ size=\“”).append(size + 1).append(“\””); html.append(“>”); return html.tostring(); } si lo analiza, verá lo que sucede. esta función crea la etiqueta html que traza una regla horizontal por la página. la altura de la regla se especifica en la variable size . fíjese otra vez en el código. este método mezcla al menos dos niveles de abstracción. el primero es la noción de que una regla horizontal tiene un tamaño. el segundo es la sintaxis de la propia etiqueta hr . el código proviene del módulo hrulewidget de fitnesse. este módulo detecta una fila de cuatro o más guiones y la convierte en la correspondiente etiqueta hr . cuantos más guiones haya, mayor será el tamaño. a continuación le muestro la refactorización del código. he cambiado el nombre del campo size para reflejar su verdadero cometido. contenía el número de guiones adicionales. public string render() throws exception { htmltag hr = new htmltag(“hr”); if (extradashes > 0) hr.addattribute(“size”, hrsize(extradashes)); return hr.html(); } private string hrsize(int height) { int hrsize = height + 1; return string.format(“%d”, hrsize); } este cambio separa correctamente los dos niveles de abstracción. la función render simplemente crea una etiqueta hr sin tener que saber nada sobre su sintaxis html. el módulo htmltag se encarga de los problemas sintácticos. de hecho, al realizar este cambio detecté un sutil error. el código original no incluía la barra final en la etiqueta hr , como haría el estándar xhtml (es decir, generaba <hr> en lugar de <hr/> ). el módulo htmltag se había modificado hace tiempo para ajustarlo a xhtml. 385la separación de niveles de abstracción es una de las tareas más importantes de la refactorización, y también una de las más complejas. por ejemplo, fíjese en el siguiente código. fue mi primer intento de separar los niveles de abstracción del método hrulewidget.render . public string render() throws exception { htmltag hr = new htmltag(“hr”); if (size > 0) { hr.addattribute (“size”, “”+(size+1)); } return hr.html(); } mi objetivo, en esta fase, es crear la separación necesaria y conseguir superar las pruebas. el objetivo lo alcancé fácilmente pero el resultado fue una función con niveles de abstracción mezclados. en este caso, fueron obra de la etiqueta hr y de la interpretación y el formato de la variable size. esto indica que al dividir una función en líneas de abstracción, suelen aparecer nuevas líneas de abstracción ocultas por la estructura anterior. g35: mantener los datos configurables en los niveles superiores si tiene una constante como un valor predeterminado o de configuración que se conoce y se espera en un nivel superior de abstracción, no debe sepultarla en una función de nivel inferior. muéstrela como argumento para esa función de nivel inferior invocado desde la función de nivel superior. fíjese en este ejemplo de fitnesse: public static void main(string[] args) throws exception { arguments arguments = parsecommandline(args); … } public class arguments { public static final string default_path = “.”; public static final string default_root = “fitnesseroot”; public static final int default_port = 80; public static final int default_version_days = 14; … } 386los argumentos de línea de comandos se analizan en la primera línea ejecutable de fitnesse. los valores predeterminados de dichos argumentos se especifican al inicio de la clase argument . no tiene que buscar instrucciones como la siguiente en los niveles inferiores del sistema: if (arguments.port == 0) // usar 80 de forma predeterminada las constantes de configuración se encuentran en un nivel superior y son fáciles de cambiar. se pasan al resto de la aplicación. los niveles inferiores de la aplicación no poseen los valores de estas constantes. g36: evitar desplazamientos transitivos por lo general, no es recomendable que un módulo sepa demasiado sobre sus colaboradores. en concreto, si a colabora con b y b con c, no queremos que los módulos que usan a sepan nada sobre c (por ejemplo, o queremos a.getb().getc().dosomething(); ). es lo que en ocasiones se denomina ley de demeter. los programadores pragmáticos lo denominan crear código silencioso [115] . en cualquier caso, se trata de garantizar que los módulos sólo tienen conocimiento de sus colaboradores inmediatos y no del mapa de navegación completo del sistema. si varios módulos usan alguna variante de la instrucción a.getb().getc() , sería complicado cambiar el diseño y la arquitectura para intercalar q entre b y c. tendría que localizar todas las instancias de a.getb().getc() y convertirlas a a.getb().getq().getc() . es la forma en que las arquitecturas se vuelven rígidas. demasiados módulos saben demasiado sobre la arquitectura. por el contrario, queremos que nuestros colaboradores intermedios ofrezcan todos los servicios que necesitamos. no debemos deambular por el gráfico de objetos del sistema en busca del método que necesitamos invocar. bastaría con poder usar: mycollaborator.dosomething(). java 387j1: evitar extensas listas de importación mediante el uso de comodines si usa dos o más clases de un paquete, importe el paquete completo con import package.*; las listas extensas de importaciones intimidan al lector. no queremos colapsar la parte superior de los módulos con 80 líneas de importaciones, sino que sean una instrucción concisa de los paquetes con los que colaboramos. las importaciones específicas son dependencias rígidas, mientras que las importaciones de comodín no. si importa una clase concreta, esa clase debe existir, pero si importa un paquete con un comodín, no es necesario que existan clases concretas. la instrucción de importación simplemente añade el paquete a la ruta de búsqueda al localizar los nombres. por tanto, no se genera una verdadera dependencia en estas importaciones y permiten aligerar las conexiones de nuestros módulos. en ocasiones, la lista extensa de importaciones puede resultar útil. por ejemplo, si tiene que trabajar con código de legado y desea saber para qué clases crear elementos ficticios, puede examinar la lista de importaciones concretas para determinar los verdaderos nombres cualificados de todas esas clases y después añadirlos. no obstante, este uso de las importaciones concretas no es habitual. es más, muchos ide modernos le permiten convertir las importaciones con comodines en una lista de importaciones concretas con un solo comando. por tanto, incluso en el caso anterior, es recomendable usar comodines. las importaciones de comodín pueden probar conflictos de nombres y ambigüedades. dos clases con el mismo nombre pero en paquetes diferentes tienen que importarse de forma concreta o al menos cualificarse de forma específica cuando se usen. puede resultar molesto pero no es habitual que el uso de importaciones de comodín sea más indicado que el de importaciones concretas. j2: no heredar constantes lo he visto muchas veces y siempre me molesta. un programador añade 388constantes a una interfaz y después accede a las mismas heredando dicha interfaz. fíjese en el siguiente código: public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } ¿de dónde salen las constantes tenths_per_week y overtime_rate ? puede que provengan de la clase employee ; comprobémoslo: public abstract class employee implements payrollconstants { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } no, de ahí no. ¿entonces de dónde? fíjese atentamente en la clase employee . implementa payrollconstants . public interface payrollconstants { public static final int tenths_per_week = 400; public static final double overtime_rate = 1.5; } es horrible. las constantes se ocultan en la parte superior de la jerarquía de herencia. no use la herencia para burlar las reglas de ámbito del lenguaje. use una importación estática: import static payrollconstants.*; public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } 389j3: constantes frente a enumeraciones ahora que se han añadido enumeraciones al lenguaje (java 5), ¡úselas! no recurra al viejo truco de public static final int . el significado de int se puede perder. el de enum no, ya que pertenece a una enumeración con nombre. es más, analice atentamente la sintaxis de las enumeraciones . pueden tener métodos y campos, lo que las convierte en potentes herramientas que ofrecen mayor expresividad y flexibilidad que los int . fíjese en esta variante del código: public class hourlyemployee extends employee { private int tenthsworked; hourlypaygrade grade; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( grade.rate() * (tenthsworked + overtime_rate * overtime) ); } … } public enum hourlypaygrade { apprentice { public double rate() { return 1.0; } }, leutenant_journeyman ( public double rate() { return 1.2; } }, journeyman { public double rate() { return 1.5; } }, master { public double rate() { return 2.0; } }; public abstract double rate(); 390} nombres n1: elegir nombres descriptivos no sea demasiado rápido a la hora de elegir un nombre. asegúrese de que sea descriptivo. recuerde que los significados suelen variar cuando el código evoluciona, de modo que debe revisar frecuentemente la corrección de los nombres elegidos. no es una recomendación de sensaciones. en software , los nombres constituyen el 90 por 100 de su legibilidad. dedique tiempo a seleccionarlos con atención y mantenga su relevancia. los nombres son demasiado importantes como para tratarlos mal. fíjese en el siguiente código. ¿para qué sirve? si le muestro el mismo código con nombres bien elegidos, tendrá sentido, pero con este formato no es más que una masa de símbolos y números mágicos. public int x() { int q = 0; int z = 0; for (int kk = 0; kk < 10; kk++) { if (l[z] == 10) { q += 10 + (l[z + 1] + l[z + 2]); z += 1; } else if (l[z] + l[z + 1] == 10) { q += 10 + l[z + 2]; z += 2; } else { q += l[z] + l[z + 1]; z += 2; } } return q; } a continuación, el código como debería haberse escrito. este fragmento es en realidad menos completo que el anterior, pero detectará inmediatamente 391lo que intenta hacer y es probable que pudiera crear las funciones que faltan en función de ese significado que intuye. los números mágicos ya no lo son y la estructura del algoritmo es descriptiva y atractiva: public int score() { int score = 0; int frame = 0; for (int framenumber = 0; framenumber < 10; framenumber++) { if (isstrike(frame)) { score += 10 + nexttwoballsforstrike(frame); frame += 1; } else if (isspare(frame)) { score += 10 + nextballforspare(frame); frame += 2; } else { score += twoballsinframe(frame); frame += 2; } } return score; } los nombres bien elegidos inundan la estructura del código con descripciones. dicha inundación define las expectativas del lector sobre el cometido de otras funciones del módulo. puede inferir la implementación de isstrike() si se fija en el código anterior. cuando lea el método isstrike , será prácticamente lo que esperaba [116] . private boolean isstrike(int frame) { return rolls[frame] = 10; } n2: elegir nombres en el nivel correcto de abstracción no elija nombres que comuniquen implementación; seleccione nombres que reflejen el nivel de abstracción de la clase o la función con la que trabaje. es complicado. de nuevo, nos cuesta mezclar niveles de abstracción. siempre que realice una pasada por su código, es probable que encuentre una variable con nombre en un nivel demasiado bajo. cambie esos nombres cuando los vea. para que el código sea legible se necesita una mejora continua. fíjese en la siguiente interfaz modem : public interface modem { 392boolean dial(string phonenumber); boolean disconnect(); boolean send(char c); char recv(); string getconnectedphonenumber(); } inicialmente parece correcta. las funciones parecen las adecuadas. de hecho lo son para muchas aplicaciones, pero piense ahora en una aplicación en la que algunos módems no se conecten mediante marcación telefónica, sino mediante cables (como los usados para conexiones domésticas a internet). puede que algunos se conecten enviando un número de puerto a un concentrador a través de una conexión usb. es evidente que la noción de números de teléfono se encuentra en un nivel de abstracción equivocado. una estrategia de nomenclatura más adecuada para este caso sería la siguiente: public interface modem { boolean connect(string connectionlocator); boolean disconnect(); boolean send(char c); char recv(); string getconnectedlocator(); } ahora los nombres no se limitan a números de teléfono. se pueden usar para números de teléfono o para otros tipos de estrategia de conexión. n3: usar nomenclatura estándar siempre que sea posible los nombres son más fáciles de entender si se basan en una convención o un uso existente. por ejemplo, si emplea el patrón decorator , debería usar la palabra decorator en los nombres de las clases. por ejemplo, autohangupmodemdecorator podría ser el nombre de una clase que permite a un módem colgar automáticamente al final de una sesión. los patrones son un tipo de estándar. en java, por ejemplo, las funciones que convierten objetos en representaciones de cadena suelen tener el nombre tostring . es mejor seguir estas convenciones que inventar otras propias. los equipos suelen inventar su propio sistema estándar de nombres para un proyecto concreto. eric evans lo denomina lenguaje omnipresente del 393proyecto [117] . su código debe usar los términos de este lenguaje. en definitiva, cuantos más nombres con significado especial y relevante para su proyecto utilice, más fácil será para los lectores saber de qué trata el código. n4: nombres inequívocos seleccione nombres que ilustren de forma inequívoca el funcionamiento de funciones y variables. fíjese en este ejemplo de fitnesse: private string dorename() throws exception { if (refactorreferences) renamereferences(); renamepage(); pathtorename.removenamefromend(); pathtorename.addnametoend(newname); return pathparser.render(pathtorename); } el nombre de esta función no indica qué hace, al menos en términos amplios y sin concretar. además, se refuerza por la presencia de la función renamepage dentro de la función dorename . ¿qué indican los nombres sobre la diferencia entre ambas funciones? nada. un nombre más acertado para la función sería renamepageandoptionallyallreferences . puede parecerle extenso, y lo es, pero sólo se invoca desde un punto del módulo, de modo que su valor descriptivo supera su longitud. n5: usar nombres extensos para ámbitos extensos la longitud de un nombre debe estar relacionada con la de su ámbito. puede usar nombres de variables breves para ámbitos diminutos pero en ámbitos mayores debe emplear nombres extensos. los nombres de variables como i y j son correctos si su ámbito tiene cinco líneas de longitud. fíjese en el siguiente fragmento del conocido juego de los bolos: private void rollmany(int n, int pins) { for (int i=0; i<n; i++) 394g.roll(pins); } es totalmente claro y se complicaría si la variable i se cambiara por algo como rollcount . por otra parte, las variables y funciones con nombres breves pierden su significado en las grandes distancias. por tanto, cuanto mayor sea el ámbito del nombre, más extenso y preciso tendrá que ser el nombre. n6: evitar codificaciones los nombres no deben codificarse con información de tipos o ámbitos. prefijos como m_ o f no sirven de nada en los entornos actuales. además, codificaciones de proyecto y/o subsistema como vis_ (para un sistema de imágenes visuales) distraen la atención y son redundantes. los entornos actuales proporcionan toda esa información sin tener que modificar los nombres. aleje sus nombres de la contaminación húngara. n7: los nombres deben describir efectos secundarios los nombres deben describir todo lo que haga una función, variable o clase. no oculte efectos secundarios con un nombre. no utilice un simple verbo para describir una función que realiza algo más que una simple acción. fíjese en este código de testng: public objectoutputstream getoos() throws ioexception { if (m_oos == null) { m_oos = new objectoutputstream(m_socket.getoutputstream()); } return m_oos; } esta función hace algo más que obtener oos ; lo crea si todavía no se ha creado. por lo tanto, un nombre más acertado sería createorreturnoos . pruebas (test) 395t1: pruebas insuficientes ¿cuántas pruebas debe incluir una suite de pruebas? desafortunadamente, muchos programadores dirían que las que parezcan suficientes. una suite de pruebas debe probar todo lo que pueda fallar. las pruebas son insuficientes mientras haya condiciones que no se hayan examinado o cálculos que no se hayan validado. t2: usar una herramienta de cobertura las herramientas de cobertura indican vacíos en su estrategia de pruebas. facilitan la detección de módulos, clases y funciones insuficientemente probadas. muchos ide le ofrecen un indicador visual y marcan en verde las líneas cubiertas y en rojo las no cubiertas. de este modo es más rápido y sencillo detectar instrucciones if o catch cuyos cuerpos no se han comprobado. t3: no ignorar pruebas triviales son fáciles de redactar y su valor documental es mayor que el coste de crearlas. t4: una prueba ignorada es una pregunta sobre una ambigüedad en ocasiones dudamos de un detalle de comportamiento porque los requisitos no son claros. podemos expresar nuestra duda sobre los requisitos en forma de prueba comentada o como prueba anotada con @ignore . la decisión depende de si la ambigüedad es sobre algo que se compila o no. t5: probar condiciones de límite 396preste especial atención a las pruebas de condiciones de límite. solemos acertar con la parte central de un algoritmo pero malinterpretar los límites. t6: probar de forma exhaustiva junto a los errores los errores suelen congregarse. si detecta un error en una función, es recomendable probarla de forma exhaustiva. seguramente no sea el único error. t7: los patrones de fallo son reveladores en ocasiones diagnosticamos un problema detectando patrones de fallo en los casos de prueba. es otro argumento para crear casos de prueba lo más completos posibles. los casos de prueba completos, si se ordenan de forma razonable, revelan patrones. como ejemplo, imagine que ha detectado que todas las pruebas con un entero mayor de cinco caracteres fallan. o que fallan todas las pruebas que pasan un número negativo al segundo argumento de una función. en ocasiones, con ver el patrón de rojos y verdes de un informe de pruebas basta para hacer saltar la chispa y llegar a una solución. en el capítulo 16 encontrará un interesante ejemplo en el caso de serialdate . t8: los patrones de cobertura de pruebas pueden ser reveladores el análisis del código que se ejecuta o no en las pruebas superadas suele indicar porqué fallan las pruebas no superadas. t9: las pruebas deben ser rápidas una prueba lenta no se ejecuta. cuando las cosas se ponen feas, las pruebas lentas se eliminan de la suite . por lo tanto, intente que sus pruebas sean 397rápidas. conclusión esta lista de heurística y síntomas no se podría considerar completa. de hecho, dudo de que alguna vez exista alguna. pero puede que ese no sea el objetivo, ya que lo que implica esta lista es un sistema de valores. el sistema de valores ha sido el objetivo y la base de este libro. el código limpio no se crea siguiendo una serie de reglas. no se convertirá en un maestro del software aprendiendo una lista de heurísticas. la profesionalidad y la maestría provienen de los valores que impulsan las disciplinas. bibliografía [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. [beck97] : smalltalk best practice patterns , kent beck, prentice hall, 1997. [beck07] : implementation patterns , kent beck, addison-wesley, 2008. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. [ddd] : domain driven design , eric evans, addison-wesley, 2003. 398apéndice a concurrencia ii por brett l. schuchert este apéndice complementa y amplía el capítulo 13 sobre concurrencia. se ha escrito como una serie de temas independientes que puede leer en el orden que desee. algunas secciones están duplicadas para facilitar dicha lectura. ejemplo cliente/servidor imagine una sencilla aplicación cliente/servidor. un servidor espera a que un cliente se conecte. un cliente se conecta y envía una solicitud. el servidor a continuación le mostramos una versión simplificada de una aplicación de servidor. el código completo de este ejemplo se recoge en el listado a-3. serversocket serversocket = new serversocket(8009); while (keepprocessing) { try { socket socket = serversocket.accept(); process(socket); } catch (exception e) { handle(e); } 399} esta sencilla aplicación espera una conexión, procesa un mensaje entrante y vuelve a esperar a la siguiente solicitud cliente. el código cliente para conectarse al servidor es el siguiente: private void connectsendreceive(int i) { try { socket socket = new socket (“localhost”, port); messageutils.sendmessage(socket, integer.tostring(i)); messageutils.getmessage(socket); socket.close(); } catch (exception e) { e.printstacktrace(); } } ¿cómo se comporta esta combinación de cliente y servidor? ¿cómo podemos describir formalmente ese rendimiento? la siguiente prueba afirma que el rendimiento es aceptable: @test(timeout = 10000) public void shouldruninunder10seconds() throws exception { thread[] threads = createthreads(); startallthreadsw(threads); waitforallthreadstofinish(threads); } se omite la configuración para que el ejemplo sea sencillo (véase “ clienttest.java ” más adelante). esta prueba afirma que debe completarse en 10 000 milisegundos. es un ejemplo clásico de validación del rendimiento de un sistema. este sistema debe completar una serie de solicitudes cliente en 10 segundos. mientras el servidor pueda procesar cada solicitud cliente a tiempo, la prueba será satisfactoria. ¿qué sucede si la prueba falla? aparte de desarrollar algún tipo de bucle de consulta de eventos, no hay mucho que hacer en un único proceso para aumentar la velocidad de este código. ¿se solucionaría el problema con varios procesos? puede, pero necesitamos saber cómo se consume el tiempo. hay dos posibilidades: e/s: con un socket, conectándose a la base de datos, esperando al intercambio de memoria virtual, etc. procesador: cálculos numéricos, procesamiento de expresiones 400regulares, recolección de elementos sin usar, etc. los sistemas suelen tener uno de cada, pero para una operación concreta suele haber uno dominante. si el código se vincula al procesador, mayor cantidad de hardware de procesamiento puede mejorar el rendimiento y hacer que se supere la prueba, pero no hay tantos ciclos de cpu disponibles, de modo que añadir procesos a un problema vinculado al procesador no hará que aumente la velocidad. por otra parte, si el proceso está vinculado a e/s, la concurrencia puede aumentar la eficacia. cuando una parte del sistema espera a e/s, otra puede usar ese tiempo de espera para procesar algo distinto, maximizando el uso eficaz de la cpu disponible. añadir subprocesos imagine que la prueba de rendimiento falla. ¿cómo podemos mejorar la producción para que la prueba de rendimiento sea satisfactoria? si el método process del servidor está vinculado a la e/s, existe una forma de conseguir que el servidor use subprocesos (basta con cambiar processmessage): void process (final socket socket) { if (socket == null) return; runnable clienthandler = new runnable() { public void run() { try { string message = messageutils.getmessage(socket); messageutils.sendmessage(socket, “processed: ” + message); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } }; thread clientconnection = new thread(clienthandler); clientconnection.start(); } asuma que este cambio hace que la prueba se supere [118] ; el código es completo, ¿correcto? 401observaciones del servidor el servidor actualizado completa satisfactoriamente la prueba en algo más de un segundo. desafortunadamente, la solución genera ciertos problemas. ¿cuántos subprocesos podría crear nuestro servidor? el código no define límites de modo que podríamos alcanzar el impuesto por la máquina virtual de java (mvj), suficiente en muchos sistemas sencillos. ¿pero y si el sistema tiene que asumir multitud de usuarios de una red pública? si se conectan demasiados usuarios al mismo tiempo, el sistema podría colapsarse. pero dejemos temporalmente este problema de comportamiento. la solución mostrada tiene problemas de limpieza y estructura. ¿cuántas responsabilidades tiene el código del servidor? administración de conexiones. procesamiento de clientes. política de subprocesos. política de cierre del servidor. desafortunadamente, todas estas responsabilidades se encuentran en la función process . además, el código cruza varios niveles diferentes de abstracción. por tanto, a pesar de la reducida función process , es necesario dividirlo. existen varios motivos para cambiar el servidor; por tanto, incumple el principio de responsabilidad única. para mantener la limpieza de un sistema concurrente, la administración de subprocesos debe limitarse a una serie de puntos controlados. es más, el código que gestione los subprocesos únicamente debe encargarse de la gestión de subprocesos. ¿por qué? si no existe otro motivo, el control de problemas de concurrencia ya es lo suficientemente complicado como para generar simultáneamente otros problemas no relacionados con la concurrencia. si creamos una lista independiente para cada una de las responsabilidades anteriores, incluyendo la administración de subprocesos, al cambiar la estrategia de administración de subprocesos, el cambio tiene un menor impacto sobre el código y no contamina a otras responsabilidades. de este 402modo también es más sencillo probar las demás responsabilidades sin necesidad de preocuparse de los subprocesos. veamos la versión actualizada que se encarga de ello: public void run() { while (keepprocessing) { try { clientconnection clientconnection = connectionmanager.awaitclient(); clientrequestprocessor requestprocessor = new clientrequestprocessor(clientconnection); clientscheduler.schedule(requestprocessor); } catch (exception e) { e.printstacktrace(); } } connectionmanager.shutdown(); } ahora centra en el mismo punto todos los aspectos relacionados con los subprocesos: clientscheduler . si hay problemas de concurrencia, bastará con examinar un punto concreto: public interface clientscheduler { void schedule(clientrequestprocessor requestprocessor); } la política actual es fácil de implementar: public class threadperrequestscheduler implements clientscheduler { public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; thread thread = new thread(runnable); thread.start(); } } tras aislar la administración de subprocesos, resulta más sencillo cambiar el control de los mismos. por ejemplo, para cambiar a la estructura executor de java 5 es necesario crear una nueva clase y conectarla (véase el listado a-1). listado a-1 403executorclientscheduler.java. import java.util.concurrent.executor; import java.util.concurrent.executors; public class executorclientscheduler implements clientscheduler { executor executor; public executorclientscheduler(int availablethreads) { executor = executors.newfixedthreadpool(availablethreads); } public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; executor.execute(runnable); } } conclusión en este ejemplo concreto, la presencia de la concurrencia ilustra una forma de mejorar la producción de un sistema y otra de validar dicha producción a través de una estructura de pruebas. al centrar el código de concurrencia en un número reducido de clases, aplicamos el principio de responsabilidad única. en el caso de la programación concurrente, resulta especialmente importante debido a su complejidad. posibles rutas de ejecución repase el método incrementvalue , un método de java de una línea sin bucles ni ramificaciones: public class idgenerator { int lastidused; public int incrementvalue() { return ++lastidused; } } ignore el desbordamiento de enteros e imagine que solamente un 404subproceso accede a una instancia de idgenerator . en este caso existe una sola ruta de ejecución y un único resultado garantizado: el valor devuelto es igual al valor de lastidused , y ambos son una unidad mayores que antes de invocar el método. ¿qué sucede si usamos dos subprocesos y no cambiamos el método? ¿cuáles son los posibles resultados si cada subproceso invoca incrementvalue una vez? ¿cuántas rutas de ejecución posibles hay? primero, los resultados (imagine que el valor inicial de lastidused es 93): el primer subproceso obtiene el valor 94, el segundo el valor 95 y lastidused es 95. el primer subproceso obtiene el valor 95, el segundo el valor 94 y lastidused es 95. el primer subproceso obtiene el valor 94, el segundo el valor 94 y lastidused es 94. el resultado final, aunque sorprendente, es posible. para ver los distintos resultados, debemos comprender las diferentes rutas de ejecución posibles y cómo las ejecuta la mvj. número de rutas para calcular el número de rutas de ejecución posibles, comenzaremos con el código de bytes generado. la única línea de java ( return ++lastidused; ) se convierte en ocho instrucciones de código de bytes . los dos subprocesos pueden intercambiar la ejecución de estas ocho instrucciones del mismo modo que mezclamos las cartas de una baraja [119] . incluso con sólo ocho cartas en cada mano, el número de posibles resultados es sorprendente. para este sencillo caso de n instrucciones en una secuencia, sin bucles ni condicionales y t subprocesos, el número total de posibles rutas de ejecución es igual a: 405(nt)! n! t calcular las órdenes posibles extraído de un correo electrónico de uncle bob a brett: con n pasos y t subprocesos hay t * n pasos totales. antes de cada paso hay un conmutador de contexto que elige entre los subprocesos. por tanto, cada ruta se representa como una cadena de dígitos que denota los cambios de contexto. dados los pasos a y b y los subprocesos 1 y 2, las seis rutas posibles son 1122, 1212, 1221, 2112, 2121 y 2211. o, en términos de pasos, a1b1a2b2, a1a2b1b2, a1a2b2b1, a2a1b1b2, a2a1b2b1 y a2b2a1b1. para tres subprocesos, la secuencia sería 112233, 112323, 113223, 113232, 112233, 121233, 121323, 121332, 123132, 123123… una característica de estas cadenas es que siempre debe haber n instancias de cada t . por tanto, la cadena 111111 no es válida ya que tiene seis instancias de 1 y ninguna de 2 y 3. por tanto, necesitamos las permutaciones de n 1, n 2… y n  t . en realidad son las permutaciones de n * t tomando cada vez n * t , que es (n * t)! , pero sin los duplicados. por tanto, el truco consiste en contar los duplicados y restarlos de (n * t)! . dados dos pasos y dos subprocesos, ¿cuántos duplicados hay? cada cadena de cuatro dígitos tiene dos 1 y dos 2. estos pares se pueden intercambiar sin modificar el sentido de la cadena. podríamos intercambiar los 1 o los 2, o ninguno. por tanto hay cuatro isomorfas por cada cadena, lo que significa que hay tres duplicados, de modo que tres de las cuatro opciones son duplicados; por otra parte, una de las cuatro permutaciones no son duplicados. 4! * .25 = 6. este razonamiento parece funcionar. ¿cuántos duplicados hay? si n = 2 y t = 2, podría intercambiar los 1, los 2, o ambos. en el caso de n = 2 y t = 3, podría intercambiar los 1, los 2, los 3, 1 y 2, 1 y 3, o 2 y 3. el intercambio son las permutaciones de n . imagine que hay p permutaciones de n . el número de formas diferentes de organizar dichas permutaciones es p**t . por tanto el número de isomorfas posibles es n!**t . y el número de rutas es ( t*n )!/( n!**t ). de nuevo, en nuestro caso t = 2, n = 2 obtenemos 6 (24/4). para n = 2 y t = 3 obtenemos 720/8 = 90. para n = 3 y t = 3 obtenemos 9!/6^3 = 1680. en nuestro sencillo caso de una sola línea de código java, que equivale a ocho líneas de código de bytes y a dos subprocesos, el número total de posibles rutas de ejecución es 12 870. si el tipo de lastidused es long , cada lectura y escritura se convierte en dos operaciones y no una, y el número de posibilidades asciende a 2 704 156. ¿qué sucede si realizamos un cambio en este método? 406public synchronized void incrementvalue() { ++lastidused; } el número de posibles rutas de ejecución es dos para dos subprocesos y n! para el caso general. un examen más profundo ¿qué piensa del sorprendente resultado de dos subprocesos que invoquen el método una vez (antes de añadir synchronized ) y obtengan el mismo resultado numérico? ¿cómo es posible? vayamos por partes. ¿qué es una operación atómica? podemos definir una operación atómica como toda operación ininterrumpible. por ejemplo, en el siguiente código, la línea 5, donde se asigna 0 a lastid , es atómica ya que de acuerdo al modelo de memoria de java, la asignación a un valor de 32 bits es ininterrumpible. 01: public class example { 02: int lastid; 03: 04: public void resetid() { 05: value = 0; 06: } 07: 08: public int getnextid() { 09: ++value; 10: } 11: } ¿qué sucede si cambiamos el tipo de lastid de int a long ? ¿sigue siendo atómica la línea 5? no de acuerdo a la especificación de la mvj. podría ser atómica en un procesador concreto, pero según la especificación de la mvj, la asignación a un valor de 64 bits requiere dos asignaciones de 32 bits. esto significa que entre la primera y la segunda podría irrumpir otro subproceso y cambiar uno de los valores. ¿y qué sucede con el operador de preincremento, ++ , de la línea 9? este operador se puede interrumpir, de modo que no es atómico. para entenderlo, repasemos el código de bytes de ambos métodos. antes de continuar, hay tres definiciones importantes: 407marco: la invocación de un método requiere un marco, el cual incluye la dirección de devolución, los parámetros pasados al método y las variables locales definidas en el mismo. es una técnica estándar empleada para definir una pila de invocaciones, que se usa en muchos lenguajes modernos para permitir la invocación de funciones y métodos básicos, además de invocaciones recursivas. variable local: las variables definidas en el ámbito del método. todos los métodos no estáticos tienen al menos una variable, this , que representa el objeto actual, el objeto que ha recibido el último mensaje (en el subproceso actual) que ha propiciado la invocación del método. pila de operandos: muchas instrucciones de la mvj aceptan parámetros. la pila de operandos es donde se incluyen dichos parámetros. la pila es una estructura de datos lifo ( last-in, first-out o último en entrar, primero en salir) estándar. veamos el código de bytes generado para resetid(). nemónico descripción pila de operandos posterior aload 0 cargar la variable 0 a en la pila de operandos. ¿qué es la variable 0 a ? es this. , el objeto actual. al invocar el método, el receptor del mensaje, una instancia de example , se envía a la matriz de variables locales del marco creado para la invocación de métodos. siempre es la primera variable que se añade a todos los métodos de instancia. this iconst_0 incluir el valor constante 0 en la pila de operandos. this, 0 putfield lastid almacenar el valor superior de la pila (0) en el valor de campo del objeto denominado por la referencia de objeto una posición alejada de la parte superior de la pila, this . <vacío> 408estas tres instrucciones son atómicas ya que a pesar de que el subproceso que las ejecuta podría verse interrumpido por cualquiera de ellas, la información para la instrucción putfield (el valor constante 0 de la parte superior de la pila y la referencia a éste una posición inferior, junto con el valor del campo) no se ve alterada por ningún otro subproceso. por tanto, al producirse la asignación, sabemos que el valor 0 se almacena en el valor del campo. la operación es atómica. todos los operandos procesan información local del método, de modo que no hay interferencias entre subprocesos. si estas instrucciones se ejecutan en diez subprocesos, hay 4.38679733629e+24 ordenaciones posibles. sin embargo, sólo hay un resultado posible, de modo que las distintas ordenaciones son irrelevantes. y además, se garantiza el mismo resultado para valores long en este caso. ¿por qué? los diez subprocesos asignan un valor constante. aunque se entremezclen, el resultado final será el mismo. habrá problemas con la operación ++ en el método getnextid . imagine que lastid contiene 42 al inicio de este método. veamos el código de bytes de este nuevo método: nemónico descripción pila de operandos posterior aload 0 cargar this en la pila de operandos. this dup copiar la parte superior de la pila. ahora tenemos dos copias de this en la pila de operandos. this, this getfield lastid recuperar el valor del campo lastid del objeto al que se apunta en la parte superior de la pila ( this ) y volver a almacenar el valor en la pila. this, 42 iconst_1 desplazar la constante entera 1 en la pila. this, 42, 1 iadd suma entera de los dos valores superiores de la pila de operandos y volver a almacenar el resultado en la pila. this, 43 dup_x1 duplicar el valor 43 y añadirlo delante de this . 43, this, 43 putfield almacenar el valor superior de la pila de operandos, 43 409value 43, en el valor de campo del objeto actual, representado por el siguiente valor superior de la pila de operandos, this . ireturn devolver el valor superior (y único) de la pila de operandos. <vacío> imagine que el primer subproceso completa las tres primeras instrucciones, hasta getfield incluida y después se interrumpe. aparece un segundo subproceso y ejecuta el método completo, incrementando lastid en uno; devuelve 43. tras ello, el primer subproceso retoma desde donde se detuvo; 42 sigue en la pila de operandos por ser el valor de lastid cuando ejecutó getfield . suma uno para obtener 43 y almacena el resultado. el valor 43 también se devuelve al primer subproceso. como resultado, uno de los incrementos se pierde ya que el primer subproceso interfiere con el segundo después de que éste haya interrumpido al primero. al convertir el método getnextid() en synchronized se corrige este problema. conclusión no se necesita un conocimiento extenso del código de bytes para entender cómo unos subprocesos interrumpen a otros. si consigue entender este ejemplo, demostrará la posibilidad de varios subprocesos entrelazados, un conocimiento suficiente. dicho esto, lo que este sencillo ejemplo revela es la necesidad de entender el modelo de memoria para saber qué se permite y qué no. equivocadamente se piensa que el operador ++ (pre o postincremento) es atómico, y evidentemente no lo es. esto significa que tiene que saber: dónde están los objetos y valores compartidos. el código que provoca problemas de lectura/actualización concurrente. cómo evitar que se produzcan dichos problemas. 410conocer su biblioteca la estructura executor como mostramos en executorclientscheduler.java , la estructura executor de java 5 permite la ejecución sofisticada por medio de agrupaciones de subprocesos. es una clase del paquete java.util.concurrent . si va a crear subprocesos y no usa una agrupación de subprocesos o utiliza una creada a mano, considere el uso de executor. hace que el código sea más limpio, más fácil de entender y de menor tamaño. la estructura executor agrupa subprocesos, los cambia automáticamente de tamaño y los vuelve a crear si es necesario. también admite futuros , una construcción de programación concurrente habitual. la estructura executor funciona con clases que implementan runnable y también con clases que implementan la interfaz callable . callable se parece a runnable , pero puede devolver un resultado, una necesidad habitual en soluciones de múltiples subprocesos. un futuro resulta muy útil cuando el código tiene que ejecutar varias operaciones independientes y esperar a que terminen: public string processrequest(string message) throws exception { callable<string> makeexternalcall = new callable<string>() { public string call() throws exception { string result = “”; // realizar solicitud externa return result; } }; future<string> result = executorservice.submit(makeexternalcall); string partialresult = dosomelocalprocessing(); return result.get() + partialresult; } en este ejemplo, el método comienza a ejecutar el objeto makeexternalcall , prosigue con otro procesamiento y la última línea invoca result.get(), que se bloquea hasta que el futuro termina. 411soluciones no bloqueantes la mv java 5 aprovecha el diseño de los procesadores modernos que admiten actualizaciones fiables y no bloqueantes. imagine una clase que usa sincronización (y por tanto bloqueo) para proporcionar la actualización compatible con subprocesos de un valor: public class objectwithvalue { private int value; public void synchronized incrementvalue() { ++value; } public int getvalue() { return value; } } java 5 dispone de varias clases nuevas para este tipo de situaciones, como por ejemplo atomicboolean , atomicinteger y atomicreference . podemos modificar el código anterior para usar un enfoque no bloqueante: public class objectwithvalue { private atomicinteger value = new atomicinteger(0); public void incrementvalue() { value.incrementandget(); } public int getvalue() { return value.get(); } } aunque use un objeto en lugar de una primitiva y envíe mensajes como incrementandget() en lugar de ++ , el rendimiento de esta clase supera en la mayoría de los casos al de la versión anterior. en algunos casos será ligeramente más rápido pero los casos en los que es más lento son prácticamente inexistentes. ¿cómo es posible? los procesadores modernos disponen de una operación denominada cas (compare and swap, comparar e intercambiar). es una operación similar al bloqueo optimista de una base de datos, mientras que la versión sincronizada es similar al bloqueo pesimista. la palabra clave synchronized siempre adquiere un bloqueo, incluso cuando un segundo subproceso no intenta actualizar el mismo valor. aunque el rendimiento de los bloqueos intrínsecos ha mejorado con respecto a versiones anteriores, sigue siendo muy costoso. la versión no bloqueante asume inicialmente que varios subprocesos no 412modifican el mismo valor con la suficiente periodicidad como para generar un problema. por el contrario, detecta de forma eficaz si se produce dicha situación y la reintenta hasta que la actualización es satisfactoria. esta detección suele ser menos costosa que la adquisición de un bloqueo, incluso en situaciones de contención moderada o alta. ¿cómo lo hace la mv? la operación cas es atómica. por tanto, la operación cas tiene este aspecto: int variablebeingset; void simulatenonblockingset (int newvalue) { int currentvalue; do { currentvalue = variablebeingset } while(currentvalue != compareandswap(currentvalue, newvalue)); } int synchronized compareandswap(int currentvalue, int newvalue) { if(variablebeingset == currentvalue) { variablebeingset = newvalue; return currentvalue; } return variablebeingset; } cuando un método intenta actualizar una variable compartida, la operación cas comprueba que la variable establecida sigue teniendo el último valor conocido. en caso afirmativo, se cambia la variable. en caso contrario, la variable no se establece ya que otro subproceso ha conseguido acceder. el método que realiza el intento (mediante la operación cas) ve que el cambio no se ha realizado y lo intenta de nuevo. clases incompatibles con subprocesos existen clases que no son compatibles con subprocesos, como las siguientes: simpledateformat . conexiones de base de datos. contenedores de java.util . 413servlet. algunas clases de colección tienen métodos concretos compatibles con subprocesos. sin embargo, cualquier operación que invoque más de un método no lo es. por ejemplo, si no quiere reemplazar algo en hashtable porque ya existe, podría crear el siguiente código: if(!hashtable.containskey(somekey)) { hashtable.put(somekey, new somevalue()); } cada uno de los métodos es compatible con subprocesos. sin embargo, otro subproceso podría añadir un valor entre las invocaciones de containskey y put . existen varias formas de solucionar este problema: bloquear primero hashtable y comprobar que los demás usuarios de hashtable hagan lo mismo; bloqueo basado en clientes: synchronized(map) { if(!map.containskey(key)) map.put(key,value); } envolver hashtable en su propio objeto y usar dos api distintas; bloqueo basado en servidores con un adaptador: public class wrappedhashtable<k, v> { private map<k, v> map = new hashtable<k, v>(); public synchronized void putifabsent(k key, v value) { if (map.containskey(key)) map.put(key, value); } } usar colecciones compatibles con subprocesos: concurrenthashmap<integer, string> map = new concurrenthashmap<integer, string>(); map.putifabsent(key, value); las colecciones de java.util.concurrent incluyen operaciones como putifabsent() para acomodar este tipo de operaciones. 414las dependencias entre métodos pueden afectar al código concurrente el siguiente ejemplo es una forma de añadir dependencias entre métodos: public class integeriterator implements iterator<integer> private integer nextvalue = 0; public synchronized boolean hasnext() { return nextvalue < 100000; } public synchronized integer next() { if (nextvalue == 100000) throw new iteratorpastendexception(); return nextvalue++; } public synchronized integer getnextvalue() { return nextvalue; } } veamos otro código que usa integeriterator : integeriterator iterator = new integeriterator(); while(iterator.hasnext()) { int nextvalue = iterator.next(); // hacer algo con nextvalue } si un subproceso ejecuta este código no habrá problemas. ¿qué sucede si dos subprocesos intentan compartir una misma instancia de integeriterator para procesar el valor que reciba cada uno pero cada elemento de la lista sólo se procesa una vez? en la mayoría de los casos, no hay consecuencias negativas; los subprocesos comparten la lista, procesan los elementos devueltos por el iterador y se detienen cuando éste termina. sin embargo, existe la posibilidad de que al final de la iteración los dos subprocesos interfieran entre ellos y provoquen que uno supere el final del iterador y se genere una excepción. el problema es el siguiente: el subproceso 1 pregunta hasnext() , que devuelve true . el subproceso 1 se evita y el subproceso 2 realiza la misma pregunta, que sigue siendo true . tras ello, el subproceso 2 invoca next() , que devuelve un valor, como era de esperar, pero como efecto secundario 415hace que hasnext() devuelva false . se vuelve a iniciar el subproceso 1, pensando que hasnext() sigue siendo true , y después invoca next() . aunque los métodos concretos están sincronizados, el cliente usa dos métodos. es un problema real y un ejemplo que puede surgir en código concurrente. en este caso concreto, el problema es especialmente sutil ya que la única ocasión en la que produce un fallo es durante la iteración final del iterador. si los subprocesos se dividen de forma correcta, puede que uno supere el final del iterador. es el tipo de error que surge en un sistema que lleva tiempo en producción, y es difícil de detectar. tiene tres opciones: tolerar el fallo. solucionar el problema cambiando el cliente: bloqueo basado en el cliente. solucionar el problema cambiando el servidor, lo que también provoca que cambie el cliente: bloqueo basado en el servidor. tolerar el fallo en ocasiones, los sistemas se configuran para que un fallo no produzca daños. por ejemplo, el cliente anterior podía capturar la excepción y limpiarla, aunque sería un tanto torpe. es como limpiar fugas de memoria reiniciando a medianoche. bloqueo basado en el cliente para que integeriterator funcione correctamente con varios subprocesos, cambie el cliente (y los demás) como se indica a continuación: integeriterator iterator = new integeriterator(); while (true) { int nextvalue; synchronized (iterator) { if (!iterator.hasnext()) break; nextvalue = iterator.next(); 416} dosometingwith(nextvalue); } cada cliente añade un bloqueo a través de la palabra clave synchronized . esta duplicación incumple el principio dry, pero puede ser necesaria si el código usa agrupaciones de terceros no compatibles con subprocesos. la estrategia es arriesgada ya que todos los programadores que usen el servidor deben acordarse de bloquearlo antes de usarlo y de desbloquearlo cuando terminen. hace muchos años, trabajé en un sistema que usaba el bloqueo basado en el cliente en un recurso compartido. el recurso se usaba en cientos de puntos distintos del código. un pobre programador se olvidó de bloquear el recurso en uno de esos puntos. era un sistema de varios terminales con software de contabilidad para el sindicato de transportistas. local 705. el ordenador se encontraba en una sala de temperatura controlada de un piso elevado, a unas 50 millas al norte de la sede de local 705. en la sede, decenas de trabajadores introducían datos en las terminales, conectadas al ordenador mediante líneas telefónicas dedicadas y módem semidúplex de 600bps (esto fue hace mucho , mucho tiempo). una vez al día, una de las terminales se bloqueaba, sin razón aparente. el bloqueo no tenía preferencia alguna por una terminal o una hora concreta. es como si alguien echara a suertes la terminal que bloquear y la hora del bloqueo. en ocasiones, se bloqueaba más de una terminal. en ocasiones, podían pasar varios días sin bloqueos. inicialmente, se optó por reiniciar como solución, pero era complicado coordinar los reinicios. tenemos que avisar a la sede y esperar a que todos terminaran lo que estuvieran haciendo en todas las terminales. tras ello, se apagaba el sistema y se reiniciaba. si alguien estaba haciendo algo importante para lo que necesitaba una o dos horas, la terminal bloqueada tenía que seguir bloqueada. tras varias semanas de depuración, descubrimos que la causa era un contador de búfer circular desincronizado con su puntero. este búfer controlaba la salida a la terminal. el valor del puntero indicaba que el búfer estaba vacío pero el contador mostraba que estaba lleno. como estaba vacío, no había nada que mostrar; pero como también estaba lleno, no se podía añadir nada al búfer que mostrar en la pantalla. 417sabíamos qué era lo que bloqueaba las terminales pero no qué provocaba la desincronización del búfer circular, por lo que añadimos un truco para resolver el problema. se podían leer los conmutadores del panel frontal en el ordenador (esto fue hace mucho, mucho, mucho tiempo). diseñamos una función de trampa que detectaba si uno de los conmutadores se había generado y después buscábamos un búfer circular que estuviera tanto lleno como vacío. si lo encontrábamos, lo variábamos. ¡ voilá ! la terminal bloqueada volvía a funcionar. de este modo no era necesario reiniciar el sistema si una terminal se bloqueaba. la sede nos llamaba y nos decía que había un bloqueo, nos acercábamos hasta la sala de ordenadores y pulsábamos un conmutador. en ocasiones ellos trabajan los fines de semana pero nosotros no. por ello, añadimos una función al programador que comprobaba los búfer circulares una vez por minuto y restablecía los que estuvieran tanto llenos como vacíos. de este modo se descongestionaban las pantallas antes de que la dirección llegara al teléfono. necesitamos varias semanas de análisis de código de lenguaje de ensamblado antes de localizar al culpable. habíamos calculado que la frecuencia de los bloqueos se debía a un uso desprotegido del búfer circular, así que sólo era necesario determinar el uso fallido. desafortunadamente, esto fue hace mucho tiempo y no disponíamos de herramientas de búsqueda, referencias cruzadas ni de otras técnicas automáticas de ayuda. teníamos que escudriñar los listados. en aquel frío invierno de 1971 en chicago aprendí que los bloqueos basados en el cliente son verdaderamente terribles. bloqueo basado en el servidor la duplicación se puede eliminar si modificamos integeriterator de esta forma: public class integeriteratorserverlocked { private integer nextvalue = 0; public synchronized integer getnextornull() { if (nextvalue < 100000) return nextvalue++; else return null; 418} } y también cambia el código cliente: while (true) { integer nextvalue = iterator.getnextornull(); if (next == null) break; // hacer algo con nextvalue } en este caso, en realidad cambiamos la api de la clase para que sea compatible con el subproceso [120] . el cliente debe realizar una comprobación de null en lugar de comprobar hasnext() . por lo general, el bloqueo basado en el servidor es preferible por estos motivos: reduce el código repetido: el bloqueo basado en el servidor hace que el cliente bloquee correctamente el servidor. al incluir el código de bloqueo en el servidor, se libera a los clientes para usar el objeto y no tener que preocuparse de crear código de bloqueo adicional. permite un mejor rendimiento: puede intercambiar un servidor compatible con subprocesos por otro incompatible en caso de desarrollo de un solo subproceso, lo que evita la sobrecarga. reduce las posibilidades de error: sólo se necesita un programador que se olvide del bloqueo. aplica una única política: la política se aplica solamente al servidor, no a todos los clientes. reduce el ámbito de las variables compartidas: el cliente las desconoce y tampoco sabe cómo se bloquean. todo se oculta en el servidor. cuando se produce un fallo, su origen se busca en menos puntos. ¿y si no es el propietario del código de servidor? usar un adaptador para cambiar la api y añadir bloqueo public class threadsafeintegeriterator { private integeriterator iterator = new integeriterator(); public synchronized integer getnextornull() { 419if(iterator.hasnext()) return iterator.next(); return null; } } mejor todavía, usar colecciones compatibles con subprocesos con interfaces ampliadas. aumentar la producción imagine que desea leer el contenido de una serie de páginas de una lista de url en la red. al leer cada página, la analizamos para acumular estadísticas. después de leer todas, imprimimos un informe de resumen. la siguiente clase devuelve el contenido de una página, dada una url. public class pagereader { //… public string getpagefor(string url) { httpmethod method = new getmethod(url); try { httpclient.executemethod(method); string response = method.getresponsebodyasstring(); return response; } catch (exception e) { handle(e); } finally { method.releaseconnection(); } } } la siguiente clase es el iterador que proporciona el contenido de las páginas en función de un iterador de url: public class pageiterator { private pagereader reader; private urliterator urls; public pageiterator(pagereader reader, urliterator urls) { this.urls = urls; this.reader = reader; } public synchronized string getnextpageornull() { if (urls.hasnext()) getpagefor(urls.next()); 420else return null; } public string getpagefor(string url) { return reader.getpagefor(ur1); } } se puede compartir una instancia de pageiterator entre varios subprocesos distintos, cada uno con su propia instancia de pagereader para leer las páginas que obtiene del iterador. hemos reducido el tamaño del bloque synchronized . simplemente contiene la sección crítica de pageiterator . siempre conviene sincronizar lo menos posible. cálculo de producción de un solo subproceso vayamos con los cálculos. imagine lo siguiente, de acuerdo al argumento anterior: tiempo de e/s para recuperar una página (de media): 1 segundo. tiempo de procesamiento para analizar la página (de media): .5 segundos. e/s requiere 0 por 100 de la cpu mientras que el procesamiento requiere 100 por 100. si se procesan n páginas en un mismo subproceso, el tiempo de ejecución total es de 1.5 segundos * n . en la figura a.1 puede ver una instantánea de 13 páginas, aproximadamente 19.5 segundos. figura a.1. un único subproceso 421cálculo de producción con varios subprocesos si se pueden recuperar páginas en cualquier orden y procesarlas de forma independiente, entonces es posible usar varios subprocesos para aumentar la producción. ¿qué sucede si usamos tres subprocesos? ¿cuántas páginas podemos obtener en el mismo tiempo? como se aprecia en la figura a.2, la solución con varios procesos permite que el análisis de las páginas vinculado al proceso se solape con la lectura de las mismas, vinculada a e/s. en un mundo ideal, significaría que el procesador se utiliza totalmente. cada lectura de página por segundo se solapa con dos análisis. por tanto, podemos procesar dos páginas por segundo, lo que triplica la producción de la solución con un solo proceso. figura a.2. tres subprocesos concurrentes. bloqueo mutuo imagine una aplicación web con dos agrupaciones de recursos compartidos de tamaño finito: una agrupación de conexiones de base de datos para tareas locales de almacenamiento de procesos. 422una agrupación de conexiones mq a un repositorio principal. imagine que hay dos operaciones en la aplicación: crear y actualizar: crear: adquirir una conexión al repositorio principal y la base de datos. comunicarse con el repositorio principal y después almacenar el trabajo local en la base de datos de procesos. actualizar: adquirir una conexión a la base de datos y después al repositorio principal. leer el trabajo de la base de datos y enviarlo al repositorio principal. ¿qué sucede con los usuarios que superan el tamaño de la agrupación? imagine que el tamaño de cada agrupación es 10 . 10 usuarios intentan usar crear, de modo que se adquieren diez conexiones de base de datos y cada subproceso se interrumpe después de esta adquisición pero antes de adquirir una conexión al repositorio principal. 10 usuarios intentan usar actualizar, de modo que se adquieren las diez conexiones al repositorio principal y cada subproceso se interrumpe después de adquirir el repositorio principal pero antes de adquirir una conexión a la base de datos. ahora los 10 subprocesos crear deben esperar a adquirir una conexión al repositorio principal pero los 10 subprocesos actualizar deben esperar a adquirir una conexión a la base de datos. bloqueo mutuo. el sistema no se recupera nunca. puede parecerle una situación improbable pero ¿quién desea un sistema que se colapsa cada semana? ¿quién quiere depurar un sistema con síntomas tan difíciles de reproducir? es el tipo de problema que tarda semanas en resolverse. una solución habitual consiste en añadir instrucciones de depuración para determinar qué sucede. evidentemente, estas instrucciones cambian tanto el código que el bloqueo mutuo se genera en otras situaciones y tarda meses en 423volver a producirse [121] . para solucionar realmente el problema del bloqueo absoluto, debemos entender sus causas. para que se produzca, deben darse cuatro condiciones: exclusión mutua. bloqueo y espera. no expropiación. espera circular. exclusión mutua la exclusión mutua se produce cuando varios subprocesos deben usar los mismos recursos y dichos recursos no se pueden usar en varios subprocesos al mismo tiempo. son de número limitado. un ejemplo típico de este tipo de recurso es una conexión de base de datos, un archivo abierto para escritura, un bloqueo de registro o un semáforo. bloqueo y espera cuando un subproceso adquiere un recurso, no lo libera hasta adquirir los demás recursos que necesita y terminar su trabajo. no expropiación un subproceso no puede adueñarse de los recursos de otro. cuando un subproceso obtiene un recurso, la única forma de que otro lo consiga es que el primero lo libere. espera circular 424también se denomina abrazo mortal. imagine dos subprocesos, t1 y t2, y dos recursos, r1 y r2. t1 tiene r1, t2 tiene r2. t1 también necesita r2 y t2 también necesita r1. es similar al diagrama de la figura a.3: figura a.3. estas cuatro condiciones deben cumplirse para que se produzca un bloqueo mutuo. si se incumple alguna de ellas, no se producirá. evitar la exclusión mutua una estrategia para evitar el bloqueo mutuo es impedir la condición de exclusión mutua, por medio de lo siguiente: usar recursos que permitan un uso simultáneo, como por ejemplo, atomicinteger . incrementar el número de recursos para que sea igual o mayor que el número de subprocesos implicados. comprobar que todos los recursos están libres antes de adquirir ninguno. desafortunadamente, la mayoría de recursos son limitados y no permiten un uso simultáneo, y es habitual que la identidad del segundo recurso se base en los resultados de operar sobre el primero, pero no se desanime, todavía 425quedan tres condiciones. evitar bloqueo y espera también puede eliminar el bloqueo mutuo si rechaza la espera. compruebe cada uno de los recursos antes de obtenerlos y libere todos los recursos y comience de nuevo si detecta uno que esté ocupado. este enfoque genera algunos problemas: inanición: un subproceso no consigue adquirir los recursos que necesita (puede que tenga una combinación exclusiva de recursos que casi nunca esté disponible). bloqueo activo: varios subprocesos pueden actuar al unísono, adquirir un recurso y liberarlo, de forma repetida. es especialmente probable en algoritmos de programación de cpu simples (como dispositivos incrustados o algoritmos de equilibrio de subprocesos escritos a mano). en ambos casos, se puede reducir la producción. el primero reduce la utilización de la cpu, mientras que el segundo genera una elevada utilización de la cpu sin sentido. aunque esta estrategia parezca ineficaz, es mejor que nada. como ventaja, siempre se puede implementar si todo lo demás falla. evitar la expropiación otra estrategia para evitar el bloqueo mutuo consiste en permitir que todos los subprocesos se apropien de los recursos de otros. suele realizarse a través de un sencillo mecanismo de solicitudes. cuando un subproceso descubre que hay un recurso ocupado, le solicita al propietario que lo libere. si el propietario también espera a otro recurso, lo libera y comienza de nuevo. es similar al enfoque anterior, pero, como ventaja, un subproceso puede esperar a un recurso, lo que reduce el número de reinicios. sin embargo, la gestión de todas estas solicitudes puede resultar complicada. 426evitar la espera circular es el enfoque más habitual para impedir el bloqueo mutuo. en la mayoría de sistemas, basta con una sencilla convención acordada entre ambas partes. en el ejemplo anterior del subproceso 1 que quiere tanto el recurso 1 como el 2, y el subproceso 2 que desea tanto el recurso 2 como el 1, al forzar a ambos subprocesos a que asignen los recursos en el mismo orden se imposibilita la espera circular. en general, si todos los subprocesos pueden acordar un orden global de los recursos y si todos asignan los recursos en ese orden, el bloqueo mutuo es imposible. pero como todas las estrategias, también se pueden producir problemas: el orden de adquisición puede no corresponderse al orden de uso; por tanto, un recurso adquirido al inicio puede que no se use hasta el final. esto puede bloquear recursos más tiempo de lo estrictamente necesario. en ocasiones no se puede imponer un orden de adquisición de recursos. si el id del segundo recurso proviene de una operación realizada en el primero, ese orden no es factible. por tanto, existen varias formas de evitar el bloqueo mutuo. algunas provocan inanición, mientras que otras usan la cpu en exceso y reducen la capacidad de respuesta. ¡ tanstaafl ! [122] el aislamiento de la parte relacionada con subprocesos de su solución para permitir ajustes y experimentación es una forma de aprender a determinar las estrategias óptimas. probar código con múltiples subprocesos ¿cómo se puede crear una prueba que demuestre que el siguiente código no es correcto? 01: public class classwiththreadingproblem { 02: int nextid; 03: 42704: public int takenextid() { 05: return nextid++; 06: } 07: } veamos la descripción de una prueba que lo demuestre: recordar el valor actual de nextid . crear dos subprocesos y que cada uno invoque takenextid() una vez. comprobar que el valor de nextid es dos más que el inicial. ejecutar hasta demostrar que nextid sólo se ha incrementado en uno y no en dos. en el listado a-2 se reproduce la prueba: listado a-2 classwiththreadingproblemtest.java. 01: package example; 02: 03: import static org.junit.assert.fail; 04: 05: import org.junit.test; 06: 07: public class classwiththreadingproblemtest { 08: @test 09: public void twothreadsshouldfaileventually() throws exception { 10: final classwiththreadingproblem classwiththreadingproblem = new classwiththreadingproblem(); 11: 12: runnable runnable = new runnable() { 13: public void run() { 14: classwiththreadingproblem.takenextid(); 15: } 16: }; 17: 18: for (int i = 0; i < 50000; ++i) { 19: int startingid = classwiththreadingproblem.lastid; 20: int expectedresult = 2 + startingid; 21: 22: thread t1 = new thread(runnable); 42823: thread t2 = new thread(runnable); 24: t1.start(); 25: t2.start(); 26: t1.join(); 27: t2.join(); 28: 29: int endingid = classwiththreadingproblem.lastid; 30: 31: if (endingid != expectedresult) 32: return; 33: } 34: 35: fail(“should have exposed a threading issue but it did not.”); 36: } 37: } línea descripción 10 crear una sola instancia de classwiththreadingproblem . debemos usar la palabra clave final ya que se usa después en una clase interna anónima. 12-16 crear una clase interna anónima que use la instancia de classwiththreadingproblem . 18 ejecutar este código hasta demostrar que falla, pero no tanto como para que la prueba tarde demasiado. es un acto de equilibrio; no queremos esperar demasiado para demostrar el fallo. elegir la cantidad de ejecuciones es complicado, aunque como veremos después, esta cifra se puede reducir considerablemente. 19 recordar el valor inicial, la prueba intenta demostrar que el código de classwiththreadingproblem es incorrecto. si se supera la prueba, lo habrá demostrado. si la prueba falla, habrá sido incapaz de demostrarlo. 20 esperamos que el valor final sea dos más que el actual. 22-23 crear dos subprocesos que usen el objeto creado en las líneas 12-16. de este modo contamos con dos posibles subprocesos que intentan usar nuestra instancia de classwiththreadingproblem y ambos interfieren entre sí. 24-25 hacer que los dos subprocesos se puedan ejecutar. 42926-27 esperar a que terminen los dos subprocesos antes de comprobar los resultados. 29 registrar el valor final. 31-32 ¿es diferente endingid a lo que esperábamos? en caso afirmativo, se finaliza la prueba; hemos demostrado que el código es incorrecto. en caso negativo, volver a intentarlo. 35 si hemos llegado hasta aquí, la prueba no ha podido demostrar que el código de producción era incorrecto en una cantidad de tiempo razonable; el código ha fallado. o no es incorrecto o no hemos realizado suficientes iteraciones para que se produzca la condición de fallo. esta prueba establece las condiciones de un problema de actualización concurrente. sin embargo, el problema es tan infrecuente que la mayoría de las veces la prueba no lo detecta. en realidad, para detectar el problema debemos establecer el número de iteraciones en más de un millón. incluso con esa cantidad, en diez ejecuciones de un bucle de 1 000 000, el problema sólo apareció una vez, lo que significa que debemos aumentar las iteraciones para obtener fallos fiables. ¿cuánto estamos dispuestos a esperar? aunque ajustáramos la prueba para obtener fallos fiables en un equipo, seguramente tendríamos que ajustarla con otros valores para ilustrar el fallo en otro equipo, sistema operativo o versión de la mvj. y es un problema sencillo . si no podemos demostrarlo, ¿qué pasará cuando detectemos problemas realmente complejos? ¿qué enfoques debemos adoptar para demostrar este sencillo fallo? y, sobre todo, ¿cómo podemos crear pruebas que demuestren fallos en un código más complejo? ¿cómo podremos saber si el código tiene fallos cuando ni siquiera sabemos dónde buscar? veamos algunas sugerencias: pruebas monte carlo: crear pruebas flexibles que se puedan ajustar. después, ejecutarlas repetidamente, por ejemplo, en un servidor de prueba, y cambiar los valores de ajuste aleatoriamente. si las pruebas 430fallan, el código es incorrecto. diseñe las pruebas en las fases iniciales para que un servidor de integración continua las ejecute lo antes posible. registre las condiciones de fallo de las pruebas. ejecutar la prueba en todas las plataformas de desarrollo: de forma repetida y continuada. cuanto más tiempo se ejecuten las pruebas sin fallos, más probable es que el código de producción sea correcto o las pruebas no sean adecuadas para revelar los problemas. ejecutar las pruebas en un equipo con distintas cargas: si puede simular cargas similares a las del entorno de producción, hágalo. sin embargo, aunque realice todos estos pasos, no es probable que detecte problemas de subprocesos en el código. los problemas más complicados son los que sólo se producen una vez cada mil millones de oportunidades. son el azote de los sistemas complejos. herramientas para probar código basado en subprocesos ibm ha creado la herramienta contest [123] . lo que hace es instrumentar las clases para aumentar las probabilidades de que falle el código sin subprocesos. no tenemos relación directa con ibm ni con el equipo que ha desarrollado contest. un colega nos la descubrió. tras varios minutos de usarla, notamos una gran mejoría en la detección de errores. a continuación, le indicamos cómo usar contest: crear pruebas y código de producción, asegurándonos que haya pruebas diseñadas específicamente para simular varios usuarios con diferentes cargas, como mencionamos antes. instrumentar el código de pruebas y producción con contest. ejecutar las pruebas. 431al instrumentar el código con contest, la tasa de éxito pasó de un fallo por cada millón de iteraciones a un fallo en 30 iteraciones. los valores de bucle de las distintas ejecuciones de la prueba tras la instrumentación son los siguientes: 13, 23, 0, 54, 16, 14, 6, 69, 107, 49, 2. evidentemente, las clases instrumentadas fallaban antes y con mayor fiabilidad. conclusión en este capítulo hemos realizado un breve recorrido por el vasto y complejo territorio de la programación concurrente. apenas hemos mostrado la superficie. nos hemos centrado en disciplinas para mantener la limpieza del código concurrente, pero hay mucho más que aprender si tiene pensado diseñar sistemas concurrentes. le recomendamos que empiece por el libro de doug lea concurrent programming in java: design principles and patterns [124] . en este capítulo hemos presentado la actualización concurrente y las disciplinas de sincronización y bloqueo para evitarla. hemos visto cómo los subprocesos pueden mejorar la producción de un sistema vinculado a e/s y las técnicas limpias para lograr dichas mejoras. hemos descrito el bloqueo mutuo y las disciplinas para evitarlo de forma limpia. por último, hemos analizado estrategias para mostrar problemas de concurrencia mediante la instrumentación del código. ejemplos de código completos cliente/servidor sin subprocesos listado a-3 server.java package com.objectmentor.clientserver.nonthreaded; 432import java.io.ioexception; import java.net.serversocket; import java.net.socket; import java.net.socketexception; import common.messageutils; public class server implements runnable { serversocket serversocket; volatile boolean keepprocessing = true; public server(int port, int millisecondstimeout) throws ioexception { serversocket = new serversocket(port); serversocket.setsotimeout(millisecondstimeout); } public void run() { system.out.printf(“server starting\n”); while (keepprocessing) { try { system.out.printf(“accepting client\n”); socket socket = serversocket.accept(); system.out.printf(“got client\n”); process(socket); } catch (exception e) { handle(e); } } } private void handle(exception e) { if (!(e instanceof socketexception)) { e.printstacktrace(); } } public void stopprocessing() { keepprocessing = false; closeignoringexception(serversocket); } void process(socket socket) { if (socket == null) return; try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); 433closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } private void closeignoringexception(socket socket) { if (socket != null) try { socket.close(); } catch (ioexception ignore) { } } private void closeignoringexception(serversocket serversocket) { if (serversocket != null) try { serversocket.close(); } catch (ioexception ignore) { } } } listado a-4 clienttest.java. package com.objectmentor.clientserver.nonthreaded; import java.io.ioexception; import java.net.serversocket; import java.net.socket; import java.net.socketexception; import common.messageutils; public class server implements runnable { serversocket serversocket; volatile boolean keepprocessing = true; public server(int port, int millisecondstimeout) throws ioexception { serversocket = new serversocket(port); serversocket.setsotimeout(millisecondstimeout); } public void run() { system.out.printf(“server starting\n”); while (keepprocessing) { try { system.out.printf(“accepting client\n”); socket socket = serversocket.accept(); system.out.printf(“got client\n”); process(socket); } catch (exception e) { 434handle(e); } } } private void handle(exception e) { if (!(e instanceof socketexception)) { e.printstacktrace(); } } public void stopprocessing() { keepprocessing = false; closeignoringexception(serversocket); } void process(socket socket) { if (socket == null) return; try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } private void closeignoringexception(socket socket) { if (socket != null) try { socket.close(); } catch (ioexception ignore) { } } private void closeignoringexception(serversocket serversocket) { if (serversocket != null) try { serversocket.close(); } catch (ioexception ignore) { } } } listado a-5 435messageutils.java. package common; import java.io.ioexception; import java.io.inputstream; import java.io.objectinputstream; import java.io.objectoutputstream; import java.io.outputstream; import java.net.socket; public class messageutils { public static void sendmessage(socket socket, string message) throws ioexception { outputstream stream = socket.getoutputstream(); objectoutputstream oos = new objectoutputstream(stream); oos.writeutf(message); oos.flush(); } public static string getmessage(socket socket) throws ioexception { inputstream stream = socket.getinputstream(); objectinputstream ois = new objectinputstream(stream); return ois.readutf(); } } cliente/servidor con subprocesos para cambiar el servidor para que use subprocesos basta con cambiar el mensaje process (las nuevas líneas se muestran en negrita para destacarlas): void process(final socket socket) { if (socket == null) return; runnable clienthandler = new runnable() { public void run() { try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } 436}; thread clientconnection = new thread(clienthandler); clientconnection.start(); } 437apéndice b org.jfree.date.serialdate listado b-1 serialdate.java 1 /*============================================================== 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 *============================================================== 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia 17 * pública general gnu si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110- 1301, 22 * ee.uu. 23 * 43824 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ------------------ 28 * serialdate.java 29 * ------------------ 30 * (c) copyright 2001-2005, de object refinery limited. 31 * 32 * autor original: david gilbert (para object refinery limited); 33 * colaborador(es): -; 34 * 35 * $id: serialdate.java,v 1.7 2005/11/03 09:25:17 mungady exp $ 36 * 37 * cambios (11-oct-2001) 38 * -------------------------------------- 39 * 11-oct-2001: reorganización de la clase y cambio a un nuevo paquete 40 * com.jrefinery.date (dg); 41 * 05-nov-2001: se añade un método getdescription() y se elimina la clase 42 * notabledate (dg); 43 * 12-nov-2001: ibd requiere el método setdescription(), una vez eliminada la clase 44 * notabledate (dg); se cambian getpreviousdayofweek(), 45 * getfollowingdayofweek() y getnearestdayofweek() para corregir 46 * errores (dg); 47 * 05-dic-2001: error corregido en la clase spreadsheetdate (dg); 48 * 29-may-2002: se transfieren las constantes de mes a una interfaz independiente 49 * (monthconstants) (dg); 50 * 27-ago-2002: error corregido en el método addmonths(), gracias a nálevka petr (dg); 51 * 03-oct-2002: errores indicados por checkstyle (dg) corregidos; 52 * 13-mar-2003: implementación de serializable (dg); 53 * 29-may-2003: error corregido en el método addmonths (dg); 54 * 04-sep-2003: implementación de comparable. actualización de los javadoc isinrange (dg); 55 * 05-ene-2005: error corregido en el método addyears() (1096282) (dg); 56 * 57 */ 58 59 package org.jfree.date; 60 61 import java.io.serializable; 62 import java.text.dateformatsymbols; 63 import java.text.simpledateformat; 64 import java.util.calendar; 65 import java.util.gregoriancalendar; 43966 67 /** 68 * clase abstracta que define nuestros requisitos para manipular fechas, 68 * sin limitación a una determinada implementación. 70 * <p> 71 * requisito 1: coincidir al menos con el procesamiento de fechas en excel; 72 * requisito 2: la clase es inmutable; 73 * <p> 74 * ¿por qué no usar java.util.date? lo haremos, cuando tenga sentido. en ocasiones, 75 * java.util.date puede ser demasiado precisa; representa un instante en el tiempo, 76 * con una precisión de 1/1000 de segundo (y la fecha depende de la 77 * zona horaria). en ocasiones sólo querremos representar un día concreto (como el 21 78 * de enero de 2015) sin preocuparnos de la hora del día, la 79 * zona horaria u otros aspectos. para eso hemos definido daydate. 80 * <p> 81 * puede invocar getinstance() para obtener una subclase concreta de serialdate, 82 * sin preocuparse de su implementación exacta 83 * 84 * @author david gilbert 85 */ 86 public abstract class serialdate implements comparable, 87 serializable, 88 monthconstants { 89 90 /** para serialización. */ 91 private static final long serialversionuid = -293716040467423637l; 92 93 /** símbolos de formato de fecha. */ 94 public static final dateformatsymbols 95 date_format_symbols = new simpledateformat().getdateformatsymbols(); 96 97 /** número de serie para el 1 de enero de 1900. */ 98 public static final int serial_lower_bound = 2; 99 100 /** número de serie para el 31 de diciembre de 9999. */ 101 public static final int serial_upper_bound = 2958465; 102 103 /** valor de año más bajo admitido por este formato de fecha. */ 104 public static final int minimum_year_supported = 1900; 105 106 /** valor de año más alto admitido por este formato de fecha. */ 440107 public static final int maximum_year_supported = 9999; 108 109 /** constante útil para lunes; equivale a java.util.calendar.monday. */ 110 public static final int monday = calendar.monday; 111 112 /** 113 * constante útil para martes; equivale a java.util.calendar.tuesday. 114 * / 115 public static final int tuesday = calendar.tuesday; 116 117 /** 118 * constante útil para miércoles; equivale a 119 * java.util.calendar.wednesday. 120 */ 121 public static final int wednesday = calendar.wednesday; 122 123 /** 124 * constante útil para jueves; equivale a java.util.calendar.thursday. 125 */ 126 public static final int thursday = calendar.thursday; 127 128 /** constante útil para viernes; equivale a java.util.calendar.friday. */ 129 public static final int friday = calendar.friday; 130 131 /** 132 * constante útil para sábado; equivale a java.util.calendar.saturday. 133 */ 134 public static final int saturday = calendar.saturday; 135 136 /** constante útil para domingo; equivale a java.util.calendar.sunday. */ 137 public static final int sunday = calendar.sunday; 138 139 /** número de días de cada mes en años no bisiestos. */ 140 static final int[] last_day_of_month = 141 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 142 143 /** número de días en un año (no bisiesto) hasta el final de cada mes. */ 144 static final int[] aggregate_days_to_end_of_month = 145 {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 146 147 /** número de días en un año hasta el final del mes anterior. */ 148 static final int[] aggregate_days_to_end_of_preceding_month = 441149 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 150 151 /** número de días en un año bisiesto hasta el final de cada mes. */ 152 static final int[] leap_year_aggregate_days_to_end_of_month = 153 {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 154 155 /** 156 * número de días en un año bisiesto hasta el final del mes anterior. 157 */ 158 static final int[] 159 leap_year_aggregate_days_to_end_of_preceding_month = 160 {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 161 162 /** una constante útil para hacer referencia a la primera semana del mes. */ 163 public static final int first_week_in_month = 1; 164 165 /** una constante útil para hacer referencia a la segunda semana del mes. */ 166 public static final int second_week_in_month = 2; 167 168 /** una constante útil para hacer referencia a la tercera semana del mes. */ 169 public static final int third_week_in_month = 3; 170 171 /** una constante útil para hacer referencia a la cuarta semana del mes. */ 172 public static final int fourth_week_in_month = 4; 173 174 /** una constante útil para hacer referencia a la última semana del mes. */ 175 public static final int last_week_in_month = 0; 176 177 /** constante de intervalo. */ 178 public static final int include_none = 0; 179 180 /** constante de intervalo. */ 181 public static final int include_first = 1; 182 183 /** constante de intervalo. */ 184 public static final int include_second = 2; 185 186 /** constante de intervalo. */ 187 public static final int include_both = 3; 188 189 /** 442190 * constante útil para especificar un día de la semana con respecto a una fecha 191 * fija. 192 */ 193 public static final int preceding = -1; 194 195 /** 196 * constante útil para especificar un día de la semana con respecto a una fecha 197 * fija. 198 */ 199 public static final int nearest = 0; 200 201 /** 202 * constante útil para especificar un día de la semana con respecto a una fecha 203 * fija. 204 */ 205 public static final int following = 1; 206 207 /** una descripción para la fecha. */ 208 private string description; 209 210 /** 211 * constructor predeterminado. 212 */ 213 protected serialdate() { 214 } 215 216 /** 217 * devuelve <code>true</code> si el código entero proporcionado representa un 218 * día de la semana válido y <code>false</code> en caso contrario. 219 * 220 * @param code el código del que se comprueba la validez. 221 * 222 * @return <code>true</code> si el código entero proporcionado representa un 223 * día de la semana válido y <code>false</code> en caso contrario. 224 */ 225 public static boolean isvalidweekdaycode(final int code) { 227 switch(code) { 228 case sunday: 229 case monday: 230 case tuesday: 231 case wednesday: 443232 case thursday: 233 case friday: 234 case saturday: 235 return true; 236 default: 237 return false; 238 } 239 240 } 241 242 /** 243 * convierte la cadena proporcionada en un día de la semana. 244 * 245 * @param s una cadena que representa el día de la semana. 246 * 247 * @return <code>-1</code> si la cadena no se puede convertir o el día de 248 * la semana en caso contrario. 249 */ 250 public static int stringtoweekdaycode(string s) { 251 252 final string[] shortweekdaynames 253 = date_format_symbols.getshortweekdays(); 254 final string[] weekdaynames = date_format_symbols.getweekdays(); 255 256 int result = -1; 257 s = s.trim(); 258 for (int i = 0; i < weekdaynames.length; i++) { 259 if (s.equals(shortweekdaynames[i])) { 260 result = i; 261 break; 262 } 263 if (s.equals(weekdaynames[i])) { 264 result = i; 265 break; 266 } 267 } 268 return result; 269 270 } 271 272 /** 273 * devuelve una representación en cadena del día de la semana proporcionado. 274 * <p> 275 * necesitamos un enfoque mejor. 444276 * 277 * @param weekday el día de la semana. 278 * 279 * @return una cadena que representa el día de la semana proporcionado. 280 */ 281 public static string weekdaycodetostring(final int weekday) { 282 283 final string[] weekdays = date_format_symbols.getweekdays(); 284 return weekdays[weekday]; 285 286 } 287 288 /** 289 * devuelve una matriz de nombres de mes. 290 * 291 * @return una matriz de nombres de mes. 292 */ 293 public static string[] getmonths() { 294 295 return getmonths(false); 296 297 } 298 299 /** 300 * devuelve una matriz de nombres de mes. 301 * 302 * @param shortened un indicador para indicar que deben devolverse los nombres 303 * de mes en formato reducido. 304 * 305 * @return una matriz de nombres de mes. 306 */ 307 public static string[] getmonths(final boolean shortened) { 308 309 if (shortened) { 310 return date_format_symbols.getshortmonths(); 311 } 312 else { 313 return date_format_symbols.getmonths(); 314 } 315 316 } 317 318 /** 319 * devuelve true si el código entero proporcionado representa un mes 445válido. 320 * 321 * @param code el código del que se comprueba la validez. 322 * 323 * return <code>true</code> si el código entero proporcionado representa un 324 * mes válido. 325 */ 326 public static boolean isvalidmonthcode(final int code) { 327 328 switch(code) { 329 case january: 330 case february: 331 case march: 332 case april: 333 case may: 334 case june: 335 case july: 336 case august: 337 case september: 338 case october: 339 case november: 340 case december: 341 return true; 342 default: 343 return false; 344 } 345 346 } 347 348 /** 349 * devuelve el trimestre del mes especificado. 350 * 351 * @param code el código del mes (1-12). 352 * 353 * @return el trimestre al que pertenece el mes. 354 * @throws java.lang.illegalargumentexception 355 */ 356 public static int monthcodetoquarter(final int code) { 357 358 switch(code) { 359 case january: 360 case february: 361 case march: return 1; 362 case april: 446363 case may: 364 case june: return 2; 365 case july: 366 case august: 367 case september: return 3; 368 case october: 369 case november: 370 case december: return 4; 371 default: throw new illegalargumentexception( 372 “serialdate.monthcodetoquarter: invalid month code.”); 373 } 374 375 } 376 377 /** 378 * devuelve una cadena que representa el mes proporcionado. 379 * <p> 380 * la cadena devuelta es la forma extensa del nombre del mes obtenido de la 381 * configuración regional. 382 * 383 * @param month el mes. 384 * 385 * @return una cadena que representa el mes proporcionado 386 */ 387 public static string monthcodetostring(final int month) { 388 389 return monthcodetostring(month, false); 390 391 } 392 393 /** 394 * devuelve una cadena que representa el mes proporcionado. 395 * <p> 396 * la cadena devuelta es la forma extensa o reducida del nombre del mes 397 * obtenido de la configuración regional. 398 * 399 * @param month el mes. 400 * @param shortened si <code>true</code> devuelve la abreviatura del 401 * mes. 402 * 403 * @return una cadena que representa el mes proporcionado. 404 * @throws java.lang.illegalargumentexception 405 */ 406 public static string monthcodetostring(final int month, 447407 final boolean shortened) { 408 409 // comprobar argumentos… 410 if (!isvalidmonthcode(month)) { 411 throw new illegalargumentexception( 412 “serialdate.monthcodetostring: month outside valid range.”); 413 } 414 415 final string[] months; 416 417 if (shortened) { 418 months = date_format_symbols.getshortmonths(); 419 } 420 else { 421 months = date_format_symbols.getmonths(); 422 } 423 424 return months[month - 1]; 425 426 } 427 428 /** 429 * convierte una cadena en el código del mes. 430 * <p> 431 * este método devuelve una de las constantes january, february, …, 432 * december correspondientes a la cadena. si la cadena no se 433 * reconoce, este método devuelve -1. 434 * 435 * @param s la cadena que analizar. 436 * 437 * @return <code>-1</code> si la cadena no se puede analizar, o el mes del 438 * año en caso contrario. 439 */ 440 public static int stringtomonthcode(string s) { 441 442 final string[] shortmonthnames = date_format_symbols.getshortmonths(); 443 final string[] monthnames = date_format_symbols.getmonths(); 444 445 int result = -1; 446 s = s.trim(); 447 448 // primero intentar analizar la cadena como entero (1-12)… 449 try { 450 result = integer.parseint(s); 448451 } 452 catch (numberformatexception e) { 453 // suprimir 454 } 455 456 // buscar por los nombres de los meses… 457 if ((result < 1) || (result > 12)) { 458 for (int i = 0; i < monthnames.length; i++) { 459 if (s.equals(shortmonthnames[i])) { 460 result = i + 1; 461 break; 462 } 463 if (s.equals(monthnames[i])) { 464 result = i + 1; 465 break; 466 } 467 } 468 } 469 470 return result; 471 472 } 473 474 /** 475 * devuelve true si el código entero proporcionado representa una semana 476 * del mes válida y false en caso contrario 477 * 478 * @param code el código del que se comprueba la validez. 479 * @return <code>true</code> si el código entero proporcionado representa una 480 * semana del mes válida. 481 */ 482 public static boolean isvalidweekinmonthcode(final int code) { 483 484 switch(code) { 485 case first_week_in_month: 486 case second_week_in_month: 487 case third_week_in_month: 488 case fourth_week_in_month: 489 case last_week_in_month: return true; 490 default: return false; 491 } 492 493 } 449494 495 /** 496 * determina si el año especificado es bisiesto o no. 497 * 498 * @param yyyy el año (entre 1900 y 9999). 499 * 500 * @return <code>true</code> si el año especificado es bisiesto. 501 */ 502 public static boolean isleapyear(final int yyyy) { 503 504 if ((yyyy % 4) != 0) { 505 return false; 506 } 507 else if ((yyyy % 400) == 0) { 508 return true; 509 } 510 else if ((yyyy % 100) == 0) { 511 return false; 512 } 513 else { 514 return true; 515 } 516 517 } 518 519 /** 520 * devuelve el número de años bisiestos desde 1900 hasta el año especificado 521 * inclusive. 522 * <p> 523 * 1900 no es un año bisiesto. 524 * 525 * @param yyyy el año (entre 1900 y 9999). 526 * 527 * @return el número de años bisiestos desde 1900 hasta el año especificado. 528 */ 529 public static int leapyearcount(final int yyyy) { 530 531 final int leap4 = (yyyy - 1896) / 4; 532 final int leap100 = (yyyy - 1800) / 100; 533 final int leap400 = (yyyy - 1600) / 400; 534 return leap4 - leap100 + leap400; 535 536 } 537 450538 /** 539 * devuelve el número del último día del mes, teniendo en cuenta los 540 * años bisiestos. 541 * 542 * @param month el mes. 543 * @param yyyy el año (entre 1900 y 9999). 544 * 545 * @return el número del último día del mes. 546 */ 547 public static int lastdayofmonth(final int month, final int yyyy) { 548 549 final int result = last_day_of_month[month]; 550 if (month != february) { 551 return result; 552 } 553 else if (isleapyear(yyyy)) { 554 return result + 1; 555 } 556 else { 557 return result; 558 } 559 560 } 561 562 /** 563 * crea una nueva fecha añadiendo el número especificado de días a la fecha 564 * base. 565 * 566 * @param days el número de días que añadir (puede ser negativo). 567 * @param base la fecha base. 568 * 569 * @return una nueva fecha. 570 */ 571 public static serialdate adddays(final int days, final serialdate base) { 572 573 final int serialdaynumber = base.toserial() + days; 574 return serialdate.createinstance(serialdaynumber); 575 576 } 577 578 /** 579 * crea una nueva fecha añadiendo el número especificado de meses a la fecha 580 * base. 451581 * <p> 582 * si la fecha base es próxima al final del mes, el día del resultado 583 * se puede ajustar ligeramente: 31 mayo + 1 mes = 30 junio. 584 * 585 * @param months el número de meses que añadir (puede ser negativo). 586 * @param base la fecha base. 587 * 588 * @return una nueva fecha. 589 */ 590 public static serialdate addmonths(final int months, 591 final serialdate base) { 592 593 final int yy = (12 * base.getyyyy() + base.getmonth() + months - 1) 594 / 12; 595 final int mm = (12 * base.getyyyy() + base.getmonth() + months – 1) 596 % 12 + 1; 597 final int dd = math.min( 598 base.getdayofmonth(), serialdate.lastdayofmonth(mm, yy) 599 ); 600 return serialdate.createinstance(dd, mm, yy); 601 602 } 603 604 /** 605 * crea una nueva fecha añadiendo el número especificado de años a la fecha 606 * base. 607 * 608 * @param years el número de años que añadir (puede ser negativo). 609 * @param base la fecha base. 610 * 611 * @return una nueva fecha. 612 */ 613 public static serialdate addyears(final int years, final serialdate base) { 614 615 final int basey = base.getyyyy(); 616 final int basem = base.getmonth(); 617 final int based = base.getdayofmonth(); 618 619 final int targety = basey + years; 620 final int targetd = math.min( 621 based, serialdate.lastdayofmonth(basem, targety) 622 ); 623 624 return serialdate.createinstance(targetd, basem, targety); 452625 626 } 627 628 /** 629 * devuelve la última fecha correspondiente al día de la semana especificado y 630 * anterior a la fecha base. 631 * 632 * @param targetweekday un código para el día de la semana de destino. 633 * @param base la fecha base. 634 * 635 * @return la última fecha correspondiente al día de la semana especificado y 636 * anterior a la fecha base. 637 */ 638 public static serialdate getpreviousdayofweek(final int targetweekday, 639 final serialdate base) { 640 641 // comprobar argumentos… 642 if (!serialdate.isvalidweekdaycode(targetweekday)) { 643 throw new illegalargumentexception( 644 “invalid day-of-the-week code.” 645 ); 646 } 647 648 // buscar la fecha… 649 final int adjust; 650 final int basedow = base.getdayofweek(); 651 if (basedow > targetweekday) { 652 adjust = math.min(0, targetweekday - basedow); 653 } 654 else { 655 adjust = -7 + math.max(0, targetweekday - basedow); 656 } 657 658 return serialdate.adddays(adjust, base); 659 660 } 661 662 /** 663 * devuelve la primera fecha que coincide con el día de la semana especificado 664 * y posterior a la fecha base. 665 * 666 * @param targetweekday un código para el día de la semana de destino. 453667 * @param base la fecha base. 668 * 669 * @return la primera fecha que coincide con el día de la semana especificado 670 * y posterior a la fecha base. 671 */ 672 public static serialdate getfollowingdayofweek(final int targetweekday, 673 final serialdate base) { 674 675 // comprobar argumentos… 676 if (!serialdate.isvalidweekdaycode(targetweekday)) { 677 throw new illegalargumentexception( 678 “invalid day-of-the-week code.” 679 ); 680 } 681 682 // buscar la fecha… 683 final int adjust; 684 final int basedow = base.getdayofweek(); 685 if (basedow > targetweekday) { 686 adjust = 7 + math.min(0, targetweekday - basedow); 687 } 688 else { 689 adjust = math.max(0, targetweekday - basedow); 690 } 691 692 return serialdate.adddays(adjust, base); 693 } 694 695 /** 696 * devuelve la fecha que coincide con el día de la semana especificado y más 697 * próxima a la fecha base. 698 * 699 * @param targetdow un código para el día de la semana de destino. 700 * @param base la fecha base. 701 * 702 * @return la fecha que coincide con el día de la semana especificado y más 703 * próxima a la fecha base. 704 */ 705 public static serialdate getnearestdayofweek(final int targetdow, 706 final serialdate base) { 707 708 // comprobar argumentos… 454709 if (!serialdate.isvalidweekdaycode(targetdow)) { 710 throw new illegalargumentexception( 711 “invalid day-of-the-week code.” 712 ); 713 } 714 715 // buscar la fecha… 716 final int basedow = base.getdayofweek(); 717 int adjust = -math.abs(targetdow - basedow); 718 if (adjust >= 4) { 719 adjust = 7 - adjust; 720 } 721 if (adjust <= -4) { 722 adjust = 7 + adjust; 723 } 724 return serialdate.adddays(adjust, base); 725 726 } 727 728 /** 729 * avanzar la fecha hasta el último día del mes. 730 * 731 * @param base la fecha base. 732 * 733 * @return una nueva fecha de serie. 734 */ 735 public serialdate getendofcurrentmonth(final serialdate base) { 736 final int last = serialdate.lastdayofmonth( 737 base.getmonth(), base.getyyyy() 738 ); 739 return serialdate.createinstance(last, base.getmonth(), base.getyyyy()); 740 } 741 742 /** 743 * devuelve una cadena correspondiente al código de la semana del mes. 744 * <p> 745 * necesitamos un enfoque mejor. 746 * 747 * @param count un código entero que representa la semana del mes. 748 * 749 * @return una cadena correspondiente al código de la semana del mes. 750 */ 751 public static string weekinmonthtostring(final int count) { 752 455753 switch (count) { 754 case serialdate.first_week_in_month : return “first”; 755 case serialdate.second_week_in_month : return “second”; 756 case serialdate.third_week_in_month : return “third”; 757 case serialdate.fourth_week_in_month : return “fourth”; 758 case serialdate.last_week_in_month : return “last”; 759 default : 760 return “serialdate.weekinmonthtostring(): invalid code.”; 761 } 762 763 } 764 765 /** 766 * devuelve una cadena que representa el valor ‘relativo’ proporcionado. 767 * <p> 768 * necesitamos un enfoque mejor. 769 * 770 * @param relative una constante que representa el valor ‘relativo’. 771 * 772 * @return una cadena que representa el valor ‘relativo’ proporcionado. 773 */ 774 public static string relativetostring(final int relative) { 775 776 switch (relative) { 777 case serialdate.preceding : return “preceding”; 778 case serialdate.nearest : return “nearest”; 779 case serialdate.following : return “following”; 780 default : return “error : relative to string”; 781 } 782 783 } 784 785 /** 786 * método de factoría que devuelve una instancia de una subclase concreta de 787 * {@link serialdate}. 788 * 789 * @param day el día (1-31). 790 * @param month el mes (1-12). 791 * @param yyyy el año (entre 1900 y 9999). 792 * 793 * @return una instancia de {@link serialdate} 794 */ 795 public static serialdate createinstance(final int day, final int 456month, 796 final int yyyy) { 797 return new spreadsheetdate(day, month, yyyy); 798 } 799 800 /** 801 * método de factoría que devuelve una instancia de una subclase concreta de 802 * {@link serialdate}. 803 * 804 * @param serial numero de serie del día (1 de enero de 1900 = 2). 805 * 806 * @return una instancia de serialdate. 807 */ 808 public static serialdate createinstance(final int serial) { 809 return new spreadsheetdate(serial); 810 } 811 812 /** 813 * método de factoría que devuelve una instancia de una subclase de serialdate. 814 * 815 * @param date un objeto de fecha de java. 816 * 817 * @return una instancia de serialdate. 818 */ 818 public static serialdate createinstance(final java.util.date date) { 820 821 final gregoriancalendar calendar = new gregoriancalendar(); 822 calendar.settime(date); 823 return new spreadsheetdate(calendar.get(calendar.date), 824 calendar.get(calendar.month) + 1, 825 calendar.get(calendar.year)); 826 827 } 828 829 /** 830 * devuelve el número de serie de la fecha, siendo el 1 de enero de 1900 = 2 (se 831 * corresponde, casi totalmente, al sistema de numeración empleado en microsoft 832 * excel para windows y lotus 1-2-3). 833 * 834 * @return el número de serie de la fecha. 835 */ 836 public abstract int toserial(); 457837 838 /** 839 * devuelve java.util.date. como java.util.date tiene mayor precisión que 840 * serialdate, debemos definir una convención para “la hora del día”. 841 * 842 * @return this como <code>java.util.date</code>. 843 */ 844 public abstract java.util.date todate(); 845 846 /** 847 * devuelve una descripción de la fecha. 848 * 849 * @return una descripción de la fecha. 850 */ 851 public string getdescription() { 852 return this.description; 853 } 854 855 /** 856 * establece la descripción de la fecha. 857 * 858 * @param description la nueva descripción de la fecha. 859 */ 860 public void setdescription(final string description) { 861 this.description = description; 862 } 863 864 /** 865 * convierte la fecha en una cadena. 866 * 867 * @return una representación en cadena de la fecha. 868 */ 869 public string tostring() { 870 return getdayofmonth() + “-” + serialdate.monthcodetostring(getmonth()) 871 + “-” + getyyyy(); 872 } 873 874 /** 875 * devuelve el año (con un intervalo válido de 1900 a 9999). 876 * 877 * @return el año. 878 */ 879 public abstract int getyyyy(); 880 458881 /** 882 * devuelve el mes (enero = 1, febrero = 2, marzo = 3). 883 * 884 * @return el mes del año. 885 */ 886 public abstract int getmonth(); 887 888 /** 889 * devuelve el día del mes. 890 * 891 * @return el día del mes. 892 */ 893 public abstract int getdayofmonth(); 894 895 /** 896 * devuelve el día de la semana. 897 * 898 * @return el día de la semana. 899 */ 900 public abstract int getdayofweek(); 901 902 /** 903 * devuelve la diferencia (en días) entre esta fecha y la 904 * ‘otra’ fecha especificada. 905 * <p> 906 * el resultado es positivo si esta fecha es posterior a la ‘otra’ y 907 * negativo si es anterior. 908 * 909 * @param other la fecha con la que se compara. 910 * 911 * @return la diferencia entre esta fecha y la otra. 912 */ 913 public abstract int compare(serialdate other); 914 915 /** 916 * devuelve true si esta serialdate representa la misma fecha que la 917 * serialdate especificada. 918 * 919 * @param other la fecha con la que se compara. 920 * 921 * @return <code>true</code> si esta serialdate representa la misma fecha que 922 * la serialdate especificada. 923 */ 924 public abstract boolean ison(serialdate other); 459925 926 /** 927 * devuelve true si esta serialdate representa una fecha anterior en 928 * comparación a la serialdate especificada. 929 * 930 * @param other la fecha con la que se compara. 931 * 932 * @return <code>true</code> si esta serialdate representa una fecha anterior 933 * en comparación a la serialdate especificada. 934 */ 935 public abstract boolean isbefore(serialdate other); 936 937 /** 938 * devuelve true si esta serialdate representa la misma fecha que la 939 * serialdate especificada. 940 * 941 * @param other la fecha con la que se compara. 942 * 943 * @return <code>true</code> si esta serialdate representa la misma fecha 944 * que la serialdate especificada. 945 */ 946 public abstract boolean isonorbefore(serialdate other); 947 948 /** 949 * devuelve true si esta serialdate representa la misma fecha que la 950 * serialdate especificada. 951 * 952 * @param other la fecha con la que se compara. 953 * 954 * @return <code>true</code> si esta serialdate representa la misma fecha 955 * que la serialdate especificada. 956 */ 957 public abstract boolean isafter(serialdate other); 958 959 /** 960 * devuelve true si esta serialdate representa la misma fecha que la 961 * serialdate especificada. 962 * 963 * @param other la fecha con la que se compara. 964 * 965 * @return <code>true</code> si esta serialdate representa la misma fecha 966 * que la serialdate especificada. 460967 */ 968 public abstract boolean isonorafter(serialdate other); 969 970 /** 971 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 972 * rango especificado (inclusive). el orden de fecha de d1 y d2 no es 973 * importante. 974 * 975 * @param d1 fecha límite del rango. 976 * @param d2 la otra fecha límite del rango. 977 * 978 * @return un valor booleano. 979 */ 980 public abstract boolean isinrange(serialdate d1, serialdate d2); 981 982 /** 983 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 984 * rango especificado (el invocador especifica si los puntos finales se 985 * incluyen o no). el orden de fecha de d1 y d2 no es importante. 986 * 987 * @param d1 fecha límite del rango. 988 * @param d2 la otra fecha límite del rango. 989 * @param include un código que controla si las fechas inicial y final 990 * se incluyen o no en el rango. 991 * 992 * @return un valor booleano. 993 */ 994 public abstract boolean isinrange(serialdate d1, serialdate d2, 995 int include); 996 997 /** 998 * devuelve la última fecha que coincide con el día de la semana especificado y 999 * que es anterior a esta fecha. 1000 * 1001 * @param targetdow un código para el día de la semana de destino. 1002 * 1003 * @return la última fecha que coincide con el día de la semana especificado y 1004 * que es anterior a esta fecha. 1005 */ 1006 public serialdate getpreviousdayofweek(final int targetdow) { 1007 return getpreviousdayofweek(targetdow, this); 1008 } 1009 4611010 /** 1011 * devuelve la primera fecha que coincide con el día de la semana especificado 1012 * y que es posterior a esta fecha. 1013 * 1014 * @param targetdow un código para el día de la semana de destino. 1015 * 1016 * @return la primera fecha que coincide con el día de la semana especificado 1017 * que es posterior a esta fecha. 1018 */ 1019 public serialdate getfollowingdayofweek(final int targetdow) { 1020 return getfollowingdayofweek(targetdow, this); 1021 } 1022 1023 /** 1024 * devuelve la fecha más próxima que coincide con el día de la semana especificado. 1025 * 1026 * @param targetdow un código para el día de la semana de destino. 1027 * 1028 * @return la fecha más próxima que coincide con el día de la semana especificado. 1029 */ 1030 public serialdate getnearestdayofweek(final int targetdow) { 1031 return getnearestdayofweek(targetdow, this); 1032 } 1033 1034 } listado b-2 serialdatetest.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del projecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 46212 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ------------------------- 28 * serialdatetests.java 29 * ------------------------- 30 * (c) copyright 2001-2005, por object refinery limited. 31 32 * autor original: david gilbert (por object refinery limited); 33 * colaborador(es): -; 34 35 * $id: serialdatetests.java,v 1.6 2005/11/16 15:58:40 taqua exp $ 36 37 * cambios 38 * ----------- 39 * 15-nov-2001: version 1 (dg); 40 * 25-jun-2002: se elimina la importación innecesaria (dg); 41 * 24-oct-2002: errores indicados checkstyle corregidos (dg); 42 * 13-mar-2003: se añade prueba de serialización (dg); 43 * 05-jan-2005: se añade prueba para el informe de errores 1096282 (dg); 44 * 45 */ 46 47 package org.jfree.date.junit; 48 49 import java.io.bytearrayinputstream; 50 import java.io.bytearrayoutputstream; 51 import java.io.objectinput; 52 import java.io.objectinputstream; 53 import java.io.objectoutput; 54 import java.io.objectoutputstream; 55 46356 import junit.framework.test; 57 import junit.framework.testcase; 58 import junit.framework.testsuite; 59 60 import org.jfree.date.monthconstants; 61 import org.jfree.date.serialdate; 62 63 /** 64 * pruebas junit para la clase {@link serialdate}. 65 */ 66 public class serialdatetests extends testcase { 67 68 /** fecha que representa 9 de noviembre. 69 private serialdate nov9y2001; 70 71 /** 72 * crea un nuevo caso de prueba. 73 * 74 * @param name el nombre. 75 */ 76 public serialdatetests(final string name) { 77 super(name); 78 } 79 80 /** 81 * devuelve una suite de pruebas para el ejecutor de pruebas junit. 82 * 83 * @return la suite de pruebas. 84 */ 85 public static test suite() { 86 return new testsuite(serialdatetests.class); 87 } 88 89 /** 90 * problema. 91 */ 92 protected void setup() { 93 this.nov9y2001 = serialdate.createinstance(9, monthconstants.november, 2001); 94 } 95 96 /** 97 * 9 nov 2001 más dos meses debe ser 9 ene 2002. 98 */ 99 public void testaddmonthsto9nov2001() { 464100 final serialdate jan9y2002 = serialdate.addmonths(2, this.nov9y2001); 101 final serialdate answer = serialdate.createinstance(9, 1, 2002); 102 assertequals(answer, jan9y2002); 103 } 104 105 /** 106 * caso de prueba de un error, ya corregido. 107 */ 108 public void testaddmonthsto5oct2003() { 109 final serialdate d1 = serialdate.createinstance(5, monthconstants.october, 2003); 110 final serialdate d2 = serialdate.addmonths(2, d1); 111 assertequals(d2, serialdate.createinstance(5, monthconstants.december, 2003)); 112 } 113 114 /** 115 * caso de prueba de un error, ya corregido. 116 */ 117 public void testaddmonthsto1jan2003() { 118 final serialdate d1 = serialdate.createinstance(1, monthconstants.january, 2003); 119 final serialdate d2 = serialdate.addmonths(0, d1); 120 assertequals(d2, d1); 121 } 122 123 /** 124 * el lunes anterior al viernes 9 de noviembre de 2001 debe ser el 5 de noviembre. 125 */ 126 public void testmondayprecedingfriday9nov2001() { 127 serialdate mondaybefore = serialdate.getpreviousdayofweek( 128 serialdate.monday, this.nov9y2001 129 ); 130 assertequals(5, mondaybefore.getdayofmonth()); 131 } 132 133 /** 134 * el lunes posterior al viernes 9 de noviembre de 2001 debe ser el 12 de noviembre. 135 */ 136 public void testmondayfollowingfriday9nov2001() { 137 serialdate mondayafter = serialdate.getfollowingdayofweek( 138 serialdate.monday, this.nov9y2001 139 ); 465140 assertequals(12, mondayafter.getdayofmonth()); 141 } 142 143 /** 144 * el lunes más próximo al viernes 9 de noviembre de 2001 debe ser el 12 de noviembre. 145 */ 146 public void testmondaynearestfriday9nov2001() { 147 serialdate mondaynearest = serialdate.getnearestdayofweek( 148 serialdate.monday, this.nov9y2001 149 ); 150 assertequals(12, mondaynearest.getdayofmonth()); 151 } 152 153 /** 154 * el lunes más próximo al 22 de enero de 1970 cae en el 19. 155 */ 156 public void testmondaynearest22jan1970() { 157 serialdate jan22y1970 = serialdate.createinstance(22, monthconstants.january, 1970); 158 serialdate mondaynearest = serialdate.getnearestdayofweek(serialdate.monday, jan22y1970); 159 assertequals(19, mondaynearest.getdayofmonth()); 160 } 161 162 /** 163 * el problema es que la conversión de días en cadenas devuelva el resultado 164 * correcto. en realidad este resultado depende de la configuración regional. 165 */ 166 public void testweekdaycodetostring() { 167 168 final string test = serialdate.weekdaycodetostring(serialdate.saturday); 169 assertequals(“saturday”, test); 170 171 } 172 173 /** 174 * probar la conversión de una cadena en día de la semana. esta prueba falla si 175 * la configuración regional predeterminada no usa nombres de días en inglés 176 */ 177 public void teststringtoweekday() { 178 466179 int weekday = serialdate.stringtoweekdaycode(“wednesday”); 180 assertequals(serialdate.wednesday, weekday); 181 182 weekday = serialdate.stringtoweekdaycode(“ wednesday ”); 183 assertequals(serialdate.wednesday, weekday); 184 185 weekday = serialdate.stringtoweekdaycode(“wed”); 186 assertequals(serialdate.wednesday, weekday); 187 188 } 189 190 /** 191 * probar la conversión de una cadena en mes. esta prueba falla si la 192 * configuración regional predeterminada no usa nombres de días en inglés 193 */ 194 public void teststringtomonthcode() { 195 196 int m = serialdate.stringtomonthcode(“january”); 197 assertequals(monthconstants.january, m); 198 199 m = serialdate.stringtomonthcode(“ january ”); 200 assertequals(monthconstants.january, m); 201 202 m = serialdate.stringtomonthcode(“jan”); 203 assertequals(monthconstants.january, m); 204 205 } 206 207 /** 208 * probar la conversión de un código de mes en cadena. 209 */ 210 public void testmonthcodetostringcode() { 211 212 final string test = serialdate.monthcodetostring(monthconstants.december); 213 assertequals(“december”, test); 214 215 } 216 217 /** 218 * 1900 no es un año bisiesto. 219 */ 220 public void testisnotleapyear1900() { 221 asserttrue(!serialdate.isleapyear(1900)); 222 } 467223 224 /** 225 * 2000 es un año bisiesto. 226 */ 227 public void testisleapyear2000() { 228 asserttrue(serialdate.isleapyear(2000)); 229 } 230 231 /** 232 * el número de años bisiestos desde 1900 y hasta 1899 incluido es 0. 233 */ 234 public void testleapyearcount1899() { 235 assertequals(serialdate.leapyearcount(1899), 0); 236 } 237 238 /** 239 * el número de años bisiestos desde 1900 y hasta 1903 incluido es 0. 240 */ 241 public void testleapyearcount1903() { 242 assertequals(serialdate.leapyearcount(1903), 0); 243 } 244 245 /** 246 * el número de años bisiestos desde 1900 y hasta 1904 incluido es 1. 247 */ 248 public void testleapyearcount1904() { 249 assertequals(serialdate.leapyearcount(1904), 1); 250 } 251 252 /** 253 * el número de años bisiestos desde 1900 y hasta 1999 incluido es 24. 254 */ 255 public void testleapyearcount1999() { 256 assertequals(serialdate.leapyearcount(1999), 24); 257 } 258 259 /** 260 * el número de años bisiestos desde 1900 y hasta 2000 incluido es 25. 261 */ 262 public void testleapyearcount2000() { 263 assertequals(serialdate.leapyearcount(2000), 25); 264 } 265 266 /** 267 * serializar una instancia, restaurarla y comprobar la igualdad. 468268 */ 269 public void testserialization() { 270 271 serialdate d1 = serialdate.createinstance(15, 4, 2000); 272 serialdate d2 = null; 273 274 try { 275 bytearrayoutputstream buffer = new bytearrayoutputstream(); 276 objectoutput out = new objectoutputstream(buffer); 277 out.writeobject(d1); 278 out.close(); 279 280 objectinput in = new objectinputstream( new bytearrayinputstream(buffer.tobytearray())); 281 d2 = (serialdate) in.readobject(); 282 in.close(); 283 } 284 catch (exception e) { 285 system.out.println(e.tostring()); 286 } 287 assertequals(d1, d2); 288 289 } 290 291 /** 292 * prueba para el informe de error 1096282 (ya corregido). 293 */ 294 public void test1096282() { 295 serialdate d = serialdate.createinstance(29, 2, 2004); 296 d = serialdate.addyears(1, d); 297 serialdate expected = serialdate.createinstance(28, 2, 2005); 298 asserttrue(d.ison(expected)); 299 } 300 301 /** 302 * diversas pruebas para el método addmonths(). 303 */ 304 public void testaddmonths() { 305 serialdate d1 = serialdate.createinstance(31, 5, 2004); 307 serialdate d2 = serialdate.addmonths(1, d1); 308 assertequals(30, d2.getdayofmonth()); 309 assertequals(6, d2.getmonth()); 310 assertequals(2004, d2.getyyyy()); 311 312 serialdate d3 = serialdate.addmonths(2, d1); 469313 assertequals(31, d3.getdayofmonth()); 314 assertequals(7, d3.getmonth()); 315 assertequals(2004, d3.getyyyy()); 316 317 serialdate d4 = serialdate.addmonths(1, serialdate.addmonths(1, d1)); 318 assertequals(30, d4.getdayofmonth()); 319 assertequals(7, d4.getmonth()); 320 assertequals(2004, d4.getyyyy()); 321 } 322 } listado b-3 monthconstants.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ---------------------- 28 * monthconstants.java 47029 * ---------------------- 30 * (c) copyright 2002, 2003, de object refinery limited. 31 * 32 * autor original: david gilbert (para object refinery limited); 33 * colaborador(es): -; 34 * 35 * $id: monthconstants.java,v 1.4 2005/11/16 15:58:40 taqua exp $ 36 * 37 * cambios 38 * ---------- 39 * 29-may-2002 : version 1 (code moved from serialdate class) (dg); 40 * 41 */ 42 43 package org.jfree.date; 44 45 /** 46 * constantes útiles para los meses. no son equivalentes a las 47 * constantes definidas por java.util.calendar (donde january=0 y december=11). 48 * <p> 49 * se usa en las clases serialdate y regulartimeperiod. 50 * 51 * @author david gilbert 52 */ 53 public interface monthconstants { 54 55 /** constante para enero. */ 56 public static final int january = 1; 57 58 /** constante para febrero. */ 59 public static final int february = 2; 60 61 /** constante para marzo. */ 62 public static final int march = 3; 63 64 /** constante para abril. */ 65 public static final int april = 4; 66 67 /** constante para mayo. */ 68 public static final int may = 5; 69 70 /** constante para junio. */ 71 public static final int june = 6; 72 47173 /** constante para julio. */ 74 public static final int july = 7; 75 76 /** constante para agosto. */ 77 public static final int august = 8; 78 79 /** constante para septiembre. */ 80 public static final int september = 9; 81 82 /** constante para octubre. */ 83 public static final int october = 10; 84 85 /** constante para noviembre. */ 86 public static final int november = 11; 87 88 /** constante para diciembre. */ 89 public static final int december = 12; 90 91 } listado b-4 bobsserialdatetest.java 1 package org.jfree.date.junit; 2 3 import junit.framework.testcase; 4 import org.jfree.date.*; 5 import static org.jfree.date.serialdate.*; 6 7 import java.util.*; 8 9 public class bobsserialdatetest extends testcase { 10 11 public void testisvalidweekdaycode() throws exception { 12 for (int day = 1; day <= 7; day++) 13 asserttrue(isvalidweekdaycode(day)); 14 assertfalse(isvalidweekdaycode(0)); 15 assertfalse(isvalidweekdaycode(8)); 16 } 17 18 public void teststringtoweekdaycode() throws exception { 19 20 assertequals(-1, stringtoweekdaycode(“hello”)); 21 assertequals(monday, stringtoweekdaycode(“monday”)); 47222 assertequals(monday, stringtoweekdaycode(“mon”)); 23 //todo assertequals(monday,stringtoweekdaycode(“monday”)); 24 // assertequals(monday,stringtoweekdaycode(“monday”)); 25 // assertequals(monday, stringtoweekdaycode(“mon”)); 26 27 assertequals(tuesday, stringtoweekdaycode(“tuesday”)); 28 assertequals(tuesday, stringtoweekdaycode(“tue”)); 29 // assertequals(tuesday,stringtoweekdaycode(“tuesday”)); 30 // assertequals(tuesday,stringtoweekdaycode(“tuesday”)); 31 // assertequals(tuesday, stringtoweekdaycode(“tue”)); 32 // assertequals(tuesday, stringtoweekdaycode(“tues”)); 33 34 assertequals(wednesday, stringtoweekdaycode (“wednesday”)); 35 assertequals(wednesday, stringtoweekdaycode(“wed”)); 36 // assertequals(wednesday,stringtoweekdaycode(“wednesday”)); 37 // assertequals(wednesday,stringtoweekdaycode(“wednesday”)); 38 // assertequals(wednesday, stringtoweekdaycode(“wed”)); 39 40 assertequals(thursday, stringtoweekdaycode(“thursday”)); 41 assertequals(thursday, stringtoweekdaycode(“thu”)); 42 // assertequals(thursday,stringtoweekdaycode(“thursday”)); 43 // assertequals(thursday,stringtoweekdaycode(“thursday”)); 44 // assertequals(thursday, stringtoweekdaycode(“thu”)); 45 // assertequals(thursday, stringtoweekdaycode(“thurs”)); 46 47 assertequals(friday, stringtoweekdaycode(“friday”)); 48 assertequals(friday, stringtoweekdaycode(“fri”)); 49 // assertequals(friday,stringtoweekdaycode(“friday”)); 50 // assertequals(friday,stringtoweekdaycode(“friday”)); 51 // assertequals(friday, stringtoweekdaycode(“fri”)); 52 53 assertequals(saturday, stringtoweekdaycode(“saturday”)); 54 assertequals(saturday, stringtoweekdaycode(“sat”)); 55 // assertequals(saturday,stringtoweekdaycode(“saturday”)); 56 // assertequals(saturday,stringtoweekdaycode(“saturday”)); 57 // assertequals(saturday, stringtoweekdaycode(“sat”)); 58 59 assertequals(sunday, stringtoweekdaycode(“sunday”)); 60 assertequals(sunday, stringtoweekdaycode(“sun”)); 61 // assertequals(sunday,stringtoweekdaycode(“sunday”)); 62 // assertequals(sunday,stringtoweekdaycode(“sunday”)); 63 // assertequals(sunday, stringtoweekdaycode(“sun”)); 64 } 65 66 public void testweekdaycodetostring() throws exception { 47367 assertequals(“sunday”, weekdaycodetostring(sunday)); 68 assertequals(“monday”, weekdaycodetostring(monday)); 69 assertequals(“tuesday”, weekdaycodetostring(tuesday)); 70 assertequals(“wednesday”, weekdaycodetostring(wednesday)); 71 assertequals(“thursday”, weekdaycodetostring(thursday)); 72 assertequals(“friday”, weekdaycodetostring(friday)); 73 assertequals(“saturday”, weekdaycodetostring(saturday)); 74 } 75 76 public void testisvalidmonthcode() throws exception { 77 for (int i = 1; i <= 12; i++) 78 asserttrue(isvalidmonthcode(i)); 79 assertfalse(isvalidmonthcode(0)); 80 assertfalse(isvalidmonthcode(13)); 81 } 82 83 public void testmonthtoquarter() throws exception { 84 assertequals(1, monthcodetoquarter(january)); 85 assertequals(1, monthcodetoquarter(february)); 86 assertequals(1, monthcodetoquarter(march)); 87 assertequals(2, monthcodetoquarter(april)); 88 assertequals(2, monthcodetoquarter(may)); 89 assertequals(2, monthcodetoquarter(june)); 90 assertequals(3, monthcodetoquarter(july)); 91 assertequals(3, monthcodetoquarter(august)); 92 assertequals(3, monthcodetoquarter(september)); 93 assertequals(4, monthcodetoquarter(october)); 94 assertequals(4, monthcodetoquarter(november)); 95 assertequals(4, monthcodetoquarter(december)); 96 97 try { 98 monthcodetoquarter(-1); 99 fail(“invalid month code should throw exception”); 100 } catch (illegalargumentexception e) { 101 } 102 } 103 104 public void testmonthcodetostring() throws exception { 105 assertequals(“january”, monthcodetostring(january)); 106 assertequals(“february”, monthcodetostring(february)); 107 assertequals(“march”, monthcodetostring(march)); 108 assertequals(“april”, monthcodetostring(april)); 109 assertequals(“may”, monthcodetostring(may)); 110 assertequals(“june”, monthcodetostring(june)); 111 assertequals(“july”, monthcodetostring(july)); 474112 assertequals(“august”, monthcodetostring(august)); 113 assertequals(“september”, monthcodetostring(september)); 114 assertequals(“october”, monthcodetostring(october)); 115 assertequals(“november”, monthcodetostring(november)); 116 assertequals(“december”, monthcodetostring(december)); 117 118 assertequals(“jan”, monthcodetostring(january, true)); 119 assertequals(“feb”, monthcodetostring(february, true)); 120 assertequals(“mar”, monthcodetostring(march, true)); 121 assertequals(“apr”, monthcodetostring(april, true)); 122 assertequals(“may”, monthcodetostring(may, true)); 123 assertequals(“jun”, monthcodetostring(june, true)); 124 assertequals(“jul”, monthcodetostring(july, true)); 125 assertequals(“aug”, monthcodetostring(august, true)); 126 assertequals(“sep”, monthcodetostring(september, true)); 127 assertequals(“oct”, monthcodetostring(october, true)); 128 assertequals(“nov”, monthcodetostring(november, true)); 129 assertequals(“dec”, monthcodetostring(december, true)); 130 131 try { 132 monthcodetostring(-1); 133 fail(“invalid month code should throw exception”); 134 } catch (illegalargumentexception e) { 135 } 136 137 } 138 139 public void teststringtomonthcode() throws exception { 140 assertequals(january,stringtomonthcode(“1”)); 141 assertequals(february,stringtomonthcode(“2”)); 142 assertequals(march,stringtomonthcode(“3”)); 143 assertequals(april,stringtomonthcode(“4”)); 144 assertequals(may,stringtomonthcode(“5”)); 145 assertequals(june,stringtomonthcode(“6”)); 146 assertequals(july,stringtomonthcode(“7”)); 147 assertequals(august,stringtomonthcode(“8”)); 148 assertequals(september,stringtomonthcode(“9”)); 149 assertequals(october,stringtomonthcode(“10”)); 150 assertequals(november, stringtomonthcode(“11”)); 151 assertequals(december,stringtomonthcode(“12”)); 152 153 //todo assertequals(-1, stringtomonthcode(“0”)); 154 // assertequals(-1, stringtomonthcode(“13”)); 155 156 assertequals(-1,stringtomonthcode(“hello”)); 475157 158 for (int m = 1; m <= 12; m++) { 159 assertequals(m, stringtomonthcode(monthcodetostring(m, false))); 160 assertequals(m, stringtomonthcode(monthcodetostring(m, true))); 161 } 162 163 // assertequals(1,stringtomonthcode(“jan”)); 164 // assertequals(2,stringtomonthcode(“feb”)); 165 // assertequals(3,stringtomonthcode(“mar”)); 166 // assertequals(4,stringtomonthcode(“apr”)); 167 // assertequals(5,stringtomonthcode(“may”)); 168 // assertequals(6,stringtomonthcode(“jun”)); 169 // assertequals(7,stringtomonthcode(“jul”)); 170 // assertequals(8,stringtomonthcode(“aug”)); 171 // assertequals(9,stringtomonthcode(“sep”)); 172 // assertequals(10,stringtomonthcode(“oct”)); 173 // assertequals(11,stringtomonthcode(“nov”)); 174 // assertequals(12,stringtomonthcode(“dec”)); 175 176 // assertequals(1,stringtomonthcode(“jan”)); 177 // assertequals(2,stringtomonthcode(“feb”)); 178 // assertequals(3,stringtomonthcode(“mar”)); 179 // assertequals(4,stringtomonthcode(“apr”)); 180 // assertequals(5,stringtomonthcode(“may”)); 181 // assertequals(6,stringtomonthcode(“jun”)); 182 // assertequals(7,stringtomonthcode(“jul”)); 183 // assertequals(8,stringtomonthcode(“aug”)); 184 // assertequals(9,stringtomonthcode(“sep”)); 185 // assertequals(10,stringtomonthcode(“oct”)); 186 // assertequals(11,stringtomonthcode(“nov”)); 187 // assertequals(12,stringtomonthcode(“dec”)); 188 189 // assertequals(1,stringtomonthcode(“january”)); 190 // assertequals(2,stringtomonthcode(“february”)); 191 // assertequals(3,stringtomonthcode(“march”)); 192 // assertequals(4,stringtomonthcode(“april”)); 193 // assertequals(5,stringtomonthcode(“may”)); 194 // assertequals(6,stringtomonthcode(“june”)); 195 // assertequals(7,stringtomonthcode(“july”)); 196 // assertequals(8,stringtomonthcode(“august”)); 197 // assertequals(9,stringtomonthcode(“september”)); 198 // assertequals(10,stringtomonthcode(“october”)); 199 // assertequals(11,stringtomonthcode(“november”)); 200 // assertequals(12,stringtomonthcode(“december”)); 201 476202 // assertequals(1,stringtomonthcode(“january”)); 203 // assertequals(2,stringtomonthcode(“february”)); 204 // assertequals(3,stringtomonthcode(“mar”)); 205 // assertequals(4,stringtomonthcode(“april”)); 206 // assertequals(5,stringtomonthcode(“may”)); 207 // assertequals(6,stringtomonthcode(“june”)); 208 // assertequals(7,stringtomonthcode(“july”)); 209 // assertequals(8,stringtomonthcode(“august”)); 210 // assertequals(9,stringtomonthcode(“september”)); 211 // assertequals(10,stringtomonthcode(“october”)); 212 // assertequals(11,stringtomonthcode(“november”)); 213 // assertequals(12,stringtomonthcode(“december”)); 214 } 215 216 public void testisvalidweekinmonthcode() throws exception { 217 for (int w = 0; w <= 4; w++) { 218 asserttrue(isvalidweekinmonthcode(w)); 219 } 220 assertfalse(isvalidweekinmonthcode(5)); 221 } 222 223 public void testisleapyear() throws exception { 224 assertfalse(isleapyear(1900)); 225 assertfalse(isleapyear(1901)); 226 assertfalse(isleapyear(1902)); 227 assertfalse(isleapyear(1903)); 228 asserttrue(isleapyear(1904)); 229 asserttrue(isleapyear(1908)); 230 assertfalse(isleapyear(1955)); 231 asserttrue(isleapyear(1964)); 232 asserttrue(isleapyear(1980)); 233 asserttrue(isleapyear(2000)); 234 assertfalse(isleapyear(2001)); 235 assertfalse(isleapyear(2100)); 236 } 237 238 public void testleapyearcount() throws exception { 239 assertequals(0, leapyearcount(1900)); 240 assertequals(0, leapyearcount(1901)); 241 assertequals(0, leapyearcount(1902)); 242 assertequals(0, leapyearcount(1903)); 243 assertequals(1, leapyearcount(1904)); 244 assertequals(1, leapyearcount(1905)); 245 assertequals(1, leapyearcount(1906)); 246 assertequals(1, leapyearcount(1907)); 477247 assertequals(2, leapyearcount(1908)); 248 assertequals(24, leapyearcount(1999)); 249 assertequals(25, leapyearcount(2001)); 250 assertequals(49, leapyearcount(2101)); 251 assertequals(73, leapyearcount(2201)); 252 assertequals(97, leapyearcount(2301)); 253 assertequals(122, leapyearcount(2401)); 254 } 255 256 public void testlastdayofmonth() throws exception { 257 assertequals(31, lastdayofmonth(january, 1901)); 258 assertequals(28, lastdayofmonth(february, 1901)); 259 assertequals(31, lastdayofmonth(march, 1901)); 260 assertequals(30, lastdayofmonth(april, 1901)); 261 assertequals(31, lastdayofmonth(may, 1901)); 262 assertequals(30, lastdayofmonth(june, 1901)); 263 assertequals(31, lastdayofmonth(july, 1901)); 264 assertequals(31, lastdayofmonth(august, 1901)); 265 assertequals(30, lastdayofmonth(september, 1901)); 266 assertequals(31, lastdayofmonth(october, 1901)); 267 assertequals(30, lastdayofmonth(november, 1901)); 268 assertequals(31, lastdayofmonth(december, 1901)); 269 assertequals(29, lastdayofmonth(february, 1904)); 270 } 271 272 public void testadddays() throws exception { 273 serialdate newyears = d(1, january, 1900); 274 assertequals(d(2, january, 1900), adddays(1, newyears)); 275 assertequals(d(1, february, 1900), adddays(31, newyears)); 276 assertequals(d(1, january, 1901), adddays(365, newyears)); 277 assertequals(d(31, december, 1904), adddays(5 * 365, newyears)); 278 } 279 280 private static spreadsheetdate d(int day, int month, int year) { return new spreadsheetdate(day, month, year); } 281 282 public void testaddmonths() throws exception { 283 assertequals(d(1, february, 1900), addmonths(1, d(1, january, 1900))); 284 assertequals(d(28, february, 1900), addmonths(1, d(31, january, 1900))); 285 assertequals(d(28, february, 1900), addmonths(1, d(30, january, 1900))); 286 assertequals(d(28, february, 1900), addmonths(1, d(29, january, 1900))); 287 assertequals(d(28, february, 1900), addmonths(1, d(28, january, 4781900))); 288 assertequals(d(27, february, 1900), addmonths(1, d(27, january, 1900))); 289 290 assertequals(d(30, june, 1900), addmonths(5, d(31, january, 1900))); 291 assertequals(d(30, june, 1901), addmonths(17, d(31, january, 1900))); 292 293 assertequals(d(29, february, 1904), addmonths(49, d(31, january, 1900))); 294 295 } 296 297 public void testaddyears() throws exception { 298 assertequals(d(1, january, 1901), addyears(1, d(1, january, 1900))); 299 assertequals(d(28, february, 1905), addyears(1, d(29, february, 1904))); 300 assertequals(d(28, february, 1905), addyears(1, d(28, february, 1904))); 301 assertequals(d(28, february, 1904), addyears(1, d(28, february, 1903))); 302 } 303 304 public void testgetpreviousdayofweek() throws exception { 305 assertequals(d(24, february, 2006), getpreviousdayofweek(friday, d(1, march, 2006))); 306 assertequals(d(22, february, 2006), getpreviousdayofweek(wednesday, d(1, march, 2006))); 307 assertequals(d(29, february, 2004), getpreviousdayofweek(sunday, d(3, march, 2004))); 308 assertequals(d(29, december, 2004), getpreviousdayofweek(wednesday, d(5, january, 2005))); 309 310 try { 311 getpreviousdayofweek(-1, d(1, january, 2006)); 312 fail(“invalid day of week code should throw exception”); 313 } catch (illegalargumentexception e) { 314 } 315 } 316 317 public void testgetfollowingdayofweek() throws exception { 318 // assertequals(d(1, january, 2005),getfollowingdayofweek(saturday, d(25, december, 2004))); 319 assertequals(d(1, january, 2005), getfollowingdayofweek(saturday, d(26, december, 2004))); 320 assertequals(d(3, march, 2004), getfollowingdayofweek(wednesday, d(28, february, 2004))); 321 479322 try { 323 getfollowingdayofweek(-1, d(1, january, 2006)); 324 fail(“invalid day of week code should throw exception”); 325 } catch (illegalargumentexception e) { 326 } 327 } 328 329 public void testgetnearestdayofweek() throws exception { 330 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(16, april, 2006))); 331 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(17, april, 2006))); 332 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(18, april, 2006))); 333 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(19, april, 2006))); 334 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(20, april, 2006))); 335 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(21, april, 2006))); 336 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(22, april, 2006))); 337 338 //todo assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(16, april, 2006))); 339 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(17, april, 2006))); 340 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(18, april, 2006))); 341 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(19, april, 2006))); 342 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(20, april, 2006))); 343 assertequals(d(24, april, 2006), getnearestdayofweek(monday, d(21, april, 2006))); 344 assertequals(d(24, april, 2006), getnearestdayofweek(monday, d(22, april, 2006))); 345 346 // assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(16, april, 2006))); 347 // assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(17, april, 2006))); 348 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(18, april, 2006))); 349 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(19, april, 2006))); 350 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(20, april, 2006))); 351 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(21, 480april, 2006))); 352 assertequals(d(25, april, 2006), getnearestdayofweek(tuesday, d(22, april, 2006))); 353 354 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(16, april, 2006))); 355 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(17, april, 2006))); 356 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(18, april, 2006))); 357 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(19, april, 2006))); 358 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(20, april, 2006))); 359 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(21, april, 2006))); 360 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(22, april, 2006))); 361 362 // assertequals(d(13, april, 2006), getnearestdayofweek(thursday, d(16, april, 2006))); 363 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(17, april, 2006))); 364 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(18, april, 2006))); 365 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(19, april, 2006))); 366 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(20, april, 2006))); 367 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(21, april, 2006))); 368 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(22, april, 2006))); 369 370 // assertequals(d(14, april, 2006), getnearestdayofweek(friday, d(16, april, 2006))); 371 // assertequals(d(14, april, 2006), getnearestdayofweek(friday, d(17, april, 2006))); 372 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(18, april, 2006))); 373 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(19, april, 2006))); 374 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(20, april, 2006))); 375 assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(21, april, 2006))); 376 assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(22, april, 2006))); 377 378 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(16, 481april, 2006))); 379 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(17, april, 2006))); 380 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(18, april, 2006))); 381 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(19, april, 2006))); 382 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(20, april, 2006))); 383 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(21, april, 2006))); 384 assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(22, april, 2006))); 385 386 try { 387 getnearestdayofweek(-1, d(1, january, 2006)); 388 fail(“invalid day of week code should throw exception”); 389 } catch (illegalargumentexception e) { 390 } 391 } 392 393 public void testendofcurrentmonth() throws exception { 394 serialdate d = serialdate.createinstance(2); 395 assertequals(d(31, january, 2006), d.getendofcurrentmonth(d(1, january, 2006))); 396 assertequals(d(28, february, 2006), d.getendofcurrentmonth(d(1, february, 2006))); 397 assertequals(d(31, march, 2006), d.getendofcurrentmonth(d(1, march, 2006))); 398 assertequals(d(30, april, 2006), d.getendofcurrentmonth(d(1, april, 2006))); 399 assertequals(d(31, may, 2006), d.getendofcurrentmonth(d(1, may, 2006))); 400 assertequals(d(30, june, 2006), d.getendofcurrentmonth(d(1, june, 2006))); 401 assertequals(d(31, july, 2006), d.getendofcurrentmonth(d(1, july, 2006))); 402 assertequals(d(31, august, 2006), d.getendofcurrentmonth(d(1, august, 2006))); 403 assertequals(d(30, september, 2006), d.getendofcurrentmonth(d(1, september, 2006))); 404 assertequals(d(31, october, 2006), d.getendofcurrentmonth(d(1, october, 2006))); 405 assertequals(d(30, november, 2006), d.getendofcurrentmonth(d(1, november, 2006))); 406 assertequals(d(31, december, 2006), d.getendofcurrentmonth(d(1, december, 2006))); 407 assertequals(d(29, february, 2008), d.getendofcurrentmonth(d(1, february, 2008))); 482408 } 409 410 public void testweekinmonthtostring() throws exception { 411 assertequals(“first”,weekinmonthtostring(first_week_in_month)); 412 assertequals(“second”,weekinmonthtostring(second_week_in_month)); 413 assertequals(“third”,weekinmonthtostring(third_week_in_month)); 414 assertequals(“fourth”,weekinmonthtostring(fourth_week_in_month)); 415 assertequals(“last”,weekinmonthtostring(last_week_in_month)); 416 417 //todo try { 418 // weekinmonthtostring(-1); 419 // fail(“invalid week code should throw exception”); 420 // } catch (illegalargumentexception e) { 421 // } 422 } 423 424 public void testrelativetostring() throws exception { 425 assertequals(“preceding”,relativetostring(preceding)); 426 assertequals(“nearest”,relativetostring(nearest)); 427 assertequals(“following”,relativetostring(following)); 428 429 //todo try { 430 // relativetostring(-1000); 431 // fail(“invalid relative code should throw exception”); 432 // } catch (illegalargumentexception e) { 433 // } 434 } 435 436 public void testcreateinstancefromddmmyyyy() throws exception { 437 serialdate date = createinstance(1, january, 1900); 438 assertequals(1,date.getdayofmonth()); 439 assertequals(january,date.getmonth()); 440 assertequals(1900,date.getyyyy()); 441 assertequals(2,date.toserial()); 442 } 443 444 public void testcreateinstancefromserial() throws exception { 445 assertequals(d(1, january, 1900),createinstance(2)); 446 assertequals(d(1, january, 1901), createinstance(367)); 447 } 448 449 public void testcreateinstancefromjavadate() throws exception { 450 assertequals(d(1, january, 1900), createinstance(new gregoriancalendar(1900,0,1).gettime())); 451 assertequals(d(1, january, 2006), 483createinstance(new gregoriancalendar(2006,0,1).gettime())); 452 } 453 454 public static void main(string[] args) { 455 junit.textui.testrunner.run(bobsserialdatetest.class); 456 } 457 } 484listado b-5 spreadsheetdate.java. 1 /* ============================================================= 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * -------------------------- 28 * spreadsheetdate.java 29 * -------------------------- 30 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 31 * 32 * autor original: david gilbert (por object refinery limited); 33 * colaboradores(s): -; 34 * 35 * $id: speadsheetdate.java,v 1.8 2005/11/03 09:25:39 mungady exp $ 36 * 37 * cambios 38 * ---------- 39 * 11-oct-2001 : version 1 (dg); 48540 * 05-nov-2001 : se añaden los métodos getdescription() y setdescription() (dg); 41 * 12-nov-2001 : se cambia el nombre exceldate.java por spreadsheetdate.java (dg); 42 * se corrige un error a la hora de calcular el día, mes y año a 43 * partir del número de serie (dg); 44 * 24-jan-2002 : se corrige un error a la hora de calcular el número de serie a 45 * partir del día, mes y año. gracias a trevor kills por el informe (dg); 46 * 29-may-2002 : se añade el método equals(object) (sourceforge id 558850) (dg); 47 * 03-oct-2002 : se corrigen los errores detectados por checkstyle (dg); 48 * 13-mar-2003 : implementación de serializable (dg); 49 * 04-sep-2003 : métodos isinrange() completados (dg); 50 * 05-sep-2003 : implementación de comparable (dg); 51 * 21-oct-2003 : se añade el método hashcode() (dg); 52 * 53 /* 54 55 package org.jfree.date; 56 57 import java.util.calendar; 58 import java.util.date; 59 /** 60 61 * representa una con un entero, de forma similar a la 62 * implementación en microsoft excel. el intervalo de fechas admitido es 63 * 1-ene-1900 a 31-dic-9999. 64 * <p> 65 * recuerde que excel tiene un error que reconoce el año 66 * 1900 como bisiesto cuando en realidad no lo es. encontrará más 67 * información en el sitio web de microsoft, en el artículo q181370: 68 * <p> 69 * http://support.microsoft.com/support/kb/articles/q181/3/70.asp 70 * <p> 71 * excel usa como convención que el 1-ene-1900 = 1. esta clase usa la 72 * convención de que 1-ene-1900 = 2. 73 * como resultado, el número de día de esta clase será diferente al de 74 * excel para enero y febrero de 1900… pero excel añade un día 75 * más (29-feb-1900 que en realidad no existe) y a partir de ahí 76 * los números de los días coinciden. 77 * 78 * @author david gilbert 79 */ 80 public class spreadsheetdate extends serialdate { 81 48682 /** para serialización. */ 83 private static final long serialversionuid = -2039586705374454461l; 84 85 /** 86 * el número de día (1-ene-1900 = 2, 2-ene-1900 = 3…, 31-dic-9999 = 87 * 2958465). 88 */ 89 private int serial; 90 91 /** el día del mes (de 1 a 28, 29, 30 o 31 en función del mes). */ 92 private int day; 93 94 /** el mes del año (de 1 a 12). */ 95 private int month; 96 97 /** el año (de 1900 a 9999). */ 98 private int year; 99 100 /** una descripción opcional para la fecha. */ 101 private string description; 102 103 /** 104 * crear una nueva instancia de la fecha. 105 * 106 * @param day el día (entre 1 y 28/29/30/31). 107 * @param month el mes (entre 1 y 12). 108 * @param year el año (entre 1900 y 9999). 109 */ 110 public spreadsheetdate(final int day, final int month, final int year) { 111 112 if ((year >= 1900) && (year <= 9999)) { 113 this.year = year; 114 } 115 else { 116 throw new illegalargumentexception( 117 “the ‘year’ argument must be in range 1900 to 9999.” 118 ); 119 } 120 121 if ((month >= monthconstants.january) 122 && (month <= monthconstants.december)) { 123 this.month = month; 124 } 125 else { 487126 throw new illegalargumentexception( 127 “the ‘month’ argument must be in the range 1 to 12.” 128 ); 129 } 130 131 if ((day >= 1) && (day <= serialdate.lastdayofmonth(month, year))) { 132 this.day = day; 133 } 134 else { 135 throw new illegalargumentexception(“invalid ‘day’ argument.”); 136 } 137 138 // es necesario sincronizar el número de serie con el día-mes-año… 139 this.serial = calcserial(day, month, year); 140 141 this.description = null; 142 143 } 144 145 /** 146 * constructor estándar: crear un nuevo objeto de fecha que representa el 147 * número de día especificado (que debe estar comprendido entre 2 y 2958465). 148 * 149 * @param serial número de serie para el día (entre 2 y 2958465). 150 */ 151 public spreadsheetdate(final int serial) { 152 153 if ((serial >= serial_lower_bound) && (serial <= serial_upper_bound)) { 154 this.serial = serial; 155 } 156 else { 157 throw new illegalargumentexception( 158 “spreadsheetdate: serial must be in range 2 to 2958465.”); 159 } 160 161 // el día-mes-año debe estar sincronizado con el número de serie… 162 calcdaymonthyear(); 163 164 } 165 166 /** 167 * devuelve la descripción adjuntada a la fecha. no es 168 * obligatorio que la fecha tenga una descripción, pero resulta útil 488169 * en algunas aplicaciones. 170 * 171 * @return la descripción adjuntada a la fecha. 172 */ 173 public string getdescription() { 174 return this.description; 175 } 176 177 /** 178 * establece la descripción de la fecha. 179 * 180 * @param description la descripción de esta fecha (<code>null</code> 181 * se permite) 182 */ 183 public void setdescription(final string description) { 184 this.description = description; 185 } 186 187 /** 188 * devuelve el número de serie de la fecha, siendo el 1 de enero 1900 = 2 189 * (se corresponde, casi totalmente, al sistema de numeración empleado en 190 * microsoft excel para windows y lotus 1-2-3). 191 * 192 * @return el número de serie de la fecha. 193 */ 194 public int toserial() { 195 return this.serial; 196 } 197 198 /** 199 * devuelve una <code>java.util.date</code> equivalente a esta fecha. 200 * 201 * @return la fecha. 202 */ 203 public date todate() { 204 final calendar calendar = calendar.getinstance(); 205 calendar.set(getyyyy(), getmonth() - 1, getdayofmonth(), 0, 0, 0); 206 return calendar.gettime(); 207 } 208 209 /** 210 * devuelve el año (con un intervalo válido de 1900 a 9999). 211 * 212 * @return el año. 489213 */ 214 public int getyyyy() { 215 return this.year; 216 } 217 218 /** 219 * devuelve el mes (enero = 1, febrero = 2, marzo = 3). 220 * 221 * @return el mes del año. 222 */ 223 public int getmonth() { 224 return this.month; 225 } 226 227 /** 228 * devuelve el día del mes. 229 * 230 * @return el día del mes. 231 */ 232 public int getdayofmonth() { 233 return this.day; 234 } 235 236 /** 237 * devuelve un código que representa el día de la semana. 238 * <p> 239 * los códigos se definen en la clase {@link serialdate} como: 240 * <code>sunday</code>, <code>monday</code>, <code>tuesday</code>, 241 * <code>wednesday</code>, <code>thursday</code>, <code>friday</code>, y 242 * <code>saturday</code>. 243 * 244 * @return un código que representa el día de la semana. 245 */ 246 public int getdayofweek() { 247 return (this.serial + 6) % 7 + 1; 248 } 249 250 /** 251 * prueba la igualdad de esta fecha con un objeto arbitrario. 252 * <p> 253 * este método sólo devuelve true si el objeto es una instancia de la 254 * clase base {@link serialdate} y representa el mismo día que 255 * {@link spreadsheetdate}. 256 * 490257 * @param object el objeto que comparar (se permite <code>null</code>). 258 * 259 * @return un valor booleano. 260 */ 261 public boolean equals(final object object) { 262 263 if (object instanceof serialdate) { 264 final serialdate s = (serialdate) object; 265 return (s.toserial() == this.toserial()); 266 } 267 else { 268 return false; 269 } 270 271 } 272 273 /** 274 * devuelve un código hash para la instancia de este objeto. 275 * 276 * @return un código hash. 277 */ 278 public int hashcode() { 279 return toserial(); 280 } 281 282 /** 283 * devuelve la diferencia (en días) entre esta fecha y la 284 * ‘otra’ fecha especificada. 285 * 286 * @param other la fecha con la que se compara. 287 * 288 * @return la diferencia (en días) entre esta fecha y la 289 * otra’ fecha especificada. 290 */ 291 public int compare(final serialdate other) { 292 return this.serial – other.toserial(); 293 } 294 295 /** 296 * implementa el método necesario para la interfaz comparable. 297 * 298 * @param other el otro objeto (normalmente otro serialdate). 299 * 300 * @return un entero negativo, cero o un entero positivo si este objeto 301 * es menor que, igual o mayor que el objeto especificado. 491302 */ 303 public int compareto(final object other) { 304 return compare((serialdate) other); 305 } 306 307 /** 308 * devuelve true si esta serialdate representa la misma fecha que la 309 * serialdate especificada. 310 * 311 * @param other la fecha con la que se compara. 312 * 313 * @return <code>true</code> si esta serialdate representa la misma fecha que 314 * la otra serialdate especificada. 315 */ 316 public boolean ison(final serialdate other) { 317 return (this.serial == other.toserial()); 318 } 319 320 /** 321 * devuelve true si esta serialdate representa una fecha anterior a 322 * la serialdate especificada. 323 * 324 * @param other la fecha con la que se compara. 325 * 326 * @return <code>true</code> si esta serialdate representa una fecha anterior a 327 * la serialdate especificada. 328 */ 329 public boolean isbefore(final serialdate other) { 330 return (this.serial < other.toserial()); 331 } 332 333 /** 334 * devuelve true si esta serialdate representa la misma fecha que la 335 * serialdate especificada. 336 * 337 * @param other la fecha con la que se compara. 338 * 339 * @return <code>true</code> si esta serialdate representa la misma fecha 340 * que la serialdate especificada. 341 */ 342 public boolean isonorbefore(final serialdate other) { 343 return (this.serial <= other.toserial()); 344 } 492345 346 /** 347 * devuelve true si esta serialdate representa la misma fecha que la 348 * serialdate especificada. 349 * 350 * @param other la fecha con la que se compara. 351 * 352 * @return <code>true</code> si esta serialdate representa la misma fecha 353 * que la serialdate especificada. 354 */ 355 public boolean isafter(final serialdate other) { 356 return (this.serial > other.toserial()); 357 } 358 359 /** 360 * devuelve true si esta serialdate representa la misma fecha que la 361 * serialdate especificada. 362 * 363 * @param other la fecha con la que se compara. 364 * 365 * @return <code>true</code> si esta serialdate representa la misma fecha 366 * que la serialdate especificada. 367 */ 368 public boolean isonorafter(final serialdate other) { 369 return (this.serial >= other.toserial()); 370 } 371 372 /** 373 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 374 * intervalo especificado (inclusive). el orden de fecha de d1 y d2 no es 375 * importante. 376 * 377 * @param d1 una fecha límite para el rango. 378 * @param d2 la otra fecha límite para el rango. 379 * 380 * @return un valor booleano. 381 */ 382 public boolean isinrange(final serialdate d1, final serialdate d2) { 383 return isinrange(d1, d2, serialdate.include_both); 384 } 385 386 /** 387 * devuelve true si esta serialdate se encuentra en el intervalo 493especificado 388 * (el invocador especifica si los puntos finales se incluyen o no). el orden 389 * de d1 y d2 no es importante. 390 * 391 * @param d1 una fecha límite para el rango. 392 * @param d2 la otra fecha límite para el rango. 393 * @param include un código que controla si la fecha inicial y final 394 * se incluyen en el intervalo. 395 * 396 * @return <code>true</code> si esta serialdate se encuentra en el intervalo 397 * especificado. 398 */ 399 public boolean isinrange(final serialdate d1, final serialdate d2, 400 final int include) { 401 final int s1 = d1.toserial(); 402 final int s2 = d2.toserial(); 403 final int start = math.min(s1, s2); 404 final int end = math.max(s1, s2); 405 406 final int s = toserial(); 407 if (include == serialdate.include_both) { 408 return (s >= start && s <= end); 409 } 410 else if (include == serialdate.include_first) { 411 return (s >= start && s < end); 412 } 413 else if (include == serialdate.include_second) { 414 return (s > start && s <= end); 415 } 416 else { 417 return (s > start && s < end); 418 } 419 } 420 421 /** 422 * calcular el número de serie a partir del día, mes y año. 423 * <p> 424 * 1-ene-1900 = 2. 425 * 426 * @param d el día. 427 * @param m el mes. 428 * @param y el año. 429 * 430 * @return el número de serie a partir del día, mes y año. 494431 */ 432 private int calcserial(final int d, final int m, final int y) { 433 final int yy = ((y - 1900) * 365) + serialdate.leapyearcount(y - 1); 434 int mm = serialdate.aggregate_days_to_end_of_preceding_month[m]; 435 if (m > monthconstants.february) { 436 if (serialdate.isleapyear(y)) { 437 mm = mm + 1; 438 } 439 } 440 final int dd = d; 441 return yy + mm + dd + 1; 442 } 443 444 /** 445 * calcular el día, mes y año a partir del número de serie. 446 */ 447 private void calcdaymonthyear() { 448 449 // obtener el año a partir del número de serie de la fecha 450 final int days = this.serial - serial_lower_bound; 451 // sobrevalorado ya que ignoramos los días bisiestos 452 final int overestimatedyyyy = 1900 + (days / 365); 453 final int leaps = serialdate.leapyearcount(overestimatedyyyy); 454 final int nonleapdays = days - leaps; 455 // subestimado ya que sobrevaloramos los años 456 int underestimatedyyyy = 1900 + (nonleapdays / 365); 457 458 if (underestimatedyyyy == overestimatedyyyy) { 459 this.year = underestimatedyyyy; 460 } 461 else { 462 int ss1 = calcserial(1, 1, underestimatedyyyy); 463 while (ss1 <= this.serial) { 464 underestimatedyyyy = underestimatedyyyy + 1; 465 ss1 = calcserial(1, 1, underestimatedyyyy); 466 } 467 this.year = underestimatedyyyy - 1; 468 } 469 470 final int ss2 = calcserial(1, 1, this.year); 471 472 int[] daystoendofprecedingmonth 473 = aggregate_days_to_end_of_preceding_month; 474 475 if (isleapyear(this.year)) { 495476 daystoendofprecedingmonth 477 = leap_year_aggregate_days_to_end_of_preceding_month; 478 } 479 480 // get the month from the serial date 481 int mm = 1; 482 int sss = ss2 + daystoendofprecedingmonth[mm] - 1; 483 while (sss < this.serial) { 484 mm = mm + 1; 485 sss = ss2 + daystoendofprecedingmonth[mm] - 1; 486 } 487 this.month = mm - 1; 488 489 // el resto es d(+1); 490 this.day = this.serial - ss2 491 - daystoendofprecedingmonth[this.month] + 1; 492 493 } 494 495 } listado b-6 relativedayofweekrule.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 49619 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * -------------------------- 28 * relativedayofweekrule.java 29 * -------------------------- 30 * (c) copyright 2000-2003, de object refinery limited y colaboradores. 31 * 32 * autor original: david gilbert (por object refinery limited); 33 * colaboradores(s): -; 34 * 35 * $id: relativedayofweekrule.java,v 1.6 2005/11/16 15:58:40 taqua exp $ 36 * 37 * cambios (26-oct-2001) 38 * -------------------------- 39 * 26-oct-2001 : se cambió el paquete por com.jrefinery.date.*; 40 * 03-oct-2002 : se corrigen los errores detectados por checkstyle (dg); 41 * 42 */ 43 44 package org.jfree.date; 45 46 /** 47 * una regla de fechas anuales que devuelve una fecha por cada año en función de 48 * (a) una regla de referencia; (b) un día de la semana y (c) un parámetro de 49 * selección (serialdate.preceding, serialdate.nearest, serialdate.following). 50 * <p> 51 * por ejemplo, el viernes santo se puede especificado ‘el viernes anterior al 52 * domingo de resurrección. 53 * 54 * @author david gilbert 55 */ 56 public class relativedayofweekrule extends annualdaterule { 57 58 /** una referencia a la regla de fechas anuales sobre la que se basa esta regla. */ 59 private annualdaterule subrule; 49760 61 /** 62 * el día de la semana (serialdate.monday, serialdate.tuesday, etc). 63 */ 64 private int dayofweek; 65 66 /** indica que día de la semana (preceding, nearest o following). */ 67 private int relative; 68 69 /** 70 * constructor predeterminado: genera una regla para el lunes siguiente al 1 de enero. 71 */ 72 public relativedayofweekrule() { 73 this(new dayandmonthrule(), serialdate.monday, serialdate.following); 74 } 75 76 /** 77 * constructor estándar: genera una regla en función de la subregla proporcionada. 78 * 79 * @param subrule la regla que determina la fecha de referencia. 80 * @param dayofweek el día de la semana relativo a la fecha de referencia. 81 * @param relative indica “qué” día de la semana (anterior, más próximo 82 * o posterior). 83 */ 84 public relativedayofweekrule(final annualdaterule subrule, 85 final int dayofweek, final int relative) { 86 this.subrule = subrule; 87 this.dayofweek = dayofweek; 88 this.relative = relative; 89 } 90 91 /** 92 * devuelve la subregla (también denominada regla de referencia). 93 * 94 * @return la regla de fechas anuales que determina la fecha de referencia para 95 * esta regla. 96 */ 97 public annualdaterule getsubrule() { 98 return this.subrule; 99 } 100 498101 /** 102 * establece la subregla. 103 * 104 * @param subrule la regla de fechas anuales que determina la fecha de 105 * referencia para esta regla. 106 */ 107 public void setsubrule(final annualdaterule subrule) { 108 this.subrule = subrule; 109 } 110 111 /** 112 * devuelve el día de la semana de esta regla. 113 * 114 * @return el día de la semana de esta regla. 115 */ 116 public int getdayofweek() { 117 return this.dayofweek; 118 } 119 120 /** 121 * establece el día de la semana de esta regla. 122 * 123 * @param dayofweek el día de la semana de (serialdate.monday, 124 * serialdate.tuesday, etc.). 125 */ 126 public void setdayofweek(final int dayofweek) { 127 this.dayofweek = dayofweek; 128 } 129 130 /** 131 * devuelve el atributo ‘relativo’ que determina “qué” 132 * día de la semana nos interesa (serialdate.preceding, 133 * serialdate.nearest o serialdate.following). 134 * 135 * @return el atributo ‘relativo’. 136 */ 137 public int getrelative() { 138 return this.relative; 139 } 140 141 /** 142 * establece el atributo ‘relativo’ (serialdate.preceding, serialdate.nearest, 143 * serialdate.following). 144 * 499145 * @param relative determina “qué” día de la semana se selecciona con esta 146 * regla. 147 */ 148 public void setrelative(final int relative) { 149 this.relative = relative; 150 } 151 152 /** 153 * crea un clon de esta regla. 154 * 155 * @return un clon de esta regla. 156 * 157 * @throws clonenotsupportedexception nunca debe producirse. 158 */ 159 public object clone() throws clonenotsupportedexception { 160 final relativedayofweekrule duplicate 161 = (relativedayofweekrule) super.clone(); 162 duplicate.subrule = (annualdaterule) duplicate.getsubrule().clone(); 163 return duplicate; 164 } 165 166 /** 167 * devuelve la fecha generada por esta regla, para el año especificado. 168 * 169 * @param year el año (1900 &lt;= year &lt;= 9999). 170 * 171 * @return la fecha generada por esta regla para un año concreto (posiblemente 172 * <code>null</code>). 173 */ 174 public serialdate getdate(final int year) { 175 176 // comprobar argumento… 177 if ((year < serialdate.minimum_year_supported) 178 || (year > serialdate.maximum_year_supported)) { 179 throw new illegalargumentexception( 180 “relativedayofweekrule.getdate(): year outside valid range.”); 181 } 182 183 // calcular la fecha… 184 serialdate result = null; 185 final serialdate base = this.subrule.getdate(year); 186 187 if (base != null) { 188 switch (this.relative) { 500189 case(serialdate.preceding): 190 result = serialdate.getpreviousdayofweek(this.dayofweek, 191 base); 192 break; 193 case(serialdate.nearest): 194 result = serialdate.getnearestdayofweek(this.dayofweek, 195 base); 196 break; 197 case(serialdate.following): 198 result = serialdate.getfollowingdayofweek(this.dayofweek, 199 base); 200 break; 201 default: 202 break; 203 } 204 } 205 return result; 206 207 } 208 209 } listado b-7 daydate.java (final) 1 /* ============================================================= 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. … 36 */ 37 package org.jfree.date; 38 39 import java.io.serializable; 40 import java.util.*; 41 42 /** 43 * una clase abstracta que representa fechas inmutables con una precisión de 44 * un día. la implementación asigna cada fecha a un entero que 45 * representa un número ordinal de días de un origen fijo. 46 * 47 * ¿por qué no usar java.útil.date? lo haremos, cuando tenga sentido. en ocasiones, 50148 * java.util.date puede ser demasiado precisa; representa un instante en el tiempo, 49 * con una precisión de 1/1000 de segundo (y la fecha depende de la 50 * zona horaria). en ocasiones solo querremos representar un día concreto (como el 21 51 * de enero de 2015) sin preocuparnos de la hora del día, la 52 * zona horaria u otros aspectos. para eso hemos definido serialdate. 53 * 54 * usar daydatefactory.makedate para crear una instancia. 55 * 56 * @author david gilbert 57 * @author robert c. martin realizó gran parte de la refactorización. 58 */ 59 60 public abstract class daydate implements comparable, serializable { 61 public abstract int getordinalday(); 62 public abstract int getyear(); 63 public abstract month getmonth(); 64 public abstract int getdayofmonth(); 65 66 protected abstract day getdayofweekforordinalzero(); 67 68 public daydate plusdays(int days) { 69 return daydatefactory.makedate(getordinalday() + days); 70 } 71 72 public daydate plusmonths(int months) { 73 int thismonthasordinal = getmonth().toint() - month.january.toint(); 74 int thismonthandyearasordinal = 12 * getyear() + thismonthasordinal; 75 int resultmonthandyearasordinal = thismonthandyearasordinal + months; 76 int resultyear = resultmonthandyearasordinal / 12; 77 int resultmonthasordinal = resultmonthandyearasordinal % 12 + month.january.toint(); 78 month resultmonth = month.fromint(resultmonthasordinal); 79 int resultday = correctlastdayofmonth(getdayofmonth(), resultmonth, resultyear); 80 return daydatefactory.makedate(resultday, resultmonth, resultyear); 81 } 82 83 public daydate plusyears(int years) { 84 int resultyear = getyear() + years; 85 int resultday = correctlastdayofmonth(getdayofmonth(), getmonth(), resultyear); 86 return daydatefactory.makedate(resultday, getmonth(), resultyear); 87 } 50288 89 private int correctlastdayofmonth(int day, month month, int year) { 90 int lastdayofmonth = dateutil.lastdayofmonth(month, year); 91 if (day > lastdayofmonth) 92 day = lastdayofmonth; 93 return day; 94 } 95 96 public daydate getpreviousdayofweek(day targetdayofweek) { 97 int offsettotarget = targetdayofweek.toint() - getdayofweek().toint(); 98 if (offsettotarget >= 0) 99 offsettotarget -= 7; 100 return plusdays(offsettotarget); 101 } 102 103 public daydate getfollowingdayofweek(day targetdayofweek) { 104 int offsettotarget = targetdayofweek.toint() - getdayofweek().toint(); 105 if (offsettotarget <= 0) 106 offsettotarget += 7; 107 return plusdays(offsettotarget); 108 } 109 110 public daydate getnearestdayofweek(day targetdayofweek) { 111 int offsettothisweekstarget = targetdayofweek.toint() - getdayofweek().toint(); 112 int offsettofuturetarget = (offsettothisweekstarget + 7) % 7; 113 int offsettoprevioustarget = offsettofuturetarget - 7; 114 115 if (offsettofuturetarget > 3) 116 return plusdays(offsettoprevioustarget); 117 else 118 return plusdays(offsettofuturetarget); 119 } 120 121 public daydate getendofmonth() { 122 month month = getmonth(); 123 int year = getyear(); 124 int lastday = dateutil.lastdayofmonth(month, year); 125 return daydatefactory.makedate(lastday, month, year); 126 } 127 128 public date todate() { 129 final calendar calendar = calendar.getinstance(); 130 int ordinalmonth = getmonth().toint() - month.january.toint(); 503131 calendar.set(getyear(), ordinalmonth, getdayofmonth(), 0, 0, 0); 132 return calendar.gettime(); 133 } 134 135 public string tostring() { 136 return string.format(“%02d-%s-%d”, getdayofmonth(), getmonth(), getyear()); 137 } 138 139 public day getdayofweek() { 140 day startingday = getdayofweekforordinalzero(); 141 int startingoffset = startingday.toint() - day.sunday.toint(); 142 int ordinalofdayofweek = (getordinalday() + startingoffset) % 7; 143 return day.fromint(ordinalofdayofweek + day.sunday.toint()); 144 } 145 146 public int dayssince(daydate date) { 147 return getordinalday() - date.getordinalday(); 148 } 149 150 public boolean ison(daydate other) { 151 return getordinalday() == other.getordinalday(); 152 } 153 154 public boolean isbefore(daydate other) { 155 return getordinalday() < other.getordinalday(); 156 } 157 158 public boolean isonorbefore(daydate other) { 159 return getordinalday() <= other.getordinalday(); 160 } 161 162 public boolean isafter(daydate other) { 163 return getordinalday() > other.getordinalday(); 164 } 165 166 public boolean isonorafter(daydate other) { 167 return getordinalday() >= other.getordinalday(); 168 } 169 170 public boolean isinrange(daydate d1, daydate d2) { 171 return isinrange(d1, d2, dateinterval.closed); 172 } 173 174 public boolean isinrange(daydate d1, daydate d2, dateinterval interval) { 504175 int left = math.min(d1.getordinalday(), d2.getordinalday()); 176 int right = math.max(d1.getordinalday(), d2.getordinalday()); 177 return interval.isin(getordinalday(), left, right); 178 } 179 } listado b-8 month.java (final) 1 package org.jfree.date; 2 3 import java.text.dateformatsymbols; 4 5 public enum month { 6 january(1), february(2), march(3), 7 april(4), may(5), june(6), 8 july(7), august(8), september(9), 9 october(10),november(11),december(12); 10 private static dateformatsymbols dateformatsymbols = new dateformatsymbols(); 11 private static final int[] last_day_of_month = 12 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 13 14 private int index; 15 16 month(int index) { 17 this.index = index; 18 } 19 20 public static month fromint(int monthindex) { 21 for (month m : month.values()) { 22 if (m.index == monthindex) 23 return m; 24 } 25 throw new illegalargumentexception(“invalid month index ” + monthindex); 26 } 27 28 public int lastday() { 29 return last_day_of_month[index]; 30 } 31 32 public int quarter() { 33 return 1 + (index - 1) / 3; 50534 } 35 36 public string tostring() { 37 return dateformatsymbols.getmonths()[index - 1]; 38 } 39 40 public string toshortstring() { 41 return dateformatsymbols.getshortmonths()[index - 1]; 42 } 43 44 public static month parse(string s) { 45 s = s.trim(); 46 for (month m : month.values()) 47 if (m.matches(s)) 48 return m; 49 50 try { 51 return fromint(integer.parseint(s)); 52 } 53 catch (numberformatexception e) {} 54 throw new illegalargumentexception(“invalid month ” + s); 55 } 56 57 private boolean matches(string s) { 58 return s.equalsignorecase(tostring()) || 59 s.equalsignorecase(toshortstring()); 60 } 61 62 public int toint() { 63 return index; 64 } 65 } listado b-9 day.java (final) 1 package org.jfree.date; 2 3 import java.util.calendar; 4 import java.text.dateformatsymbols; 5 6 public enum day { 7 monday(calendar.monday), 8 tuesday(calendar.tuesday), 5069 wednesday(calendar.wednesday), 10 thursday(calendar.thursday), 11 friday(calendar.friday), 12 saturday(calendar.saturday), 13 sunday(calendar.sunday); 14 15 private final int index; 16 private static dateformatsymbols datesymbols = new dateformatsymbols(); 17 18 day(int day) { 19 index = day; 20 } 21 22 public static day fromint(int index) throws illegalargumentexception { 23 for (day d : day.values()) 24 if (d.index == index) 25 return d; 26 throw new illegalargumentexception( 27 string.format(“illegal day index: %d.”, index)); 28 } 29 30 public static day parse(string s) throws illegalargumentexception { 31 string[] shortweekdaynames = 32 datesymbols.getshortweekdays(); 33 string[] weekdaynames = 34 datesymbols.getweekdays(); 35 36 s = s.trim(); 37 for (day day : day.values()) { 38 if (s.equalsignorecase(shortweekdaynames[day.index]) || 39 s.equalsignorecase(weekdaynames[day.index])) { 40 return day; 41 } 42 } 43 throw new illegalargumentexception( 44 string.format(“%s is not a valid weekday string”, s)); 45 } 46 47 public string tostring() { 48 return datesymbols.getweekdays()[index]; 49 } 50 51 public int toint() { 52 return index; 53 } 50754 } listado b-10 dateinterval.java (final) 1 package org.jfree.date; 2 3 public enum dateinterval { 4 open { 5 public boolean isin(int d, int left, int right) { 6 return d > left && d < right; 7 } 8 }, 9 closed_left { 10 public boolean isin(int d, int left, int right) { 11 return d >= left && d < right; 12 } 13 }, 14 closed_right { 15 public boolean isin(int d, int left, int right) { 16 return d > left && d <= right; 17 } 18 }, 19 closed { 20 public boolean isin(int d, int left, int right) { 21 return d >= left && d <= right; 22 } 23 }; 24 25 public abstract boolean isin(int d, int left, int right); 26 } listado b-11 weekinmonth.java (final) 1 package org.jfree.date; 2 3 public enum weekinmonth { 4 first(1), second(2), third(3), fourth(4), last(0); 5 private final int index; 6 7 weekinmonth(int index) { 8 this.index = index; 5089 } 10 11 public int toint() { 12 return index; 13 } 14 } listado b-12 weekdayrange.java (final) 1 package org.jfree.date; 2 3 public enum weekdayrange { 4 last, nearest, next 5 } listado b-13 dateutil.java (final) 1 package org.jfree.date; 2 3 import java.text.dateformatsymbols; 4 5 public class dateutil { 6 private static dateformatsymbols dateformatsymbols = new dateformatsymbols(); 7 8 public static string[] getmonthnames() { 9 return dateformatsymbols.getmonths(); 10 } 11 12 public static boolean isleapyear(int year) { 13 boolean fourth = year % 4 == 0; 14 boolean hundredth = year % 100 == 0; 15 boolean fourhundredth = year % 400 == 0; 16 return fourth && (!hundredth || fourhundredth); 17 } 18 19 public static int lastdayofmonth(month month, int year) { 20 if (month == month.february && isleapyear(year)) 21 return month.lastday() + 1; 22 else 23 return month.lastday(); 50924 } 25 26 public static int leapyearcount(int year) { 27 int leap4 = (year - 1896) / 4; 28 int leap100 = (year - 1800) / 100; 29 int leap400 = (year - 1600) / 400; 30 return leap4 - leap100 + leap400; 31 } 32 } listado b-14 daydatefactory.java (final) 1 package org.jfree.date; 2 3 public abstract class daydatefactory { 4 private static daydatefactory factory = new spreadsheetdatefactory(); 5 public static void setinstance(daydatefactory factory) { 6 daydatefactory.factory = factory; 7 } 8 9 protected abstract daydate _makedate(int ordinal); 10 protected abstract daydate _makedate(int day, month month, int year); 11 protected abstract daydate _makedate(int day, int month, int year); 12 protected abstract daydate _makedate(java.util.date date); 13 protected abstract int _getminimumyear(); 14 protected abstract int _getmaximumyear(); 15 16 public static daydate makedate(int ordinal) { 17 return factory._makedate(ordinal); 18 } 19 20 public static daydate makedate(int day, month month, int year) { 21 return factory._makedate(day, month, year); 22 } 23 24 public static daydate makedate(int day, int month, int year) { 25 return factory._makedate(day, month, year); 26 } 27 28 public static daydate makedate(java.util.date date) { 29 return factory._makedate(date); 30 } 51031 32 public static int getminimumyear() { 33 return factory._getminimumyear(); 34 } 35 36 public static int getmaximumyear() { 37 return factory._getmaximumyear(); 38 } 39 } listado b-15 spreadsheetdatefactory.java (final) 1 package org.jfree.date; 2 3 import java.util.*; 4 5 public class spreadsheetdatefactory extends daydatefactory { 6 public daydate _makedate(int ordinal) { 7 return new spreadsheetdate(ordinal); 8 } 9 10 public daydate _makedate(int day, month month, int year) { 11 return new spreadsheetdate(day, month, year); 12 } 13 14 public daydate _makedate(int day, int month, int year) { 15 return new spreadsheetdate(day, month, year); 16 } 17 18 public daydate _makedate(date date) { 19 final gregoriancalendar calendar = new gregoriancalendar(); 20 calendar.settime(date); 21 return new spreadsheetdate( 22 calendar.get(calendar.date), 23 month.fromint(calendar.get(calendar.month) + 1), 24 calendar.get(calendar.year)); 25 } 26 27 protected int _getminimumyear() { 28 return spreadsheetdate.minimum_year_supported; 29 } 30 31 protected int _getmaximumyear() { 51132 return spreadsheetdate.maximum_year_supported; 33 } 34 } listado b-16 spreadsheetdate.java (final) 1 /* ============================================================== 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================== 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * … 52 * 53 */ 54 55 package org.jfree.date; 56 57 import static org.jfree.date.month.february; 58 59 import java.util.*; 60 61 /** 62 * representa una fecha con un entero, de forma similar a la 63 * implementación en microsoft excel. el intervalo de fechas admitido es 64 * del 1-ene-1900 al 31-dic-9999. 65 * <p/> 66 * recuerde que excel tiene un error que reconoce el año 67 * 1900 como bisiesto cuando en realidad no lo es. encontrará más 68 * información en el sitio de microsoft, en el artículo q181370: 69 * <p/> 70 * http://support.microsoft.com/support/kb/articles/q181/3/70.asp 71 * <p/> 72 * excel usa como convención que el 1-ene-1900 = 1. esta clase usa la 73 * convención de que el 1-ene-1900 = 2. 74 * como resultado, el número de día de esta clase será diferente al de 75 * excel para enero y febrero de 1900… pero excel añade un día 76 * más (29-feb-1900 que en realidad no existe) y a partir de ahí 77 * los números de los días coinciden. 78 * 79 * @author david gilbert 80 */ 81 public class spreadsheetdate extends daydate { 51282 public static final int earliest_date_ordinal = 2; // 1/1/1900 83 public static final int latest_date_ordinal = 2958465; // 12/31/9999 84 public static final int minimum_year_supported = 1900; 85 public static final int maximum_year_supported = 9999; 86 static final int[] aggregate_days_to_end_of_preceding_month = 87 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 88 static final int[] leap_year_aggregate_days_to_end_of_preceding_month = 89 {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 90 91 private int ordinalday; 92 private int day; 93 private month month; 94 private int year; 95 96 public spreadsheetdate(int day, month month, int year) { 97 if (year < minimum_year_supported || year > maximum_year_supported) 98 throw new illegalargumentexception( 99 “the ‘year’ argument must be in range ” + 100 minimum_year_supported + “ to ” + maximum_year_supported + “.”); 101 if (day < 1 || day > dateutil.lastdayofmonth(month, year)) 102 throw new illegalargumentexception(“invalid ‘day’ argument.”); 103 104 this.year = year; 105 this.month = month; 106 this.day = day; 107 ordinalday = calcordinal(day, month, year); 108 } 109 110 public spreadsheetdate(int day, int month, int year) { 111 this(day, month.fromint(month), year); 112 } 113 114 public spreadsheetdate(int serial) { 115 if (serial < earliest_date_ordinal || serial > latest_date_ordinal) 116 throw new illegalargumentexception( 117 “spreadsheetdate: serial must be in range 2 to 2958465.”); 118 119 ordinalday = serial; 120 calcdaymonthyear(); 121 } 122 123 public int getordinalday() { 124 return ordinalday; 125 } 513126 127 public int getyear() { 128 return year; 129 } 130 131 public month getmonth() { 132 return month; 133 } 134 135 public int getdayofmonth() { 136 return day; 137 } 138 139 protected day getdayofweekforordinalzero() {return day.saturday;} 140 141 public boolean equals(object object) { 142 if (!(object instanceof daydate)) 143 return false; 144 145 daydate date = (daydate) object; 146 return date.getordinalday() == getordinalday(); 147 } 148 149 public int hashcode() { 150 return getordinalday(); 151 } 152 153 public int compareto(object other) { 154 return dayssince((daydate) other); 155 } 156 157 private int calcordinal(int day, month month, int year) { 158 int leapdaysforyear = dateutil.leapyearcount(year - 1); 159 int daysuptoyear = (year - minimum_year_supported) * 365 + leapdaysforyear; 160 int daysuptomonth = aggregate_days_to_end_of_preceding_month[month.toint()]; 161 if (dateutil.isleapyear(year) && month.toint() > february.toint()) 162 daysuptomonth++; 163 int daysinmonth = day - 1; 164 return daysuptoyear + daysuptomonth + daysinmonth + earliest_date_ordinal; 165 } 166 167 private void calcdaymonthyear() { 168 int days = ordinalday - earliest_date_ordinal; 514169 int overestimatedyear = minimum_year_supported + days / 365; 170 int nonleapdays = days - dateutil.leapyearcount(overestimatedyear); 171 int underestimatedyear = minimum_year_supported + nonleapdays / 365; 172 173 year = huntforyearcontaining(ordinalday, underestimatedyear); 174 int firstordinalofyear = firstordinalofyear(year); 175 month = huntformonthcontaining(ordinalday, firstordinalofyear); 176 day = ordinalday - firstordinalofyear - daysbeforethismonth(month.toint()); 177 } 178 179 private month huntformonthcontaining(int anordinal, int firstordinalofyear) { 180 int daysintothisyear = anordinal - firstordinalofyear; 181 int amonth = 1; 182 while (daysbeforethismonth(amonth) < daysintothisyear) 183 amonth++; 184 185 return month.fromint(amonth - 1); 186 } 187 188 private int daysbeforethismonth(int amonth) { 189 if (dateutil.isleapyear(year)) 190 return leap_year_aggregate_days_to_end_of_preceding_month[amonth] - 1; 191 else 192 return aggregate_days_to_end_of_preceding_month[amonth] - 1; 193 } 194 195 private int huntforyearcontaining(int anordinalday, int startingyear) { 196 int ayear = startingyear; 197 while (firstordinalofyear(ayear) <= anordinalday) 198 ayear++; 199 200 return ayear - 1; 201 } 202 203 private int firstordinalofyear(int year) { 204 return calcordinal(1, month.january, year); 205 } 206 207 public static daydate createinstance(date date) { 208 gregoriancalendar calendar = new gregoriancalendar(); 209 calendar.settime(date); 210 return new spreadsheetdate(calendar.get(calendar.date), 515211 month.fromint(calendar.get(calendar.month) + 1), 212 calendar.get(calendar.year)); 213 214 } 215 } 516epílogo en 2005, mientras asistía a la conferencia agile en denver (ee.uu.), elisabeth hedrickson [125] me dio una pulsera verde parecida a la que lance armstrong popularizó hace unos años. en ésta se leía test obsessed (obsesionado por las pruebas). me la puse y la lucí con orgullo. desde que aprendí el tdd de kent beck en 1999, sin duda el desarrollo controlado por pruebas me ha obsesionado. pero sucedió algo extraño. no me podía quitar la pulsera. no porque se hubiera quedado físicamente pegada, sino porque estaba moralmente pegada. la pulsera resumía mi ética profesional. era un indicador visible de mi compromiso por crear el mejor código posible. si me la hubiera quitado habría traicionado a esa ética y a ese compromiso. y todavía la llevo en la muñeca. cuando escribo código, la veo ahí. es un recordatorio constante de la promesa que me hice de escribir código limpio. 517robert cecil “uncle bob” martin (palo alto california, estados unidos, 1952). es un prestigioso desarrollador de software desde 1970 y consultor internacional desde 1990. es fundador y presidente de object mentor, inc., un equipo de experimentados consultores que ayudan a clientes de todo el mundo en diferentes campos de la programación como c++, java, c#, ruby, programación orientada a objetos (poo), patrones de diseño, uml, metodologías ágiles y programación extreme. 518notas 519[1] [beck07]. << 520[2] cuando ignaz semmelweis recomendó en 1847 que los médicos se lavaran las manos, su propuesta fue rechazada aludiendo que los doctores estaban demasiado ocupados para hacerlo entre paciente y paciente. << 521[3] http://www.pragmaticprogrammer.com/booksellers/2004-12.html. << 522[4] [knuth92]. << 523[5] es una adaptación del mensaje de despedida de robert stephenson smyth baden-powell a los scouts: «intentad dejar este mundo un poco mejor de como os lo encontrasteis…». << 524[6] como veremos más adelante, aunque un contenedor sea una lista , no conviene codificar el tipo de contenedor en el nombre. << 525[7] imagine que se crea una variable con el nombre klass sólo porque el nombre class se ha usado en otro elemento. << 526[8] uncle bob solía hacerlo en c++ pero ha abandonado esta práctica ya que no es necesario en los ide modernos. << 527[9] http://java.sun.com/products/javabeans/docs/spec.html. << 528[10] una herramienta de pruebas de código abierto (www.fitnese.org). << 529[11] una herramienta de código abierto para probar unidades para java ( www.junit.org ). << 530[12] le pregunté a kent si todavía conservaba una copia, pero no la encontró. busqué en mis viejos ordenadores, pero nada. solamente se conserva el recuerdo de aquél programa. << 531[13] el lenguaje logo usaba la palabra clave to al igual que ruby y python usaban def . por tanto, todas las funciones comenzaban por to , lo que tenía un efecto interesante en cómo se diseñaban. << 532[14] [kp78], p. 37. << 533[15] y, por supuesto, se incluyen cadenas if/else. << 534[16] a. http://en.wikipedia.org/wiki/single_responsibility_principle b. http://www.objectmentor.com/resources/articles/srp.pdf << 535[17] a. http://en.wikipedia.org/wiki/open/closed_principle b. http://www.objectmentor.com/resources/articles/ocp.pdf << 536[18] [gof]. << 537[19] terminé la refactorización de un módulo que usaba la forma dinámica. conseguí convertir el módulo outputstream en un campo de la clase y las invocaciones de writefield a formato monódico. el resultado fue mucho más limpio. << 538[20] existen algunos que creen que pueden evitar volver a compilar e implementar, y nos hemos encargado de ellos. << 539[21] ejemplo de principio abierto/cerrado (ocp) [ppp02]. << 540[22] el principio dry. [prag]. << 541[23] [sp72]. << 542[24] [kp78], p. 144. << 543[25] la tendencia actual de los ide de comprobar la ortografía de los comentarios será un bálsamo para los que tenemos que leer gran cantidad de código. << 544[26] el cuadro muestra sigma/2 por encima y debajo de la media. asumo que la distribución de la longitud de archivos no es normal, por lo que la desviación estándar no es matemáticamente precisa. pero aquí el objetivo no es la precisión, sino la sensación. << 545[27] es lo contrario a lo que sucede en lenguajes como pascal, c y c++ que obligan a definir, o al menos a declarar, las funciones antes de usarlas. << 546[28] ¿a quien voy a engañar? sigo siendo programador de lenguajes de ensamblado. en este caso, el hábito sí hace al monje. << 547[29] siempre existe una solución conocida por los diseñadores orientados a objetos con experiencia: visitor o entrega dual, por ejemplo. pero son técnicas costosas y suelen devolver la estructura de un programa por procedimientos. << 548[30] http://es.wikipedia.org/wiki/ley_de_demeter. << 549[31] de la estructura apache. << 550[32] en ocasiones se denomina feature envy (envidia de las características), de [refactoring]. << 551[33] [martin]. << 552[34] [becktdd], pp. 136-137. << 553[35] véase el patrón del adaptador en [gof]. << 554[36] más información al respecto en [welc]. << 555[37]  professionalism and test-driven development , robert c. martin, object mentor, ieee software, mayo/junio 2007 (vol. 24, no. 3) pp. 32-36 http://doi.ieeecomputersociety.org/10.1109/ms.2007.85 << 556[38] http://fitnesse.org/fitnesse.acceptancetestpatterns. << 557[39] véase el apartado sobre asignaciones mentales del capítulo 2. << 558[40] véase la entrada de dave astel: http://www.artima.com/weblogs/viewpost.jsp?thread=35578 << 559[41] [rspec]. << 560[42] [gof]. << 561[43] ¡cíñase al código! << 562[44] materiales de formación de object mentor. << 563[45] [rdd]. << 564[46] encontrará más información sobre este principio en [ppp]. << 565[47] [knuth92]. << 566[48] [ppp]. << 567[49] [ppp]. << 568[50] [mezzaros07]. << 569[51] [gof]. << 570[52] véase, por ejemplo, [fowler]. << 571[53] véase [spring], también existe una estructura spring.net. << 572[54] no olvide que la creación de instancias/evaluación tardía es sólo una optimización, puede que prematura. << 573[55] sistema de administración de base de datos. << 574[56] consulte [aosd] si necesita información general sobre aspectos y [aspectj] y [colyer] para información concreta de aspectj. << 575[57] no se necesita la modificación manual del código fuente de destino. << 576[58] véase [cglib], [asm] y [javassist]. << 577[59] si necesita ejemplos más detallados de la api proxy y ejemplos de uso, consulte [goetz]. << 578[60] aop se suele confundir con técnicas empleadas para implementarlo, como la intercepción y envoltorio de métodos a través de proxies . el verdadero valor de un sistema aop es la capacidad para especificar comportamientos del sistema de forma concisa y modular. << 579[61] véase [spring] y [jboss]. java puro significa sin aspectj. << 580[62] adaptado de www.theserverside.com/tt/articles/article.tss? l=introtospring25. << 581[63] [gof]. << 582[64] el ejemplo se puede simplificar mediante mecanismos que usen convenciones y anotaciones de java 5 para reducir la cantidad necesaria de lógica de conexión explícita. << 583[65] adaptado de http://www.onjava.com/pub/a/onjava/2006/05/17/standardizing-with-ejb3- java-persistence-api.html. << 584[66] véase [aspectj] y [colyer]. << 585[67] no confundir con la práctica de diseño anticipado. bduf es la práctica de diseñar todo por adelantado antes de implementar nada. << 586[68] existe una cantidad significativa de exploración iterativa y detalles de análisis, incluso una vez iniciada la construcción. << 587[69] el término fue empleado por primera vez por [kolence]. << 588[70] el trabajo de [alexander] ha sido una gran influencia para la comunidad de software . << 589[71] véase, por ejemplo, [dsl]. [jmock] es un buen ejemplo de api de java que crea un dsl. << 590[72] [xpe]. << 591[73] [gof]. << 592[74] correspondencia privada. << 593[75] rayos cósmicos, repeticiones, etc. << 594[76] véase el apéndice a. << 595[77] véase el apéndice a. << 596[78] [ppp]. << 597[79] véase el apéndice a. << 598[80] [prag]. << 599[81] [lea99]. << 600[82] http://en.wikipedia.org/wiki/producer-consumer. << 601[83] http://en.wikipedia.org/wiki/readers-writers_problem. << 602[84] http://es.wikipedia.org/wiki/problema_de_la_cena_de_los_filósofos. << 603[85] véase el apéndice a. << 604[86] una sección crítica es cualquier sección de código que debe protegerse de usos simultáneos por parte del programa para que sea correcta. << 605[87] véase el apéndice a. << 606[88] véase el apéndice a. << 607[89] ¿sabía que el modelo de procesos de java no garantiza el procesamiento preventivo? los so modernos sí lo hacen, de modo que lo obtiene de forma gratuita. no obstante, la mvj no lo garantiza. << 608[90] no es estrictamente el caso. como la mvj no garantiza los procesos preventivos, un determinado algoritmo puede que siempre funcione en un so que no prevea los procesos. lo contrario también es posible, pero por distintos motivos. << 609[91] https://www.ibm.com/developerworks/community/groups/service/html/communityview? lang=es&communityuuid=18d10b14-e2c8-4780-bace-9af1fc463cc0. << 610[92] hace poco modifiqué este módulo para ruby. tenía una séptima parte del tamaño original y una mejor estructura. << 611[93] para evitar este tipo de sorpresas, añadí una nueva prueba de unidad que invocaba todas las pruebas de fitnesse. << 612[94]  junit pocket guide , kent beck, o’reilly. 2004. p. 43. << 613[95] véase el capítulo 1. << 614[96] una solución mejor sería que el javadoc presentara todos los comentarios con formato previo, para que tengan el mismo aspecto en el código y en el documento. << 615[97] algunos revisores de este texto no comparten esta decisión. sostienen que en una estructura de código abierto es más recomendable ejercer control manual sobre el id de serie para que los cambios mínimos del software no invaliden las fechas señalizadas antiguas. me parece justo. sin embargo, al menos el fallo, aunque sea inconveniente, tiene un motivo evidente. por otra parte, si el autor de la clase se olvida de actualizar el id, el modo de fallo será indefinido y puede que silencioso. creo que la moraleja es que no debe esperar a deserializar entre versiones. << 616[98] [gof]. << 617[99] ibid. << 618[100] ibid. << 619[101] [simmons04], p. 73. << 620[102] [refactoring]. << 621[103] [beck97]. << 622[104] [refactoring]. << 623[105] http://es.wikipedia.org/wiki/principio_de_la_mínima_sorpresa << 624[106] [prag]. << 625[107] [gof]. << 626[108] [gof]. << 627[109] [refactoring]. << 628[110] en concreto, el principio de responsabilidad única, el principio abierto/cerrado y el principio de cierre común. véase [ppp]. << 629[111] [beck97], p. 108. << 630[112] [beck07]. << 631[113] es distinto saber cómo funciona el código y saber si el algoritmo se encargará de realizar la tarea para la que se necesita. es habitual desconocer si un algoritmo es el adecuado. desconocer lo que hace el código es indolencia. << 632[114] o mejor todavía, una clase money que use enteros. << 633[115] [prag]. p. 138. << 634[116] véase la cita de ward cunningham del capítulo 1. << 635[117] [ddd]. << 636[118] puede comprobar personalmente el código antes y después, y revisar las versiones con y sin subprocesos, que veremos en un apartado posterior. << 637[119] es una comparación simplificada, pero para los objetivos de este ejercicio es un modelo válido. << 638[120] de hecho, la interfaz iterator es incompatible con subprocesos por naturaleza. no se diseñó para usar varios subprocesos, de modo que no debería sorprenderle. << 639[121] por ejemplo, alguien añade un resultado de depuración y el problema desaparece. el código de depuración corrige el problema, pero permanece en el sistema. << 640[122] siglas de there ain’t no such thing as a free lunch (todo tiene un precio). << 641[123] http://www.haifa.ibm.com/projects/verification/contest/index.html << 642[124] véase [lea99] p. 191. << 643[125] http://www.qualitytree.com/ << 644cada año, se invierten innumerables horas y se pierden numerosos recursos debido a código mal escrito, ralentizando el desarrollo, disminuyendo la productividad, generando graves fallos e incluso pudiendo acabar con la organización o empresa. el reconocido experto de software robert c. martin, junto con sus colegas de object mentor, nos presentan sus óptimas técnicas y metodologías ágiles para limpiar el código sobre la marcha y crearlo de forma correcta, de este modo mejorará como programador. esta obra se divide en tres partes. la primera describe los principios, patrones y prácticas para crear código limpio. la segunda incluye varios casos de estudio cuya complejidad va aumentando. cada ejemplo es un ejercicio de limpieza y transformación de código con problemas. la tercera parte del libro contiene una lista de heurística y síntomas de código erróneo (smells) confeccionada al crear los casos prácticos. el resultado es una base de conocimientos que describe cómo pensamos cuando creamos, leemos y limpiamos código. imprescindible para cualquier desarrollador, ingeniero de software, director de proyectos, jefe de equipo o analista de sistemas interesado en crear código de mejor calidad. ¡el libro que todo programador debe leer! 2robert cecil martin código limpio manual de estilo para el desarrollo ágil de software epub r1.1 xcuidi 21.03.2018 3título original: clean code: a handbook of agile software craftsmanship robert cecil martin, 2009 traducción: josé luis gómez celador ilustraciones: jeniffer kohnke & angela brooks editor digital: xcuidi colaborador: mario j. c. (pdf-español) epub base r1.2 este libro se ha maquetado siguiendo los estándares de calidad de www.epublibre.org. la página, y sus editores, no obtienen ningún tipo de beneficio económico por ello. si ha llegado a tu poder desde otra web debes saber que seguramente sus propietarios sí obtengan ingresos publicitarios mediante archivos como este 4para ann marie: el verdadero amor de mi vida. 5agradecimientos me gustaría dar las gracias a mis dos artistas, jeniffer kohnke y angela brooks. jennifer es la encargada de las impresionantes ilustraciones del inicio de cada capítulo y también de los retratos de kent beck, ward cunningham, bjarne stroustrup, ron jeffries, grady booch, dave thomas, michael feathers y el mío propio. angela se encarga de las ilustraciones internas de los capítulos. ha realizado muchos dibujos para mí en los últimos años, incluidos muchos de los del libro agile software development: principles, patterns, and practices . también es mi primogénita. un agradecimiento especial a los revisores bob bogetti, george bullock, jeffrey overbey y especialmente matt heusser. han sido increíbles. han sido inmisericordes. han sido minuciosos. me han forzado al máximo para realizar las mejoras necesarias. gracias a mi editor, chris guzikowski, por su apoyo, aliento y amistad. gracias a todo el personal de la editorial, incluida raina chrobak, que se encargó de que fuera honesto y cumpliera los plazos. gracias a micah martin y a todos los de 8th light (www.8thlight.com) por sus críticas y su apoyo. gracias a todos los object mentor, pasados, presentes y futuros, incluidos bob koss, michael feathers, michael hill, erik meade, jeff langr, pascal roy, david farber, brett schuchert, dean wampler, tim ottinger, dave thomas, james grenning, brian button, ron jeffries, lowell lindstrom, angelique martin, cindy sprague, libby ottinger, joleen craig, janice 6brown, susan rosso y el resto. gracias jim newkirk, mi amigo y socio, que me ha enseñado más de lo que cree. mi agradecimiento a kent beck, martin fowler, ward cunningham, bjarne stroustrup, grady booch y todos mis mentores, compatriotas y colegas. gracias a john vlissides por estar ahí cuando lo necesitaba. gracias a todos los de zebra por permitirme despotricar sobre la extensión que debe tener una función. y, por último, darle las gracias por leer estos agradecimientos. 7prólogo una de nuestras golosinas preferidas en dinamarca es ga-jol , con un fuerte sabor a regaliz, que constituye un complemento perfecto para nuestro húmedo y frío clima. parte del encanto de ga-jol para los daneses es la frase que suele incluir en el envoltorio. esta mañana compré un paquete de dos y me encontré con este antiguo dicho danés: ærlighed i små ting er ikke nogen lille ting. «la honestidad por las cosas pequeñas no es algo menor». perfecto para que lo que pensaba escribir. las cosas pequeñas importan. este libro trata sobre humildes preocupaciones cuyo valor dista mucho de ser menor. 8dios está en los detalles , afirmó el arquitecto ludwig mies van der rohe. esta cita recuerda argumentos contemporáneos sobre el papel de la arquitectura en el desarrollo de software , en especial en el universo ágil. bob y yo hemos tenido esta conversación muchas veces. y sí, mies van der rohe se fijaba en la utilidad y la forma atemporal de la construcción que subyace a las grandes creaciones arquitectónicas. por otra parte, seleccionaba personalmente los pomos de todas las puertas de todas las casas que diseñaba. ¿por qué? porque las cosas pequeñas importan. en nuestro interminable debate sobre tdd, bob y yo coincidimos en que la arquitectura del software desempeña una importante labor en el desarrollo, aunque tenemos diferentes visiones de lo que esto significa. estas diferencias carecen de importancia, ya que podemos aceptar que los profesionales responsables dedican parte de su tiempo a planificar un proyecto antes de comenzarlo. las nociones de diseño controlado únicamente por pruebas y el código, propias de finales de la década de 1990, ya no son válidas. y la atención al detalle es un pilar fundamental de los profesionales, casi como cualquier visión. por un lado, la práctica en los detalles otorga dominio a los profesionales, y aumenta su confianza para la práctica a mayor escala. por otra parte, el más mínimo fallo de construcción, una puerta que no cierre bien o un baldosín mal colocado, acaba con el encanto del todo. de eso se trata el código limpio. pero la arquitectura es sólo una metáfora del desarrollo de software y en concreto de la parte del software que ofrece el producto inicial, de la misma forma que un arquitecto entrega un edificio inmaculado. hoy en día, el objetivo es comercializar rápidamente los productos. queremos que las fábricas produzcan software a pleno rendimiento. se trata de fábricas humanas, programadores que piensan, que sienten y que trabajan para crear un producto. la metáfora de la manufacturación es incluso más evidente en este pensamiento. los aspectos productivos de las fábricas de automóviles japonesas fueron una gran inspiración para serum. pero incluso en la industria automovilística, gran parte del trabajo no radica en la fabricación sino en el mantenimiento, o más bien en cómo evitarlo. en el software , el 80 por 100 o más de lo que hacemos se denomina cuantitativamente mantenimiento, el acto de reparar. en lugar de optar por la 9típica costumbre occidental de crear software de calidad, debemos pensar como reparadores o mecánicos. ¿qué piensan los directores japoneses de todo esto? en 1951, un enfoque de calidad denominado tpm ( total productive maintenance o mantenimiento productivo total) apareció en escena. se centraba en el mantenimiento y no en la producción. uno de los pilares de tpm es el conjunto de principios denominados 5s, una serie de disciplinas. estos principios 5s son en realidad la base lean, otro conocido término en la escena occidental, y cada vez más presente en el mundo del software . estos principios no son opcionales. como indica uncle bob, la práctica del software correcto requiere disciplina. no siempre se trata de hacer, de producir a la velocidad óptima. la filosofía 5s incluye estos conceptos: seiri u organización : es fundamental saber dónde están las cosas, mediante enfoques como el uso de nombres correctos. ¿cree que los nombres de los identificadores no son relevantes? lea los siguientes capítulos. seiton o sistematización : existe un antiguo dicho norteamericano: un sitio para cada cosa y cada cosa en su sitio. un fragmento de código debe estar donde esperamos encontrarlo; en caso contrario, refactorice hasta conseguirlo. seiso o limpieza : mantenga limpio el lugar de trabajo. ¿qué dicen los autores sobre inundar el código de comentarios y líneas que capturan historias o deseos futuros? elimínelos. seiketsu o estandarización : el grupo decide cómo mantener limpio el lugar de trabajo. ¿cree que este libro habla sobre tener un estilo de código coherente y una serie de prácticas dentro del grupo? ¿de dónde provienen esos estándares? siga leyendo. shutsuke o disciplina : significa ser disciplinado en la aplicación de las prácticas y reflejarlas en el trabajo y aceptar los cambios. si acepta el reto, ha leído bien, el reto, de leer y llevar a la práctica este libro, podrá comprender y apreciar el último punto. aquí nos acercamos a la 10raíz de la profesionalidad responsable de una profesión que debería preocuparse del ciclo vital de un producto. al igual que mantenemos coches y otras máquinas, el mantenimiento divisible, esperar a que surjan los errores, es la excepción. por el contrario, ascendemos un nivel: inspeccionamos diariamente las máquinas y arreglamos los componentes gastados antes de que se rompan, o cambiamos el aceite cada varios miles de kilómetros para evitar problemas. en el código, debemos refactorizar sin compasión. puede ascender otro nivel más, como hizo el movimiento tpm hace 50 años: crear máquinas que se pueden mantener mejor. crear código legible es tan importante como crear código ejecutable. la práctica definitiva, que apareció en los círculos tpm en 1960, es la que se centra en introducir nuevas máquinas o sustituir las antiguas. como fred brooks nos advirtió, deberíamos rehacer el software cada siete años para eliminar los problemas latentes. tendríamos que actualizar este plazo por semanas, días e incluso horas en lugar de años. ahí es donde se encuentra el detalle. el detalle tiene un gran poder, y es un enfoque vital humilde y profundo, como es de esperar de cualquier enfoque de origen japonés. pero no es sólo la visión oriental de la vida; también lo encontramos en el pueblo norteamericano. la cita seiton anterior proviene de la pluma de un ministro de ohio que, literalmente, consideraba la limpieza como un remedio para todas las formas del mal. ¿y seiso ? la limpieza es la pureza . aunque una casa sea bella, el mobiliario inadecuado acaba con su encanto. ¿y la opinión de shutsuke al respecto? el que confíe en lo pequeño confiará en lo superior . ¿y la predisposición a refactorizar en el momento adecuado, reforzando nuestra posición para las posteriores grandes decisiones, en lugar de dejarlo pasar? una puntada a tiempo ahorra ciento. al que madruga, dios le ayuda. no dejes para mañana lo que puedas hacer hoy (éste era el sentido original de la frase «en el momento adecuado» de lean hasta que cayó en manos de consultores de software ). ¿y sobre calibrar la importancia de los pequeños esfuerzos individuales en un todo mayor? de pequeñas semillas crecen grandes árboles . ¿y la integración de sencillas tareas preventivas en la vida diaria? más vale prevenir que curar . el código limpio honra las raíces de la sabiduría popular, de antes o de ahora, y se puede aplicar con atención al detalle. 11incluso en la literatura arquitectónica encontramos ejemplos de estos detalles. piense en los pomos de mies van der rohe. eso es seiri . es la atención a todos los nombres de variables. debe bautizar a una variable con el mismo cuidado como si fuera su primogénito. y como todo sabemos, este cuidado no acaba nunca. el arquitecto christopher alexander, padre de patrones y lenguajes de patrones, considera todo acto de diseño como un pequeño acto local de reparación, y considera la maestría de la estructura como competencia única del arquitecto; las formas mayores se ceden a los patrones y su aplicación a los habitantes. el diseño es interminable no sólo al añadir una nueva habitación a una casa, sino al prestar atención a la pintura, a cambiar las alfombras o a instalar un nuevo fregadero en la cocina. otras artes muestran sentimientos análogos. en nuestra búsqueda por la importancia de los detalles, nos topamos con el autor francés del siglo xix gustav flaubert. el poeta francés paul valery afirma que un poema no se acaba nunca y que tiene que retocarse continuamente, y que dejar de trabajar en el poema es señal de abandono. tal preocupación por el detalle es común en todas las empresas de excelencia. puede que esto no sea nada nuevo, pero al leer este libro sentirá la necesidad de adoptar disciplinas rechazadas en su momento por apatía o por un deseo de espontaneidad o una simple respuesta al cambio. desafortunadamente, no solemos considerar estas preocupaciones la clave del arte de la programación. renunciamos pronto a nuestro código, no porque lo hayamos completado, sino porque nuestro sistema de valores se centra en el futuro más que en la sustancia de nuestros productos. esto tiene un precio final: hierba mala nunca muere . la investigación, ni en el mundo industrial ni en el académico, se reduce a mantener limpio el código. cuando trabajaba en la organización bell labs software production research (sin duda de producción) comprobamos que un estilo de sangrado coherente era uno de los mayores indicadores estadísticamente significativos de una baja densidad de errores. queremos que una arquitectura, un lenguaje de programación u otra noción superior sea el motivo de la calidad; como seres cuya supuesta profesionalidad se debe al dominio de herramientas y métodos de diseño, nos sentimos insultados por el valor que los programadores añaden con tan sólo aplicar un estilo de sangrado coherente. 12para citar mi propio libro de hace 17 años, dicho estilo distingue la excelencia de la simple competencia. la visión japonesa comprende el verdadero valor del trabajador cotidiano y, en especial, de los sistemas de desarrollo que dependen de las sencillas acciones diarias de tales trabajadores. la calidad es el resultado de un millón de acciones cuidadosas, no de un método magnífico caído del cielo. que dichas acciones sean simples no significa que sean simplistas, y mucho menos que sean sencillas. son la base de la grandeza y, cada vez más, de cualquier empresa humana. ignorarlas no es humano en absoluto. evidentemente, todavía defiendo el pensamiento global, en especial el valor de los enfoques arquitectónicos cimentados en el conocimiento de los dominios y la capacidad de uso del software . este libro no versa sobre esto, al menos no de forma evidente. este libro transmite un mensaje más sutil cuya profundidad no debe menospreciarse. coincide con la visión de gente como peter sommerlad, kevlin henney y giovanni asproni, cuyos mantras son «el código es el diseño» y «código simple». aunque debemos recordar que la interfaz es el programa y que sus estructuras dicen mucho sobre la propia estructura del programa, es fundamental adoptar de forma continuada la humilde posición de que el diseño vive en el código. y aunque los cambios y la metáfora de la fábrica supongan costes, los cambios de diseño suponen valor. debemos considerar al código como la articulación de los esfuerzos de diseño, visto como un proceso, no como algo estático. es en el código donde se desarrollan los conceptos arquitectónicos de conexión y cohesión. si escucha a larry constantine describir la conexión y la cohesión, lo hace en términos del código, no desde conceptos abstractos propios de uml. en su ensayo abstraction descant , richard gabriel afirma que la abstracción es el mal. el código es el remedio al mal y el código limpio puede que sea divino. volviendo a mi caja de ga-jol , considero importante recordar que la sabiduría danesa nos recomienda no sólo prestar atención a las pequeñas cosas, sino también ser honestos con ellas. esto significa ser honesto con el código, con nuestros colegas sobre el estado del código y, en especial, con nosotros mismos. ¿hemos hecho todo lo posible para dejar las cosas mejor que como las encontramos? ¿hemos refactorizado el código antes de terminarlo? no se trata de preocupaciones periféricas, sino que se encuentran 13en la base misma de los valores agile. en serum se recomienda que la refactorización sea parte del concepto de terminado. ni la arquitectura ni el código limpio insisten en la perfección, sino en la honestidad y en hacerlo lo mejor posible. errar es humano; perdonar es divino . en serum, todo lo hacemos de forma visible. aireamos los trapos sucios. somos honestos sobre el estado de nuestro código ya que nunca es perfecto. nos hemos hecho más humanos, más merecedores de lo divino y estamos más próximos a la grandeza de los detalles. en nuestra profesión, necesitamos desesperadamente toda la ayuda posible. si un suelo seco reduce el riesgo de resbalones y las herramientas bien organizadas aumentan la productividad, es nuestra meta. y en cuanto al libro, es la mejor aplicación pragmática de los principios lean de software que he visto nunca en formato impreso. no esperaba menos de este grupo de individuos que durante años se han esforzado no sólo por mejorar sino en ofrecer sus conocimientos a la industria mediante obras como la que ahora tiene entre manos. hace que el mundo sea un poco mejor que antes de que uncle bob me enviara el manuscrito. y tras completar este ejercicio, me dispongo a limpiar mi escritorio. james o. coplien mørdrup, dinamarca 14introducción reproducido con permiso de thom holwerda. http://www.osnews.com/story/19266/wtfs_m. © 2008 focus shift. ¿qué puerta representa su código? ¿qué puerta representa a su equipo o a su 15empresa? ¿por qué estamos en esa habitación? ¿es una sencilla revisión del código o hemos detectado un sinfín de problemas terribles? ¿depuramos presas del pánico el código que pensábamos que funcionaba? ¿los clientes huyen despavoridos y los directores nos pisan los talones? ¿cómo asegurarnos de que abrimos la puerta correcta cuando las cosas se ponen feas? la respuesta: la maestría . la maestría se consigue de dos formas: conocimientos y trabajo. debe adquirir el conocimiento de los principios, patrones, prácticas y heurística propios de un maestro, y dominar dichos conocimientos a través de la práctica. puedo enseñarle la teoría de montar en bicicleta. de hecho, los conceptos matemáticos clásicos son muy sencillos. gravedad, fricción, velocidad angular, centro de masa, etc., se pueden demostrar en menos de una página repleta de ecuaciones. con esas fórmulas, puedo demostrar que montar en bicicleta es práctico y proporcionarle los conocimientos necesarios para conseguirlo. pero la primera vez que se monte en una bici se caerá al suelo. el diseño de código no es diferente. podríamos enumerar todos los principios del código limpio y confiar en que se encargue del resto (es decir, dejar que se cayera de la bici) pero entonces la pregunta sería qué clase de profesores somos y qué clase de alumno sería. no. así no funciona este libro. aprender a crear código limpio es complicado . requiere algo más que conocer principios y patrones. tiene que sudar. debe practicarlo y fallar. debe ver cómo otros practican y fallan. debe observar cómo se caen y recuperan el paso. debe ver cómo agonizan en cada decisión y el precio que pagan por tomar decisiones equivocadas. para leer este libro, prepárese a trabajar duro. no es un libro que se pueda leer en un avión y terminarlo antes de aterrizar. este libro le hará trabajar, y mucho. ¿y qué tipo de trabajo? tendrá que leer código, en abundancia. y se le pedirá que piense en qué acierta el código y en qué falla. se le pedirá que siga nuestras descripciones mientras despedazamos módulos y los volvemos a ensamblar. para ello necesitará tiempo y esfuerzo, pero creemos que merece la pena. hemos dividido el libro en tres partes. los primeros capítulos describen 16los principios, patrones y prácticas para crear código limpio. incluyen abundante código y resultan difíciles de leer. sirven como preparación a la segunda parte. si abandona tras leer la primera sección, que tenga buena suerte. la segunda parte del libro es la más difícil. incluye varios casos de estudio cuya complejidad va aumentando. cada ejemplo es un ejercicio de limpieza de código, transformar código con problemas para que tenga menos problemas. el detalle de esta parte es abundante . tendrá que alternar entre el texto y los listados de código. tendrá que analizar y entender el código, y comprender el razonamiento de cada cambio realizado. piense en que esta parte le llevará varios días . la tercera parte del libro es un único capítulo que contiene una lista de heurística y síntomas de código erróneo ( smells ) confeccionada al crear los casos prácticos. al analizar y limpiar el código de los ejemplos, documentamos el motivo de todas nuestras acciones como heurística o síntoma. intentamos comprender nuestras reacciones al código que leíamos y modificábamos, y nos esforzamos por capturar las sensaciones que tuvimos y las decisiones que adoptamos. el resultado es una base de conocimientos que describe cómo pensamos cuando creamos, leemos y limpiamos código. esta base de conocimientos no le servirá de mucho si no lee atentamente los casos de la segunda parte del libro. en esos capítulos hemos anotado con precisión todos los cambios realizados con referencias a la heurística. estas referencias se muestran entre corchetes, como [h22]. de este modo puede ver el contexto en el que se ha aplicado y creado dicha heurística. no importa tanto el propio valor de las heurísticas sino la relación entre ellas y las decisiones adoptadas al limpiar el código en los ejemplos . si lee la primera y la tercera parte y se salta los casos prácticos, habrá leído otro libro distinto sobre cómo crear código correcto, pero si dedica tiempo a analizar los casos, sigue todos y cada uno de los pasos, cada una de las decisiones, si se pone en nuestro lugar y se obliga a pensar tal y como lo hicimos nosotros, entonces comprenderá mucho mejor todos los principios, patrones, prácticas y heurística. ya no será un conocimiento superficial. se convertirá en algo profundo. lo integrará de la misma forma que una bicicleta se convierte en una extensión propia una vez dominada la forma de 17montar. 18sobre la imagen de cubierta la imagen de la portada es m104: la galaxia del sombrero. m104 se encuentra en virgo, a unos 30 millones de años luz, y su núcleo es un súper agujero negro que pesa aproximadamente mil millones de masas solares. ¿la imagen le recuerda la explosión de la luna praxis de klingon? recuerdo la escena de star trek vi en la que se mostraba un anillo de restos flotando tras la explosión. tras esa escena, el anillo se ha convertido en un elemento habitual de las explosiones de ciencia ficción. incluso se añadió a la explosión de alderaan en ediciones posteriores de la primera película de la guerra de las galaxias. ¿qué provocó la formación de este anillo alrededor de m104? ¿por qué tiene un centro de tales dimensiones y un núcleo tan brillante y diminuto? parece como si el agujero negro central hubiera provocado un orificio de 30 000 años luz en el centro de la galaxia. la desgracia caería sobre las civilizaciones que se encontraran en el camino de este desastre cósmico. los súper agujeros negros desayunan estrellas y convierten parte de su masa en energía. e=mc 2 puede bastar, pero cuando m es una masa estelar hay que tener cuidado. ¿cuántas estrellas habrá engullido este monstruo antes de saciar su apetito? el tamaño del vacío central podría ser una pista. la imagen de m104 de la portada es una combinación de la famosa fotografía del hubble (imagen superior) y la reciente imagen de infrarrojos del observatorio orbital spitzer (inferior). esta última muestra claramente la forma de anillo de la galaxia. a la luz, sólo vemos el borde frontal de la silueta del anillo. 19imagen de portada: © spitzet space telescope. la masa central oculta el resto. pero en la imagen de infrarrojos, las partículas calientes del anillo brillan a través de la masa central. las dos imágenes combinadas nos ofrecen una vista desconocida hasta ahora e implican que hace tiempo era un auténtico infierno activo. 201 código limpio está leyendo este libro por dos motivos. por un lado, es programador. por otro, quiere ser mejor programador. perfecto. necesitamos mejores 21programadores. este libro trata sobre programación correcta. está repleto de código. lo analizaremos desde todas las direcciones. desde arriba, desde abajo y desde dentro. cuando terminemos, sabremos mucho sobre código y, en especial sabremos distinguir entre código correcto e incorrecto. sabremos cómo escribir código correcto y cómo transformar código incorrecto en código correcto. hágase el código se podría afirmar que un libro sobre código es algo obsoleto, que el código ya no es el problema y que deberíamos centrarnos en modelos y requisitos. hay quienes sugieren que el final del código está próximo. que los programadores ya no serán necesarios porque los empresarios generarán programas a partir de especificaciones. no es cierto. el código nunca desaparecerá, ya que representa los detalles de los requisitos. en algún nivel, dichos detalles no se pueden ignorar ni abstraer; deben especificarse, y para especificar requisitos de forma que un equipo pueda ejecutarlos se necesita la programación. dicha especificación es el código. espero que el nivel de abstracción de nuestros lenguajes siga aumentando. también espero que aumente el número de lenguajes específicos de dominios. será algo positivo, pero no eliminará el código. de hecho, todas las especificaciones creadas en estos lenguajes de nivel superior y específicos de los dominios serán código, y tendrá que ser riguroso, preciso, formal y detallado para que un equipo pueda entenderlo y ejecutarlo. el que piense que el código va a desaparecer es como el matemático que espera que un día las matemáticas no sean formales. esperan descubrir una forma de crear máquinas que hagan lo que queramos en lugar de lo que digamos. esas máquinas tendrían que entendernos de tal forma que puedan traducir necesidades ambiguas en programas perfectamente ejecutados que satisfagan dichas necesidades a la perfección. esto nunca sucederá. ni siquiera los humanos, con toda su intuición y 22creatividad, han sido capaces de crear sistemas satisfactorios a partir de las sensaciones de sus clientes. en realidad, si la disciplina de la especificación de requisitos nos ha enseñado algo es que los requisitos bien especificados son tan formales como el código y que pueden actuar como pruebas ejecutables de dicho código. recuerde que el código es básicamente el lenguaje en el que expresamos los requisitos en última instancia. podemos crear lenguajes que se asemejen a dichos requisitos. podemos crear herramientas que nos permitan analizar y combinar dichos requisitos en estructuras formales, pero nunca eliminaremos la precisión necesaria; por ello, siempre habrá código. código incorrecto recientemente leí el prólogo del libro implementation pattern [1] de kent beck, donde afirmaba que «…este libro se basa en una frágil premisa: que el código correcto es relevante…». ¿una frágil premisa? en absoluto. considero que es una de las más robustas, admitidas e importantes de nuestro sector (y creo que kent lo sabe). sabemos que el código correcto es relevante porque durante mucho tiempo hemos tenido que sufrir su ausencia. sé de una empresa que, a finales de la década de 1980, creó una magnífica aplicación, muy popular y que muchos profesionales compraron y utilizaron. pero los ciclos de publicación empezaron a distanciarse. no se corrigieron los errores entre una versión y la siguiente. crecieron los tiempos de carga y aumentaron los fallos. todavía recuerdo el día en que apagué el producto y nunca más lo volví a usar. poco después, la empresa desapareció. 23dos décadas después conocí a uno de los empleados de la empresa y le pregunté sobre lo que había pasado. la respuesta confirmó mis temores. habían comercializado el producto antes de tiempo con graves fallos en el código. al añadir nuevas funciones, el código empeoró hasta que ya no pudieron controlarlo. el código incorrecto fue el motivo del fin de la empresa . ¿en alguna ocasión el código incorrecto le ha supuesto un obstáculo? si es programador seguramente sí. de hecho, tenemos una palabra que lo describe: sortear . tenemos que sortear el código incorrecto. nos arrastramos por una maraña de zarzas y trampas ocultas. intentamos buscar el camino, una pista de lo que está pasando, pero lo único que vemos es más y más código sin sentido. sin duda el código incorrecto le ha supuesto un obstáculo. entonces, ¿por qué lo escribió? ¿tenía prisa? ¿plazos de entrega? seguramente. puede que pensara que no tenía tiempo para hacer un buen trabajo; que su jefe se enfadaría si necesitaba tiempo para limpiar su código. o puede que estuviera cansado de trabajar en ese programa y quisiera acabar cuanto antes. o que viera el trabajo pendiente y tuviera que acabar con un módulo para pasar al siguiente. a todos nos ha pasado. todos hemos visto el lío en el que estábamos y hemos optado por dejarlo para otro día. todos hemos sentido el alivio de ver cómo un programa incorrecto funcionaba y hemos decidido que un mal programa que funciona es mejor que nada. todos hemos dicho que lo solucionaríamos después. evidentemente, por aquel entonces, no conocíamos la ley de leblanc: después es igual a nunca . el coste total de un desastre si es programador desde hace dos o tres años, probablemente haya sufrido los desastres cometidos por otros en el código. si tiene más experiencia, lo habrá sufrido en mayor medida. el grado de sufrimiento puede ser significativo. en un periodo de un año o dos, los equipos que avancen rápidamente al inicio de 24un proyecto pueden acabar a paso de tortuga. cada cambio en el código afecta a dos o tres partes del mismo. ningún cambio es trivial. para ampliar o modificar el sistema es necesario comprender todos los detalles, efectos y consecuencias, para de ese modo poder añadir nuevos detalles, efectos y consecuencias. con el tiempo, el desastre aumenta de tal modo que no se puede remediar. es imposible. al aumentar este desastre, la productividad del equipo disminuye y acaba por desaparecer. al reducirse la productividad, el director hace lo único que puede: ampliar la plantilla del proyecto con la esperanza de aumentar la productividad. pero esa nueva plantilla no conoce el diseño del sistema. no conocen la diferencia entre un cambio adecuado al objetivo de diseño y otro que lo destroce. por tanto, todos se encuentran sometidos a una gran presión para aumentar la productividad. por ello, cometen más errores, aumenta el desastre y la productividad se acerca a cero cada vez más (véase la figura 1.1). figura 1.1. productividad frente a tiempo. el gran cambio de diseño en última instancia, el equipo se rebela. informan al director que no pueden seguir trabajando con ese código. exigen un cambio de diseño. la dirección no requiere invertir en un cambio de diseño del proyecto, pero no puede ignorar el bajo nivel de productividad. 25acaba por ceder a las exigencias de los programadores y autoriza el gran cambio de diseño. se selecciona un nuevo equipo. todos quieren formar parte del nuevo equipo por ser un lienzo en blanco. pueden empezar de cero y crear algo realmente bello, pero sólo los mejores serán elegidos para el nuevo equipo. los demás deben continuar con el mantenimiento del sistema actual. ahora los dos equipos compiten. el nuevo debe crear un sistema que haga lo que el antiguo no puede. además, deben asumir los cambios que continuamente se aplican al sistema antiguo. la dirección no sustituirá el sistema antiguo hasta que el nuevo sea capaz de hacer todo lo que hace el antiguo. esta competición puede durar mucho tiempo. conozco casos de casi 10 años. y cuando acaba, los miembros originales del equipo nuevo han desaparecido y los miembros actuales exigen un cambio de diseño del nuevo sistema porque es un desastre. si ha experimentado alguna fase de esta historia, ya sabrá que dedicar tiempo a que el código sea correcto no sólo es rentable, es una cuestión de supervivencia profesional. actitud ¿alguna vez ha tenido que superar un desastre tan grave que ha tardado semanas en lo que normalmente hubiera tardado horas? ¿ha visto un cambio que debería haberse realizado en una línea, aplicado en cientos de módulos distintos? son síntomas demasiado habituales. ¿por qué sucede en el código? ¿por qué el código de calidad se transforma tan rápidamente en código incorrecto? hay muchas explicaciones. nos quejamos de que los requisitos cambian de forma que comprometen el diseño original, de que los plazos de entrega son demasiado exigentes para hacer las cosas bien. culpamos a directores incompetentes, a usuarios intolerantes y a comerciales sin sentido. pero la culpa, querido dilbert, es nuestra. no somos profesionales. puede que resulte duro escucharlo. ¿cómo es posible que seamos responsables de tales desastres? ¿qué pasa con los requisitos? ¿y los plazos de entrega? ¿y los directores incompetentes y los comerciales sin sentido? 26¿no es también culpa suya? no. los directores y los comerciales nos exigen la información que necesitan para realizar sus promesas y compromisos, e incluso cuando no recurren a nosotros, no debemos tener miedo a decirles lo que pensamos. los usuarios acuden a nosotros para validar la forma de encajar los requisitos en el sistema. los directores de proyectos acuden a nosotros para determinar los objetivos. somos cómplices en la programación del proyecto y compartimos gran parte de la responsabilidad de los fallos, en especial si tienen que ver con código incorrecto. seguramente piense que, si no hace lo que su jefe le dice, le despedirán. es improbable. muchos jefes sólo quieren la verdad, aunque lo disimulen. muchos quieren código correcto, aunque estén obsesionados con los objetivos. pueden defender apasionadamente los objetivos y los requisitos, pero es su trabajo. el nuestro es defender el código con la misma intensidad. para resumir, imagine que es médico y un paciente le exige que no se lave las manos antes de una operación porque se pierde demasiado tiempo [2] . en este caso, el paciente es el jefe, pero el médico debe negarse a lo que pide. ¿por qué? porque el médico sabe más que el paciente sobre los riesgos de infecciones. no sería profesional (incluso sería ilegal) que el médico cediera a las exigencias del paciente. tampoco sería profesional que los programadores cedieran a la voluntad de los jefes que no entienden los riesgos de un posible desastre. el enigma los programadores se enfrentan a un enigma de valores básicos. los que tienen años de experiencia saben que un desastre ralentiza su trabajo, y aun así todos los programadores sienten la presión de cometer errores para poder cumplir los plazos de entrega. en definitiva, no toman el tiempo necesario para avanzar. los verdaderos profesionales saben que la segunda parte del enigma no es cierta. no se cumple un plazo de entrega cometiendo un error. de hecho, el error nos ralentiza de forma inmediata y hace que no lleguemos al plazo de entrega. la única forma de cumplirlo, la única forma de avanzar, es intentar 27que el código siempre sea limpio. ¿el arte del código limpio? imagine que cree que el código incorrecto es un obstáculo significativo. imagine que acepta que la única forma de avanzar es mantener el código limpio. entonces se preguntará cómo crear código limpio. no tiene sentido intentar crearlo si no sabe lo que es. la mala noticia es que crear código limpio es como pintar un cuadro. muchos sabemos si un cuadro se ha pintado bien o no, pero poder reconocer la calidad de una obra no significa que sepamos pintar. por ello, reconocer código limpio no significa que sepamos cómo crearlo. para crearlo se requiere el uso disciplinado de miles de técnicas aplicadas mediante un detallado sentido de la «corrección». este sentido del código es la clave. algunos nacen con este sentido. otros han de luchar para conseguirlo. no sólo permite distinguir entre código correcto e incorrecto, sino que también muestra la estrategia para aplicar nuestra disciplina y transformar código incorrecto en código correcto. un programador sin este sentido puede reconocer el desastre cometido en un módulo, pero no saber cómo solucionarlo. un programador con este sentido verá las posibles opciones y elegirá la variante óptima para definir una secuencia de cambios. en definitiva, un programador que cree código limpio es un artista que puede transformar un lienzo en blanco en un sistema de código elegante. concepto de código limpio existen tantas definiciones como programadores. por ello, he consultado la opinión de conocidos y experimentados programadores. bjarne stroustrup, inventor de c++ y autor de the c++ programming language 28me gusta que mi código sea elegante y eficaz. la lógica debe ser directa para evitar errores ocultos, las dependencias deben ser mínimas para facilitar el mantenimiento, el procesamiento de errores completo y sujeto a una estrategia articulada, y el rendimiento debe ser óptimo para que los usuarios no tiendan a estropear el código con optimizaciones sin sentido. el código limpio hace bien una cosa. bjarne usa la palabra «elegante». menuda palabra. según el diccionario, «elegante» significa « dotado de gracia, nobleza y sencillez ». aparentemente bjarne piensa que el código limpio es un placer a la hora de leerlo. su lectura debe hacernos sonreír, como una caja de música o un coche bien diseñado. bjarne también menciona la eficacia, en dos ocasiones . no debería sorprendemos viniendo del inventor de c++; pero considero que hay algo más que el mero deseo de velocidad. los ciclos malgastados no son elegantes, no son un placer. y fíjese en la palabra empleada por bjarne para describir la consecuencia de esta falta de elegancia. usa tiendan . una gran verdad. el código incorrecto tiende a aumentar el desastre. cuando otros cambian código incorrecto, tienden a empeorarlo. dave thomas y andy hunt lo expresan de forma diferente. usan la metáfora de las ventanas rotas [3] . un edificio con ventanas rotas parece abandonado. y hace que otros lo abandonen. dejan que se rompan otras ventanas. e incluso las rompen a propósito. la fachada se ensucia con pintadas y se acumula la basura. una ventana rota inicia el proceso de la decadencia. bjarne también menciona que el procesamiento de errores debe ser completo, lo que se relaciona con la disciplina de prestar atención a los detalles. el procesamiento de errores abreviado es una forma de ignorar los detalles. otras son las fugas de memoria, las condiciones de carrera o el uso 29incoherente de los nombres. en definitiva, el código limpio muestra gran atención al detalle. bjarne termina afirmando que el código limpio hace una cosa bien . no es accidental que existan tantos principios de diseño de software que se puedan reducir a esta sencilla máxima. muchos escritores han tratado de comunicar este pensamiento. el código incorrecto intenta hacer demasiadas cosas y su cometido es ambiguo y enrevesado. el código limpio es concreto . cada función, cada clase y cada módulo muestran una única actitud que se mantiene invariable y no se contamina por los detalles circundantes. grady booch, autor de object oriented analysis and design with applications el código limpio es simple y directo. el código limpio se lee como un texto bien escrito. el código limpio no oculta la intención del diseñador, sino que muestra nítidas abstracciones y líneas directas de control. grady mantiene las mismas ideas que bjarne, pero adopta una perspectiva de legibilidad . me gusta especialmente que el código limpio se pueda leer como un texto bien escrito. piense en un buen libro. recordará que las palabras desaparecen y se sustituyen por imágenes, como ver una película. mejor todavía. es ver los caracteres, escuchar los sonidos, experimentar las sensaciones. leer código limpio nunca será como leer el señor de los anillos . pero esta metáfora literaria no es incorrecta. como una buena novela, el código limpio debe mostrar de forma clara el suspense del problema que hay que resolver. debe llevar ese suspense hasta un punto álgido para después demostrar al lector que los problemas y el suspense se han solucionado de forma evidente. 30la frase «nítida abstracción» de grady es un oxímoron fascinante. nítido es casi un sinónimo de concreto, con un potente mensaje. el código debe ser específico y no especulativo. sólo debe incluir lo necesario. nuestros lectores deben percibir que hemos tomado decisiones. «big» dave thomas, fundador de oti, el padrino de la estrategia eclipse el código limpio se puede leer y mejorar por parte de un programador que no sea su autor original. tiene pruebas de unidad y de aceptación. tiene nombres con sentido. ofrece una y no varias formas de hacer algo. sus dependencias son mínimas, se definen de forma explícita y ofrece una api clara y mínima. el código debe ser culto en función del lenguaje, ya que no toda la información necesaria se puede expresar de forma clara en el código. big dave comparte el deseo de grady de la legibilidad, pero con una importante variante. dave afirma que el código limpio facilita las labores de mejora de otros . puede parecer evidente pero no debemos excedernos. después de todo, existe una diferencia entre el código fácil de leer y el código fácil de cambiar. dave vincula la limpieza a las pruebas. hace 10 años esto hubiera provocado cierta controversia. pero la disciplina del desarrollo controlado por pruebas ha tenido un gran impacto en nuestro sector y se ha convertido en uno de sus pilares. dave tiene razón. el código, sin pruebas, no es limpio. independientemente de su elegancia, legibilidad y accesibilidad, si no tiene pruebas, no será limpio. dave usa dos veces la palabra mínimo . valora el código de tamaño 31reducido, una opinión habitual en la literatura de software desde su concepción. cuanto más pequeño, mejor. también afirma que el código debe ser culto , una referencia indirecta a la programación de knuth [4] y que en definitiva indica que el código debe redactarse de una forma legible para los humanos. michael feathers, autor de working effectively with legacy code podría enumerar todas las cualidades del código limpio, pero hay una principal que engloba a todas ellas. el código limpio siempre parece que ha sido escrito por alguien a quien le importa. no hay nada evidente que hacer para mejorarlo. el autor del código pensó en todos los aspectos posibles y si intentamos imaginar alguna mejora, volvemos al punto de partida y sólo nos queda disfrutar del código que alguien a quien le importa realmente nos ha proporcionado. una palabra; dar importancia. es el verdadero tema de este libro, que incluso podría usar el subtítulo « cómo dar importancia al código ». michael ha acertado de pleno. el código limpio es aquél al que se le ha dado importancia. alguien ha dedicado su tiempo para que sea sencillo y ha prestado atención a los detalles. se ha preocupado. ron jeffries, autor de extreme programming installed y extreme programming adventures in c# 32ron comenzó su carrera como programador con fortran en strategic air command y ha escrito código para la práctica totalidad de lenguajes y equipos. merece la pena fijarse en sus palabras: en los últimos años, comencé y prácticamente terminé con las reglas de código simple de beck. en orden de prioridad, el código simple: ejecuta todas las pruebas. no contiene duplicados. expresa todos los conceptos de diseño del sistema. minimiza el número de entidades como clases, métodos, funciones y similares. de todos ellos, me quedo con la duplicación. cuando algo se repite una y otra vez, es una señal de que tenemos una idea que no acabamos de representar correctamente en el código. intento determinar cuál es y, después, expresar esa idea con mayor claridad. para mí, la expresividad debe incluir nombres con sentido y estoy dispuesto a cambiar los nombres de las cosas varias veces. con las modernas herramientas de creación de código como eclipse, el cambio de nombres es muy sencillo, por lo que no me supone problema alguno. la expresividad va más allá de los nombres. también me fijo si un objeto o un método hacen más de una cosa. si se trata de un objeto, probablemente tenga que dividirse en dos o más. si se trata de un método, siempre recurro a la refactorización de extracción de métodos para generar un método que exprese con mayor claridad su cometido y varios métodos secundarios que expliquen cómo lo hace. la duplicación y la expresividad son dos factores que permiten mejorar considerablemente código que no sea limpio. sin embargo, 33existe otra cosa que también hago conscientemente, aunque sea más difícil de explicar. tras años en este trabajo, creo que todos los programas están formados de elementos muy similares. un ejemplo es la búsqueda de elementos en una colección. independientemente de que sea una base de datos de registros de empleados o un mapa de claves y valores, o una matriz de elementos, por lo general tenemos que buscar un elemento concreto de esa colección. cuando esto sucede, suelo incluir esa implementación concreta en un método o una clase más abstractos. de ese modo disfruto de una serie de interesantes ventajas. puedo implementar la funcionalidad con algo sencillo, como un mapa hash, por ejemplo, pero como ahora todas las referencias a la búsqueda se ocultan en mi pequeña abstracción, puedo modificar la implementación siempre que desee. puedo avanzar rápidamente al tiempo que conservo la posibilidad de realizar cambios posteriores. además, la abstracción de la colección suele captar mi atención en lo que realmente sucede e impide que implemente comportamientos de colecciones arbitrarias si lo que realmente necesito es una forma sencilla de localizar un elemento. reducir los duplicados, maximizar la expresividad y diseñar sencillas abstracciones en las fases iniciales. para mí, es lo que hace que el código sea limpio. en estos breves párrafos, ron resume el contenido de este libro. nada de duplicados, un objetivo, expresividad y pequeñas abstracciones. todo está ahí. ward cunningham, inventor de wiki, fit, y uno de los inventores de la programación extreme. uno de los impulsores de los patrones de diseño. una de las mentes tras smalltalk y la programación orientada a objetos. el padrino de todos a los que les importa el código. 34sabemos que estamos trabajando con código limpio cuando cada rutina que leemos resulta ser lo que esperábamos. se puede denominar código atractivo cuando el código hace que parezca que el lenguaje se ha creado para el problema en cuestión. este tipo de afirmaciones son características de ward. las leemos, asentimos y pasamos a la siguiente. es tan razonable y evidente que apenas parece profundo. incluso podemos pensar que es lo que esperábamos. pero preste atención. «… resulta ser lo que esperábamos». ¿cuándo fue la última vez que vio un módulo que fuera más o menos lo que esperaba? ¿lo habitual no es ver módulos complicados y enrevesados? ¿no es esta falta de concreción lo habitual? ¿no está acostumbrado a intentar extraer el razonamiento de un sistema para llegar al módulo que está leyendo? ¿cuándo fue la última vez que leyó un código y asintió como seguramente haya hecho al leer la afirmación de ward? ward espera que al leer código limpio no le sorprenda. de hecho, ni siquiera tendrá que esforzarse. lo leerá y será prácticamente lo que esperaba. será evidente, sencillo y atractivo. cada módulo prepara el camino del siguiente. cada uno indica cómo se escribirá el siguiente. los programas limpios están tan bien escritos que ni siquiera se dará cuenta. el diseñador consigue simplificarlo todo enormemente, como sucede con todos los diseños excepcionales. ¿y la noción de atractivo de ward? todos hemos criticado que nuestros lenguajes no se hayan diseñado para nuestros problemas. pero la afirmación de ward hace que ahora la responsabilidad sea nuestra. afirma que el código atractivo hace que el lenguaje parezca creado para el problema . por tanto, somos responsables de que el lenguaje parezca sencillo. no es el lenguaje el que hace que los programas parezcan sencillos, sino el programador que consigue que el lenguaje lo parezca. 35escuelas de pensamiento ¿y yo (uncle bob)? ¿qué es para mí el código limpio? en este libro le contaremos, con todo detalle, lo que yo y mis colegas pensamos del código limpio. le contaremos lo que pensamos que hace que un nombre de variable, una función o una clase sean limpias. presentaremos estas opiniones de forma absoluta, sin disculparnos. en este punto de nuestra carrera, ya son absolutas. son nuestra escuela de pensamiento del código limpio. los especialistas de las artes marciales no se ponen de acuerdo sobre cuál es la mejor de todas, ni siquiera sobre cuál es la mejor técnica de un arte marcial. es habitual que los maestros de las artes marciales creen sus propias escuelas de pensamiento y los alumnos aprendan de ellos. de esta forma nació gracie jiu jitsu , creada e impartida por la familia gracie en brasil; hakkoryu jiu jitsu , fundada e impartida por okuyama ryuho en tokio o jeet kune do , fundada e impartida por bruce lee en estados unidos. los alumnos de estas disciplinas se sumergen en las enseñanzas del fundador. se dedican a aprender lo que su maestro les enseña y suelen excluir las enseñanzas de otros maestros. después, cuando han mejorado su arte, pueden convertirse en alumnos de otro maestro diferente para ampliar sus conocimientos y su experiencia. algunos seguirán mejorando sus habilidades, descubriendo nuevas técnicas y fundando sus propias escuelas. ninguna de estas escuelas tiene la razón absoluta pero dentro de cada una actuamos como si las enseñanzas y las técnicas fueran correctas. después de todo, existe una forma correcta de practicar hakkoryu jiu jitsu o jeet kune do, pero esta corrección dentro de una escuela determinada no anula las enseñanzas de otra diferente. 36imagine que este libro es una descripción de la escuela de mentores del código limpio . las técnicas y enseñanzas impartidas son la forma en la que practicamos nuestro arte. podemos afirmar que, si sigue nuestras enseñanzas, disfrutará de lo que hemos disfrutado nosotros, y aprenderá a crear código limpio y profesional. pero no cometa el error de pensar que somos los únicos que tenemos razón. existen otras escuelas y otros maestros tan profesionales como nosotros, y su labor es aprender de ellos también. de hecho, muchas de las recomendaciones del libro son controvertidas, seguramente no esté de acuerdo con muchas de ellas y puede que rechace algunas de forma definitiva. es correcto. no somos la autoridad final. pero, por otra parte, las recomendaciones del libro son algo en lo que hemos pensado mucho. las hemos aprendido tras décadas de experiencia y ensayo y error. por lo tanto, esté o no de acuerdo, sería una lástima que no apreciara, y respetara, nuestro punto de vista. somos autores el campo @author de un javadoc indica quiénes somos. somos autores. y los autores tienen lectores. de hecho, los autores son responsables de comunicarse correctamente con sus lectores. la próxima vez que escriba una línea de código, recuerde que es un autor y que escribe para que sus lectores juzguen su esfuerzo. seguramente se pregunte qué cantidad de código se lee realmente y si la mayor parte del esfuerzo no se concentra en crearlo. ¿alguna vez ha reproducido una sesión de edición? en las décadas de 1980 y 1990 teníamos editores como emacs que controlaban cada pulsación de tecla. se podía trabajar durante una hora y después reproducir la sesión de edición completa como una película a alta velocidad. cuando lo hice, los resultados fueron fascinantes. la mayor parte de la reproducción eran desplazamientos entre módulos. bob accede al módulo. se desplaza hasta la función que tiene que cambiar. 37se detiene y piensa en las posibles opciones. oh, vuelve al inicio del módulo para comprobar la inicialización de una variable. ahora vuelve a bajar y comienza a escribir. vaya, borra lo que había escrito. vuelve a escribirlo. lo vuelve a borrar. escribe algo diferente pero también lo borra. se desplaza a otra función que invoca la función que está modificando para comprobar cómo se invoca. vuelve a subir y escribe el mismo código que acaba de borrar. se detiene. vuelve a borrar el código. abre otra ventana y examina las subclases. ¿se ha reemplazado esa función? … se hace una idea. en realidad, la proporción entre tiempo dedicado a leer frente a tiempo dedicado a escribir es de más de 10:1. constantemente tenemos que leer código antiguo como parte del esfuerzo de crear código nuevo. al ser una proporción tan elevada, queremos que la lectura del código sea sencilla, aunque eso complique su creación. evidentemente, no se puede escribir código sin leerlo, de modo que si es más fácil de leer será más fácil de escribir . es una lógica sin escapatoria. no se puede escribir código si no se puede leer el código circundante. el código que intente escribir hoy será fácil o difícil de escribir en función de lo fácil o difícil de leer que sea el código circundante. si quiere avanzar rápidamente, terminar cuanto antes y que su código sea fácil de escribir, haga que sea fácil de leer. la regla del boy scout 38no basta con escribir código correctamente. el código debe limpiarse con el tiempo. todos hemos visto que el código se corrompe con el tiempo, de modo que debemos adoptar un papel activo para evitarlo. los boy scouts norteamericanos tienen una sencilla regla que podemos aplicar a nuestra profesión: dejar el campamento más limpio de lo que se ha encontrado [5] . si todos entregamos el código más limpio de lo que lo hemos recibido, no se corromperá. no hace falta que la limpieza sea masiva. cambie el nombre de una variable, divida una función demasiado extensa, elimine elementos duplicados, simplifique una instrucción if compuesta. ¿se imagina trabajar en un proyecto en el que el código mejorara con el tiempo? ¿cree que hay otras opciones que puedan considerarse profesionales? de hecho, ¿la mejora continuada no es una parte intrínseca de la profesionalidad? precuela y principios en muchos aspectos, este libro es una «precuela» de otro que escribí en 2002 titulado agile software development: principles, patterns, and practices (ppp). el libro ppp trata sobre los principios del diseño orientado a objetos y muchas de las técnicas empleadas por desarrolladores profesionales. si no ha leído ppp, comprobará que continúa la historia contada en este libro. si lo ha leído, encontrará muchas de las sensaciones de ese libro reproducidas en éste a nivel del código. en este libro encontrará referencias esporádicas a distintos principios de diseño como srp ( single responsibility principle o principio de responsabilidad única), ocp ( open closed principle o principio abierto/cerrado) y dip ( dependency inversion principle o principio de inversión de dependencias) entre otros. todos estos principios se describen detalladamente en ppp. 39conclusión los libros sobre arte no le prometen que se convertirá en artista. solamente pueden mostrarle herramientas, técnicas y procesos de pensamiento que otros artistas hayan utilizado. del mismo modo, este libro no puede prometer que se convierta en un buen programador, que tenga sentido del código. sólo puede mostrarle los procesos de pensamiento de buenos programadores y los trucos, técnicas y herramientas que emplean. al igual que un libro sobre arte, este libro está repleto de detalles. encontrará mucho código. verá código correcto y código incorrecto. verá código incorrecto transformado en código correcto. verá listas de heurística, disciplinas y técnicas. verá un ejemplo tras otro. y después de todo, será responsabilidad suya. ¿recuerda el chiste sobre el violinista que se pierde camino de un concierto? se cruza con un anciano y le pregunta cómo llegar al teatro real. el anciano mira al violinista y al violín que lleva bajo el brazo y le responde: «practique joven, practique». bibliografía [beck07] : implementation patterns , kent beck, addison-wesley, 2007. [knuth92] : literate programming , donald e. knuth, center for the study of language and information, leland stanford junior university, 1992. 402 nombres con sentido por tim ottinger introducción en el software , los nombres son omnipresentes. aparecen en variables, 41funciones, argumentos, clases y paquetes. asignamos nombres a archivos y a directorios, a archivos jar, war y ear. usamos nombres constantemente. por ello, debemos hacerlo bien. a continuación, veremos algunas reglas básicas para crear nombres correctos. usar nombres que revelen las intenciones es fácil afirmar que los nombres deben revelar nuestras intenciones. lo que queremos recalcar es la importancia de hacerlo. elegir nombres correctos lleva tiempo, pero también ahorra trabajo. por ello, preste atención a los nombres y cámbielos cuando encuentre otros mejores. todo el que lea su código se lo agradecerá. el nombre de una variable, función o clase debe responder una serie de cuestiones básicas. debe indicar por qué existe, qué hace y cómo se usa. si un nombre requiere un comentario, significa que no revela su cometido. int d; // tiempo transcurrido en días el nombre d no revela nada. no evoca una sensación de tiempo transcurrido, ni de días. debe elegir un nombre que especifique lo que se mide y la unidad de dicha medida: int elapsedtimeindays; int dayssincecreation; int dayssincemodification; int fileageindays; la elección de nombres que revelen intenciones facilita considerablemente la comprensión y la modificación del código. ¿para qué sirve el siguiente código? public list<int[]> getthem() { list<int[]> list1 = new arraylist<int[]>(); for (int[] x : thelist) if (x[0] == 4) list1.add(x); return list1; } ¿por qué es complicado saber la función de este código? no hay expresiones complejas. los espacios y el sangrado son razonables. sólo hay tres variables y dos constantes. ni siquiera contiene clases complejas o 42métodos polimórficos, sólo una lista de matrices (o eso parece). el problema no es la simplicidad del código sino su carácter implícito : el grado en el que el contexto no es explícito en el propio código. implícitamente, el código requiere que sepamos las respuestas a las siguientes preguntas: ¿qué contiene thelist ? ¿qué significado tiene el subíndice cero de un elemento de thelist ? ¿qué importancia tiene el valor 4 ? ¿cómo se usa la lista devuelta? las respuestas a estas preguntas no se encuentran en el código, pero se podrían haber incluido. imagine que trabaja en un juego de buscar minas. el tablero es una lista de celdas llamada thelist . cambiemos el nombre por gameboard . cada celda del teclado se representa por medio de una matriz. el subíndice cero es la ubicación de un valor de estado que, cuando es 4 , significa que se ha detectado. al asignar nombres a estos conceptos mejoramos considerablemente el código: public list<int[]> getflaggedcells() { list<int[]> flaggedcells = new arraylist<int[]>(); for (int[] cell : gameboard) if (cell[status_value] == flagged) flaggedcells.add(cell); return flaggedcells; } la simplicidad del código no ha cambiado. sigue teniendo los mismos operadores y constantes y el mismo número de niveles anidados, pero ahora es mucho más explícito. podemos crear una sencilla clase para celdas en lugar de usar una matriz de elementos int . puede incluir una función que revele el objetivo (con el nombre isflagged ) para ocultar los números. el resultado es una nueva versión de la función: public list<cell> getflaggedcells() { list<cell> flaggedcells = new arraylist<cell>(); for (cell cell : gameboard) if (cell.isflagged()) flaggedcells.add(cell); 43return flaggedcells; } con estos sencillos cambios de nombre, es fácil saber qué sucede. es la ventaja de seleccionar nombres adecuados. evitar la desinformación los programadores deben evitar dejar pistas falsas que dificulten el significado del código. debemos evitar palabras cuyo significado se aleje del que pretendemos. por ejemplo, hp , aix y sco son nombres de variables pobres ya que son los nombres de plataformas o variantes de unix. aunque se trate del código de una hipotenusa y hp parezca la abreviatura correcta, puede no serlo. no haga referencia a un grupo de cuentas como accountlist a menos que realmente sea una lista ( list ). la palabra lista tiene un significado concreto para los programadores. si el contenedor de las cuentas no es realmente una lista, puede provocar falsas conclusiones [6] . por tanto, resulta más adecuado usar accountgroup , bunchofaccounts o simplemente accounts . evite usar nombres con variaciones mínimas. ¿cuánto se tarda en apreciar la sutil diferencia entre xyzcontrollerforefficienthandlingofstrings y xyzcontrollerforefficientstorageofstrings en un módulo? ambas palabras tienen una forma similar. la ortografía similar de conceptos parecidos es información; el uso de ortografía incoherente es desinformación. en los entornos modernos de java, el código se completa de forma automática. escribimos varios caracteres de un nombre y pulsamos varias teclas para obtener una lista de posibles opciones de un nombre. es muy útil si los nombres de elementos similares se ordenan alfabéticamente de forma conjunta y si las diferencias son muy evidentes, ya que es probable que el programador elija un objeto por nombre sin fijarse en los comentarios o la lista de métodos proporcionados por una clase. 44un ejemplo de nombre desinformativo sería el uso de la l minúscula o la o mayúscula como nombres de variables, sobre todo combinados. el problema, evidentemente, es que se parecen a las constantes 1 y 0 respectivamente: int a = l; if ( o == l ) a = o1; else l = 01; el lector puede pensar que es una invención, pero hemos visto código con abundancia de estos elementos. en un caso, el autor del código, sugirió usar una fuente distinta para que las diferencias fueran más evidentes, una solución que se hubiera transmitido a todos los futuros programadores como tradición oral o en un documento escrito. el problema se resolvió con carácter definitivo y sin necesidad de crear nuevos productos, con tan sólo cambiar los nombres. realizar distinciones con sentido los programadores se crean un problema al crear código únicamente dirigido a un compilador o intérprete. por ejemplo, como se puede usar el mismo nombre para hacer referencia a dos elementos distintos en el mismo ámbito, puede verse tentado a cambiar un nombre de forma arbitraria. en ocasiones se hace escribiéndolo incorrectamente, lo que provoca que los errores ortográficos impidan la compilación [7] . no basta con añadir series de números o palabras adicionales, aunque eso satisfaga al compilador. si los nombres tienen que ser distintos, también deben tener un significado diferente. los nombres de series numéricas ( a1 , a2 … an ) son lo contrario a los nombres intencionados. no desinforman, simplemente no ofrecen información; son una pista sobre la intención del autor. fíjese en lo siguiente: 45public static void copychars(char a1[], char a2[]) { for (int i = 0; i < a1.length; i++) { a2[i] = a1[i]; } } esta función se lee mejor cuando se usa source y destination como nombres de argumentos. las palabras adicionales son otra distinción sin sentido. imagine que tiene la clase product. si tiene otra clase con el nombre productinfo o productdata , habrá creado nombres distintos, pero con el mismo significado. info y data son palabras adicionales, como a , an y the . no es incorrecto usar prefijos como a y the mientras la distinción tenga sentido. imagine que usa a para variables locales y for para argumentos de funciones [8] . el problema aparece cuando decide invocar la variable thezork porque ya tiene otra variable con el nombre zork . las palabras adicionales son redundantes. la palabra variable no debe incluirse nunca en el nombre de una variable. la palabra table no debe incluirse nunca en el nombre de una tabla. ¿es mejor namestring que name ? ¿podría ser name un número de coma flotante? en caso afirmativo, incumple la regla anterior sobre desinformación. imagine que encuentra una clase con el nombre customer y otra con el nombre customerobject . ¿cuál sería la distinción? ¿cuál representa mejor el historial de pagos de un cliente? existe una aplicación que lo ilustra. hemos cambiado los nombres para proteger al culpable. veamos el error exacto: getactiveaccount(); getactiveaccounts(); getactiveaccountinfo(); ¿cómo saben los programadores de este proyecto qué función deben invocar? en ausencia de convenciones concretas, la variable moneyamount no se distingue de money , customerinfo no se distingue de customer , accountdata no se distingue de account y themessage no se distingue de message . debe diferenciar los nombres de forma que el lector aprecie las diferencias. 46usar nombres que se puedan pronunciar a los humanos se nos dan bien las palabras. gran parte de nuestro cerebro se dedica al concepto de palabras. y, por definición, las palabras son pronunciables. sería una pena malgastar esa parte de nuestro cerebro dedicada al lenguaje hablado. por tanto, cree nombres pronunciables. si no lo puede pronunciar, no podrá explicarlo sin parecer tonto. es un factor importante, ya que la programación es una actividad social. conozco una empresa que usa genymdhms (fecha de generación, año, mes, día, hora, minuto y segundo) y lo pronuncian tal cual. yo tengo la costumbre de pronunciar todo tal y como lo veo escrito, de forma que muchos analistas y diseñadores acabaron por llamarme algo como «genimedemes». era un chiste y nos parecía divertido, pero en realidad estábamos tolerando el uso de nombres pobres. teníamos que explicar las variables a los nuevos programadores y cuando las pronunciaban, usaban palabras inventadas en lugar de nombres correctos. compare: class dtarcrd102 { private date genymdhms; private date modymdhms; private final string pszqint = “102”; /*… */ }; con: class customer { private date generationtimestamp; private date modificationtimestamp; private final string recordid = “102”; /*… */ }; ahora se puede mantener una conversación inteligente: «eh, mikey, fíjate en este registro. la marca de tiempo de generación es para mañana. ¿cómo es posible?» usar nombres que se puedan buscar 47los nombres de una letra y las constantes numéricas tienen un problema: no son fáciles de localizar en el texto. se puede detectar max_classes_per_student , pero el número 7 resulta más complicado. las búsquedas pueden devolver el dígito como parte de nombres de archivo, otras definiciones de constantes o expresiones en las que se use con otra intención. mucho peor si la constante es un número extenso y alguien ha intercambiado los dígitos, lo que genera un error inmediato y no aparece en la búsqueda. del mismo modo, el nombre e es una opción muy pobre para variables que el programador tenga que buscar. es la letra más usada en inglés y aparece en la práctica totalidad de los textos de un programa. a este respecto, los nombres extensos superan a los breves y cualquier nombre que se pueda buscar supera a una constante en el código. personalmente prefiero nombres de una letra que sólo se puedan usar como variables locales dentro de métodos breves. la longitud de un nombre debe corresponderse al tamaño de su ámbito [n5]. si una variable o constante se usa en varios puntos del código, debe asignarle un nombre que se pueda buscar. compare: for (int j=0; j<34; j++) { s += (t[j]*4)/5; } con: int realdaysperidealday = 4; const int work_days_per_week = 5; int sum = 0; for (int j = 0; j < number_of_tasks; j++) { int realtaskdays = taskestimate[j] * realdaysperidealday; int realtaskweeks = (realdays / work_days_per_week); sum += realtaskweeks; } en este ejemplo, sum no es un nombre especialmente útil, pero al menos se puede buscar. se usa una función más extensa, pero comprobará que resulta mucho más fácil buscar work_days_per_week que todas las instancias de 5 y filtrar la lista a los casos con el significado adecuado. evitar codificaciones 48ya tenemos suficientes codificaciones como para tener que añadir otras nuevas. al codificar información de tipos o ámbitos en un nombre se dificulta la descodificación. no parece razonable que todos los nuevos empleados tengan que aprender otro lenguaje de codificación además del código con el que van a trabajar. es una carga mental innecesaria a la hora de intentar solucionar un problema. los nombres codificados resultan impronunciables y suelen escribirse de forma incorrecta. notación húngara antiguamente, cuando trabajábamos con lenguajes en los que la longitud de los nombres era un reto, incumplíamos esta regla a nuestro pesar. fortran forzaba las codificaciones convirtiendo la primera letra de un tipo en código. en sus primeras versiones, basic sólo se permitía una letra y un dígito. la notación húngara (hn) lo llevó a un nuevo nivel. hn se consideraba muy importante en el api c de windows, donde todo era un control entero, un puntero long , un puntero void o una de varias implementaciones de string (con diferentes usos y atributos). por aquel entonces, el compilador no comprobaba los tipos, de modo que los programadores tenían que recordarlos. en los lenguajes modernos disponemos de sistemas de tipos más completos y los compiladores recuerdan los tipos y los aplican. es más, existe una tendencia a usar clases y funciones más breves para que los usuarios aprecien la declaración de las variables que usan. los programadores de java no tienen que codificar tipos. los objetos son de tipos fuertes y los entornos de edición han avanzado tanto que detectan un error de tipo antes de ejecutar la compilación. por ello, en la actualidad hn y otras formas de codificación de tipos no son más que un impedimento. hacen que sea más complicado cambiar el nombre o el tipo de una variable o clase. dificultan la legibilidad del código y pueden hacer que el sistema de codificación confunda al lector: phonenumber phonestring; // el nombre no cambia cuando cambia el tipo 49prefijos de miembros tampoco es necesario añadir m_ como prefijo a los nombres de variables. las clases y funciones tienen el tamaño necesario para no tener que hacerlo, y debe usar un entorno de edición que resalte o coloree los miembros para distinguirlos. public class part { private string m_dsc; // la descripción textual void setname(string name) { m_dsc = name; } } public class part { string description; void setdescription(string description) { this.description = description; } } además, los usuarios aprenden rápidamente a ignorar el prefijo (o sufijo) y fijarse en la parte con sentido del nombre. cuanto más código leemos, menos nos fijamos en los prefijos. en última instancia, los prefijos son un indicio de código antiguo. interfaces e implementaciones existe un caso especial para usar codificaciones. imagine por ejemplo que crea una factoría abstracta para crear formas. esta factoría será una interfaz y se implementará por medio de una clase concreta. ¿qué nombres debe asignar? ¿ ishapefactory y shapefactory ? prefiero las interfaces sin adornos. la i inicial, tan habitual en los archivos de legado actuales es, en el mejor de los casos, una distracción, y en el peor, un exceso de información. no quiero que mis usuarios sepan que se trata de una interfaz, solamente que se trata de shapefactory . si tengo que codificar la interfaz o la implementación, opto por ésta última. es mejor usar shapefactoryimp o incluso cshapefactory , que codificar la interfaz. 50evitar asignaciones mentales los lectores no tienen que traducir mentalmente sus nombres en otros que ya conocen. este problema suele aparecer al elegir entre no usar términos de dominio de problemas o de soluciones. es un problema de los nombres de variables de una sola letra. un contador de bucles se podría bautizar como i , j o k (pero nunca l ) si su ámbito es muy reducido y no hay conflictos con otros nombres, ya que los nombres de una letra son tradicionales en contadores de bucles. sin embargo, en otros contextos, un nombre de una letra es una opción muy pobre: es como un marcador de posición que el lector debe asignar mentalmente a un concepto real. no hay peor motivo para usar el nombre c que a y b ya estén seleccionados. por lo general, los programadores son gente inteligente. a la gente inteligente le gusta presumir de sus habilidades mentales. si puede recordar que r es la versión en minúscula de una url sin el host y el sistema, debe ser muy listo. una diferencia entre un programador inteligente y un programador profesional es que este último sabe que la claridad es lo que importa . los profesionales usan sus poderes para hacer el bien y crean código que otros puedan entender. nombres de clases las clases y los objetos deben tener nombres o frases de nombre como customer , wikipage , account y addressparser . evite palabras como manager , processor , data , o info en el nombre de una clase. el nombre de una clase no debe ser un verbo. nombres de métodos 51los métodos deben tener nombres de verbo como postpayment , deletepage o save . los métodos de acceso, de modificación y los predicados deben tener como nombre su valor y usar como prefijo get , set e is de acuerdo al estándar de javabean [9] . string name = employee.getname(); customer.setname(“mike”); if (paycheck.isposted())… al sobrecargar constructores, use métodos de factoría estáticos con nombres que describan los argumentos. por ejemplo: complex fulcrumpoint = complex.fromrealnumber(23.0); es mejor que: complex fulcrumpoint = new complex(23.0); refuerce su uso convirtiendo en privados sus constructores correspondientes. no se exceda con el atractivo si los nombres son demasiado inteligentes, sólo los recordarán los que compartan el sentido del humor de su autor, y sólo mientras se acuerden del chiste. ¿sabrán qué significa la función holyhandgrenade ? sin duda es atractiva, pero en este caso puede que deleteitems fuera más indicado. opte por la claridad antes que por el entretenimiento. en el código, el atractivo suele aparecer como formas coloquiales o jergas. por ejemplo, no use whack() en lugar de kill() . no recurra a bromas culturales como eatmyshorts() si quiere decir abort() . diga lo que piense. piense lo que diga. una palabra por concepto elija una palabra por cada concepto abstracto y manténgala. por ejemplo, 52resulta confuso usar fetch , retrieve y get como métodos equivalentes de clases distintas. ¿cómo va a recordar qué método se corresponde a cada clase? desafortunadamente, tendrá que recordar qué empresa, grupo o individuo ha creado la biblioteca o clase en cuestión para recordar qué término se ha empleado. en caso contrario, perderá mucho tiempo buscando en encabezados y fragmentos de código. los entornos de edición modernos como eclipse e intellij ofrecen pistas sensibles al contexto, como la lista de métodos que puede invocar en un determinado objeto. pero esta lista no suele incluir los comentarios de nombres de funciones y listas de parámetros. tendrá suerte si muestra los nombres de parámetros de las declaraciones de funciones. los nombres de funciones deben ser independientes y coherentes para que pueda elegir el método correcto sin necesidad de búsquedas adicionales. del mismo modo, resulta confuso tener un controlador, un administrador y un control en la misma base de código. ¿cuál es la diferencia entre devicemanager y protocolcontroller ? ¿por qué no son los dos controladores o administradores? ¿son controladores? el nombre hace que espere que dos objetos tengan un tipo diferente y clases diferentes. un léxico coherente es una gran ventaja para los programadores que tengan que usar su código. no haga juegos de palabras evite usar la misma palabra con dos fines distintos. suele hacerse en juegos de palabras. si aplica la regla de una palabra por conceptos, acabará con muchas clases que por ejemplo tengan un método add . mientras las listas de parámetros y los valores devueltos de los distintos métodos add sean semánticamente equivalentes, no hay problema. sin embargo, alguien puede decidir usar la palabra add por motivos de coherencia, aunque no sea en el mismo sentido. imagine que hay varias clases en las que add crea un nuevo valor sumando o concatenando dos valores existentes. imagine ahora que crea una nueva clase con un método 53que añada su parámetro a una colección. ¿este método debe tener el método add ? parece coherente ya que hay otros muchos métodos add , pero en este caso hay una diferencia semántica, de modo que debemos usar un nombre como insert o append . llamar add al nuevo método sería un juego de palabras. nuestro objetivo, como autores, es facilitar la comprensión del código. queremos que el código sea algo rápido, no un estudio exhaustivo. queremos usar un modelo en el que el autor sea el responsable de transmitir el significado, no un modelo académico que exija investigar el significado mostrado. usar nombres de dominios de soluciones recuerde que los lectores de su código serán programadores. por ello, use términos informáticos, algoritmos, nombres de patrones, términos matemáticos y demás. no conviene extraer todos los nombres del dominio de problemas ya que no queremos que nuestros colegas tengan que preguntar el significado de cada nombre en especial cuando ya conocen el concepto bajo otro nombre diferente. el nombre accountvisitor tiene mucho significado para un programador familiarizado con el patrón visitor . ¿qué programador no sabe lo que es jobqueue ? hay cientos de cosas técnicas que los programadores tienen que hacer y elegir nombres técnicos para dichas cosas suele ser lo más adecuado. usar nombres de dominios de problemas cuando no exista un término de programación para lo que esté haciendo, use el nombre del dominio de problemas. al menos el programador que mantenga su código podrá preguntar el significado a un experto en dominios. separar los conceptos de dominio de soluciones y de problemas es parte del trabajo de un buen programador y diseñador. el código que tenga más relación con los conceptos del dominio de problemas tendrá nombres 54extraídos de dicho dominio. añadir contexto con sentido algunos nombres tienen significado por sí mismos, pero la mayoría no. por ello, debe incluirlos en un contexto, en clases, funciones y espacios de nombres con nombres adecuados. cuando todo lo demás falle, pueden usarse prefijos como último recurso. imagine que tiene las variables firstname , lastname , street , housenumber , city , state y z ipcode . si las combina, es evidente que forman una dirección. pero si la variable state se usa de forma aislada en un método, ¿sabría que forma parte de una dirección? puede añadir contexto por medio de prefijos: addrfirstname , addrlastname , addrstate , etc. al menos los lectores comprenderán que estas variables forman parte de una estructura mayor. evidentemente, es mejor crear la clase address . de ese modo, incluso el compilador sabrá que las variables pertenecen a un concepto más amplio. fíjese en el método del listado 2-1. ¿las variables necesitan un contexto con más sentido? el nombre de la función sólo ofrece parte del contexto, el resto se obtiene del algoritmo. tras leer la función, verá que las tres variables number , verb y pluralmodifier forman parte del mensaje guess statistics . desafortunadamente, es necesario inferir el contexto. al leer el método, el significado de las variables no es evidente. listado 2-1 variables en un contexto ambiguo. private void printguessstatistics(char candidate, int count) { string number; string verb; string pluralmodifier; if (count == 0) { number = “no”; verb = “are”; pluralmodifier = “s”; } else if (count == 1) { number = “1”; 55verb = “is”; pluralmodifier = “”; } else { number = integer.tostring(count); verb = “are”; pluralmodifier = “s”; } string guessmessage = string.format( “there %s %s %s%s”, verb, number, candidate, pluralmodifier ); print(guessmessage); } la función es demasiado extensa y las variables aparecen por todas partes. para dividir la función en fragmentos más reducidos necesitamos crear una clase guessstatisticsmessage y convertir a las tres variables en campos de la misma. de este modo contamos con un contexto más obvio para las tres variables. forman parte sin duda de guessstatisticsmessage . la mejora del contexto también permite que el algoritmo sea más limpio y se divida en funciones más reducidas (véase el listado 2-2). listado 2-2 variables con un contexto. public class guessstatisticsmessage ( private string number; private string verb; private string pluralmodifier; public string make(char candidate, int count) { createpluraldependentmessageparts(count); return string.format( “there %s %s %s%s, verb, number, candidate, pluralmodifier); } private void createpluraldependentmessageparts(int count) { if (count == 0) { therearenoletters(); } else if (cout == 1) { thereisoneletter(); } else { therearemanyletters(count); } } private void therearemanyletters(int count) { number = “1”; 56verb = “is”; pluralmodifier = “”; } private void thereisoneletter() { number = “1”; verb = “is”; pluralmodifier = “”; } private void therearenoletters() { number = “no”; verb = “are”; pluralmodifier = “s”; } } no añadir contextos innecesarios en la aplicación imaginaria gas station deluxe, no es aconsejable usar el prefijo gsd en todas las clases. es trabajar contra las herramientas proporcionadas. introduzca g y pulse la tecla de finalización para acceder a una lista interminable de todas las clases del sistema. ¿es lo correcto? ¿por qué dificultar la ayuda del ide? del mismo modo, imagine que ha creado la clase mailingaddress en un módulo de contabilidad de gsd , con el nombre gsdaccountaddress . después, necesita una dirección de correo para la aplicación de contacto con el cliente. ¿usará gsdaccountaddress ? ¿le parece el nombre correcto? 10 de los 17 caracteres son redundantes o irrelevantes. los nombres breves suelen ser más adecuados que los extensos, siempre que sean claros. no añada más contexto del necesario a un nombre. los nombres accountaddress y customeraddress son perfectos para instancias de la clase address pero no sirven como nombres de clase. address sirve como nombre de clase. para distinguir entre direcciones mac, direcciones de puertos y direcciones web, podría usar postaladdress , mac y uri . los nombres resultantes son más precisos, el objetivo de cualquier nombre. 57conclusión lo más complicado a la hora de elegir un buen nombre es que requiere habilidad descriptiva y acervo cultural. es un problema de formación más que técnico, empresarial o administrativo. como resultado, mucha gente del sector no aprende a hacerlo bien. la gente teme que al cambiar los nombres otros programadores se quejen. nosotros no compartimos ese temor y agradecemos los cambios de nombre (siempre que sean a mejor). en muchos casos no memorizamos los nombres de clases y métodos. usamos herramientas modernas para estos detalles y así poder centrarnos en si el código se lee como frases o párrafos, o al menos como tablas y estructuras de datos (una frase no siempre es la mejor forma de mostrar datos). seguramente acabará sorprendiendo a alguien cuando cambie los nombres, como puede suceder con cualquier otra mejora del código. no deje que le detenga. aplique estas reglas y compruebe si mejora o no la legibilidad de su código. si es el encargado de mantener código de terceros, use herramientas para solucionar estos problemas. obtendrá recompensas a corto y largo plazo. 583 funciones 59en los inicios de la programación, creábamos sistemas a partir de rutinas y subrutinas. después, en la época de fortran y pl/1, creábamos nuestros sistemas con programas, subprogramas y funciones. en la actualidad, sólo las funciones han sobrevivido. son la primera línea organizativa en cualquier programa. en este capítulo veremos cómo crearlas. fíjese en el código del listado 3-1. es complicado encontrar una función extensa en fitnesse [10] , pero acabé encontrando ésta. no sólo es extensa, sino que también contiene código duplicado, muchas cadenas y tipos de datos extraños, además de api poco habituales y nada evidentes. intente 60comprenderlo en los próximos tres minutos. listado 3-1 htmlutil.java (fitnesse 20070619). public static string testablehtml { pagedata pagedata, boolean includesuitesetup } throws exception { wikipage wikipage = pagedata.getwikipage(); stringbuffer buffer = new stringbuffer(); if (pagedata.hasattribute(“test”)) { if (includesuitesetup) { wikipage suitesetup = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_setup_name, wikipage ); if (suitesetup != null) { wikipagepath pagepath = suitesetup.getpagecrawler().getfullpath (suitesetup); string pagepathname = pathparser.render(pagepath); buffer.append(“!include -setup .”) .append(pagepathname) .append(“\n”); } } wikipage setup = pagecrawlerimpl.getinheritedpage(“setup”, wikipage); if (setup != null) { wikipagepath setuppath = wikipage.getpagecrawler().getfullpath(setup); string setuppathname = pathparser.render(setuppath); buffer.append(“!include -setup .”) .append(setuppathname) .append(“\n”); } } buffer.append(pagedata.getcontent()); if (pagedata.hasattribute(“test”)) { wikipage teardown = pagecrawlerimpl.getinheritedpage(“teardown”, wikipage); if (teardown != null) { wikipagepath teardownpath = wikipage.getpagecrawler().getfullpath(teardown); string teardownpathname = pathparser.render(teardownpath); buffer.append(“\n”) .append(“!include -teardown .”) .append(teardownpathname) .append(“\n”); } if (includesuitesetup) { 61wikipage suiteteardown = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_teardown_name, wikipage ); if (suiteteardown != null) { wikipagepath pagepath = suiteteardown.getpagecrawler().getfullpath (suiteteardown); string pagepathname = pathparser.render(pagepath); buffer.append(“!include -teardown .”) .append(pagepathname) .append(“\n”); } } } pagedata.setcontent(buffer.tostring()); return pagedata.gethtml(); } ¿tras tres minutos entiende la función? seguramente no. pasan demasiadas cosas y hay demasiados niveles de abstracción diferentes. hay cadenas extrañas e invocaciones de funciones mezcladas en instrucciones if doblemente anidadas controladas por indicadores. sin embargo, con sencillas extracciones de código, algún cambio de nombres y cierta reestructuración, pude capturar la intención de la función en las nueve líneas del listado 3-2. compruebe si ahora la entiende. listado 3-2 htmlutil.java (refactorización). public static string renderpagewithsetupsandteardowns( pagedata pagedata, boolean issuite ) throws exception { boolean istestpage = pagedata.hasattribute(“test”); if (istestpage) { wikipage testpage = pagedata.getwikipage(); stringbuffer newpagecontent = new stringbuffer(); includesetuppages (testpage, newpagecontent, issuite); newpagecontent.append(pagedata.getcontent()); includeteardownpages(testpage, newpagecontent, issuite); pagedata.setcontent(newpagecontent.tostring()); } return pagedata.gethtml(); } a menos que sea un alumno de fitnesse, seguramente no entienda los 62detalles. entenderá que la función se encarga de añadir páginas de configuración y detalles en una página de prueba, que después muestra en html. si está familiarizado con junit [11] , verá que esta función pertenece a algún tipo de estructura de pruebas basada en la web y, evidentemente, es correcto. resulta sencillo adivinar esta información del listado 3-2 pero no del listado 3-1. ¿qué tiene la función del listado 3-2 para que resulte sencilla de leer y entender? ¿qué hay que hacer para que una función transmita su intención? ¿qué atributos podemos asignar a nuestras funciones para que el lector pueda intuir el tipo de programa al que pertenecen? tamaño reducido la primera regla de las funciones es que deben ser de tamaño reducido. la segunda es que deben ser todavía más reducidas . no es una afirmación que pueda justificar. no puedo mostrar referencias a estudios que demuestren que las funciones muy reducidas sean mejores. lo que sí puedo afirmar es que durante casi cuatro décadas he creado funciones de diferentes tamaños. he creado monstruos de casi 3000 líneas y otras muchas funciones de entre 100 y 300 líneas. también he creado funciones de 20 a 30 líneas de longitud. esta experiencia me ha demostrado, mediante ensayo y error, que las funciones deben ser muy reducidas. en la década de 1980 se decía que una función no debía superar el tamaño de una pantalla. por aquel entonces, las pantallas vt100 tenían 24 líneas por 80 columnas, y nuestros editores usaban 4 líneas para tareas administrativas. en la actualidad, con una fuente mínima y un monitor de gran tamaño, se pueden encajar 150 caracteres por línea y 100 líneas o más en una pantalla. las líneas no deben tener 150 caracteres. las funciones no deben tener 100 líneas de longitud. las funciones deben tener una longitud aproximada de 20 líneas. ¿qué tamaño mínimo debe tener una función? en 1999 visité a kent beck en su casa de oregon. nos sentamos y comenzamos a programar. me enseñó un atractivo programa de java/swing que había llamado sparkle . generaba un efecto visual en pantalla, similar a la varita mágica del hada de 63cenicienta. al mover el ratón, salían estrellitas del cursor, y descendían a la parte inferior de la pantalla en un campo gravitatorio simulado. cuando kent me enseñó el código, me sorprendió la brevedad de las funciones. estaba acostumbrado a ver programas de swing con funciones que ocupaban kilómetros de espacio vertical. en este programa, las funciones tenían dos, tres o cuatro líneas de longitud. todas eran obvias. todas contaban una historia y cada una llevaba a la siguiente en un orden atractivo. ¡así de breves deberían ser todas las funciones! [12] ¿qué tamaño mínimo deben tener sus funciones? deberían ser más breves que las del listado 3-2. de hecho, el listado 3-2 debería reducirse como el listado 3-3. listado 3-3 htmlutil.java (nueva refactorización). public static string renderpagewithsetupsandteardowns( pagedata pagedata, boolean issuite) throws exception { if (istestpage(pagedata)) includesetupandteardownpages(pagedata, issuite); return pagedata.gethtml(); } bloques y sangrado esto implica que los bloques en instrucciones if , else , while y similares deben tener una línea de longitud que, seguramente, sea la invocación de una función. de esta forma, no sólo se reduce el tamaño de la función, sino que también se añade valor documental ya que la función invocada desde el bloque puede tener un nombre descriptivo. también implica que las funciones no deben tener un tamaño excesivo que albergue estructuras anidadas. por tanto, el nivel de sangrado de una función no debe ser mayor de uno o dos. evidentemente, de esta forma las funciones son más fáciles de leer y entender. hacer una cosa 64es evidente que el listado 3-1 hace más de una cosa. crea búferes, obtiene páginas, busca páginas heredadas, añade cadenas antiguas y genera html. el listado 3-1 está muy ocupado realizando varias tareas. por su parte, el listado 3-3 sólo hace una cosa: incluye configuraciones y detalles en páginas de prueba. el siguiente consejo lleva vigente, de una u otra forma, durante más de 30 años: las funciones sólo deben hacer una cosa. deben hacerlo bien y debe ser lo único que hagan. el problema de esta afirmación es saber qué es una cosa. ¿el listado 3-3 hace una cosa? se podría pensar que hace tres: 1 . determinar si la página es una página de prueba. 2 . en caso afirmativo, incluir configuraciones y detalles. 3 . representar la página en html. ¿cuál será de las tres? ¿la función hace una o tres cosas? los tres pasos de la función se encuentran un nivel de abstracción por debajo del nombre de la función. podemos describir la función como un breve párrafo to (para) [13] : para renderpagewithsetupsandteardowns , comprobamos si la página es de prueba y, en caso afirmativo, incluimos las configuraciones y los detalles. en ambos casos, la representamos en html. si una función sólo realiza los pasos situados un nivel por debajo del nombre de la función, entonces hace una cosa. en definitiva, creamos funciones para descomponer conceptos más amplios (es decir, el nombre de 65la función) en un conjunto de pasos en el siguiente nivel de abstracción. es evidente que el listado 3-1 contiene pasos en distintos niveles de abstracción, por lo que es obvio que hace más de una cosa. incluso el listado 3-2 tiene tres niveles de abstracción, como ha demostrado la capacidad de reducirlo, pero sería complicado reducir con sentido el listado 3-3. podríamos extraer la instrucción if en la función includesetupsandteardownsiftestpage , pero sólo reduciríamos el código sin cambiar el nivel de abstracción. por ello, otra forma de saber que una función hace más de una cosa es extraer otra función de la misma con un nombre que no sea una reducción de su implementación [g34]. secciones en funciones fíjese en el listado 4-7. verá que la función generateprimes se divide en secciones como declaraciones, inicializaciones y filtros. es un síntoma evidente de que hace más de una cosa. las funciones que hacen una sola cosa no se pueden dividir en secciones. un nivel de abstracción por función para que las funciones realicen «una cosa», asegúrese de que las instrucciones de la función se encuentran en el mismo nivel de abstracción. el listado 3-1 incumple esta regla. incluye conceptos a un elevado nivel de abstracción, como gethtml(); otros se encuentran en un nivel intermedio, como stringpagepathname = pathparser.render(pagepath) y hay otros en un nivel especialmente bajo, como .append(“\n”). la mezcla de niveles de abstracción en una función siempre resulta confusa. los lectores no sabrán si una determinada expresión es un concepto esencial o un detalle. peor todavía, si se mezclan detalles con conceptos esenciales, aumentarán los detalles dentro de la función. 66leer código de arriba a abajo: la regla descendente el objetivo es que el código se lea como un texto de arriba a abajo [14] . queremos que tras todas las funciones aparezcan las del siguiente nivel de abstracción para poder leer el programa, descendiendo un nivel de abstracción por vez mientras leemos la lista de funciones. es lo que denomino la regla descendente. para decirlo de otra forma, queremos leer el programa como si fuera un conjunto de párrafos to , en el que cada uno describe el nivel actual de abstracción y hace referencia a los párrafos to posteriores en el siguiente nivel. para incluir configuraciones y detalles, incluimos configuraciones, después del contenido de la página de prueba, y por último los detalles. para incluir las configuraciones, incluimos la configuración de suite si se trata de una suite , y después la configuración convencional. para incluir la configuración de suite ; buscamos la jerarquía principal de la página suitesetup y añadimos una instrucción include con la ruta de dicha página. para buscar la jerarquía principal… a los programadores les resulta complicado aprender esta regla y crear funciones en un único nivel de abstracción, pero es un truco importante. es la clave para reducir la longitud de las funciones y garantizar que sólo hagan una cosa. al conseguir que el código se lea de arriba a abajo, se mantiene la coherencia de los niveles de abstracción. fíjese en el listado 3-7 del final del capítulo. muestra la función testablehtml modificada de acuerdo a estos principios. cada función presenta a la siguiente y se mantiene en un nivel de abstracción coherente. instrucciones switch 67es complicado usar una instrucción switch de tamaño reducido [15] . aunque sólo tenga dos casos, es mayor de lo que un bloque o función debería ser. también es complicado crear una instrucción switch que haga una sola cosa. por su naturaleza, las instrucciones switch siempre hacen n cosas. desafortunadamente, no siempre podemos evitar las instrucciones switch pero podemos asegurarnos de incluirlas en una clase de nivel inferior y de no repetirlas. para ello, evidentemente, recurrimos al polimorfismo. fíjese en el listado 3-4. muestra una de las operaciones que pueden depender del tipo de empleado. listado 3-4 payroll.java. public money calculatepay(employee e) throws invalidemployeetype ( switch (e.type) { case commissioned: return calculatecommissionedpay(e); case hourly: return calculatehourlypay(e); case salaried: return calculatesalariedpay(e); default: throw new invalidemployeetype(e.type); } } esta función tiene varios problemas. por un lado, es de gran tamaño y cuando se añadan nuevos tipos de empleado, aumentará más. por otra parte, hace más de una cosa. también incumple el principio de responsabilidad única ( single responsibility principie o srp) [16] ya que hay más de un motivo para cambiarla. además, incumple el principio de abierto/cerrado ( open closed principle u ocp) [17] , ya que debe cambiar cuando se añadan nuevos tipos, pero posiblemente el peor de los problemas es que hay un número ilimitado de funciones que tienen la misma estructura. por ejemplo, podríamos tener: ispayday(employee e, date date), o 68deliverpay(employee e, date date), o muchas otras, todas con la misma estructura. la solución al problema (véase el listado 3-5) consiste en ocultar la instrucción switch en una factoría abstracta [18] e impedir que nadie la vea. la factoría usa la instrucción switch para crear las instancias adecuadas de los derivados de employee y las distintas funciones, como calculatepay , ispayday y deliverpay , se entregarán de forma polimórfica a través de la interfaz employee . listado 3-5 employee y factory. public abstract class employee { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } public interface employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype; } public class employeefactoryimpl implements employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype { switch (r.type) { case commissioned: return new commissionedemployee(r); case hourly: return new hourlyemployee(r); case salaried: return new salariedemployee(r); default: throw new invalidemployeetype(r.type); } } } mi regla general para las instrucciones switch es que se pueden tolerar si sólo aparecen una vez, se usan para crear objetos polimórficos y se ocultan tras una relación de herencia para que el resto del sistema no las pueda ver [g23]. evidentemente, cada caso es diferente y en ocasiones se puede 69incumplir una o varias partes de esta regla. usar nombres descriptivos en el listado 3-7, hemos cambiado el nombre de la función de ejemplo de testablehtml a setupteardownincluder.render . es un nombre más apropiado ya que describe mejor el cometido de la función. también hemos asignado a los métodos privados un nombre descriptivo como istestable o includesetupandteardownpages . no hay que olvidar el valor de los nombres correctos. recuerde el principio de ward: «sabemos que trabajamos con código limpio cuando cada rutina es más o menos lo que esperábamos». para alcanzar este principio, gran parte del esfuerzo se basa en seleccionar nombres adecuados para pequeñas funciones que hacen una cosa. cuanto más reducida y concreta sea una función, más sencillo será elegir un nombre descriptivo. no tema los nombres extensos. un nombre descriptivo extenso es mucho mejor que uno breve pero enigmático. use una convención de nombres que permita leer varias palabras en los nombres de las funciones y use esas palabras para asignar a la función un nombre que describa su cometido. no tema dedicar tiempo a elegir un buen nombre. de hecho, debería probar con varios nombres y leer el código con todos ellos. los ide modernos como eclipse o intellij facilitan el cambio de nombres. use uno de estos ide y experimente con diferentes nombres hasta que encuentre uno que sea lo bastante descriptivo. la elección de nombres descriptivos clarifica el diseño de los módulos y le permite mejorarlos. no es extraño que la búsqueda de nombres adecuados genere una reestructuración favorable del código. sea coherente con los nombres. use las mismas frases, sustantivos y verbos en los nombres de función que elija para los módulos. pruebe, por ejemplo, con includesetupandteardownpages , includesetuppages , includesuitesetuppage e includesetuppage . la estructura similar de estos nombres permite que la secuencia cuente una historia. en realidad, si ve la secuencia anterior, seguramente se pregunte qué ha pasado con 70includeteardownpages , includesuiteteardownpage e includeteardownpage . argumentos de funciones el número ideal de argumentos para una función es cero. después uno (monádico) y dos (diádico). siempre que sea posible, evite la presencia de tres argumentos (triádico). más de tres argumentos (poliádico) requiere una justificación especial y no es muy habitual. los argumentos son complejos ya que requieren un gran poder conceptual. por ello suelo evitarlos en los ejemplos. fíjese en stringbuffer . podríamos haberlo pasado como argumento en lugar de como variable de instancia, pero los lectores habrían tenido que interpretarlo cada vez que lo vieran. al leer la historia que cuenta el módulo, includesetuppage() es más sencillo de interpretar que includesetuppageinto(newpagecontent) . el argumento se encuentra en un nivel de abstracción diferente que el nombre de la función y nos obliga a conocer un detalle ( stringbuffer ) que no es especialmente importante en ese momento. los argumentos son todavía más complicados desde un punto de vista de pruebas. imagine la dificultad de crear todos los casos de prueba para garantizar el funcionamiento de las distintas combinaciones de argumentos. si no hay argumentos, todo es más sencillo. si hay uno, no es demasiado difícil. con dos argumentos el problema es más complejo. con más de dos argumentos, probar cada combinación de valores adecuados es todo un reto. los argumentos de salida son más difíciles de entender que los de entrada. al leer una función, estamos acostumbrados al concepto de información añadida 71a la función a través de argumentos y extraída a través de un valor devuelto. no esperamos que la información se devuelva a través de los argumentos. por ello, los argumentos de salida suelen obligamos a realizar una comprobación doble. un argumento de salida es la mejor opción, después de la ausencia de argumentos. setupteardownincluder.render(pagedata) se entiende bien. evidentemente, vamos a representar los datos en el objeto pagedata . formas monádicas habituales hay dos motivos principales para pasar un solo argumento a una función. puede que realice una pregunta sobre el argumento, como en boolean fileexists(“myfile”), o que procese el argumento, lo transforme en otra cosa y lo devuelva. por ejemplo, inputstream fileopen(“myfile”) transforma un nombre de archivo string en un valor devuelto inputstream . los usuarios esperan estos dos usos cuando ven una función. debe elegir nombres que realicen la distinción con claridad y usar siempre ambas formas en un contexto coherente (consulte el apartado sobre separación de consultas de comandos). una forma menos habitual pero muy útil para un argumento es un evento. en esta forma, hay argumento de entrada pero no de salida. el programa debe interpretar la invocación de la función como evento y usar el argumento para alterar el estado del sistema, por ejemplo, void passwordattemptfailedntimes(int attempts) . use esta forma con precaución. debe ser claro para el lector que se trata de un evento. elija nombres y contextos con atención. intente evitar funciones monádicas que no tengan estas formas, por ejemplo, void includesetuppageinto(stringbuffer pagetext) . el uso de un argumento de salida en lugar de un valor devuelto para realizar transformaciones resulta confuso. si una función va a transformar su argumento de entrada, la transformación debe aparecer como valor devuelto. sin duda stringbuffertransform(stringbuffer in) es mejor que void 72transform(stringbuffer out) , aunque la implementación del primer caso devuelva solamente el argumento de entrada. al menos se ajusta a la forma de la transformación. argumentos de indicador los argumentos de indicador son horribles. pasar un valor booleano a una función es una práctica totalmente desaconsejable. complica inmediatamente la firma del método e indica que la función hace más de una cosa. hace algo si el indicador es true y otra cosa diferente si es false . en el listado 3-7 no se puede evitar, porque los invocadores ya pasan el indicador y el objetivo era limitar el ámbito a la función y después, pero la invocación de render (true) es confusa para el lector. si se desplaza el ratón sobre la invocación vemos que render (boolean issuite) puede ayudar, pero no demasiado. tendremos que dividir la función en dos: renderforsuite() y renderforsingletest() . funciones diádicas una función con dos argumentos es más difícil de entender que una función monádica. por ejemplo writefield(name) es más fácil de entender que writefield (outputstream, name) [19] . aunque en ambos casos el significado es evidente, la primera se capta mejor visualmente. la segunda requiere una breve pausa hasta que ignoramos el segundo parámetro, lo que en última instancia genera problemas ya que no debemos ignorar esa parte del código. las partes que ignoramos son las que esconden los errores. pero en ocasiones se necesitan dos argumentos. por ejemplo. point p = new point(0,0); es totalmente razonable. los puntos cartesianos suelen adoptar dos argumentos. de hecho, sería muy sorprendente ver point(0) . sin embargo, en este caso ambos argumentos son componentes ordenados de un mismo valor, mientras que outputstream y name carecen de una cohesión o un orden natural. 73incluso funciones diádicas evidentes como assertequals(expected, actual) resultan problemáticas. ¿cuántas veces ha incluido el valor real en su posición esperada? los dos argumentos carecen de un orden natural. el orden real y esperado es una convención que se adquiere gracias a la práctica. las combinaciones diádicas no son el mal en persona y tendrá que usarlas. sin embargo, recuerde que tienen un precio y que debe aprovechar los mecanismos disponibles para convertirlas en unitarias. por ejemplo, puede hacer que el método writefield sea un miembro de outputstream para poder usar outputstream.writefield(name) , o podría convertir outputstream en una variable miembro de la clase actual para no tener que pasarla. incluso podría extraer una nueva clase como fieldwriter que usara outputstream en su constructor y tuviera un método write . triadas las funciones que aceptan tres argumentos son sin duda mucho más difíciles de entender que las de dos. los problemas a la hora de ordenar, ignorar o detenerse en los argumentos se duplican. piense atentamente antes de crear una triada. por ejemplo, fíjese en la sobrecarga de assertequals que acepta tres argumentos: assertequals(message, expected, actual) . ¿cuántas veces lee el mensaje y piensa que es lo esperado? he visto esta triada en concreto muchas veces. de hecho, siempre que la veo, tengo que repasarla antes de ignorar el mensaje. por otra parte, hay otra triada que no es tan negativa: assertequals(1.0, amount, .001) . aunque también exija doble atención, merece la pena. conviene recordar siempre que la igualdad de los valores de coma flotante es algo relativo. objeto de argumento cuando una función parece necesitar dos o más argumentos, es probable que 74alguno de ellos se incluya en una clase propia. fíjese en la diferencia entre las dos siguientes declaraciones: circle makecircle (double x, double y, double radius); circle makecircle(point center, double radius); la reducción del número de argumentos mediante la creación de objetos puede parecer una trampa pero no lo es. cuando se pasan grupos de variables de forma conjunta, como x e y en el ejemplo anterior, es probable que formen parte de un concepto que se merece un nombre propio. listas de argumentos en ocasiones tendremos que pasar un número variable de argumentos a una función. fíjese en el método string.format : string.format (“%s worked %.2f hours.”, name, hours); si los argumentos variables se procesan de la misma forma, como en el ejemplo anterior, serán equivalentes a un único argumento de tipo list . por tanto, string.format es en realidad diádico. de hecho, la siguiente declaración de string.format es claramente diádica. public string format(string format, object… args) así pues, se aplican las mismas reglas. las funciones que aceptan argumentos variables pueden ser monádicas, diádicas o incluso triádicas, pero sería un error asignar más argumentos. void monad(integer… args); void dyad(string name, integer… args); void triad(string name, int count, integer… args); verbos y palabras clave la selección de nombres correctos para una función mejora la explicación de su cometido, así como el orden y el cometido de los argumentos. en formato monádico, la función y el argumento deben formar un par de verbo y sustantivo. por ejemplo, write(name) resulta muy evocador. sea lo que sea name , sin duda se escribe (write) . 75un nombre más acertado podría ser writefield(name) , que nos dice que name es un campo (field) . éste es un ejemplo de palabra clave como nombre de función. con este formato codificamos los nombres de los argumentos en el nombre de la función. por ejemplo, assertequals se podría haber escrito como assertexpectedequalsactual(expected, actual) , lo que mitiga el problema de tener que recordar el orden de los argumentos. sin efectos secundarios los efectos secundarios son mentiras. su función promete hacer una cosa, pero también hace otras cosas ocultas. en ocasiones realiza cambios inesperados en las variables de su propia clase. en ocasiones las convierte en las variables pasadas a la función o a elementos globales del sistema. en cualquier caso, se comete un engaño que suele provocar extrañas combinaciones temporales y dependencias de orden. fíjese en la función del listado 3-6, aparentemente inofensiva. usa un algoritmo estándar para comparar username con password . devuelve true si coinciden y false si hay algún problema, pero también hay un efecto secundario. ¿lo detecta? listado 3-6 uservalidator.java. public class uservalidator { private cryptographer cryptographer; public boolean checkpassword(string username, string password) { user user = usergateway.findbyname(username); if (user != user.null) { string codedphrase = user.getphraseencodedbypassword(); string phrase = cryptographer.decrypt(codedphrase, password); if (“valid password”.equals(phrase)){ session.initialize(); return true; } } return false; } 76} el efecto secundario es la invocación de session.initialize() . la función checkpassword , por su nombre, afirma comprobar la contraseña. el nombre no implica que inicialice la sesión. por tanto, un invocador que se crea lo que dice el nombre de la función se arriesga a borrar los datos de sesión actuales cuando decida comprobar la validez del usuario. este efecto secundario genera una combinación temporal. es decir, sólo se puede invocar checkpassword en determinados momentos (cuando se pueda inicializar la sesión). si no se invoca en orden, se pueden perder los datos de la sesión. las combinaciones temporales son confusas, en especial cuando se ocultan como efecto secundario. si tiene que realizar una combinación temporal, hágalo de forma clara en el nombre de la función. en este caso, podríamos cambiar el nombre de la función por checkpasswordandinitializesession , pero incumpliría la norma de hacer una sola cosa. argumentos de salida los argumentos suelen interpretarse como entradas de una función. si lleva varios años programando, estoy seguro de que habrá visto un argumento que en vez de ser de entrada era de salida. por ejemplo; appendfooter(s); ¿está función añade s al final de algo? ¿o añade el final de algo a s ? ¿ s es una entrada o una salida? lo sabemos al ver la firma de la función: public void appendfooter(stringbuffer report) esto lo aclara todo, pero para ello hay que comprobar la declaración de la función. todo lo que le obligue a comprobar la firma de la función es un esfuerzo doble. es una pausa cognitiva y debe evitarse. antes de la programación orientada a objetos, era necesario tener argumentos de salida. sin embargo, gran parte de su necesidad desaparece en los lenguajes orientados a objetos, pensados para actuar como argumento de salida. es decir, sería más indicado invocar appendfooter como report.appendfooter();. por lo general, los argumentos de salida deben evitarse. si su función 77tiene que cambiar el estado de un elemento, haga que cambie el estado de su objeto contenedor. separación de consultas de comando las funciones deben hacer algo o responder a algo, pero no ambas cosas. su función debe cambiar el estado de un objeto o devolver información sobre el mismo, pero ambas operaciones causan confusión. fíjese en la siguiente función: public boolean set(string attribute, string value); esta función establece el valor de un atributo y devuelve true en caso de éxito o false si el atributo no existe. esto provoca la presencia de una extraña instrucción como la siguiente: if (set(“username”, “unclebob”))… imagínelo desde el punto de vista del lector. ¿qué significa? ¿pregunta si el atributo « username » se ha establecido antes en « unclebob », o si el atributo «username» se ha establecido correctamente en « unclebob »? es complicado saberlo por la invocación ya que no es evidente si set es un verbo o un adjetivo. el autor pretendía que set fuera un verbo, pero el contexto de la instrucción if parece un adjetivo. la instrucción se lee como «si el atributo username se ha establecido previamente en unclebob », no como «establecer el atributo username en unclebob y si funciona, entonces…». podríamos solucionarlo si cambiamos el nombre de la función set por setandcheckifexists , pero no mejoraría la legibilidad de la instrucción if . la verdadera solución es separar el comando de la consulta para evitar la ambigüedad. if (attributeexists(“username”)) { setattribute(“username”, “unclebob”); … } 78mejor excepciones que devolver códigos de error devolver códigos de error de funciones de comando es un sutil incumplimiento de la separación de comandos de consulta. hace que los comandos usados asciendan a expresiones en los predicados de las instrucciones if . if (deletepage(page) == e_ok) no padece la confusión entre verbo y adjetivo, pero genera estructuras anidadas. al devolver un código de error se crea un problema: el invocador debe procesar el error de forma inmediata. if (deletepage(page) == e_ok) { if (registry.deletereference(page.name) == e_ok) { if (configkeys.deletekey(page.name.makekey()) == e_ok) { logger.log(“page deleted”); } else { logger.log(“configkey not deleted”); } } else { logger.log(“deletereference from registry failed”); } } else { logger.log(“delete failed”); return e_error; } por otra parte, si usa excepciones en lugar de códigos de error, el código de procesamiento del error se puede separar del código de ruta y se puede simplificar: try { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } catch (exception e) { logger.log(e.getmessage()); } extraer bloques try/catch los bloques try/catch no son atractivos por naturaleza. confunden la estructura del código y mezclan el procesamiento de errores con el normal. 79por ello, conviene extraer el cuerpo de los bloques try y catch en funciones individuales. public void delete(page page) { try { deletepageandallreferences(page); } catch (exception e) { logerror(e); } } private void deletepageandallreferences(page page) throws exception { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } private void logerror(exception e) { logger.log(e.getmessage()); } en este caso, la función delete es de procesamiento de errores. es fácil de entender e ignorar. la función deletepageandallreferences es para los procesos de borrar una página. el procesamiento de errores se puede ignorar. de este modo, la separación facilita la comprensión y la modificación del código. el procesamiento de errores es una cosa las funciones sólo deben hacer una cosa y el procesamiento de errores es un ejemplo. por tanto, una función que procese errores no debe hacer nada más. esto implica (como en el ejemplo anterior) que, si una función incluye la palabra clave try , debe ser la primera de la función y que no debe haber nada más después de los bloques catch/finally . el imán de dependencias error.java la devolución de códigos de error suele implicar que existe una clase o enumeración en la que se definen los códigos de error. public enum error { 80ok, invalid, no_such, locked, out_of_resources, waiting_for_event; } clases como ésta son un imán para las dependencias ; otras muchas clases deben importarlas y usarlas. por ello, cuando cambia la enumeración error , es necesario volver a compilar e implementar dichas clases [20] . esto añade presión a la clase error . los programadores no quieren añadir nuevos errores porque tendrán que volver a generar e implementarlo todo. por ello, reutilizan códigos de error antiguos en lugar de añadir otros nuevos. al usar excepciones en lugar de códigos de error, las nuevas excepciones son derivaciones de la clase de la excepción. se pueden añadir sin necesidad de volver a compilar o implementar [21] . no repetirse [22] fíjese de nuevo en el listado 3-1; verá que hay un algoritmo que se repite cuatro veces, en los casos setup , suitesetup , teardown y suiteteardown . no es fácil detectar esta repetición ya que las cuatro instancias se mezclan con otro código, pero la duplicación es un problema ya que aumenta el tamaño del código y requerirá una modificación cuádruple si alguna vez cambia el algoritmo. también se cuadriplica el riesgo de errores. esta duplicación se remedia gracias al método include del listado 3-7. vuelva a leer el código y fíjese en cómo se ha mejorado la legibilidad del código reduciendo la duplicación. la duplicación puede ser la raíz de todos los problemas del software . existen numerosos principios y prácticas para controlarla o eliminarla. imagine que todas las formas normales de la base de datos de codd sirvieran 81para eliminar la duplicación de datos. imagine también cómo la programación orientada a objetos concentra el código en clases base que en otros casos serian redundantes. la programación estructurada, la programación orientada a aspecto y la orientada a componentes son, en parte, estrategias para eliminar duplicados. parece que, desde la aparición de las subrutinas, las innovaciones en desarrollo de software han sido un intento continuado por eliminar la duplicación de nuestro código fuente. programación estructurada algunos programadores siguen las reglas de programación estructurada de edsger dijkstra [23] . dijkstra afirma que todas las funciones y todos los bloques de una función deben tener una entrada y una salida. estas reglas implican que sólo debe haber una instrucción return en una función, que no debe haber instrucciones break o continue en un bucle y nunca, bajo ningún concepto, debe haber instrucciones goto . aunque apreciemos los objetivos y disciplinas de la programación estructurada, no sirven de mucho cuando las funciones son de reducido tamaño. su verdadero beneficio se aprecia en funciones de gran tamaño. por tanto, si sus funciones son de tamaño reducido, una instrucción return , break o continue no hará daño alguno y en ocasiones puede resultar más expresiva que la regla de una entrada y una salida. por otra parte, goto sólo tiene sentido en funciones de gran tamaño y debe evitarse. cómo crear este tipo de funciones la creación de software es como cualquier otro proceso creativo. al escribir un informe o un artículo, primero se estructuran las ideas y después el mensaje hasta que se lea bien. el primer borrador puede estar desorganizado, de modo que lo retoca y mejora hasta que se lea de la forma adecuada. cuando creo funciones, suelen ser extensas y complicadas, con abundancia de sangrados y bucles anidados. con extensas listas de 82argumentos, nombres arbitrarios y código duplicado, pero también cuento con una serie de pruebas de unidad que abarcan todas y cada una de las líneas de código. por tanto, retoco el código, divido las funciones, cambio los nombres y elimino los duplicados. reduzco los métodos y los reordeno. en ocasiones, elimino clases enteras, mientras mantengo las pruebas. al final, consigo funciones que cumplen las reglas detalladas en este capítulo. no las escribo al comenzar y dudo que nadie pueda hacerlo. conclusión todo sistema se crea a partir de un lenguaje específico del dominio diseñado por los programadores para describir dicho sistema. las funciones son los verbos del lenguaje y las clases los sustantivos. no es volver a la noción de que los sustantivos y verbos de un documento de requisitos son las clases y funciones de un sistema. es una verdad mucho más antigua. el arte de la programación es, y ha sido siempre, el arte del diseño del lenguaje. los programadores experimentados piensan en los sistemas como en historias que contar, no como en programas que escribir. recurren a las prestaciones del lenguaje de programación seleccionado para crear un lenguaje expresivo mejor y más completo que poder usar para contar esa historia. parte de ese lenguaje es la jerarquía de funciones que describen las acciones que se pueden realizar en el sistema. dichas acciones se crean para usar el lenguaje de dominio concreto que definen para contar su pequeña parte de la historia. en este capítulo hemos visto la mecánica de la creación de funciones correctas. si aplica estas reglas, sus funciones serán breves, con nombres correctos, y bien organizadas, pero no olvide que su verdadero objetivo es contar la historia del sistema y que las funciones que escriba deben encajar en un lenguaje claro y preciso que le sirva para contar esa historia. setupteardownincluder 83listado 3-7 setupteardownincluder.java. package fitnesse.html; import fitnesse.responders.run.suiteresponder; import fitnesse.wiki.*; public class setupteardownincluder { private pagedata pagedata; private boolean issuite; private wikipage testpage; private stringbuffer newpagecontent; private pagecrawler pagecrawler; public static string render(pagedata pagedata) throws exception { return render(pagedata, false); } public static string render(pagedata pagedata, boolean issuite) throws exception { return new setupteardownincluder(pagedata).render(issuite); } private setupteardownincluder(pagedata pagedata) { this.pagedata = pagedata; testpage = pagedata.getwikipage(); pagecrawler = testpage.getpagecrawler(); newpagecontent = new stringbuffer(); } private string render(boolean issuite) throws exception { this.issuite = issuite; if (istestpage()) includesetupandteardownpages(); return pagedata.gethtml(); } private boolean istestpage() throws exception { return pagedata.hasattribute(“test”); } private void includesetupandteardownpages() throws exception { includesetuppages(); includepagecontent(); includeteardownpages(); updatepagecontent(); } private void includesetuppages() throws exception { if (issuite) includesuitesetuppage(); includesetuppage(); } 84private void includesuitesetuppage() throws exception { include(suiteresponder.suite_setup_name, “-setup”); } private void includesetuppage() throws exception { include(“setup”, “-setup”); } private void includepagecontent() throws exception { newpagecontent.append(pagedata.getcontent()); } private void includeteardownpages() throws exception { includeteardownpage(); if (issuite) includesuiteteardownpage(); } private void includeteardownpage() throws exception { include(“teardown”, “-teardown”); } private void includesuiteteardownpage() throws exception { include(suiteresponder.suite_teardown_name, “-teardown”); } private void updatepagecontent() throws exception { pagedata.setcontent(newpagecontent.tostring()); } private void include(string pagename, string arg) throws exception ( wikipage inheritedpage = findinheritedpage(pagename); if (inheritedpage != null) { string pagepathname = getpathnameforpage(inheritedpage); buildincludedirective(pagepathname, arg); } } private wikipage findinheritedpage(string pagename) throws exception { return pagecrawlerimpl.getinheritedpage(pagename, testpage); } private string getpathnameforpage(wikipage page) throws exception { wikipagepath pagepath = pagecrawler.getfullpath(page); return pathparser.render(pagepath); } private void buildincludedirective(string pagepathname, string arg) { newpagecontent .append(“\n!include ”) .append(arg) .append(“ .”) .append(pagepathname) .append(“\n”); } 85} bibliografía [kp78] : kernighan and plaugher, the elements of programming style , 2d. ed., mcgraw-hill, 1978. [ppp02] : robert c. martin, agile software development: principles, patterns, and practices, prentice hall, 2002. [gof] : design patterns: elements of reusable object oriented software, gamma et al., addison wesley, 1996. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. [sp72] : structured programming , o. j. dahl, e. w. dijkstra, c. a. r. hoare, academic press, london, 1972. 864 comentarios «no comente el código incorrecto, reescríbalo». brian w. kernighan y p. j. plaugher [24] no hay nada más útil que un comentario bien colocado. no hay nada que colapse más un módulo que comentarios dogmáticos innecesarios. no hay nada más dañino que un comentario antiguo que propague mentiras y desinformación. los comentarios no son como la lista de schindler. no son pura bondad. de hecho, en el mejor de los casos, son un mal necesario. si los lenguajes de 87programación fueran más expresivos o si pudiéramos dominarlos para expresar nuestras intenciones, no necesitaríamos demasiados comentarios, puede que incluso ninguno. el uso correcto de los comentarios permite compensar nuestra incapacidad para expresarnos en el código. he usado la palabra incapacidad, a propósito. los comentarios siempre son fallos. debemos usarlos porque no siempre sabemos cómo expresarnos sin ellos pero su uso no es motivo de celebración. cuando tenga que escribir un comentario, piense si no existe otra forma de expresarse en el código. siempre que se exprese en el código, debe felicitarse. siempre que escriba un comentario, debe hacer un gesto de desaprobación y sentir su incapacidad para expresarse. ¿por qué estoy en contra de los comentarios? porque mienten. no siempre y no siempre intencionadamente, pero lo hacen. cuando más antiguo es un comentario y más se aleja del código que describe, mayor es la probabilidad de que sea equivocado. el motivo es sencillo. los programadores no los pueden mantener. el código cambia y evoluciona. los fragmentos cambian de lugar, se bifurcan, se reproducen y se vuelven a combinar para crear quimeras. desafortunadamente, los comentarios no siempre siguen el ritmo, no siempre pueden hacerlo y suelen separarse del código que describen y se convierten en huérfanos sin precisión alguna. por ejemplo, fíjese en lo que sucede con este comentario y la línea que pretendía describir: mockrequest request; private final string http_date_regexp = “[smtwf][a-z]{2}\\,\\s[0-9]{2}\\s[jfmasond][a-z]{2}\\s” + “[0-9]{4}\\s[0-9]{2}\\:[0-9]{2}\\:[0-9]{2}\\sgmt”; private response response; private fitnessecontext context; private fileresponder responder; private locale savelocale; // ejemplo: «tue, 02 apr 2003 22:18:49 gmt» seguramente se añadieron después otras variables de instancia entre la constante http_date_regexp y su comentario explicativo. se podría afirmar que los programadores deben ser lo bastante disciplinados como para mantener los comentarios actualizados, relevantes y precisos. de acuerdo, debería, pero esa energía debería invertirse en crear 88código claro y expresivo que no necesite comentario alguno. los comentarios imprecisos son mucho peor que la ausencia de comentarios. suelen confundir al usuario. generan expectativas que nunca se cumplen. definen reglas que no deben seguirse en absoluto. la verdad sólo se encuentra en un punto: el código. sólo el código puede contar lo que hace. es la única fuente de información precisa. por tanto, aunque los comentarios sean necesarios en ocasiones, dedicaremos nuestra energía a minimizarlos. los comentarios no compensan el código incorrecto una de las principales motivaciones para crear comentarios es el código incorrecto. creamos un módulo y sabemos que es confuso y está desorganizado. sabemos que es un desastre y entonces decidimos comentarlo. error. mejor límpielo. el código claro y expresivo sin apenas comentarios es muy superior al código enrevesado y complejo con multitud de comentarios. en lugar de perder tiempo escribiendo comentarios que expliquen el desastre cometido, dedíquelo a solucionarlo. explicarse en el código en ocasiones, el código es un pobre vehículo de expresión. desafortunadamente, muchos programadores lo entienden como que el código no es un buen medio de expresión. esto es falso. ¿qué prefiere ver? esto: // comprobar si el empleado tiene derecho a todos los beneficios if ((employee.flags & hourly_flag) && (employee.age > 65)) o esto otro: if (employee.iseligibleforfullbenefits()) apenas se tardan unos segundos en explicar nuestras intenciones en el código. en muchos casos, basta con crear una función que diga lo mismo que 89el comentario que pensaba escribir. comentarios de calidad algunos comentarios son necesarios o beneficiosos. veremos algunos de los que considero válidos. no obstante, recuerde que el único comentario realmente bueno es el que no tiene que escribir. comentarios legales en ocasiones, nuestros estándares corporativos de creación de código nos obligan a crear determinados comentarios por motivos legales. por ejemplo, los comentarios de derechos de autor son necesarios y deben incluirse al inicio de cada archivo. el siguiente encabezado de comentario se incluye de forma estándar al inicio de todos los archivos fuente de fitnesse. nuestro ide evita que este comentario parezca sobrante replegándolo de forma automática. // copyright (c) 2003,2004,2005 de object mentor, inc. todos los derechos reservados. // publicado bajo las condiciones de la licencia pública general gnu versión 2 o posterior. este tipo de comentarios no deben ser contratos ni tomos legales. siempre que sea posible, haga referencia a una licencia estándar o a otro documento externo en lugar de incluir todos los términos y condiciones en el comentario. comentarios informativos en ocasiones es útil proporcionar información básica con un comentario. por ejemplo, el siguiente comentario explica el valor devuelto por un método abstracto: // devuelve una instancia del elemento responder probado. protected abstract responder responderinstance(); estos comentarios pueden ser útiles, pero es mejor usar el nombre de la función para transmitir la información siempre que sea posible. por ejemplo, 90en este caso el comentario sería redundante si cambiamos el nombre de la función por responderbeingtested. veamos un ejemplo mejor: // el formato coincide con kk:mm:ss eee, mmm dd, yyyy pattern timematcher = pattern.compile( “\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*”); en este caso, el comentario nos indica que la expresión regular debe coincidir con una fecha y una hora con el formato aplicado por la función simpledateformat.format con la cadena de formato especificada. hubiera resultado mejor y más claro si el código se hubiera cambiado a una clase especial que convirtiera los formatos de fechas y horas. de ese modo el comentario habría sido superfluo. explicar la intención en ocasiones, un comentario es algo más que información útil sobre la implementación y proporciona la intención de una decisión. en el siguiente caso, vemos una interesante decisión documentada por un comentario. al comparar dos objetos, el autor decidió ordenar los objetos de su clase por encima de los objetos de otra. public int compareto(object o) { if (o instanceof wikipagepath) { wikipagepath p = (wikipagepath) o; string compressedname = stringutil.join(names, “”); string compressedargumentname = stringutil.join(p.names, “”); return compressedname.compareto(compressedargumentname); } return 1; // somos mayores porque somos el tipo correcto. } veamos otro ejemplo mejor. puede que no esté de acuerdo con la solución del programador, pero al menos sabe lo que intentaba hacer. public void testconcurrentaddwidgets() throws exception { widgetbuilder widgetbuilder = new widgetbuilder(new class[](boldwidget.class)); string text = “‘‘‘bold text’’’”; parentwidget parent = new boldwidget(new mockwidgetroot(), “‘‘‘bold text’’’”); atomicboolean failflag = new atomicboolean(); failflag.set(false); 91//nuestro mejor intento de obtener una condición de carrera //creando un gran número de procesos. for (int i = 0; i < 25000; i++) { widgetbuilderthread widgetbuiiderthread = new widgetbuilderthread(widgetbuilder, text, parent, failflag); thread thread = new thread(widgetbuilderthread); thread.start(); } assertequals(false, failflag.get()); } clarificación en ocasiones, basta con traducir el significado de un argumento o valor devuelto en algo más legible. por lo general, conviene buscar la forma de que el argumento o el valor devuelto sean claros por sí mismos; pero cuando forma parte de una biblioteca estándar o de código que no se puede alterar, un comentario aclarativo puede ser muy útil. public void testcompareto() throws exception { wikipagepath a = pathparser.parse(“pagea”); wikipagepath ab = pathparser.parse(“pagea.pageb”); wikipagepath b = pathparser.parse(“pageb”); wikipagepath aa = pathparser.parse(“pagea.pagea”); wikipagepath bb = pathparser.parse(“pageb.pageb”); wikipagepath ba = pathparser.parse(“pageb.pagea”); asserttrue(a.compareto(a) == 0); // a == a asserttrue(a.compareto(b) != 0); // a != b asserttrue(ab.compareto(ab) == 0); // ab == ab asserttrue(a.compareto(b) == -1); // a < b asserttrue(aa.compareto(ab) == -1); // aa < ab asserttrue(ba.compareto(bb) == -1); // ba < bb asserttrue(b.compareto(a) == 1); // b > a asserttrue(ab.compareto (aa) == 1); // ab > aa asserttrue(bb.compareto(ba) == 1); // bb > ba } pero también existe el riesgo de que un comentario aclarativo sea incorrecto. en el ejemplo anterior, compruebe lo difícil que resulta comprobar si los comentarios son correctos. esto explica por qué la clarificación es necesaria y también arriesgada. por ello, antes de escribir estos comentarios, asegúrese de que no hay una solución mejor y también de que sean precisos. 92advertir de las consecuencias en ocasiones es muy útil advertir a otros programadores de determinadas consecuencias. por ejemplo, el siguiente comentario explica por qué un determinado caso de prueba está desactivado: // no ejecutar a menos // que le sobre tiempo. public void _testwithreallybigfile() { writelinestofile(10000000); response.setbody(testfile); response.readytosend(this); string responsestring = output.tostring(); assertsubstring(“content-length: 1000000000”, responsestring); asserttrue(bytessent > 1000000000); } en la actualidad, evidentemente, desactivaríamos la prueba por medio del atributo @ignore con la correspondiente cadena explicativa: @ignore(“takes too long to run”) , pero antes de la aparición de junit 4, era habitual añadir un guion bajo delante del nombre del método. el comentario realizaba su cometido. veamos otro ejemplo: public static simpledateformat makestandardhttpdateformat() { //simpledataformat no es compatible con procesos, //por lo que debe crear cada instancia de forma independiente. simpledateformat df = new simpledateformat(“eee, dd mmm yyyy hh:mm:ss z”); df.settimezone (timezone.gettimezone (“gmt”)); return df; } seguramente conozca soluciones mejores para este problema. estoy de acuerdo, pero el comentario es perfectamente razonable. evita que un programador use un inicializador estático por motivos de eficacia. comentarios todo en ocasiones conviene usar notas con forma de comentarios //todo . en el 93siguiente caso, el comentario todo explica por qué la función tiene una implementación incorrecta y cuál debe ser su futuro. // todo-mdm no son necesarios // esperamos que desaparezca en el modelo definitivo protected versioninfo makeversion() throws exception { return null; } todo son tareas que el programador piensa que debería haber hecho pero que no es así. pueden ser un recordatorio para eliminar una función obsoleta o una petición para resolver un problema. pueden ser una solicitud para buscar un nombre más adecuado o para realizar un cambio que dependa de un evento planeado. sea lo que sea, no es excusa para mantener código incorrecto en el sistema. en la actualidad, muchos ide cuentan con funciones especiales para localizar comentarios todo , por lo que seguramente no se pierda. sin embargo, no colapse el código con estos comentarios. examínelos y elimine todos los que pueda. amplificación se puede usar un comentario para amplificar la importancia de algo que, en caso contrario, parecería irrelevante. string listitemcontent = match.group(3).trim(); // el recorte es importante. elimina los espacios iniciales // que harían que el elemento se reconociera como // otra lista. new listitemwidget(this, listitemcontent, this.level + 1); return buildlist(text.substring(match.end())); javadoc en api públicas no hay nada más útil y satisfactorio que una api pública bien descrita. los javadoc de la biblioteca estándar de java son un ejemplo. sería muy complicado crear programas de java sin ellos. si usa una api pública, debe crear javadoc de calidad para la misma, pero recuerde el siguiente consejo a lo largo del capítulo: los javadoc pueden ser 94tan ambiguos, amplios y descorteses como cualquier otro tipo de documento. comentarios incorrectos muchos comentarios pertenecen a esta categoría. suelen ser excusas de código pobre o justificaciones de decisiones insuficientes, algo así como si el programador se hablara a sí mismo. balbucear añadir un comentario sin razón o porque el proceso lo requiere es un error. si decide escribir un comentario, tómese el tiempo necesario para asegurarse de que sea el mejor que puede redactar. el siguiente ejemplo es de fitnesse, donde un comentario sin duda sería de utilidad, pero el autor tenía prisa o no prestó demasiada atención. su balbuceo generó un enigma: public void loadproperties() { try { string propertiespath = propertieslocation + “/” + properties_file; fileinputstream propertiesstream = new fileinputstream(propertiespath); loadedproperties.load(propertiesstream); } catch(ioexception e) { // si no hay archivos de propiedades significan que cargan las predeterminadas } } ¿qué significa el comentario del bloque catch ? seguro que algo para el autor, pero el significado no está claro. aparentemente, si se genera ioexception , significa que no hay archivo de propiedades y, en ese caso, se cargan los valores predeterminados. ¿pero quién carga los valores predeterminados? ¿se cargan antes de la invocación de loadproperties.load o loadproperties.load captura la excepción, carga los valores predeterminados y después nos pasa la excepción para que la ignoremos? ¿o será que loadproperties.load carga todos los valores 95predeterminados antes de intentar abrir el archivo? ¿intentaba el autor consolarse por dejar el bloque catch vacío? ésta es la posibilidad más temida, ¿se estaba diciendo que volviera más tarde para crear el código para cargar los valores predeterminados? nuestro único recurso es examinar el código en otras partes del sistema para determinar qué sucede. cualquier comentario que le obligue a buscar su significado en otro módulo ha fallado en su intento de comunicación y no merece los bits que consume. comentarios redundantes el listado 4-1 muestra una sencilla función con un comentario de encabezado totalmente redundante. seguramente se tarde más en leer que el propio código. listado 4-1 waitforclose. // método de utilidad devuelto cuando this.closed es true. genera una excepción // si se alcanza el tiempo de espera. public synchronized void waitforclose(final long timeoutmillis) throws exception { if (!closed) { wait(timeoutmillis); if(!closed) throw new exception (“mockresponsesender could not be closed”); } } ¿para qué sirve este comentario? no es más informativo que el código. no lo justifica ni transmite la intención ni la lógica. no es más fácil de leer que el código. de hecho, es menos preciso y obliga al lector a aceptar la falta de precisión en lugar de a entenderlo. es como un vendedor de coches de segunda menos que le asegura que no hace falta revisar el motor. fíjese ahora en la legión de javadoc inútiles y redundantes del listado 4- 2, obtenido de tomcat. estos comentarios únicamente ensucian y oscurecen el código. no tienen ninguna función documental. para empeorar las cosas, 96sólo le mostramos algunos. el módulo tiene muchos más. listado 4-2 containerbase.java (tomcat). public abstract class containerbase implements container, lifecycle, pipeline, mbeanregistration, serializable { /** * retardo del procesador para este componente. */ protected int backgroundprocessordelay = -1; /** * compatibilidad con eventos de ciclo vital de este componente. */ protected lifecyclesupport lifecycle = new lifecyclesupport(this); /** * escuchadores de eventos de contenedor de este contenedor. */ protected arraylist listeners = new arraylist(); /** * implementación loader a la que se asocia este contenedor. */ protected loader loader = null; /** * implementación logger a la que se asocia este contenedor. */ protected log logger = null; /** * nombre de registrador asociado. */ protected string logname = null; /** * implementación manager a la que se asocia este contenedor. */ protected manager manager = null; /** * clúster al que se asocia este contenedor. */ protected cluster cluster = null; /** * nombre legible de este contenedor. 97*/ protected string name = null; /** * contenedor principal de este contenedor. */ protected container parent = null; /** * cargador de clase principal que configurar al instalar un elemento * loader. */ protected classloader parentclassloader = null; /** * objeto pipeline al que se asocia este contenedor. */ protected pipeline pipeline = new standardpipeline(this); /** * objeto realm al que se asocia este contenedor. */ protected realm realm = null; /** * objeto dircontext de recursos al que se asocia este contenedor. */ protected dircontext resources = null; comentarios confusos en ocasiones, a pesar de las buenas intenciones, un programador realiza una afirmación en sus comentarios que no es del todo precisa. fíjese otra vez en el comentario redundante y confuso del listado 4-1. ¿sabe por qué es confuso? el método no devuelve nada cuando this.closed se convierte en true . devuelve algo si this.closed es true ; en caso contrario, espera y genera una excepción si this.closed no es true . este sutil fragmento, oculto en un comentario más difícil de leer que el cuerpo del código, puede hacer que otro programador invoque la función con la esperanza de que devuelva algo cuando this.closed sea true . ese pobre programador se encontrará en una sesión de depuración intentando determinar por qué el código se ejecuta tan lentamente. 98comentarios obligatorios es una locura tener una regla que afirme que todas las funciones deben tener un javadoc o que todas las variables deben tener un comentario. este tipo de comentarios ensucian el código y generan confusión y desorganización. por ejemplo, los javadoc obligatorios para todas las funciones crean abominaciones como el listado 4-3. no sirven de nada, complican el código y constituyen posibles engaños y desorientaciones. listado 4-3 /** * * @param title el título del cd * @param author el autor del cd * @param tracks el número de pistas del cd * @param durationinminutes la duración del cd en minutos */ public void addcd(string title, string author, int tracks, int durationinminutes) { cd cd = new cd(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = duration; cdlist.add(cd); } comentarios periódicos en ocasiones, se añade un comentario al inicio de un módulo cada vez que se edita. estos comentarios acumulan una especie de registro de todos los cambios realizados. he visto módulos con decenas de páginas con estas entradas. * cambios (11-oct-2001) * ----------------------------- * 11-oct- 2001 : reorganización de la clase y cambio a un nuevo paquete * com.jrefinery.date (dg); * 05-nov- 2001 : se añade un método getdescription() y se elimina la clase notabledate (dg); 99* 12-nov- 2001 : ibd requiere el método setdescription(), una vez eliminada la clase notabledate * (dg); se cambian getpreviousdayofweek(), getfollowingdayofweek() * y getnearestdayofweek() para corregir errores (dg); * 05-dic- 2001 : error corregido en la clase spreadsheetdate (dg); * 29-may- 2002 : se transfieren todas las constantes de mes a una interfaz * independiente (monthconstants) (dg); * 27-ago- 2002 : error corregido en el método addmonths(), gracias a nálevka petr (dg); * 03-oct- 2002 : errores indicados por checkstyle (dg) corregidos; * 13-mar- 2003 : implementación de serializable (dg); * 29-may- 2003 : error corregido en el método addmonths (dg); * 04-sep- 2003 : implementación de comparable. actualización de los javadoc isinrange (dg); * 05-ene- 2005 : error corregido en el método addyears() (1096202) (dg); hace tiempo hubo una buena razón para crear y mantener estas entradas de registro al inicio de cada módulo. carecíamos de sistemas de control de código fuente que se encargaran de ello, pero en la actualidad, estas entradas son elementos sobrantes que complican los módulos. debe eliminarlas totalmente. comentarios sobrantes en ocasiones vemos comentarios que simplemente sobran. restan importancia a lo evidente y no ofrecen información nueva. /** * constructor predeterminado. */ protected annualdaterule() { } ¿en serio? ¿y este otro?: /** día del mes. */ private int dayofmonth; y aquí el parangón de la redundancia: /** * devuelve el día del mes. 100* * @return el día del mes. */ public int getdayofmonth() { return dayofmonth; } estos comentarios son tan inservibles que aprendemos a ignorarlos. al leer el código, la vista los salta. con el tiempo, los comentarios empiezan a mentir cuando cambia el código que les rodea. el primer comentario del listado 4-4 parece correcto [25] . explica por qué se ignora el bloque catch , pero el segundo comentario sobra. parece que el programador estaba tan frustrado con crear bloques try/catch en la función que necesitaba explotar. listado 4-4 startsending. private void startsending() { try { dosending(); } catch(socketexception e) { // normal, alguien ha detenido la solicitud. } catch(exception e) { try { response.add(errorresponder.makeexceptionstring(e)); response.closeall(); } catch(exception e1) { //¡un respiro! } } } en lugar de explotar en un comentario sin sentido, el programador debería haber sabido que su frustración se podría aliviar mejorando la estructura del código. tendría que haber centrado su energía en extraer el último bloque try/catch en una función independiente, como muestra el 101listado 4-5. listado 4-5 startsending (refactorizado). private void startsending() { try { dosending(); } catch(socketexception e) { // normal. alguien ha detenido la solicitud. } catch(exception e) { addexceptionandcloseresponse(e); } } private void addexceptionandcloseresponse(exception e) { try { response.add(errorresponder.makeexceptionstring(e)); response.closeall(); } catch(exception e1) { } } cambie la tentación de crear elementos sobrantes por la determinación de limpiar su código. mejorará como programador y será más fácil. comentarios sobrantes espeluznantes los javadoc también pueden ser innecesarios. ¿para qué sirven los siguientes javadoc (de una conocida biblioteca) de código abierto? la respuesta: para nada. son comentarios redundantes creados en un intento equivocado de redactar documentación. /** el nombre. */ private string name; /** la versión. */ 102private string version; /** el licencename. */ private string licencename; /** la versión. */ private string info; vuelva a leer los comentarios. ¿detecta el error de corta y pega? si los autores no prestan atención al escribir sus comentarios (o al pegarlos), ¿por qué se espera que sean de utilidad para los lectores? no usar comentarios si se puede usar una función o una variable fíjese en el siguiente código: // ¿el módulo de la lista global <mod> depende del // subsistema del que formamos parte? if (smodule.getdependsubsystems().contains(subsysmod.getsubsystem())) se podría cambiar sin el comentario de esta forma: arraylist moduledependees = smodule.getdependsubsystems(); string oursubsystem = subsysmod.getsubsystem(); if (moduledependees.contains(oursubsystem)) el autor del código original seguramente escribió primero el comentario (improbable) y después el código para ajustarlo al comentario. sin embargo, el autor tendría que haber refactorizado el código, como hice yo, para poder eliminar el comentario. marcadores de posición en ocasiones los programadores marcan una determinada posición en un archivo. por ejemplo, recientemente encontré esto en un programa: // acciones ////////////////////////////////// son escasas las ocasiones en las que tiene sentido agrupar funciones bajo esta estructura. por lo general, debe eliminarse, sobre todo la molesta hilera de barras al final. piénselo de esta forma. estas estructuras son atractivas si no las usa demasiado. por ello, úselas esporádicamente y sólo cuando el beneficio sea 103significativo. si las usa en exceso, acabarán por ser ignoradas. comentarios de llave de cierre en ocasiones, los programadores incluyen comentarios especiales en llaves de cierre, como en el listado 4-6. aunque pueda tener sentido en funciones extensas con estructuras anidadas, únicamente estorba a las funciones encapsuladas y de pequeño tamaño que nos gustan. por ello, si siente el deseo de marcar sus llaves de cierre, pruebe a reducir el tamaño de sus funciones. listado 4-6 wc.java. public class wc { public static void main(string[] args) { bufferedreader in = new bufferedreader(new inputstreamreader(system.in)); string line; int linecount = 0; int charcount = 0; int wordcount = 0; try { while ((line = in.readline()) != null) { linecount++; charcount += line.length(); string words[] = line.split(“\\w”); wordcount += words.length; } //while system.out.println(“wordcount = ” + wordcount); system.out.println(“linecount = ” + linecount); system.out.println(“charcount = ” + charcount); } // try catch (ioexception e) { system.err.println(“error: ” + e.getmessage()); } //catch } //main } asignaciones y menciones /* añadido por rick */ los sistemas de control de código fuente recuerdan a la perfección quién ha añadido qué y cuándo. no es necesario plagar el código con pequeñas 104menciones. puede pensar que estos comentarios son útiles y que ayudan a otros a hablar sobre el código, pero en realidad sobreviven durante años y cada vez son menos precisos y relevantes. el sistema de control de código fuente es el punto idóneo para este tipo de información. código comentado no hay nada más odioso que el código comentado. ¡no lo haga! inputstreamresponse response = new inputstreamresponse(); response.setbody(formatter.getresultstream(), formatter.getbytecount()); // inputstream resultsstream = formatter.getresultstream(); // streamreader reader = new streamreader(resultsstream); // response.setcontent(reader.read(formatter.getbytecount())); los lectores que vean código comentado no tendrán el valor de borrarlo. pensarán que está ahí por algo y que es demasiado importante para borrarlo. por ello, el código comentado se acumula como los sedimentos en una botella de vino malo. fíjese en este fragmento de apache commons: this.bytepos = writebytes(pngidbytes, 0); //hdrpos = bytepos; writeheader(); writeresolution(); //datapos = bytepos; if (writeimagedata()) { writeend(); this.pngbytes = resizebytearray(this.pngbytes, this.maxpos); } else { this.pngbytes = null; } return this.pngbytes; ¿por qué hay dos líneas comentadas? ¿son importantes? ¿se han conservado como recordatorio de un cambio inminente o es algo que alguien comentó hace años y no se ha preocupado de limpiar? hubo una época, en la década de 1960, en la que el código comentado pudo ser útil, pero hace tiempo que contamos con buenos sistemas de control de código fuente, sistemas que recuerdan el código por nosotros. ya no tenemos que comentarlo. elimínelo. no lo perderá. se lo aseguro. 105comentarios html el html en comentarios de código fuente es una aberración, como puede apreciar en el siguiente fragmento. dificulta la lectura de los comentarios donde debería ser más fácil; el editor o ide. si los comentarios se van a extraer con una herramienta (como javadoc) para mostrarlos en una página web, debe ser responsabilidad de dicha herramienta y no del programador el adornar los comentarios con el correspondiente html. /** * tarea para ejecutar pruebas de aceptación. * esta tarea ejecuta pruebas de aceptación y publica los resultados. * <p/> * <pre> * uso: * &lt;taskdef name=&quot;execute-fitnesse-tests&quot; * classname=&quot;fitnesse.ant.executefitnesseteststask&quot; * classpathref=&quot;classpath&quot; /&gt; * or * &lt;taskdef classpathref=&quot;classpath&quot; * resource=&quot;tasks.properties&quot; /&gt; * <p/> * &lt;execute-fitnesse-tests * suitepage=&quot;fitnesse.suiteacceptancetests&quot; * fitnesseport=&quot;8082&quot; * resultsdir=&quot;$(results.dir)&quot; * resultshtmlpage=&quot;fit-results.html&quot; * classpathref=&quot;classpath&quot; /&gt; * </pre> */ información no local si tiene que escribir un comentario, asegúrese de que describa el código que le rodea. no ofrezca información global del sistema en el contexto de un comentario local. fíjese en el siguiente comentario javadoc. aparte de su terrible redundancia, también ofrece información sobre el puerto predeterminado y la función no tiene control alguno sobre el puerto predeterminado. el comentario no describe la función sino otra parte distinta 106del sistema. evidentemente, no hay garantías de que el comentario cambie cuando lo haga el código que contiene el valor predeterminado. /** * puerto para ejecutar fitnesse. el predeterminado es <b>8082</b>. * * @param fitnesseport */ public void setfitnesseport(int fitnesseport) { this.fitnesseport = fitnesseport; } demasiada información no incluya en sus comentarios interesantes reflexiones históricas ni irrelevantes descripciones de detalles. el siguiente comentario se ha extraído de un módulo diseñado para probar que una función puede codificar y descodificar base64. aparte del número rfc, el lector de este código no necesita la información obsoleta que contiene el comentario. /* rfc 2045 - extensiones multipropósito de correo de internet (mime) primera parte: formato del cuerpo de los mensajes de internet sección 6.8. codificación de transferencia de contenidos base64 el proceso de codificación representa grupos de 24 bits de la entrada como cadenas de salida de 4 caracteres codificados. procediendo de izquierda a derecha, se forma un grupo de 24 bits de entrada concatenando 3 grupos de 8 bits de entrada. estos 24 bits se tratan como 4 grupos concatenados de 6 bits, cada uno de los cuales se traduce en un solo dígito del alfabeto base64. cuando se codifica un flujo de bits mediante la codificación base64, el flujo de bits se debe considerar ordenado con el bit más significativo primero. esto es, el primer bit del flujo será el bit de orden más alto en el primer byte de 8 bits, y el octavo bit será el de orden más bajo en el primer byte de 8 bits, y así sucesivamente. */ conexiones no evidentes la conexión entre un comentario y el código que describe debe ser evidente. si se ha preocupado de escribir un comentario, lo mínimo es que el lector que lo vea entienda a qué se refiere. fíjese en este comentario obtenido de apache commons: 107/* * comienza con una matriz de tamaño suficiente para albergar todos los pixeles * (más bytes de filtro), y 200 bytes adicionales para la información de encabezado */ this.pngbytes = new byte[((this.width + 1) * this.height * 3) + 200]; ¿qué es un byte de filtro? ¿está relacionado con +1 ? ¿o con *3 ? ¿con ambos? ¿es un pixel un byte ? ¿por qué 200? la función de un comentario es explicar código que no se explica por sí mismo. es una lástima que un comentario requiera su propia explicación. encabezados de función las funciones breves apenas requieren explicación. un nombre bien elegido para una función que hace una cosa suele ser mejor que un encabezado de comentario. javadocs en código no público a pesar de la utilidad de los javadoc para las api públicas, no sirven para código no dirigido a consumo público. la generación de páginas javadoc para clases y funciones de un sistema no suele ser útil y la formalidad adicional de los comentarios javadoc no es más que una distracción. ejemplo escribí el módulo del listado 4-7 para la primera versión de xp immersion . debía ser un ejemplo de estilo incorrecto de creación de código y comentarios. después, kent beck refactorizó este código en algo mucho más atractivo delante de varios alumnos. posteriormente, adapté el ejemplo para mi libro agile software development, principles, patterns, and practices y para el primero de mis artículos craftsman publicados en la revista software development . lo que me fascina de este módulo es que hubo un tiempo en que muchos 108lo hubiéramos considerado bien documentado. ahora vemos que es un auténtico desastre. a ver cuántos problemas detecta en los comentarios. listado 4-7 generateprimes.java. /** * esta clase genera números primos hasta la cantidad máxima especificada por el * usuario. el algoritmo usado es la criba de eratóstenes. * <p> * eratóstenes de cirene, 276 a. c., cirene, libia - * 194 a. c., alejandría. el primer hombre en calcular la * circunferencia de la tierra. también trabajó con calendarios * con años bisiestos y fue responsable de la biblioteca de alejandría. * <p> * el algoritmo es muy simple. dada una matriz de enteros * empezando por el 2, se tachan todos los múltiplos de 2. se busca el siguiente * entero sin tachar y se tachan todos sus múltiplos. * repetir hasta superar la raíz cuadrada del valor * máximo. * * ©author alphonse * ©version 13 feb 2002 atp */ import java.util.*; public class generateprimes { /** * @param maxvalue es el límite de generación. */ public static int[] generateprimes(int maxvalue) { if (maxvalue >= 2) //el único caso válido { // declaraciones int s = maxvalue + 1; // tamaño de la matriz boolean[] f = new boolean[s]; int i; // inicializar la matriz en true. for (i = 0; i < s; i++) f[i] = true; // eliminar los números no primos conocidos f[0] = f[1] = false; // cribar int j; 109for (i = 2; i < math.sqrt(s) + 1; i++) { if (f[i]) // si no está tachado, tachar sus múltiplos. { for (j = 2 * i; j < s; j += i) f[j] = false; // el múltiplo no es primo } } // ¿cuántos primos hay? int count = 0; for (i = 0; i < s; i++) { if (f[i]) count++; // contador. } int[] primes = new int[count]; // enviar primos al resultado for (i = 0, j = 0; i < s; i++) { if (f[i]) // si es primo primes[j++] = i; } return primes; // devolver los primos } else // maxvalue < 2 return new int[0]; // devolver matriz null si la entrada no es correcta. } } en el listado 4-8 puede ver una versión refactorizada del mismo módulo. se ha limitado considerablemente el uso de comentarios. hay sólo dos en todo el módulo y ambos claramente descriptivos. listado 4-8 primegenerator.java (refactorizado). /** * esta clase genera números primos hasta la cantidad máxima especificada por el * usuario. el algoritmo usado es la criba de eratóstenes. dada una matriz de enteros * empezando por el 2: buscar el primer entero sin tachar y tachar todos sus * múltiplos. repetir hasta que no haya más múltiplos en la matriz. */ public class primegenerator { 110private static boolean[] crossedout; private static int[] result; public static int[] generateprimes(int maxvalue) { if (maxvalue < 2) return new int[0]; else { uncrossintegersupto(maxvalue); crossoutmultiples(); putuncrossedintegersintoresult(); return result; } } private static void uncrossintegersupto(int maxvalue) { crossedout = new boolean[maxvalue + 1]; for (int i = 2; i < crossedout.length; i++) crossedout[i] = false; } private static void crossoutmultiples() { int limit = determineiterationlimit(); for (int i = 2; i <= limit; i++) if (notcrossed(i)) crossoutmultiplesof(i); } private static int determineiterationlimit() { // cada múltiplo en la matriz tiene un factor primordial que // es menor o igual que la raíz del tamaño de la matriz, // entonces no tenemos que tachar múltiplos de números // más grande que esa raíz. double iterationlimit = math.sqrt(crossedout.length); return (int) iterationlimit; } private static void crossoutmultiplesof (int i) { for (int multiple = 2 * i; multiple < crossedout.length; multiple += i) crossedout[multiple] = true; } private static boolean notcrossed(int i) { return crossedout[i] == false; } private static void putuncrossedintegersintoresult() 111{ result = new int[numberofuncrossedintegers()]; for (int j = 0, i = 2; i < crossedout.length; i++) if (notcrossed(i)) result[j++] = i; } private static int numberofuncrossedintegers() { int count = 0; for (int i = 2; i < crossedout.length; i++) if (notcrossed(i)) count++; return count; } } se podría decir que el primer comentario es redundante ya que es muy similar a la función generateprimes , pero creo que muestra mejor el algoritmo al lector, motivo por el que lo he mantenido. el segundo argumento es sin duda necesario. explica la lógica del uso de la raíz cuadrada como límite del bucle. no encontré otro nombre de variable más sencillo ni otra estructura de código que lo aclarara más. por otra parte, el uso de la raíz cuadrada podría resultar presuntuoso. ¿realmente se ahorra tanto tiempo limitando la iteración a la raíz cuadrada? ¿el cálculo de la raíz cuadrada llevaría más tiempo del que se ahorra? conviene analizarlo. el uso de la raíz cuadrada como límite de iteración satisface al viejo hacker de c y de lenguajes de ensamblado de mi interior, pero no estoy convencido de que merezca el tiempo y el esfuerzo que los demás puedan dedicar a entenderlo. bibliografía [kp78] : kernighan and plaugher, the elements of programming style , 2d. ed., mcgraw-hill, 1978. 1125 formato cuando los usuarios miran entre bastidores, queremos que queden 113impresionados por el atractivo, la coherencia y la atención al detalle que perciben. queremos que el orden les sorprenda, que abran los ojos con asombro cuando se desplacen por los módulos. queremos que aprecien que se trata de un trabajo de profesionales. si ven una masa amorfa de código que parece escrito por un grupo de marineros borrachos, es probable que piensen que sucederá lo mismo en otros aspectos del proyecto. debe preocuparse por el formato de su código. debe elegir una serie de reglas sencillas que controlen el formato del código y después aplicarlas de forma coherente. si trabaja en equipo, debe acordar una serie de reglas que todos los miembros deben cumplir. también es muy útil usar una herramienta automatizada que se encargue de aplicar las reglas. la función del formato en primer lugar, debe ser claro. el formato de código es importante, demasiado importante como para ignorarlo y también demasiado importante como para tratarlo de forma religiosa. el formato del código se basa en la comunicación y la comunicación debe ser el principal pilar de un desarrollador profesional. puede que piense que conseguir que algo funcione es la principal preocupación de un programador profesional. espero que este libro le haga cambiar de idea. la funcionalidad que cree hoy es muy probable que cambie en la siguiente versión, pero la legibilidad de su código afectará profundamente a todos los cambios que realice. el estilo del código y su legibilidad establecen los precedentes que afectan a la capacidad de mantenimiento y ampliación mucho después de que el código cambie. su estilo y su disciplina sobrevivirán, aunque el código no lo haga. veamos qué aspectos del formato nos permiten comunicarnos mejor. formato vertical comencemos por el tamaño vertical. ¿qué tamaño debe tener un archivo 114fuente? en java, el tamaño de los archivos está relacionado con el tamaño de las clases, como veremos más adelante. por el momento, nos detendremos en el tamaño de los archivos. ¿qué tamaño tienen la mayoría de archivos fuente de java? existe una amplia gama de tamaños e importantes diferencias de estilo, como se aprecia en la figura 5.1. figura 5.1. escala log de distribuciones de longitud de archivos (altura del cuadro = sigma). se describen siete proyectos: junit, fitnesse, testng, time and money, jdepend, ant y tomcat. las líneas que cruzan los cuadros muestran la longitud máxima y mínima de cada proyecto. el cuadro muestra aproximadamente un tercio (una desviación estándar [26] ) de los archivos. la parte central del cuadro es la media. por tanto, el tamaño de archivo medio del proyecto fitnesse es de 65 líneas y un tercio de los archivos ocupan entre 40 y 100+ líneas. el mayor archivo de fitnesse tiene unas 400 líneas y el de menor tamaño, 6. es una escala de registro, de modo que la pequeña diferencia de posición vertical supone una gran diferencia en tamaño absoluto. junit, fitnesse y time and money tienen archivos relativamente pequeños. ninguno supera las 500 líneas y la mayoría tienen menos de 200. tomcat y ant, por su parte, tienen archivos con varios miles de líneas de 115longitud y más de la mitad superan las 200. ¿qué significa todo esto? aparentemente se pueden crear sistemas (fitnesse se aproxima a las 50 000 líneas) a partir de archivos de unas 200 líneas de longitud, con un límite máximo de 500. aunque no debería ser una regla, es un intervalo aconsejable. los archivos de pequeño tamaño se entienden mejor que los grandes. la metáfora del periódico piense en un artículo de periódico bien escrito. en la parte superior espera un titular que indique de qué se trata la historia y le permita determinar si quiere leerlo o no. el primer párrafo ofrece una sinopsis de la historia, oculta los detalles y muestra conceptos generales. al avanzar la lectura, aumentan los detalles junto con todas las fechas, nombres, citas y otros elementos. un archivo de código debe ser como un artículo de periódico. el nombre debe ser sencillo pero claro. por sí mismo, debe bastar para indicarnos si estamos o no en el módulo correcto. los elementos superiores del archivo deben proporcionar conceptos y algoritmos de nivel superior. los detalles deben aumentar según avanzamos, hasta que en la parte final encontremos las funciones de nivel inferior del archivo. un periódico se compone de varios artículos, algunos muy reducidos y otros de gran tamaño. no hay muchos que ocupen toda la página con texto, para que el periódico sea manejable. si el periódico fuera un único y extenso texto con una aglomeración desorganizada de hechos, fechas y nombres, no lo leeríamos. apertura vertical entre conceptos la práctica totalidad del código se lee de izquierda a derecha y de arriba a abajo. cada línea representa una expresión o una cláusula, y cada grupo de líneas representa un pensamiento completo. estos pensamientos deben separarse mediante líneas en blanco. fíjese en el listado 5-1. hay líneas en blanco que separan la declaración 116del paquete, las importaciones y las funciones. es una regla muy sencilla con un profundo efecto en el diseño visual del código. cada línea en blanco es una pista visual que identifica un nuevo concepto independiente. al avanzar por el listado, la vista se fija en la primera línea que aparece tras una línea en blanco. listado 5-1 boldwidget.java package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = “‘‘‘.+?’’’”; private static final pattern pattern = pattern.compile (“‘‘‘(.+?)’’’”, pattern.multiline + pattern.dotall ); public boldwidget(parentwidget parent, string text) throws exception { super(parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group(1)); } public string render() throws exception { stringbuffer html = new stringbuffer(“<b>”); html.append(childhtml()).append (“</b>”); return html.tostring(); } } si eliminamos las líneas en blanco, como en el listado 5-2, se oscurece la legibilidad del código. listado 5-2 boldwidget.java package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = “‘‘‘.+?’’’”; private static final pattern pattern = pattern.compile(“‘‘‘(.+?)’’’”, pattern.multiline + pattern.dotall); public boldwidget(parentwidget parent, string text) throws exception { 117super(parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group(1));} public string render() throws exception { stringbuffer html = new stringbuffer(“<b>”); html.append(childhtml()).append(“</b>”); return html.tostring(); } } este efecto aumenta todavía más si no centramos la vista. en el primer ejemplo, los distintos grupos de líneas saltan a la vista, mientras que en el segundo es una mezcla amorfa. la diferencia entre ambos listados es una ligera apertura vertical. densidad vertical si la apertura separa los conceptos, la densidad vertical implica asociaciones. por tanto, las líneas de código con una relación directa deben aparecer verticalmente densas. fíjese en cómo los comentarios sin sentido del listado 5-3 anulan la asociación entre las dos variables de instancia. listado 5-3 public class reporterconfig { /** * nombre de clase del escuchador */ private string m_classname; /** * propiedades del escuchador */ private list<property> m_properties = new arraylist<property>(); public void addproperty(property property) { m_properties.add(property); } el listado 5-4 es mucho más fácil de leer. lo apreciamos a simple vista o al menos yo lo hago. al mirarlo, veo que es una clase con dos variables y un método, sin tener que mover la cabeza ni la vista. el listado anterior nos 118obliga a forzar la vista y a mover la cabeza para alcanzar el mismo nivel de comprensión. listado 5-4 public class reporterconfig { private string m_classname; private list<property> m_properties = new arraylist<property>(); public void addproperty(property property) { m_properties.add(property); } distancia vertical ¿alguna vez ha tenido que recorrer una clase, saltando de una función a otra, desplazándose por el código para intentar adivinar la relación y el funcionamiento de las funciones, y acabar totalmente confundido? ¿alguna vez ha escudriñado la cadena de herencia buscando la definición de una variable o función? resulta frustrante porque intenta comprender lo que hace el sistema, pero pierde el tiempo y su energía mental en intentar localizar y recordar sus elementos. los conceptos relacionados entre sí deben mantenerse juntos verticalmente [g10]. esta regla no funciona con conceptos de archivos independientes. por lo tanto, no debe separar conceptos relacionados en archivos independientes a menos que tenga un motivo de peso. de hecho, es uno de los motivos por los que se debe evitar el uso de variables protegidas. para los conceptos relacionados que pertenecen al mismo archivo, su separación vertical debe medir su importancia con respecto a la legibilidad del otro. debe evitar que el lector deambule entre archivos y clases. declaraciones de variables las variables deben declararse de la forma más aproximada a su uso. como las funciones son muy breves, las variables locales deben aparecer en la parte superior de cada función, como en este ejemplo de junit4.3.1. 119private static void readpreferences() { inputstream is = null; try { is = new fileinputstream(getpreferencesfile()); setpreferences(new properties(getpreferences())); getpreferences().load(is); } catch (ioexception e) { try { if (is != null) is.close(); } catch (ioexception e1) { } } } las variables de control de bucles deben declararse en la instrucción del bucle, como en esta pequeña función del mismo código fuente: public int counttestcases() { int count= 0; for ( test each : tests) count += each.counttestcases(); return count; } en casos excepcionales, una variable puede declararse en la parte superior de un bloque o antes de un bucle en una función extensa. puede ver este tipo de variable en la siguiente función de testng. … for (xmltest test: m_suite.gettests()) { testrunner tr = m_runnerfactory.newtestrunner(this, test); tr.addlistener(m_textreporter); m_testrunners.add(tr); invoker = tr.getinvoker(); for (itestngmethod m : tr.getbeforesuitemethods()) { beforesuitemethods.put(m.getmethod(), m); } for (itestngmethod m : tr.getaftersuitemethods()) { aftersuitemethods.put(m.getmethod(), m); } } … variables de instancia las variables de instancia, por su parte, deben declararse en la parte superior de la clase. esto no debe aumentar la distancia vertical de las variables, ya 120que en una clase bien diseñada se usan en muchos sino en todos sus métodos. existen discrepancias sobre la ubicación de las variables de instancia. en c++ suele aplicarse la denominada regla de las tijeras, que sitúa todas las variables de instancia en la parte inferior. en java, sin embargo, es habitual ubicarlas en la parte superior de la clase. no veo motivos para no hacerlo. lo importante es declarar las variables de instancia en un punto conocido para que todo el mundo sepa dónde buscarlas. fíjese en el extraño caso de la clase testsuite de junit 4.3.1. he atenuado considerablemente esta clase para ilustrar este concepto. si se fija en la mitad del listado, verá dos variables de instancia declaradas. resultaría complicado ocultarlas en un punto mejor. cualquiera que lea este código tendría que toparse con las declaraciones por casualidad (como me pasó a mí). public class testsuite implements test { static public test createtest(class<? extends testcase> theclass, string name) { … } public static constructor<? extends testcase> gettestconstructor(class<? extends testcase> theclass) throws nosuchmethodexception { … } public static test warning(final string message) { … } private static string exceptiontostring(throwable t) { … } private string fname; private vector<test> ftests = new vector<test>(10); public testsuite() { } public testsuite(final class<? extends testcase> theclass) { … } public testsuite(class<? extends testcase> theclass, string name) { … } 121… … … … } funciones dependientes si una función invoca otra, deben estar verticalmente próximas, y la función de invocación debe estar por encima de la invocada siempre que sea posible. de este modo el programa fluye con normalidad. si la convención se sigue de forma fiable, los lectores sabrán que las definiciones de función aparecen después de su uso. fíjese en el fragmento de fitnesse del listado 5-5. la función superior invoca las situadas por debajo que, a su vez, invocan a las siguientes. esto facilita la detección de las funciones invocadas y mejora considerablemente la legibilidad del módulo completo. listado 5-5 wikipageresponder.java. public class wikipageresponder implements secureresponder { protected wikipage page; protected pagedata pagedata; protected string pagetitle; protected request request; protected pagecrawler crawler; public response makeresponse(fitnessecontext context, request request) throws exception { string pagename = getpagenameordefault(request, “frontpage”); loadpage(pagename, context); if (page == null) return notfoundresponse(context, request); else return makepageresponse(context); } private string getpagenameordefault(request request, string defaultpagename) { string pagename = request.getresource(); if (stringutil.isblank(pagename)) pagename = defaultpagename; return pagename; } protected void loadpage(string resource, fitnessecontext context) throws exception { wikipagepath path = pathparser.parse(resource); 122crawler = context.root.getpagecrawler(); crawler.setdeadendstrategy(new virtualenabledpagecrawler()); page = crawler.getpage(context.root, path); if (page != null) pagedata = page.getdata(); } private response notfoundresponse(fitnessecontext context, request request) throws exception { return new notfoundresponder().makeresponse(context, request); } private simpleresponse makepageresponse(fitnessecontext context) throws exception { pagetitle = pathparser.render(crawler.getfullpath(page)); string html = makehtml(context); simpleresponse response = new simpleresponse(); response.setmaxage(0); response.setcontent(html); return response; } … además, este fragmento es un buen ejemplo de ubicación de constantes en un nivel correcto [g35]. la constante frontpage se podría haber ocultado en la función getpagenameordefault , pero eso habría ocultado una constante conocida y esperada en una función de nivel inferior de forma incorrecta. es mejor pasar la constante desde un punto en el que tiene sentido a la posición en la que realmente se usa. afinidad conceptual determinados conceptos de código deben estar próximos a otros. tienen una afinidad conceptual concreta. cuanto mayor sea esta afinidad, menor distancia vertical debe existir entre ellos. como hemos visto, esta afinidad se puede basar en una dependencia directa, como cuando una función invoca a otra, o cuando usa una variable. pero hay otras causas de afinidad. puede generarse porque un grupo de funciones realice una operación similar. fíjese en este fragmento de código de junit 4.3.1: public class assert { static public void asserttrue(string message, boolean condition) { 123if (!condition) fail(message); } static public void asserttrue(boolean condition) { asserttrue (null, condition); } static public void assertfalse(string message, boolean condition) { asserttrue(message, !condition); } static public void assertfalse(boolean condition) { assertfalse(null, condition); } … estas funciones tienen una elevada afinidad conceptual ya que comparten un sistema de nombres común y realizan variantes de la misma tarea básica. el hecho de que se invoquen unas a otras es secundario. aunque no lo hicieran, deberían seguir estando próximas entre ellas. orden vertical por lo general, las dependencias de invocaciones de funciones deben apuntar hacia abajo. es decir, la función invocada debe situarse por debajo de la que realice la invocación [27] . esto genera un agradable flujo en el código fuente, de los niveles superiores a los inferiores. como sucede en los artículos del periódico, esperamos que los conceptos más importantes aparezcan antes y que se expresen con la menor cantidad de detalles sobrantes. esperamos que los detalles de nivel inferior sean los últimos. de este modo, podemos ojear los archivos de código y captar el mensaje en las primeras funciones sin necesidad de sumergirnos en los detalles. el listado 5-5 se organiza de esta forma. puede que otros ejemplos mejores sean los listados 15-5 y 3-7. formato horizontal 124¿qué ancho debe tener una línea? para responderlo, fíjese en la anchura de las líneas de un programa convencional. de nuevo, examinamos siete proyectos diferentes. en la figura 5.2 puede ver la distribución de longitud de todos ellos. la regularidad es impresionante, en especial en tomo a los 45 caracteres. de hecho, los tamaños entre 20 y 60 representan un uno por cien del número total de líneas. ¡eso es un 40 por 100! puede que otro 30 por 100 sea menos de 10 caracteres de ancho. recuerde que es una escala de registro, de modo que la apariencia lineal es muy significativa. es evidente que los programadores prefieren líneas menos anchas. figura 5.2. distribución de anchura de líneas en java. esto sugiere que debemos intentar reducir las líneas de código. el antiguo límite hollerith de 80 es un tanto arbitrario y no me opongo a líneas que tienen 100 o incluso 120, pero no más. como norma, no debe tener que desplazarse hacia la derecha. los monitores modernos son más anchos y los programadores noveles pueden reducir la fuente para encajar hasta 200 caracteres en la pantalla. no lo haga. mi límite personal es de 120. apertura y densidad horizontal 125usamos el espacio en blanco horizontal para asociar elementos directamente relacionados y separar otros con una relación menos estrecha. fíjese en la siguiente función: private void measureline(string line) { linecount++; int linesize = line.length(); totalchars += linesize; linewidthhistogram.addline(linesize, linecount); recordwidestline(linesize); } hemos rodeado los operadores de asignación con espacios en blanco para destacarlos. las instrucciones de asignación tienen dos elementos principales: el lado izquierdo y el derecho. los espacios acentúan esta separación. por otra parte, no hemos incluido espacios entre los nombres de las funciones y el paréntesis de apertura, ya que la función y sus argumentos están estrechamente relacionados. su separación los desconectaría. separo los argumentos en los paréntesis de invocación de la función para acentuar la coma e indicar que los argumentos son independientes. el espacio en blanco también se usa para acentuar la precedencia de los operadores: public class quadratic { public static double root1(double a, double b, double c) { double determinant = determinant(a, b, c); return (-b + math.sqrt(determinant)) / (2*a); } public static double root2(int a, int b, int c) { double determinant = determinant(a, b, c); return (-b - math.sqrt(determinant)) / (2*a); } private static double determinant(double a, double b, double c) { return b*b - 4*a*c; } } fíjese en lo bien que se leen las ecuaciones. los factores carecen de espacios en blanco ya que tienen una mayor precedencia. los términos se separan mediante espacios en blanco ya que la suma y la resta son de precedencia inferior. desafortunadamente, muchas herramientas de formato de código ignoran la precedencia de los operadores e imponen un espaciado uniforme. por ello, separaciones sutiles como las anteriores suelen perderse tras modificar el 126formato del código. alineación horizontal cuando era programador de lenguajes de ensamblado [28] , usaba la alineación horizontal para acentuar determinadas estructuras. cuando comencé a programar en c, c++ y java, seguía intentando alinear los nombres de variables en un conjunto de declaraciones o todos los valores en un grupo de instrucciones de asignación. el aspecto de mi código era el siguiente: public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long requestprogress; private long requestparsingdeadline; private boolean haserror; public fitnesseexpediter( socket s, fitnessecontext context) throws exception { this.context = context; socket = s; input = s.getinputstream(); output = s.getoutputstream(); requestparsingtimelimit = 10000; } sin embargo, este tipo de alineación no es útil. parece enfatizar los elementos incorrectos y aleja la vista de la verdadera intención. por ejemplo, en la lista anterior de declaraciones, nos vemos tentados a leer la lista de nombres de variables sin fijarnos en sus tipos. del mismo modo, en la lista de instrucciones de asignación, nos fijamos en los valores sin ver el operador. para empeorarlo todo, las herramientas automáticas de formato suelen eliminar este tipo de alineación. por tanto, al final, ya no lo uso. ahora prefiero declaraciones y asignaciones sin alinear, como se muestra a 127continuación, ya que resaltan una deficiencia importante. si tengo listas extensas que deben alinearse, el problema es la longitud de las listas, no la falta de alineación. la longitud de la siguiente lista de declaraciones de fitnesseexpediter sugiere que esta clase debe dividirse. public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long request progress; private long requestparsingdeadline; private boolean haserror; public fitnesseexpediter(socket s, fitnessecontext context) throws exception { this.context = context; socket = s; input = s.getinputstream(); output = s.getoutputstream(); requestparsingtimelimit = 10000; } sangrado un archivo de código es una jerarquía más que un contorno. incluye información que pertenece a la totalidad del archivo, a sus clases individuales, a los métodos de las clases, a los bloques de los métodos y a los bloques de los bloques. cada nivel de esta jerarquía es un ámbito en el que se pueden declarar nombres y en el que se interpretan declaraciones e instrucciones ejecutables. para que esta jerarquía de ámbitos sea visible, sangramos las líneas de código fuente de acuerdo a su posición en la jerarquía. las instrucciones al nivel del archivo, como las declaraciones de clases, no se sangran. los métodos de una clase se sangran un nivel a la derecha de la clase. las implementaciones de dichos métodos se implementan un nivel a la derecha de la declaración de los métodos. las implementaciones de bloques se 128implementan un nivel a la derecha de su bloque contenedor y así sucesivamente. los programadores dependen de este sistema de sangrado. alinean visualmente las líneas a la izquierda para ver el ámbito al que pertenece. de este modo pueden acceder rápidamente a los ámbitos, como por ejemplo a implementaciones de instrucciones if o while , que no son relevantes para la situación actual. buscan en la izquierda nuevas declaraciones de métodos, variables e incluso clases. sin el sangrado, los programas serian prácticamente ilegibles. fíjese en los siguientes programas, sintáctica y semánticamente idénticos: public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket s) { serve(s, 10000); } public void serve(socket s, long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(s, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch(exception e) { e.printstacktrace(); } } } public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket s) { serve (s, 10000); } public void serve(socket s, long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(s, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch (exception e) { e.printstacktrace(); } } } a la vista puede incluso apreciar la estructura del archivo sangrado. detectamos inmediatamente las variables, constructores y métodos de acceso. en cuestión de segundos vemos que es una especie de interfaz de conexión, 129con un tiempo de espera. la versión sin sangrar, por su parte, es prácticamente impenetrable. romper el sangrado en ocasiones tenemos la tentación de romper la regla de sangrado con instrucciones if breves, bucles while breves o funciones breves. siempre que he sucumbido a esta tentación, he acabado por volver a aplicar el sangrado. por ello, evito replegar ámbitos a una línea, como en este ejemplo: public class commentwidget extends textwidget { public static final string regexp = “^#[^\r\n]*(?:(?:\r\n)|\n|\r)?”; public commentwidget(parentwidget parent, string text){super (parent, text);} public string render() throws exception { return “”; } } prefiero desplegar y sangrar los ámbitos: public class commentwidget extends textwidget { public static final string regexp = “^#[^\r\n]*(?:(?:\r\n)|\n|\r)?”; public commentwidget(parentwidget parent, string text) { super(parent, text); } public string render() throws exception { return “”; } } ámbitos ficticios en ocasiones, el cuerpo de una instrucción while o for es ficticio, como se muestra a continuación. no me gustan estas estructuras y prefiero evitarlas. en caso de no poder hacerlo, me aseguro de sangrar el cuerpo ficticio y de incluirlo entre paréntesis. no sabría decir cuántas veces me ha engañado un punto y coma situado al final de un bucle while en la misma línea. a menos que lo haga visible y lo sangre en una línea propia, es difícil de ver. while (dis.read(buf, 0, readbuffersize) != -1) ; 130reglas de equipo todo programador tiene sus reglas de formato preferidas, pero si forma parte de un equipo, el equipo manda. un equipo de programadores debe acordar un único estilo de formato y todos los integrantes del equipo deben aplicarlo. el objetivo es que el software tenga un estilo coherente. no queremos que parezca escrito por individuos enfrentados. cuando comencé el proyecto fitnesse en 2002, me reuní con el equipo para definir un estilo de código. tardamos 10 minutos. decidimos dónde añadir las llaves, qué tamaño de sangrado utilizar, los nombres de clases, variables y métodos, y demás. tras ello, codificamos las reglas en el ide y las cumplimos desde entonces. no son las reglas que prefiero, son las que el equipo decidió. y como miembro de ese equipo, las apliqué cuando creamos el código del proyecto fitnesse. recuerde que un buen sistema de software se compone de una serie de documentos que se leen fácilmente. deben tener un estilo coherente y dinámico. el lector debe confiar en que los formatos que ve en nuestro archivo de código significarán lo mismo para otros. lo último que queremos es aumentar la complejidad del código creando una mezcla de estilos diferentes. reglas de formato de uncle bob las reglas que uso personalmente son sencillas y se ilustran en el código del listado 5-6. considérelo un ejemplo de documento estándar de código óptimo. listado 5-6 131codeanalyzer.java. public class codeanalyzer implements javafileanalysis { private int linecount; private int maxlinewidth; private int widestlinenumber; private linewidthhistogram linewidthhistogram; private int totalchars; public codeanalyzer() { linewidthhistogram = new linewidthhistogram(); } public static list<file> findjavafiles(file parentdirectory) { list<file> files = new arraylist<file>(); findjavafiles(parentdirectory, files); return files; } private static void findjavafiles(file parentdirectory, list<file> files) { for (file file : parentdirectory.listfiles()) { if (file.getname().endswith(“.java”)) files.add(file); else if (file.isdirectory()) findjavafiles(file, files); } } public void analyzefile(file javafile) throws exception { bufferedreader br = new bufferedreader(new filereader(javafile)); string line; while ((line = br.readline()) != null) measureline(line); } private void measureline(string line) { linecount++; int linesize = line.length(); totalchars += linesize; linewidthhistogram.addline(linesize, linecount); recordwidestline(linesize); } private void recordwidestline(int linesize) { if (linesize > maxlinewidth) { maxlinewidth = linesize; widestlinenumber = linecount; } } public int getlinecount() { return linecount; } 132public int getmaxlinewidth() { return maxlinewidth; } public int getwidestlinenumber() { return widestlinenumber; } public linewidthhistogram getlinewidthhistogram() { return linewidthhistogram; } public double getmeanlinewidth() { return (double)totalchars/linecount; } public int getmedianlinewidth() { integer[] sortedwidths = getsortedwidths(); int cumulativelinecount = 0; for (int width : sortedwidths) { cumulativelinecount += linecountforwidth(width); if (cumulativelinecount > linecount/2) return width; } throw new error (“cannot get here”); } private int linecountforwidth(int width) { return linewidthhistogram.getlinesforwidth(width).size(); } private integer[] getsortedwidths() { set<integer> widths = linewidthhistogram.getwidths(); integer[] sortedwidths = (widths.toarray(new integer[0])); arrays.sort(sortedwidths); return sortedwidths; } } 1336 objetos y estructuras de datos 134hay una razón para que las variables sean privadas. no queremos que nadie más dependa de ellas. queremos poder cambiar su tipo o implementación cuando deseemos. entonces, ¿por qué tantos programadores añaden automáticamente métodos de establecimiento y recuperación que muestran sus variables privadas como si fueran públicas? abstracción de datos fíjese en la diferencia entre los listados 6-1 y 6-2. ambos representan los datos de un punto cartesiano, pero uno muestra su implementación y otro la oculta totalmente. listado 6-1 punto concreto. public class point { public double x; public double y; } listado 6-2 punto abstracto. public interface point { double getx(); double gety(); void setcartesian(double x, double y); double getr(); double gettheta(); void set polar(double r, double theta); } lo mejor del listado 6-2 es que no hay forma de saber si la implementación está en coordenadas rectangulares o polares. ¡puede que en ninguna! y aun así la interfaz representa sin lugar a dudas una estructura de datos. pero representa algo más que una estructura de datos. los métodos refuerzan una política de acceso. puede leer las coordenadas de forma 135independiente, pero debe establecerlas de forma conjunta como operación atómica. el listado 6-1, por su parte, se implementa claramente en coordenadas rectangulares y nos obliga a manipularlas de forma independiente, lo que muestra la implementación. de hecho, la mostraría igualmente, aunque las variables fueran privadas y usáramos métodos variables de establecimiento y recuperación. para ocultar la implementación no basta con añadir una capa de funciones entre las variables. se basa en la abstracción. una clase no fuerza sus variables a través de métodos de establecimiento y recuperación. por el contrario, muestra interfaces abstractas que permiten a sus usuarios manipular la esencia de los datos sin necesidad de conocer su implementación. fíjese en los listados 6-3 y 6-4. el primero usa términos concretos para indicar el nivel de combustible de un vehículo mientras que el segundo lo hace con la abstracción del porcentaje. en el caso concreto, podemos estar seguros de que se trata de métodos de acceso de variables. en el caso abstracto, desconocemos la forma de los datos. listado 6-3 vehículo concreto. public interface vehicle { double getfueltankcapacityingallons(); double getgallonsofgasoline(); } listado 6-4 vehículo abstracto. public interface vehicle { double getpercentfuelremaining(); } en ambos casos, la segunda opción es preferible. no queremos mostrar los detalles de los datos, sino expresarlos en términos abstractos. esto no se consigue simplemente mediante interfaces o métodos de establecimiento y recuperación. hay que meditar seriamente la forma óptima de representar los datos que contiene un objeto. la peor opción es añadir métodos de 136establecimiento y recuperación a ciegas. antisimetría de datos y objetos estos dos ejemplos ilustran la diferencia entre objetos y estructuras de datos. los objetos ocultan sus datos tras abstracciones y muestran funciones que operan en dichos datos. la estructura de datos muestra sus datos y carece de funciones con significado. vuelva a leerlos. fíjese en la naturaleza complementaria de las dos definiciones. son virtualmente opuestas. puede parecer una diferencia menor, pero tiene importantes implicaciones. fíjese en el ejemplo del listado 6-5. la clase geometry opera en las tres clases de formas, que son sencillas estructuras de datos sin comportamiento. todo el comportamiento se encuentra en la clase geometry. listado 6-5 forma mediante procedimientos. public class square { public point topleft; public double side; } public class rectangle { public point topleft; public double height; public double width; } public class circle { public point center; public double radius; } public class geometry { public final double pi = 3.141592653589793; public double area(object shape) throws nosuchshapeexception { if (shape instanceof square) { square s = (square)shape; return s.side * s.side; } else if (shape instanceof rectangle) { 137rectangle r = (rectangle)shape; return r.height * r.width; } else if (shape instanceof circle) { circle c = (circle)shape; return pi * c.radius * c.radius; } throw new nosuchshapeexception(); } } los programadores orientados a objetos se quejarán de que es un ejemplo de procedimiento, y tienen razón. imagine qué pasaría si añadimos la función perimeter() a geometry . ¡las clases de formas no se verían afectadas! ¡y las demás clases que dependieran de las formas tampoco! por otra parte, si añado una nueva forma, tendría que cambiar todas las funciones de geometry . vuélvalo a leer. comprobará que las dos condiciones son diametralmente opuestas. fíjese ahora en la solución orientada a objetos del listado 6-6. aquí, el método area() es polimórfico. no se necesita una clase geometry . por tanto, si añado una nueva forma, ninguna de las funciones existentes se ven afectadas, pero si añado otra función, habrá que cambiar todas las formas [29] . listado 6-6 formas polimórficas. public class square implements shape { private point topleft; private double side; public double area() { return side*side; } public class rectangle implements shape { private point topleft; private double height; private double width; public double area() { return height * width; } } public class circle implements shape { private point center; 138private double radius; public final double pi = 3.141592653589793; public double area() { return pi * radius * radius; } } de nuevo, vemos la naturaleza complementaria de estas dos definiciones; totalmente contrarias. esto ilustra la dicotomía fundamental entre objetos y estructuras de datos: el código por procedimientos (el que usa estructuras de datos) facilita la inclusión de nuevas funciones sin modificar las estructuras de datos existentes. el código orientado a objetos, por su parte, facilita la inclusión de nuevas clases sin cambiar las funciones existentes. el complemento también es cierto: el código por procedimientos dificulta la inclusión de nuevas estructuras de datos ya que es necesario cambiar todas las funciones. el código orientado a objetos dificulta la inclusión de nuevas funciones ya que es necesario cambiar todas las clases. por tanto, lo que es difícil para la programación orientada a objetos es fácil para los procedimientos, y viceversa. en cualquier sistema complejo habrá ocasiones en las que queramos añadir nuevos tipos de datos en lugar de nuevas funciones. en dichos casos, los objetos y la programación orientada a objetos es lo más adecuado. por otra parte, en ocasiones tendremos que añadir nuevas funciones en lugar de tipos de datos, para lo que resulta más adecuado usar código por procedimientos y estructuras de datos. los programadores experimentados saben que la idea de que todo es un objeto es un mito. en ocasiones solamente queremos sencillas estructuras de datos con procedimientos que operen en las mismas. 139la ley de demeter existe una conocida heurística denominada ley de demeter [30] que afirma que un módulo no debe conocer los entresijos de los objetos que manipula. como vimos en el apartado anterior, los objetos ocultan sus datos y muestran operaciones, lo que significa que un objeto no debe mostrar su estructura interna a través de métodos de acceso ya que, si lo hace, mostraría, no ocultaría, su estructura interna. en concreto, la ley de demeter afirma que un método de una clase c sólo debe invocar los métodos de: c . un objeto creado por f . un objeto pasado como argumento a f . un objeto en una variable de instancia de c . el método no debe invocar métodos de objetos devueltos por ninguna de las funciones permitidas. es decir, no hable con desconocidos, sólo con amigos. el siguiente código [31] parece incumplir la ley de demeter (entre otras cosas) ya que invoca la función getscratchdir() en el valor devuelto de getoptions() y después invoca getabsolutepath() en el valor devuelto de getscratchdir() . final string outputdir = ctxt.getoptions().getscratchdir().getabsolutepath(); choque de trenes ese tipo de código suele denominarse choque de trenes ya que se asemeja a un grupo de vagones de tren. estas cadenas de invocaciones suelen considerarse un estilo descuidado y deben evitarse [g36]. conviene dividirlas de esta forma: options opts = ctxt.getoptions(); file scratchdir = opts.getscratchdir(); 140final string outputdir = scratchdir.getabsolutepath(); ¿incumplen estos dos fragmentos de código la ley de demeter? sin duda el módulo contenedor sabe que el objeto ctxt contiene opciones, que contienen un directorio scratch , que tiene una ruta absoluta. la función sabe demasiado. la función que realiza la invocación sabe cómo desplazarse por numerosos objetos diferentes. si incumple o no la ley de demeter depende de si ctxt , options y scratchdir son objetos o estructuras de datos. si son objetos, debería ocultarse su estructura interna, no mostrarse, y conocer sus detalles internos sería un claro incumplimiento de la ley de demeter. por otra parte, si ctxt , options y scratchdir son simples estructuras de datos, mostrarán su estructura interna con naturalidad y la ley de demeter no se aplica. el uso de funciones de acceso complica el problema. si el código se hubiera escrito de esta otra forma, probablemente no nos preocuparíamos de si se incumple la ley de demeter o no. final string outputdir = ctxt.options.scratchdir.absolutepath; el problema sería menos confuso si las estructuras de datos tuvieran variables públicas y no funciones, y los objetos tuvieran variables privadas y funciones públicas. sin embargo, existen estructuras y estándares (como los bean ) que exigen que incluso una sencilla estructura de datos tenga elementos de acceso y mutación. híbridos esta confusión genera ocasionalmente desafortunadas estructuras híbridas mitad objeto y mitad estructura de datos. tienen funciones que realizan tareas significativas y también variables públicas o método públicos de acceso y mutación que hacen que las variables privadas sean públicas, y tientan a otras funciones externas a usar dichas variables de la misma forma que un programa por procedimientos usaría una estructura de datos [32] . estos 141híbridos dificultan la inclusión de nuevas funciones y también de nuevas estructuras de datos. son lo peor de ambos mundos. evítelos. indican un diseño descuidado cuyos autores dudan, o peor todavía, desconocen, si necesitan protegerse de funciones o tipos. ocultar la estructura ¿qué pasaría si ctxt , options y scratchdir fueran objetos con un comportamiento real? como los objetos deben ocultar su estructura interna, no podríamos desplazarnos por los mismos. entonces, ¿cómo obtendríamos la ruta absoluta del directorio scratch ? ctxt.getabsolutepathofscratchdirectoryoption(); o ctxt.getscratchdirectoryoption().getabsolutepath() la primera opción provocaría una explosión de métodos en el objeto ctxt . la segunda asume que getscratchdirectoryoption() devuelve una estructura de datos, no un objeto. ninguna de las opciones parece correcta. si ctxt es un objeto, deberíamos indicarle que hiciera algo, no preguntar sobre sus detalles internos. entonces, ¿para qué queremos la ruta absoluta del directorio scratch ? ¿cómo vamos a usarla? fíjese en este código del mismo módulo (muchas líneas después): string outfile = outputdir + “/” + classname.replace(‘.’, ‘/’) + “.class”; fileoutputstream fout = new fileoutputstream(outfile); bufferedoutputstream bos = new bufferedoutputstream(fout); la mezcla de distintos niveles de detalle [g34][g6] es preocupante. puntos, guiones, extensiones de archivo y objetos file no deben mezclarse de esta forma, junto al código contenedor. si lo ignoramos, vemos que la intención de obtener la ruta absoluta del directorio scratch es crear un archivo de borrador de un nombre concreto. ¿y si le dijéramos al objeto ctxt que hiciera esto? bufferedoutputstream bos = ctxt.createscratchfilestream(classfilename); parece algo razonable para un objeto. permite a ctxt ocultar sus detalles internos e impide que la función actual incumpla la ley de demeter y se 142desplace por objetos que no debería conocer. objetos de transferencia de datos la quintaesencia de una estructura de datos es una clase con variables públicas y sin funciones. en ocasiones se denomina objeto de transferencia de datos ( data transfer object u otd). los otd son estructuras muy útiles, en especial para comunicarse con bases de datos o analizar mensajes de conexiones, etc. suelen ser los primeros de una serie de fases de traducción que convierten datos sin procesar en objetos en el código de la aplicación. más común es la forma de bean mostrada en el listado 6-7. los bean tienen variables privadas manipuladas por métodos de establecimiento y recuperación. la cuasi-encapsulación de bean hace que algunos puristas de la programación orientada a objetos se sientan mejor pero no ofrece ningún otro beneficio. listado 6-7 address.java public class address { private string street; private string streetextra; private string city; private string state; private string zip; public address(string street, string streetextra, string city, string state, string zip) { this.street = street; this.streetextra = streetextra; this.city = city; this.state = state; this.zip = zip; } public string getstreet() { return street; } public string getstreetextra() { return streetextra; } 143public string getcity() { return city; } public string getstate() { return getstate; } public string getzip() { return zip; } } registro activo los registros activos son una forma especial de otd. son estructuras de datos con variables públicas (o de acceso por bean) pero suelen tener métodos de navegación como save y find . por lo general, estos registros activos son traducciones directas de tablas de base de datos u otros orígenes de datos. desafortunadamente, muchos programadores intentan procesar estas estructuras de datos como si fueran objetos y les añaden métodos de reglas empresariales. es algo extraño ya que crea un híbrido entre una estructura de datos y un objeto. la solución, evidentemente, consiste en considerar al registro activo una estructura de datos y crear objetos independientes que contengan las reglas empresariales y que oculten sus datos internos (que probablemente sean instancias del propio registro activo). conclusión los objetos muestran comportamiento y ocultan datos. esto facilita la inclusión de nuevos tipos de objetos sin necesidad de cambiar los comportamientos existentes. también dificulta la inclusión de nuevos comportamientos en objetos existentes. las estructuras de datos muestran datos y carecen de comportamiento significativo. esto facilita la inclusión de nuevos comportamientos en las estructuras de datos existentes, pero dificulta la inclusión de nuevas estructuras de datos en funciones existentes. 144en un sistema, en ocasiones necesitaremos la flexibilidad de añadir nuevos tipos de datos, por lo que preferimos objetos para esa parte del sistema. en otros casos, querremos añadir nuevos comportamientos, para lo que preferimos tipos de datos y procedimientos en esa parte del sistema. los buenos programadores de software entienden estos problemas sin prejuicios y eligen el enfoque más adecuado para cada tarea concreta. bibliografía [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. 1457 procesar errores por michael feathers le parecerá extraño encontrar una sección de control de errores en un libro sobre código limpio. el control de errores es algo que todos tenemos que hacer al programar. las entradas pueden ser incorrectas y los dispositivos pueden fallar, y cuando lo hacen, los programadores somos responsables de comprobar que el código hace lo que debe hacer. no obstante, la conexión con el código limpio debe ser evidente. muchas bases de código están totalmente dominadas por el control de errores. cuando digo que están dominadas, no quiero decir que únicamente realicen control de 146código, sino que es prácticamente imposible ver lo que el código hace debido a todo ese control de errores. el control de errores es importante, pero si oscurece la lógica, es incorrecto . en este capítulo detallaremos diversas técnicas y consideraciones que puede usar para crear código limpio y robusto, código que procese los errores con elegancia y estilo. usar excepciones en lugar de códigos devueltos en el pasado, muchos lenguajes carecían de excepciones. las técnicas para procesar e informar de errores eran limitadas. se definía un indicador de error o se devolvía un código de error que el invocador podía comprobar. el código del listado 7-1 ilustra estos enfoques. listado 7-1 devicecontroller.java. public class devicecontroller { … public void sendshutdown() { devicehandle handle = gethandle(dev1); // comprobar el estado del dispositivo if (handle != devicehandle.invalid) { // guardar el estado del dispositivo en el campo de registro retrievedevicerecord(handle); // si no está suspendido, cerrarlo if { record.getstatus() != device_suspended) { pausedevice(handle); cleardeviceworkqueue(handle); closedevice(handle); } else { logger.log(“device suspended. unable to shut down”); } } else { logger.log(“invalid handle for: ” + dev1.tostring()); } } … } el problema de estos enfoques es que confunden al invocador. el invocador debe comprobar inmediatamente los errores después de la 147invocación. desafortunadamente, es algo que se suele olvidar. por ello, es más recomendable generar una excepción al detectar un error. el código de invocación es más limpio. su lógica no se oscurece por el control de errores. el listado 7-2 muestra el código tras generar una excepción en los métodos que pueden detectar errores. listado 7-2 devicecontroller.java (con excepciones). public class devicecontroller { … public void sendshutdown() { try { trytoshutdown(); } catch (deviceshutdownerror e) { logger.log(e); } } private void trytoshutdown() throws deviceshutdownerror { devicehandle handle = gethandle(dev1); devicerecord record = retrievedevicerecord(handle); pausedevice(handle); cleardeviceworkqueue(handle); closedevice(handle); } private devicehandle gethandle(deviceid id) { … throw new deviceshutdownerror(“invalid handle for: ” - id.tostring()); … } … } comprobará que es mucho más limpio. no es cuestión de estética. el código es mejor porque se solventan dos preocupaciones: el algoritmo para apagar el dispositivo y el control de errores ahora se encuentran separados. puede ver cada uno de ellos y entenderlos de forma independiente. crear primero la instrucción try-catch-finally 148uno de los aspectos más interesantes de las excepciones es que definen un ámbito en el programa. al ejecutar código en la parte try de una instrucción try-catch-finally , indicamos que la ejecución se puede cancelar en cualquier momento y después retomar en catch . los bloques try son como las transacciones, catch debe salir del programa en un estado coherente, independientemente de lo que suceda en try . por este motivo, es aconsejable iniciar con una instrucción try-catch- finally el código que genere excepciones. de este modo define lo que debe esperar el usuario del código, independientemente de que se produzca un error en el código ejecutado en la cláusula try . veamos un ejemplo. imagine que tiene que crear un código que acceda a un archivo y lea objetos serializados. comenzamos con una prueba de unidad que muestra que obtendremos una excepción cuando el archivo no exista: @test(expected = storageexception.class) public void retrievesectionshouldthrowoninvalidfilename() { sectionstore.retrievesection(“invalid - file”); } la prueba nos lleva a crear lo siguiente: public list<recordedgrip> retrievesection(string sectionname) { // se devuelve un resultado ficticio hasta tener una implementación real return new arraylist<recordedgrip>(); } nuestra prueba falla ya que no genera una excepción. tras ello, cambiamos la implementación para que intente acceder a un archivo no válido. esta operación genera una excepción: public list<recordedgrip> retrievesection (string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname) } catch (exception e) { throw new storageexception(“retrieval error”, e); } return new arraylist<recordedgrip>(); } ahora la prueba es correcta ya que capturamos la excepción y ya podemos refactorizar. podemos reducir el tipo de la excepción capturada para que coincida con el tipo generado desde el constructor fileinputstream: 149filenotfoundexception : public list<recordedgrip> retrievesection(string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname); stream.close(); } catch (filenotfoundexception e) { throw new storageexception(“retrieval error”, e); } return new arraylist<recordedgrip>(); } ahora que hemos definido el ámbito con una estructura try-catch , podemos usar tdd para diseñar el resto de la lógica necesaria. dicha lógica se añade entre la creación de fileinputstream y el cierre, y podemos pretender que no pasa nada incorrecto. intente crear pruebas que fuercen las excepciones, para después añadir al controlador un comportamiento que satisfaga dichas pruebas. de este modo primero creará el ámbito de transacción del bloque try y podrá mantener la naturaleza de transacción del ámbito. usar excepciones sin comprobar el debate ha terminado. durante años, los programadores de java han debatido las ventajas y los problemas de las excepciones comprobadas. cuando aparecieron en la primera versión de java, parecían una gran idea. la firma de todos los métodos enumeraría todas las excepciones que se podían pasar a su invocador. es más, estas excepciones formaban parte del tipo del método. el código no se compilaría si la firma no coincidía con lo que el código iba a hacer. en aquel momento, pensábamos que las excepciones comprobadas eran una gran idea y sí, ofrecían ciertas ventajas. sin embargo, ahora es evidente que no se necesitan para crear software robusto. c# carece de excepciones comprobadas y, a pesar de los intentos, c++ tampoco, como sucede en python o ruby. y en todos estos lenguajes se puede crear software robusto. por ello, debemos decidir si las excepciones comprobadas valen su precio. ¿qué precio? el precio de las excepciones comprobadas es un 150incumplimiento del principio abierto/cerrado [33] . si genera una excepción comprobada desde un método de su código y la cláusula catch se encuentra tres niveles por debajo, debe declarar dicha excepción en la firma de todos los métodos comprendidos entre su posición y catch . esto significa que un cambio en un nivel inferior del software puede forzar cambios de firma en muchos niveles superiores. será necesario volver a generar e implementar los módulos cambiados, aunque no cambien los elementos a los que hacen referencia. piense en la jerarquía de invocación de un sistema. las funciones de la parte superior invocan a las funciones situadas debajo, que invocan a otras funciones inferiores y así sucesivamente. imagine que una de las funciones de nivel inferior se modifica de forma que debe generar una excepción. si la excepción se comprueba, la firma de la función tendrá que añadir una cláusula throws . pero esto significa que todas las funciones que invoquen nuestra función modificada también tendrán que cambiarse para capturar la nueva excepción o para añadir la correspondiente cláusula throws en su firma. y así indefinidamente. el resultado final es una cascada de cambios que pasan desde los niveles inferiores del software hasta los superiores. la encapsulación se rompe ya que todas las funciones en la ruta de throw deben conocer detalles de la excepción de nivel inferior. como el cometido de las excepciones es permitimos procesar errores a distancia, es una lástima que las excepciones comprobadas rompan la encapsulación de esta forma. las excepciones comprobadas pueden ser útiles si tiene que crear una biblioteca crítica: tendrá que capturarlas. pero en el desarrollo de aplicaciones generales, los costes de dependencia superan las ventajas. ofrecer contexto junto a las excepciones las excepciones que genere deben proporcionar el contexto adecuado para determinar el origen y la ubicación de un error. en java, puede obtener un rastreo de pila de cualquier excepción; sin embargo, no le indicará el cometido de la función fallida. redacte mensajes de error informativos y páselos junto a sus 151excepciones. mencione la operación fallida y el tipo de fallo. si guarda registros en su aplicación, incluya información suficiente para poder registrar el error en la cláusula catch . definir clases de excepción de acuerdo a las necesidades del invocador existen varias formas de clasificar los errores. podemos hacerlo por origen (¿provienen de uno u otro componente?) o por tipo (¿son fallos del dispositivo, de la red o errores de programación?). sin embargo, al definir clases de excepción en una aplicación, debemos preocuparnos principalmente en cómo se capturan . veamos un pobre ejemplo de clasificación de excepciones. es una instrucción try-catch-finally de la invocación de una biblioteca de terceros. abarca todas las excepciones que las invocaciones pueden generar: acmeport port = new acmeport(12); try { port.open(); } catch (deviceresponseexception e) { reportporterror(e); logger.log{“device response exception”, e); } catch (atm1212unlockedexception e) { reportporterror(e); logger.log(“unlock exception”, e); } catch (gmxerror e) { reportporterror(e); logger.log(“device response exception”); } finally { … } esta instrucción contiene elementos duplicados, algo que no debería sorprendernos. en muchos casos de control de excepciones, el trabajo que realizamos es relativamente estándar independientemente de la causa real. debemos registrar un error y asegurarnos de poder continuar. en este caso, como sabemos que el trabajo es el mismo independientemente de la excepción, podemos simplificar el código si incluimos la api invocada y nos aseguramos de que devuelve un tipo de 152excepción común: localport port = new localport(12); try { port.open(); } catch (portdevicefailure e) { reporterror(e); logger.log(e.getmessage(), e); } finally { … } nuestra clase localport es un simple envoltorio que captura y traduce excepciones generadas por la clase acmeport : public class localport { private acmeport innerport; public localport(int portnumber) { innerport = new acmeport(portnumber); } public void open() { try { innerport.open(); } catch (deviceresponseexception e) { throw new portdevicefailure(e); } catch (atm1212unlockedexception e) { throw new portdevicefailure(e); } catch (gmxerror e) { throw new portdevicefailure(e); } } … } los envoltorios como el definido para acmeport pueden ser muy útiles. de hecho, es recomendable envolver api de terceros. al hacerlo, se minimizan las dependencias: puede cambiar a otra biblioteca diferente sin apenas problemas y el envoltorio también facilita imitar invocaciones de terceros cuando se prueba el código. una última ventaja es que no estamos limitados a las decisiones de diseño de api de un determinado fabricante. puede definir una api que le resulte cómoda. en el ejemplo anterior, definimos un único tipo de excepción para el fallo de puertos y podemos escribir un código mucho más limpio. a menudo, una única clase de excepción es suficiente para una zona concreta del código. la información enviada con la excepción puede distinguir los errores. use clases diferentes 153sólo para capturar una excepción y permitir el paso de otra distinta. definir el flujo normal si sigue los consejos de apartados anteriores, realizará una importante separación entre la lógica empresarial y el control de errores. la mayoría de su código parecerá un algoritmo limpio y sin adornos. sin embargo, el proceso desplaza la detección de errores hacia los bordes del programa. debe envolver api externas para poder generar sus propias excepciones y definir un controlador por encima del código para poder procesar cálculos cancelados. en muchos casos es el enfoque más acertado, pero en ocasiones conviene no cancelar. veamos un ejemplo, un código extraño que suma gastos en una aplicación de facturación: try { mealexpenses expenses = expensereportdao.getmeals(employee.getid()); m_total += expenses.gettotal(); } catch(mealexpensesnotfound e) { m_total += getmealperdiem(); } en esta empresa, si las comidas son gastos, pasan a formar parte del total. si no lo son, los trabajadores reciben una cantidad diaria para la comida. la excepción entorpece la lógica. sería más adecuado no tener que procesar el caso especial y el código sería mucho más sencillo: mealexpenses expenses = expensereportdao.getmeals(employee.getid()); m_total += expenses.gettotal(); ¿de verdad que el código puede ser tan simple? pues sí. podemos cambiar expensereportdao para que siempre devuelva un objeto mealexpense . si no hay gastos de comida, devuelve un objeto mealexpense que devuelve la dieta diaria como total: public class perdiemmealexpenses implements mealexpenses { public int gettotal() { // devolver la dieta diaria predeterminada 154} } es lo que se denomina patrón de caso especial [fowler]. se crea una clase o se configura un objeto que procese un caso especial. al hacerlo, el código cliente no tiene que procesar comportamientos excepcionales. dichos comportamientos se encapsulan en un objeto de caso especial. no devolver null creo que toda descripción del control de errores debe mencionar los elementos proclives a errores. el primero es devolver null. he perdido la cuenta de la cantidad de aplicaciones en que las que línea sí y línea también se comprueba null: public void registeritem(item item) { if (item != null) { itemregistry registry = peristentstore.getitemregistry(); if (registry != null) { item existing = registry.getitem(item.getid()); if (existing.getbillingperiod().hasretailowner()) { existing.register(item); } } } } si trabaja en una base de código como ésta, puede que no le parezca tan mala, pero lo es. al devolver null , básicamente nos creamos trabajo y generamos problemas para los invocadores. basta con que falte una comprobación de null para que la aplicación pierda el control. ¿se ha fijado en que no hay una comprobación de null en la segunda línea de la instrucción if anidada? ¿qué sucedería en tiempo de ejecución si persistentstore fuera null ? se generaría nullpointerexception en tiempo de ejecución y se capturaría nullpointerexception en el nivel superior o no. en ambos casos es incorrecto. ¿qué debería hace como respuesta a la generación de nullpointerexception desde el interior de su aplicación? se puede afirmar que el problema de este código es la ausencia de una comprobación de null pero en realidad el problema es su exceso. si 155siente la tentación de devolver null desde un método, pruebe a generar una excepción o a devolver un objeto de caso especial. si invoca un método que devuelva null desde una api de terceros, envuélvalo en un método que genere una excepción o devuelva un objeto de caso especial. en muchos casos, los objetos de caso especial son un remedio sencillo. imagine que tiene el siguiente código: list<employee> employees = getemployees(); if (employees != null) { for(employee e : employees) { totalpay += e.getpay(); } } ahora, getemployees puede devolver null , ¿pero es necesario? si cambiamos getemployee para que devuelva una lista vacía, podremos limpiar el código: list<employee> employees = getemployees(); for(employee e : employees) { totalpay += e.getpay(); } afortunadamente, java dispone de collections.emptylist() y devuelve una lista inmutable predefinida que podemos usar para este cometido: public list<employee> getemployees() { if (… there are no employees …) return collections.emptylist(); } si usa este tipo de código, minimizará la presencia de nullpointerexception y su código será más limpio. no pasar null devolver null desde métodos es incorrecto, pero es peor pasar null a métodos. a menos que trabaje con una api que espere que pase null , debe evitarlo siempre que sea posible. veamos otro ejemplo, un sencillo método que calcula una métrica para dos puntos: public class metricscalculator 156{ public double xprojection(point p1, point p2) { return (p2.x – p1.x) * 1.5; } … } ¿qué sucede cuando alguien pasa null como argumento? calculator.xprojection(null, new point (12, 13)); se genera nullpointerexception , evidentemente. ¿cómo solucionarlo? podríamos crear un nuevo tipo de excepción y generarla: public class metricscalculator { public double xprojection(point p1, point p2) { if (p1==null || p2==null) { throw invalidargumentexception( “invalid argument for metricscalculator.xprojection”); } return (p2.x – p1.x) * 1.5; } } } ¿mejor? puede que sea mejor que una excepción de puntero nulo, pero recuerde que debe definir un controlador para invalidargumentexception . ¿qué debe hacer el controlador? ¿hay alguna forma correcta de hacerlo? existe otra alternativa, usar un grupo de afirmaciones: public class metricscalculator ( public double xprojection{point p1, point p2) { assert p1 != null : “p1 should not be null”; assert p2 != null : “p2 should not be null”; return (p2.x - pl.x) * 1.5; } } es documentación correcta pero no soluciona el problema. si alguien pasa null , seguirá produciéndose un error de tiempo de ejecución. en la mayoría de lenguajes de programación no hay una forma correcta de procesar un null pasado por accidente. como éste es el caso, el enfoque racional es impedir que se pase null de forma predeterminada. si lo hace, puede diseñar código sabiendo que null en una lista de argumentos indica un problema y los errores serán menores. 157conclusión el código limpio es legible pero también debe ser robusto. no son objetivos opuestos. podemos crear código limpio y robusto si consideramos el control de errores una preocupación diferente, algo que vemos de forma independiente desde nuestra lógica principal. si somos capaces de lograrlo, razonaremos de forma independiente y podemos aumentar la capacidad de mantenimiento de nuestro código. bibliografía [martin] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. 1588 límites por james grenning no es habitual que controlemos todo el software de nuestros sistemas. en ocasiones, adquirimos paquetes de terceros o usamos código abierto. en otros casos, dependemos de equipos de nuestra propia empresa para producir 159componentes o subsistemas que utilizamos. de algún modo debemos integrar este código externo con el nuestro. en este capítulo veremos prácticas y técnicas para definir con claridad los límites de nuestro software . utilizar código de terceros existe una tensión natural entre el proveedor de una interfaz y el usuario de la misma. los proveedores de paquetes y estructuras de terceros abogan por una capacidad de aplicación global para poder trabajar en diversos entornos y atraer a un público más amplio. los usuarios, por su parte, desean una interfaz centrada en sus necesidades concretas. esta tensión puede provocar problemas en los límites de nuestros sistemas. analicemos java.util.map como ejemplo. como puede apreciar en la siguiente lista. map tiene una amplia interfaz con numerosas prestaciones. esta potencia y flexibilidad es muy útil, pero también puede ser un problema. por ejemplo, nuestra aplicación puede generar un map y compartirlo. nuestra intención puede que sea que ninguno de los receptores del mapa borre sus elementos. pero en la parte superior de la lista encontramos el método clear() . cualquier usuario del mapa puede borrarlo. o puede que nuestra convención de diseño determine que sólo se puedan almacenar objetos concretos en el mapa, pero map no limita de forma fiable los tipos de objetos que admite. cualquier usuario puede añadir elementos de cualquier tipo a cualquier mapa. clear() void - map containskey (object key) boolean - map containsvalue (object value) boolean - map entryset() set - map equals(object o) boolean - map get(object key) object - map getclass() class<? extends object> - object hashcode() int - map isempty() boolean - map keyset() set - map notify() void - object 160notifyall() void - object put(object key, object value) object - map putall(map t) void - map remove(object key) object - map size() int - map tostring() string - object values() collection - map wait() void - object wait(long timeout) void - object wait(long timeout, int nanos) void - object figura 8.1. los métodos de map si nuestra aplicación necesita un mapa de sensor , comprobará que los sensores se definen de esta forma: map sensors = new hashmap(); tras ello, cuando otra parte del código necesite acceder a sensor, vemos este código: sensor s = (sensor)sensors.get(sensorid); no lo vemos una sola vez, sino repetidamente a lo largo del código. el cliente de este código es responsable de obtener un objeto de map y convertirlo al tipo correcto. funciona, pero no es código limpio. además, este código no cuenta su historia como debería. la legibilidad del código se podría mejorar mediante el uso de genéricos, como se indica a continuación: map<sensor> sensors = new hashmap<sensor>(); … sensor s = sensors.get(sensorid); sin embargo, esto no soluciona el problema de que map<sensor> ofrezca más prestaciones de las que necesitamos o deseamos. al pasar una instancia de map<sensor> en el sistema, significa que habrá muchos puntos que corregir si la interfaz de map cambia. seguramente piense que son cambios improbables, pero recuerde que se han producido al añadir compatibilidad con genéricos en java 5. sin duda hemos visto sistemas que impiden el uso de genéricos debido a la gran cantidad de cambios necesarios para compensar el uso liberal de map . una forma más limpia de usar map sería la siguiente. a ningún usuario 161sensor le importa si se usan genéricos o no. esa opción se ha convertido (y siempre debería serlo) en un detalle de implementación. public class sensors { private map sensors = new hashmap(); public sensor getbyid(string id) { return (sensor) sensors.get(id); } //corte } la interfaz en el límite (map) está oculta. ha conseguido evolucionar sin apenas impacto en el resto de la aplicación. el uso de genéricos ya no es un problema ya que la conversión y la administración de tipos se procesa dentro de la clase sensors . esta interfaz también se ha ajustado y limitado a las necesidades de la aplicación. genera código más fácil de entender y con menor probabilidad de errores. la clase sensors puede aplicar las reglas empresariales y de diseño. no sugerimos que se encapsulen de esta forma todos los usos de map, sino que no se pase map (ni otras interfaces en el límite) por el sistema. si usa una interfaz de límite como map , manténgala dentro de la clase o la familia de clases en la que se use. evite devolverla o aceptarla como argumento de api públicas. explorar y aprender límites el código de terceros nos permite obtener mayor funcionalidad en menos tiempo. ¿por dónde empezamos cuando queremos utilizar un paquete de terceros? nuestra labor no es probar el código, pero sí crear pruebas para el código de terceros que utilicemos. imagine que no es evidente cómo usar una biblioteca de terceros. podríamos perder uno o varios días en leer la documentación y decidir cómo usarla. tras ello, podríamos escribir el código para usar el código de terceros y comprobar si se comporta de la forma esperada. no deberíamos sorprendernos por tener que realizar extensas sesiones de depuración intentando localizar errores en nuestro código o en el suyo. 162aprender el código de terceros es complicado, y también integrarlo. hacer ambas cosas al mismo tiempo es el doble de complicado. necesitamos un enfoque diferente. en lugar de experimentar y probar el nuevo material en nuestro código de producción, podríamos crear pruebas que analicen nuestro entendimiento del código de terceros. jim newkirk las denomina pruebas de aprendizaje [34] . en las pruebas de aprendizaje, invocamos la api de terceros como supuestamente la usaríamos en nuestra aplicación. básicamente realizamos experimentos controlados para comprobar si la entendemos. las pruebas se centran en lo que queremos obtener de la api. aprender log4j imagine que desea usar el paquete de apache log4j en lugar de su propio dispositivo de registro personalizado. lo descarga y abre la página inicial de la documentación. sin una lectura exhaustiva, crea el primer caso de prueba con la esperanza de que escriba hello en la consola. @test public void testlogcreate() { logger logger = logger.getlogger(“mylogger”); logger.info(“hello”); } al ejecutarlo, el registrador genera un error que nos indica que necesitamos algo denominado appender . tras investigar, descubrimos que existe un elemento consoleappender . creamos consoleappender y comprobamos si hemos conseguido revelar los secretos del registro en la consola. @test public void testlogaddappender() { logger logger = logger.getlogger (“mylogger”); consoleappender appender = new consoleappender(); logger.addappender(appender); logger.info(“hello”); } en esta ocasión descubrimos que appender carece de flujo de salida, algo extraño, ya que parece lógico que lo tuviera. tras recurrir a google, 163probamos lo siguiente: @test public void testlogaddappender() { logger logger = logger.getlogger(“mylogger”); logger.removeallappenders(); logger.addappender(new consoleappender( new patternlayout(“%p %t %m%n”), consoleappender.system_out)); logger.info(“hello”); } funciona; en la consola aparece un mensaje con la palabra hello . resulta extraño tener que indicarle a consoleappender que escriba en la consola. al eliminar el argumento consoleappender.systemout , vemos que hello sigue impreso. pero al eliminar patternlayout , de nuevo vemos la queja de la falta de un flujo de salida. es un comportamiento muy extraño. si nos fijamos en la documentación, vemos que el constructor consoleappender predeterminado no está configurado, lo que no parece demasiado obvio ni útil. parece más bien un error o una incoherencia de log4j . tras nuevas búsquedas en google, investigaciones y pruebas, conseguimos el listado 8-1. hemos descubierto cómo funciona log4j y hemos codificado esos conocimientos en un grupo de sencillas pruebas de unidad. listado 8-1 logtest.java. public class logtest ( private logger logger; @before public void initialize() { logger = logger.getlogger(“logger”); logger.removeallappenders(); logger.getrootlogger().removeallappenders(); } @test public void basiclogger() { basicconfigurator.configure(); logger.info(“basiclogger”); } 164@test public void addappenderwithstream() { logger.addappender(new consoleappender( new patternlayout (“%p %t %m%n”), consoleappender.system_out)); logger.info(“addappenderwithstream”); } @test public void addappenderwithoutstream() { logger.addappender(new consoleappender( new patternlayout(“%p %t %m%n”))); logger.info(“addappenderwithoutstream”); } } ahora sabemos cómo inicializar un sencillo registrador de consola y encapsular ese conocimiento en nuestra propia clase de registro para que el resto de la aplicación se aísle de la interfaz de límite log4j . las pruebas de aprendizaje son algo más que gratuitas las pruebas de aprendizaje no cuestan nada. de todas formas, hemos tenido que aprender la api y crear las pruebas fue una forma sencilla y aislada de adquirir esos conocimientos. las pruebas de aprendizaje fueron experimentos precisos que permitieron aumentar nuestros conocimientos. las pruebas no sólo son gratuitas, sino también rentables. cuando aparezcan nuevas versiones del paquete de terceros, ejecutamos las pruebas de aprendizaje para comprobar si hay diferencias de comportamiento. las pruebas de aprendizaje demuestran que los paquetes de terceros que usamos funcionan de la forma esperada. una vez integrados, no hay garantía de que el código de terceros sea compatible con nuestras necesidades. los autores originales se verán presionados para cambiar el código y ajustarlo a sus propias necesidades. corregirán errores y añadirán nuevas funciones. en cada versión surgirán nuevos riesgos. si el paquete de terceros cambia de una forma incompatible con nuestras pruebas, lo sabremos al instante. independientemente de que necesite los conocimientos proporcionados por las pruebas de aprendizaje, un límite claro debe estar respaldado por un conjunto de pruebas que ejerciten la interfaz de la misma forma que hace el 165código de producción. sin estas pruebas de límites para facilitar la transición, podríamos conservar la versión antigua más tiempo del necesario. usar código que todavía no existe existe otro tipo de límite, que separa lo conocido de lo desconocido. en ocasiones, nuestro conocimiento del código parece desvanecerse. lo que hay al otro lado del límite es desconocido (al menos por el momento). en ocasiones, decidimos no mirar más allá del límite. hace años formé parte de un equipo de desarrollo de software para un sistema de comunicación por radio. había un subsistema, el transmisor, que apenas conocíamos y cuya interfaz todavía no se había diseñado. como no queríamos quedarnos parados, comenzamos a trabajar alejándonos de la parte desconocida del código. sabíamos perfectamente dónde acababa nuestro mundo y comenzaba el nuevo. mientras avanzábamos, en ocasiones nos topábamos con este límite. aunque la ignorancia ocultaba nuestra visión más allá del límite, sabíamos cómo queríamos que fuera la interfaz. queríamos decirle al transmisor algo como lo siguiente: ajustar el transmisor en la frecuencia proporcionada y emitir una representación analógica de los datos que provienen de este flujo. no sabíamos cómo hacerlo ya que todavía no se había diseñado la api. por ello decidimos determinar después los detalles. para no quedarnos bloqueados, definimos nuestra propia interfaz. le dimos un nombre sencillo, transmitter . le asignamos el método transmit que aceptaba una frecuencia y un flujo de datos. es la interfaz que deseábamos haber tenido. lo mejor de escribir la interfaz que deseábamos haber tenido era que la controlábamos. esto hace que el código cliente sea más legible y se ciña a los objetivos previstos. en la figura 8.1 se aprecia que aislamos las clases 166communicationscontroller de la api del transmisor (que no controlábamos y estaba por definir). al usar nuestra propia interfaz específica de la aplicación, el código de communicationscontroller era limpio y expresivo. una vez definida la api del transmisor, creamos transmitteradapter para reducir las distancias. el adaptador [35] encapsulaba la interacción con la api y ofrecía un único punto en el que evolucionaba. figura 8.1. predicción del transmisor este diseño también nos ofrece un sello [36] en el código para realizar pruebas. con un elemento faketransmitter , podemos probar las clases communicationscontroller . también podemos crear pruebas de límite una vez diseñada la api transmitter para asegurarnos de que la utilizamos correctamente. límites limpios en los límites suceden cosas interesantes. los cambios es una de ellas. los diseños de código correctos acomodan los cambios sin necesidad de grandes modificaciones. cuando usamos código que no controlamos, hay que prestar especial atención a proteger nuestra inversión y asegurarnos de que los cambios futuros no son demasiado costosos. el código en los límites requiere una separación evidente y pruebas que definan expectativas. debemos evitar que el código conozca los detalles de terceros. es más aconsejable depender de algo que controlemos que de algo que no controlemos, y menos todavía si nos controla. los límites de terceros se gestionan gracias a la presencia de 167puntos mínimos en el código que hagan referencia a los mismos. podemos envolverlos como hicimos con map o usar un adaptador para convertir nuestra interfaz perfecta en la interfaz proporcionada. en cualquier caso, el código se lee mejor, promueve el uso coherente e interno en el límite y hay menos puntos de mantenimiento cuando cambie el código de terceros. bibliografía [becktdd] : test driven development , kent beck, addison-wesley, 2003. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison wesley, 19%. [welc] : working effectively with legacy code , addison-wesley, 2004. 1689 pruebas de unidad nuestra profesión ha evolucionado mucho en los últimos 10 años. en 1997 nadie había oído hablar del desarrollo guiado por pruebas (dgp). para la mayoría, las pruebas de unidad eran pequeños fragmentos de código 169desechable que creábamos para asegurarnos de que nuestros programas funcionaban. escribíamos clases y métodos, y después código ad hoc para probarlos, lo que implicaba algún tipo de programa controlador que nos permitiera interactuar manualmente con el programa que habíamos escrito. recuerdo crear un programa de c++ para un sistema incrustado de tiempo real a mediados de la década de 1990. el programa era un sencillo temporizador con la siguiente firma: void timer::schedulecommand(command* thecommand, int milliseconds) la idea era sencilla; el método execute de command se ejecutaba en un nuevo subproceso tras el número especificado de milisegundos. el problema era cómo probarlo. confeccioné un sencillo programa controlador que escuchaba al teclado. cada vez que se introducía un carácter, se programaba un comando que escribía el mismo carácter cinco segundos después. introduje una rítmica melodía en el teclado y esperé a que se reprodujera en pantalla cinco segundos después: «i… want-a-girl… just… like-the-girl-who-marr… ied… dear… old… dad.» incluso tarareé la melodía mientras pulsaba la tecla, y la volví a cantar cuando aparecieron los puntos en la pantalla. ésa fue mi prueba. cuando vi que funcionaba y se lo mostré a mis compañeros, me deshice del código de prueba. como he afirmado, nuestra profesión ha evolucionado mucho. ahora crearía una prueba que garantizara el funcionamiento de hasta el más mínimo detalle del código. aislaría el código del sistema operativo en lugar de invocar las funciones estándar de temporización. las imitaría para tener control total sobre el tiempo. programaría comandos que definieran indicadores booleanos y avanzaría el tiempo, para observar los indicadores y asegurarme de que pasaran de false a true al cambiar el tiempo al valor correcto. cuando superara una serie de pruebas, comprobaría que fueran adecuadas para todo el que tuviera que trabajar con el código. me aseguraría de comprobar las pruebas y el código en el mismo paquete. sí, hemos 170avanzado mucho, pero nos queda mucho por avanzar. los movimientos agile y tdd han animado a muchos programadores a crear pruebas de unidad automatizadas y cada vez son más. pero en esta alocada carrera por añadir pruebas a nuestra disciplina, muchos programadores han pasado por alto dos de los aspectos más sutiles e importantes de diseñar pruebas de calidad. las tres leyes del dgp todos sabemos que el dgp nos pide que primero creemos las pruebas de unidad, antes que el código de producción. pero esa norma es sólo la punta del iceberg. tenga en cuenta las tres siguientes leyes [37] : primera ley : no debe crear código de producción hasta que haya creado una prueba de unidad que falle. segunda ley : no debe crear más de una prueba de unidad que baste como fallida, y no compilar se considera un fallo. tercera ley : no debe crear más código de producción que el necesario para superar la prueba de fallo actual. estas tres leyes generan un ciclo de unos 30 segundos de duración. las pruebas y el código de producción se crean de forma conjunta, las pruebas unos segundos antes que el código. si trabajamos de esta forma, crearemos decenas de pruebas al día, cientos al mes y miles al año. si trabajamos de esta forma, las pruebas abarcarán todos los aspectos de nuestro código de producción. el tamaño de dichas pruebas, que puede ser similar al del código de producción, puede suponer un problema de administración. realizar pruebas limpias hace unos años me pidieron que dirigiera un equipo que había decidido explícitamente que su código de prueba no debía mantenerse con los mismos estándares de calidad que su código de producción. podían incumplir las 171reglas en sus pruebas de unidad. la premisa era «rápido y directo». no era necesario que las variables tuvieran nombres adecuados, ni que las funciones de prueba fueran breves y descriptivas. no era necesario que el código de prueba estuviera bien diseñado. bastaba con que funcionara y abarcara el código de producción. puede que algunos lectores empaticen con esta decisión. puede que en el pasado creara el tipo de pruebas que cree para la clase timer . supone un gran paso crear ese tipo de pruebas desechables a diseñar una suite de pruebas de unidad automatizadas. por ello, como el equipo que dirigía, puede decidir que pruebas incorrectas sea mejor que no tener pruebas. pero el equipo no se daba cuenta que tener pruebas incorrectas era igual o peor que no tener prueba alguna. el problema es que las pruebas deben cambiar de acuerdo a la evolución del código. cuanto menos limpias sean, más difícil es cambiarlas. cuando más enrevesado sea el código de prueba, más probabilidades de que dedique más tiempo a añadir nuevas pruebas a la suite que el empleado en crear el nuevo código de producción. al modificar el código de producción, las pruebas antiguas comienzan a fallar y el desastre impide que las pruebas se superen, por lo que acaban por convertirse en un obstáculo interminable. entre versiones, aumentó el coste de mantener la suite de pruebas de mi equipo. acabó por convertirse en la principal queja entre los desarrolladores. cuando los directores preguntaron sobre este aumento, los desarrolladores culparon a las pruebas. al final, se vieron obligados a descartar la suite de pruebas completa. pero sin una suite de pruebas perdieron la posibilidad de garantizar el funcionamiento esperado de los cambios en el código. sin una suite de pruebas no podían asegurar que los cambios en una parte del sistema no afectaran a otras diferentes. los defectos aumentaron, lo que propició que temieran realizar cambios. dejaron de limpiar su código de producción por miedo a que los cambios fueran dañinos. el código de producción comenzó a corromperse. al final, se quedaron sin pruebas, con un código de producción enmarañado y defectuoso, clientes frustrados y la sensación de que su esfuerzo les había fallado. en cierto modo tenían razón. su esfuerzo les había fallado. pero fue su 172decisión de permitir que las pruebas fueran incorrectas lo que provocó el fallo. si hubieran empleado pruebas limpias, su esfuerzo no habría fallado. puedo afirmarlo con cierta seguridad porque he participado y dirigido muchos equipos que han tenido éxito gracias a pruebas de unidad limpias. la moraleja de la historia es sencilla: el código de prueba es tan importante como el de producción. no es un ciudadano de segunda. requiere concentración, diseño y cuidado. debe ser tan limpio como el código de producción. las pruebas propician posibilidades si sus pruebas no son limpias, las perderá. y sin ellas pierde lo mismo que hace que su código de producción sea flexible. sí, ha leído bien. las pruebas de unidad son las que hacen que el código sea flexible y se pueda mantener y reutilizar. la razón es sencilla. si tiene pruebas, no tendrá miedo a realizar cambios en el código. sin pruebas, cada cambio es un posible error. independientemente de la flexibilidad de su arquitectura, de la división del diseño, sin pruebas tendrá miedo a realizar cambios por la posibilidad de añadir errores no detectados. pero con las pruebas ese miedo desaparece. cuanto mayor sea el alcance de sus pruebas, menos miedo tendrá. podrá modificar el código con total impunidad, aunque su arquitectura no sea la mejor y el diseño sea mediocre. podrá mejorar la arquitectura y el diseño sin miedo alguno. por tanto, disponer de una suite automatizada de pruebas de unidad que cubran el código de producción es la clave para mantener limpio el diseño y la arquitectura. las pruebas proporcionan las posibilidades, ya que permiten el cambio. si sus pruebas no son limpias, la capacidad de modificar el código se verá limitada y perderá la posibilidad de mejorar la estructura de dicho código. cuanto menos limpias sean las pruebas, menos lo será el código. en última instancia perderá las pruebas y el código se corromperá. pruebas limpias 173¿qué hace que una prueba sea limpia? tres elementos: legibilidad, legibilidad y legibilidad. la legibilidad es sin duda más importante en las pruebas de unidad que en el código de producción. ¿qué hace que una prueba sea legible? lo mismo que en el código: claridad, simplicidad y densidad de expresión. en una prueba debe decir mucho con el menor número de expresiones posible. fíjese en el código de fitnesse del listado 9-1. estas tres pruebas son difíciles de entender y sin duda se pueden mejorar. por un lado, hay mucho código duplicado [g5] en las invocaciones repetidas a addpage y assertsubstring . sobre todo, este código se carga con detalles que interfieren con la expresividad de la prueba. listado 9-1 serializedpagerespondertest.java. public void testgetpagehieratchyasxml() throws exception { crawler.addpage(root, pathparser.parse(“pageone”)); crawler.addpage(root, pathparser.parse(“pageone.childone”)); crawler.addpage(root, pathparser.parse(“pagetwo”)); request.setresource(“root”); request.addinput(“type”, “pages”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“<name>pageone</name>”, xml); assertsubstring(“<name>pagetwo</name>”, xml); assertsubstring(“<name>childone</name>”, xml); } public void testgetpagehieratchyasxmldoesntcontainsymboliclinks() throws exception { wikipage pageone = crawler.addpage(root, pathparser.parse(“pageone”)); crawler.addpage(root, pathparser.parse(“pageone.childone”)); crawler.addpage(root, pathparser.parse(“pagetwo”)); pagedata data = pageone.getdata(); wikipageproperties properties = data.getproperties(); 174wikipageproperty symlinks = properties.set(symbolicpage.property_name); symlinks.set(“sympage”, “pagetwo”); pageone.commit(data); request.setresource(“root”); request.addinput(“type”, “pages”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“<name>pageone</name>”, xml); assertsubstring(“<name>pagetwo</name>”, xml); assertsubstring(“<name>childone</name>”, xml); assertnotsubstring(“sympage”, xml); } public void testgetdataashtml() throws exception { crawler.addpage(root, pathparser.parse(“testpageone”), “test page”); request.setresource(“testpageone”); request.addinput(“type”, “data”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“test page”, xml); assertsubstring(“<test”, xml); } fíjese en las invocaciones de pathparser . transforman cadenas en instancias de pagepath usadas por las arañas. esta transformación es totalmente irrelevante para la prueba y únicamente complica su cometido. los detalles circundantes a la creación del respondedor y la obtención y conversión de la respuesta también sobran. también la forma de crear la url de solicitud a partir de un recurso y un argumento (contribuí a crear este código, por lo que tengo todo el derecho a criticarlo). al final, el código no se ha diseñado de forma legible. el lector se ve rodeado de miles de detalles que debe comprender antes de que las pruebas tengan sentido. fíjese ahora en las pruebas mejoradas del listado 9-2. hacen exactamente lo mismo, pero se han refactorizado de forma más clara y 175descriptiva. listado 9-2 serializedpagerespondertest.java (refactorizado) public void testgetpagehierarchyasxml() throws exception { makepages(“pageone”, “pageone.childone”, “pagetwo”); submitrequest(“root”, “type:pages”); assertresponseisxml(); assertresponsecontains( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); } public void testsymboliclinksarenotinxmlpagehierarchy() throws exception { wikipage page = makepage(“pageone”); makepages(“pageone.childone”, “pagetwo”); addlinkto(page, “pagetwo”, “sympage”); submitrequest(“root”, “type:pages”); assertresponseisxml(); assertresponsecontains( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); assertresponsedoesnotcontain(“sympage”); } public void testgetdataasxml() throws exception { makepagewithcontent(“testpageone”, “test page”); submitrequest(“testpageone”, “type:data”); assertresponseisxml(); assertresponsecontains(“test page”, “<test”); } el patrón generar-operar-comprobar [38] es evidente en la estructura de las pruebas. cada una se divide claramente en tres partes. la primera crea los datos de prueba, la segunda opera en dichos datos y la tercera comprueba que la operación devuelva los resultados esperados. comprobará que se ha eliminado gran parte de los detalles molestos. las pruebas son concisas y sólo usan los tipos de datos y funciones que realmente necesitan. todo el que lea estas pruebas sabrá rápidamente para qué sirven y no se perderá entre detalles irrelevantes. 176lenguaje de pruebas específico del dominio las pruebas del listado 9-2 ilustran la creación de un lenguaje específico del dominio para sus pruebas. en lugar de usar las api que los programadores emplean para manipular el sistema, creamos una serie de funciones y utilidades que usan dichas api y que facilitan la escritura y la lectura de las pruebas. estas funciones y utilidades se convierten en una api especializada usada por las pruebas. son un lenguaje de pruebas que los programadores usan personalmente para crear sus pruebas y para ayudar a los que después las lean. esta api de pruebas no se diseña con antelación, sino que evoluciona con la refactorización continuada del código de prueba. al igual que refactorizamos el listado 9-1 en el listado 9-2, los programadores disciplinados refactorizan su código de prueba en versiones más sucintas y expresivas. un estándar dual en un sentido, el equipo que mencionamos antes tenía razón. el código de la api de pruebas tiene un conjunto de estándares de ingeniería diferentes al código de producción. también tiene que ser sencillo, sucinto y expresivo, pero no tan eficaz como el código de producción. después de todo, se ejecuta en un entorno de prueba, no de producción, y cada entorno tiene sus propias necesidades. fíjese en la prueba del listado 9-3. la creé como parte de un prototipo de sistema de control medioambiental. sin entrar en detalles, se aprecia que esta prueba comprueba que la alarma de baja temperatura, el calentador y el fuelle estén activados cuando la temperatura sea demasiado fría. listado 9-3 environmentcontrollertest.java @test public void turnonlotempalarmatthreashold() throws exception { hw.settemp(way_too_cold); 177controller.tic(); asserttrue(hw.heaterstate()); asserttrue(hw.blowerstate()); assertfalse(hw.coolerstate()); assertfalse(hw.hitempalarm()); asserttrue(hw.lotempalarm()); } aquí hay muchos detalles. por ejemplo, ¿para qué sirve la función tic ? de hecho, la ignoraría mientras leemos esta prueba. intente centrarse en saber si está de acuerdo en que el estado final del sistema tiene que ver con que la temperatura sea demasiado baja. al leer la prueba, la vista tiene que cambiar entre el nombre del estado comprobado y el sentido del estado comprobado. vemos heaterstate y después la vista salta a asserttrue . vemos coolerstate y nos fijamos en assertfalse . resulta tedioso y dificulta la lectura de la prueba. he conseguido mejorar la legibilidad de la prueba transformándola en el listado 9-4. listado 9-4 environmentcontrollertest.java (refactorizado) @test public void turnonlotempalarmatthreshold() throws exception { waytoocold(); assertequals(“hbchl”, hw.getstate()); } evidentemente, he ocultado el detalle de la función tic creando una función waytoocold . pero lo importante es la extraña cadena de assertequals . las mayúsculas significan activado y las minúsculas desactivado, y las letras siempre aparece en este orden: {heater, blower, cooler, hi-temp-alarm, lo-temp-alarm} . aunque prácticamente sea un incumplimiento de las reglas de asignación mental [39] , en este caso parece apropiado. una vez que conocemos el significado, la vista pasa por la cadena y podemos interpretar los resultados. la lectura de la prueba es casi un placer. fíjese en el listado 9-5 y compruebe con qué facilidad entiende las pruebas. 178listado 9-5 environmentcontrollertest.java (una selección mayor). @test public void turnoncoolerandbloweriftoohot() throws exception { toohot(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonheaterandbloweriftoocold() throws exception { toocold(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonhitempalarmatthreshold() throws exception { waytoohot(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonlotempalarmatthreshold() throws exception { waytoocold(); assertequals(“hbchl”, hw.getstate()); } la función getstate se reproduce en el listado 9-6. no es un código muy eficaz. para que lo sea, deberíamos haber usado stringbuffer . listado 9-6 mockcontrolhardware.java. public string getstate() { string state = “”; state += heater ? “h” : “h”; state += blower ? “b” : “b”; state += cooler ? “c” : “c”; state += hitempalarm ? “h” : “h”; state += lotempalarm ? “l” : “l”; return state; } stringbuffer es poco atractivo. incluso en código de producción, intento evitarlo si el coste es mínimo, como podría suceder en el listado 9-6. pero esta aplicación es claramente un sistema incrustado en tiempo real y es probable que los recursos del equipo y la memoria estén limitados. sin 179embargo, el entorno de pruebas es improbable que lo esté. es la naturaleza del estándar dual. hay cosas que nunca haría en un entorno de producción totalmente válidas para un entorno de prueba. suelen ser problemas de memoria o eficacia de la cpu, pero nunca problemas de limpieza. una afirmación por prueba existe una escuela de pensamiento [40] que afirma que todas las funciones de prueba de una prueba junit sólo deben tener una instrucción de afirmación. puede parecer una regla draconiana pero la ventaja se aprecia en el listado 9- 5. las pruebas llegan a una misma conclusión, que se entiende de forma rápida y sencilla. ¿pero qué sucede con el listado 9-2? no parece razonable afirmar que el resultado es xml y que contiene determinadas subcadenas. sin embargo, podemos dividir la prueba en dos, cada una con una afirmación concreta, como se muestra en el listado 9-7. listado 9-7 serializedpagerespondertest.java (una sola afirmación). public void testgetpagehierarchyasxml() throws exception { givenpages(“pageone”, “pageone.childone”, “pagetwo”); whenrequestisissued(“root”, “type:pages”); thenresponseshouldbexml(); } public void testgetpagehierarchyhasrighttags() throws exception { givenpages(“pageone”, “pageone.childone”, “pagetwo”); whenrequestisissued(“root”, “type:pages”); thenresponseshouldcontain( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); } he cambiado los nombres de las funciones para usar la convención dado- cuando-entonces [41] . de este modo las pruebas son más fáciles de leer. desafortunadamente, al dividir las pruebas se genera código duplicado. 180podemos eliminar los duplicados por medio del patrón método de plantilla [42] e incluir las partes dado/cuando en la clase base, y las partes entonces en derivaciones diferentes. o podríamos crear una clase de prueba independiente e incluir las partes dado y cuando en la función @before y las partes entonces en cada función @test . pero parece un mecanismo excesivo para un problema tan menor. al final, opto por las afirmaciones múltiples del listado 9-2. considero que la regla de una sola afirmación es una directriz adecuada [43] . siempre intento crear un lenguaje de pruebas específico del dominio que la complemente, como en el listado 9-5, pero no rechazo incluir más de una afirmación en una prueba. creo que lo mejor que podemos decir es que el número de afirmaciones de una prueba debe ser mínimo. un solo concepto por prueba puede que una regla más indicada sea probar un único concepto en cada función de prueba. no queremos extensas funciones que prueben una cosa diferente tras otra, como sucede en el listado 9-8. esta prueba debería dividirse en tres diferentes que probaran tres cosas distintas. al combinarlas en la misma función se obliga al lector a determinar por qué cada sección se ubica en ese punto y qué prueba dicha sección. listado 9-8 /** * varias pruebas para el método addmonths(). */ public void testaddmonths() { serialdate d1 = serialdate.createinstance(31, 5, 2004); serialdate d2 = serialdate.addmonths(1, d1); assertequals(30, d2.getdayofmonth()); assertequals(6, d2.getmonth()); assertequals(2004, d2.getyyyy()); serialdate d3 = serialdate.addmonths(2, d1); assertequals(31, d3.getdayofmonth()); assertequals(7, d3.getmonth()); assertequals(2004, d3.getyyyy()); 181serialdate d4 = serialdate.addmonths(1, serialdate.addmonths(1, d1)); assertequals(30, d4.getdayofmonth()); assertequals(7, d4.getmonth()); assertequals(2004, d4.getyyyy()); } las tres funciones deberían ser las siguientes: dado el último día de un mes con 31 días (como mayo): 1 . cuando se añade un mes, si el último día de ese mes es el 30 (como en junio), entonces la fecha debe ser el día 30 de ese mes, no el 31. 2 . cuando se añaden dos meses a esa fecha, si el último mes tiene 31 días, entonces la fecha debe ser el día 31. dado el último día de un mes con 30 días (como junio): 1 . cuando se añade, si el último día de ese mes tiene 31 días, entonces la fecha debe ser el 30, no el 31. expresado de esta forma, se aprecia que existe una regla general entre las distintas pruebas. al incrementar el mes, la fecha no puede ser mayor que su último día. esto implica que al incrementar el mes en el 28 de febrero debe generarse el 28 de marzo. falta esa prueba y convendría que la escribiéramos. así pues, no son las múltiples afirmaciones del listado 9-8 las causantes del problema, sino el hecho de que se prueba más de un concepto. probablemente la regla óptima sea minimizar el número de activos por concepto y probar un solo concepto por función de prueba. f.i.r.s.t. [44] las pruebas limpias siguen otras cinco reglas, cuyas iniciales forman las siglas first en inglés: rapidez ( fast ): las reglas deben ser rápidas y ejecutarse de forma rápida. si lo hacen lentamente, no las ejecutará con frecuencia. al no hacerlo, no detectará los problemas con la suficiente antelación como para solucionarlos. no se sentirá con libertad para limpiar el código, que acabará corrompiéndose. 182independencia ( independent ): las pruebas no deben depender entre ellas. una prueba no debe establecer condiciones para la siguiente. debe poder ejecutar cada prueba de forma independiente y en el orden que desee. si las pruebas dependen unas de otras, la primera que falle provocará una sucesión de fallos, dificultará el diagnóstico y ocultará efectos posteriores. repetición ( repeatable ): las pruebas deben poder repetirse en cualquier entorno. debe poder ejecutarlas en el entorno de producción, en el de calidad y en su portátil de camino a casa en un tren sin red. si no puede repetir las pruebas en cualquier entorno, siempre tendrá una excusa de su fallo. también verá que no puede ejecutar las pruebas si el entorno no está disponible. validación automática ( self-validating ): las pruebas deben tener un resultado booleano: o aciertan o fallan. no debe tener que leer un extenso archivo de registro para saber si una prueba ha acertado, ni comparar manualmente dos archivos de texto distintos para ello. si las pruebas no se validan automáticamente, el fallo puede ser subjetivo y la ejecución de las pruebas puede requerir una extensa evaluación manual. puntualidad ( timely ): las pruebas deben crearse en el momento preciso: antes del código de producción que hace que acierten. si crea las pruebas después del código de producción, puede que resulte difícil probarlo. puede decidir qué parte del código de producción sea demasiado difícil de probar. no diseñe código de producción que no se pueda probar. conclusión apenas hemos abordado la superficie de este tema. de hecho, se podría crear un libro entero sobre pruebas limpias. las pruebas son tan importantes para la salud de un proyecto como el código de producción. puede que incluso más, ya que conservan y mejoran la flexibilidad, capacidad de mantenimiento y reutilización del código de producción. por ello, intente que sean limpias. trabaje para que resulten expresivas y concisas. invente api de prueba que actúen como lenguaje específico del dominio que le ayude a crear las pruebas. si deja que las pruebas se corrompan, sucederá lo mismo con el código de 183producción. mantenga limpias las pruebas. bibliografía [rspec] : rspec: behavior driven development for ruby programmers , aslak hellesay, david chelimsky, pragmatic bookshelf, 2008. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 18410 clases con jeff langr hasta ahora nos hemos centrado en escribir bien líneas y bloques de código. nos hemos adentrado en la correcta composición de las funciones y en su interrelación. pero a pesar de la atención dedicada a la expresividad de las instrucciones y las funciones, no tendremos código limpio hasta que nos fijemos en los niveles superiores de su organización. hablemos sobre clases. 185organización de clases de acuerdo a la convención estándar de java, una clase debe comenzar con una lista de variables. las constantes estáticas públicas, si existen, deben aparecer primero. tras ello, las variables estáticas privadas y después las variables de instancia privadas. no suele ser necesario usar variables públicas. las funciones públicas deben seguir a la lista de variables. incluimos las utilidades públicas invocadas por una función pública tras la propia función pública. este sistema cumple la regla descendente y permite que el programa se lea como un artículo de periódico. encapsulación queremos que nuestras variables y funciones de utilidad sean privadas, pero no es imprescindible. en ocasiones podemos proteger una variable o función de utilidad para que sea accesible para una prueba. las reglas mandan. si una regla del mismo paquete tiene que invocar una función o acceder a una variable, hacemos que tenga ámbito protected o de paquete. sin embargo, primero veremos una forma de mantener la privacidad. la relajación de la encapsulación siempre es un último resorte. las clases deben ser de tamaño reducido la primera regla de las clases es que deben ser de tamaño reducido. la segunda regla es que deben ser todavía más reducidas. no, no vamos a repetir el mismo texto en el capítulo sobre las funciones, pero como sucede con las funciones, el tamaño reducido es lo principal a la hora de diseñar una clase. y la pregunta inmediata es qué nivel de reducción. con las funciones medimos el tamaño contando líneas físicas. con las clases usamos otra medida distinta: las responsabilidades [45] . el listado 10-1 muestra una clase, superdashboard , que muestra 70 186métodos públicos. muchos programadores estarán de acuerdo en que es un tamaño excesivo. algunos denominarían a superdashboard una clase dios. listado 10-1 demasiadas responsabilidades. public class superdashboard extends jframe implements metadatauser public string getcustomizerlanguagepath() public void setsystemconfigpath(string systemconfigpath) public string getsystemconfigdocument() public void setsystemconfigdocument(string systemconfigdocument) public boolean getgurustate() public boolean getnovicestate() public boolean getopensourcestate() public void showobject(metaobject object) public void showprogress(string s) public boolean ismetadatadirty() public void setismetadatadirty(boolean ismetadatadirty) public component getlastfocusedcomponent() public void setlastfocused(component lastfocused) public void setmouseselectstate(boolean ismouseselected) public boolean ismouseselected() public languagemanager getlanguagemanager() public project getproject() public project getfirstproject() public project getlastproject() public string getnewprojectname() public void setcomponentsizes(dimension dim) public string getcurrentdir() public void setcurrentdir(string newdir) public void updatestatus(int dotpos, int markpos) public class[] getdatabaseclasses() public metadatafeeder getmetadatafeeder() public void addproject(project project) public boolean setcurrentproject(project project) public boolean removeproject(project project) public metaprojectheader getprogrammetadata() public void resetdashboard() public project loadproject(string filename, string projectname) public void setcansavemetadata(boolean cansave) public metaobject getselectedobject() public void deselectobjects() public void setproject(project project) public void editoraction(string actionname, actionevent event) public void setmode(int mode) public filemanager getfilemanager() public void setfilemanager(filemanager filemanager) public configmanager getconfigmanager() public void setconfigmanager(configmanager configmanager) public classloader getclassloader() 187public void setclassloader(classloader classloader) public properties getprops() public string getuserhome() public string getbasedir() public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() public metaobject pasting( metaobject target, metaobject pasted, metaproject project) public void processmenuitems(metaobject metaobject) public void processmenuseparators(metaobject metaobject) public void processtabpages(metaobject metaobject) public void processplacement(metaobject object) public void processcreatelayout(metaobject object) public void updatedisplaylayer(metaobject object, int layerindex) public void propertyeditedrepaint(metaobject object) public void processdeleteobject(metaobject object) public boolean getattachedtodesigner() public void processprojectchangedstate(boolean hasprojectchanged) public void processobjectnamechanged(metaobject object) public void runproject() public void setallowdragging(boolean allowdragging) public boolean allowdragging() public boolean iscustomizing() public void settitle(string title) public idemenubar getidemenubar() public void showhelper(metaobject metaobject, string propertyname) //… y otros muchos métodos no públicos… } ¿y si superdashboard sólo incluyera los métodos mostrados en el listado 10-2? listado 10-2 ¿suficientemente reducido? public class superdashboard extends jframe implements metadatauser public component getlastfocusedcomponent() public void setlastfocused(component lastfocused) public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() } cinco métodos no es demasiado, ¿verdad? en este caso sí ya que a pesar del reducido número de métodos, superdashboard también tiene demasiadas responsabilidades. el nombre de una clase debe describir las responsabilidades que 188desempeña. de hecho, el nombre es la primera forma para determinar el tamaño de una clase. si no podemos derivar un nombre conciso para una clase, seguramente sea demasiado extenso. cuanto más ambiguo sea el nombre de la clase, más probabilidades hay de que tenga demasiadas responsabilidades. por ejemplo, los nombres de clase con palabras como processor , manager o super suelen indicar una desafortunada acumulación de responsabilidades. también debemos ser capaces de escribir una breve descripción de la clase en unas 25 palabras, sin usar las palabras « si », « o », « y » o « pero ». ¿cómo describiríamos superdashboard ?: superdashboard permite acceder al componente con el enfoque y nos permite controlar los números de versión y producto. el primer y indica que superdashboard tiene demasiadas responsabilidades. el principio de responsabilidad única el principio de responsabilidad única ( single responsibility principle , srp) [46] indica que una clase o módulo debe tener uno y sólo un motivo para cambiar. este principio nos indica la definición de responsabilidad y una directriz para el tamaño de la clase. las clases sólo deben tener una responsabilidad, un motivo para cambiar. la clase superdashboard aparentemente reducida del listado 10-2 tiene dos motivos para cambiar. primero, controla información de versión que supuestamente debe actualizarse cada vez que se comercialice el software . por otra parte, gestiona componentes de java swing (un derivado de jframe, la representación swing de una ventana de igu de nivel superior). sin duda, querremos cambiar el número de versión si cambiamos el código swing, pero lo contrario no es necesario: podríamos cambiar la información de versión en función de los cambios de otro código del sistema. la identificación de responsabilidades (los motivos del cambio) nos permite reconocer y mejorar las abstracciones en nuestro código. podemos extraer los tres métodos de superdashboard relacionados con la información de versiones en una clase independiente como version (véase el listado 10-3.) la clase version es una construcción 189que se puede reutilizar en otras aplicaciones. listado 10-3 una clase con una única responsabilidad. public class version { public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() } srp es uno de los conceptos más importantes del diseño orientado a objetos y también uno de los más sencillos de entender y cumplir, pero también es uno de los que más se abusa al diseñar clases. habitualmente nos encontramos clases que hacen demasiadas cosas. ¿por qué? crear software que funcione y crear software limpio son dos actividades diferentes. muchos tenemos un cerebro limitado, de modo que nos centramos en que el código funcione más que en su organización y limpieza. es algo totalmente válido. mantener objetivos separados es tan importante en nuestras actividades de programación como en nuestros programas. el problema es que muchos creemos que hemos terminado cuando el programa funciona. no cambiamos al otro objetivo de organización y limpieza. pasamos al siguiente problema en lugar de retroceder y dividir las clases en unidades independientes con una única responsabilidad. al mismo tiempo, muchos programadores temen que un elevado número de pequeñas clases con un único propósito dificulten la comprensión del conjunto. les preocupa que tengan que desplazarse entre las clases para determinar cómo funciona un aspecto concreto. sin embargo, un sistema con muchas clases reducidas no tiene más elementos móviles que un sistema con algunas clases enormes. en ambos hay que entender lo mismo. la pregunta es si quiere organizar sus herramientas en cajas con muchos pequeños cajones que contengan componentes bien definidos y etiquetados, o usar varios cajones grandes en los que mezcle todo. todos los sistemas tienen una gran lógica y complejidad. el objetivo principal para gestionar dicha complejidad es organizarla para que un programador sepa dónde buscar y comprenda la complejidad directamente afectada en cada momento concreto. por el contrario, un sistema con clases 190multipropósito de mayor tamaño nos obliga a buscar entre numerosos elementos que no siempre necesitamos conocer. para reformular los puntos anteriores, diremos que los sistemas deben estar formados por muchas claves reducidas, no por algunas de gran tamaño. cada clase reducida encapsula una única responsabilidad, tiene un solo motivo para cambiar y colabora con algunas otras para obtener los comportamientos deseados del sistema. cohesión las clases deben tener un número reducido de variables de instancia. los métodos de una clase deben manipular una o varias de dichas variables. por lo general, cuantas más variables manipule un método, más cohesión tendrá con su clase. una clase en la que cada variable se usa en cada método tiene una cohesión máxima. por lo general, no es recomendable ni posible crear este tipo de clases pero queremos que la cohesión de nuestras clases sea elevada. si lo logramos, significa que los métodos y variables de la clase dependen unos de otros y actúan como un todo lógico. fíjese en la implementación de stack en el listado 10-4. es una clase muy consistente. de los tres métodos, sólo size() no usa ambas variables. listado 10-4 stack.java, una clase consistente. public class stack { private int topofstack = 0; list<integer> elements = new linkedlist<integer>(); public int size() { return topofstack; } public void push(int element) { topofstack++; elements.add(element); } public int pop() throws poppedwhenempty { 191if (topofstack == 0) throw new poppedwhenempty(); int element = elements.get(--topofstack); elements.remove(topofstack); return element; } } la estrategia de reducir el tamaño de las funciones y de las listas de parámetros suele provocar la proliferación de variables de instancia usadas por un subconjunto de los métodos. si esto sucede, siempre existe al menos una clase que intenta huir de la clase de mayor tamaño. debe intentar separar las variables y métodos en dos o más clases para que las nuevas sean más consistentes. mantener resultados consistentes en muchas clases de tamaño reducido la división de grandes funciones en otras más pequeñas aumenta la proliferación de clases. imagine una gran función con numerosas variables declaradas. imagine que desea extraer una pequeña parte de esa función en otra independiente. sin embargo, el código que extrae usa cuatro de las variables declaradas en la función. ¿debe pasar las cuatro variables como argumentos a la nueva función? en absoluto. si ascendemos estas cuatro variables a variables de instancia de la clase, podremos extraer el código sin pasar las variables. resultaría más sencillo dividir la función en pequeños fragmentos. desafortunadamente, eso significaría que nuestras clases perderían cohesión ya que acumularían más y más variables de instancia que sólo existen para que otras funciones las compartan. pero un momento. si apenas existen funciones que compartan determinadas variables, ¿no son entonces una clase con derecho propio? por supuesto. cuando las clases pierdan cohesión, divídalas. por tanto, dividir una gran función en otras más reducidas también nos permite dividir varias clases más reducidas. de este modo mejora la organización del programa y su estructura resulta más transparente. como ejemplo, usaremos un ejemplo obtenido del libro de knuth literate 192programming [47] . el listado 10-5 muestra una traducción a java del programa printprimes de knuth. para hacerle justicia, no es el programa que creó sino el resultado generado por su herramienta web. lo usamos aquí por ser un magnífico punto de partida para dividir una función de gran tamaño en varias funciones y clases más reducidas. listado 10-5 printprimes.java package literateprimes; public class printprimes { public static void main(string[] args) { final int m = 1000; final int rr = 50; final int cc = 4; final int ww = 10; final int ordmax = 30; int p[] = new int[m + 1]; int pagenumber; int pageoffset; int rowoffset; int c; int j; int k; boolean jprime; int ord; int square; int n; int mult[] = new int[ordmax + 1]; j = 1; k = 1; p[1] = 2; ord = 2; square = 9; while (k < m) { do { j = j + 2; if (j == square) { ord = ord + 1; square = p[ord] * p[ord]; mult[ord - 1] = j; } n = 2; jprime = true; while (n < ord && jprime) { while (mult[n] < j) 193mult[n] = mult[n] + p[n] + p[n]; if (mult[n] == j) jprime = false; n = n + 1; } } while (!jprime); k = k + 1; p[k] = j; } { pagenumber = 1; pageoffset = 1; while (pageoffset <= m) { system.out.println(“the first ” + m + “ prime numbers --- page ” + pagenumber); system.out.println(“”); for (rowoffset = pageoffset; rowoffset < pageoffset + rr; rowoffset++) { for (c = 0; c < cc;c++) if (rowoffset + c * rr <= m) system.out.format(“%10d”, p[rowoffset + c * rr]); system.out.println(“”); } system.out.println(“\f”); pagenumber = pagenumber + 1; pageoffset = pageoffset + rr * cc; } } } } este programa, escrito como una sola función, es un desastre. el sangrado de su estructura es excesivo y hay demasiadas variables extrañas. como mínimo, la función debería dividirse en otras más pequeñas. los listados del 10-6 al 10-8 muestran la división del código del listado 10-5 en clases y funciones de menor tamaño, además de los nombres elegidos para dichas clases, funciones y variables. listado 10-6 primeprinter.java (refactorizado) package literateprimes; public class primeprinter ( public static void main(string[] args) { final int number_of_prime5 = 1000; int[] primes = primegenerator.generate(number_of_primes); final int rows_per_page = 50; 194final int columns_per_page = 4; rowcolumnpageprinter tableprinter = new rowcolumnpageprinter(rows_per_page, columns_per_page, “the first ” + number_of_primes + “ prime numbers”); tableprinter.print(primes); } } listado 10-7 rowcolumnpageprinter.java. package literateprimes; import java.io.printstream; public class rowcolumnpageprinter { private int rowsperpage; private int columnsperpage; private int numbersperpage; private string pageheader; private printstream printstream; public rowcolumnpageprinter(int rowsperpage, int columnsperpage, string pageheader) { this.rowsperpage = rowsperpage; this.columnsperpage = columnsperpage; this.pageheader = pageheader; numbersperpage = rowsperpage * columnsperpage; printstream = system.out; } public void print(int data[]) { int pagenumber = 1; for (int firstindexonpage = 0; firstindexonpage < data.length; firstindexonpage += numbersperpage) { int lastindexonpage = math.min(firstindexonpage + numbersperpage - 1, data.length - 1); printpageheader(pageheader, pagenumber); printpage(firstindexonpage, lastindexonpage, data); printstream.println(“\f”); pagenumber++; } } private void printpage (int firstindexonpage, int lastindexonpage, int[] data) { 195int firstindexoflastrowonpage = firstindexonpage + rowsperpage - 1; for (int firstindexinrow = firstindexonpage; firstindexinrow <= firstindexoflastrowonpage; firstindexinrow++) { printrow(firstindexinrow, lastindexonpage, data); printstream.println(“”); } } private void printrow(int firstindexinrow, int lastindexonpage, int[] data) { for (int column = 0; column < columnsperpage; column++) { int index = firstindexinrow + column * rowsperpage; if (index <= lastindexonpage) printstream.format(“%10d”, data[index]); } } private void printpageheader(string pageheader, int pagenumber) { printstream.println(pageheader + “ --- page ” + pagenumber); printstream.println(“”); } public void setoutput(printstream printstream) { this.printstream = printstream; } } listado 10-8 primegenerator.java package literateprimes; import java.util.arraylist; public class primegenerator { private static int[] primes; private static arraylist<integer> multiplesofprimefactors; protected static int[] generate(int n) { primes = new int[n]; multiplesofprimefactors = new arraylist<integer>(); set2asfirstprime(); checkoddnumbersforsubsequentprimes(); return primes; } private static void set2asfirtsprime() { primes[0] = 2; multiplesofprimefactors.add(2); 196} private static void checkoddnumbersforsubsequentprimes() { int primeindex = 1; for (int candidate = 3; primeindex < primes.length; candidate += 2) { if (isprime(candidate)) primes[primeindex++] = candidate; } } private static boolean isprime(int candidate) { if (isleastrelevantmultipleofnextlargerprimefactor(candidate)) { multiplesofprimefactors.add(candidate); return false; } return isnotmultipleofanypreviousprimefactor(candidate); } private static boolean isleastrelevantmultipleofnextlargerprimefactor(int candidate) { int nextlargerprimefactor = primes[multiplesofprimefactors.size()]; int leastrelevantmultiple = nextlargerprimefactor * nextlargerprimefactor; return candidate == leastrelevantmultiple; } private static boolean isnotmultipleofanypreviousprimefactor(int candidate) { for (int n = 1; n < multiplesofprimefactors.size(); n++) { if (ismultipleofnthprimefactor(candidate, n)) return false; } return true; } private static boolean ismultipleofnthprimefactor(int candidate, int n) { return candidate == smallestoddnthmultiplenotlessthancandidate(candidate, n); } private static int smallestoddnthmultiplenotlessthancandidate(int candidate, int n) { int multiple = multiplesofprimefactors.get(n); while (multiple < candidate) multiple += 2 * primes[n]; multiplesofprimefactors.set(n, multiple); return multiple; } } lo primero que apreciará es que ha aumentado la longitud del programa, 197de una a casi tres páginas. este aumento se debe a varios motivos. en primer lugar, el programa refactorizado usa nombres de variable más extensos y descriptivos. por otra parte, usa declaraciones de funciones y clases como comentarios del código. por último, usamos espacios en blanco y técnicas de formato para mantener la legibilidad. el programa se ha dividido en tres responsabilidades principales. la parte principal se incluye en la clase primeprinter , responsable de controlar el entorno de ejecución. cambia si se modifica el método de invocación. por ejemplo, si este programa se convierte en un servicio soa, es la clase que se verá afectada. rowcolumnpageprinter sabe cómo aplicar formato a una lista de números con una determinada cantidad de filas y columnas. si es necesario cambiar el formato del resultado, es la clase que se verá afectada. la clase primegenerator sabe cómo generar una lista de números primos. no se creará una instancia como objeto. la clase es sólo un ámbito útil en el que declarar y ocultar sus variables. esta clase cambia si se modifica el algoritmo para calcular números primos. no hemos reescrito el programa. no hemos empezado de cero y los hemos vuelto a diseñar. en realidad, si se fija atentamente en los dos programas, verá que usan los mismos algoritmos y mecanismos. el cambio se ha realizado creando una suite de pruebas que verifican el comportamiento preciso del primer programa. tras ello, se aplican numerosos cambios mínimos, de uno en uno. tras cada cambio, se ejecuta el programa para garantizar que el comportamiento no varía. paso a paso, el primer programa se limpia y se transforma en el segundo. organizar los cambios en muchos sistemas, el cambio es continuo. cada cambio supone un riesgo de que el resto del sistema no funcione de la forma esperada. en un sistema limpio organizamos las clases para reducir los riesgos de los cambios. la clase sql del listado 10-9 se usa para generar cadenas sql de forma correcta con los metadatos adecuados. es un trabajo continuo y, como tal, no 198admite funciones sql como instrucciones update . cuando la clase sql tenga que admitir una instrucción update , tendremos que abrirla para realizar modificaciones. el problema de abrir una clase es el riesgo que conlleva. cualquier modificación puede afectar a otro código de la clase. debe probarse concienzudamente. listado 10-9 clase que debemos abrir para realizar cambios. public class sql { public sql(string table, column[] columns) public string create() public string insert(object[] fields) public string selectall() public string findbykey(string keycolumn, string keyvalue) public string select(column column, string pattern) public string select(criteria criteria) public string preparedinsert() private string columnlist(column[] columns) private string valueslist(object[] fields, final column[] columns) private string selectwithcriteria(string criteria) private string placeholderlist(column[] columns) } la clase sql debe cambiar al añadir un nuevo tipo de instrucción. también debe cambiar cuando variemos los detalles de un tipo de instrucción concreto; por ejemplo, si tenemos que modificar la funcionalidad select para admitir selecciones secundarias. estos dos motivos de cambio significan que la clase sql incumple srp. podemos detectar este incumplimiento desde un punto de vista organizativo. el método outline de sql muestra que hay métodos privados, como selectwithcriteria , que parecen relacionarse únicamente con instrucciones select . el comportamiento de métodos privados aplicados a un pequeño subconjunto de una clase puede ser una heurística útil para detectar zonas que mejorar. sin embargo, la verdadera razón debe ser el cambio del sistema. si la clase sql se considera totalmente lógica, no debemos preocuparnos por separar las responsabilidades. si no necesitamos funcionalidad de actualización en el futuro, podemos olvidarnos de sql . pero si tenemos que 199abrir una clase, debemos corregir el diseño. ¿y si optamos por una solución como la del listado 10-10? los métodos públicos de interfaz definidos en sql en el listado 10-9 se refactorizan en sus propias variantes de la clase sql . los métodos privados, como valueslist , se mueven directamente a las posiciones necesarias. el comportamiento privado se reduce a un par de clases de utilidad: where y columnlist . listado 10-10 un grupo de clases cerradas. abstract public class sql { public sql(string table, column[] columns) abstract public string generate(); } public class createsql extends sql { public createsql(string table, column[] columns) @override public string generate() } public class selectsql extends sql { public selectsql(string table, column[] columns) @override public string generate() } public class insertsql extends sql { public selectsql(string table, column[] columns, object[] fields) @override public string generate() private string valueslist(object[] fields, final column[] columns) } public class selectwithcriteriasql extends sql { public selectwithcriteriasql( string table, column[] columns, criteria criteria) @override public string generate() } public class selectwithmatchsql extends sql { public selectwithmatchsql( string table, column[] columns, column column, string pattern) @override public string generate() } public class findbykeysql extends sql { public findbykeysql( string table, column[] columns, string keycolumn, string keyvalue) @override public string generate() } 200public class preparedinsertsql extends sql { public preparedinsertsql(string table, column[] columns) @override public string generate() private string placeholderlist(column[] columns) } public class where { public where(string criteria) public string generate() } public class columnlist { public columnlist(column[] columns) public string generate() } el código de cada clase se simplifica enormemente. el tiempo necesario para entender las clases se reduce al mínimo. el riesgo de que una función afecte a otra desaparece casi por completo. desde el punto de vista de las pruebas, resulta más sencillo probar la lógica de esta solución, ya que las clases se aíslan unas de otras. además, cuando llegue el momento de añadir las instrucciones update , no cambia ninguna de las clases existentes. añadimos la lógica para generar instrucciones update a una nueva subclase de sql , updatesql . este cambio no afecta a otro código del sistema. nuestra lógica sql reestructurada representa lo mejor de ambos mundos. cumple con srp y también con otro principio clave del diseño de clases orientadas a objetos, denominado principio abierto/cerrado [48] : las clases deben abrirse para su ampliación para cerrarse para su modificación. la nueva clase sql se abre a nuevas funcionalidades mediante la creación de subclases pero podemos realizar estos cambios y mantener cerradas las demás clases. basta con añadir nuestra clase updatesql . debemos estructurar nuestros sistemas para ensuciarlos lo menos posible cuando los actualicemos con nuevas funciones o cambios. en un sistema ideal, incorporamos nuevas funciones ampliándolo, no modificando el código existente. aislarnos de los cambios 201las necesidades cambiarán y también lo hará el código. en la programación orientada a objetos aprendemos que hay clases concretas que contienen detalles de implementación (el código) y clases abstractas que sólo representan conceptos. una clase cliente que dependa de detalles concretos está en peligro si dichos detalles cambian. podemos recurrir a interfaces y clases abstractas para aislar el impacto de dichos detalles. las dependencias de detalles de concretos crean retos para nuestro sistema. si tenemos que crear la clase portfolio y ésta depende de una api tokyostockexchange externa para obtener su valor, nuestros casos de prueba se verán afectados por la volatilidad de esta búsqueda. resulta complicado crear una prueba cuando se obtiene una respuesta diferente cada cinco minutos. en lugar de diseñar portfolio para que dependa directamente de tokyostockexchange , creamos una interfaz, stockexchange , que declara un único método: public interface stockexchange { money currentprice(string symbol); } diseñamos tokyostockexchange para implementar esta interfaz. también nos aseguramos de que el constructor de portfolio adopte como argumento una referencia a stockexchange: public portfolio { private stockexchange exchange; public portfolio(stockexchange exchange) { this.exchange = exchange; } //… } ahora la prueba puede crear una implementación de la interfaz stockexchange que emule tokyostockexchange . esta implementación de prueba fijará el valor actual del símbolo que usemos en la prueba. si nuestra prueba demuestra la adquisición de cinco acciones de microsoft para nuestra cartera de valores, diseñe el código de la implementación de prueba para que siempre devuelva 100 dólares por acción de microsoft. nuestra implementación de prueba de la interfaz stockexchange se reduce a una sencilla búsqueda de tabla. de este modo 202podemos crear una prueba que espere un valor de cartera total de 500 dólares: public class portfoliotest { private fixedstockexchangestub exchange; private portfolio portfolio; @before protected void setup() throws exception { exchange = new fixedstockexchangestub(); exchange.fix(“msft”, 100); portfolio = new portfolio(exchange); } @test public void givenfivemsfttotalshouldbe500() throws exception { portfolio.add(5, “msft”); assert.assertequals(500, portfolio.value()); } } si diseccionamos un sistema para poder probarlo de esta forma, resultará más flexible y se podrá reutilizar. la ausencia de conexiones significa que los elementos del sistema se aíslan entre ellos y de otros cambios. este aislamiento hace que comprendamos mejor los elementos del sistema. al minimizar las conexiones de esta forma, nuestras clases cumplen otro principio de diseño: dependency inversion principle (dip) o principio de inversión de dependencias [49] . básicamente afirma que nuestras clases deben depender de abstracciones, no de detalles concretos. en lugar de depender de los detalles de implementación de la clase tokyostockexchange , nuestra clase portfolio depende de la interfaz stockexchange , que representa el concepto abstracto de solicitar el precio actual de una acción. esta abstracción aísla todos los datos concretos de la obtención de dicho precio, incluyendo de dónde se obtiene. bibliografía [rdd] : object design: roles, responsibilities, and collaborations , rebecca wirfs-brock et al., addison-wesley, 2002. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. 203[knuth92] : literate programming , donald e. knuth, center for the study of language and information, leland stanford junior university, 1992. 20411 sistemas por el dr. kevin dean wampler 205«la complejidad es letal. acaba con los desarrolladores y dificulta la planificación, generación y pruebas de los productos». —ray ozzie, cto, microsoft corporation cómo construir una ciudad ¿podría encargarse de todos los detalles por su cuenta? seguramente no. incluso la gestión de una ciudad existente sería demasiado para una sola persona. y aun así, las ciudades funcionan (en la mayoría de los casos). funcionan porque tienen equipos que controlan partes concretas de la ciudad, el alcantarillado, la red eléctrica, el tráfico, la seguridad, las normativas 206urbanísticas, etc. algunos se encargan de aspectos generales y otros se centran en los detalles. las ciudades también funcionan porque disponen de evolucionados niveles de abstracción y modularidad que permiten a individuos y componentes trabajar de forma eficaz, sin necesidad de entender el trasfondo general. aunque los equipos de software se suelen organizar de esta forma, los sistemas en los que trabajan no suelen contar con la misma separación de aspectos y niveles de abstracción. en este capítulo veremos cómo mantener la limpieza en niveles superiores de abstracción, en el sistema. separar la construcción de un sistema de su uso en primer lugar, recuerde que la construcción es un proceso muy diferente al uso. mientras escribo estas líneas, a través de la ventana veo un nuevo hotel en construcción en chicago. hoy instalarán una gran grúa. todos los obreros llevan casco. dentro de un año habrán acabado el hotel. la grúa desaparecerá. el edificio estará terminado, con su reluciente fachada de cristal y su atractiva decoración. la gente que trabajará en él también será diferente. los sistemas de software deben separar el proceso de inicio, en el que se crean los objetos de la aplicación y se conectan las dependencias, de la lógica de ejecución que toma el testigo tras el inicio. el proceso de inicio es un aspecto que toda aplicación debe abordar. es el primero que veremos en este capítulo. la separación de aspectos es una de las técnicas de diseño más antiguas e importantes de nuestra profesión. desafortunadamente, muchas aplicaciones no lo hacen. el código del proceso de inicio se mezcla con la lógica de tiempo de ejecución. veamos un ejemplo típico: public service getservice() { if (service == null) service = new myserviceimpl (…); //¿lo bastante predeterminado para la 207mayoría de los casos? return service; } es la técnica de inicialización/evaluación tardía y tiene sus méritos. no incurrimos en la sobrecarga de la construcción a menos que usemos el objeto realmente, y como resultado el tiempo de inicio se puede acelerar. también evitamos que se devuelva null . sin embargo, ahora tenemos una dependencia en myserviceimpl y todo lo que su constructor requiere (que he omitido). no podemos compilar sin resolver estas dependencias, aunque nunca usemos un objeto de este tipo en tiempo de ejecución. las pruebas también pueden ser un problema. si myserviceimpl es un objeto pesado, tendremos que asegurarnos de asignar el correspondiente test double [50] u objeto simulado al campo de servicio antes de invocar este método en las pruebas de unidad. como la lógica de la construcción se mezcla con el procesamiento normal de tiempo de ejecución, debemos probar todas las rutas de ejecución (como la prueba null y su bloque). al contar con ambas responsabilidades, el método hace más de una cosa, por lo que se incumple el principio de responsabilidad única. lo peor de todo es que no sabemos si myserviceimpl es el objeto correcto en todos los casos. ¿por qué la clase con este método tiene que conocer el contexto global? ¿podemos saber realmente cuál es el objeto correcto que usar aquí? ¿es posible que un mismo tipo sea el correcto para todos los contextos posibles? un caso de inicialización tardía no es un problema serio. sin embargo, suele haber muchos casos de este tipo de configuración en las aplicaciones. por tanto, la estrategia de configuración global (si existe) se disemina por la aplicación, sin apenas modularidad y con una significativa duplicación. si somos diligentes sobre el diseño de sistemas robustos y bien formados, no debemos permitir fallos de modularidad. el proceso de inicio de la construcción y conexión de objetos no es una excepción. debemos modularizar este proceso y asegurarnos de contar con una estrategia global y coherente para resolver las dependencias principales. 208separar main una forma de separar la construcción del uso consiste en trasladar todos los aspectos de la construcción a main o a módulos invocados por main , y diseñar el resto del sistema suponiendo que todos los objetos se han creado y conectado correctamente (véase la figura 11.1). el flujo de control es fácil de seguir. la función main crea los objetos necesarios para el sistema, los pasa a la aplicación y ésta los utiliza. verá que las flechas de dependencia atraviesan la barrera entre main y la aplicación. todas van en la misma dirección, alejándose de main , lo que significa que la aplicación no tiene conocimiento de main ni del proceso de construcción. simplemente espera que todo se haya construido correctamente. figura 11.1. separación de la construcción en main() . factorías en ocasiones, la aplicación tendrá que ser responsable de la creación de un objeto. por ejemplo, en un sistema de procesamiento de pedidos, la aplicación debe crear las instancias lineitem que añadir a order . en este caso, podemos usar el patrón de factoría abstracta [51] para que la aplicación controle cuándo crear lineitem , pero mantener los detalles de dicha construcción separados del código de la aplicación (véase la figura 11.2). 209de nuevo vemos que todas las dependencias se desplazan desde main a la aplicación orderprocessing , lo que significa que la aplicación se desconecta de los detalles de creación de lineitem . esta capacidad se incluye en lineitemfactoryimplementation , en el extremo main de la línea. y sin embargo, la aplicación tiene control total sobre cuándo se crean las instancias lineitem e incluso puede proporcionar argumentos de constructor específicos de la aplicación. figura 11.2. separación de la construcción con una factoría. inyectar dependencias un potente mecanismo para separar la construcción del uso es la inyección de dependencias, la aplicación de inversión de control ( inversion of control o ioc) a la administración de dependencias [52] . la inversión de control pasa responsabilidades secundarias de un objeto a otros dedicados a ese cometido, por lo que admite el principio de responsabilidad única. en el contexto de la administración de dependencias, un objeto no debe ser responsable de instanciar dependencias, sino que debe delegar esta responsabilidad en otro mecanismo autorizado, de modo que se invierte el control. como la configuración es un aspecto global, este mecanismo autorizado suele ser la 210rutina main o un contenedor de propósito especial. las búsquedas jndi son una implementación parcial de la inyección de dependencias, en las que un objeto solicita a un servidor de directorios un servicio que coincida con un nombre concreto. myservice myservice = (myservice)(jndicontext.lookup(“nameofmyservice”)); el objeto invocador no controla el tipo de objeto devuelto (siempre que implemente la interfaz correcta, evidentemente), pero es el que resuelve la dependencia de forma activa. la verdadera inyección de dependencias va un paso más allá. la clase no hace nada directamente para resolver sus dependencias, es totalmente pasiva. por el contrario, ofrece métodos de establecimiento o argumentos de constructor (o ambos) que se usan para inyectar las dependencias. en el proceso de construcción, el contenedor de inyección de dependencias crea instancias de los objetos necesarios (normalmente bajo demanda) y usa los argumentos de constructor o métodos de establecimiento proporcionados para conectar las dependencias. los objetos dependientes empleados suelen especificarse a través de un archivo de configuración o mediante programación en un módulo de construcción de propósito especial. la estructura spring proporciona el contenedor de inyección de dependencias más conocido para java [53] . los objetos que se van a conectar se definen en un archivo de configuración xml y después se solicitan objetos concretos por nombre en código de java. veremos un ejemplo en breve. ¿y qué sucede con las virtudes de la inicialización tardía? en ocasiones es útil con la inyección de dependencias. por un lado, muchos contenedores de inyección de dependencias no crean un objeto hasta que es necesario. por otra parte, muchos de estos contenedores cuentan con mecanismos para invocar factorías o crear proxies que se pueden usar para evaluación tardía y optimizaciones similares [54] . evolucionar las ciudades nacen de pueblos, que nacen de asentamientos. inicialmente, los 211caminos son estrechos y prácticamente inexistentes, después se asfaltan y aumentan de tamaño. los pequeños edificios y solares vacíos se llenan de otros mayores que acaban convirtiéndose en rascacielos. al principio no hay servicios, electricidad, agua, alcantarillado o internet (¡vaya!). estos servicios se añaden cuando aumenta la densidad de población. este crecimiento no es fácil. cuántas veces mientras conduce por una carretera llena de baches y ve una señal de obras no se ha preguntado por qué no la hicieron más ancha desde un principio. no se podía haber hecho de otra forma. ¿quién puede justificar el gasto en una autopista de seis carriles que atraviese un pequeño pueblo como anticipación a un supuesto crecimiento? ¿quién querría una autopista así en su ciudad? conseguir sistemas perfectos a la primera es un mito. por el contrario, debemos implementar hoy, y refactorizar y ampliar mañana. es la esencia de la agilidad iterativa e incremental. el desarrollo controlado por pruebas, la refactorización y el código limpio que generan hace que funcione a nivel del código. ¿pero qué sucede en el nivel del sistema? ¿la arquitectura del sistema no requiere una planificación previa? sin duda no puede aumentar incrementalmente algo sencillo a algo complejo, ¿o sí? los sistemas de software son únicos si los comparamos con los sistemas físicos. sus arquitecturas pueden crecer incrementalmente, si mantenemos la correcta separación de los aspectos. la naturaleza efímera de los sistemas de software hace que sea posible, como veremos. primero nos centraremos en una arquitectura que no separa correctamente los aspectos. las arquitecturas ejb1 y ejb2 originales no separaban correctamente los aspectos y por tanto imponían barreras innecesarias al crecimiento orgánico. imagine un bean de entidad para una clase bank persistente. un bean de entidad es una representación en memoria de datos relacionales, es decir, una fila de una tabla. primero, debe definir una interfaz local (en proceso) o remota (mvj 212independiente), que los clientes usen. el listado 1-1 muestra una posible interfaz local: listado 11-1 una interfaz local ejb2 para el ejb bank. package com.example.banking; import java.util.collections; import javax.ejb.*; public interface banklocal extends java.ejb.ejblocalobject { string getstreetaddrl{} throws ejbexception; string getstreetaddr2{} throws ejbexception; string getcity() throws ejbexception; string getstate() throws ejbexception; string getzipcode() throws ejbexception; void setstreetaddr1(string street1) throws ejbexception; void setstreetaddr2(string street2) throws ejbexception; void setcity(string city) throws ejbexception; void setstate(string state) throws ejbexception; void setzipcode(string zip) throws ejbexception; collection getaccounts() throws ejbexception; void setaccounts(collection accounts) throws ejbexception; void addaccount(accountdto accountdto) throws ejbexception; } mostramos diversos atributos de la dirección de bank y una colección de cuentas del banco, cuyos datos se procesarán por un ejb account diferente. el listado 11-2 muestra la correspondiente clase de implementación del bean bank . listado 11-2 implementación del bean de entidad ejb2. package com.example.banking; import java.util.collections; import javax.ejb.*; public abstract class bank implements javax.ejb.entitybean { // lógica empresarial… public abstract string getstreeraddr1(); public abstract string getstreetaddr2(); public abstract string getcity(); public abstract string getstate(); public abstract string getzipcode(); public abstract void setstreetaddr1(string street1); 213public abstract void setstreetaddr2(string street2); public abstract void setcity(string city); public abstract void setstate(string state); public abstract void setzipcode(string zip); public abstract collection getaccounts(); public abstract void setaccounts(collection accounts); public void addaccount(accountpto accountdto) { initialcontext context = new initialcontext(); accounthomelocal accounthome = context.lookup(“accounthomelocal”); accountlocal account = accounthome.create(accountdto); collection accounts = getaccounts(); accounts.add(account); } // lógica del contenedor ejb public abstract void setid(integer id); public abstract integer getid(); public integer ejbcreate(integer id) {…} public void ejbpostcreate(integer id) {…} // el resto tendría que implementarse pero se deja vacío: public void setentitycontext(entitycontext ctxt) {} public void unsetentitycontext() {} public void ejbactivate() {} public void ejbpassivate() {} public void ejbload() {} public void ejbstore() {} public void ejbremove() {} } no mostramos la correspondiente interfaz localhome , básicamente una factoría usada para crear objetos, no los métodos de consulta bank que pueda añadir. por último, debemos crear uno o varios descriptores de implementación xml que especifiquen los detalles de asignación relacional de objetos en un almacén persistente, el comportamiento deseado de la transacción, limitaciones de seguridad y demás. la lógica empresarial está directamente conectada al contenedor de la aplicación ejb2. debe crear subclases de tipos de contenedor y proporcionar los métodos de ciclo vital necesarios para el contenedor. debido a esta conexión al contenedor pesado, las pruebas de unidad aisladas son complicadas. es necesario imitar el contenedor, algo difícil, o perder demasiado tiempo en la implementación de ejb y pruebas en un servidor real. la reutilización fuera de la arquitectura ejb2 es imposible, debido a esta estrecha conexión. por último, incluso la programación orientada a objetos se ve afectada. un bean no se puede heredar de otro. fíjese en la lógica para 214añadir una nueva cuenta. en bean ejb2 es habitual definir objetos de transferencia de datos ( data transfer objects o dto), estructuras sin comportamiento. esto suele generar tipos redundantes con los mismos datos y requiere código predefinido para copiar datos entre objetos. aspectos transversales la arquitectura ejb2 se acerca a la verdadera separación de aspectos en determinados aspectos. por ejemplo, los comportamientos transaccionales, de seguridad y comportamiento deseados se declaran en los descriptores de implementación, independientemente del código fuente. aspectos como la persistencia suelen cruzar los límites de objeto naturales de un dominio. por lo general intentará mantener todos sus objetos mediante la misma estrategia, por ejemplo con un determinado dbms [55] y no archivos planos, usando determinadas convenciones de nomenclatura para tablas y columnas, una semántica transaccional coherente, etc. en principio, puede razonar su estrategia de persistencia de una forma modular y encapsulada, pero en la práctica tendrá que distribuir el mismo código que implemente la estrategia de persistencia entre varios objetos. usamos el término transversales para este tipo de aspectos. de nuevo, la estructura de persistencia podría ser modular y la lógica de dominios, aislada, también. el problema es la intersección entre ambos dominios. de hecho, la forma en que la arquitectura ejb procesa persistencia, seguridad y transacciones es una programación orientada a aspectos ( aspect oriented programming o aop) [56] anticipada, un enfoque de carácter general para restaurar la modularidad en aspectos transversales. en aop, construcciones modulares denominadas aspectos especifican qué puntos del sistema deben modificar su comportamiento de forma coherente para admitir un determinado aspecto. esta especificación se realiza mediante un sucinto mecanismo de declaración o programación. si usamos la persistencia como ejemplo, podría declarar qué objetos y atributos (o patrones) deben conservarse y después delegar las tareas de persistencia a su estructura de persistencia. las modificaciones de 215comportamiento no son invasivas [57] para el código de destino. veamos tres aspectos o mecanismos similares en java. proxies de java los proxies de java son útiles en casos sencillos, como envolver invocaciones de métodos en objetos o clases concretas. sin embargo, los proxies dinámicos proporcionados en el jdk sólo funcionan con interfaces. para aplicarlos a clases, debe usar una biblioteca de manipulación de código de bytes , como cglib, asm o javassist [58] . el listado 11-3 muestra la estructura de un proxy jdk para ofrecer asistencia de persistencia a nuestra aplicación bank; únicamente abarca los métodos para obtener y establecer la lista de cuentas. listado 11-3 ejemplo de proxy del jdk. // bank.java (eliminando nombres de paquetes…) import java.utils.*; // la abstracción de un banco. public interface bank { collection<account> getaccounts(); void setaccounts(collection<accounts> accounts); } // bankimpl.java import java.utils.*; // “plain old java object” pojo que implementa la abstracción. public class bankimpl implements bank { private list<account> accounts; public collection<account> getaccounts() { return accounts; } public void setaccounts(collections<accounts> accounts) { this.accounts = new arraylist<accounts>(); for (account account: accounts) { this.accounts.add(account); } } } 216// bankproxyhandler.java import java.lang.reflect.*; import java.util.*; // «invocationhandler» necesario para la api de proxy. public class bankproxyhandler implements invocationhandler { private bank bank; public bankhandler (bank bank) { this.bank = bank; } // método definido en invocationhandler public object invoke(object proxy, method method, object[] args) throws throwable { string methodname = method.getname(); if (methodname.equals(“getaccounts”)) { bank.setaccounts(getaccountsfromdatabase()); return bank.getaccounts(); } else if (methodname.equals(“setaccounts”)) { bank.setaccounts((collection<account>) args[0]); setaccountstodatabase(bank.getaccounts()); return null; } else { … } } // muchos detalles: protected collection<account> getaccountsfromdatabase() {…} protected void setaccountstodatabase(collection<account> accounts) {…} } //en otra parte… bank bank = (bank) proxy.newproxyinstance( bank.class.getclassloader(), new class[] { bank.class }, new bankproxyhandler(new bankimpl())); definimos la interfaz bank , que envolvemos en el proxy y un pojo ( plain-old object u objeto sencillo de java), bankimpl , que implementa la lógica empresarial (encontrará más información sobre pojo en un apartado posterior). la api proxy requiere un objeto invocationhandler que invocar para implementar las invocaciones de métodos bank realizadas en el proxy. bankproxyhandler usa la api de reflexión de java para asignar las invocaciones de métodos genéricos a los métodos correspondientes de 217bankimpl , y así sucesivamente. el código es abundante y complejo, incluso para este sencillo caso [59] . el uso de una de las bibliotecas de manipulación de bytes es igualmente complicado. el volumen y la complejidad de este código son dos de los inconvenientes de los proxies . dificultan la creación de código limpio. además, los proxies no ofrecen un mecanismo para especificar puntos de ejecución globales del sistema, imprescindibles para una verdadera solución aop [60] . estructuras aop java puras afortunadamente, gran parte del código predefinido de proxy se puede procesar de forma automática mediante herramientas. los proxies se usan internamente en varias estructuras de java como spring aop y jboss aop, para implementar aspectos en java [61] . en spring, se crea la lógica empresarial en forma de pojo, específicos de su dominio. no dependen de estructuras empresariales (ni de otros dominios). por tanto, son conceptualmente más sencillos y más fáciles de probar. su relativa simplicidad garantiza que se implementen correctamente las correspondientes historias y el mantenimiento y evolución del código en historias futuras. la infraestructura necesaria de la aplicación, incluidos aspectos transversales como persistencia, transacciones, seguridad, almacenamiento en caché y recuperación ante fallos, se incorpora por medio de archivos de configuración declarativos o api. en muchos casos, se especifican aspectos de bibliotecas spring o jboss, en los que la estructura controla el uso de proxies de java o bibliotecas de código de bytes de forma transparente al usuario. estas declaraciones controlan el contenedor de inyección de dependencias, que crea instancias de los principales objetos y las conecta bajo demanda. el listado 11-4 muestra un fragmento tipo de un archivo de configuración de spring v2.5, app.xml [62] . 218listado 11-4 archivo de configuración de spring 2.x <beans> … <bean id=“appdatasource” class=“org.apache.commons.dbcp.basicdatasource” destroy-method=“close” p:driverclassname=“com.mysql.jdbc.driver” p:url=“jdbc:mysql://localhost:3306/mydb” p:username=“me”/> <bean id=“bankdataaccessobject” class=“com.example.banking.persistence.bankdataaccessobject” p:datasource-ref=“appdatasource”/> <bean id=“bank” class=“com.example.banking.model.bank” p:dataaccessobject-ref=“bankdataaccessobject”/> … </beans> cada bean es como una parte de una muñeca rusa anidada, con un objeto de domino de un proxy bank (envuelto) por un objeto de acceso a datos ( data accessor object , dao), que también se procesa a través de un proxy por medio de un origen de datos de controlador jdbc (véase la figura 11.3). figura 11.3. la “muñeca rusa” de elementos de decoración. el cliente cree que invoca getaccounts() en un objeto bank , pero en realidad se comunica con el objeto decorator [63] más externo de un grupo, un objeto que amplía el comportamiento básico del pojo bank . podríamos añadir otros objetos de decoración para transacciones, almacenamiento en caché y demás. en la aplicación, bastan unas líneas para solicitar al contenedor de id los objetos de nivel superior del sistema, como se especifica en el archivo xml. 219xmlbeanfactory bf = new xmlbeanfactory(new classpathresource(“app.xml”, getclass())); bank bank = (bank) bf.getbean(“bank”); como apenas se necesitan líneas de código java específico de spring, la aplicación se desconecta casi por completo de spring y desaparecen los problemas de conexión de sistemas como ejb2. aunque xml puede ser difícil de leer [64] , la directiva especificada en estos archivos de configuración es más sencilla que la complicada lógica de proxy y aspectos oculta a la vista y creada de forma automática. es una arquitectura tan atractiva que sistemas como spring modificaron totalmente el estándar ejb para la versión 3. ejb3 sigue el modelo de spring de aspectos transversales admitidos mediante declaraciones con archivos de configuración xml y/o anotaciones de java 5. el listado 11-5 muestra nuestro objeto bank reescrito en ejb3 [65] . listado 11-5 un ejb bank ejb3. package com.example.banking.model; import javax.persistence; import java.util.arraylist; import java.util.collection; @entity @table(name = “banks”) public class bank implements java.io.serializable { @id @generatedvalue(strategy=generationtype.auto) private int id; @embeddable // un objeto en línea en la fila db de bank public class address { protected string streetaddr1; protected string streetaddr2; protected string city; protected string state; protected string zipcode; } @embedded private address address; @onetomany (cascade = cascadetype.all, fetch = fetchtype.eager, mappedby=“bank”) private collection<account> accounts = new arraylist<account>(); 220public int getid() { return id; } public void setid(int id) { this.id = id; } public void addaccount(account account) { account.setbank(this); accounts.add(account); } public collection<account> getaccounts() { return accounts; } public void setaccounts(collection<account> accounts) { this.accounts = accounts; } } este código es mucho más limpio que el código ejb2 original. se conservan algunos detalles de entidades, en las anotaciones. sin embargo, como no hay información fuera de las anotaciones, el código es limpio y fácil de probar, mantener y demás. parte de la información de persistencia de las anotaciones se puede cambiar a descriptores de implementación xml si es necesario, dejando un pojo puro. si los detalles de asignación de persistencia no cambian con frecuencia, muchos equipos pueden optar por mantener las anotaciones pero con menos obstáculos que si usaran ejb2. aspectos de aspectj por último, la herramienta más completa de separación a través de aspectos es el lenguaje aspectj [66] , una extensión de java que ofrece compatibilidad de primer nivel para aspectos como construcciones de modularidad. los enfoques puros de java proporcionados por spring aop y jboss aop son suficientes en el 80-90 por 100 de los casos en los que los aspectos son útiles. sin embargo, aspectj ofrece un conjunto de herramientas avanzadas y completas para la separación de aspectos. el inconveniente de aspectj es la necesidad de adoptar nuevas herramientas y aprender nuevas construcciones 221del lenguaje. los problemas de adopción se han mitigado parcialmente gracias a la introducción de un formato de anotación de aspectj, en el que se usan anotaciones de java 5 para definir aspectos con código puro de java. además, la estructura spring dispone de funciones que facilitan la incorporación de aspectos basados en anotaciones en un equipo con experiencia limitada con aspectj. el análisis completo de aspectj supera los objetivos de este libro. si necesita más información al respecto, consulte [aspectj], [colyer] y [spring]. pruebas de unidad de la arquitectura del sistema la separación a través de enfoques similares a aspectos no se puede menospreciar. si puede crear la lógica de dominios de su aplicación mediante pojo, sin conexión con los aspectos arquitectónicos a nivel del código, entonces se podrá probar realmente la arquitectura. puede evolucionar de simple a sofisticado, de acuerdo a las necesidades, adoptando nuevas tecnologías bajo demanda. no es necesario realizar un buen diseño por adelantado (big design up front [67] , bduf). de hecho, bduf puede ser negativo ya que impide la adaptación al cambio, debido a la resistencia fisiológica a descartar esfuerzos previos y a la forma en que las decisiones arquitectónicas influyen en la concepción posterior del diseño. los arquitectos deben realizar bduf ya que no resulta factible aplicar cambios arquitectónicos radicales a una estructura física una vez avanzada la construcción [68] . aunque el software se rige por una física propia [69] , es económicamente factible realizar cambios radicales si la estructura del software separa sus aspectos de forma eficaz. esto significa que podemos iniciar un proyecto de software con una arquitectura simple pero bien desconectada, y ofrecer historias funcionales de forma rápida, para después aumentar la infraestructura. algunos de los principales sitios web del mundo han alcanzado una gran disponibilidad y rendimiento por medio de sofisticadas técnicas de almacenamiento en caché, seguridad, virtualización y demás, todo ello de forma eficaz y flexible ya que los diseños mínimamente conectados son adecuadamente simples en cada 222nivel de abstracción y ámbito. evidentemente, no quiere decir que acometamos los proyectos sin timón. debemos tener expectativas del ámbito general, objetivos y un programa, así como la estructura general del sistema resultante. sin embargo, debemos mantener la capacidad de cambiar de rumbo en respuesta a las circunstancias. la arquitectura ejb inicial es una de las api conocidas con un exceso de ingeniería y que compromete la separación de aspectos. incluso las api bien diseñadas pueden ser excesivas cuando no resultan necesarias. una api correcta debe desaparecer de la vista en la mayoría de los casos, para que el equipo dedique sus esfuerzos creativos a las historias implementadas. en caso contrario, las limitaciones arquitectónicas impedirán la entrega eficaz de un valor óptimo para el cliente. para recapitular: una arquitectura de sistema óptima se compone de dominios de aspectos modularizados, cada uno implementado con pojo. los distintos dominios se integran mediante aspectos o herramientas similares mínimamente invasivas. al igual que en el código, en esta arquitectura se pueden realizar pruebas. optimizar la toma de decisiones la modularidad y separación de aspectos permite la descentralización de la administración y la toma de decisiones. en un sistema suficientemente amplio, ya sea una ciudad o un proyecto de software , no debe haber una sola persona que adopte todas las decisiones. sabemos que conviene delegar las responsabilidades en las personas más cualificadas. solemos olvidar que también conviene posponer decisiones hasta el último momento. no es falta de responsabilidad; nos permite tomar decisiones con la mejor información posible. una decisión prematura siempre es subjetiva. si decidimos demasiado pronto, tendremos menos información del cliente, reflexión mental sobre el proyecto y experiencia con las opciones de implementación. 223la agilidad que proporciona un sistema pojo con aspectos modularizados nos permite adoptar decisiones óptimas a tiempo, basadas en los conocimientos más recientes. además, se reduce la complejidad de estas decisiones. usar estándares cuando añadan un valor demostrable la construcción de edificios es una maravilla para la vista debido al ritmo empleado (incluso en invierno) y los extraordinarios diseños posibles gracias a la tecnología actual. la construcción es un sector maduro con elementos, métodos y estándares optimizados que han evolucionado bajo presión durante siglos. muchos equipos usaron la arquitectura ejb2 por ser un estándar, aunque hubiera bastado con diseños más ligeros y sencillos. he visto equipos obsesionados con estándares de moda y que se olvidaron de implementar el valor para sus clientes. los estándares facilitan la reutilización de ideas y componentes, reclutan individuos con experiencia, encapsulan buenas ideas y conectan componentes. sin embargo, el proceso de creación de estándares puede tardar demasiado para el sector, y algunos pierden el contacto con las verdaderas necesidades de aquello para los que están dirigidos. los sistemas necesitan lenguajes específicos del dominio la construcción de edificios, como muchos dominios, ha desarrollado un rico lenguaje con vocabularios, frases y patrones [70] que comunican información esencial de forma clara y concisa. en el mundo del software , ha renacido el interés por crear lenguajes específicos del dominio ( domain-specific languages o dsl) [71] , pequeños lenguajes independientes de creación de secuencias de comandos o api de lenguajes estándar que permiten crear 224código que se lea de una forma estructurada, como lo escribiría un experto del dominio. un buen dsl minimiza el vacío de comunicación entre un concepto de dominio y el código que lo implementa, al igual que las prácticas ágiles optimizan la comunicación entre un equipo y los accionistas del proyecto. si tiene que implementar la lógica de dominios en el mismo lenguaje usado por un experto del dominio, hay menos riesgo de traducir incorrectamente el dominio en la implementación. los dsl, si se usan de forma eficaz, aumentan el nivel de abstracción por encima del código y los patrones de diseño. permiten al desarrollador revelar la intención del código en el nivel de abstracción adecuado. los lenguajes específicos del dominio permiten expresar como pojo todos los niveles de abstracción y todos los dominios de la aplicación, desde directivas de nivel superior a los detalles más mínimos. conclusión los sistemas también deben ser limpios. una arquitectura invasiva afecta a la lógica de dominios y a la agilidad. si la lógica de dominios se ve afectada, la calidad se resiente, ya que los errores se ocultan y las historias son más difíciles de implementar. si la agilidad se ve comprometida, la productividad sufre y las ventajas de tdd se pierden. en todos los niveles de abstracción, los objetivos deben ser claros. esto sólo sucede si crea pojo y usa mecanismos similares a aspectos para incorporar otros aspectos de implementación de forma no invasiva. independientemente de que diseñe sistemas o módulos individuales, no olvide usar los elementos más sencillos que funcionen. bibliografía [alexander] : christopher alexander, a timeless way of building , oxford university press, new york, 1979. 225[aosd] : puerto de desarrollo de software orientado a aspectos, http://aosd.net. [asm] : página de asm, http://asm.objectweb.org/. [aspectj] : http: //eclipse.org/aspectj. [cglib] : biblioteca de generación de código, http://cglib.sourceforge.net/. [colyer] : adrian colyer, andy clement, george hurley, mathew webster, eclipse aspectj , person education, inc., upper saddle river, nj, 2005. [dsl] : lenguaje de programación específico del dominio, http://es.wikipedia.org/wiki/lenguaje_espec%c3%adfico_del_dominio. [fowler] : inversión de contenedores de control y el patrón de inyección de dependencias (http://martinfowler.com/articles/injection.html). [goetz] : brian goetz, java theory and practice: decorating with dynamic proxies , http://www.ibm.com/developerworks/java/library/j- jtp08305.html. [javassist] : página de javassist, http://www.csg.is.titech.ac.jp/chiba/javassist/. [jboss] : página de jboss, http: //jboss.org. [jmock] : jmock: una biblioteca de objetos mock ligeros para java, http://jmock.org. [kolence] : kenneth w. kolence, software physics and computer performance measurements, proceedings of the acm annual conference-volume 2, boston, massachusetts, pp. 1024-1040,1972. [spring] : the spring framework , http://www.springframework.org. [mezzaros07] : xunit patterns , gerard mezzaros, addison-wesley, 2007. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 22612 emergencia con jeff langr limpieza a través de diseños emergentes 227imagine que existieran cuatro sencillas reglas para crear diseños de calidad. imagine que siguiéndolas accediera a la estructura y al diseño de su código y facilitara la aplicación de principios como srp y dip. imagine que estas cuatro reglas facilitaran la emergencia de diseños de calidad. muchos consideramos que las cuatro reglas de kent beck de diseño sencillo [72] son fundamentales para crear un software bien diseñado. según kent, un diseño es sencillo si cumple estas cuatro reglas: ejecuta todas las pruebas. no contiene duplicados. expresa la intención del programador. minimiza el número de clases y métodos. describiremos estas reglas en orden de importancia. primera regla del diseño sencillo: ejecutar todas las pruebas en primer lugar, un diseño debe generar un sistema que actúe de la forma prevista. un sistema puede tener un diseño perfecto sobre el papel pero si no existe una forma sencilla de comprobar que realmente funciona de la forma esperada, el esfuerzo sobre el papel es cuestionable. un sistema minuciosamente probado y que supera todas las pruebas en todo momento se denomina sistema testable. es una afirmación obvia, pero importante. los sistemas que no se pueden probar no se pueden verificar, y un sistema que no se puede verificar no debe implementarse. afortunadamente, crear sistemas testables hace que diseñemos clases de tamaño reducido y un solo cometido. resulta más sencillo probar clases que cumplen el srp. cuantas más pruebas diseñemos, más nos acercaremos a elementos más fáciles de probar. por lo tanto, hacer que nuestro sistema se pueda probar nos ayuda a crear mejores diseños. las conexiones rígidas dificultan la creación de pruebas. del mismo modo, cuantas más pruebas creemos, más usaremos principios como dip y 228herramientas con inyección de dependencias, interfaces y abstracción para minimizar dichas conexiones. nuestros diseños mejorarán todavía más. en especial, seguir una sencilla regla que afirme que debemos realizar pruebas y ejecutarlas continuamente afecta el cumplimiento por parte de nuestro sistema de los principales objetivos de la programación orientada a objetos de baja conexión y elevada cohesión. la creación de pruebas conduce a obtener mejores diseños. reglas 2 a 4 del diseño sencillo: refactorizar una vez creadas las pruebas, debemos mantener limpio el código y las clases. para ello, refactorizamos el código progresivamente. tras añadir unas líneas, nos detenemos y reflejamos el nuevo diseño. ¿ha empeorado? en caso afirmativo, lo limpiamos y ejecutamos las pruebas para comprobar que no hay elementos afectados. la presencia de las pruebas hace que perdamos el miedo a limpiar el código y que resulte dañado . en la fase de refactorización, podemos aplicar todos los aspectos del diseño de software correcto. podemos aumentar la cohesión, reducir las conexiones, separar las preocupaciones, modularizar aspectos del sistema, reducir el tamaño de funciones y clases, elegir nombres más adecuados, etc. aquí también aplicamos las tres últimas reglas del diseño correcto: eliminar duplicados, garantizar la capacidad de expresión y minimizar el número de clases y métodos. eliminar duplicados los duplicados son los mayores enemigos de un sistema bien diseñado. suponen un esfuerzo adicional, riesgos añadidos y una complejidad a mayores innecesaria. los duplicados se manifiestan de diversas formas. las líneas de código similar pueden modificarse para que parezcan refactorizadas, y hay otras formas de duplicación como la de implementación. por ejemplo, podríamos tener dos métodos en una clase de colección: 229int size() {} boolean isempty() {} podríamos tener implementaciones separadas para cada método. el método isempty podría controlar un valor booleano y size un contador, o podemos eliminar la duplicación y vincular isempty a la definición de size : boolean isempty() { return 0 == size(); } la creación de un sistema limpio requiere la eliminación de duplicados, aunque sean unas cuantas líneas de código. fíjese en el siguiente ejemplo: public void scaletoonedimension { float desireddimension, float imagedimension) { if (math.abs(desireddimension - imagedimension) < errorthreshold) return; float scalingfactor = desireddimension / imagedimension; scalingfactor = (float)(math.floor(scalingfactor * 100) * 0.01f); renderedop newimage = imageutilities.getscaledimage( image, scalingfactor, scalingfactor); image.dispose(); system.gc(); image = newimage; } public synchronized void rotate(int degrees) { renderedop newimage = imageutilities.getrotatedimage( image, degrees); image.dispose(); system.gc(); image = newimage; } para mantener limpio este sistema, debemos eliminar la pequeña cantidad de duplicación entre los métodos scaletoonedimension y rotate : public void scaletoonedimension ( float desireddimension, float imagedimension) { if (math.abs(desireddimension - imagedimension) < errorthreshold) return; float scalingfactor = desireddimension / imagedimension; scalingfactor = (float)(math.floor(scalingfactor * 100) * 0.01f); replaceimage(imageutilities.getscaledimage( image, scalingfactor, scalingfactor)); } public synchronized void rotate (int degrees) { replaceimage(imageutilities.getrotatedimage(image, degrees)); } private void replaceimage(renderedop newimage) ( 230image.dispose(); system.gc(); image = newimage; } al extraer a este reducido nivel, comenzamos a detectar incumplimientos de srp. por ello, podríamos cambiar un nuevo método extraído a otra clase. esto aumenta su visibilidad. otro miembro del equipo puede ver la necesidad de volver a extraer el nuevo método y usarlo en otro contexto diferente. esta reutilización mínima puede reducir considerablemente la complejidad del sistema. saber cómo lograrlo es fundamental para alcanzar la reutilización a gran escala. el patrón método de plantilla [73] es una técnica muy utilizada para eliminar duplicados de nivel superior. por ejemplo: public class vacationpolicy { public void accrueusdivisionvacation() { // código para calcular las vacaciones en función de las horas trabajadas //… // código para garantizar que las vacaciones cumplen los mínimos legales //… // código para aplicar vacation al registro payroll //… } public void accrueeudivisionvacation() { // código para calcular las vacaciones en función de las horas trabajadas //… // código para garantizar que las vacaciones cumplen los mínimos legales //… // código para aplicar vacation al registro payroll //… } } el código entre accrueusdivisionvacation y accrueeuropeandivisionvacation es prácticamente idéntico, a excepción del cálculo de mínimos legales. esa parte del algoritmo cambia en función del tipo de empleado. podemos eliminar la duplicación evidente si aplicamos el patrón de método de plantilla : abstract public class vacationpolicy { public void accruevacation() { calculatebasevacationhours(); alterforlegalminimums(); applytopayroll(); } 231private void calculatebasevacationhours() { /* … */ }; abstract protected void alterforlegalminimums(); private void applytopayroll(); { /* … */ }; } public class usvacationpolicy extends vacationpolicy { @override protected void alterforlegalminimums() { // lógica específica de ee.uu. } } public class euvacationpolicy extends vacationpolicy { @override protected void alterforlegalminimums() { // lógica específica de la ue. } } las subclases ocupan el vacío generado en el algoritmo accruevacation y solamente proporcionan los datos que no están duplicados. expresividad muchos tenemos experiencia con código enrevesado. muchos lo hemos creado. es fácil crear código que entendamos, ya que durante su creación nos centramos en comprender el problema que intentamos resolver. los encargados de mantener el código no lo comprenderán de la misma forma. el principal coste de un proyecto de software es su mantenimiento a largo plazo. para minimizar los posibles defectos al realizar cambios, es fundamental que comprendamos el funcionamiento del sistema. al aumentar la complejidad de los sistemas, el programador necesita más tiempo para entenderlo y aumentan las posibilidades de errores. por tanto, el código debe expresar con claridad la intención de su autor. cuando más claro sea el código, menos tiempo perderán otros en intentar comprenderlo. esto reduce los defectos y el coste de mantenimiento. puede expresarse si elige nombres adecuados. el objetivo es ver el nombre de una clase y función, y que sus responsabilidades no nos sorprendan. también puede expresarse si reduce el tamaño de funciones y clases. al hacerlo, resulta más sencillo asignarles nombres, crearlas y comprenderlas. 232otra forma de expresarse es usar una nomenclatura estándar. los patrones de diseño, por ejemplo, se basan en la comunicación y en la capacidad de expresión. al usar los nombres de patrones estándar, como command o visitor , en los nombres de las clases que implementan dichos patrones puede describir sucintamente su diseño a otros programadores. las pruebas de unidad bien escritas también son expresivas. uno de los principales objetivos de una prueba es servir de documentación mediante ejemplos. los que lean las pruebas deben entender con facilidad para qué sirve una clase. pero la forma más importante de ser expresivo es la práctica. a menudo, conseguimos que el código funcione y pasamos al siguiente problema sin detenernos en facilitar la lectura del código para otros. no olvide que seguramente sea el próximo que lea el código. por tanto, afronte su creación con orgullo. dedique tiempo a sus funciones y clases. seleccione nombres mejores, divida las funciones extensas en otras más reducidas y cuide su obra. el cuidado es un recurso precioso. clases y métodos mínimos incluso conceptos tan básicos como la eliminación de código duplicado, la expresividad del código y srp pueden exagerarse. en un esfuerzo por reducir el tamaño de clases y métodos, podemos crear demasiadas clases y métodos reducidos. esta regla también sugiere minimizar la cantidad de funciones y clases. una gran cantidad de clases y métodos suele indicar un dogmatismo sin sentido. imagine un estándar de código que insista en la creación de una interfaz para todas las clases, o a programadores que insisten en qué campos y comportamientos siempre deben separarse en clases de datos y clases de comportamiento. este dogma debe evitarse y cambiarse por un enfoque más pragmático. nuestro objetivo es reducir el tamaño general del sistema además del tamaño de clases y funciones, pero recuerde que esta regla es la de menor 233prioridad de las cuatro. por ello, aunque sea importante reducir la cantidad de clases y funciones, es más importante contar con pruebas, eliminar duplicados y expresarse correctamente. conclusión ¿existen prácticas sencillas que puedan reemplazar a la experiencia? por supuesto que no. sin embargo, las prácticas descritas en este capítulo y en el libro son una forma cristalizada de décadas de experiencia de muchos autores. la práctica del diseño correcto anima y permite a los programadores adoptar principios y patrones que en caso contrario tardarían años en aprender. bibliografía [xpe] : extreme programming explained: embrace change , kent beck, addison wesley, 1999. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 23413 concurrencia por brett l. schuchert 235“los objetos son abstracciones de procesamiento. los subprocesos son abstracciones de programaciones”. —james o. coplien [74] la creación de programas concurrentes limpios es complicada, muy complicada. es mucho más sencillo crear código que se ejecute en un mismo proceso. también es fácil crear código de subprocesamiento múltiple que parezca correcto en la superficie pero que esté dañado a niveles más profundos. este código funciona correctamente hasta que el sistema se somete a determinadas presiones. en este capítulo analizaremos la necesidad de la programación concurrente y sus dificultades. tras ello, presentaremos diversas recomendaciones para superar dichas dificultades y crear código concurrente limpio. por último, finalizaremos con los problemas relacionados con la prueba de código concurrente. la concurrencia limpia es un tema complejo, merecedor de un libro propio. aquí, intentaremos ofrecer una visión general, que después ampliaremos en el apéndice a. si simplemente tiene curiosidad por el tema, le bastará con este capítulo. si necesita entender la concurrencia a un nivel más profundo, consulte también el apéndice. ¿por qué concurrencia? la concurrencia es una estrategia de desvinculación. nos permite desvincular lo que se hace de dónde se hace. en aplicación de un solo proceso, el qué y el cuándo están tan firmemente vinculados que el estado de la aplicación se puede determinar analizando la huella de la pila. un programador que depure este tipo de sistemas puede definir un punto de interrupción (o varios) y saber el estado de la aplicación en función del punto al que se llegue. la desvinculación del qué del dónde puede mejorar considerablemente el rendimiento y la estructura de una aplicación. desde un punto de vista estructural, la aplicación parece una serie de equipos colaboradores y no un gran bucle principal. esto puede hacer que el sistema sea más fácil de 236comprender y ofrece diversas formas de separar las preocupaciones. pongamos por caso el modelo servlet estándar de aplicaciones web. estos sistemas se ejecutan bajo un contenedor web o ejb que gestiona parcialmente la concurrencia. los servlet se ejecutan de forma asíncrona cuando se reciben solicitudes web. el programador de los servlet no tiene que gestionar todas las solicitudes entrantes. en principio, la ejecución de cada servlet vive en un mundo propio y se desvincula del resto. evidentemente, si fuera tan sencillo, no necesitaríamos este capítulo. de hecho, la desvinculación proporcionada por los contenedores web dista mucho de ser perfecta. los programadores de servlet deben asegurarse de que sus programas sean correctos. no obstante, las ventajas estructurales del modelo de servlet son significativas. pero la estructura no es el único motivo para adoptar la concurrencia. algunos sistemas tienen limitaciones de tiempo de respuesta y producción que requieren soluciones concurrentes manuales. imagine un dispositivo para añadir información, con un solo proceso, que obtiene datos de distintos sitios web y los combina en un resumen diario. al tener un solo proceso, accede por turnos a cada sitio web y siempre termina uno antes de comenzar el siguiente. su recorrido diario debe ejecutarse en menos de 24 horas. sin embargo, al añadir nuevos sitios web, el tiempo aumenta hasta necesitarse más de 24 horas para recopilar todos los datos. el único proceso implica una prolongada espera para completar la e/s. podríamos mejorar el rendimiento con ayuda de un algoritmo de subprocesamiento múltiple que visite más de un sitio web por vez. imagine un sistema que procesa un usuario por vez y sólo requiere un segundo por cada uno. su capacidad de respuesta es válida para un número reducido de usuarios pero si aumenta, también lo hace el tiempo de respuesta del sistema. ningún usuario querrá esperar a otros 150. podríamos mejorar el tiempo de respuesta de este sistema procesando varios usuarios a la vez. imagine un sistema que interprete grandes conjuntos de datos pero que sólo ofrezca una solución completa tras procesarlos todos. se podría procesar cada conjunto de datos en un equipo distinto, para poder procesarlos todos en paralelo. 237mitos e imprecisiones también existen motivos evidentes para adoptar la concurrencia aunque, como indicamos antes, sea complicada. si no presta la suficiente atención, pueden darse casos desagradables. veamos los mitos e imprecisiones más habituales: la concurrencia siempre mejora el rendimiento : en ocasiones lo hace pero sólo cuando se puede compartir tiempo entre varios procesos o procesadores. ninguna situación es trivial. el diseño no cambia al crear programas concurrentes : de hecho, el diseño de un algoritmo concurrente puede ser muy distinto al de un sistema de un solo proceso. la desvinculación entre el qué y el cuándo suele tener un efecto importante en la estructura del sistema. no es importante entender los problemas de concurrencia al trabajar con un contenedor web o ejb : en realidad, debe saber lo que hace su contenedor y protegerlo de problemas de actualizaciones concurrentes y bloqueo, como veremos después. veamos otros aspectos relacionados con la creación de software concurrente: la concurrencia genera cierta sobrecarga , tanto en rendimiento como en la creación de código adicional. la concurrencia correcta es compleja , incluso para problemas sencillos. los errores de concurrencia no se suelen repetir , de modo que se ignoran [75] en lugar de considerarse verdaderos problemas. la concurrencia suele acarrear un cambio fundamental de la estrategia de diseño . desafíos ¿qué hace que la programación concurrente sea tan complicada? fíjese en la 238siguiente clase: public class x { private int lastidused; public int getnextid() { return ++lastidused; } } imagine que creamos una instancia x , establecemos el campo lastidused en 42 y después compartimos la instancia entre dos procesos. imagine ahora que esos dos procesos invocan el método getnextid() ; hay tres resultados posibles: el primer proceso obtiene el valor 43, el segundo el valor 44 y lastidused es 44. el primer proceso obtiene el valor 44, el segundo el valor 43 y lastidused es 44. el primer proceso obtiene el valor 43, el segundo el valor 43 y lastidused es 43. el sorprendente tercer resultado [76] se produce cuando los dos procesos coinciden. se debe a que pueden adoptar varias rutas posibles en una línea de código de java y algunas generan resultados incorrectos. ¿cuántas rutas distintas existen? para responder, debemos entender lo que hace el compilador justo a tiempo con el código de bytes generado, y lo que el modelo de memoria de java considera atómico. una rápida respuesta, con el código de bytes generado, es que existen 12 870 rutas de ejecución diferentes [77] para los dos procesos ejecutados en el método getnextid . si el tipo de lastidused cambia de int a long , el número de rutas asciende a 2 704 156. evidentemente, muchas generan resultados válidos. el problema es que algunas no lo hacen . principios de defensa de la concurrencia a continuación le mostramos una serie de principios y técnicas para proteger 239a sus sistemas de los problemas del código concurrente. principio de responsabilidad única (srp) srp [78] establece que un método, clase o componente sólo debe tener un motivo para cambiar. el diseño de concurrencia es lo bastante complejo como para ser un motivo de cambio con derecho propio y, por tanto, debe separarse del resto del código. desafortunadamente, es habitual incrustar los detalles de la implementación de concurrencia directamente en otro código de producción. tenga en cuenta los siguientes aspectos: el código relacionado con la concurrencia tiene su propio ciclo de desarrollo , cambios y ajustes. el código relacionado con la concurrencia tiene sus propios desafíos , diferentes y más complicados, que los del código no relacionado con la concurrencia. el número de formas en las que el código incorrecto basado en la concurrencia puede fallar lo complica ya de por sí, sin la carga añadida del código de aplicación circundante. recomendación : separe el código de concurrencia del resto del código [79] . corolario: limitar el ámbito de los datos como hemos visto, dos procesos que modifican el mismo campo u objeto compartido pueden interferir entre ellos y provocar un comportamiento inesperado. una solución consiste en usar la palabra clave synchronized para proteger una sección importante del código que use el objeto compartido, aunque conviene limitar la cantidad de estas secciones. cuantos más puntos actualicen datos compartidos, es más probable que: 240se olvide de proteger uno o varios de esos puntos, y se dañe el código que modifica los datos compartidos. se duplique el esfuerzo necesario para garantizar la protección de todos los elementos (incumplimiento de dry [80] ). resulta complicado determinar el origen de los fallos, que por naturaleza son difíciles de detectar. recomendación : encapsule los datos y limite el acceso a los datos compartidos . corolario: usar copias de datos una forma de evitar datos compartidos es no compartirlos. en algunos casos se pueden copiar objetos y procesarlos como si fueran de sólo lectura. en otros, se pueden copiar objetos, recopilar los resultados de varios procesos en las copias y después combinar los resultados en un mismo proceso. si existe una forma sencilla de evitar los objetos compartidos, el código resultante tendrá menos problemas. puede que le preocupe el coste de la creación de objetos adicionales. merece la pena experimentar y comprobar si es un problema real. no obstante, si el uso de copias de objetos permite al código evitar la sincronización, las ventajas de evitar el bloque compensan la creación adicional y la sobrecarga de la recolección de elementos sin usar. corolario: los procesos deben ser independientes pruebe a crear el código de sus procesos de forma que cada uno sea independiente y no comparta datos con otros. cada uno procesa una solicitud cliente y todos los datos necesarios provienen de un origen sin compartir y se almacenan como variables locales. de este modo, los procesos se comportan como si fueran los únicos del mundo y no existieran requisitos de sincronización. por ejemplo, las subclases de httpservlet reciben toda su información como parámetros pasados en los métodos doget y dopost . esto hace que cada servlet actúe como si dispusiera de su propio equipo. mientras 241el código del servlet sólo use variables locales, es imposible que cause problemas de sincronización. evidentemente, muchas aplicaciones que usan servlet se topan con recursos compartidos como conexiones de base de datos. recomendación : intente dividir los datos en subconjuntos independientes que se puedan procesar en procesos independientes, posiblemente en distintos procesadores . conocer las bibliotecas java 5 ofrece muchas mejoras para el desarrollo concurrente con respecto a versiones anteriores. existen diversos aspectos que tener en cuenta a la hora de crear código de procesos en java 5: usar las colecciones compatibles con procesos proporcionadas. usar la estructura de ejecución de tareas no relacionadas. usar soluciones antibloqueo siempre que sea posible. varias clases de bibliotecas no son compatibles con procesos. colecciones compatibles con procesos en los albores de java, doug lea escribió el conocido libro [81]  concurrent programming in java . al mismo tiempo, desarrolló varias colecciones compatibles con procesos, que posteriormente pasaron a formar parte del jdk en el paquete java.util.concurrent . las colecciones de dicho paquete son compatibles con casos de procesos múltiples y tienen un rendimiento adecuado. de hecho, la implementación concurrenthashmap tiene mejor rendimiento que hashmap en la mayoría de los casos. también permite lecturas y escrituras simultáneas, y dispone de métodos que admiten operaciones de composición habituales que en caso contrario serian incompatibles con subprocesos. si java 5 es su entorno de desarrollo, comience con concurrenthashmap . 242existen otras clases añadidas para admitir diseño avanzado de concurrencia. veamos algunos ejemplos: reentrantlock bloqueo que se puede adquirir en un método y liberar en otro. semaphore una implementación del clásico semáforo, un bloqueo con un contador. countdownlatch bloqueo que espera un número de eventos antes de liberar todos los subprocesos retenidos. de este modo todos tienen la misma oportunidad de iniciarse al mismo tiempo. recomendación : revise las clases de las que disponga. en el caso de java, debe familiarizarse con java.util.concurrent, java.util.concurrent.atomic y java.util.concurrent.locks . conocer los modelos de ejecución existen diversas formas de dividir el comportamiento de una aplicación concurrente. para describirlos debe conocer ciertas definiciones básicas. recursos vinculados recursos de tamaño o número fijo usados en un entorno concurrente, como por ejemplo conexiones de base de datos y búfer de lectura/escritura de tamaño fijo. exclusión mutua sólo un proceso puede acceder a datos o a un recurso compartido por vez. inanición se impide que un proceso o grupo de procesos continúen demasiado tiempo o indefinidamente. por ejemplo, si permite primero la ejecución de los procesos más rápidos, los que se ejecutan durante más tiempo pueden perecer de inanición si los primeros no terminan nunca. bloqueo dos o más procesos esperan a que ambos terminen. cada proceso tiene un recurso y ninguno puede terminar hasta que obtenga el otro recurso. bloqueo procesos bloqueados, intentando realizar su labor pero 243activo estorbándose unos a otros. por motivos de resonancia, los procesos siguen intentando avanzar pero no pueden durante demasiado tiempo, o de forma indefinida. tras mostrar estas definiciones, ya podemos describir los distintos modelos de ejecución empleados en la programación concurrente. productor-consumidor [82] uno o varios procesos productores crean trabajo y lo añaden a un búfer o a una cola. uno o varios procesos consumidores adquieren dicho trabajo de la cola y lo completan. la cola entre productores y consumidores es un recurso vinculado, lo que significa que los productores deben esperar a que se libere espacio en la cola antes de escribir y los consumidores deben esperar hasta que haya algo que consumir en la cola. la coordinación entre productores y consumidores a través de la cola hace que unos emitan señales a otros. los productores escriben en la cola e indican que ya no está vacía. los consumidores leen de la cola e indican que ya no está llena. ambos esperan la notificación para poder continuar. lectores-escritores [83] cuando un recurso compartido actúa básicamente como fuente de información para lectores pero ocasionalmente se actualiza por parte de escritores, la producción es un problema. el énfasis de la producción puede provocar la inanición y la acumulación de información caducada. las actualizaciones pueden afectar a la producción. la coordinación de lectores para que no lean algo que un escritor está actualizando y viceversa es complicada. los escritores tienden a bloquear a los lectores durante periodos prolongados, lo que genera problemas de producción. el desafío consiste en equilibrar las necesidades de ambos para satisfacer un funcionamiento correcto, proporcionar una producción razonable y evitar la inanición. una sencilla estrategia hace que los escritores esperen hasta que deje de haber lectores antes de realizar una actualización. si hay lectores 244continuos, los escritores perecen de inanición. por otra parte, si hay escritores frecuentes y se les asigna prioridad, la producción se ve afectada. determinar el equilibrio y evitar problemas de actualización concurrente es el objetivo de este modelo. la cena de los filósofos [84] imagine varios filósofos sentados alrededor de una mesa redonda. a la izquierda de cada uno hay un tenedor. en el centro de la mesa, una gran fuente de espaguetis. los filósofos pasan el tiempo pensando a menos que tengan hambre. cuando tienen hambre, utilizan los tenedores situados a ambos lados para comer. no pueden comer a menos que tengan dos tenedores. si el filósofo situado a la derecha o izquierda de otros ya tiene uno de los tenedores que necesita, tendrá que esperar a que termine de comer y deje los tenedores. cuando un filósofo termina de comer, vuelve a colocar los tenedores en la mesa hasta que vuelve a tener hambre. cambie los filósofos por procesos y los tenedores por recursos y tendrá un problema habitual en muchas aplicaciones en las que los procesos compiten por recursos. a menos que se diseñen correctamente, los sistemas que compiten de esta forma experimentan problemas de bloqueo, bloqueo mutuo, producción y degradación de la eficacia. la mayoría de problemas de concurrencia que encontrará serán alguna variante de éstos. analice los algoritmos y cree soluciones propias para estar preparado cuando surjan problemas de concurrencia. recomendación : aprenda estos algoritmos básicos y comprenda sus soluciones . dependencias entre métodos sincronizados las dependencias entre métodos sincronizados generan sutiles errores en el código concurrente. java cuenta con synchronized , que protege métodos individuales. no obstante, si hay más de un método sincronizado en la misma clase compartida, puede que su sistema sea incorrecto [85] . 245recomendación : evite usar más de un método en un objeto compartido . en ocasiones tendrá que usar más de un método en un objeto compartido. en ese caso, hay tres formas de crear código correcto: bloqueo basado en clientes : el cliente debe bloquear al servidor antes de invocar el primer método y asegurarse de que el alcance del bloque incluye el código que invoque el último método. bloqueo basado en servidores : debe crear un método en el servidor que bloquee el servidor, invoque todos los métodos y después anule el bloqueo. el cliente debe invocar el nuevo método. servidor adaptado : cree un intermediario que realice el bloque. es un ejemplo de bloqueo basado en servidores en el que el servidor original no se puede modificar. reducir el tamaño de las secciones sincronizadas la palabra clave synchronized presenta un bloqueo. todas las secciones de código protegidas por el mismo bloque sólo tendrán un proceso que las ejecute en un momento dado. los bloqueos son costosos ya que generan retrasos y añaden sobrecarga. por ello, no conviene colapsar el código con instrucciones synchronized . por otra parte, las secciones críticas [86] deben protegerse, de modo que debemos diseñar nuestro código con el menor número posible de secciones críticas. algunos programadores intentan lograrlo ampliando el tamaño de sus secciones críticas. sin embargo, al ampliar la sincronización más allá de la sección crítica mínima aumentan los problemas y afecta negativamente al rendimiento [87] . recomendación : reduzca al máximo el tamaño de las secciones synchronized . crear código de cierre correcto es complicado 246crear un sistema activo y que se ejecute indefinidamente es distinto a crear algo que funcione de forma temporal y después se cierre correctamente. entre los problemas más habituales destacan los bloqueos [88] , con procesos que esperan una señal para continuar que nunca se produce. imagine, por ejemplo, un sistema con un proceso principal que genera varios procesos secundarios y que espera a que todos terminen antes de liberar sus recursos y cerrarse. ¿qué sucede si uno de los procesos secundarios está bloqueado? el principal esperará indefinidamente y el sistema nunca se cerrará. imagine ahora un sistema similar al que se le indica que se cierre. el proceso principal indica a todos los secundarios que abandonen sus tareas y terminen. pero imagine que dos procesos secundarios funcionan como par productor/consumidor y que el productor recibe una señal del principal y se cierra rápidamente. el consumidor espera un mensaje del productor y puede quedar bloqueado en un estado en el que no recibe la señal del principal, lo que también impide que éste finalice. son situaciones habituales. por tanto, si tiene que crear código concurrente con cierres correctos, tendrá que dedicar tiempo a que el cierre se produzca de forma correcta. recomendación : planifique con antelación el proceso de cierre y pruébelo hasta que funcione. le llevará más tiempo del que espera. repase los algoritmos existentes porque será complicado . probar código con procesos demostrar que el código es correcto no resulta práctico. las pruebas no garantizan su corrección. sin embargo, las pruebas adecuadas pueden minimizar los riesgos, en especial en aplicaciones de un solo proceso. cuando hay dos o más procesos que usan el mismo código y trabajan con datos compartidos, la situación se vuelve más compleja. recomendación : cree pruebas que puedan detectar problemas y ejecútelas periódicamente, con distintas configuraciones de programación y del sistema, y cargas. si las pruebas fallan, identifique el fallo. no lo ignore 247porque las pruebas superen una ejecución posterior . hay muchos factores que tener en cuenta. veamos algunas recomendaciones concretas: considere los fallos como posibles problemas de los procesos. consiga que primero funcione el código sin procesos. el código con procesos se debe poder conectar a otros elementos. el código con procesos debe ser modificable. ejecute con más procesos que procesadores. ejecute en diferentes plataformas. diseñe el código para probar y forzar fallos. considerar los fallos como posibles problemas de los procesos el código con procesos hace que fallen elementos que no deberían fallar. muchos desarrolladores desconocen cómo interactúan los procesos con otro tipo de código. los problemas del código con procesos pueden mostrar sus síntomas una vez cada mil o un millón de ejecuciones. los intentos por repetir los sistemas pueden resultar frustrantes, lo que suele provocar que los programadores consideren el fallo como algo aislado. es recomendable asumir que los fallos aislados no existen. cuanto más los ignore, mayor será la cantidad de código que se acumule sobre un enfoque defectuoso. recomendación : no ignore los fallos del sistema como algo aislado . conseguir que primero funcione el código sin procesos puede parecer evidente pero no está de más recordarlo. asegúrese de que el código funciona fuera de sus procesos. por lo general, esto significa crear algunos pojo que los procesos deban invocar. los pojo no son compatibles con los procesos y por tanto se pueden probar fuera de su entorno. conviene 248incluir en los pojo la mayor cantidad posible del sistema. recomendación : no intente identificar fallos de procesos y que no sean de procesos al mismo tiempo. asegúrese de que su código funciona fuera de los procesos . el código con procesos se debe poder conectar a otros elementos cree el código compatible con la concurrencia de forma que se pueda ejecutar en distintas configuraciones: un proceso, varios procesos y variarlo durante la ejecución. el código con procesos interactúa con algo que puede ser real o probado. ejecutar con pruebas dobles ejecutadas de forma rápida, lenta y variable. configurar pruebas que ejecutar en diferentes iteraciones. recomendación : el código con procesos debe poder conectar a otros elementos y ejecutar en distintas configuraciones . el código con procesos debe ser modificable la obtención del equilibrio adecuado de procesos suele requerir operaciones de ensayo y error. en las fases iniciales, compruebe el rendimiento del sistema bajo diferentes configuraciones. permita que se puedan modificar los distintos procesos y también durante la ejecución del sistema. también puede permitir la modificación automática en función de la producción y la utilización del sistema. ejecutar con más procesos que procesadores cuando el sistema cambia de tarea, se producen reacciones. para promover el intercambio de tareas, realice la ejecución con más procesos que procesadores o núcleos. cuanto mayor sea la frecuencia de intercambio de las 249tareas, más probabilidades existen de que el código carezca de una sección crítica o se produzcan bloqueos. ejecutar en diferentes plataformas en 2007 diseñamos un curso sobre programación concurrente, principalmente en os x. la clase se presentó con windows xp ejecutado en una mv. se crearon pruebas para ilustrar condiciones de fallo que fallaban con más frecuencia en os x que en xp. en todos los casos, el código probado era incorrecto. esto refuerza el hecho de que cada sistema operativo tiene una política de procesos diferente que afecta a la ejecución del código. el código con procesos múltiples se comporta de forma distinta en cada entorno [89] . debe ejecutar sus pruebas en todos los entornos de implementación posibles. recomendación : ejecute el código con procesos en todas las plataformas de destino con frecuencia y en las fases iniciales . diseñar el código para probar y forzar fallos es habitual que los fallos del código concurrente se oculten. las pruebas sencillas no suelen mostrarlos. en realidad, suelen ocultarse durante el procesamiento normal. pueden aparecer horas, días o semanas después. la razón de que los problemas de procesos sean infrecuentes, esporádicos y apenas se repitan es que sólo fallan algunas de las miles de rutas posibles que recorren una sección vulnerable. por tanto, la probabilidad de adoptar una ruta fallida es realmente baja, lo que dificulta la detección y la depuración. se preguntará cómo aumentar las posibilidades de capturar estos casos. puede diseñar el código y forzarle a que se ejecute en diferentes órdenes añadiendo métodos como object.wait() , object.sleep() , object.yield() y object.priority() . estos métodos afectan al orden de ejecución y, por tanto, aumentan las posibilidades de detectar un error. resulta más adecuado que el código 250incorrecto falle lo antes posible y con frecuencia. hay dos opciones de instrumentación de código: manual. automática. manual puede añadir invocaciones de wait() , sleep() , yield() y priority() manualmente a su código, en especial si tiene que probar un fragmento especialmente escabroso. veamos un ejemplo: public synchronized string nexturlornull() { if (hasnext()) { string url = urlgenerator.next(); thread.yield(); // se añade para pruebas. updatehasnext(); return url; } return null; } la invocación de yield() cambia la ruta de ejecución adoptada por el código y posiblemente hace que el código falla donde no lo hacía antes. si el código falla, no se debe a la invocación de yield() añadida [90] . se debe a que el código es incorrecto y hemos hecho que el fallo sea más evidente. este enfoque presenta varios problemas: tendrá que buscar manualmente los puntos adecuados donde hacerlo. ¿cómo sabe dónde incluir la invocación y qué tipo de invocación usar? la presencia de este código en un entorno de producción ralentiza innecesariamente el código. es un enfoque que puede o no detectar los fallos; de hecho, no las tiene todas consigo. lo que necesitamos es una forma de hacerlo durante la fase de pruebas, no de producción. también debemos poder mezclar configuraciones entre ejecuciones, lo que aumenta las probabilidades de detectar los errores. 251evidentemente, si dividimos el sistema pojo que no sepa nada los procesos en clases que controlen los procesos, resultará más sencillo ubicar los puntos en los que instrumentar el código. es más, podríamos crear diferentes pruebas que invoquen los pojo bajo distintos regímenes de invocaciones a sleep , yield y demás. automática puede usar herramientas como la estructura orientada a aspectos, cglib o asm para instrumentar su código mediante programación. por ejemplo, podría usar una clase con un único método: public class threadjigglepoint { public static void jiggle() { } } puede añadir invocaciones en distintos puntos del código: public synchronized string nexturlornull() { if(hasnext()) { threadjigglepoint.jiggle(); string url = urlgenerator.next(); threadjigglepoint.jiggle(); updatehasnext(); threadjigglepoint.jiggle(); return url; } return null; } tras ello, use un sencillo aspecto que seleccione aleatoriamente entre no hacer nada, pausar o generar un resultado. imagine que la clase threadjigglepoint tiene dos implementaciones. la primera implementa jiggle para no hacer nada y se usa en producción. la segunda genera un número aleatorio para elegir entre sleep , yield o nada. si ejecuta sus pruebas mil veces con jiggle de forma aleatoria, puede descubrir algunos fallos. si la prueba es satisfactoria, al menos puede felicitarse por haber actuado correctamente. aunque sea un tanto simple, puede resultar una opción razonable en lugar de recurrir a una herramienta más sofisticada. la herramienta contest [91] , desarrollada por ibm, tiene un funcionamiento 252similar pero es más sofisticada. el objetivo es que los procesos del código se ejecuten en distinto orden en momentos diferentes. la combinación de pruebas bien escritas y ejecuciones aleatorias puede aumentar considerablemente la capacidad de detectar errores. recomendación : use estas estrategias para detectar errores . conclusión es complicado conseguir código concurrente correcto. el código sencillo se puede complicar al añadir varios procesos y datos compartidos. si tiene que crear código concurrente, tendrá que hacerlo con rigor o se enfrentará a sutiles y esporádicos fallos. en primer lugar, siga el principio de responsabilidad única. divida su sistema en varios pojo que separen el código compatible con procesos del resto. asegúrese de probar únicamente el código compatible con procesos y nada más, por lo que este código debe ser de tamaño reducido y específico. conozca los orígenes de los problemas de concurrencia: varios procesos que operen en datos compartidos o usen una agrupación de recursos común. los casos de límites, como el cierre correcto o la conclusión de la iteración de un bucle, pueden ser especialmente espinosos. conozca su biblioteca y los algoritmos fundamentales. debe comprender cómo las funciones de la biblioteca permiten resolver problemas similares a los de los algoritmos fundamentales. aprenda a localizar regiones del código que se puedan bloquear y bloquéelas. no bloquee otras regiones que no lo necesiten. evite invocar una sección bloqueada desde otra. para ello debe saber si un elemento está compartido o no. reduzca la cantidad de objetos compartidos y su ámbito. cambie los diseños de los objetos con datos compartidos para acomodar clientes en lugar de obligar a los clientes a gestionar el estado compartido. los problemas se acumularán. los que no aparezcan inicialmente suelen considerarse esporádicos y suelen producirse en la fase de carga o de modo aparentemente aleatorio. por tanto, debe poder ejecutar su código con 253procesos en diferentes configuraciones y plataformas de forma repetida y continua. la capacidad de prueba, algo natural si aplica las tres leyes de tdd, implica cierto nivel de conectividad, lo que ofrece la compatibilidad necesaria para ejecutar código en distintas configuraciones. la probabilidad de detectar errores mejora si se toma el tiempo necesario para instrumentar su código. puede hacerlo manualmente o mediante tecnologías automatizadas. hágalo en las fases iniciales. es aconsejable ejecutar el código basado en procesos durante el mayor tiempo posible antes de pasarlo a producción. si adopta un enfoque limpio, aumentarán las probabilidades de hacerlo de forma correcta. bibliografía [lea99] : concurrent programming in java: design principles and patterns , 2d. ed., doug lea, prentice hall, 1999. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. 25414 refinamiento sucesivo caso práctico de un analizador de argumentos de línea de comandos este capítulo es un caso práctico de refinamiento sucesivo. veremos un 255módulo que comienza correctamente pero no mantiene dicha corrección. tras ello, veremos cómo se refactoriza y se limpia. muchos hemos tenido que analizar argumentos de línea de comando. si no disponemos de una utilidad para ello, recorremos la matriz de cadenas pasadas a la función principal. puede encontrar utilidades de calidad pero ninguna hace exactamente lo que necesitamos. por ello, decidí crear una propia, a la que he denominado args . args es muy fácil de usar. basta crearla con los argumentos de entrada y una cadena de formato, y después consultar a la instancia de args los valores de los argumentos. fíjese en el siguiente ejemplo: listado 14-1 uso de args public static void main(string[] args) { try { args arg = new args(“l,p#,d*”, args); boolean logging = arg.getboolean(‘l’); int port = arg.getint(‘p’); string directory = arg.getstring(‘d’); executeapplication(logging, port, directory); } catch (argsexception e) { system.out.printf(“argument error: %s\n”, e.errormessage()); } } comprobará lo sencillo que es. creamos una instancia de la clase args con dos parámetros. el primero es la cadena de formato o esquema: “l,p#,d*” . define tres argumentos de línea de comandos. el primero, -l , es un argumento booleano. el segundo, -p , es un argumento entero. el tercero, - d , es un argumento de cadena. el segundo parámetro del constructor args es la matriz de argumentos de línea de comandos pasada a main . si el constructor no genera argsexception , la línea de comandos entrante se ha analizado y se puede consultar la instancia args . se usan métodos como getboolean , getinteger y getstring para acceder a los valores de los argumentos por sus nombres. si hay un problema, ya sea en la cadena de formato o en los argumentos de línea de comandos, se genera argsexception . la descripción del error se 256puede recuperar del método errormessage de la excepción. implementación de args el listado 14-2 es la implementación de la clase args . examínela con atención. el estilo y la estructura se han trabajado concienzudamente y espero que los imite. listado 14-2 args.java package com.objectmentor.utilities.args; import static com.objectmentor.utilities.args.argsexception.errorcode.*; import java.util.*; public class args { private map<character, argumentmarshaler> marshalers; private set<character> argsfound; private listiterator<string> currentargument; public args(string schema, string[] args) throws argsexception { marshalers = new hashmap<character, argumentmarshaler>(); argsfound = new hashset<character>(); parseschema(schema); parseargumentstrings(arrays.aslist(args)); } private void parseschema(string schema) throws argsexception { for (string element : schema.split(“,”)) if (element.length() > 0) parseschemaelement(element.trim()); } private void parseschemaelement(string element) throws argsexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(element id); if (elementtail.length() == 0) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail.equals(“*”)) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail.equals(“#”)) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); 257else if (elementtail.equals(“[*]”)) marshalers.put(elementid, new stringarrayargumentmarshaler()); else throw new argsexception(invalid_argument_format, elementid, elementtail); } private void validateschemaelementid(char elementid) throws argsexception { if {!character.isletter(elementid)) throw new argsexception(invalid_argument_name, elementid, null); } private void parseargumentstrings(list<string> argslist) throws argsexception { for (currentargument = argslist.listiterator(); currentargument.hasnext();) { string argstring = currentargument.next(); if (argstring.startswith(“-”)) { parseargumentcharacters(argstring.substring(1)); } else { currentargument.previous(); break; } } } private void parseargumentcharacters(string argchars) throws argsexception { for (int i = 0; i < argchars.length(); i++) parseargumentcharacter(argchars.charat(i)); } private void parseargumentcharacter(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) { throw new argsexception (unexpected_argument, argchar, null); } else { argsfound.add(argchar); try { m.set(currentargument); } catch (argsexception e) { e.seterrorargumentid(argchar); throw e; } } } public boolean has(char arg) { return argsfound.contains(arg); } public int nextargument() { 258return currentargument.nextindex(); } public boolean getboolean(char arg) { return booleanargumentmarshaler.getvalue(marshalers.get(arg)); } public string getstring(char arg) { return stringargumentmarshaler.getvalue(marshalers.get(arg)); } public int getint(char arg) { return integerargumentmarshaler.getvalue (marshalers.get(arg)); } public double getdouble(char arg) { return doubleargumentmarshaler.getvalue(marshalers.get(arg)); } public string[] getstringarray(char arg) { return stringarrayargumentmarshaler.getvalue(marshalers.get(arg)); } } puede leer el código de arriba a abajo sin necesidad de saltar de un punto a otro ni buscar hacia adelante. lo que seguramente busque es la definición de argumentmarshaler , que hemos omitido intencionadamente. tras leer el código, comprenderá la interfaz argumentmarshaler y la función de sus variantes. veamos algunas de ellas (entre los listados 14-3 y 14-6). listado 14-3 argumentmarshaler.java public interface argumentmarshaler { void set(iterator<string> currentargument) throws argsexception; } listado 14-4 booleanargumentmarshaler.java public class booleanargumentmarshaler implements argumentmarshaler { private boolean booleanvalue = false; public void set (iterator<string> currentargument) throws argsexception { booleanvalue = true; } public static boolean getvalue(argumentmarshaler am) { 259if (am != null && am instanceof booleanargumentmarshaler) return ((booleanargumentmarshaler) am).booleanvalue; else return false; } } listado 14-5 stringargumentmarshaler.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class stringargumentmarshaler implements argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { throw new argsexception(missing_string); } } public static string getvalue(argumentmarshaler am) { if (am != null && am instanceof stringargumentmarshaler) return ((stringargumentmarshaler) am).stringvalue; else return “”; } } listado 14-6 integerargumentmarshaler.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class integerargumentmarshaler implements argumentmarshaler { private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); intvalue = integer.parseint(parameter); } catch (nosuchelementexception e) { throw new argsexception(missing_integer); } catch (numberformatexception e) { throw new argsexception(invalid_integer, parameter); } } 260public static int getvalue (argumentmarshaler am) { if (am != null && am instanceof integerargumentmarshaler) return ((integerargumentmarshaler) am).intvalue; else return 0; } } las otras variantes de argumentmarshaler simplemente repiten este patrón en matrices double y string y sólo complicarían el capítulo. puede consultarlas como ejercicio. otro fragmento que puede resultar complicado es la definición de las constantes de código de error, incluidas en la clase argsexception (véase el listado 14-7). listado 14-7 argsexception.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = null; private errorcode errorcode = ok; public argsexception() {} public argsexception(string message) { super(message); } public argsexception(errorcode errorcode) { this.errorcode = errorcode; } public argsexception(errorcode errorcode, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; } public argsexception(errorcode errorcode, char errorargumentid, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; this.errorargumentid = errorargumentid; } public char geterrorargumentid() { return errorargumentid; } public void seterrorargumentid(char errorargumentid) { this.errorargumentid = errorargumentid; 261} public string geterrorparameter() { return errorparameter; } public void seterrorparameter(string errorparameter) { this.errorparameter = errorparameter; } public errorcode geterrorcode() { return errorcode; } public void seterrorcode(errorcode errorcode) { this.errorcode = errorcode; } public string errormessage() { switch (errorcode) { case ok: return “tilt: should not get here.”; case unexpected_argument: return string.format(“argument -%c unexpected.”, errorargumentid); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c.”, errorargumentid); case invalid_argument_name: return string.format(“‘%c’ is not a valid argument name.”, errorargumentid); case invalid_argument_format: return string.format(“‘%s’ is not a valid argument format.”, errorparameter); } return “”; } public enum errorcode { ok, invalid_argument_format, unexpected_argument, invalid_argument_name, missing_string, missing_integer, invalid_integer, missing_double, invalid_double } } 262es sorprendente la cantidad de código necesario para detallar este sencillo concepto. uno de los motivos es el uso de un lenguaje especialmente profuso. java, al ser un lenguaje de tipos estáticos, requiere muchas palabras para satisfacer el sistema de tipos. en lenguajes como ruby, python o smalltalk, este programa es mucho más reducido [92] . vuelva a leer el código. fíjese especialmente en los nombres de los elementos, el tamaño de las funciones y el formato. si tiene experiencia como programador, partes del estilo o la estructura no le convencerán, pero espero que, desde un punto de vista global, considere que el programa está bien escrito y tiene una estructura limpia. por ejemplo, debería ser evidente cómo añadir un nuevo tipo de argumento, como una fecha o un número complejo, y que dicha inclusión apenas requeriría código. en definitiva, bastaría con una nueva variante de argumentmarshaler , una nueva función getxxx y una nueva instrucción case en la función parseschemaelement . también habría un nuevo código argsexception.errorcode y un nuevo mensaje de error. cómo se ha realizado no diseñé este programa de principio a fin en su forma actual y, sobre todo, no espero que pueda crear programas limpios y elegantes a la primera. si algo hemos aprendido en las dos últimas décadas es que la programación es un arte más que una ciencia. para escribir código limpio, primero debe crear código imperfecto y después limpiarlo. no debería sorprenderle. ya lo aprendimos en el colegio cuando los profesores (normalmente en vano) nos obligaban a crear borradores de nuestras redacciones. el proceso, nos decían, era escribir un primer borrador, después otro, y después otros muchos hasta lograr una versión definitiva. para escribir redacciones limpias, el refinamiento debía ser continuado. muchos programadores noveles (como sucede con los alumnos) no siguen este consejo. creen que el objetivo principal es que el programa funcione. una vez que lo consiguen, pasan a la siguiente tarea, y conservan el estado funcional del programa, sea cual sea. los programadores 263experimentados saben que esto es un suicidio profesional. args: el primer borrador el listado 14-8 muestra una versión inicial de la clase args . funciona, pero es un desastre. listado 14-8 args.java (primer borrador) import java.text.parseexception; import java.util.*; public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private map<character, string> stringargs = new hashmap<character, string>(); private map<character, integer> intargs = new hashmap<character, integer>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema. string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { 264} return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)); parsebooleanschemaelement(elementid); else if (isstringschemaelement(elementtail)) parsestringschemaelement(elementid); else if (isintegerschemaelement(elementtail)) { parseintegerschemaelement(elementid); } else { throw new parseexception( string.format(“argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, false); } private void parseintegerschemaelement(char elementid) { intargs.put(elementid, 0); } private void parsestringschemaelement(char elementid) { stringargs.put(elementid, “”); } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } 265private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private boolean isintegerschemaelement(string elementtail) { return elementtail.equals(“#”); } private boolean parsearguments() throws argsexception { for (currentargument = 0; currentargument < args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = errorcode.unexpected_argument; valid = false; } } private boolean setargument(char argchar) throws argsexception { if (isbooleanarg(argchar)) setbooleanarg(argchar, true); else if (isstringarg(argchar)) setstringarg(argchar); else if (isintarg(argchar)) setintarg(argchar); else return false; return true; } private boolean isintarg(char argchar) { return intargs.containskey(argchar); } 266private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.put(argchar, new integer(parameter)); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch (numberformatexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.put(argchar, args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } private boolean isstringarg(char argchar) { return stringargs.containskey(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isbooleanarg(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return "-[" + schema + “]”; else return “”; } 267public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument - %c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“arguments(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } private boolean falseifnull(boolean b) { return b != null && b; } private int zeroifnull(integer i) { return i == null ? 0 : i; } private string blankifnull(string s) { return s = null ? “” : s; } public string getstring(char arg) { return blankifnull(stringargs.get(arg)); } public int getint(char arg) { return zeroifnull(intargs.get(arg)); } public boolean getboolean(char arg) { return falseifnull(booleanargs.get(arg)); } public boolean has(char arg) ( 268return argsfound.contains(arg); } public boolean isvalid() { return valid; } private class argsexception extends exception { } } espero que su reacción inicial ante tal cantidad de código es alegrarse por no haberlo conservado tal cual. si ha sido su reacción, recuerde que será la que tengan otros que lean un borrador de su código. en realidad, primer borrador es lo mejor que se puede decir sobre este código. evidentemente es un trabajo en progreso. la cantidad de variables de instancia es apabullante. cadenas extrañas como « tilt », hashset y treeset , y los bloques try-catch-catch aumentan el desastre. no era mi intención crear este desastre. en realidad, intentaba mantener cierta organización, como demuestra la elección de nombres de funciones y variables, y la estructura del programa. pero es evidente que el problema se me fue de las manos. el desastre aumentó gradualmente. las versiones anteriores no fueron tan malas. por ejemplo, el listado 14-9 muestra una versión inicial en la que sólo funcionaban los argumentos booleanos. listado 14-9 args.java (sólo argumentos booleanos) package com.objectmentor.utilities.getopts; import java.util.*; public class args { private string schema; private string[] args; private boolean valid; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private int numberofarguments = 0; public args(string schema, string[] args) { this.schema = schema; this.args = args; 269valid = parse(); } public boolean isvalid() { return valid; } private boolean parse() { if (schema.length() == 0 && args.length == 0) return true; parseschema(); parsearguments(); return unexpectedarguments.size() == 0; } private boolean parseschema() { for (string element : schema.split(“,”)) { parseschemaelement(element); } return true; } private void parseschemaelement(string element) { if (element.length() == 1) { parsebooleanschemaelement(element); } } private void parsebooleanschemaelement(string element) { char c = element.charat(0); if (character.isletter(c)) { booleanargs.put(c, false); } } private boolean parsearguments() { for (string arg : args) parseargument(arg); return true; } private void parseargument(string arg) { if (arg.startswith(“-”)) parseelement(arg); } private void parseelements(string arg) { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) { if (isboolean(argchar)) { numberofarguments++; setbooleanarg(argchar, true); 270} else unexpectedarguments.add(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return numberofarguments; } public string usage() { if (schema.length() > 0) return “-[”+schema+“]”; else return “”; } public string errormessage() { if (unexpectedarguments.size() > 0) { return unexpectedargumentmessage(); } else return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return booleanargs.get(arg); } } aunque hay motivos para quejarse del código, no es tan malo. es compacto y sencillo, y fácil de entender. sin embargo, en este código se aprecia la semilla del desastre posterior y resulta evidente porqué. la versión posterior sólo tiene dos tipos de argumentos más que ésta: string e integer . la inclusión de sólo dos tipos más tiene un tremendo impacto negativo en el código. lo convierte de algo que sería razonablemente 271mantenible en algo que seguramente esté plagado de errores. añadí los dos tipos de argumento de forma incremental. primero, el argumento string , que genera lo siguiente: listado 14-10 args.java (booleano y string) package com.objectmentor.utilities.getopts; import java.text.parseexception; import java.util.*; public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private map<character, string> stringargs = new hashmap<character, string>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargument = ‘\0’; enum errorcode { ok, missing_string } private errorcode errorcode = errorcode.ok; public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); parsearguments(); return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; 272} private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) parsebooleanschemaelement(elementid); else if (isstringschemaelement(elementtail)) parsestringschemaelement(elementid); } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private void parsestringschemaelement(char elementid) { stringargs.put(elementid, “”); } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, false); } private boolean parsearguments() { for (currentargument = 0; currentargument < args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } 273private void parseelement(char argchar) { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); valid = false; } } private boolean setargument(char argchar) { boolean set = true; if (isboolean(argchar)) setbooleanarg(argchar, true); else if (isstring(argchar)) setstringarg (argchar, “”); else set = false; return set; } private void setstringarg(char argchar, string s) { currentargument++; try { stringargs.put(argchar, args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargument = argchar; errorcode = errorcode.missing_string; } } private boolean isstring(char argchar) { return stringargs.containskey(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return “-[” + schema + “]”; else return “”; } 274public string errormessage() throws exception { if (unexpectedarguments.size() > 0) { return unexpectedargumentmessage(); } else switch (errorcode) { case missing_string: return string.format (“could not find string parameter for -%c.”, errorargument); case ok: throw new exception(“tilt: should not get here.”); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return falseifnull(booleanargs.get(arg)); } private boolean falseifnull(boolean b) { return b == null ? false : b; } public string getstring(char arg) { return blankifnull(stringargs.get(arg)); } private string blankifnull(string s) { return s == null ? “” : s; } public boolean has(char arg) { return argsfound.contains(arg); } public boolean isvalid() { return valid; } } comprobará que empieza a desbocarse. no es terrible pero el desastre se está gestando. basta con incluir el tipo de argumento integer para que resulte fatídico. 275entonces me detuve todavía tenía que añadir otros dos tipos de argumentos y sabía que empeorarían las cosas. si los forzaba, seguramente funcionarían pero provocaría un desastre demasiado complicado de arreglar. si la estructura del código tenía que poder mantenerse, era el momento de corregirla. por ello dejé de añadir elementos y comencé la refactorización. tras añadir los argumentos string e integer , sabía que cada uno necesitaría nuevo código en tres puntos principales. en primer lugar, cada tipo de argumento necesita una forma de analizar su elemento de esquema para poder seleccionar el hashmap de ese tipo. tras ello, sería necesario analizar cada tipo de argumento en las cadenas de línea de comandos y convertirlos en su tipo correcto. por último, cada tipo de argumento necesitaría un método getxxx para poder devolverlo al invocador como su tipo correcto. muchos tipos diferentes y todos con métodos similares, lo que en realidad era una clase. y de este modo nació el concepto de argumentmarshaler . sobre el incrementalismo una de las mejores formas de acabar con un programa es realizar cambios masivos con la intención de mejorarlo. algunos programas nunca se recuperan de estas mejoras. el problema es lo complicado que resulta conseguir que el programa funcione de la misma forma que antes de la mejora. para evitarlo, recurro a la disciplina tdd ( test-driven development o desarrollo guiado por pruebas). una de las doctrinas centrales de este enfoque es mantener la ejecución del sistema en todo momento. es decir, con tdd no puedo realizar cambios que afecten al funcionamiento del sistema. todos los cambios deben mantenerlo como antes de los cambios. para lograrlo, necesito una serie de pruebas automatizadas que ejecutar rápidamente y que verifiquen que el comportamiento del sistema no ha variado. para la clase args , creé una serie de pruebas de unidad y aceptación. las pruebas de unidad se crearon en java y se administraron con junit. las 276pruebas de aceptación se crearon como páginas wiki en fitnesse. podría haber ejecutado estas pruebas en cualquier momento y, si eran satisfactorias, sabría que el sistema funcionaba de la forma especificada. así pues, comencé a realizar pequeños cambios. cada uno desplazaba la estructura del sistema hacia el concepto argumentmarshaler , y cada cambio mantenía el funcionamiento del sistema. el primer cambio realizado fue añadir el esqueleto de argumentmarshaller al final del desastre anterior (véase el listado 14-11). listado 14-11 argumentmarshaller añadido a args.java private class argumentmarshaler { private boolean booleanvalue = false; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } private class booleanargumentmarshaler extends argumentmarshaler { } private class stringargumentmarshaler extends argumentmarshaler { } private class integerargumentmarshaler extends argumentmarshaler { } } evidentemente, esto no afectaría a nada, por lo que realicé la modificación más sencilla posible que afectara a la mínima cantidad de código. cambié hashmap para que los argumentos boolean aceptaran argumentmarshaler . private map<character, argumentmarshaler > booleanargs = new hashmap<character, argumentmarshaler >(); esto afectaba a varias instrucciones que corregí rápidamente. … private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, new booleanargumentmarshaler ()); } … 277private void setbooleanarg(char argchar, boolean value) { booleanargs. get (argchar). setboolean (value); } … public boolean getboolean(char arg) { return falseifnull (booleanargs.get(arg). getboolean() ); } estos cambios se aplican a las zonas que mencionamos antes: parse , set y get para el tipo de argumento. desafortunadamente, aunque sean cambios menores, algunas de las pruebas comenzaron a fallar. si se fija atentamente en getboolean , comprobará que se puede invocar con y pero no existe un argumento y , por lo que booleanargs.get(‘y’) devolverá null y la función generará nullpointerexception . la función falseifnull se usa como protección ante este hecho pero el cambio aplicado hace que la función sea irrelevante. el incrementalismo exigía que esto funcionara antes de realizar otros cambios. la solución no era demasiado complicada; bastaba con cambiar la comprobación de null . ya no era necesario comprobar null en boolean, sino en argumentmarshaller . primero, eliminé la invocación de falseifnull en la función getboolean . ya no servía de nada, por lo que eliminé directamente la función. las pruebas seguían fallando igual, lo que suponía que no había nuevos errores. public boolean getboolean(char arg) { return booleanargs.get(arg).getboolean(); } tras ello, dividí la función en dos líneas y añadí argumentmarshaller a una variable propia: argumentmarshaller . no me preocupaba el extenso nombre de la variable; era redundante y estorbaba a la función, por lo que lo reduje a am [n5]. public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am .getboolean(); } y tras ello añadí la lógica de detección de null . public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); 278return am != null && am.getboolean(); } argumentos de cadena la inclusión de los argumentos string fue similar a la de los argumentos boolean . tuve que cambiar hashmap y conseguir que funcionaran parse , set y get . no deberían producirse sorpresas posteriores a excepción de que la implementación completa se incluía en la clase argumentmarshaller en lugar de distribuirla en variantes. private map<character, argumentmarshaler > stringargs = new hashmap<character, argumentmarshaler >(); … private void parsestringschemaelement(char elementid) { stringargs.put(elementid, new stringargumentmarshaler()); } … private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs. get (argchar). setstring (args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring (char arg) { args.argumentmarshaler am = stringargs.get(arg); return am == null ? “” : am.getstring(); } … private class argumentmarshaler { private boolean booleanvalue = false; private string stringvalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { 279stringvalue = s; } public string getstring() { return stringvalue == null ? “” : stringvalue; } } de nuevo, estos cambios se realizaron individualmente para conservar las pruebas, aunque fallaran. si una prueba fallaba, me aseguraba de que fuera correcta antes de continuar con el siguiente cambio. ya debería reconocer mi intención. tras incluir el comportamiento de señalización en la clase base argumentmarshaler , comencé a transferirlo a las variantes, para de esta forma mantener el funcionamiento mientras cambiaba gradualmente la forma del programa. el siguiente paso consistía en transferir la funcionalidad del argumento int a argumentmarshaler . de nuevo, no hubo sorpresas. private map<character, argumentmarshaler > intargs = new hashmap<character, argumentmarshaler >(); … private void parseintegerschemaelement(char elementid) { intargs.put(elementid, new integerargumentmarshaler() ); } … private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs. get (argchar). setinteger (integer.parseint(parameter)); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch (numberformatexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } … public int getint(char arg) { args.argumentmarshaler am = intargs.get(arg); return am == null ? 0 : am.getinteger(); } 280… private class argumentmarshaler { private boolean booleanvalue = false; private string stringvalue; private int integervalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { stringvalue = s; } public string getstring() { return stringvalue == null ? “” : stringvalue; } public void setinteger(int i) { integervalue = i; } public int getinteger() { return integervalue; } } tras transferir la señalización a argumentmarshaler , comencé a transferir la funcionalidad a las variantes. el primer paso fue pasar la función setboolean a booleanargumentmarshaller y garantizar su correcta invocación. para ello creé un método set abstracto. private abstract class argumentmarshaler { protected boolean booleanvalue = false; private string stringvalue; private int integervalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { stringvalue = s; } public string getstring() { 281return stringvalue == null ? “” : stringvalue; } public void set integer(int i) { integervalue = i; } public int getinteger() { return integervalue; } public abstract void set(string s); } tras ello, implementé el método set en booleanargumentmarshaller . private class booleanargumentmarshaler extends argumentmarshaler { public void set(string s) { booleanvalue = true; } } y por último cambié la invocación de setboolean por la de set . private void setbooleanarg(char argchar, boolean value) { booleanargs.get(argchar). set(“true”) ; } las pruebas seguían siendo satisfactorias. como este cambio hacía que set se implementara en booleanargumentmarshaler , eliminé el método setboolean de la clase base argumentmarshaler . la función abstracta set acepta un argumento string pero la implementación de booleanargumentmarshaler no lo usa. he incluido el argumento porque sabía que stringargumentmarshaler e integerargumentmarshaler lo utilizarían. tras ello, el objetivo era implementar el método get en booleanargumentmarshaler . la implementación de funciones get siempre es escabrosa ya que el tipo devuelto tiene que ser object y en este caso debe convertirse a boolean . public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am != null && (boolean) am. get (); } para compilarlo, añadí la función get a argumentmarshaler . private abstract class argumentmarshaler { … 282public object get() { return null; } } se compila y las pruebas fallan. para que vuelvan a funcionar, basta con convertir get en abstracto e implementarlo en booleanargumentmarshaler . private abstract class argumentmarshaler { protected boolean booleanvalue = false; … public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { public void set (string s) { booleanvalue = true; } public object get() { return booleanvalue; } } de nuevo, las pruebas son satisfactorias. ahora tanto get como set se implementan en booleanargumentmarshaler . esto me permite eliminar la antigua función getboolean de argumentmarshaler , cambiar la variable protegida booleanvalue a booleanargumentmarshaler y convertirla en privada. repetí el mismo patrón de cambios con las cadenas. implementé set y get , eliminé las funciones sin usar y desplacé las variables. private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.get(argchar). set (args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring(char arg) { args.argumentmarshaler am = stringargs.get(arg); return am == null ? “” : (string) am. get (); } 283… private abstract class argumentmarshaler { private int integervalue; public void setinteger(int i) { integervalue = i; } public int getinteger() { return integervalue; } public abstract void set(string s); public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(string s) { booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { public void set(string s){ } public object get() { return null; } } } por último, repetí el proceso con los enteros. resulta más complicado ya que los enteros deben analizarse y la operación de análisis puede generar una 284excepción, pero el resultado es más indicado ya que el concepto de numberformatexception se oculta totalmente en integerargumentmarshaler . private boolean isintarg(char argchar) { return intargs.containskey(argchar); } private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.get(argchar). set (parameter); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( argsexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e ; } } … private void setbooleanarg(char argchar) { try { booleanargs.get(argchar).set(“true”); } catch (argsexception e) { } } … public int getint(char arg) { args.argumentmarshaler am = intargs.get(arg); return am == null ? 0 : (integer) am. get (); } … private abstract class argumentmarshaler { public abstract void set(string s) throws argsexception; public abstract object get(); } … private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception s) { throw new argsexception(); } 285} public object get() { return intvalue; } } evidentemente, las pruebas seguían funcionando. tras ello, me deshice de las distintas asignaciones de la parte superior del algoritmo, lo que hace que el sistema sea mucho más genérico. sin embargo, no las puede eliminar ya que afectaría a la integridad del sistema. en su lugar, añadí un nuevo map para argumentmarshaler y, tras ello, cambié uno a uno los métodos para que usaran la nueva asignación en lugar de las originales. public class args { … private map<character, argumentmarshaler> booleanargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … private void parsebooleanschemaelement(char elementid) { argumentmarshaler m = new booleanargumentmarshaler(); booleanargs.put(elementid, m); marshalers.put(elementid, m); } private void parseintegerschemaelement(char elementid) { argumentmarshaler m = new integerargumentmarshaler(); intargs.put(elementid, m); marshalers.put(elementid, m); } private void parsestringschemaelement(char elementid) { argumentmarshaler m = new stringargumentmarshaler(); stringargs.put(elementid, m); marshalers.put(elementid, m); } las pruebas seguían funcionando. tras ello, cambié isbooleanarg de esto: private boolean isbooleanarg(char argchar) { return booleanargs.containskey(argchar); } a este otro: 286private boolean isbooleanarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof booleanargumentmarshaler; } las pruebas funcionaban, por lo que apliqué el mismo cambio en isintarg e isstringarg . private boolean isintarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof integerargumentmarshaler; } private boolean isstringarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof stringargumentmarshaler; } las pruebas eran correctas, por lo que eliminé las invocaciones duplicadas de marshalers.get : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (isbooleanarg( m )) setbooleanarg(argchar); else if (isstringarg( m )) setstringarg(argchar); else if (isintarg( m )) setintarg(argchar); else return false; return true; } private boolean isintarg ( argumentmarshaler m ) { return m instanceof integerargumentmarshaler; } private boolean isstringarg ( argumentmarshaler m ) { return m instanceof stringargumentmarshaler; } private boolean isbooleanarg ( argumentmarshaler m ) { return m instanceof booleanargumentmarshaler; } los tres argumentos isxxxarg ya no tenían sentido, de modo que los reubiqué: private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if ( m instanceof booleanargumentmarshaler ) setbooleanarg(argchar); 287else if ( m instanceof stringargumentmarshaler ) setstringarg(argchar); else if ( m instanceof integerargumentmarshaler ) setintarg(argchar); else return false; return true; } tras ello, empecé a usar la asignación marshalers en las funciones set , dividiendo el uso de las otras tres asignaciones. comencé por los elementos boolean . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m instanceof booleanargumentmarshaler) setbooleanarg( m ); else if (m instanceof stringargumentmarshaler) setstringarg(argchar); else if (m instanceof integerargumentmarshaler) setintarg(argchar); else return false; return true; } … private void setbooleanarg( argumentmarshaler m ) { try { m .set(“true”); // era: booleanargs.get(argchar).set(“true”); } catch (argsexception e) { } } las pruebas seguían siendo correctas de modo que repetí la operación con las cadenas y los enteros. de esta manera se puede integrar parte del desagradable código de gestión de excepciones en la función setargument . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg( m ); else if (m instanceof integerargumentmarshaler) setintarg( m ); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; 288throw e; } return true; } private void setintarg( argumentmarshaler m ) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; m .set(parameter); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg( argumentmarshaler m ) throws argsexception { currentargument++; try { m .set(args[currentargument]); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } ya podía eliminar las tres asignaciones antiguas. primero, debía cambiar la función getboolean de: public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am != null && (boolean) am.get(); } a: public boolean getboolean(char arg) { args.argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } este último cambio puede parecer sorprendente. ¿por qué de repente decidí enfrentarme a classcastexception ? por tener una serie de pruebas de 289unidad y otra serie independiente de pruebas de aceptación creadas en fitnesse. las pruebas de fitnesse garantizan que si se invoca getboolean en un argumento no booleano, se obtiene false . no sucede lo mismo con las pruebas de unidad. hasta el momento, sólo había ejecutado las pruebas de unidad [93] . este último cambio me permitió extraer otro uso de la asignación boolean: private void parsebooleanschemaelement(char elementid) { argumentmarshaler m = new booleanargumentmarshaler(); booleanargs.put(elementid, m); marshalers.put(elementid, m); } y ahora ya podemos eliminar la asignación boolean. public class args { … private map<character, argumentmarshaler> booleanargs = new hashmap<character, argmentmarshaler>(); private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … tras ello, cambié los argumentos string e integer de la misma forma y limpié los valores boolean . private void parsebooleanschemaelement(char elementid) { marshalers.put(elementid, new booleanargumentmarshaler() ); } private void parseintegerschemaelement(char elementid) { marshalers.put(elementid, new integerargumentmarshaler() ); } private void parsestringschemaelement(char elementid) { marshalers.put(elementid, new stringargumentmarshaler() ); } … public string getstring(char arg) { args.argumentmarshaler am = marshalers .get(arg); try { return am null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } 290public int getint(char arg) { args.argumentmarshaler am = marshalers .get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } … public class args { … private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … seguidamente, dispuse en línea los tres métodos parse ya que no servían para mucho: private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else if (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentmarshaler()); else if (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( “argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } es el momento de ver la estructura completa. el listado 14-12 muestra la clase args actual. listado 14-12 args.java (tras la primera refactorización) package com.objectmentor.utilities.getopts; import java.text.parseexception; import java.util.*; public class args { private string schema; 291private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { } return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else if (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentwarshaler()); else if (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( 292“argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private boolean isintegerschemaelement(string elementtail) { return elementtail.equals(“#”); } private boolean parsearguments() throws argsexception { for (currentargument=0; currentargument<args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = errorcode.unexpected_argument; valid = false; } } private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); try { 293if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } private void setintarg(argumentmarshaler m) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; m.set(parameter); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg(argumentmarshaler m) throws argsexception { currentargument++; try { m.set (args[currentargument]); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } private void setbooleanarg(argumentmarshaler m) { try { m.set(“true”); } catch (argsexception e) { } } public int cardinality() { return argsfound.size(); } public string usage() { 294if (schema.length() > 0) return = “-[” + schema + “]”; else return “”; } public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for {char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { args.argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } public string getstring(char arg) { args.argumentmarshaler am = marshalers.get (arg); try { return am == null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } 295public int getint(char arg) { args.argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } public boolean has(char arg) { return argsfound.contains(arg); } public boolean isvalid() { return valid; } private class argsexception extends exception { } private abstract class argumentmarshaler { public abstract void set(string s) throws argsexception; public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(string s) { booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); 296} catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } } tras todo este esfuerzo, es un tanto decepcionante. la estructura ha mejorado pero todavía hay demasiadas variables en la parte superior; se mantiene un terrible caso de tipos en setargument ; y todas las funciones set . sin mencionar el procesamiento de errores. todavía nos queda mucho trabajo por hacer. mi intención es eliminar el caso de tipos de setargument [g23] y que sólo incluya una invocación a argumentmarshaler.set . para ello, debo desplazar setintarg , setstringarg y setbooleanarg a las correspondientes variantes de argumentmarshaler . pero hay un problema. si se fija atentamente en setintarg , comprobará que usa dos variables de instancia: args y currentarg . para desplazar setintarg hasta booleanargumentmarshaler , tengo que pasar args y currentargs como argumentos de función. muy desagradable [f1]. resultaría más indicado pasar un argumento y no dos. afortunadamente, la solución es sencilla. podemos convertir la matriz args en list y pasar iterator a las funciones set . para el siguiente cambio necesité diez pasos, y superar todas las pruebas tras cada uno. pero sólo mostraremos el resultado. debería determinar la mayoría de estos pequeños pasos. public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private iterator<string> currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private list<string> argslist; 297private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument } public args(string schema. string[] args) throws parseexception { this.schema = schema; argslist = arrays.aslist(args); valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && argslist.size() == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { } return valid; } … private boolean parsearguments() throws argsexception { for (currentargument = argslist.iterator(); currentargument. hasnext() ;) { string arg = currentargument. next() ; parseargument(arg); } return true; } … private void setintarg(argumentmarshaler m) throws argsexception { string parameter = null; try { parameter = currentargument. next() ; m.set(parameter); } catch ( nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg(argumentmarshaler m) throws argsexception { try { m.set (currentargument. next() ); } catch ( nosuchelementexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } 298son pequeños cambios que conservan el funcionamiento de las pruebas. ahora podemos empezar a desplazar las funciones set a las correspondientes variantes. primero, debemos realizar el siguiente cambio en setargument : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } es un cambio importante ya que queremos eliminar totalmente la cadena if-else . por tanto, debemos excluir la condición de error. ya podemos empezar a desplazar las funciones set . la función setbooleanarg es trivial, de modo que la prepararemos en primer lugar. el objetivo es cambiar la función setbooleanarg para redirigirla a booleanargumentmarshaler . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m, currentargument ); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } 299return true; } --- private void setbooleanarg (argumentmarshaler m, iterator<string> currentargument) throws argsexception { try { m.set(“true”); catch (argsexception e) { } } ¿no acabamos de incluir el procesamiento de excepciones? añadir elementos para después excluirlos es habitual en los procesos de refactorización. los pasos reducidos y la necesidad de que las pruebas sigan siendo correctas implican que los elementos cambien de posición. la refactorización es como resolver el cubo de rubik. se necesitan muchos pasos pequeños para lograr un objetivo mayor. cada paso habilita el siguiente. se preguntará por qué pasamos iterator si setbooleanarg no lo necesita. pues porque setintarg y setstringarg sí. y como el objetivo es implementar las tres funciones a través de un método abstracto en argumentmarshaller , es necesario pasarlo a setbooleanarg . ahora setbooleanarg no sirve de nada. si hubiera una función set en argumentmarshaler , podríamos invocarla directamente. es el momento de crear dicha función. el primer paso consiste en añadir el nuevo método abstracto a argumentmarshaler . private abstract class argumentmarshaler { public abstract void set(iterator<string> currentargument) throws argsexception; public abstract void set (string s) throws argsexception; public abstract object get(); } evidentemente, esto afecta a todas las variantes, de modo que implementamos el nuevo método en cada una. private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(iterator<string> currentargument) throws argsexception { booleanvalue = true; } public void set(string s) { 300booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { } public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { } public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } y ahora ya podemos eliminar setbooleanarg : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) m.set (currentargument); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); 301} catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } las pruebas siguen siendo satisfactorias y la función set se implementa en boolean argumentmarshaler . podemos repetir la operación con las cadenas y los enteros. private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) m.set(currentargument); else if (m instanceof stringargumentmarshaler) m.set(currentargument); else if (m instanceof integerargumentmarshaler) m.set(currentargument); } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } --- private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } public void set(string s){ } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { 302private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); set(parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } y el golpe de gracia: se elimina el caso de tipos. private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { m.set(currentargument); return true; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } } ya podemos deshacernos de las funciones de integerargumentmarshaler y limpiar el resto. private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0 public void set (iterator<string> currentargument) throws argsexception { string parameter = null; try { 303parameter = currentargument.next(); intvalue = integer.parseint (parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( numberformatexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } public object get() { return intvalue; } } también podemos convertir argumentmarshaler en una interfaz. private interface argumentmarshaler { void set (iterator<string> currentargument) throws argsexception; object get(); } veamos ahora lo sencillo que resulta añadir un nuevo tipo de argumento a la estructura. apenas necesitaremos cambios y los que apliquemos tendrán que ser aislados. en primer lugar, añadimos un nuevo caso de prueba para comprobar que el argumento double funciona correctamente: public void testsimpledoublepresent() throws exception { args args = new args(“x##”, new string[] {“-x”,“42.3”}); asserttrue(args.isvalid()); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42.3, args.getdouble(‘x’), .001); } limpiamos el código de análisis de esquemas y añadimos la detección ## para el tipo de argumento double . private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (elementtail. length() == 0 ) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail. equals(“*”) ) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail. equals(“#”) ) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); 304else throw new parseexception(string.format( “argument: %c has invalid format: %s.”, elementid, elementtail), 0); } seguidamente, creamos la clase doubleargumentmarshaler . private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_double; throw new argsexception(); } catch (numberformatexception e) { errorparameter = parameter; errorcode = errorcode.invalid_double; throw new argsexception(); } } public object get() { return doublevalue; } } esto nos obliga a añadir un nuevo código de error ( errorcode ). private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } y necesitamos una función getdouble . public double getdouble(char arg) { args.argumentmarshaler am = marshalers.get(arg); try { return am = null ? 0 : (double) am.get(); } catch (exception e) { return 0.0; } } y todas las pruebas son correctas. ha sido sencillo. a continuación comprobamos que el procesamiento de errores funciona correctamente. el siguiente caso de prueba comprueba que se declare un error si se proporciona 305una cadena que no se puede analizar a un argumento ##. public void testinvaliddouble() throws exception { args args = new args(“x##”, new string[] {“-x”, “forty two”}); assertfalse(args.isvalid()); assertequals(0, args.cardinality()); assertfalse(args.has(‘x’)); assertequals(0, args.getint(‘x’)); assertequals(“argument -x expects a double but was ‘forty two’.”, args.errormessage()); } --- public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c”, errorargumentid); } return “”; } y las pruebas son satisfactorias. la siguiente prueba garantiza que se detecte correctamente la ausencia de un argumento double . public void testmissingdouble() throws exception { args args = new args(“x##”, new string[]{"-x"}); assertfalse (args.isvalid()); assertequals(0, args.cardinality()); assertfalse(args.has(‘x’)); assertequals(0.0, args.getdouble(‘x’), 0.01); assertequals(“could not find double parameter for -x.”, args.errormessage()); } es correcto. la incluimos para que el ejemplo resulte más completo. el código de excepciones no es atractivo y no pertenece realmente a la 306clase args . también generamos parseexception , que no nos pertenece. por ello, combinamos todas las excepciones en una única clase argsexception y la incluimos en su propio módulo. public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; public argsexception() {} public argsexception(string message) { super(message); } public enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } } … public class args { … private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private argsexception .errorcode errorcode = argsexception .errorcode.ok; private list<string> argslist; public args(string schema, string[] args) throws argsexception { this.schema = schema; argslist = arrays.aslist(args); valid = parse(); } private boolean parse() throws argsexception { if (schema.length() == 0 && argslist.size() == 0) return true; parseschema(); try { parsearguments(); } catch ( argsexception e) { } return valid; } private boolean parseschema() throws argsexception { … } private void parseschemaelement(string element) throws argsexception { … else throw new argsexception ( string.format(“argument: %c has invalid format: %s.”, elementid, elementtail)); } 307private void validateschemaelementid(char elementid) throws argsexception { if (!character.isletter(elementid)) { throw new argsexception ( “bad character:” + elementid + “in args format: ” + schema); } } … private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = argsexception .errorcode.unexpected_argument; valid = false; } } … private class stringargumentmarshaler implements argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { errorcode = argsexception .errorcode.missing_string; throw new argsexception(); } } public object get() { return stringvalue; } } private class integerargumentmarshaler implements argumentmarshaler { private int intvalue = 0; public void set (iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); intvalue = integer.parseint(parameter); } catch (nosuchelementexception e) { errorcode = argsexception.errorcode.missing_integer; throw new argsexception (); } catch (numberformatexception e) { errorparameter = parameter; errorcode = argsexception .errorcode.invalid_integer; throw new argsexception (); 308} } public object get() { return intvalue; } } private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception e) { errorcode = argsexception .errorcode.missing_double; throw new argsexception(); } catch (numberformatexception e) { errorparameter = parameter; errorcode = argsexception .errorcode.invalid_double; throw new argsexception); } } public object get() { return doublevalue; } } } muy bien. ahora, args solamente genera argsexception . al desplazar argsexception a un módulo propio, podemos añadir a dicho módulo gran parte del código de error y extraerlo del módulo args . es una posición natural y evidente para incluir todo el código y nos permitirá limpiar posteriormente el módulo args . ya hemos separado el código de excepciones y de error del módulo args (véanse los listados del 14-13 al 14-16). para ello realizamos una serie de 30 pasos mínimos y las pruebas fueron satisfactorias entre todos ellos. listado 14-13 argstest.java. package com.objectmentor.utilities.args; import junit.framework.testcase; 309public class argstest extends testcase { public void testcreatewithnoschemaorarguments() throws exception { args args = new args(“”, new string[0]); assertequals(0, args.cardinality()); } public void testwithnoschemabutwithoneargument() throws exception { try { new args(“”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.unexpected_argument, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testwithnoschemabutwithmultiplearguments() throws exception { try { new args(“”, new string[]{“-x”, “-y”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.unexpected_argument, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testnonletterschema() throws exception { try { new args(“*”, new string[]{}); fail(“args constructor should have thrown exception”); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_argument_name, e.geterrorcode()); assertequals(‘*’, e.geterrorargumentid()); } } public void testinvalidargumentformat() throws exception { try { new args(“f~”, new string[]{}); fail(“args constructor should have throws exception”); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_format, e.geterrorcode()); assertequals(‘f’, e.geterrorargumentid()); } } public void testsimplebooleanpresent() throws exception { args args = new args(“x”, new string []{“-x”}); assertequals(1, args.cardinality()); assertequals(true, args.getboolean(‘x’)); 310} public void testsimplestringpresent() throws exception { args args = new args(“x*”, new string[]{“-x”, “param”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(“param”, args.getstring(‘x’)); } public void testmissingstringargument() throws exception { try { new args(“x*”, new string[]{"-x"}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_string, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testspacesinformat() throws exception { args args = new args(“x, y”, new string[]{“-xy”}); assertequals(2, args.cardinality()); asserttrue(args.has(‘x’)); asserttrue(args.has(‘y’)); } public void testsimpleintpresent() throws exception { args args = new args(“x#”, new string[]{“-x”, “42”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42, args.getint(‘x’)); } public void testinvalidinteger() throws exception { try { new args(“x#”, new string[] {“-x”, “forty two”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_integer, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); assertequals(“forty two”, e.geterrorparameter()); } } public void testmissinginteger() throws exception { try { new args(“x#”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_integer, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } 311public void testsimpledoublepresent() throws exception { args args = new args(“x##”, new string[](“-x”, “42.3”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42.3, args.getdouble(‘x’), .001); } public void testinvaliddouble() throws exception { try { new args(“x##”, new string []{“-x”, “forty two”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_double, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); assertequals(“forty two”, e.geterrorparameter()); } } public void testmissingdouble() throws exception { try { new args(“x##”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_double, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } } listado 14-14 argsexceptiontest.java. public class argsexceptiontest extends testcase { public void testunexpectedmessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.unexpected_argument, ‘x’, null); assertequals(“argument -x unexpected.”, e.errormessage()); } public void testmissingstringmessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_string, ‘x’, null); assertequals(“could not find string parameter for –x.”, e.errormessage()); } public void testinvalidintegermessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.invalid_integer, 312‘x’, “forty two”); assertequals(“argument –x expects an integer but was ‘forty two’.”, e.errormessage()); } public void testmissingintegermessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_integer, ‘x’, null); assertequals(“could not find integer parameter for -x.”, e.errormessage()); } public void testinvaliddoublemessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.invalid_double, ‘x’, “forty two”); assertequals(“argument -x expects a double but was ‘forty two’.”, e.errormessage()); } public void testmissingdoublemessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_double, ‘x’, null); assertequals(“could not find double parameter for -x.”, e.errormessage()); } } listado 14-15 argsexception.java. public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; public argsexception() {} public argsexception(string message) {super(message);} public argsexception(errorcode errorcode) { this.errorcode = errorcode; } public argsexception(errorcode errorcode, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; } public argsexception(errorcode errorcode, char errorargumentid, string errorparameter) { this.errorcode = errorcode; 313this.errorparameter = errorparameter; this.errorargumentid = errorargumentid; } public char geterrorargumentid() { return errorargumentid; } public void seterrorargumentid(char errorargumentid) { this.errorargumentid = errorargumentid; } public string geterrorparameter() { return errorparameter; } public void seterrorparameter(string errorparameter) { this.errorparameter = errorparameter; } public errorcode geterrorcode() { return errorcode; } public void seterrorcode(errorcode errorcode) { this.errorcode = errorcode; } public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return string.format(“argument -%c unexpected.”, errorargumentid); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c.”, errorargumentid); } return “”; } public enum errorcode { ok, invalid_format, unexpected_argument, invalid_argument_name, 314missing_string, missing_integer, invalid_integer, missing_double, invalid_double} } listado 14-16 args.java. public class args { private string schema; private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private iterator<string> currentargument; private list<string> argslist; public args(string schema, string[] args) throws argsexception { this.schema = schema; argslist = arrays.aslist(args); parse(); } private void parse() throws argsexception { parseschema(); parsearguments(); } private boolean parseschema() throws argsexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { parseschemaelement(element.trim()); } } return true; } private void parseschemaelement(string element) throws argsexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (elementtail.length() == 0) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail.equals(“*”)) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail.equals(“#”)) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); else throw new argsexception(argsexception.errorcode.invalid_format, elementid, elementtail); } 315private void validateschemaelementid(char elementid) throws argsexception { if (!character.isletter(elementid)) { throw new argsexception(argsexception.errorcode.invalid_argument_name, elementid, null); } } private void parsearguments() throws argsexception { for (currentargument = argslist.iterator(); currentargument.hasnext();) { string arg = currentargument.next(); parseargument(arg); } } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { throw new argsexception(argsexception.errorcode.unexpected_argument, argchar, null); } } private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { m.set(currentargument); return true; } catch (argsexception e) { e.seterrorargumentid(argchar); throw e; } } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return "-[" + schema + “]”; 316else return “”; } public boolean getboolean(char arg) { argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } public string getstring(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } public int getint(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } public double getdouble(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (double) am.get(); } catch (exception e) { return 0.0; } } public boolean has(char arg) { return argsfound.contains(arg); } } la mayoría de los cambios realizados en la clase args han sido eliminaciones. gran parte del código se extrajo de args y se añadió a argsexception . perfecto. también cambiamos todos los elementos argumentmarshaller a sus propios archivos. mejor todavía. 317el diseño de software correcto se basa gran parte en las particiones, en crear zonas adecuadas para incluir distintos tipos de código. esta separación hace que el código sea más fácil de entender y mantener. especialmente interesante es el método errormessage de argsexception . incumple claramente el srp al incluir el formato de mensajes de error en args . args debe centrarse en el procesamiento de argumentos, no en el formato de los mensajes de error. sin embargo, ¿realmente tiene sentido incluir el código de formato de mensajes de error en argsexception ? francamente es un compromiso. los usuarios que no deseen los mensajes de error proporcionados por argsexception tendrán que crear los suyos propios, pero la utilidad de mensajes de error ya preparados es evidente. ya debería haberse dado cuenta de la distancia recorrida con respecto a la solución mostrada al inicio del capítulo. las transformaciones finales puede examinarlas por su cuenta. conclusión no basta con que el código funcione. el código que funciona suele ser incorrecto. los programadores que se conforman con código funcional no se comportan de forma profesional. puede que teman que no tienen tiempo para mejorar la estructura y el diseño del código, pero discrepo. no hay nada que afecte más negativamente a un proyecto de desarrollo que el código incorrecto. los plazos incorrectos se pueden rehacer y los requisitos equivocados se pueden volver a definir. la dinámica incorrecta de un equipo se puede reparar pero el código incorrecto se corrompe y se convierte en una carga que arrastra al equipo completo. he visto equipos dominados por el desastre que han generado y que han dominado su destino. evidentemente, el código incorrecto se puede limpiar pero resulta muy costoso. cuando el código se corrompe los módulos se insinúan unos a otros y generan multitud de dependencias ocultas y entrelazadas. la localización y división de dependencias antiguas es una tarea larga y complicada. por otra parte, resulta relativamente sencillo mantener código limpio. si comete un error en un módulo, es más fácil limpiarlo directamente. mejor todavía, si 318cometió un error hace cinco minutos, es muy fácil limpiarlo ahora. por tanto, la solución consiste en mantener el código limpio y sencillo siempre que se pueda y no dejar que llegue a corromperse. 31915 aspectos internos de junit 320junit es una de las estructuras de java más conocidas. de concepción sencilla, definición precisa y documentación elegante. ¿y su código? en este capítulo analizaremos un ejemplo extraído de la estructura junit. la estructura junit junit ha tenido muchos autores, comenzando por kent beck y eric gamma en un vuelo a atlanta. kent quería aprender java y eric quería saber más sobre la estructura de pruebas smalltalk de kent. “¿hay algo más natural que 321dos fanáticos enciendan sus portátiles y empiecen a escribir código?” [94] tras tres horas de trabajo de altura, habían creado los fundamentos de junit. el módulo que analizaremos es un inteligente fragmento de código que permite identificar errores de comparación de cadenas. el nombre del módulo es comparisoncompactor . dadas dos cadenas diferentes, como abcde y abxde , muestra la diferencia entre ambas generando una cadena como <… b[x]d…> . podríamos explicarlo más, pero los casos de prueba son mejores. fíjese en el listado 15-1 para comprender los requisitos de este módulo. analice la estructura de las pruebas. ¿podrían ser más simples o más evidentes? listado 15-1 comparisoncompactortest.java. package junit.tests.framework; import junit.framework.comparisoncompactor; import junit.framework.testcase; public class comparisoncompactortest extends testcase { public void testmessage() { string failure= new comparisoncompactor(0, “b”, “c”).compact(“a”); asserttrue(“a expected:<[b]> but was:<[c]>”.equals(failure)); } public void teststartsame() { string failure= new comparisoncompactor(1, “ba”, “bc”).compact(null); assertequals(“expected:<b[a]> but was:<b[c]>”, failure); } public void testendsame() { string failure= new comparisoncompactor(1, “ab”, “cb”).compact(null); assertequals(“expected:<[a]b> but was:<[c]b>”, failure); } public void testsame() { string failure= new comparisoncompactor(1, “ab”, “ab”).compact(null); assertequals(“expected:<ab> but was:<ab>”, failure); } public void testnocontextstartandendsame() { string failure= new comparisoncompactor(0, “abc”, “adc”).compact(null); assertequals(“expected:<…[b]…> but was:<…[d]…>”, failure); } 322public void teststartandendcontext() { string failure= new comparisoncompactor(1, “abc”, “adc”).compact(null); assertequals(“expected:<a[b]c> but was:<a[d]c>”, failure); } public void teststartandendcontextwithellipses() { string failure= new comparisoncompactor(1, “abcde”, “abfde”).compact(null); assertequals(“expected:<…b[c]d…> but was:<…b[f]d…>”, failure); } public void testcomparisonerrorstartsamecomplete() { string failure= new comparisoncompactor(2, “ab”, “abc”).compact(null); assertequals(“expected:<ab[]> but was:<ab[c]>”, failure); } public void testcomparisonerrorendsamecomplete() { string failure= new comparisoncompactor(0, “bc”, “abc”).compact(null); assertequals(“expected:<[]…> but was:<[a]…>”, failure); } public void testcomparisonerrorendsamecompletecontext() { string failure= new comparisoncompactor(2, “bc”, “abc”).compact(null); assertequals(“expected:<[]bc> but was:<[a]bc>”, failure); } public void testcomparisonerroroverlapingmatches() { string failure= new comparisoncompactor(0, “abc”, “abbc”).compact(null); assertequals(“expected:<…[]…> but was:<…[b]…>”, failure); } public void testcomparisonerroroverlapingmatchescontext() { string failure= new comparisoncompactor(2, “abc”, “abbc”).compact(null); assertequals(“expected:<ab[]c> but was:<ab[b]c>”, failure); } public void testcomparisonerroroverlapingmatches2() { string failure= new comparisoncompactor(0, “abcdde”, “abcde”).compact(null); assertequals(“expected:<…[d]…> but was:<…[]…>”, failure); } public void testcomparisonerroroverlapingmatches2context() { string failure= new comparisoncompactor(2, “abcdde”, “abcde”).compact(null); assertequals(“expected:<…cd[d]e> but was:<…cd[]e>”, failure); } public void testcomparisonerrorwithactualnull() { string failure= new comparisoncompactor(0, “a”, null).compact(null); assertequals(“expected:<a> but was:<null>”, failure); } public void testcomparisonerrorwithactualnullcontext() { string failure= new comparisoncompactor(2, “a”, null).compact(null); 323assertequals(“expected:<a> but was:<null>”, failure); } public void testcomparisonerrorwithexpectednull() { string failure= new comparisoncompactor(0, null, “a”).compact(null); assertequals(“expected:<null> but was:<a>”, failure); } public void testcomparisonerrorwithexpectednullcontext() { string failure= new comparisoncompactor(2, null, “a”).compact(null); assertequals(“expected:<null> but was:<a>”, failure); } public void testbug609972() { string failure= new comparisoncompactor(10, “s&p500”, “0”).compact(null); assertequals(“expected:<[s&p50]0> but was:<[]0>”, failure); } } realicé un análisis de alcance de código en comparisoncompactor con estas pruebas. el código se cubre en un 100 por 100. cada línea, cada instrucción if y cada bucle for se ejecuta con las pruebas. de este modo sé que el código funciona y sus autores me merecen el mayor de los respetos. el código comparisoncompactor se reproduce en el listado 15-2. examínelo. creo que lo encontrará bien distribuido, razonablemente expresivo y estructuralmente sencillo. cuando termine, lo diseccionaremos. listado 15-2 comparisoncompactor.java (original). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int fcontextlength; private string fexpected; private string factual; private int fprefix; private int fsuffix; public comparisoncompactor(int contextlength, string expected, string actual) { fcontextlength = contextlength; fexpected = expected; 324factual = actual; } public string compact(string message) { if (fexpected == null || factual == null || arestringsequal()) return assert.format(message, fexpected, factual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(fexpected); string actual = compactstring(factual); return assert.format(message, expected, actual); } private string compactstring(string source) { string result = delta_start + source.substring(fprefix, source.length() - fsuffix + 1) + delta_end; if (fprefix > 0) result = computecommonprefix() + result; if (fsuffix > 0) result = result + computecommonsuffix(); return result; } private void findcommonprefix() { fprefix = 0; int end = math.min(fexpected.length(), factual.length()); for (; fprefix < end; fprefix++) { if (fexpected.charat(fprefix) != factual.charat(fprefix)) break; } } private void findcommonsuffix() { int expectedsuffix = fexpected.length() - 1; int actualsuffix = factual.length() - 1; for (; actualsuffix >= fprefix && expectedsuffix >= fprefix; actualsuffix--, expectedsuffix--) { if (fexpected.charat(expectedsuffix) != factual.charat(actualsuffix)) break; } fsuffix = fexpected.length() - expectedsuffix; } private string computecommonprefix() { return (fprefix > fcontextlength ? ellipsis : “”) + fexpected.substring(math.max(0, fprefix - fcontextlength), fprefix); } private string computecommonsuffix() { int end = math.min(fexpected.length() - fsuffix + 1 + fcontextlength, fexpected.length()); 325return fexpected.substring(fexpected.length() - fsuffix + 1, end) + (fexpected.length() - fsuffix + 1 < fexpected.length() - fcontextlength ? ellipsis : “”); } private boolean arestringsequal() { return fexpected.equals(factual); } } puede que tenga varias quejas sobre el módulo. incluye expresiones extensas y extraños elementos +1 . pero en general, está bastante bien. después de todo, podría haber sido como el listado 15-3. listado 15-3 comparisoncompator.java (defactorizado) package junit.framework; public class comparisoncompactor { private int ctxt; private string s1; private string s2; private int pfx; private int sfx; public comparisoncompactor(int ctxt, string s1, string s2) { this.ctxt = ctxt; this.s1 = s1; this.s2 = s2; } public string compact(string msg) { if (s1 == null || s2 == null || s1.equals(s2)) return assert.format(msg, s1, s2); pfx = 0; for (; pfx < math.min(s1.length(), s2.length()); pfx++) { if (s1.charat(pfx) != s2.charat(pfx)) break; } int sfx1 = s1.length() - 1; int sfx2 = s2.length() - 1; for (; sfx2 >= pfx && sfx1 >= pfx; sfx2--, sfx1--) { if (s1.charat(sfx1) != s2.charat(sfx2)) break; } sfx = s1.length() - sfx1; string cmp1 = compactstring(s1); string cmp2 = compactstring(s2); return assert.format(msg, cmp1, cmp2); 326} private string compactstring(string s) { string result = “[” + s.substring(pfx, s.length() - sfx + 1) + “]”; if (pfx > 0) result = (pfx > ctxt ? “…” : “”) + s1.substring(math.max(0, pfx - ctxt), pfx) + result; if (sfx > 0) { int end = math.min(s1.length() - sfx + 1 + ctxt, s1.length()); result = result + (s1.substring(s1.length() - sfx + 1, end) + (s1.length() - sfx + 1 < s1.length() - ctxt ? “…” : “”)); } return result; } } aunque los autores hicieron un buen trabajo con este módulo, la regla del boy scout [95] muestra que podrían haberlo dejado más limpio de lo que se encontró. ¿cómo podemos mejorar el código original del listado 15-2? lo primero que no necesitamos es el prefijo f de las variables miembro [n6]. los entornos actuales hacen que este tipo de código de ámbito sea redundante, por lo que eliminaremos todas las f . private int contextlength; private string expected; private string actual; private int prefix; private int suffix; tras ello, tenemos una condicional sin encapsular al inicio de la función compact [g28]. public string compact(string message) { if (expected == null || actual == null || arestringsequal()) return assert.format(message, expected, actual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } es necesario encapsular esta condicional para que nuestra intención sea más clara. por tanto, extraemos un método que la explique. public string compact(string message) { if ( shouldnotcompact() ) return assert.format(message, expected, actual); 327findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } private boolean shouldnotcompact() { return expected == null || actual == null || arestringsequal(); } en la función compact , this.expected y this.actual no son demasiado relevantes. sucede al cambiar el nombre de fexpected por expected . ¿por qué esta función tiene variables con los mismos nombres que las variables miembro? ¿no representan cosas diferentes?[n4]. los nombres deben ser exclusivos. string compactexpected = compactstring( expected ); string compactactual = compactstring( actual ); los negativos son más difíciles de entender que los positivos [g29]. por ello, invertimos esa instrucción if para cambiar el sentido de la condicional. public string compact(string message) { if ( canbecompacted() ) { findcommonprefix(); findcommonsuffix(); string compactexpected = compactstring(expected); string compactactual = compactstring(actual); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private boolean canbecompacted () { return expected != null && actual != null && !arestringsequal(); } el nombre de la función es extraño [n7]. aunque compacta las cadenas, puede que lo haga si canbecompacted devuelve false . al asignar el nombre compact a esta función se oculta el efecto secundario de la comprobación de errores. además, la función devuelve un mensaje con formato, no sólo las cadenas compactadas. por tanto, el nombre de la función debería ser formatcompactedcomparison . de esta forma, se lee mejor junto al argumento de la función: 328public string formatcompactedcomparison(string message) { el cuerpo de la instrucción if es donde se realiza la verdadera compactación de las cadenas. debemos extraerlo como método con el nombre compactexpectedandactual . sin embargo, queremos que la función formatcompactedcomparison realice todo el formato. la función compact … sólo debe realizar la compactación [g30], de modo que la dividimos de esta forma: … private string compactexpected; private string compactactual; … public string formatcompactedcomparison(string message) { if (canbecompacted()) { compactexpectedandactual(); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private void compactexpectedandactual () { findcommonprefix(); findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } para ello, hemos tenido que ascender compactexpected y compactactual a variables miembro. no me gusta la forma en que las dos últimas líneas de la nueva función devuelven variables pero las dos primeras no lo hacen. no utilizan convenciones coherentes [g11]. debemos cambiar findcommonprefix y findcommonsuffix para que devuelvan los valores de prefijo y sufijo. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonprefix() { int prefix index = 0; int end = math.min(expected.length(), actual.length()); for (; prefix index < end; prefix index ++) { 329if (expected.charat(prefix index ) != actual.charat(prefix index )) break; } return prefixindex; } private int findcommonsuffix() { int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefix index && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix--) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } también debemos cambiar los nombres de las variables miembro para que sean más preciosas [n1], ya que en el fondo son índices. al examinar findcommonsuffix vemos una conexión temporal oculta [g31]; depende de que prefixindex se calcule por findcommonprefix . si estas dos funcione se invocan de forma desordenada, la sesión de depuración posterior sería complicada. por ello, para mostrar esta combinación temporal, haremos que findcommonsuffix acepte prefixindex como argumento. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix( prefixindex ); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonsuffix( int prefixindex ) { int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefixindex && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix--) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } no me convence del todo. el hecho de pasar prefixindex como argumento es un tanto arbitrario [g32]. permite establecer el orden pero no explica la necesidad del mismo. otro programador podría deshacer esta operación ya que no se indica en ningún momento para qué sirve el parámetro. adoptemos un enfoque diferente. 330private void compactexpectedandactual() { findcommonprefixandsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private void findcommonprefixandsuffix () { findcommonprefix(); int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefixindex && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix-- ) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } suffixindex = expected.length() - expectedsuffix; } private void findcommonprefix() { prefixindex = 0; int end = math.min(expected.length(), actual.length()); for (; prefixindex < end; prefixindex++) if (expected.charat(prefixindex) != actual.charat(prefixindex)) break; } devolvemos findcommonprefix y findcommonsuffix a su posición original, cambiamos el nombre de findcommonsuffix por findcommonprefixandsuffix y hacemos que invoque findcommonprefix antes de hacer nada más. de ese modo se establece la naturaleza temporal de ambas funciones de forma más evidente que antes. además, se muestra el mínimo atractivo de findcommonprefixandsuffix , que limpiaremos a continuación: private void findcommonprefixandsuffix() { findcommonprefix(); int suffixlength = 1; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } suffixindex = suffixlength; } private char charfromend(string s, int i) { return s.charat(s.length()-i);} private boolean suffixoverlapsprefix(int suffixlength) { 331return actual.length() - suffixlength < prefixlength || expected.length() - suffixlength < prefixlength; } mucho mejor. muestra que suffixindex es en realidad la longitud del sufijo y que su nombre no es correcto. lo mismo sucede con prefixindex , aunque en ese caso índice y longitud son sinónimos. incluso así, es más coherente usar length . el problema es que la variable suffixindex no es de base cero, sino de base 1 y no es una verdadera longitud. éste es el motivo de la abundancia de +1 en computecommonsuffix [g33]. lo corregimos. en el listado 15-4 puede ver el resultado. listado 15-4 comparisoncompactor.java (versión intermedia). public class comparisoncompactor { … private int suffixlength ; … private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = 0; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } } private char charfromend(string s, int i) { return s.charat(s.length() - i - 1 ); } private boolean suffixoverlapsprefix(int suffixlength) { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } … private string compactstring(string source) { string result = delta_start + source.substring(prefixlength, source.length() - suffixlength ) + delta_end; if (prefixlength > 0) result = computecommonprefix() + result; if ( suffixlength > 0) 332result = result + computecommonsuffix(); return result; } … private string computecommonsuffix() { int end = math.min(expected.length() - suffixlength + contextlength, expected.length() ); return expected.substring(expected.length() - suffixlength , end) + (expected.length() - suffixlength < expected.length() - contextlength ? ellipsis : “”); } cambiamos +1 en computecommonsuffix por un -1 en charfromend, donde tiene sentido, y dos operadores <= en suffixoverlapsprefix , totalmente correctos. de este modo podemos cambiar el nombre de suffixindex por suffixlength , lo que mejora considerablemente la legibilidad del código. pero hay un problema. al comenzar a eliminar los +1 , me fijé en la siguiente línea de compactstring : if (suffixlength > 0) búsquela en el listado 15-4. como ahora suffixlength es una unidad menos que antes, debemos cambiar el operador > por >= . pero eso no tiene sentido. ahora sí. significa que no tenía sentido antes y que seguramente fuera un error. bueno, no del todo. tras un análisis detallado, vemos que ahora la instrucción if impide que se añada un sufijo de longitud cero. antes de realizar el cambio, la instrucción if no funcionaba ya que suffixindex nunca podía ser menos de uno. esto cuestiona ambas instrucciones if en compactstring . parece como si se pudieran eliminar. por ello, las comentamos y ejecutamos las pruebas. satisfactorias. reestructuremos compactstring para eliminar las instrucciones if sobrantes y simplificar la función [g9]. private string compactstring(string source) { return computecommonprefix() + delta_start + source.substring(prefixlength, source.length() - suffixlength) + 333delta_end + computecommonsuffix(); } mucho mejor. ahora vemos que la función compactstring simplemente combina los fragmentos. probablemente lo podríamos limpiar más, en pequeñas operaciones, pero en lugar de desarrollar el resto de los cambios, mostraremos el resultado final en el listado 15-5. listado 15-5 comparisoncompactor.java (versión definitiva). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int contextlength; private string expected; private string actual; private int prefixlength; private int suffixlength; public comparisoncompactor( int contextlength, string expected, string actual ) { this.contextlength = contextlength; this.expected = expected; this.actual = actual; } public string formatcompactedcomparison(string message) { string compactexpected = expected; string compactactual = actual; if (shouldbecompacted()) { findcommonprefixandsuffix(); compactexpected = compact(expected); compactactual = compact(actual); } return assert.format(message, compactexpected, compactactual); } private boolean shouldbecompacted() { return !shouldnotbecompacted(); } private boolean shouldnotbecompacted() { return expected == null || 334actual == null || expected.equals(actual); } private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = 0; for (; !suffixoverlapsprefix(); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength) ) break; } } private char charfromend(string s, int i) { return s.charat(s.length() - i - 1); } private boolean suffixoverlapsprefix() { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } private void findcommonprefix() { prefixlength = 0; int end = math.min(expected.length(), actual.length()); for (; prefixlength < end; prefixlength++) if (expected.charat(prefixlength) != actual.charat(prefixlength)) break; } private string compact(string s) { return new stringbuilder() .append(startingellipsis()) .append(startingcontext()) .append(delta_start) .append(delta(s)) .append(delta_end) .append(endingcontext()) .append(endingellipsis()) .tostring(); } private string startingellipsis() { return prefixlength > contextlength ? ellipsis : “”; } private string startingcontext() { int contextstart = math.max(0, prefixlength - contextlength); int contextend = prefixlength; return expected.substring(contextstart, contextend); } private string delta(string s) { 335int deltastart = prefixlength; int deltaend = s.length() - suffixlength; return s.substring(deltastart, deltaend); } private string endingcontext() { int contextstart = expected.length() - suffixlength; int contextend = math.min(contextstart + contextlength, expected.length()); return expected.substring(contextstart, contextend); } private string endingellipsis() { return (suffixlength > contextlength ? ellipsis : “”); } } bastante atractivo. el módulo se separa en un grupo de funciones de análisis y otro grupo de funciones de síntesis. se ordenan topológicamente para que la definición de cada función aparezca donde realmente se usa. primero se muestran las funciones de análisis y después las de síntesis. si se fija atentamente, verá que he invertido algunas de las decisiones adoptadas inicialmente. por ejemplo, he añadido algunos métodos extraídos a formatcompactedcomparison y he modificado el sentido de la expresión shouldnotbecompacted . es algo habitual. a menudo, un cambio de refactorización lleva a otro que a su vez lleva a deshacer el primero. la refactorización es un proceso iterativo de ensayo y error, e inevitablemente converge en algo que consideramos digno de un profesional. conclusión hemos cumplido la regla del boy scout. hemos dejado este módulo más limpio de como lo encontramos. no es que no estuviera limpio originalmente, ya que el trabajo de sus autores es excelente, pero cualquier módulo se puede mejorar y es nuestra responsabilidad dejar el código más limpio de lo que lo encontramos. 33616 refactorización de serialdate si visita http://www.jfree.org/jcommon/index.php , encontrará la biblioteca jcommon. en su interior incluye el paquete org.jfree.date y, dentro de éste, la clase serialdate . vamos a analizar esta clase. el autor de serialdate es david gilbert. david es un programador experimentado y competente. como veremos, muestra un elevado grado de profesionalidad y disciplina en su código. en lo que a éste respecta, se puede 337considerar de calidad. y voy a despedazarlo. no es un acto de malicia, ni tampoco me creo mejor que david y con el derecho de juzgar su código. de hecho, si leyera algún código que he creado, seguramente tendría que objetar muchos aspectos del mismo. no es un acto de arrogancia. lo que voy a hacer no es más que una revisión profesional, algo con lo que todos deberíamos sentirnos cómodos y algo que deberíamos agradecer si alguien lo hace. a través de las críticas es como podemos aprender, como hacen médicos, pilotos o abogados. y nosotros, como programadores, también tenemos que aprender a hacerlo. otra cosa más sobre david gilbert: es más que un buen programador. david ha tenido el valor y la buena voluntad de ofrecer este código al público gratuitamente, para que cualquiera pueda usarlo y examinarlo. ¡bien hecho! serialdate (véase el listado b-1) es una clase que representa una fecha en java. ¿para qué se necesita una clase que represente una fecha si java ya cuenta con java.util.date y java.util.calendar , entre otras? el autor creó esta clase como respuesta a un problema que yo también he padecido. el comentario de su javadoc inicial (línea 67) lo explica. podríamos cuestionar su intención, pero yo también he sufrido este problema y se agradece una clase sobre fechas en lugar de horas. primero, conseguir que funcione hay varias pruebas de unidad en la clase serialdatetests (véase el listado b-2). todas son satisfactorias. desafortunadamente, un rápido examen demuestra que no comprueban todos los aspectos [t1]. por ejemplo, al realizar una búsqueda de usos en el método monthcodetoquarter (línea 334) se indica que no se usa [f4]. por lo tanto, las pruebas de unidad no lo comprueban. por ello, recurrí a clover para ver el alcance de las pruebas de unidad. clover indicó que las pruebas sólo ejecutan 91 de las 185 instrucciones ejecutables de serialdate (aproximadamente el 50 por 100) [t2]. el mapa de alcance muestra grandes fragmentos de código sin ejecutar desperdigados por la clase. mi objetivo era comprender la clase y refactorizarla, algo que no podía 338lograr sin una cobertura mayor de las pruebas. por ello diseñé mi propia suite de pruebas de unidad independientes (véase el listado b-4). si se fija en las pruebas, comprobará que muchas están comentadas, ya que no se superaron. representan un comportamiento que considero debería incluirse en serialdate . por tanto, al refactorizar serialdate , intentaré que estas pruebas funcionen. incluso con algunas de las pruebas comentadas, el informe de clover indica que ahora ejecutan 170 (el 92 por ciento) de las 185 instrucciones ejecutables. un gran resultado que creo que puedo mejorar. las primeras pruebas comentadas (líneas 23-63) son un tanto pretenciosas. el programa no fue diseñado para superar estas pruebas, pero el comportamiento me parecía evidente [g2]. desconozco por qué se ha creado el método testweekdaycodetostring pero ya que está ahí, parece obvio que no debe distinguir entre mayúsculas y minúsculas. el diseño de las pruebas fue sencillo [t3] y más todavía que fueran satisfactorias; simplemente cambié las líneas 259 y 263 para usar equalsignorecase . comenté las pruebas de las líneas 32 y 45 ya que no estaba seguro de si las abreviaturas tues y thurs se admitían o no. las pruebas de las líneas 153 y 154 no se superaron, aunque deberían haberlo hecho [g2]. podemos corregirlas, junto a las pruebas de las líneas 163 a la 213, si realizamos los siguientes cambios en la función stringtomonthcode . 457 if ((result < 1) || (result > 12)) { result = -1; 458 for (int i = 0; i < monthnames.length; i++) { 459 if (s.equalsignorecase(shortmonthnames[i])) { 460 result = i + 1; 461 break; 462 } 463 if (s.equalsignorecase(monthnames[i])) { 464 result = i + 1; 465 break; 466 } 467 } 468 } la prueba comentada de la línea 318 descubre un error en el método getfollowingdayofweek (línea 672). el 25 de diciembre de 2004 fue sábado y el siguiente sábado fue el 1 de enero de 2005. sin embargo, al ejecutar la 339prueba, vemos que getfollowingdayofweek devuelve el 25 de diciembre como siguiente sábado después del 25 de diciembre, un error evidente [g3], [t1]. vemos el problema en la línea 685. es un error de condición de límite típico [t5]. debería ser lo siguiente: 685 if (basedow >= targetweekday) { conviene destacar que esta función sufrió una reparación anterior. el historial de cambios (línea 43) muestra que se corrigieron los errores en getpreviousdayofweek , getfollowingdayofweek y getnearestdayofweek [t6]. la prueba de unidad testgetnearestdayofweek (línea 329), que prueba el método getnearestdayofweek (línea 705), inicialmente no era tan extensa y completa. añadí multitud de casos de prueba ya que los iniciales no se superaban [t6]. puede ver el patrón de fallos si se fija en los casos de prueba comentados. el patrón es revelador [t7]. muestra que el algoritmo falla si el día más próximo es de una fecha futura. evidentemente se trata de algún tipo de error de condición de límite [t5]. el patrón de alcance de las pruebas generado por clover también es interesante [t8]. la línea 719 nunca se ejecuta, lo que significa que la instrucción if de la línea 718 siempre es false , pero si nos fijamos en el código, indica que debe ser true . la variable adjust siempre es negativa y no puede ser mayor o igual a 4, por lo que el algoritmo es incorrecto. a continuación se muestra el algoritmo correcto: int delta = targetdow - base.getdayofweek(); int positivedelta = delta + 7; int adjust = positivedelta % 7; if (adjust > 3) adjust -= 7; return serialdate.adddays (adjust, base); por último, las pruebas de la líneas 417 y 429 se pueden superar si se genera illegalargumentexception en lugar de devolver una cadena de error desde weekinmonthtostring y relativetostring . con estos cambios, todas las pruebas de unidad se superan y creo que ahora serialdate funciona. llega el momento de hacer que sea correcta. 340hacer que sea correcta describiremos serialdate de arriba a abajo para mejorarla en nuestro recorrido. aunque no lo veamos en este análisis, ejecutaré todas las pruebas de unidad de jcommon , incluida mi prueba de unidad mejorada para serialdate , con todos los cambios efectuados. por ello, tenga la seguridad de que todos los cambios que vea funcionan para jcommon . en la línea 1 vemos abundantes comentarios sobre información de licencia, derechos de autor, autores e historial de cambios. asumo que hay ciertos aspectos legales que mostrar, por lo que los derechos de autor y las licencias deben conservarse. por otra parte, el historial de cambios es una rémora de la década de 1960. ahora tenemos herramientas de control de código fuente que se encargan de ello. hay que eliminar este historial [c1]. la lista de importación que comienza en la línea 61 se puede reducir por medio de java.text.* y java.util.* . [j1] no me convence el formato html del javadoc (línea 67). un archivo fuente con más de un lenguaje me parece un problema. este comentario tiene cuatro lenguajes: java, español, javadoc y html [g1]. con tantos lenguajes se hace difícil mantener la coherencia. por ejemplo, la ubicación de las líneas 71 y 72 se pierde al generar el javadoc y además, ¿quién quiere ver <ul> y <li> en el código fuente? una estrategia más acertada consiste en rodear el comentario con <pre> para que el formato del código fuente se conserve en el javadoc [96] . la línea 86 es la declaración de la clase. ¿por qué se le asigna el nombre serialdate ? ¿qué sentido tiene la palabra serial ? ¿es porque la clase se deriva de serializable ? parece improbable. basta de adivinanzas. sé por qué (o al menos eso creo) se usa la palabra serial . la clave se encuentra en las constantes serial_lower_bound y serial_upper_bound de las líneas 98 y 101. y una clave todavía mejor es el comentario de la línea 830. el nombre de la clase es serialdate ya que se implementa con un número de serie, que parece ser el número de días desde el 30 de diciembre de 1899. 341pero esto supone un problema. por un lado, el término «número de serie» no es realmente correcto. puede ser un detalle menor pero la representación es más un desplazamiento relativo que un número de serie. el término «número de serie» tiene que ver más con marcadores de identificación de productos que con fechas. por ello, no lo considero especialmente descriptivo [n1]. un término más descriptivo sería «ordinal». el segundo problema es más significativo. el nombre serialdate implica una implementación. esta clase es abstracta. no es necesario que implique nada sobre la implementación; de hecho, es aconsejable ocultarla. por ello, creo que el nombre se encuentra en un nivel de abstracción incorrecto [n2]. en mi opinión, el nombre de esta clase debería ser simplemente date . desafortunadamente, hay demasiadas clases con el nombre date en la biblioteca de java, de modo que no es el más adecuado. como esta clase trabaja con días y no horas, podríamos usar day , pero ya se usa en otros muchos puntos. al final, opté por daydate como mejor opción. a partir de ahora, usaremos daydate . recuerde que los listados que va a leer siguen usando serialdate . entiendo porque daydate se hereda de comparable y serializable . ¿pero de monthconstants ? la clase monthconstants (véase el listado b-3) es una serie de constantes finales estáticas que definen los meses. heredar de clases con constantes es un viejo truco que los programadores de java usan para evitar expresiones como monthconstants.january , pero es una mala idea [j2]. monthconstants debería ser una enumeración. public abstract class daydate implements comparable, serializable { public static enum month { january(1), february(2), march(3), april(4), may(5), june(6), july(7), august(8), september(9), october(10), november(11), december(12); 342month(int index) { this.index = index; } public static month make(int monthindex) { for (month m : month.values()) { if (m.index == monthindex) return m; } throw new illegalargumentexception(“invalid month index ” + monthindex); } public final int index; } al cambiar monthconstants por esta enumeración se modifica la clase daydate y todos sus usuarios. tardé una hora en realizar todos los cambios. sin embargo, las funciones que antes aceptaban un valor int para el mes, ahora aceptan un enumerador month . esto significa que podemos deshacernos del método isvalidmonthcode (línea 326) y de la comprobación de errores del código de los meses como en monthcodetoquarter (línea 356) [g5]. tras ello, en la línea 91, tenemos serialversionuid . esta variable se usa para controlar el señalizador. si la cambiamos, con lo que todos los elementos daydate escritos con una versión antigua del software serán ilegibles y se generará invalidclassexception . si no declara la variable serialversionuid , el compilador genera una automáticamente y será diferente cada vez que modifique el módulo. ya sé que todos los documentos recomiendan el control manual de esta variable, pero creo que el control automático de la señalización es más seguro [g4]. después de todo, prefiero depurar una invalidclassexception que el extraño comportamiento que se produciría si me olvido de cambiar serialversionuid . por ello, eliminaré la variable, al menos por ahora [97] . creo que el comentario de la línea 93 es redundante. los comentarios redundantes sólo sirven para acumular mentiras y desinformación [c2]. por ello los eliminaré. los comentarios de las líneas 97 y 100 hablan sobre números de serie, que ya hemos mencionado antes [c1]. las variables que describen son la primera y última fecha posible que daydate puede describir. podríamos hacer que fuera más claro [n1]. 343public static final int earliest_date_ordinal = 2; // 1/1/1900 public static final int latest_date_ordinal = 2958465; // 12/31/9999 desconozco por qué earliest_date_ordinal es 2 en lugar de 0. el comentario de la línea 829 sugiere que tiene que ver con la forma de representar fechas en microsoft excel. hay información mucho más completa en una variante de daydate : spreadsheetdate (véase el listado b-5). el comentario de la línea 71 describe este problema. el problema parece relacionado con la implementación de spreadsheetdate y no con daydate . mi conclusión es que earliest_date_ordinal y latest_date_ordinal no pertenecen a daydate y deberían cambiarse a spreadsheetdate [g6]. de hecho, una búsqueda en el código demuestra que estas variables sólo se usan en spreadsheetdate . ni en daydate , ni en otras clases de la estructura jcommon. por lo tanto, las cambio por spreadsheetdate . las siguientes variables, minimum_year_supported y maximum_year_supported (líneas 104 y 107), constituyen un dilema. parece evidente que si daydate es una clase abstracta que no dice nada sobre implementación, no debería informarnos de un año mínimo o máximo. de nuevo, siento la necesidad de cambiar las variables a spreadsheetdate [g6]. pero una búsqueda rápida de los usuarios de estas variables muestra que otra clase las utiliza: relativedayofweekrule (véase el listado b-6), vemos dicho uso en las líneas 177 y 178, en la función getdate , donde se usan para comprobar que el argumento de getdate sea un año válido. el dilema es que un usuario de una clase abstracta necesita información sobre su implementación. tendremos que proporcionar esta información sin contaminar daydate . por lo general, obtendríamos la información de implementación de una instancia de una variante. sin embargo, la función getdate no recibe una instancia de daydate , aunque sí la devuelve, lo que significa que debe crearla en alguna parte. la solución está en las líneas 187-205. la instancia daydate se crea por medio de una de estas tres funciones: getpreviousdayofweek , getnearestdayofweek o getfollowingdayofweek . si nos fijamos en el 344listado daydate , vemos que estas funciones (líneas 638-724) devuelven una fecha creada por adddays (línea 571), que invoca createinstance (línea 808), que crea spreadsheetdate [g7]. no es recomendable que las clases base conozcan sus variantes. para corregirlo, debemos usar el patrón de factoría abstracta [98] y crear daydatefactory . esta factoría creará las instancias de daydate que necesitamos y también responderá a preguntas sobre la implementación, como las fechas máxima y mínima. public abstract class daydatefactory { private static daydatefactory factory = new spreadsheetdatefactory(); public static void set instance(daydatefactory factory) { daydatefactory.factory = factory; } protected abstract daydate _makedate(int ordinal); protected abstract daydate _makedate(int day, daydate.month month, int year); protected abstract daydate _makedate(int day, int month, int year); protected abstract daydate _makedate(java.util.date date); protected abstract int _getminimumyear(); protected abstract int _getmaximumyear(); public static daydate makedate(int ordinal) { return factory._makedate(ordinal); } public static daydate makedate(int day, daydate.month month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(int day, int month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(java.util.date date) { return factory._makedate(date); } public static int getminimumyear() { return factory._getminimumyear(); } public static int getmaximumyear() { return factory._getmaximumyear(); } } esta clase de factoría sustituye los métodos createinstance por métodos 345makedate , lo que mejora ligeramente los nombres [n1]. de forma predeterminada es spreadsheetdatefactory pero se puede cambiar por otra factoría. los métodos estáticos delegados en métodos abstractos usan una combinación de los patrones de instancia única [99] , decorador [100] y factoría abstracta que considero muy útil. spreadsheetdatefactory tiene este aspecto: public class spreadsheetdatefactory extends daydatefactory { public daydate _makedate(int ordinal) { return new spreadsheetdate(ordinal); } public daydate _makedate(int day, daydate.month month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(int day, int month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(date date) { final gregoriancalendar calendar = new gregoriancalendar(); calendar.settime(date); return new spreadsheetdate( calendar.get(calendar.date), daydate.month.make(calendar.get(calendar.month) + 1), calendar.get(calendar.year)); } protected int _getminimumyear() { return spreadsheetdate.minimum_year_supported; } protected int _getmaximumyear() { return spreadsheetdate.maximum_year_supported; } } como puede apreciar, hemos enviado las variables minimum_year_supported y maximum_year_supported a spreadsheetdate , donde pertenecen [g6]. el siguiente problema de daydate son las constantes de días, comenzando en la línea 109. deberían ser otra enumeración [j3]. ya hemos visto este patrón, de modo que no lo repetiremos. se incluye en los listados definitivos. seguidamente, vemos una serie de tablas que comienzan en last_day_of_month (línea 140). el primer problema con estas tablas es que 346los comentarios que las describen son redundantes [c3]. basta con sus nombres, de modo que eliminamos los comentarios. no hay motivos para que la tabla no sea privada [g8], ya que existe una función estática lastdayofmonth que proporciona los mismos datos. la siguiente tabla, aggregate_days_to_end_of_month , es más misteriosa, ya que no se usa en ninguna parte de la estructura jcommon [g9], de modo que la elimino. lo mismo sucede con leap_year_aggregate_days_to_end_of_month . la siguiente tabla, aggregate_days_to_end_of_preceding_month , sólo se usa en spreadsheetdate (líneas 434 y 473), lo que me hace dudar si transferirla a spreadsheetdate . la razón de no cambiarla es que la tabla no es específica de ninguna implementación concreta [g6]. por otra parte, sólo existe la implementación spreadsheetdate , de modo que la tabla debe acercarse a donde se vaya a usar [g10], para zanjar la duda y ser coherentes [g11], deberíamos privatizar la tabla y mostrarla a través de una función como juliandateoflastdayofmonth . pero nadie parece que la necesita. es más, la tabla se puede cambiar a daydate si una nueva implementación de daydate la necesita. así que la cambiamos. lo mismo sucede con leap_year_aggregate_days_to_end_of_month . tras ello, vemos tres grupos de constantes que se pueden convertir en enumeraciones (líneas 162-205). la primera selecciona una semana de un mes. la transformo en la enumeración weekinmonth . public enum weekinmonth { first(1), second(2), third(3), fourth(4), last(0); public final int index; weekinmonth(int index) { this.index = index; } } el segundo grupo de constantes (líneas 177-187) es más complicado. las constantes include_none, include_first, include_second e include_both se usan para describir si las fechas finales de un intervalo deben incluirse en el mismo. matemáticamente, se describe como intervalo 347abierto, intervalo a medio abrir e intervalo cerrado. creo que resulta más claro con la nomenclatura matemática [n3], de modo que lo cambio por la enumeración dateinterval con los enumeradores closed, closed_left, closed_right y open . el tercer grupo de constantes (líneas 18-205) describen si la búsqueda de un día concreto de la semana devuelve la última instancia, la siguiente o la más próxima. decidir un nombre adecuado es complicado. al final, opté por weekdayrange con los enumeradores last, next y nearest . puede que no esté de acuerdo con los nombres elegidos. para mí tienen sentido. lo importante es que ahora son más fáciles de cambiar [j3]. ya no se pasan como enteros, sino como símbolos. puedo usar la función de cambio de nombre de mi ide para cambiar los nombres o los tipos sin preocuparme de haberme olvidado de un -1 o un 2 en alguna parte del código o de que la declaración de un argumento int no estén bien descrita. el campo de descripción de la línea 208 no parece que se use en ninguna parte. lo elimino junto a sus elementos de acceso y mutación [g9]. también elimino el constructor predeterminado de la línea 213 [g12]. el compilador se encargará de generarlo. podemos ignorar el método isvalidweekdaycode (líneas 216-238) ya que lo eliminamos al crear la enumeración day . llegamos al método stringtoweekdaycode (líneas 242-270). los javadoc que no suponen demasiado para la firma del método sobran [c3], [g12]. el único valor de este javadoc es la descripción del valor devuelto -1 . sin embargo, como cambiamos a la enumeración day , el comentario es en realidad incorrecto [c2]. ahora el método genera illegalargumentexception . por ello, eliminamos el javadoc. también elimino las palabras clave final de argumentos y declaraciones de variables, ya que no parecen servir de mucho [g12]. la eliminación de final no goza de gran aceptación. por ejemplo, robert simmons [101] recomienda «… diseminar final por la totalidad del código». no estoy de acuerdo. creo que existen casos para usar final , por ejemplo como constante ocasional, pero en general, esta palabra clave apenas añade valor y suele ser 348un estorbo. puede que lo piense porque el tipo de errores que puede capturar final ya se capturan en las pruebas de unidad que he creado. las instrucciones if duplicadas [g5] del bucle for (líneas 259 y 263) son irrelevantes, de modo que las conecté en una única instrucción if con el operador || . también usé la enumeración day para dirigir el bucle for y realicé otros cambios estéticos. este método no pertenece realmente a daydate . en realidad es la función de análisis de day . por lo tanto, lo cambié a la enumeración day , lo que hizo que aumentara considerablemente de tamaño. como el concepto de day no depende de daydate , extraje la enumeración day de la clase daydate a un archivo propio [g13]. también cambié la siguiente función, weekdaycodetostring (líneas 272-286) a la enumeración day y le asigné el nombre tostring . public enum day { monday(calendar.monday), tuesday(calendar.tuesday), wednesday(calendar.wednesday), thursday(calendar.thursday), friday(calendar.friday), saturday(calendar.saturday), sunday(calendar.sunday); public final int index; private static dateformatsymbols datesymbols = new dateformatsymbols(); day(int day) { index = day; } public static day make(int index) throws illegalargumentexception { for (day d : day.values()) if (d.index == index) return d; throw new illegalargumentexception( string.format(“illegal day index: %d.”, index)); } public static day parse(string s) throws illegalargumentexception { string[] shortweekdaynames = datesymbols.getshortweekdays(); string[] weekdaynames = datesymbols.getweekdays(); s = s.trim(); for (day day : day.values()) { 349if (s.equalsignorecase(shortweekdaynames[day.index]) || s.equalsignorecase(weekdaynames[day.index])) { return day; } } throw new illegalargumentexception( string.format(“%s is not a valid weekday string”, s)); } public string tostring() { return datesymbols.getweekdays()[index]; } } hay dos funciones getmonths (líneas 288-316). la primera invoca la segunda. la segunda solamente se invoca desde la primera. por ello, las he combinado en una y las he simplificado considerablemente [g9], [g12], [f4]. por último, he cambiado el nombre por otro más descriptivo [n1]. public static string[] getmonthnames() { return dateformatsymbols.getmonths(); } la función isvalidmonthcode (líneas 326-346) es ahora irrelevante gracias a la enumeración month , de modo que la elimino [g9]. la función monthcodetoquarter (líneas 356-375) parece sufrir envidia de las características [102] [g14] y seguramente pertenezca a la enumeración month como método quarter , motivo por el que la sustituyo. public int quarter() { return 1 + (index-1)/3; } de este modo, la enumeración month tiene tamaño suficiente como para estar en una clase propia. la extraigo de daydate para mantener la coherencia con la enumeración day [g11], [g13]. los dos siguientes métodos tienen el nombre monthcodetostring (líneas 377-426). vemos de nuevo que uno invoca al otro con un indicador. no es recomendable pasar un indicador como argumento de una función, en especial si dicho indicador sólo selecciona el formato del resultado [g15]. por tanto, cambio de nombre, simplifico y reestructuro estas funciones y las incluyo en la enumeración month [n1], [n3], [c3], [g14]. public string tostring() { return dateformatsymbols.getmonths()[index - 1]; 350} public string toshortstring() { return dateformatsymbols.getshortmonths()[index – 1]; } el siguiente método es stringtomonthcode (líneas 428-472). lo cambio de nombre, lo paso a la enumeración month y lo simplifico [n1], [n3], [c3], [g14], [g12]. public static month parse(string s) { s = s.trim(); for (month m : month.values()) if (m.matches(s)) return m; try { return make(integer.parseint(s)); } catch (numberformatexception e) {} throw new illegalargumentexception(“invalid month ” + s); } private boolean matches(string a) { return s.equalsignorecase(tostring()) || s.equalsignorecase(toshortstring()); } el método isleapyear (líneas 495-517) se puede modificar para que sea más expresivo [g16]. public static boolean isleapyear(int year) { boolean fourth = year % 4 == 0; boolean hundredth = year % 100 == 0; boolean fourhundredth = year % 400 == 0; return fourth && (!hundredth || fourhundredth); } la siguiente función, leapyearcount (líneas 519-536) no pertenece realmente a daydate . nadie la invoca, excepto los dos métodos de spreadsheetdate , de modo que la desplazo hacia abajo [g6]. la función lastdayofmonth (líneas 538-560) usa la matriz last_day_of_month , que en realidad pertenece a la enumeración month [g17], por lo que la cambio de ubicación. también simplifico la función y aumento su expresividad [g16]. public static int lastdayofmonth(month month, int year) { if (month == month.february && isleapyear(year)) return month.lastday() + 1; else 351return month.lastday(); } ahora empieza a ponerse interesante. la siguiente función es adddays (líneas 562-576). en primer lugar, como opera en las variables de daydate , no debería ser estática [g18]. la cambio por un método de instancia. por otra parte, invoca la función toserial , cuyo nombre deberíamos cambiar por toordinal [n1]. por último, el método se puede simplificar. public daydate adddays(int days) { return daydatefactory.makedate(toordinal() + days); } lo mismo sucede con addmonths (líneas 578-602). debería ser un método de instancia [g18]. el algoritmo es un tanto complicado, de modo que recurro a la explicación de variables temporales [103] [g19] para que sea más transparente. también cambio el nombre del método getyyy por getyear [n1]. public daydate addmonths(int months) { int thismonthasordinal = 12 * getyear() + getmonth().index - 1; int resultmonthasordinal = thismonthasordinal + months; int resultyear = resultmonthasordinal / 12; month resultmonth = month.make(resultmonthasordinal % 12 + 1); int lastdayofresultmonth = lastdayofmonth(resultmonth, resultyear); int resultday = math.min(getdayofmonth(), lastdayofresultmonth); return daydatefactory.makedate(resultday, resultmonth, resultyear); } la función addyears (líneas 604-626) es similar al resto. public daydate plusyears(int years) { int resultyear = getyear() + years; int lastdayofmonthinresultyear = lastdayofmonth(getmonth(), resultyear); int resultday = math.min(getdayofmonth(), lastdayofmonthinresultyear); return daydatefactory.makedate(resultday, getmonth(), resultyear); } hay algo que me preocupa sobre el cambio de estos métodos de estáticos a métodos de instancia. ¿la expresión date.adddays(5) aclara que el objeto date no cambia y que se devuelve una nueva instancia de daydate o se supone, equivocadamente, que se añaden cinco días al objeto date ? pensará que no es un gran problema, pero un fragmento de código como el siguiente puede ser muy engañoso [g20]. daydate date = datefactory.makedate(5, month.december, 1952); date.adddays(7); // desplazar la fecha una semana 352un lector de este código podría aceptar que adddays cambia el objeto date , de modo que necesitamos un nombre que acabe con la ambigüedad [n4]: plusdays y plusmonths . creo que la intención del método se captura correctamente por medio de daydate date = olddate.plusdays(5); mientras que el siguiente no transmite con fluidez al lector que el objeto date ha cambiado: date.plusdays(5); los algoritmos son cada vez más interesantes. getpreviousdayofweek (líneas 628-660) funciona pero es complicado. tras meditar en lo que sucedía [g21], pude simplificarlo y aplicar la explicación de variables temporales [g19] para aclarar su significado. también lo cambié de método estático a método de instancia [g18] y me deshice del método de instancia duplicado [g5] (líneas 997-1008). public daydate getpreviousdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index = getdayofweek().index; if (offsettotarget >= 0) offsettotarget - 7; return plusdays(offsettotarget); } sucede exactamente lo mismo con getfollowingdayofweek (líneas 662-693). public daydate getfollowingdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index - getdayofweek().index; if (offsettotarget <= 0) offsettotarget += 7; return plusdays(offsettotarget); } la siguiente función es getnearestdayofweek (líneas 695-726), que corregimos en un apartado anterior. pero esos cambios no son coherentes con el patrón actual de las dos últimas funciones [g11]. por ello, recurro a la explicación de variables temporales [g19] para aclarar el algoritmo. public daydate getnearestdayofweek(final day targetday) { int offsettothisweekstarget = targetday.index - getdayofweek().index; int offsettofuturetarget = (offsettothisweekstarget + 7) % 7; int offsettoprevioustarget = offsettofuturetarget - 7; if (offsettofuturetarget > 3) 353return plusdays(offsettoprevioustarget); else return plusdays(offsettofuturetarget); } el método getendofcurrentmonth (líneas 728-740) es un tanto extraño ya que es un método de instancia que envidia [g14] a su propia clase aceptado un argumento daydate . lo convierto en un verdadero método de instancia y clarifico algunos de los nombres. public daydate getendofmonth() { month month = getmonth(); int year = getyear(); int lastday = lastdayofmonth(month, year); return daydatefactory.makedate(lastday, month, year); } la refactorización de weekinmonthtostring (líneas 742-761) resultó ser muy interesante. mediante las herramientas de refactorización de mi ide, primero cambié el método a la enumeración weekinmonth creada antes y después cambié el nombre por tostring . tras ello, lo convertí en método de instancia. todas las pruebas fueron correctas (¿adivina hacia dónde nos dirigimos?). seguidamente, eliminé el método. fallaron cinco afirmaciones (líneas 411-415 del listado b-4). cambié estas líneas para usar los nombres de los enumeradores ( first , second , etc.). las pruebas fueron correctas. ¿ve por qué? ¿puede ver también por qué son necesarios estos pasos? la herramienta de refactorización se encargó de que los invocadores anteriores de weekinmonthtostring invocaran ahora tostring en el enumerador weekinmonth ya que todos los enumeradores implementan tostring para devolver sus nombres… desafortunadamente, me pasé de listo. a pesar de la elegancia de la cadena de refactorización, comprobé que los únicos usuarios de esta función eran las pruebas que acababa de modificar, de modo que las eliminé. así pues, tras determinar que sólo las pruebas invocaban relativetostring (líneas 765-781), eliminé directamente la función y sus pruebas. hemos llegado a los métodos abstractos de esta clase abstracta. y el primero es toserial (líneas 838-844). en un apartado anterior cambié el nombre por toordinal . al verlo en este contexto, decidí que el cambio de 354nombre debería ser por getordinalday . el siguiente método abstracto es todate (líneas 838-844). convierte daydate en java.util.date . ¿por qué es abstracto? si analizamos su implementación en spreadsheetdate (líneas 198-207 del listado b-5), vemos que no depende de la implementación de esa clase [g6]. por tanto, lo desplazo hacia arriba. los métodos getyyyy , getmonth y getdayofmonth son evidentemente abstractos. sin embargo, getdayofweek debería ascender desde spreadsheetdate ya que no depende de nada de lo que encontremos en daydate [g6]. ¿o sí? si se fija atentamente (línea 247 del listado b-5), verá que el algoritmo depende implícitamente del origen del día ordinal (es decir, el día de la semana del día 0). por ello, aunque esta función carezca de dependencias físicas que no se puedan cambiar a daydate , cuenta con una dependencia lógica. este tipo de dependencias lógicas me molestan [g22]. si algo lógico depende de la implementación, también debería haber algo físico. además, me parece que el propio algoritmo podría ser genérico y que debería depender en menor medida de la implementación [g6]. por tanto, creé un método abstracto en daydate con el nombre getdayofweekforordinalzero y lo implementé en spreadsheetdate para devolver day.saturday . tras ello, envié el método getdayofweek a daydate y lo cambié para que invocara getordinalday y getdayofweekforordinalzero . public day getdayofweek() { day startingday = getdayofweekforordinalzero(); int startingoffset = startingday.index - day.sunday.index; return day.make((getordinalday() + startingoffset) % 7 + 1); } fíjese en el comentario de las líneas 895-899. ¿necesitamos realmente esta repetición? como de costumbre, eliminé este comentario junto a los demás. el siguiente método es compare (líneas 902-913). de nuevo, es incorrectamente abstracto [g6], por lo que cambio la implementación a daydate . además, el nombre no es descriptivo [n1]. en realidad, este método devuelve la diferencia en días desde el argumento, por lo que cambié el nombre por dayssince . tampoco existían pruebas para este método, de 355modo que las creé. las seis siguientes funciones (líneas 915-980) son métodos abstractos que deben implementarse en daydate , por lo que las extraje de spreadsheetdate . la última función, isinrange (líneas 982-995), también debe extraerse y refactorizarse. la instrucción switch no es agradable [g23] y se puede modificar si enviamos los casos a la enumeración dateinterval . public enum dateinterval { open { public boolean isin(int d, int left, int right) { return d > left && d < right; } }, closed_left { public boolean isin(int d, int left, int right) { return d >= left && d < right; } }, closed_right { public boolean isin(int d, int left, int right) { return d > left && d <= right; } }, closed { public boolean isin(int d, int left, int right) { return d >= left && d <= right; } }; public abstract boolean isin(int d, int left, int right); } public boolean isinrange(daydate d1, daydate d2, dateinterval interval) { int left = math.min(d1.getordinalday(), d2.getordinalday()); int right = math.max(d1.getordinalday(), d2.getordinalday()); return interval.isin(getordinalday(), left, right); } con esto llegamos al final de daydate . realizaremos una nueva pasada por la clase completa para comprobar cómo fluye. primero, el comentario inicial está desfasado, de modo que lo reduzco y lo mejoro [c2]. tras ello, desplazo las enumeraciones restantes a sus propios archivos [g12]. seguidamente, desplazo la variable estática ( dateformatsymbols ) y tres métodos estáticos ( getmonthnames , isleapyear , lastdayofmonth ) a una nueva clase con el nombre dateutil [g6]. 356cambio los métodos abstractos a una posición superior, donde pertenecen [g24]. cambio month.make por month.fromint [n1] y repito la operación con las demás enumeraciones. también creo un método de acceso toint() para todas las enumeraciones y convierto en privado el campo index . se produce una interesante duplicación [g5] en plusyears y plusmonths que conseguí eliminar extrayendo un nuevo método con el nombre correctlastdayofmonth , lo que aclaraba el significado de los tres métodos. me deshice del número mágico 1 [g25] y lo sustituí por month.january.toint() o day.sunday.toint() , según el caso. me detuve en limpiar los algoritmos de spreadsheetdate . el resultado final se puede comprobar en los listados b.7 a b.16. el alcance del código en daydate se ha reducido al 84.9 por 100, no porque se pruebe una cantidad menor de funcionalidad, sino porque la clase se ha reducido tanto que las líneas sin alcance tienen un peso mayor. ahora, en daydate las pruebas se aplican a 45 de las 53 instrucciones ejecutables. las líneas sin alcance son tan triviales que no merece la pena probarlas. conclusión otra vez hemos aplicado la regla del boy scout. hemos entregado el código más limpio de lo que lo recibimos. nos ha llevado tiempo, pero ha merecido la pena. el alcance de las pruebas ha aumentado, hemos corregido algunos errores y hemos aclarado y reducido el tamaño del código. la próxima persona que lo lea seguramente lo encontrará más fácil de leer. y probablemente esa persona sea capaz de limpiarlo algo más de lo que hemos hecho nosotros. bibliografía [gof] : design patterns: elements of reusable object oriented 357software , gamma et al., addison-wesley, 1996. [simmons04] : hardcore java , robert simmons, jr., o’reilly, 2004. [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. [beck97] : smalltalk best practice patterns , kent beck, prentice hall, 1997. 35817 síntomas y heurística en su magnífico libro refactoring [104] , martin fowler identifica diversos síntomas de código ( smells ). la lista que mostramos a continuación incluye muchos de los síntomas de martin y otros propios. también contiene otras perlas y heurística que suelo emplear en mi trabajo. 359para compilar esta lista he examinado diversos programas y los he refactorizado. al aplicar un cambio, me preguntaba el por qué y anotaba el motivo. el resultado es una extensa lista de aspectos que no me «huelen» bien cuando leo código. la lista se debe leer de arriba a abajo, y también se puede usar como referencia. comentarios c1: información inapropiada no es apropiado que un comentario contenga información que se pueda almacenar en otro tipo de sistema como un sistema de control de código fuente, de seguimiento de problemas o de mantenimiento de registros. los historiales de cambios, por ejemplo, abarrotan los archivos de código con abundante texto sin interés alguno. por lo general, metadatos como autores, fechas de modificación, números spr y similares no deben aparecer en los comentarios. los comentarios deben reservarse para notas técnicas sobre el código y el diseño. c2: comentario obsoleto un comentario anticuado, irrelevante e incorrecto es obsoleto. los comentarios envejecen rápidamente. es recomendable no escribir un comentario que vaya a quedar obsoleto. si detecta un comentario obsoleto, conviene actualizarlo o eliminarlo lo antes posible. los comentarios obsoletos tienden a alejarse del código que describían. se convierten en islas de irrelevancia y desorientación en el código. c3: comentario redundante un comentario es redundante si describe algo que ya se define correctamente 360por sí mismo. por ejemplo: i++; // incrementar i otro ejemplo es un javadoc que no dice más (o incluso menos) que la firma de una función: /** * @param sellrequest * @return * @throws managedcomponentexception */ public sellresponse beginsellitem(sellrequest sellrequest) throws managedcomponentexception los comentarios deben comunicar lo que el código no pueda expresar por sí mismo. c4: comentario mal escrito un comentario que merezca la pena escribir merece la pena ser leído. si piensa escribir un comentario, asegúrese de que es el mejor que puede crear. elija las palabras con atención. use gramática y puntuación correctas. no divague. no afirme lo evidente. sea breve. c5: código comentado me molesta ver grandes fragmentos de código comentado. ¿quién sabe qué antigüedad tienen? ¿quién sabe si tiene sentido o no? pero nadie lo borra porque piensa que alguien más lo necesita. ese código se estanca y se corrompe, y cada día que pasa es menos relevante. invoca funciones que ya no existen. usa variables cuyos nombres han cambiado. se rige por convenciones obsoletas. contamina los módulos en los que aparece y distrae a los usuarios que lo leen. el código comentado es una aberración. cuando vea código comentado, elimínelo. no se preocupe, el sistema de control de código fuente lo recordará. si alguien lo necesita, puede consultar una versión anterior. no sufra el código comentado para sobrevivir. 361entorno e1: la generación requiere más de un paso la generación de un proyecto debería ser una operación sencilla. no debería tener que comprobar demasiados elementos del control de código fuente. no debería necesitar una secuencia de antiguos comandos ni secuencias de comandos dependientes del contexto para generar cada elemento. no debería tener que buscar los distintos archivos jar, xml y similares necesarios para el sistema. debería finalizar el sistema con un sencillo comando y después ejecutar otro igual de sencillo para generarlo. svn get mysystem cd mysystem ant all e2: las pruebas requieren más de un paso debería poder ejecutar todas las pruebas de unidad con un solo comando. en el mejor de los casos, debería poder ejecutarlas pulsando un botón de su ide. en el peor, debería poder ejecutar un único comando en una línea de comandos. la capacidad de ejecutar todas las pruebas es tan importante que debe ser algo rápido, sencillo y obvio. funciones f1: demasiados argumentos las funciones deben tener un número reducido de argumentos. lo mejor es que no tengan, seguido de uno, dos y tres argumentos. más de tres ya es cuestionable y debería evitarse (véase el capítulo 3). 362f2: argumentos de salida los argumentos de salida son ilógicos. el lector espera que los argumentos sean entradas, no salidas. si su función tiene que cambiar el estado de algo, haga que cambie el estado del objeto en el que se invoca (véase el capítulo 3). f3: argumentos de indicador los argumentos booleanos declaran abiertamente que la función hace más de una cosa. resultan confusos y deben eliminarse (véase el capítulo 3). f4: función muerta los métodos que nunca se invocan deben descartarse. la presencia de código muerto es innecesaria. no tema eliminar la función. su sistema de control de código fuente la recordará. general g1: varios lenguajes en un archivo de código los modernos entornos de programación actuales permiten incluir varios lenguajes diferentes en el mismo archivo de código. por ejemplo, un archivo de java puede contener fragmentos de xml, html, yaml, javadoc, javascript, y similares. además de html, un archivo jsp podría incluir java, sintaxis de biblioteca de etiquetas, comentarios en español, javadoc, xml, javascript, etc. resulta confuso en el mejor de los casos y un desastre en el peor. lo ideal sería que el archivo de código incluyera un solo lenguaje pero, en realidad, seguramente tendremos que usar más de uno. debemos intentar minimizar la cantidad y el alcance de los lenguajes adicionales en nuestros 363archivos de código. g2: comportamiento evidente no implementado de acuerdo al principio de la mínima sorpresa [105] , una función o clase debe implementar los comportamientos que otro programador esperaría. por ejemplo, imagine una función que traduce el nombre de un día en una enumeración que represente dicho día. day day = daydate.stringtoday(string dayname); esperaríamos que la cadena « monday » se tradujera en day.monday. también esperaríamos la traducción de las abreviaturas habituales y que la función ignorara mayúsculas y minúsculas. cuando un comportamiento obvio no se implementa, los lectores y usuarios del código ya no dependen de su intuición sobre los nombres de las funciones. pierden su confianza en el autor original y se ven obligados a leer los detalles del código. g3: comportamiento incorrecto en los límites parece evidente afirmar que el código debe comportarse de forma correcta. el problema es que no nos damos cuenta de lo complicado que es dicho comportamiento correcto. los programadores suelen crear funciones que esperan que funcionen y confían en su intuición más que en comprobar que el código funciona en todos los casos de límites. no existe sustituto para la meticulosidad. las condiciones de límite, los casos extremos, las excepciones, representan algo que puede confundir a un algoritmo elegante e intuitivo. no dependa de su intuición . busque todas las condiciones de límite y cree pruebas para cada una. g4: medidas de seguridad canceladas chernobyl se derritió porque el director de la central ignoró todos y cada uno de los mecanismos de seguridad. impedían que se realizara un experimento. 364el resultado fue que el experimento no salió bien y el mundo fue testigo de la primera gran catástrofe nuclear para la población. anular las medidas de seguridad es un riesgo. puede que sea necesario ejercer el control manual sobre serialversionuid pero siempre es arriesgado. la desactivación de determinadas advertencias del compilador (o de todas) puede ayudarle a conseguir la generación, pero corre el riesgo de sufrir interminables sesiones de depuración. desactivar las pruebas que fallan y convencerse de que conseguirá que después sean satisfactorias es tan erróneo como pensar que sus tarjetas de crédito son dinero gratuito. g5: duplicación una de las reglas más importantes del libro y que debe tomarse muy en serio. la práctica totalidad de los autores que escriben sobre diseño de software mencionan esta regla. dave thomas y andy hunt la denominaron principio dry [106] ( don't repeat yourself , no repetirse). kent beck la convirtió en uno de los principios fundamentales de la programación extreme y la denominó «una sola vez». ron jeffries sitúa esta regla en segunda posición, por debajo de la consecución satisfactoria de todas las pruebas. siempre que vea duplicados en el código, indican una oportunidad de abstracción fallida. la duplicación podría convertirse en una subrutina o en otra clase. al incluir la duplicación en una abstracción, aumenta el vocabulario del lenguaje del diseño. otros programadores pueden usar sus creaciones abstractas. el código se vuelve más rápido y menos proclive a errores ya que ha aumentado el nivel de abstracción. el caso más evidente de duplicación es la presencia de fragmentos de código idéntico que parecen pegados repetidamente por el programador, sin sentido. conviene reemplazarlos por métodos simples. una forma más sutil es la cadena switch/case o if/else que aparece repetidamente en diversos módulos y que siempre prueba las mismas condiciones. conviene reemplazar estas cadenas por polimorfismo. y más sutiles todavía son los módulos con algoritmos similares pero que no comparten las mismas líneas de código. sigue siendo duplicación y debe 365corregirse por medio del patrón de método de plantilla [107] o estrategia [108] . en realidad, la mayoría de patrones de diseño aparecidos en los últimos 15 años son formas de eliminar la duplicación. las formas normales de codd también son una estrategia para eliminar la duplicación en esquemas de base de datos. incluso la programación orientada a objetos es una estrategia para organizar módulos y eliminar la duplicación. no debería sorprenderle, ya que se trata de programación estructurada. creo que el objetivo es evidente: localice los elementos duplicados y elimínelos siempre que pueda. g6: código en un nivel de abstracción incorrecto es importante crear abstracciones que separen conceptos generales de nivel superior de conceptos detallados de nivel inferior. para ello, en ocasiones creamos clases abstractas que contengan los conceptos de nivel superior y variantes los de nivel inferior. si lo hacemos, debemos asegurarnos de que la separación sea completa. todos los conceptos de nivel inferior deben estar en las variantes y los de nivel superior en la clase base. por ejemplo, constantes, variables o funciones de utilidad que solamente pertenezcan a la implementación detallada no deben aparecer en la clase base. la clase base no debe saber nada al respecto de estos elementos. esta regla también se aplica a archivos fuente, componentes y módulos. el diseño correcto de software requiere la separación de conceptos en distintos niveles y su inclusión en contenedores diferentes. en ocasiones, dichos contenedores son clases base o variantes, y en otros casos son archivos fuente, módulos o componentes. independientemente del caso, la separación debe ser completa. no queremos que conceptos de nivel inferior y superior se mezclen. fíjese en este código: public interface stack { object pop() throws emptyexception; void push(object o) throws fullexception; double percentfull(); class emptyexception extends exception {} class fullexception extends exception {} } la función percentfull se encuentra en el nivel de abstracción 366equivocado. aunque hay implementaciones de stack en las que el concepto de amplitud es razonable, otras no pueden conocer su nivel de amplitud. por tanto, la función debería incluirse en una interfaz derivada como boundedstack . pensará que la implementación podría devolver cero si la pila no tuviera límites. el problema es que no existen pilas totalmente sin límites. no se puede evitar outofmemoryexception mediante la comprobación de stack.percentfull() < 50.0. la implementación de esta función para que devuelva 0 sería una mentira. la moraleja es que no puede mentir o escapar de una abstracción mal ubicada. el aislamiento de abstracciones es una de las operaciones más complicadas para los desarrolladores de software y no se puede corregir cuando se realiza de forma incorrecta. g7: clases base que dependen de sus variantes el motivo más habitual para dividir conceptos en clases base y derivadas es para que los conceptos de nivel superior de la clase base sean independientes de los de nivel inferior de las derivadas. por ello, cuando vemos clases base que mencionan los nombres de sus variantes, se intuye un problema. por lo general, las clases base no deben saber nada sobre su derivadas. evidentemente, hay excepciones. en ocasiones, el número de variantes es fijo y la clase base tiene código que elegir entre las variantes. es muy habitual en implementaciones de equipos con estado finito. sin embargo, en ese caso las variantes y la clase base están íntimamente unidas y siempre se implementan en el mismo archivo jar. en el caso general, deben implementarse en archivos independientes. al implementar variantes y clases base en archivos diferentes y garantizar que los archivos de la clase base desconocen el contenido de los archivos de las variantes podemos implementar nuestros sistemas en componentes discretos e independientes. al modificar dichos componentes, se pueden volver a implementar sin necesidad de implementar de nuevo los componentes base. de este modo se reduce significativamente el impacto del 367cambio y se facilita el mantenimiento de los sistemas. g8: exceso de información los módulos bien definidos tienen interfaces reducidas que nos permiten hacer mucho con poco. los módulos definidos de forma incorrecta tienen interfaces más amplias que nos obligan a usar distintos gestos para realizar operaciones sencillas. una interfaz bien definida no ofrece demasiadas funciones y las conexiones son reducidas. una interfaz definida de forma incorrecta ofrece multitud de funciones que invocar y, por tanto, las conexiones son elevadas. los buenos programadores de software aprenden a limitar la parte de sus clases y módulos que muestran en sus interfaces. cuantos menos métodos tenga una clase, mejor. cuantas menos variables conozca una función, mejor. cuantas menos variables de instancia tenga una clase, mejor. oculte sus datos. oculte sus funciones de utilidad. oculte sus constantes y elementos temporales. no cree clases con multitud de métodos y variables de instancia. no cree multitud de variables y funciones protegidas para sus subclases. concéntrese en crear interfaces concisas y de tamaño reducido. limite la información para reducir las conexiones. g9: código muerto el código muerto es el que no se ejecuta. se encuentra en el cuerpo de una instrucción if que comprueba una condición que no sucede. se encuentra en el bloque catch de una instrucción try que carece de throws . se encuentra en pequeños métodos de utilidad que nunca se invocan o en condiciones switch/case inexistentes. el problema del código muerto es que con el tiempo empieza a oler. cuanto más antiguo es, más profundo el hedor que despide. se debe a que el código muerto no se actualiza al cambiar los diseños. sigue compilándose pero no se rige por nuevas convenciones o reglas. se creó en un momento en el que el sistema era diferente . debe tener un entierro digno. bórrelo del 368sistema. g10: separación vertical variables y funciones deben definirse cerca de donde se utilicen. las variables locales deben declararse por encima de su primer uso y deben tener un reducido ámbito vertical. no deben declararse a cientos de líneas de distancia de su uso. las funciones privadas deben definirse justo debajo de su primer uso. pertenecen al ámbito de la clase completa pero conviene limitar la distancia vertical entre las invocaciones y las definiciones. para localizar una función privada debe bastar con buscar debajo de su primer uso. g11: incoherencia si hace algo de una forma concreta, aplique la misma técnica a operaciones similares. esto entronca con el principio de mínima sorpresa. preste atención a las convenciones que elija y, una vez elegidas, asegúrese de mantenerlas. si en una función concreta usa la variable response para almacenar httpservletresponse , use el mismo nombre de variable en las demás funciones que usen objetos httpservletresponse . si asigna el nombre processverificationrequest a un método, use un nombre similar, como processdeletionrequest , para los métodos que procesen otros tipos de solicitudes. este tipo de coherencia, si se aplica repetidamente, facilita la lectura y modificación del código. g12: desorden ¿para qué sirve un constructor predeterminado sin implementación? únicamente desordena el código y lo inunda de elementos sin sentido. variables sin usar, funciones que nunca se invocan, comentarios que no añaden información, etc. todos estos elementos sobran y deben eliminarse. 369mantenga limpios sus archivos, bien organizados y sin elementos sobrantes. g13: conexiones artificiales los elementos que no dependen unos de otros no deben conectarse de forma artificial. por ejemplo, las enumeraciones generales no deben incluirse en clases más específicas ya que esto obliga a la aplicación a saber más sobre dichas clases. lo mismo sucede con funciones static de propósito general declaradas en clases específicas. por lo general, una conexión artificial es la que se establece entre dos módulos sin un propósito directo. es el resultado de incluir una variable, constante o función en una ubicación temporalmente útil pero inadecuada. es un síntoma de falta de atención. piense en dónde debe declarar sus funciones, constantes y variables. no las deje en el punto más cómodo. g14: envidia de las características uno de los síntomas de martin fowler [109] . los métodos de una clase deben interesarse por las variables y funciones de la clase a la que pertenecen, no por las variables y funciones de otras clases. cuando un método usa elementos de acceso y mutación de otro objeto para manipular los datos de éste, envidia el ámbito de la clase de dicho objeto. desea formar parte de la otra clase para tener acceso directo a las variables que manipula. por ejemplo: public class hourlypaycalculator { public money calculateweeklypay(hourlyemployee e) { int tenthrate = e.gettenthrate().getpennies(); int tenthsworked = e.gettenthsworked(); int straighttime = math.min(400, tenthsworked); int overtime = math.max(0, tenthsworked - straighttime); int straightpay = straighttime * tenthrate; int overtimepay = (int)math.round(overtime*tenthrate*1.5); return new money(straightpay + overtimepay); } } el método calculateweeklypay se acerca al objeto hourlyemployee para 370obtener los datos sobre los que opera. el método calculateweeklypay envidia el ámbito de hourlyemployee . su deseo es formar parte de hourlyemployee . es recomendable suprimir la envidia de características ya que muestra los detalles internos de una clase a otra. sin embargo, en ocasiones es un mal necesario. fíjese en lo siguiente: public class hourlyemployeereport { private hourlyemployee employee; public hourlyemployeereport(hourlyemployee e) { this.employee = e; } string reporthours() { return string.format( “name: %s\thours:%d.%1d\n”, employee.getname(), employee.gettenthsworked()/10, employee.gettenthsworked()%10); } } evidentemente, el método reporthours envidia la clase hourlyemployee . por otra parte, no queremos que hourlyemployee tenga que conocer el formato del informe. al incluir la cadena de formato en la clase hourlyemployee incumpliríamos varios de los principios del diseño orientado a objetos [110] . conectaría hourlyemployee al formato del informe y lo mostraría en los cambios de dicho formato. g15: argumentos de selector no hay nada más abominable que un argumento false aislado al final de la invocación de una función. ¿qué significa? ¿qué cambiaría si fuera true ? no sólo el propósito de un argumento de selector es difícil de recordar, sino que cada argumento de selector combina varias funciones en una. los argumentos de selector son una forma indolente de evitar dividir una función de gran tamaño en otras menores. fíjese en lo siguiente: public int calculateweeklypay(boolean overtime) { int tenthrate = gettenthrate(); int tenthsworked = gettenthsworked(); 371int straighttime = math.min(400, tenthsworked); int overtime = math.max(0, tenthsworked - straighttime); int straightpay = straighttime * tenthrate; double overtimerate = overtime ? 1.5 : 1.0 * tenthrate; int overtimepay = (int)math.round(overtime*overtimerate); return straightpay + overtimepay; } esta función se invoca con true si las horas extras se pagan como hora y media, y con false si se pagan como una hora normal. ya es bastante malo tener que recordar lo que significa calculateweeklypay(false) cada vez que aparezca. pero lo peor de esta función es que el autor ha perdido la oportunidad de crear lo siguiente: public int straightpay() { return gettenthsworked() * gettenthrate(); } public int overtimepay() { int overtimetenths = math.max(0, gettenthsworked() - 400); int overtimepay = overtimebonus(overtimetenths); return straightpay() + overtimepay; } private int overtimebonus(int overtimetenths) { double bonus = 0.5 * gettenthrate() * overtimetenths; return (int) math.round(bonus); } evidentemente, los selectores no deben ser boolean . pueden ser enumeraciones, enteros u otro tipo de argumento que se use para seleccionar el comportamiento de la función. es más recomendable tener varias funciones que pasar código a una función para seleccionar el comportamiento. g16: intención desconocida queremos que el código sea lo más expresivo posible. expresiones extensas, notación húngara y números mágicos distorsionan la intención del autor. por ejemplo, veamos la función overtimepay cómo podría haber aparecido: public int m_otcalc() { return ithswkd * ithsrte + (int) math.round(0.5 * ithsrte * math.max(0/ ithswkd - 400) ); } 372aunque parezca reducida y densa, también es prácticamente impenetrable. es recomendable dedicar tiempo a lograr que la intención de nuestro código sea aparente para nuestros lectores. g17: responsabilidad desubicada una de las principales decisiones de un programador de software es dónde ubicar el código. por ejemplo, dónde incluir la constante pi . ¿en la clase math ? ¿pertenece a la clase trigonometry ? ¿o a la clase circle ? el principio de mínima sorpresa vuelve a aparecer. el código debe ubicarse donde el lector espera encontrarlo. la constante pi debe incluirse junto a la declaración de las funciones trigonométricas. la constante overtime_rate debe declararse en la clase hourlypaycalculator . en ocasiones presumimos de dónde añadimos una determinada funcionalidad. incluimos una función porque nos resulta cómodo pero no porque sea intuitivo para el lector. por ejemplo, puede que tengamos que imprimir un informe con el total de horas que ha trabajado un empleado. podríamos sumar las horas en el código que imprime el informe o intentar mantener un total en el código que acepte horarios de trabajo. una forma de tomar esta decisión consiste en analizar el nombre de las funciones. imagine que el módulo del informe tiene la función gettotalhours . imagine también que el módulo que acepta horarios de trabajo tiene la función savetimecard . ¿cuál de las dos, por nombre, implica que calcula el total? la respuesta es evidente. existen motivos de rendimiento para calcular el total como horarios de trabajo y no como informe impreso. es correcto, pero el nombre de las funciones debería reflejarlo. por ejemplo, debería haber una función computerunningtotalofhours en el módulo de horarios. g18: elementos estáticos incorrectos math.max (double a, double b) es un método estático correcto. no opera 373en una única instancia; de hecho, sería un error tener que usar new math().max(a,b) o incluso a.max(b) . todos los datos que usa max provienen de sus dos argumentos, no de un objeto. además, es prácticamente imposible que queramos que math.max sea polimórfico. sin embargo, en ocasiones creamos funciones estáticas que no deben serlo. fíjese en este ejemplo: hourlypaycalculator.calculatepay(employee, overtimerate). de nuevo, parece una función estática razonable. no opera en un objeto concreto y recibe todos los datos de sus argumentos. sin embargo, existe la posibilidad de que queramos que sea polimórfica. puede que queramos implementar distintos algoritmos para calcular el precio de la hora, como por ejemplo. overtimehourlypaycalculator y straighttimehourlypaycalculator . en este caso, la función no debe ser estática. debería ser una función miembro no estática de employee . por lo general, debe decantarse por métodos no estáticos. en caso de duda, convierta la función en no estática. si realmente quiere que una función sea estática, asegúrese de que nunca querrá que sea polimórfica. g19: usar variables explicativas kent beck escribió sobre este tema en su magnífico libro smalltalk best practice patterns [111] y, más recientemente en implementation patterns [112] . una de las técnicas más completas para que un programa sea legible consiste en dividir los cálculos en valores intermedios almacenados en variables con nombres descriptivos. fíjese en este ejemplo de fitnesse: matcher match = headerpattern.matcher(line); if(match.find()) { string key = match.group(1); string value = match.group(2); headers.put(key.tolowercase(), value); } el simple uso de variables explicativas ilustra con claridad que el primer grupo comparado es la clave y el segundo es el valor . es complicado excederse en esta técnica. por lo general, es mejor tener más variables explicativas que menos. es sorprendente que un módulo opaco 374se vuelva más transparente con tan sólo dividir los cálculos en valores intermedios con los nombres adecuados. g20: los nombres de función deben indicar lo que hacen fíjese en este código: date newdate = date.add(5); ¿intuye que se añaden cinco días a la fecha o son semanas u horas? ¿la instancia date cambia y la función simplemente devuelve un nuevo objeto date sin cambiar el antiguo? por la invocación no podemos saber qué hace la función . si la función añade cinco días a la fecha y después la cambia, el nombre debería ser adddaysto o increasebydays . si, por otra parte, la función devuelve una nueva fecha con cinco días más pero no cambia la instancia date , el nombre debería ser dayslater o dayssince . si tiene que fijarse en la implementación (o documentación) de la función para saber qué hace, tendrá que elegir un nombre más apropiado o modificar la funcionalidad para que se pueda incluir en funciones con nombres más acertados. g21: comprender el algoritmo se crea gran cantidad de código extraño porque los autores no se esfuerzan en comprender el algoritmo. consiguen que algo funcione combinando instrucciones if e indicadores sin pararse a pensar en qué sucede realmente. la programación es una tarea de exploración. creemos que conocemos el algoritmo adecuado para algo pero después lo modificamos y variamos hasta conseguir que funcione . ¿cómo sabemos que funciona ? porque supera los casos de prueba que pensamos. no es un enfoque equivocado. de hecho, suele ser la única forma de conseguir que una función haga lo que pensamos que debe hacer. sin 375embargo, no basta con conseguir que funcione . antes de creer que hemos terminado con una función, asegúrese de entender su funcionamiento. no basta con que supere todas las pruebas. tiene que estar seguro [113] de que la solución es la correcta. por lo general, la forma óptima de saberlo consiste en refactorizar la función en algo tan limpio y expresivo que su funcionamiento sea evidente . g22: convertir dependencias lógicas en físicas si un módulo depende de otro, dicha dependencia debe ser física, no sólo lógica. el módulo dependiente no debe asumir aspectos (es decir, dependencias lógicas) sobre el módulo del que depende. por el contrario, debe solicitar de forma explícita al módulo toda la información de la que depende. por ejemplo, imagine que tiene que crear una función que imprima un informe de las horas trabajadas por cada empleado. la clase hourlyreporter recopila los datos y los pasa a hourlyreportformatter para imprimirlos (véase el listado 17-1). listado 17-1 hourlyreporter.java. public class hourlyreporter { private hourlyreportformatter formatter; private list<lineitem> page; private final int page_size = 55; public hourlyreporter(hourlyreportformatter formatter) { this.formatter = formatter; page = new arraylist<lineitem>(); } public void generatereport(list<hourlyemployee> employees) { for (hourlyemployee e : employees) { addlineitemtopage(e); if (page.size() == page_size) printandclearitemlist(); } if (page.size() > 0) printandclearitemlist(); 376} private void printandclearitemlist() { formatter.format(page); page.clear(); } private void addlineitemtopage(hourlyemployee e) { lineitem item = new lineitem(); item.name = e.getname(); item.hours = e.gettenthsworked() / 10; item.tenths = e.gettenthsworked() % 10; page.add(item); } public class lineitem { public string name; public int hours; public int tenths; } } este código tiene una dependencia lógica que no se ha convertido en física. ¿la detecta? es la constante page_size . ¿para qué necesita hourlyreporter saber el tamaño de la página? el tamaño de la página debe ser responsabilidad de hourlyreportformatter . la declaración de page_size en hourlyreporter representa una responsabilidad desubicada [g17] que hace que hourlyreporter asuma que conoce el tamaño que debe tener la página. esta presunción es una dependencia lógica. hourlyreporter depende de que hourlyreportformatter pueda procesar tamaños de página de hasta 55. si alguna implementación de hourlyreportformatter no puede asumir esos tamaños, se producirá un error. podemos convertir en física esta dependencia si creamos un nuevo método en hourlyreportformatter con el nombre getmaxpagesize() . tras ello, hourlyreporter invoca esta función en lugar de usar la constante page_size . g23: polimorfismo antes que if/else o switch/case puede parecer una sugerencia extraña dado el tema descrito en el capítulo 6. en este capítulo, afirmo que las instrucciones switch son adecuadas en partes del sistema en las que se añadan más funciones nuevas que tipos nuevos. 377por un lado, la mayoría usamos instrucciones switch por ser una solución de fuerza bruta evidente, no por ser la solución perfecta. por tanto, esta heurística nos recuerda que debemos considerar el uso de polimorfismo antes de usar switch . por otra parte, los casos en que las funciones son más volátiles que los tipos son escasos. por tanto, toda instrucción switch es sospechosa. suelo aplicar la siguiente regla de una instrucción switch : no puede haber más de una instrucción  switch  por cada tipo de selección. los casos de esa instrucción  switch  deben crear objetos polimórficos que ocupen el lugar de otras instrucciones  switch  similares en el resto del sistema . g24: seguir las convenciones estándar todos los equipos deben seguir un estándar de diseño de código basado en normas comunes de la industria. este estándar debe especificar aspectos como dónde declarar variables de instancia, cómo asignar nombres a clases, métodos y variables, dónde añadir llaves, etc. el equipo no debe necesitar un documento que describa estas convenciones ya que su código proporciona los ejemplos. todos los miembros del equipo deben seguir estas convenciones, lo que significa que no importa dónde añada cada uno las llaves mientras todos estén de acuerdo en dónde añadirlas. si desea saber qué convenciones aplico, puede verlas en el código refactorizado de los listados b.7 a b.14 del apéndice b. g25: sustituir números mágicos por constantes con nombre es probablemente una de las reglas más antiguas del desarrollo de software . recuerdo haberla leído a finales de la década de 1960 en manuales de cobol, fortran y pl/1. por lo general, no es recomendable incluir números sin procesar en el código; debe ocultarlos tras constantes con 378nombres correctos. por ejemplo, el número 86 400 debe ocultarse tras la constante seconds_per_day . si va a imprimir 55 líneas por página, la constante 55 debe ocultarse tras la constante lines_per_page . algunas constantes son tan fáciles de reconocer que no siempre necesitan una constante con nombre tras la que ocultarse mientras se usen junto a código explicativo. por ejemplo: double mileswalked = feetwalked/5280.0; int dailypay = hourlyrate * 8; double circumference = radius * math.pi * 2; ¿necesitamos realmente las constantes feet_per_mile, work_hours_per_day y two en los ejemplos anteriores? el último caso es absurdo. existen ciertas fórmulas en las que las constantes se escriben mejor como números sin procesar. puede cuestionar el caso de work_hours_per_day ya que las leyes o las convenciones pueden cambiar. por otra parte, esa fórmula se lee perfectamente si se incluye el 8 por lo que no es necesario añadir 17 más. en el caso de feet_per_mile , el número 5280 es una constante tan conocida y exclusiva que los lectores la reconocerán aunque se muestre de forma independiente en una página sin contexto alguno. constantes como 3.141592653589793 también son conocidas y reconocibles. sin embargo, la probabilidad de errores es alta y no conviene mostrarlas tal cual. siempre que alguien ve 3.1415927535890793, sabe que es π, y no se molestan en examinarlo (¿ha visto el error de un dígito?). tampoco queremos que la gente use 3.14, 3.14159, 3.142, y similares. por lo tanto, es una suerte contar con math.pi . el término número mágico no sólo se aplica a números, sino a todo símbolo que tenga un valor que no sea descriptivo por sí mismo. por ejemplo: assertequals(7777, employee.find(“john doe”).employeenumber()); en esta afirmación hay dos números mágicos. el primero es obviamente 7777, aunque no significa que no sea obvio. el segundo es « john doe » y su cometido tampoco está claro. “john doe” es el nombre del empleado #7777 en una conocida base de datos de pruebas creada por nuestro equipo. todo el mundo sabe que al 379conectarse a la base de datos, ya cuenta con varios empleados con sus valores y atributos. además, « john doe » representa el único empleado por horas de la base de datos. por tanto, la prueba debería ser la siguiente: assertequals( hourly_employee_id, employee.find(hourly_employee_name).employeenumber()); g26: precisión esperar que la primera coincidencia de una consulta sea la única es una ingenuidad. el uso de números de coma flotante para representar divisas es casi un delito. evitar bloqueos y/o la administración de transacciones por creer que las actualizaciones concurrentes no son posibles es pura indolencia. declarar una variable como arraylist cuando se necesita list es un exceso de restricciones. crear todas las variables como protected de forma predeterminada es falta de restricciones. al adoptar una decisión en el código, debe hacerlo de forma precisa. debe saber por qué la adopta y cómo afrontará las excepciones. no sea indolente sobre la precisión de sus decisiones. si decide invocar una función que pueda devolver null , asegúrese de comprobar null . si consulta el que considera el único registro de una base de datos, asegúrese de que el código comprueba que no haya otros. si tiene que trabajar con divisas, use enteros [114] y aplique el redondeo correcto. si existe la posibilidad de una actualización concurrente, asegúrese de implementar algún tipo de mecanismo de bloqueo. en el código, la ambigüedad y las imprecisiones son el resultado de desacuerdos o de indolencia. en cualquier caso, elimínelas. g27: estructura sobre convención aplique las decisiones de diseño con estructura y no convenciones. las convenciones de nomenclatura son correctas pero resultan inferiores a estructuras que refuerzan la compatibilidad. por ejemplo, los casos switch con enumeraciones de nombres correctos son inferiores a clases base con 380métodos abstractos. no estamos obligados a implementar siempre la instrucción switch/case de la misma forma, pero las clases base hacen que las clases concretas implementen métodos abstractos. g28: encapsular condicionales la lógica booleana es difícil de entender sin necesidad de verla en el contexto de una instrucción if o while . extraiga funciones que expliquen el cometido de la condicional. por ejemplo: if (shouldbedeleted(timer)) es preferible a if (timer.hasexpired() && !timer.isrecurrent()) g29: evitar condicionales negativas las condicionales negativas son más difíciles de entender que las positivas. por ello, siempre que sea posible, debe expresar las condiciones como positivas. por ejemplo: if (buffer.shouldcompact()) es preferible a if (!buffer.shouldnotcompact()) g30: las funciones sólo deben hacer una cosa es tentador crear funciones con varias secciones que realicen una serie de operaciones. este tipo de funciones hacen más de una cosa y deben convertirse en funciones de menor tamaño, cada una para una cosa . por ejemplo: public void pay() { for (employee e : employees) { if (e.ispayday()) { money pay = e .calculatepay(); e.deliverpay(pay); } } 381} este fragmento de código realiza tres operaciones. itera por todos los empleados, comprueba si cada uno debe recibir su paga y después paga al empleado. se podría reescribir de esta forma: public void pay() { for (employee e : employees) payifnecessary(e); } private void payifnecessary(employee e) { if (e.ispayday()) calculateanddeliverpay(e); } private void calculateanddeliverpay(employee e) { money pay = e.calculatepay(); e.deliverpay(pay); } cada una de estas funciones hace una sola cosa (véase el capítulo 3). g31: conexiones temporales ocultas las conexiones temporales suelen ser necesarias pero no debe ocultar la conexión. estructure los argumentos de sus funciones de modo que el orden de invocación sea evidente. fíjese en lo siguiente: public class moogdiver { gradient gradient; list<spline> splines; public void dive(string reason) { saturategradient(); reticulatesplines(); diveformoog(reason); } … } el orden de las tres funciones es importante. debe saturar el degradado antes de poder entrelazar las tiras, para después continuar. desafortunadamente, el código no aplica esta conexión temporal. otro programador podría invocar reticulatesplines antes de saturategradient , lo que generaría unsaturatedgradientexception . una solución más acertada sería: 382public class moogdiver { gradient gradient; list<spline> splines; public void dive(string reason) { gradient gradient = saturategradient(); list<spline> splines = reticulatesplines(gradient); diveformoog(splines, reason); } … } de este modo se muestra la conexión temporal generando una especie de embudo. cada función genera un resultado que la siguiente necesita de modo que no se pueden invocar en otro orden. puede argumentar que esto aumenta la complejidad de las funciones y tiene razón, pero ese incremento de complejidad sintáctica muestra la verdadera complejidad temporal de la situación. observará que he mantenido las variables de instancia. imagino que son necesarias para los métodos privados de las clases. incluso así, conservo los argumentos para que la conexión temporal sea explícita. g32: evitar la arbitrariedad argumente la estructura de su código y asegúrese de que la estructura del código comunica dicho argumento. si la estructura parece arbitraria, otros se verán con derecho a modificarla. si la estructura parece coherente en la totalidad del sistema, otros la usarán y conservarán la convención. por ejemplo, recientemente repasaba cambios realizados en fitnesse y descubrí lo siguiente: public class aliaslinkwidget extends parentwidget { public static class variableexpandingwidgetroot { … … } el problema es que variableexpandingwidgetroot no debía estar en el ámbito de aliaslinkwidget . es más, otras clases sin relación usaban aliaslinkwidget.variableexpandingwidgetroot y no tenían por qué saber 383nada de aliaslinkwidget . puede que el programador añadiera variableexpandingwidgetroot a aliaswidget por comodidad o que realmente pensara que debía formar parte del ámbito de aliaswidget . independientemente del motivo, el resultado será arbitrario. las clases públicas que no son utilidades de otra clase no deben incluirse en el ámbito de otra clase. la convención es convertirlas en públicas en el nivel superior de su paquete. g33: encapsular condiciones de límite las condiciones de límite son difíciles de controlar. aísle su procesamiento y no permita que se transfieran al resto del código. no necesitamos legiones de +1 y -1 por todas partes. fíjese en este ejemplo de fit: if (level + 1 < tags.length) { parts = new parse(body, tags, level + 1, offset + endtag); body = null; } level+1 aparece dos veces. es una condición de límite que debe encapsularse en una variable con un nombre como nextlevel . int nextlevel = level + 1; if(nextlevel < tags.length) { parts = new parse(body, tags, nextlevel, offset + endtag); body = null; } g34: las funciones sólo deben descender un nivel de abstracción las instrucciones de una función deben crearse en el mismo nivel de abstracción, un nivel por debajo de la operación descrita por el nombre de la función. puede que sea la heurística más difícil de interpretar y aplicar. aunque la idea es simple, como humanos nos cuesta mezclar niveles de abstracción. fíjese en el siguiente código de fitnesse: public string render() throws exception { 384stringbuffer html = new stringbuffer(“<hr”); if(size > 0) html.append(“ size=\“”).append(size + 1).append(“\””); html.append(“>”); return html.tostring(); } si lo analiza, verá lo que sucede. esta función crea la etiqueta html que traza una regla horizontal por la página. la altura de la regla se especifica en la variable size . fíjese otra vez en el código. este método mezcla al menos dos niveles de abstracción. el primero es la noción de que una regla horizontal tiene un tamaño. el segundo es la sintaxis de la propia etiqueta hr . el código proviene del módulo hrulewidget de fitnesse. este módulo detecta una fila de cuatro o más guiones y la convierte en la correspondiente etiqueta hr . cuantos más guiones haya, mayor será el tamaño. a continuación le muestro la refactorización del código. he cambiado el nombre del campo size para reflejar su verdadero cometido. contenía el número de guiones adicionales. public string render() throws exception { htmltag hr = new htmltag(“hr”); if (extradashes > 0) hr.addattribute(“size”, hrsize(extradashes)); return hr.html(); } private string hrsize(int height) { int hrsize = height + 1; return string.format(“%d”, hrsize); } este cambio separa correctamente los dos niveles de abstracción. la función render simplemente crea una etiqueta hr sin tener que saber nada sobre su sintaxis html. el módulo htmltag se encarga de los problemas sintácticos. de hecho, al realizar este cambio detecté un sutil error. el código original no incluía la barra final en la etiqueta hr , como haría el estándar xhtml (es decir, generaba <hr> en lugar de <hr/> ). el módulo htmltag se había modificado hace tiempo para ajustarlo a xhtml. 385la separación de niveles de abstracción es una de las tareas más importantes de la refactorización, y también una de las más complejas. por ejemplo, fíjese en el siguiente código. fue mi primer intento de separar los niveles de abstracción del método hrulewidget.render . public string render() throws exception { htmltag hr = new htmltag(“hr”); if (size > 0) { hr.addattribute (“size”, “”+(size+1)); } return hr.html(); } mi objetivo, en esta fase, es crear la separación necesaria y conseguir superar las pruebas. el objetivo lo alcancé fácilmente pero el resultado fue una función con niveles de abstracción mezclados. en este caso, fueron obra de la etiqueta hr y de la interpretación y el formato de la variable size. esto indica que al dividir una función en líneas de abstracción, suelen aparecer nuevas líneas de abstracción ocultas por la estructura anterior. g35: mantener los datos configurables en los niveles superiores si tiene una constante como un valor predeterminado o de configuración que se conoce y se espera en un nivel superior de abstracción, no debe sepultarla en una función de nivel inferior. muéstrela como argumento para esa función de nivel inferior invocado desde la función de nivel superior. fíjese en este ejemplo de fitnesse: public static void main(string[] args) throws exception { arguments arguments = parsecommandline(args); … } public class arguments { public static final string default_path = “.”; public static final string default_root = “fitnesseroot”; public static final int default_port = 80; public static final int default_version_days = 14; … } 386los argumentos de línea de comandos se analizan en la primera línea ejecutable de fitnesse. los valores predeterminados de dichos argumentos se especifican al inicio de la clase argument . no tiene que buscar instrucciones como la siguiente en los niveles inferiores del sistema: if (arguments.port == 0) // usar 80 de forma predeterminada las constantes de configuración se encuentran en un nivel superior y son fáciles de cambiar. se pasan al resto de la aplicación. los niveles inferiores de la aplicación no poseen los valores de estas constantes. g36: evitar desplazamientos transitivos por lo general, no es recomendable que un módulo sepa demasiado sobre sus colaboradores. en concreto, si a colabora con b y b con c, no queremos que los módulos que usan a sepan nada sobre c (por ejemplo, o queremos a.getb().getc().dosomething(); ). es lo que en ocasiones se denomina ley de demeter. los programadores pragmáticos lo denominan crear código silencioso [115] . en cualquier caso, se trata de garantizar que los módulos sólo tienen conocimiento de sus colaboradores inmediatos y no del mapa de navegación completo del sistema. si varios módulos usan alguna variante de la instrucción a.getb().getc() , sería complicado cambiar el diseño y la arquitectura para intercalar q entre b y c. tendría que localizar todas las instancias de a.getb().getc() y convertirlas a a.getb().getq().getc() . es la forma en que las arquitecturas se vuelven rígidas. demasiados módulos saben demasiado sobre la arquitectura. por el contrario, queremos que nuestros colaboradores intermedios ofrezcan todos los servicios que necesitamos. no debemos deambular por el gráfico de objetos del sistema en busca del método que necesitamos invocar. bastaría con poder usar: mycollaborator.dosomething(). java 387j1: evitar extensas listas de importación mediante el uso de comodines si usa dos o más clases de un paquete, importe el paquete completo con import package.*; las listas extensas de importaciones intimidan al lector. no queremos colapsar la parte superior de los módulos con 80 líneas de importaciones, sino que sean una instrucción concisa de los paquetes con los que colaboramos. las importaciones específicas son dependencias rígidas, mientras que las importaciones de comodín no. si importa una clase concreta, esa clase debe existir, pero si importa un paquete con un comodín, no es necesario que existan clases concretas. la instrucción de importación simplemente añade el paquete a la ruta de búsqueda al localizar los nombres. por tanto, no se genera una verdadera dependencia en estas importaciones y permiten aligerar las conexiones de nuestros módulos. en ocasiones, la lista extensa de importaciones puede resultar útil. por ejemplo, si tiene que trabajar con código de legado y desea saber para qué clases crear elementos ficticios, puede examinar la lista de importaciones concretas para determinar los verdaderos nombres cualificados de todas esas clases y después añadirlos. no obstante, este uso de las importaciones concretas no es habitual. es más, muchos ide modernos le permiten convertir las importaciones con comodines en una lista de importaciones concretas con un solo comando. por tanto, incluso en el caso anterior, es recomendable usar comodines. las importaciones de comodín pueden probar conflictos de nombres y ambigüedades. dos clases con el mismo nombre pero en paquetes diferentes tienen que importarse de forma concreta o al menos cualificarse de forma específica cuando se usen. puede resultar molesto pero no es habitual que el uso de importaciones de comodín sea más indicado que el de importaciones concretas. j2: no heredar constantes lo he visto muchas veces y siempre me molesta. un programador añade 388constantes a una interfaz y después accede a las mismas heredando dicha interfaz. fíjese en el siguiente código: public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } ¿de dónde salen las constantes tenths_per_week y overtime_rate ? puede que provengan de la clase employee ; comprobémoslo: public abstract class employee implements payrollconstants { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } no, de ahí no. ¿entonces de dónde? fíjese atentamente en la clase employee . implementa payrollconstants . public interface payrollconstants { public static final int tenths_per_week = 400; public static final double overtime_rate = 1.5; } es horrible. las constantes se ocultan en la parte superior de la jerarquía de herencia. no use la herencia para burlar las reglas de ámbito del lenguaje. use una importación estática: import static payrollconstants.*; public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } 389j3: constantes frente a enumeraciones ahora que se han añadido enumeraciones al lenguaje (java 5), ¡úselas! no recurra al viejo truco de public static final int . el significado de int se puede perder. el de enum no, ya que pertenece a una enumeración con nombre. es más, analice atentamente la sintaxis de las enumeraciones . pueden tener métodos y campos, lo que las convierte en potentes herramientas que ofrecen mayor expresividad y flexibilidad que los int . fíjese en esta variante del código: public class hourlyemployee extends employee { private int tenthsworked; hourlypaygrade grade; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( grade.rate() * (tenthsworked + overtime_rate * overtime) ); } … } public enum hourlypaygrade { apprentice { public double rate() { return 1.0; } }, leutenant_journeyman ( public double rate() { return 1.2; } }, journeyman { public double rate() { return 1.5; } }, master { public double rate() { return 2.0; } }; public abstract double rate(); 390} nombres n1: elegir nombres descriptivos no sea demasiado rápido a la hora de elegir un nombre. asegúrese de que sea descriptivo. recuerde que los significados suelen variar cuando el código evoluciona, de modo que debe revisar frecuentemente la corrección de los nombres elegidos. no es una recomendación de sensaciones. en software , los nombres constituyen el 90 por 100 de su legibilidad. dedique tiempo a seleccionarlos con atención y mantenga su relevancia. los nombres son demasiado importantes como para tratarlos mal. fíjese en el siguiente código. ¿para qué sirve? si le muestro el mismo código con nombres bien elegidos, tendrá sentido, pero con este formato no es más que una masa de símbolos y números mágicos. public int x() { int q = 0; int z = 0; for (int kk = 0; kk < 10; kk++) { if (l[z] == 10) { q += 10 + (l[z + 1] + l[z + 2]); z += 1; } else if (l[z] + l[z + 1] == 10) { q += 10 + l[z + 2]; z += 2; } else { q += l[z] + l[z + 1]; z += 2; } } return q; } a continuación, el código como debería haberse escrito. este fragmento es en realidad menos completo que el anterior, pero detectará inmediatamente 391lo que intenta hacer y es probable que pudiera crear las funciones que faltan en función de ese significado que intuye. los números mágicos ya no lo son y la estructura del algoritmo es descriptiva y atractiva: public int score() { int score = 0; int frame = 0; for (int framenumber = 0; framenumber < 10; framenumber++) { if (isstrike(frame)) { score += 10 + nexttwoballsforstrike(frame); frame += 1; } else if (isspare(frame)) { score += 10 + nextballforspare(frame); frame += 2; } else { score += twoballsinframe(frame); frame += 2; } } return score; } los nombres bien elegidos inundan la estructura del código con descripciones. dicha inundación define las expectativas del lector sobre el cometido de otras funciones del módulo. puede inferir la implementación de isstrike() si se fija en el código anterior. cuando lea el método isstrike , será prácticamente lo que esperaba [116] . private boolean isstrike(int frame) { return rolls[frame] = 10; } n2: elegir nombres en el nivel correcto de abstracción no elija nombres que comuniquen implementación; seleccione nombres que reflejen el nivel de abstracción de la clase o la función con la que trabaje. es complicado. de nuevo, nos cuesta mezclar niveles de abstracción. siempre que realice una pasada por su código, es probable que encuentre una variable con nombre en un nivel demasiado bajo. cambie esos nombres cuando los vea. para que el código sea legible se necesita una mejora continua. fíjese en la siguiente interfaz modem : public interface modem { 392boolean dial(string phonenumber); boolean disconnect(); boolean send(char c); char recv(); string getconnectedphonenumber(); } inicialmente parece correcta. las funciones parecen las adecuadas. de hecho lo son para muchas aplicaciones, pero piense ahora en una aplicación en la que algunos módems no se conecten mediante marcación telefónica, sino mediante cables (como los usados para conexiones domésticas a internet). puede que algunos se conecten enviando un número de puerto a un concentrador a través de una conexión usb. es evidente que la noción de números de teléfono se encuentra en un nivel de abstracción equivocado. una estrategia de nomenclatura más adecuada para este caso sería la siguiente: public interface modem { boolean connect(string connectionlocator); boolean disconnect(); boolean send(char c); char recv(); string getconnectedlocator(); } ahora los nombres no se limitan a números de teléfono. se pueden usar para números de teléfono o para otros tipos de estrategia de conexión. n3: usar nomenclatura estándar siempre que sea posible los nombres son más fáciles de entender si se basan en una convención o un uso existente. por ejemplo, si emplea el patrón decorator , debería usar la palabra decorator en los nombres de las clases. por ejemplo, autohangupmodemdecorator podría ser el nombre de una clase que permite a un módem colgar automáticamente al final de una sesión. los patrones son un tipo de estándar. en java, por ejemplo, las funciones que convierten objetos en representaciones de cadena suelen tener el nombre tostring . es mejor seguir estas convenciones que inventar otras propias. los equipos suelen inventar su propio sistema estándar de nombres para un proyecto concreto. eric evans lo denomina lenguaje omnipresente del 393proyecto [117] . su código debe usar los términos de este lenguaje. en definitiva, cuantos más nombres con significado especial y relevante para su proyecto utilice, más fácil será para los lectores saber de qué trata el código. n4: nombres inequívocos seleccione nombres que ilustren de forma inequívoca el funcionamiento de funciones y variables. fíjese en este ejemplo de fitnesse: private string dorename() throws exception { if (refactorreferences) renamereferences(); renamepage(); pathtorename.removenamefromend(); pathtorename.addnametoend(newname); return pathparser.render(pathtorename); } el nombre de esta función no indica qué hace, al menos en términos amplios y sin concretar. además, se refuerza por la presencia de la función renamepage dentro de la función dorename . ¿qué indican los nombres sobre la diferencia entre ambas funciones? nada. un nombre más acertado para la función sería renamepageandoptionallyallreferences . puede parecerle extenso, y lo es, pero sólo se invoca desde un punto del módulo, de modo que su valor descriptivo supera su longitud. n5: usar nombres extensos para ámbitos extensos la longitud de un nombre debe estar relacionada con la de su ámbito. puede usar nombres de variables breves para ámbitos diminutos pero en ámbitos mayores debe emplear nombres extensos. los nombres de variables como i y j son correctos si su ámbito tiene cinco líneas de longitud. fíjese en el siguiente fragmento del conocido juego de los bolos: private void rollmany(int n, int pins) { for (int i=0; i<n; i++) 394g.roll(pins); } es totalmente claro y se complicaría si la variable i se cambiara por algo como rollcount . por otra parte, las variables y funciones con nombres breves pierden su significado en las grandes distancias. por tanto, cuanto mayor sea el ámbito del nombre, más extenso y preciso tendrá que ser el nombre. n6: evitar codificaciones los nombres no deben codificarse con información de tipos o ámbitos. prefijos como m_ o f no sirven de nada en los entornos actuales. además, codificaciones de proyecto y/o subsistema como vis_ (para un sistema de imágenes visuales) distraen la atención y son redundantes. los entornos actuales proporcionan toda esa información sin tener que modificar los nombres. aleje sus nombres de la contaminación húngara. n7: los nombres deben describir efectos secundarios los nombres deben describir todo lo que haga una función, variable o clase. no oculte efectos secundarios con un nombre. no utilice un simple verbo para describir una función que realiza algo más que una simple acción. fíjese en este código de testng: public objectoutputstream getoos() throws ioexception { if (m_oos == null) { m_oos = new objectoutputstream(m_socket.getoutputstream()); } return m_oos; } esta función hace algo más que obtener oos ; lo crea si todavía no se ha creado. por lo tanto, un nombre más acertado sería createorreturnoos . pruebas (test) 395t1: pruebas insuficientes ¿cuántas pruebas debe incluir una suite de pruebas? desafortunadamente, muchos programadores dirían que las que parezcan suficientes. una suite de pruebas debe probar todo lo que pueda fallar. las pruebas son insuficientes mientras haya condiciones que no se hayan examinado o cálculos que no se hayan validado. t2: usar una herramienta de cobertura las herramientas de cobertura indican vacíos en su estrategia de pruebas. facilitan la detección de módulos, clases y funciones insuficientemente probadas. muchos ide le ofrecen un indicador visual y marcan en verde las líneas cubiertas y en rojo las no cubiertas. de este modo es más rápido y sencillo detectar instrucciones if o catch cuyos cuerpos no se han comprobado. t3: no ignorar pruebas triviales son fáciles de redactar y su valor documental es mayor que el coste de crearlas. t4: una prueba ignorada es una pregunta sobre una ambigüedad en ocasiones dudamos de un detalle de comportamiento porque los requisitos no son claros. podemos expresar nuestra duda sobre los requisitos en forma de prueba comentada o como prueba anotada con @ignore . la decisión depende de si la ambigüedad es sobre algo que se compila o no. t5: probar condiciones de límite 396preste especial atención a las pruebas de condiciones de límite. solemos acertar con la parte central de un algoritmo pero malinterpretar los límites. t6: probar de forma exhaustiva junto a los errores los errores suelen congregarse. si detecta un error en una función, es recomendable probarla de forma exhaustiva. seguramente no sea el único error. t7: los patrones de fallo son reveladores en ocasiones diagnosticamos un problema detectando patrones de fallo en los casos de prueba. es otro argumento para crear casos de prueba lo más completos posibles. los casos de prueba completos, si se ordenan de forma razonable, revelan patrones. como ejemplo, imagine que ha detectado que todas las pruebas con un entero mayor de cinco caracteres fallan. o que fallan todas las pruebas que pasan un número negativo al segundo argumento de una función. en ocasiones, con ver el patrón de rojos y verdes de un informe de pruebas basta para hacer saltar la chispa y llegar a una solución. en el capítulo 16 encontrará un interesante ejemplo en el caso de serialdate . t8: los patrones de cobertura de pruebas pueden ser reveladores el análisis del código que se ejecuta o no en las pruebas superadas suele indicar porqué fallan las pruebas no superadas. t9: las pruebas deben ser rápidas una prueba lenta no se ejecuta. cuando las cosas se ponen feas, las pruebas lentas se eliminan de la suite . por lo tanto, intente que sus pruebas sean 397rápidas. conclusión esta lista de heurística y síntomas no se podría considerar completa. de hecho, dudo de que alguna vez exista alguna. pero puede que ese no sea el objetivo, ya que lo que implica esta lista es un sistema de valores. el sistema de valores ha sido el objetivo y la base de este libro. el código limpio no se crea siguiendo una serie de reglas. no se convertirá en un maestro del software aprendiendo una lista de heurísticas. la profesionalidad y la maestría provienen de los valores que impulsan las disciplinas. bibliografía [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. [beck97] : smalltalk best practice patterns , kent beck, prentice hall, 1997. [beck07] : implementation patterns , kent beck, addison-wesley, 2008. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. [ddd] : domain driven design , eric evans, addison-wesley, 2003. 398apéndice a concurrencia ii por brett l. schuchert este apéndice complementa y amplía el capítulo 13 sobre concurrencia. se ha escrito como una serie de temas independientes que puede leer en el orden que desee. algunas secciones están duplicadas para facilitar dicha lectura. ejemplo cliente/servidor imagine una sencilla aplicación cliente/servidor. un servidor espera a que un cliente se conecte. un cliente se conecta y envía una solicitud. el servidor a continuación le mostramos una versión simplificada de una aplicación de servidor. el código completo de este ejemplo se recoge en el listado a-3. serversocket serversocket = new serversocket(8009); while (keepprocessing) { try { socket socket = serversocket.accept(); process(socket); } catch (exception e) { handle(e); } 399} esta sencilla aplicación espera una conexión, procesa un mensaje entrante y vuelve a esperar a la siguiente solicitud cliente. el código cliente para conectarse al servidor es el siguiente: private void connectsendreceive(int i) { try { socket socket = new socket (“localhost”, port); messageutils.sendmessage(socket, integer.tostring(i)); messageutils.getmessage(socket); socket.close(); } catch (exception e) { e.printstacktrace(); } } ¿cómo se comporta esta combinación de cliente y servidor? ¿cómo podemos describir formalmente ese rendimiento? la siguiente prueba afirma que el rendimiento es aceptable: @test(timeout = 10000) public void shouldruninunder10seconds() throws exception { thread[] threads = createthreads(); startallthreadsw(threads); waitforallthreadstofinish(threads); } se omite la configuración para que el ejemplo sea sencillo (véase “ clienttest.java ” más adelante). esta prueba afirma que debe completarse en 10 000 milisegundos. es un ejemplo clásico de validación del rendimiento de un sistema. este sistema debe completar una serie de solicitudes cliente en 10 segundos. mientras el servidor pueda procesar cada solicitud cliente a tiempo, la prueba será satisfactoria. ¿qué sucede si la prueba falla? aparte de desarrollar algún tipo de bucle de consulta de eventos, no hay mucho que hacer en un único proceso para aumentar la velocidad de este código. ¿se solucionaría el problema con varios procesos? puede, pero necesitamos saber cómo se consume el tiempo. hay dos posibilidades: e/s: con un socket, conectándose a la base de datos, esperando al intercambio de memoria virtual, etc. procesador: cálculos numéricos, procesamiento de expresiones 400regulares, recolección de elementos sin usar, etc. los sistemas suelen tener uno de cada, pero para una operación concreta suele haber uno dominante. si el código se vincula al procesador, mayor cantidad de hardware de procesamiento puede mejorar el rendimiento y hacer que se supere la prueba, pero no hay tantos ciclos de cpu disponibles, de modo que añadir procesos a un problema vinculado al procesador no hará que aumente la velocidad. por otra parte, si el proceso está vinculado a e/s, la concurrencia puede aumentar la eficacia. cuando una parte del sistema espera a e/s, otra puede usar ese tiempo de espera para procesar algo distinto, maximizando el uso eficaz de la cpu disponible. añadir subprocesos imagine que la prueba de rendimiento falla. ¿cómo podemos mejorar la producción para que la prueba de rendimiento sea satisfactoria? si el método process del servidor está vinculado a la e/s, existe una forma de conseguir que el servidor use subprocesos (basta con cambiar processmessage): void process (final socket socket) { if (socket == null) return; runnable clienthandler = new runnable() { public void run() { try { string message = messageutils.getmessage(socket); messageutils.sendmessage(socket, “processed: ” + message); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } }; thread clientconnection = new thread(clienthandler); clientconnection.start(); } asuma que este cambio hace que la prueba se supere [118] ; el código es completo, ¿correcto? 401observaciones del servidor el servidor actualizado completa satisfactoriamente la prueba en algo más de un segundo. desafortunadamente, la solución genera ciertos problemas. ¿cuántos subprocesos podría crear nuestro servidor? el código no define límites de modo que podríamos alcanzar el impuesto por la máquina virtual de java (mvj), suficiente en muchos sistemas sencillos. ¿pero y si el sistema tiene que asumir multitud de usuarios de una red pública? si se conectan demasiados usuarios al mismo tiempo, el sistema podría colapsarse. pero dejemos temporalmente este problema de comportamiento. la solución mostrada tiene problemas de limpieza y estructura. ¿cuántas responsabilidades tiene el código del servidor? administración de conexiones. procesamiento de clientes. política de subprocesos. política de cierre del servidor. desafortunadamente, todas estas responsabilidades se encuentran en la función process . además, el código cruza varios niveles diferentes de abstracción. por tanto, a pesar de la reducida función process , es necesario dividirlo. existen varios motivos para cambiar el servidor; por tanto, incumple el principio de responsabilidad única. para mantener la limpieza de un sistema concurrente, la administración de subprocesos debe limitarse a una serie de puntos controlados. es más, el código que gestione los subprocesos únicamente debe encargarse de la gestión de subprocesos. ¿por qué? si no existe otro motivo, el control de problemas de concurrencia ya es lo suficientemente complicado como para generar simultáneamente otros problemas no relacionados con la concurrencia. si creamos una lista independiente para cada una de las responsabilidades anteriores, incluyendo la administración de subprocesos, al cambiar la estrategia de administración de subprocesos, el cambio tiene un menor impacto sobre el código y no contamina a otras responsabilidades. de este 402modo también es más sencillo probar las demás responsabilidades sin necesidad de preocuparse de los subprocesos. veamos la versión actualizada que se encarga de ello: public void run() { while (keepprocessing) { try { clientconnection clientconnection = connectionmanager.awaitclient(); clientrequestprocessor requestprocessor = new clientrequestprocessor(clientconnection); clientscheduler.schedule(requestprocessor); } catch (exception e) { e.printstacktrace(); } } connectionmanager.shutdown(); } ahora centra en el mismo punto todos los aspectos relacionados con los subprocesos: clientscheduler . si hay problemas de concurrencia, bastará con examinar un punto concreto: public interface clientscheduler { void schedule(clientrequestprocessor requestprocessor); } la política actual es fácil de implementar: public class threadperrequestscheduler implements clientscheduler { public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; thread thread = new thread(runnable); thread.start(); } } tras aislar la administración de subprocesos, resulta más sencillo cambiar el control de los mismos. por ejemplo, para cambiar a la estructura executor de java 5 es necesario crear una nueva clase y conectarla (véase el listado a-1). listado a-1 403executorclientscheduler.java. import java.util.concurrent.executor; import java.util.concurrent.executors; public class executorclientscheduler implements clientscheduler { executor executor; public executorclientscheduler(int availablethreads) { executor = executors.newfixedthreadpool(availablethreads); } public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; executor.execute(runnable); } } conclusión en este ejemplo concreto, la presencia de la concurrencia ilustra una forma de mejorar la producción de un sistema y otra de validar dicha producción a través de una estructura de pruebas. al centrar el código de concurrencia en un número reducido de clases, aplicamos el principio de responsabilidad única. en el caso de la programación concurrente, resulta especialmente importante debido a su complejidad. posibles rutas de ejecución repase el método incrementvalue , un método de java de una línea sin bucles ni ramificaciones: public class idgenerator { int lastidused; public int incrementvalue() { return ++lastidused; } } ignore el desbordamiento de enteros e imagine que solamente un 404subproceso accede a una instancia de idgenerator . en este caso existe una sola ruta de ejecución y un único resultado garantizado: el valor devuelto es igual al valor de lastidused , y ambos son una unidad mayores que antes de invocar el método. ¿qué sucede si usamos dos subprocesos y no cambiamos el método? ¿cuáles son los posibles resultados si cada subproceso invoca incrementvalue una vez? ¿cuántas rutas de ejecución posibles hay? primero, los resultados (imagine que el valor inicial de lastidused es 93): el primer subproceso obtiene el valor 94, el segundo el valor 95 y lastidused es 95. el primer subproceso obtiene el valor 95, el segundo el valor 94 y lastidused es 95. el primer subproceso obtiene el valor 94, el segundo el valor 94 y lastidused es 94. el resultado final, aunque sorprendente, es posible. para ver los distintos resultados, debemos comprender las diferentes rutas de ejecución posibles y cómo las ejecuta la mvj. número de rutas para calcular el número de rutas de ejecución posibles, comenzaremos con el código de bytes generado. la única línea de java ( return ++lastidused; ) se convierte en ocho instrucciones de código de bytes . los dos subprocesos pueden intercambiar la ejecución de estas ocho instrucciones del mismo modo que mezclamos las cartas de una baraja [119] . incluso con sólo ocho cartas en cada mano, el número de posibles resultados es sorprendente. para este sencillo caso de n instrucciones en una secuencia, sin bucles ni condicionales y t subprocesos, el número total de posibles rutas de ejecución es igual a: 405(nt)! n! t calcular las órdenes posibles extraído de un correo electrónico de uncle bob a brett: con n pasos y t subprocesos hay t * n pasos totales. antes de cada paso hay un conmutador de contexto que elige entre los subprocesos. por tanto, cada ruta se representa como una cadena de dígitos que denota los cambios de contexto. dados los pasos a y b y los subprocesos 1 y 2, las seis rutas posibles son 1122, 1212, 1221, 2112, 2121 y 2211. o, en términos de pasos, a1b1a2b2, a1a2b1b2, a1a2b2b1, a2a1b1b2, a2a1b2b1 y a2b2a1b1. para tres subprocesos, la secuencia sería 112233, 112323, 113223, 113232, 112233, 121233, 121323, 121332, 123132, 123123… una característica de estas cadenas es que siempre debe haber n instancias de cada t . por tanto, la cadena 111111 no es válida ya que tiene seis instancias de 1 y ninguna de 2 y 3. por tanto, necesitamos las permutaciones de n 1, n 2… y n  t . en realidad son las permutaciones de n * t tomando cada vez n * t , que es (n * t)! , pero sin los duplicados. por tanto, el truco consiste en contar los duplicados y restarlos de (n * t)! . dados dos pasos y dos subprocesos, ¿cuántos duplicados hay? cada cadena de cuatro dígitos tiene dos 1 y dos 2. estos pares se pueden intercambiar sin modificar el sentido de la cadena. podríamos intercambiar los 1 o los 2, o ninguno. por tanto hay cuatro isomorfas por cada cadena, lo que significa que hay tres duplicados, de modo que tres de las cuatro opciones son duplicados; por otra parte, una de las cuatro permutaciones no son duplicados. 4! * .25 = 6. este razonamiento parece funcionar. ¿cuántos duplicados hay? si n = 2 y t = 2, podría intercambiar los 1, los 2, o ambos. en el caso de n = 2 y t = 3, podría intercambiar los 1, los 2, los 3, 1 y 2, 1 y 3, o 2 y 3. el intercambio son las permutaciones de n . imagine que hay p permutaciones de n . el número de formas diferentes de organizar dichas permutaciones es p**t . por tanto el número de isomorfas posibles es n!**t . y el número de rutas es ( t*n )!/( n!**t ). de nuevo, en nuestro caso t = 2, n = 2 obtenemos 6 (24/4). para n = 2 y t = 3 obtenemos 720/8 = 90. para n = 3 y t = 3 obtenemos 9!/6^3 = 1680. en nuestro sencillo caso de una sola línea de código java, que equivale a ocho líneas de código de bytes y a dos subprocesos, el número total de posibles rutas de ejecución es 12 870. si el tipo de lastidused es long , cada lectura y escritura se convierte en dos operaciones y no una, y el número de posibilidades asciende a 2 704 156. ¿qué sucede si realizamos un cambio en este método? 406public synchronized void incrementvalue() { ++lastidused; } el número de posibles rutas de ejecución es dos para dos subprocesos y n! para el caso general. un examen más profundo ¿qué piensa del sorprendente resultado de dos subprocesos que invoquen el método una vez (antes de añadir synchronized ) y obtengan el mismo resultado numérico? ¿cómo es posible? vayamos por partes. ¿qué es una operación atómica? podemos definir una operación atómica como toda operación ininterrumpible. por ejemplo, en el siguiente código, la línea 5, donde se asigna 0 a lastid , es atómica ya que de acuerdo al modelo de memoria de java, la asignación a un valor de 32 bits es ininterrumpible. 01: public class example { 02: int lastid; 03: 04: public void resetid() { 05: value = 0; 06: } 07: 08: public int getnextid() { 09: ++value; 10: } 11: } ¿qué sucede si cambiamos el tipo de lastid de int a long ? ¿sigue siendo atómica la línea 5? no de acuerdo a la especificación de la mvj. podría ser atómica en un procesador concreto, pero según la especificación de la mvj, la asignación a un valor de 64 bits requiere dos asignaciones de 32 bits. esto significa que entre la primera y la segunda podría irrumpir otro subproceso y cambiar uno de los valores. ¿y qué sucede con el operador de preincremento, ++ , de la línea 9? este operador se puede interrumpir, de modo que no es atómico. para entenderlo, repasemos el código de bytes de ambos métodos. antes de continuar, hay tres definiciones importantes: 407marco: la invocación de un método requiere un marco, el cual incluye la dirección de devolución, los parámetros pasados al método y las variables locales definidas en el mismo. es una técnica estándar empleada para definir una pila de invocaciones, que se usa en muchos lenguajes modernos para permitir la invocación de funciones y métodos básicos, además de invocaciones recursivas. variable local: las variables definidas en el ámbito del método. todos los métodos no estáticos tienen al menos una variable, this , que representa el objeto actual, el objeto que ha recibido el último mensaje (en el subproceso actual) que ha propiciado la invocación del método. pila de operandos: muchas instrucciones de la mvj aceptan parámetros. la pila de operandos es donde se incluyen dichos parámetros. la pila es una estructura de datos lifo ( last-in, first-out o último en entrar, primero en salir) estándar. veamos el código de bytes generado para resetid(). nemónico descripción pila de operandos posterior aload 0 cargar la variable 0 a en la pila de operandos. ¿qué es la variable 0 a ? es this. , el objeto actual. al invocar el método, el receptor del mensaje, una instancia de example , se envía a la matriz de variables locales del marco creado para la invocación de métodos. siempre es la primera variable que se añade a todos los métodos de instancia. this iconst_0 incluir el valor constante 0 en la pila de operandos. this, 0 putfield lastid almacenar el valor superior de la pila (0) en el valor de campo del objeto denominado por la referencia de objeto una posición alejada de la parte superior de la pila, this . <vacío> 408estas tres instrucciones son atómicas ya que a pesar de que el subproceso que las ejecuta podría verse interrumpido por cualquiera de ellas, la información para la instrucción putfield (el valor constante 0 de la parte superior de la pila y la referencia a éste una posición inferior, junto con el valor del campo) no se ve alterada por ningún otro subproceso. por tanto, al producirse la asignación, sabemos que el valor 0 se almacena en el valor del campo. la operación es atómica. todos los operandos procesan información local del método, de modo que no hay interferencias entre subprocesos. si estas instrucciones se ejecutan en diez subprocesos, hay 4.38679733629e+24 ordenaciones posibles. sin embargo, sólo hay un resultado posible, de modo que las distintas ordenaciones son irrelevantes. y además, se garantiza el mismo resultado para valores long en este caso. ¿por qué? los diez subprocesos asignan un valor constante. aunque se entremezclen, el resultado final será el mismo. habrá problemas con la operación ++ en el método getnextid . imagine que lastid contiene 42 al inicio de este método. veamos el código de bytes de este nuevo método: nemónico descripción pila de operandos posterior aload 0 cargar this en la pila de operandos. this dup copiar la parte superior de la pila. ahora tenemos dos copias de this en la pila de operandos. this, this getfield lastid recuperar el valor del campo lastid del objeto al que se apunta en la parte superior de la pila ( this ) y volver a almacenar el valor en la pila. this, 42 iconst_1 desplazar la constante entera 1 en la pila. this, 42, 1 iadd suma entera de los dos valores superiores de la pila de operandos y volver a almacenar el resultado en la pila. this, 43 dup_x1 duplicar el valor 43 y añadirlo delante de this . 43, this, 43 putfield almacenar el valor superior de la pila de operandos, 43 409value 43, en el valor de campo del objeto actual, representado por el siguiente valor superior de la pila de operandos, this . ireturn devolver el valor superior (y único) de la pila de operandos. <vacío> imagine que el primer subproceso completa las tres primeras instrucciones, hasta getfield incluida y después se interrumpe. aparece un segundo subproceso y ejecuta el método completo, incrementando lastid en uno; devuelve 43. tras ello, el primer subproceso retoma desde donde se detuvo; 42 sigue en la pila de operandos por ser el valor de lastid cuando ejecutó getfield . suma uno para obtener 43 y almacena el resultado. el valor 43 también se devuelve al primer subproceso. como resultado, uno de los incrementos se pierde ya que el primer subproceso interfiere con el segundo después de que éste haya interrumpido al primero. al convertir el método getnextid() en synchronized se corrige este problema. conclusión no se necesita un conocimiento extenso del código de bytes para entender cómo unos subprocesos interrumpen a otros. si consigue entender este ejemplo, demostrará la posibilidad de varios subprocesos entrelazados, un conocimiento suficiente. dicho esto, lo que este sencillo ejemplo revela es la necesidad de entender el modelo de memoria para saber qué se permite y qué no. equivocadamente se piensa que el operador ++ (pre o postincremento) es atómico, y evidentemente no lo es. esto significa que tiene que saber: dónde están los objetos y valores compartidos. el código que provoca problemas de lectura/actualización concurrente. cómo evitar que se produzcan dichos problemas. 410conocer su biblioteca la estructura executor como mostramos en executorclientscheduler.java , la estructura executor de java 5 permite la ejecución sofisticada por medio de agrupaciones de subprocesos. es una clase del paquete java.util.concurrent . si va a crear subprocesos y no usa una agrupación de subprocesos o utiliza una creada a mano, considere el uso de executor. hace que el código sea más limpio, más fácil de entender y de menor tamaño. la estructura executor agrupa subprocesos, los cambia automáticamente de tamaño y los vuelve a crear si es necesario. también admite futuros , una construcción de programación concurrente habitual. la estructura executor funciona con clases que implementan runnable y también con clases que implementan la interfaz callable . callable se parece a runnable , pero puede devolver un resultado, una necesidad habitual en soluciones de múltiples subprocesos. un futuro resulta muy útil cuando el código tiene que ejecutar varias operaciones independientes y esperar a que terminen: public string processrequest(string message) throws exception { callable<string> makeexternalcall = new callable<string>() { public string call() throws exception { string result = “”; // realizar solicitud externa return result; } }; future<string> result = executorservice.submit(makeexternalcall); string partialresult = dosomelocalprocessing(); return result.get() + partialresult; } en este ejemplo, el método comienza a ejecutar el objeto makeexternalcall , prosigue con otro procesamiento y la última línea invoca result.get(), que se bloquea hasta que el futuro termina. 411soluciones no bloqueantes la mv java 5 aprovecha el diseño de los procesadores modernos que admiten actualizaciones fiables y no bloqueantes. imagine una clase que usa sincronización (y por tanto bloqueo) para proporcionar la actualización compatible con subprocesos de un valor: public class objectwithvalue { private int value; public void synchronized incrementvalue() { ++value; } public int getvalue() { return value; } } java 5 dispone de varias clases nuevas para este tipo de situaciones, como por ejemplo atomicboolean , atomicinteger y atomicreference . podemos modificar el código anterior para usar un enfoque no bloqueante: public class objectwithvalue { private atomicinteger value = new atomicinteger(0); public void incrementvalue() { value.incrementandget(); } public int getvalue() { return value.get(); } } aunque use un objeto en lugar de una primitiva y envíe mensajes como incrementandget() en lugar de ++ , el rendimiento de esta clase supera en la mayoría de los casos al de la versión anterior. en algunos casos será ligeramente más rápido pero los casos en los que es más lento son prácticamente inexistentes. ¿cómo es posible? los procesadores modernos disponen de una operación denominada cas (compare and swap, comparar e intercambiar). es una operación similar al bloqueo optimista de una base de datos, mientras que la versión sincronizada es similar al bloqueo pesimista. la palabra clave synchronized siempre adquiere un bloqueo, incluso cuando un segundo subproceso no intenta actualizar el mismo valor. aunque el rendimiento de los bloqueos intrínsecos ha mejorado con respecto a versiones anteriores, sigue siendo muy costoso. la versión no bloqueante asume inicialmente que varios subprocesos no 412modifican el mismo valor con la suficiente periodicidad como para generar un problema. por el contrario, detecta de forma eficaz si se produce dicha situación y la reintenta hasta que la actualización es satisfactoria. esta detección suele ser menos costosa que la adquisición de un bloqueo, incluso en situaciones de contención moderada o alta. ¿cómo lo hace la mv? la operación cas es atómica. por tanto, la operación cas tiene este aspecto: int variablebeingset; void simulatenonblockingset (int newvalue) { int currentvalue; do { currentvalue = variablebeingset } while(currentvalue != compareandswap(currentvalue, newvalue)); } int synchronized compareandswap(int currentvalue, int newvalue) { if(variablebeingset == currentvalue) { variablebeingset = newvalue; return currentvalue; } return variablebeingset; } cuando un método intenta actualizar una variable compartida, la operación cas comprueba que la variable establecida sigue teniendo el último valor conocido. en caso afirmativo, se cambia la variable. en caso contrario, la variable no se establece ya que otro subproceso ha conseguido acceder. el método que realiza el intento (mediante la operación cas) ve que el cambio no se ha realizado y lo intenta de nuevo. clases incompatibles con subprocesos existen clases que no son compatibles con subprocesos, como las siguientes: simpledateformat . conexiones de base de datos. contenedores de java.util . 413servlet. algunas clases de colección tienen métodos concretos compatibles con subprocesos. sin embargo, cualquier operación que invoque más de un método no lo es. por ejemplo, si no quiere reemplazar algo en hashtable porque ya existe, podría crear el siguiente código: if(!hashtable.containskey(somekey)) { hashtable.put(somekey, new somevalue()); } cada uno de los métodos es compatible con subprocesos. sin embargo, otro subproceso podría añadir un valor entre las invocaciones de containskey y put . existen varias formas de solucionar este problema: bloquear primero hashtable y comprobar que los demás usuarios de hashtable hagan lo mismo; bloqueo basado en clientes: synchronized(map) { if(!map.containskey(key)) map.put(key,value); } envolver hashtable en su propio objeto y usar dos api distintas; bloqueo basado en servidores con un adaptador: public class wrappedhashtable<k, v> { private map<k, v> map = new hashtable<k, v>(); public synchronized void putifabsent(k key, v value) { if (map.containskey(key)) map.put(key, value); } } usar colecciones compatibles con subprocesos: concurrenthashmap<integer, string> map = new concurrenthashmap<integer, string>(); map.putifabsent(key, value); las colecciones de java.util.concurrent incluyen operaciones como putifabsent() para acomodar este tipo de operaciones. 414las dependencias entre métodos pueden afectar al código concurrente el siguiente ejemplo es una forma de añadir dependencias entre métodos: public class integeriterator implements iterator<integer> private integer nextvalue = 0; public synchronized boolean hasnext() { return nextvalue < 100000; } public synchronized integer next() { if (nextvalue == 100000) throw new iteratorpastendexception(); return nextvalue++; } public synchronized integer getnextvalue() { return nextvalue; } } veamos otro código que usa integeriterator : integeriterator iterator = new integeriterator(); while(iterator.hasnext()) { int nextvalue = iterator.next(); // hacer algo con nextvalue } si un subproceso ejecuta este código no habrá problemas. ¿qué sucede si dos subprocesos intentan compartir una misma instancia de integeriterator para procesar el valor que reciba cada uno pero cada elemento de la lista sólo se procesa una vez? en la mayoría de los casos, no hay consecuencias negativas; los subprocesos comparten la lista, procesan los elementos devueltos por el iterador y se detienen cuando éste termina. sin embargo, existe la posibilidad de que al final de la iteración los dos subprocesos interfieran entre ellos y provoquen que uno supere el final del iterador y se genere una excepción. el problema es el siguiente: el subproceso 1 pregunta hasnext() , que devuelve true . el subproceso 1 se evita y el subproceso 2 realiza la misma pregunta, que sigue siendo true . tras ello, el subproceso 2 invoca next() , que devuelve un valor, como era de esperar, pero como efecto secundario 415hace que hasnext() devuelva false . se vuelve a iniciar el subproceso 1, pensando que hasnext() sigue siendo true , y después invoca next() . aunque los métodos concretos están sincronizados, el cliente usa dos métodos. es un problema real y un ejemplo que puede surgir en código concurrente. en este caso concreto, el problema es especialmente sutil ya que la única ocasión en la que produce un fallo es durante la iteración final del iterador. si los subprocesos se dividen de forma correcta, puede que uno supere el final del iterador. es el tipo de error que surge en un sistema que lleva tiempo en producción, y es difícil de detectar. tiene tres opciones: tolerar el fallo. solucionar el problema cambiando el cliente: bloqueo basado en el cliente. solucionar el problema cambiando el servidor, lo que también provoca que cambie el cliente: bloqueo basado en el servidor. tolerar el fallo en ocasiones, los sistemas se configuran para que un fallo no produzca daños. por ejemplo, el cliente anterior podía capturar la excepción y limpiarla, aunque sería un tanto torpe. es como limpiar fugas de memoria reiniciando a medianoche. bloqueo basado en el cliente para que integeriterator funcione correctamente con varios subprocesos, cambie el cliente (y los demás) como se indica a continuación: integeriterator iterator = new integeriterator(); while (true) { int nextvalue; synchronized (iterator) { if (!iterator.hasnext()) break; nextvalue = iterator.next(); 416} dosometingwith(nextvalue); } cada cliente añade un bloqueo a través de la palabra clave synchronized . esta duplicación incumple el principio dry, pero puede ser necesaria si el código usa agrupaciones de terceros no compatibles con subprocesos. la estrategia es arriesgada ya que todos los programadores que usen el servidor deben acordarse de bloquearlo antes de usarlo y de desbloquearlo cuando terminen. hace muchos años, trabajé en un sistema que usaba el bloqueo basado en el cliente en un recurso compartido. el recurso se usaba en cientos de puntos distintos del código. un pobre programador se olvidó de bloquear el recurso en uno de esos puntos. era un sistema de varios terminales con software de contabilidad para el sindicato de transportistas. local 705. el ordenador se encontraba en una sala de temperatura controlada de un piso elevado, a unas 50 millas al norte de la sede de local 705. en la sede, decenas de trabajadores introducían datos en las terminales, conectadas al ordenador mediante líneas telefónicas dedicadas y módem semidúplex de 600bps (esto fue hace mucho , mucho tiempo). una vez al día, una de las terminales se bloqueaba, sin razón aparente. el bloqueo no tenía preferencia alguna por una terminal o una hora concreta. es como si alguien echara a suertes la terminal que bloquear y la hora del bloqueo. en ocasiones, se bloqueaba más de una terminal. en ocasiones, podían pasar varios días sin bloqueos. inicialmente, se optó por reiniciar como solución, pero era complicado coordinar los reinicios. tenemos que avisar a la sede y esperar a que todos terminaran lo que estuvieran haciendo en todas las terminales. tras ello, se apagaba el sistema y se reiniciaba. si alguien estaba haciendo algo importante para lo que necesitaba una o dos horas, la terminal bloqueada tenía que seguir bloqueada. tras varias semanas de depuración, descubrimos que la causa era un contador de búfer circular desincronizado con su puntero. este búfer controlaba la salida a la terminal. el valor del puntero indicaba que el búfer estaba vacío pero el contador mostraba que estaba lleno. como estaba vacío, no había nada que mostrar; pero como también estaba lleno, no se podía añadir nada al búfer que mostrar en la pantalla. 417sabíamos qué era lo que bloqueaba las terminales pero no qué provocaba la desincronización del búfer circular, por lo que añadimos un truco para resolver el problema. se podían leer los conmutadores del panel frontal en el ordenador (esto fue hace mucho, mucho, mucho tiempo). diseñamos una función de trampa que detectaba si uno de los conmutadores se había generado y después buscábamos un búfer circular que estuviera tanto lleno como vacío. si lo encontrábamos, lo variábamos. ¡ voilá ! la terminal bloqueada volvía a funcionar. de este modo no era necesario reiniciar el sistema si una terminal se bloqueaba. la sede nos llamaba y nos decía que había un bloqueo, nos acercábamos hasta la sala de ordenadores y pulsábamos un conmutador. en ocasiones ellos trabajan los fines de semana pero nosotros no. por ello, añadimos una función al programador que comprobaba los búfer circulares una vez por minuto y restablecía los que estuvieran tanto llenos como vacíos. de este modo se descongestionaban las pantallas antes de que la dirección llegara al teléfono. necesitamos varias semanas de análisis de código de lenguaje de ensamblado antes de localizar al culpable. habíamos calculado que la frecuencia de los bloqueos se debía a un uso desprotegido del búfer circular, así que sólo era necesario determinar el uso fallido. desafortunadamente, esto fue hace mucho tiempo y no disponíamos de herramientas de búsqueda, referencias cruzadas ni de otras técnicas automáticas de ayuda. teníamos que escudriñar los listados. en aquel frío invierno de 1971 en chicago aprendí que los bloqueos basados en el cliente son verdaderamente terribles. bloqueo basado en el servidor la duplicación se puede eliminar si modificamos integeriterator de esta forma: public class integeriteratorserverlocked { private integer nextvalue = 0; public synchronized integer getnextornull() { if (nextvalue < 100000) return nextvalue++; else return null; 418} } y también cambia el código cliente: while (true) { integer nextvalue = iterator.getnextornull(); if (next == null) break; // hacer algo con nextvalue } en este caso, en realidad cambiamos la api de la clase para que sea compatible con el subproceso [120] . el cliente debe realizar una comprobación de null en lugar de comprobar hasnext() . por lo general, el bloqueo basado en el servidor es preferible por estos motivos: reduce el código repetido: el bloqueo basado en el servidor hace que el cliente bloquee correctamente el servidor. al incluir el código de bloqueo en el servidor, se libera a los clientes para usar el objeto y no tener que preocuparse de crear código de bloqueo adicional. permite un mejor rendimiento: puede intercambiar un servidor compatible con subprocesos por otro incompatible en caso de desarrollo de un solo subproceso, lo que evita la sobrecarga. reduce las posibilidades de error: sólo se necesita un programador que se olvide del bloqueo. aplica una única política: la política se aplica solamente al servidor, no a todos los clientes. reduce el ámbito de las variables compartidas: el cliente las desconoce y tampoco sabe cómo se bloquean. todo se oculta en el servidor. cuando se produce un fallo, su origen se busca en menos puntos. ¿y si no es el propietario del código de servidor? usar un adaptador para cambiar la api y añadir bloqueo public class threadsafeintegeriterator { private integeriterator iterator = new integeriterator(); public synchronized integer getnextornull() { 419if(iterator.hasnext()) return iterator.next(); return null; } } mejor todavía, usar colecciones compatibles con subprocesos con interfaces ampliadas. aumentar la producción imagine que desea leer el contenido de una serie de páginas de una lista de url en la red. al leer cada página, la analizamos para acumular estadísticas. después de leer todas, imprimimos un informe de resumen. la siguiente clase devuelve el contenido de una página, dada una url. public class pagereader { //… public string getpagefor(string url) { httpmethod method = new getmethod(url); try { httpclient.executemethod(method); string response = method.getresponsebodyasstring(); return response; } catch (exception e) { handle(e); } finally { method.releaseconnection(); } } } la siguiente clase es el iterador que proporciona el contenido de las páginas en función de un iterador de url: public class pageiterator { private pagereader reader; private urliterator urls; public pageiterator(pagereader reader, urliterator urls) { this.urls = urls; this.reader = reader; } public synchronized string getnextpageornull() { if (urls.hasnext()) getpagefor(urls.next()); 420else return null; } public string getpagefor(string url) { return reader.getpagefor(ur1); } } se puede compartir una instancia de pageiterator entre varios subprocesos distintos, cada uno con su propia instancia de pagereader para leer las páginas que obtiene del iterador. hemos reducido el tamaño del bloque synchronized . simplemente contiene la sección crítica de pageiterator . siempre conviene sincronizar lo menos posible. cálculo de producción de un solo subproceso vayamos con los cálculos. imagine lo siguiente, de acuerdo al argumento anterior: tiempo de e/s para recuperar una página (de media): 1 segundo. tiempo de procesamiento para analizar la página (de media): .5 segundos. e/s requiere 0 por 100 de la cpu mientras que el procesamiento requiere 100 por 100. si se procesan n páginas en un mismo subproceso, el tiempo de ejecución total es de 1.5 segundos * n . en la figura a.1 puede ver una instantánea de 13 páginas, aproximadamente 19.5 segundos. figura a.1. un único subproceso 421cálculo de producción con varios subprocesos si se pueden recuperar páginas en cualquier orden y procesarlas de forma independiente, entonces es posible usar varios subprocesos para aumentar la producción. ¿qué sucede si usamos tres subprocesos? ¿cuántas páginas podemos obtener en el mismo tiempo? como se aprecia en la figura a.2, la solución con varios procesos permite que el análisis de las páginas vinculado al proceso se solape con la lectura de las mismas, vinculada a e/s. en un mundo ideal, significaría que el procesador se utiliza totalmente. cada lectura de página por segundo se solapa con dos análisis. por tanto, podemos procesar dos páginas por segundo, lo que triplica la producción de la solución con un solo proceso. figura a.2. tres subprocesos concurrentes. bloqueo mutuo imagine una aplicación web con dos agrupaciones de recursos compartidos de tamaño finito: una agrupación de conexiones de base de datos para tareas locales de almacenamiento de procesos. 422una agrupación de conexiones mq a un repositorio principal. imagine que hay dos operaciones en la aplicación: crear y actualizar: crear: adquirir una conexión al repositorio principal y la base de datos. comunicarse con el repositorio principal y después almacenar el trabajo local en la base de datos de procesos. actualizar: adquirir una conexión a la base de datos y después al repositorio principal. leer el trabajo de la base de datos y enviarlo al repositorio principal. ¿qué sucede con los usuarios que superan el tamaño de la agrupación? imagine que el tamaño de cada agrupación es 10 . 10 usuarios intentan usar crear, de modo que se adquieren diez conexiones de base de datos y cada subproceso se interrumpe después de esta adquisición pero antes de adquirir una conexión al repositorio principal. 10 usuarios intentan usar actualizar, de modo que se adquieren las diez conexiones al repositorio principal y cada subproceso se interrumpe después de adquirir el repositorio principal pero antes de adquirir una conexión a la base de datos. ahora los 10 subprocesos crear deben esperar a adquirir una conexión al repositorio principal pero los 10 subprocesos actualizar deben esperar a adquirir una conexión a la base de datos. bloqueo mutuo. el sistema no se recupera nunca. puede parecerle una situación improbable pero ¿quién desea un sistema que se colapsa cada semana? ¿quién quiere depurar un sistema con síntomas tan difíciles de reproducir? es el tipo de problema que tarda semanas en resolverse. una solución habitual consiste en añadir instrucciones de depuración para determinar qué sucede. evidentemente, estas instrucciones cambian tanto el código que el bloqueo mutuo se genera en otras situaciones y tarda meses en 423volver a producirse [121] . para solucionar realmente el problema del bloqueo absoluto, debemos entender sus causas. para que se produzca, deben darse cuatro condiciones: exclusión mutua. bloqueo y espera. no expropiación. espera circular. exclusión mutua la exclusión mutua se produce cuando varios subprocesos deben usar los mismos recursos y dichos recursos no se pueden usar en varios subprocesos al mismo tiempo. son de número limitado. un ejemplo típico de este tipo de recurso es una conexión de base de datos, un archivo abierto para escritura, un bloqueo de registro o un semáforo. bloqueo y espera cuando un subproceso adquiere un recurso, no lo libera hasta adquirir los demás recursos que necesita y terminar su trabajo. no expropiación un subproceso no puede adueñarse de los recursos de otro. cuando un subproceso obtiene un recurso, la única forma de que otro lo consiga es que el primero lo libere. espera circular 424también se denomina abrazo mortal. imagine dos subprocesos, t1 y t2, y dos recursos, r1 y r2. t1 tiene r1, t2 tiene r2. t1 también necesita r2 y t2 también necesita r1. es similar al diagrama de la figura a.3: figura a.3. estas cuatro condiciones deben cumplirse para que se produzca un bloqueo mutuo. si se incumple alguna de ellas, no se producirá. evitar la exclusión mutua una estrategia para evitar el bloqueo mutuo es impedir la condición de exclusión mutua, por medio de lo siguiente: usar recursos que permitan un uso simultáneo, como por ejemplo, atomicinteger . incrementar el número de recursos para que sea igual o mayor que el número de subprocesos implicados. comprobar que todos los recursos están libres antes de adquirir ninguno. desafortunadamente, la mayoría de recursos son limitados y no permiten un uso simultáneo, y es habitual que la identidad del segundo recurso se base en los resultados de operar sobre el primero, pero no se desanime, todavía 425quedan tres condiciones. evitar bloqueo y espera también puede eliminar el bloqueo mutuo si rechaza la espera. compruebe cada uno de los recursos antes de obtenerlos y libere todos los recursos y comience de nuevo si detecta uno que esté ocupado. este enfoque genera algunos problemas: inanición: un subproceso no consigue adquirir los recursos que necesita (puede que tenga una combinación exclusiva de recursos que casi nunca esté disponible). bloqueo activo: varios subprocesos pueden actuar al unísono, adquirir un recurso y liberarlo, de forma repetida. es especialmente probable en algoritmos de programación de cpu simples (como dispositivos incrustados o algoritmos de equilibrio de subprocesos escritos a mano). en ambos casos, se puede reducir la producción. el primero reduce la utilización de la cpu, mientras que el segundo genera una elevada utilización de la cpu sin sentido. aunque esta estrategia parezca ineficaz, es mejor que nada. como ventaja, siempre se puede implementar si todo lo demás falla. evitar la expropiación otra estrategia para evitar el bloqueo mutuo consiste en permitir que todos los subprocesos se apropien de los recursos de otros. suele realizarse a través de un sencillo mecanismo de solicitudes. cuando un subproceso descubre que hay un recurso ocupado, le solicita al propietario que lo libere. si el propietario también espera a otro recurso, lo libera y comienza de nuevo. es similar al enfoque anterior, pero, como ventaja, un subproceso puede esperar a un recurso, lo que reduce el número de reinicios. sin embargo, la gestión de todas estas solicitudes puede resultar complicada. 426evitar la espera circular es el enfoque más habitual para impedir el bloqueo mutuo. en la mayoría de sistemas, basta con una sencilla convención acordada entre ambas partes. en el ejemplo anterior del subproceso 1 que quiere tanto el recurso 1 como el 2, y el subproceso 2 que desea tanto el recurso 2 como el 1, al forzar a ambos subprocesos a que asignen los recursos en el mismo orden se imposibilita la espera circular. en general, si todos los subprocesos pueden acordar un orden global de los recursos y si todos asignan los recursos en ese orden, el bloqueo mutuo es imposible. pero como todas las estrategias, también se pueden producir problemas: el orden de adquisición puede no corresponderse al orden de uso; por tanto, un recurso adquirido al inicio puede que no se use hasta el final. esto puede bloquear recursos más tiempo de lo estrictamente necesario. en ocasiones no se puede imponer un orden de adquisición de recursos. si el id del segundo recurso proviene de una operación realizada en el primero, ese orden no es factible. por tanto, existen varias formas de evitar el bloqueo mutuo. algunas provocan inanición, mientras que otras usan la cpu en exceso y reducen la capacidad de respuesta. ¡ tanstaafl ! [122] el aislamiento de la parte relacionada con subprocesos de su solución para permitir ajustes y experimentación es una forma de aprender a determinar las estrategias óptimas. probar código con múltiples subprocesos ¿cómo se puede crear una prueba que demuestre que el siguiente código no es correcto? 01: public class classwiththreadingproblem { 02: int nextid; 03: 42704: public int takenextid() { 05: return nextid++; 06: } 07: } veamos la descripción de una prueba que lo demuestre: recordar el valor actual de nextid . crear dos subprocesos y que cada uno invoque takenextid() una vez. comprobar que el valor de nextid es dos más que el inicial. ejecutar hasta demostrar que nextid sólo se ha incrementado en uno y no en dos. en el listado a-2 se reproduce la prueba: listado a-2 classwiththreadingproblemtest.java. 01: package example; 02: 03: import static org.junit.assert.fail; 04: 05: import org.junit.test; 06: 07: public class classwiththreadingproblemtest { 08: @test 09: public void twothreadsshouldfaileventually() throws exception { 10: final classwiththreadingproblem classwiththreadingproblem = new classwiththreadingproblem(); 11: 12: runnable runnable = new runnable() { 13: public void run() { 14: classwiththreadingproblem.takenextid(); 15: } 16: }; 17: 18: for (int i = 0; i < 50000; ++i) { 19: int startingid = classwiththreadingproblem.lastid; 20: int expectedresult = 2 + startingid; 21: 22: thread t1 = new thread(runnable); 42823: thread t2 = new thread(runnable); 24: t1.start(); 25: t2.start(); 26: t1.join(); 27: t2.join(); 28: 29: int endingid = classwiththreadingproblem.lastid; 30: 31: if (endingid != expectedresult) 32: return; 33: } 34: 35: fail(“should have exposed a threading issue but it did not.”); 36: } 37: } línea descripción 10 crear una sola instancia de classwiththreadingproblem . debemos usar la palabra clave final ya que se usa después en una clase interna anónima. 12-16 crear una clase interna anónima que use la instancia de classwiththreadingproblem . 18 ejecutar este código hasta demostrar que falla, pero no tanto como para que la prueba tarde demasiado. es un acto de equilibrio; no queremos esperar demasiado para demostrar el fallo. elegir la cantidad de ejecuciones es complicado, aunque como veremos después, esta cifra se puede reducir considerablemente. 19 recordar el valor inicial, la prueba intenta demostrar que el código de classwiththreadingproblem es incorrecto. si se supera la prueba, lo habrá demostrado. si la prueba falla, habrá sido incapaz de demostrarlo. 20 esperamos que el valor final sea dos más que el actual. 22-23 crear dos subprocesos que usen el objeto creado en las líneas 12-16. de este modo contamos con dos posibles subprocesos que intentan usar nuestra instancia de classwiththreadingproblem y ambos interfieren entre sí. 24-25 hacer que los dos subprocesos se puedan ejecutar. 42926-27 esperar a que terminen los dos subprocesos antes de comprobar los resultados. 29 registrar el valor final. 31-32 ¿es diferente endingid a lo que esperábamos? en caso afirmativo, se finaliza la prueba; hemos demostrado que el código es incorrecto. en caso negativo, volver a intentarlo. 35 si hemos llegado hasta aquí, la prueba no ha podido demostrar que el código de producción era incorrecto en una cantidad de tiempo razonable; el código ha fallado. o no es incorrecto o no hemos realizado suficientes iteraciones para que se produzca la condición de fallo. esta prueba establece las condiciones de un problema de actualización concurrente. sin embargo, el problema es tan infrecuente que la mayoría de las veces la prueba no lo detecta. en realidad, para detectar el problema debemos establecer el número de iteraciones en más de un millón. incluso con esa cantidad, en diez ejecuciones de un bucle de 1 000 000, el problema sólo apareció una vez, lo que significa que debemos aumentar las iteraciones para obtener fallos fiables. ¿cuánto estamos dispuestos a esperar? aunque ajustáramos la prueba para obtener fallos fiables en un equipo, seguramente tendríamos que ajustarla con otros valores para ilustrar el fallo en otro equipo, sistema operativo o versión de la mvj. y es un problema sencillo . si no podemos demostrarlo, ¿qué pasará cuando detectemos problemas realmente complejos? ¿qué enfoques debemos adoptar para demostrar este sencillo fallo? y, sobre todo, ¿cómo podemos crear pruebas que demuestren fallos en un código más complejo? ¿cómo podremos saber si el código tiene fallos cuando ni siquiera sabemos dónde buscar? veamos algunas sugerencias: pruebas monte carlo: crear pruebas flexibles que se puedan ajustar. después, ejecutarlas repetidamente, por ejemplo, en un servidor de prueba, y cambiar los valores de ajuste aleatoriamente. si las pruebas 430fallan, el código es incorrecto. diseñe las pruebas en las fases iniciales para que un servidor de integración continua las ejecute lo antes posible. registre las condiciones de fallo de las pruebas. ejecutar la prueba en todas las plataformas de desarrollo: de forma repetida y continuada. cuanto más tiempo se ejecuten las pruebas sin fallos, más probable es que el código de producción sea correcto o las pruebas no sean adecuadas para revelar los problemas. ejecutar las pruebas en un equipo con distintas cargas: si puede simular cargas similares a las del entorno de producción, hágalo. sin embargo, aunque realice todos estos pasos, no es probable que detecte problemas de subprocesos en el código. los problemas más complicados son los que sólo se producen una vez cada mil millones de oportunidades. son el azote de los sistemas complejos. herramientas para probar código basado en subprocesos ibm ha creado la herramienta contest [123] . lo que hace es instrumentar las clases para aumentar las probabilidades de que falle el código sin subprocesos. no tenemos relación directa con ibm ni con el equipo que ha desarrollado contest. un colega nos la descubrió. tras varios minutos de usarla, notamos una gran mejoría en la detección de errores. a continuación, le indicamos cómo usar contest: crear pruebas y código de producción, asegurándonos que haya pruebas diseñadas específicamente para simular varios usuarios con diferentes cargas, como mencionamos antes. instrumentar el código de pruebas y producción con contest. ejecutar las pruebas. 431al instrumentar el código con contest, la tasa de éxito pasó de un fallo por cada millón de iteraciones a un fallo en 30 iteraciones. los valores de bucle de las distintas ejecuciones de la prueba tras la instrumentación son los siguientes: 13, 23, 0, 54, 16, 14, 6, 69, 107, 49, 2. evidentemente, las clases instrumentadas fallaban antes y con mayor fiabilidad. conclusión en este capítulo hemos realizado un breve recorrido por el vasto y complejo territorio de la programación concurrente. apenas hemos mostrado la superficie. nos hemos centrado en disciplinas para mantener la limpieza del código concurrente, pero hay mucho más que aprender si tiene pensado diseñar sistemas concurrentes. le recomendamos que empiece por el libro de doug lea concurrent programming in java: design principles and patterns [124] . en este capítulo hemos presentado la actualización concurrente y las disciplinas de sincronización y bloqueo para evitarla. hemos visto cómo los subprocesos pueden mejorar la producción de un sistema vinculado a e/s y las técnicas limpias para lograr dichas mejoras. hemos descrito el bloqueo mutuo y las disciplinas para evitarlo de forma limpia. por último, hemos analizado estrategias para mostrar problemas de concurrencia mediante la instrumentación del código. ejemplos de código completos cliente/servidor sin subprocesos listado a-3 server.java package com.objectmentor.clientserver.nonthreaded; 432import java.io.ioexception; import java.net.serversocket; import java.net.socket; import java.net.socketexception; import common.messageutils; public class server implements runnable { serversocket serversocket; volatile boolean keepprocessing = true; public server(int port, int millisecondstimeout) throws ioexception { serversocket = new serversocket(port); serversocket.setsotimeout(millisecondstimeout); } public void run() { system.out.printf(“server starting\n”); while (keepprocessing) { try { system.out.printf(“accepting client\n”); socket socket = serversocket.accept(); system.out.printf(“got client\n”); process(socket); } catch (exception e) { handle(e); } } } private void handle(exception e) { if (!(e instanceof socketexception)) { e.printstacktrace(); } } public void stopprocessing() { keepprocessing = false; closeignoringexception(serversocket); } void process(socket socket) { if (socket == null) return; try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); 433closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } private void closeignoringexception(socket socket) { if (socket != null) try { socket.close(); } catch (ioexception ignore) { } } private void closeignoringexception(serversocket serversocket) { if (serversocket != null) try { serversocket.close(); } catch (ioexception ignore) { } } } listado a-4 clienttest.java. package com.objectmentor.clientserver.nonthreaded; import java.io.ioexception; import java.net.serversocket; import java.net.socket; import java.net.socketexception; import common.messageutils; public class server implements runnable { serversocket serversocket; volatile boolean keepprocessing = true; public server(int port, int millisecondstimeout) throws ioexception { serversocket = new serversocket(port); serversocket.setsotimeout(millisecondstimeout); } public void run() { system.out.printf(“server starting\n”); while (keepprocessing) { try { system.out.printf(“accepting client\n”); socket socket = serversocket.accept(); system.out.printf(“got client\n”); process(socket); } catch (exception e) { 434handle(e); } } } private void handle(exception e) { if (!(e instanceof socketexception)) { e.printstacktrace(); } } public void stopprocessing() { keepprocessing = false; closeignoringexception(serversocket); } void process(socket socket) { if (socket == null) return; try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } private void closeignoringexception(socket socket) { if (socket != null) try { socket.close(); } catch (ioexception ignore) { } } private void closeignoringexception(serversocket serversocket) { if (serversocket != null) try { serversocket.close(); } catch (ioexception ignore) { } } } listado a-5 435messageutils.java. package common; import java.io.ioexception; import java.io.inputstream; import java.io.objectinputstream; import java.io.objectoutputstream; import java.io.outputstream; import java.net.socket; public class messageutils { public static void sendmessage(socket socket, string message) throws ioexception { outputstream stream = socket.getoutputstream(); objectoutputstream oos = new objectoutputstream(stream); oos.writeutf(message); oos.flush(); } public static string getmessage(socket socket) throws ioexception { inputstream stream = socket.getinputstream(); objectinputstream ois = new objectinputstream(stream); return ois.readutf(); } } cliente/servidor con subprocesos para cambiar el servidor para que use subprocesos basta con cambiar el mensaje process (las nuevas líneas se muestran en negrita para destacarlas): void process(final socket socket) { if (socket == null) return; runnable clienthandler = new runnable() { public void run() { try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } 436}; thread clientconnection = new thread(clienthandler); clientconnection.start(); } 437apéndice b org.jfree.date.serialdate listado b-1 serialdate.java 1 /*============================================================== 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 *============================================================== 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia 17 * pública general gnu si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110- 1301, 22 * ee.uu. 23 * 43824 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ------------------ 28 * serialdate.java 29 * ------------------ 30 * (c) copyright 2001-2005, de object refinery limited. 31 * 32 * autor original: david gilbert (para object refinery limited); 33 * colaborador(es): -; 34 * 35 * $id: serialdate.java,v 1.7 2005/11/03 09:25:17 mungady exp $ 36 * 37 * cambios (11-oct-2001) 38 * -------------------------------------- 39 * 11-oct-2001: reorganización de la clase y cambio a un nuevo paquete 40 * com.jrefinery.date (dg); 41 * 05-nov-2001: se añade un método getdescription() y se elimina la clase 42 * notabledate (dg); 43 * 12-nov-2001: ibd requiere el método setdescription(), una vez eliminada la clase 44 * notabledate (dg); se cambian getpreviousdayofweek(), 45 * getfollowingdayofweek() y getnearestdayofweek() para corregir 46 * errores (dg); 47 * 05-dic-2001: error corregido en la clase spreadsheetdate (dg); 48 * 29-may-2002: se transfieren las constantes de mes a una interfaz independiente 49 * (monthconstants) (dg); 50 * 27-ago-2002: error corregido en el método addmonths(), gracias a nálevka petr (dg); 51 * 03-oct-2002: errores indicados por checkstyle (dg) corregidos; 52 * 13-mar-2003: implementación de serializable (dg); 53 * 29-may-2003: error corregido en el método addmonths (dg); 54 * 04-sep-2003: implementación de comparable. actualización de los javadoc isinrange (dg); 55 * 05-ene-2005: error corregido en el método addyears() (1096282) (dg); 56 * 57 */ 58 59 package org.jfree.date; 60 61 import java.io.serializable; 62 import java.text.dateformatsymbols; 63 import java.text.simpledateformat; 64 import java.util.calendar; 65 import java.util.gregoriancalendar; 43966 67 /** 68 * clase abstracta que define nuestros requisitos para manipular fechas, 68 * sin limitación a una determinada implementación. 70 * <p> 71 * requisito 1: coincidir al menos con el procesamiento de fechas en excel; 72 * requisito 2: la clase es inmutable; 73 * <p> 74 * ¿por qué no usar java.util.date? lo haremos, cuando tenga sentido. en ocasiones, 75 * java.util.date puede ser demasiado precisa; representa un instante en el tiempo, 76 * con una precisión de 1/1000 de segundo (y la fecha depende de la 77 * zona horaria). en ocasiones sólo querremos representar un día concreto (como el 21 78 * de enero de 2015) sin preocuparnos de la hora del día, la 79 * zona horaria u otros aspectos. para eso hemos definido daydate. 80 * <p> 81 * puede invocar getinstance() para obtener una subclase concreta de serialdate, 82 * sin preocuparse de su implementación exacta 83 * 84 * @author david gilbert 85 */ 86 public abstract class serialdate implements comparable, 87 serializable, 88 monthconstants { 89 90 /** para serialización. */ 91 private static final long serialversionuid = -293716040467423637l; 92 93 /** símbolos de formato de fecha. */ 94 public static final dateformatsymbols 95 date_format_symbols = new simpledateformat().getdateformatsymbols(); 96 97 /** número de serie para el 1 de enero de 1900. */ 98 public static final int serial_lower_bound = 2; 99 100 /** número de serie para el 31 de diciembre de 9999. */ 101 public static final int serial_upper_bound = 2958465; 102 103 /** valor de año más bajo admitido por este formato de fecha. */ 104 public static final int minimum_year_supported = 1900; 105 106 /** valor de año más alto admitido por este formato de fecha. */ 440107 public static final int maximum_year_supported = 9999; 108 109 /** constante útil para lunes; equivale a java.util.calendar.monday. */ 110 public static final int monday = calendar.monday; 111 112 /** 113 * constante útil para martes; equivale a java.util.calendar.tuesday. 114 * / 115 public static final int tuesday = calendar.tuesday; 116 117 /** 118 * constante útil para miércoles; equivale a 119 * java.util.calendar.wednesday. 120 */ 121 public static final int wednesday = calendar.wednesday; 122 123 /** 124 * constante útil para jueves; equivale a java.util.calendar.thursday. 125 */ 126 public static final int thursday = calendar.thursday; 127 128 /** constante útil para viernes; equivale a java.util.calendar.friday. */ 129 public static final int friday = calendar.friday; 130 131 /** 132 * constante útil para sábado; equivale a java.util.calendar.saturday. 133 */ 134 public static final int saturday = calendar.saturday; 135 136 /** constante útil para domingo; equivale a java.util.calendar.sunday. */ 137 public static final int sunday = calendar.sunday; 138 139 /** número de días de cada mes en años no bisiestos. */ 140 static final int[] last_day_of_month = 141 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 142 143 /** número de días en un año (no bisiesto) hasta el final de cada mes. */ 144 static final int[] aggregate_days_to_end_of_month = 145 {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 146 147 /** número de días en un año hasta el final del mes anterior. */ 148 static final int[] aggregate_days_to_end_of_preceding_month = 441149 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 150 151 /** número de días en un año bisiesto hasta el final de cada mes. */ 152 static final int[] leap_year_aggregate_days_to_end_of_month = 153 {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 154 155 /** 156 * número de días en un año bisiesto hasta el final del mes anterior. 157 */ 158 static final int[] 159 leap_year_aggregate_days_to_end_of_preceding_month = 160 {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 161 162 /** una constante útil para hacer referencia a la primera semana del mes. */ 163 public static final int first_week_in_month = 1; 164 165 /** una constante útil para hacer referencia a la segunda semana del mes. */ 166 public static final int second_week_in_month = 2; 167 168 /** una constante útil para hacer referencia a la tercera semana del mes. */ 169 public static final int third_week_in_month = 3; 170 171 /** una constante útil para hacer referencia a la cuarta semana del mes. */ 172 public static final int fourth_week_in_month = 4; 173 174 /** una constante útil para hacer referencia a la última semana del mes. */ 175 public static final int last_week_in_month = 0; 176 177 /** constante de intervalo. */ 178 public static final int include_none = 0; 179 180 /** constante de intervalo. */ 181 public static final int include_first = 1; 182 183 /** constante de intervalo. */ 184 public static final int include_second = 2; 185 186 /** constante de intervalo. */ 187 public static final int include_both = 3; 188 189 /** 442190 * constante útil para especificar un día de la semana con respecto a una fecha 191 * fija. 192 */ 193 public static final int preceding = -1; 194 195 /** 196 * constante útil para especificar un día de la semana con respecto a una fecha 197 * fija. 198 */ 199 public static final int nearest = 0; 200 201 /** 202 * constante útil para especificar un día de la semana con respecto a una fecha 203 * fija. 204 */ 205 public static final int following = 1; 206 207 /** una descripción para la fecha. */ 208 private string description; 209 210 /** 211 * constructor predeterminado. 212 */ 213 protected serialdate() { 214 } 215 216 /** 217 * devuelve <code>true</code> si el código entero proporcionado representa un 218 * día de la semana válido y <code>false</code> en caso contrario. 219 * 220 * @param code el código del que se comprueba la validez. 221 * 222 * @return <code>true</code> si el código entero proporcionado representa un 223 * día de la semana válido y <code>false</code> en caso contrario. 224 */ 225 public static boolean isvalidweekdaycode(final int code) { 227 switch(code) { 228 case sunday: 229 case monday: 230 case tuesday: 231 case wednesday: 443232 case thursday: 233 case friday: 234 case saturday: 235 return true; 236 default: 237 return false; 238 } 239 240 } 241 242 /** 243 * convierte la cadena proporcionada en un día de la semana. 244 * 245 * @param s una cadena que representa el día de la semana. 246 * 247 * @return <code>-1</code> si la cadena no se puede convertir o el día de 248 * la semana en caso contrario. 249 */ 250 public static int stringtoweekdaycode(string s) { 251 252 final string[] shortweekdaynames 253 = date_format_symbols.getshortweekdays(); 254 final string[] weekdaynames = date_format_symbols.getweekdays(); 255 256 int result = -1; 257 s = s.trim(); 258 for (int i = 0; i < weekdaynames.length; i++) { 259 if (s.equals(shortweekdaynames[i])) { 260 result = i; 261 break; 262 } 263 if (s.equals(weekdaynames[i])) { 264 result = i; 265 break; 266 } 267 } 268 return result; 269 270 } 271 272 /** 273 * devuelve una representación en cadena del día de la semana proporcionado. 274 * <p> 275 * necesitamos un enfoque mejor. 444276 * 277 * @param weekday el día de la semana. 278 * 279 * @return una cadena que representa el día de la semana proporcionado. 280 */ 281 public static string weekdaycodetostring(final int weekday) { 282 283 final string[] weekdays = date_format_symbols.getweekdays(); 284 return weekdays[weekday]; 285 286 } 287 288 /** 289 * devuelve una matriz de nombres de mes. 290 * 291 * @return una matriz de nombres de mes. 292 */ 293 public static string[] getmonths() { 294 295 return getmonths(false); 296 297 } 298 299 /** 300 * devuelve una matriz de nombres de mes. 301 * 302 * @param shortened un indicador para indicar que deben devolverse los nombres 303 * de mes en formato reducido. 304 * 305 * @return una matriz de nombres de mes. 306 */ 307 public static string[] getmonths(final boolean shortened) { 308 309 if (shortened) { 310 return date_format_symbols.getshortmonths(); 311 } 312 else { 313 return date_format_symbols.getmonths(); 314 } 315 316 } 317 318 /** 319 * devuelve true si el código entero proporcionado representa un mes 445válido. 320 * 321 * @param code el código del que se comprueba la validez. 322 * 323 * return <code>true</code> si el código entero proporcionado representa un 324 * mes válido. 325 */ 326 public static boolean isvalidmonthcode(final int code) { 327 328 switch(code) { 329 case january: 330 case february: 331 case march: 332 case april: 333 case may: 334 case june: 335 case july: 336 case august: 337 case september: 338 case october: 339 case november: 340 case december: 341 return true; 342 default: 343 return false; 344 } 345 346 } 347 348 /** 349 * devuelve el trimestre del mes especificado. 350 * 351 * @param code el código del mes (1-12). 352 * 353 * @return el trimestre al que pertenece el mes. 354 * @throws java.lang.illegalargumentexception 355 */ 356 public static int monthcodetoquarter(final int code) { 357 358 switch(code) { 359 case january: 360 case february: 361 case march: return 1; 362 case april: 446363 case may: 364 case june: return 2; 365 case july: 366 case august: 367 case september: return 3; 368 case october: 369 case november: 370 case december: return 4; 371 default: throw new illegalargumentexception( 372 “serialdate.monthcodetoquarter: invalid month code.”); 373 } 374 375 } 376 377 /** 378 * devuelve una cadena que representa el mes proporcionado. 379 * <p> 380 * la cadena devuelta es la forma extensa del nombre del mes obtenido de la 381 * configuración regional. 382 * 383 * @param month el mes. 384 * 385 * @return una cadena que representa el mes proporcionado 386 */ 387 public static string monthcodetostring(final int month) { 388 389 return monthcodetostring(month, false); 390 391 } 392 393 /** 394 * devuelve una cadena que representa el mes proporcionado. 395 * <p> 396 * la cadena devuelta es la forma extensa o reducida del nombre del mes 397 * obtenido de la configuración regional. 398 * 399 * @param month el mes. 400 * @param shortened si <code>true</code> devuelve la abreviatura del 401 * mes. 402 * 403 * @return una cadena que representa el mes proporcionado. 404 * @throws java.lang.illegalargumentexception 405 */ 406 public static string monthcodetostring(final int month, 447407 final boolean shortened) { 408 409 // comprobar argumentos… 410 if (!isvalidmonthcode(month)) { 411 throw new illegalargumentexception( 412 “serialdate.monthcodetostring: month outside valid range.”); 413 } 414 415 final string[] months; 416 417 if (shortened) { 418 months = date_format_symbols.getshortmonths(); 419 } 420 else { 421 months = date_format_symbols.getmonths(); 422 } 423 424 return months[month - 1]; 425 426 } 427 428 /** 429 * convierte una cadena en el código del mes. 430 * <p> 431 * este método devuelve una de las constantes january, february, …, 432 * december correspondientes a la cadena. si la cadena no se 433 * reconoce, este método devuelve -1. 434 * 435 * @param s la cadena que analizar. 436 * 437 * @return <code>-1</code> si la cadena no se puede analizar, o el mes del 438 * año en caso contrario. 439 */ 440 public static int stringtomonthcode(string s) { 441 442 final string[] shortmonthnames = date_format_symbols.getshortmonths(); 443 final string[] monthnames = date_format_symbols.getmonths(); 444 445 int result = -1; 446 s = s.trim(); 447 448 // primero intentar analizar la cadena como entero (1-12)… 449 try { 450 result = integer.parseint(s); 448451 } 452 catch (numberformatexception e) { 453 // suprimir 454 } 455 456 // buscar por los nombres de los meses… 457 if ((result < 1) || (result > 12)) { 458 for (int i = 0; i < monthnames.length; i++) { 459 if (s.equals(shortmonthnames[i])) { 460 result = i + 1; 461 break; 462 } 463 if (s.equals(monthnames[i])) { 464 result = i + 1; 465 break; 466 } 467 } 468 } 469 470 return result; 471 472 } 473 474 /** 475 * devuelve true si el código entero proporcionado representa una semana 476 * del mes válida y false en caso contrario 477 * 478 * @param code el código del que se comprueba la validez. 479 * @return <code>true</code> si el código entero proporcionado representa una 480 * semana del mes válida. 481 */ 482 public static boolean isvalidweekinmonthcode(final int code) { 483 484 switch(code) { 485 case first_week_in_month: 486 case second_week_in_month: 487 case third_week_in_month: 488 case fourth_week_in_month: 489 case last_week_in_month: return true; 490 default: return false; 491 } 492 493 } 449494 495 /** 496 * determina si el año especificado es bisiesto o no. 497 * 498 * @param yyyy el año (entre 1900 y 9999). 499 * 500 * @return <code>true</code> si el año especificado es bisiesto. 501 */ 502 public static boolean isleapyear(final int yyyy) { 503 504 if ((yyyy % 4) != 0) { 505 return false; 506 } 507 else if ((yyyy % 400) == 0) { 508 return true; 509 } 510 else if ((yyyy % 100) == 0) { 511 return false; 512 } 513 else { 514 return true; 515 } 516 517 } 518 519 /** 520 * devuelve el número de años bisiestos desde 1900 hasta el año especificado 521 * inclusive. 522 * <p> 523 * 1900 no es un año bisiesto. 524 * 525 * @param yyyy el año (entre 1900 y 9999). 526 * 527 * @return el número de años bisiestos desde 1900 hasta el año especificado. 528 */ 529 public static int leapyearcount(final int yyyy) { 530 531 final int leap4 = (yyyy - 1896) / 4; 532 final int leap100 = (yyyy - 1800) / 100; 533 final int leap400 = (yyyy - 1600) / 400; 534 return leap4 - leap100 + leap400; 535 536 } 537 450538 /** 539 * devuelve el número del último día del mes, teniendo en cuenta los 540 * años bisiestos. 541 * 542 * @param month el mes. 543 * @param yyyy el año (entre 1900 y 9999). 544 * 545 * @return el número del último día del mes. 546 */ 547 public static int lastdayofmonth(final int month, final int yyyy) { 548 549 final int result = last_day_of_month[month]; 550 if (month != february) { 551 return result; 552 } 553 else if (isleapyear(yyyy)) { 554 return result + 1; 555 } 556 else { 557 return result; 558 } 559 560 } 561 562 /** 563 * crea una nueva fecha añadiendo el número especificado de días a la fecha 564 * base. 565 * 566 * @param days el número de días que añadir (puede ser negativo). 567 * @param base la fecha base. 568 * 569 * @return una nueva fecha. 570 */ 571 public static serialdate adddays(final int days, final serialdate base) { 572 573 final int serialdaynumber = base.toserial() + days; 574 return serialdate.createinstance(serialdaynumber); 575 576 } 577 578 /** 579 * crea una nueva fecha añadiendo el número especificado de meses a la fecha 580 * base. 451581 * <p> 582 * si la fecha base es próxima al final del mes, el día del resultado 583 * se puede ajustar ligeramente: 31 mayo + 1 mes = 30 junio. 584 * 585 * @param months el número de meses que añadir (puede ser negativo). 586 * @param base la fecha base. 587 * 588 * @return una nueva fecha. 589 */ 590 public static serialdate addmonths(final int months, 591 final serialdate base) { 592 593 final int yy = (12 * base.getyyyy() + base.getmonth() + months - 1) 594 / 12; 595 final int mm = (12 * base.getyyyy() + base.getmonth() + months – 1) 596 % 12 + 1; 597 final int dd = math.min( 598 base.getdayofmonth(), serialdate.lastdayofmonth(mm, yy) 599 ); 600 return serialdate.createinstance(dd, mm, yy); 601 602 } 603 604 /** 605 * crea una nueva fecha añadiendo el número especificado de años a la fecha 606 * base. 607 * 608 * @param years el número de años que añadir (puede ser negativo). 609 * @param base la fecha base. 610 * 611 * @return una nueva fecha. 612 */ 613 public static serialdate addyears(final int years, final serialdate base) { 614 615 final int basey = base.getyyyy(); 616 final int basem = base.getmonth(); 617 final int based = base.getdayofmonth(); 618 619 final int targety = basey + years; 620 final int targetd = math.min( 621 based, serialdate.lastdayofmonth(basem, targety) 622 ); 623 624 return serialdate.createinstance(targetd, basem, targety); 452625 626 } 627 628 /** 629 * devuelve la última fecha correspondiente al día de la semana especificado y 630 * anterior a la fecha base. 631 * 632 * @param targetweekday un código para el día de la semana de destino. 633 * @param base la fecha base. 634 * 635 * @return la última fecha correspondiente al día de la semana especificado y 636 * anterior a la fecha base. 637 */ 638 public static serialdate getpreviousdayofweek(final int targetweekday, 639 final serialdate base) { 640 641 // comprobar argumentos… 642 if (!serialdate.isvalidweekdaycode(targetweekday)) { 643 throw new illegalargumentexception( 644 “invalid day-of-the-week code.” 645 ); 646 } 647 648 // buscar la fecha… 649 final int adjust; 650 final int basedow = base.getdayofweek(); 651 if (basedow > targetweekday) { 652 adjust = math.min(0, targetweekday - basedow); 653 } 654 else { 655 adjust = -7 + math.max(0, targetweekday - basedow); 656 } 657 658 return serialdate.adddays(adjust, base); 659 660 } 661 662 /** 663 * devuelve la primera fecha que coincide con el día de la semana especificado 664 * y posterior a la fecha base. 665 * 666 * @param targetweekday un código para el día de la semana de destino. 453667 * @param base la fecha base. 668 * 669 * @return la primera fecha que coincide con el día de la semana especificado 670 * y posterior a la fecha base. 671 */ 672 public static serialdate getfollowingdayofweek(final int targetweekday, 673 final serialdate base) { 674 675 // comprobar argumentos… 676 if (!serialdate.isvalidweekdaycode(targetweekday)) { 677 throw new illegalargumentexception( 678 “invalid day-of-the-week code.” 679 ); 680 } 681 682 // buscar la fecha… 683 final int adjust; 684 final int basedow = base.getdayofweek(); 685 if (basedow > targetweekday) { 686 adjust = 7 + math.min(0, targetweekday - basedow); 687 } 688 else { 689 adjust = math.max(0, targetweekday - basedow); 690 } 691 692 return serialdate.adddays(adjust, base); 693 } 694 695 /** 696 * devuelve la fecha que coincide con el día de la semana especificado y más 697 * próxima a la fecha base. 698 * 699 * @param targetdow un código para el día de la semana de destino. 700 * @param base la fecha base. 701 * 702 * @return la fecha que coincide con el día de la semana especificado y más 703 * próxima a la fecha base. 704 */ 705 public static serialdate getnearestdayofweek(final int targetdow, 706 final serialdate base) { 707 708 // comprobar argumentos… 454709 if (!serialdate.isvalidweekdaycode(targetdow)) { 710 throw new illegalargumentexception( 711 “invalid day-of-the-week code.” 712 ); 713 } 714 715 // buscar la fecha… 716 final int basedow = base.getdayofweek(); 717 int adjust = -math.abs(targetdow - basedow); 718 if (adjust >= 4) { 719 adjust = 7 - adjust; 720 } 721 if (adjust <= -4) { 722 adjust = 7 + adjust; 723 } 724 return serialdate.adddays(adjust, base); 725 726 } 727 728 /** 729 * avanzar la fecha hasta el último día del mes. 730 * 731 * @param base la fecha base. 732 * 733 * @return una nueva fecha de serie. 734 */ 735 public serialdate getendofcurrentmonth(final serialdate base) { 736 final int last = serialdate.lastdayofmonth( 737 base.getmonth(), base.getyyyy() 738 ); 739 return serialdate.createinstance(last, base.getmonth(), base.getyyyy()); 740 } 741 742 /** 743 * devuelve una cadena correspondiente al código de la semana del mes. 744 * <p> 745 * necesitamos un enfoque mejor. 746 * 747 * @param count un código entero que representa la semana del mes. 748 * 749 * @return una cadena correspondiente al código de la semana del mes. 750 */ 751 public static string weekinmonthtostring(final int count) { 752 455753 switch (count) { 754 case serialdate.first_week_in_month : return “first”; 755 case serialdate.second_week_in_month : return “second”; 756 case serialdate.third_week_in_month : return “third”; 757 case serialdate.fourth_week_in_month : return “fourth”; 758 case serialdate.last_week_in_month : return “last”; 759 default : 760 return “serialdate.weekinmonthtostring(): invalid code.”; 761 } 762 763 } 764 765 /** 766 * devuelve una cadena que representa el valor ‘relativo’ proporcionado. 767 * <p> 768 * necesitamos un enfoque mejor. 769 * 770 * @param relative una constante que representa el valor ‘relativo’. 771 * 772 * @return una cadena que representa el valor ‘relativo’ proporcionado. 773 */ 774 public static string relativetostring(final int relative) { 775 776 switch (relative) { 777 case serialdate.preceding : return “preceding”; 778 case serialdate.nearest : return “nearest”; 779 case serialdate.following : return “following”; 780 default : return “error : relative to string”; 781 } 782 783 } 784 785 /** 786 * método de factoría que devuelve una instancia de una subclase concreta de 787 * {@link serialdate}. 788 * 789 * @param day el día (1-31). 790 * @param month el mes (1-12). 791 * @param yyyy el año (entre 1900 y 9999). 792 * 793 * @return una instancia de {@link serialdate} 794 */ 795 public static serialdate createinstance(final int day, final int 456month, 796 final int yyyy) { 797 return new spreadsheetdate(day, month, yyyy); 798 } 799 800 /** 801 * método de factoría que devuelve una instancia de una subclase concreta de 802 * {@link serialdate}. 803 * 804 * @param serial numero de serie del día (1 de enero de 1900 = 2). 805 * 806 * @return una instancia de serialdate. 807 */ 808 public static serialdate createinstance(final int serial) { 809 return new spreadsheetdate(serial); 810 } 811 812 /** 813 * método de factoría que devuelve una instancia de una subclase de serialdate. 814 * 815 * @param date un objeto de fecha de java. 816 * 817 * @return una instancia de serialdate. 818 */ 818 public static serialdate createinstance(final java.util.date date) { 820 821 final gregoriancalendar calendar = new gregoriancalendar(); 822 calendar.settime(date); 823 return new spreadsheetdate(calendar.get(calendar.date), 824 calendar.get(calendar.month) + 1, 825 calendar.get(calendar.year)); 826 827 } 828 829 /** 830 * devuelve el número de serie de la fecha, siendo el 1 de enero de 1900 = 2 (se 831 * corresponde, casi totalmente, al sistema de numeración empleado en microsoft 832 * excel para windows y lotus 1-2-3). 833 * 834 * @return el número de serie de la fecha. 835 */ 836 public abstract int toserial(); 457837 838 /** 839 * devuelve java.util.date. como java.util.date tiene mayor precisión que 840 * serialdate, debemos definir una convención para “la hora del día”. 841 * 842 * @return this como <code>java.util.date</code>. 843 */ 844 public abstract java.util.date todate(); 845 846 /** 847 * devuelve una descripción de la fecha. 848 * 849 * @return una descripción de la fecha. 850 */ 851 public string getdescription() { 852 return this.description; 853 } 854 855 /** 856 * establece la descripción de la fecha. 857 * 858 * @param description la nueva descripción de la fecha. 859 */ 860 public void setdescription(final string description) { 861 this.description = description; 862 } 863 864 /** 865 * convierte la fecha en una cadena. 866 * 867 * @return una representación en cadena de la fecha. 868 */ 869 public string tostring() { 870 return getdayofmonth() + “-” + serialdate.monthcodetostring(getmonth()) 871 + “-” + getyyyy(); 872 } 873 874 /** 875 * devuelve el año (con un intervalo válido de 1900 a 9999). 876 * 877 * @return el año. 878 */ 879 public abstract int getyyyy(); 880 458881 /** 882 * devuelve el mes (enero = 1, febrero = 2, marzo = 3). 883 * 884 * @return el mes del año. 885 */ 886 public abstract int getmonth(); 887 888 /** 889 * devuelve el día del mes. 890 * 891 * @return el día del mes. 892 */ 893 public abstract int getdayofmonth(); 894 895 /** 896 * devuelve el día de la semana. 897 * 898 * @return el día de la semana. 899 */ 900 public abstract int getdayofweek(); 901 902 /** 903 * devuelve la diferencia (en días) entre esta fecha y la 904 * ‘otra’ fecha especificada. 905 * <p> 906 * el resultado es positivo si esta fecha es posterior a la ‘otra’ y 907 * negativo si es anterior. 908 * 909 * @param other la fecha con la que se compara. 910 * 911 * @return la diferencia entre esta fecha y la otra. 912 */ 913 public abstract int compare(serialdate other); 914 915 /** 916 * devuelve true si esta serialdate representa la misma fecha que la 917 * serialdate especificada. 918 * 919 * @param other la fecha con la que se compara. 920 * 921 * @return <code>true</code> si esta serialdate representa la misma fecha que 922 * la serialdate especificada. 923 */ 924 public abstract boolean ison(serialdate other); 459925 926 /** 927 * devuelve true si esta serialdate representa una fecha anterior en 928 * comparación a la serialdate especificada. 929 * 930 * @param other la fecha con la que se compara. 931 * 932 * @return <code>true</code> si esta serialdate representa una fecha anterior 933 * en comparación a la serialdate especificada. 934 */ 935 public abstract boolean isbefore(serialdate other); 936 937 /** 938 * devuelve true si esta serialdate representa la misma fecha que la 939 * serialdate especificada. 940 * 941 * @param other la fecha con la que se compara. 942 * 943 * @return <code>true</code> si esta serialdate representa la misma fecha 944 * que la serialdate especificada. 945 */ 946 public abstract boolean isonorbefore(serialdate other); 947 948 /** 949 * devuelve true si esta serialdate representa la misma fecha que la 950 * serialdate especificada. 951 * 952 * @param other la fecha con la que se compara. 953 * 954 * @return <code>true</code> si esta serialdate representa la misma fecha 955 * que la serialdate especificada. 956 */ 957 public abstract boolean isafter(serialdate other); 958 959 /** 960 * devuelve true si esta serialdate representa la misma fecha que la 961 * serialdate especificada. 962 * 963 * @param other la fecha con la que se compara. 964 * 965 * @return <code>true</code> si esta serialdate representa la misma fecha 966 * que la serialdate especificada. 460967 */ 968 public abstract boolean isonorafter(serialdate other); 969 970 /** 971 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 972 * rango especificado (inclusive). el orden de fecha de d1 y d2 no es 973 * importante. 974 * 975 * @param d1 fecha límite del rango. 976 * @param d2 la otra fecha límite del rango. 977 * 978 * @return un valor booleano. 979 */ 980 public abstract boolean isinrange(serialdate d1, serialdate d2); 981 982 /** 983 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 984 * rango especificado (el invocador especifica si los puntos finales se 985 * incluyen o no). el orden de fecha de d1 y d2 no es importante. 986 * 987 * @param d1 fecha límite del rango. 988 * @param d2 la otra fecha límite del rango. 989 * @param include un código que controla si las fechas inicial y final 990 * se incluyen o no en el rango. 991 * 992 * @return un valor booleano. 993 */ 994 public abstract boolean isinrange(serialdate d1, serialdate d2, 995 int include); 996 997 /** 998 * devuelve la última fecha que coincide con el día de la semana especificado y 999 * que es anterior a esta fecha. 1000 * 1001 * @param targetdow un código para el día de la semana de destino. 1002 * 1003 * @return la última fecha que coincide con el día de la semana especificado y 1004 * que es anterior a esta fecha. 1005 */ 1006 public serialdate getpreviousdayofweek(final int targetdow) { 1007 return getpreviousdayofweek(targetdow, this); 1008 } 1009 4611010 /** 1011 * devuelve la primera fecha que coincide con el día de la semana especificado 1012 * y que es posterior a esta fecha. 1013 * 1014 * @param targetdow un código para el día de la semana de destino. 1015 * 1016 * @return la primera fecha que coincide con el día de la semana especificado 1017 * que es posterior a esta fecha. 1018 */ 1019 public serialdate getfollowingdayofweek(final int targetdow) { 1020 return getfollowingdayofweek(targetdow, this); 1021 } 1022 1023 /** 1024 * devuelve la fecha más próxima que coincide con el día de la semana especificado. 1025 * 1026 * @param targetdow un código para el día de la semana de destino. 1027 * 1028 * @return la fecha más próxima que coincide con el día de la semana especificado. 1029 */ 1030 public serialdate getnearestdayofweek(final int targetdow) { 1031 return getnearestdayofweek(targetdow, this); 1032 } 1033 1034 } listado b-2 serialdatetest.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del projecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 46212 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ------------------------- 28 * serialdatetests.java 29 * ------------------------- 30 * (c) copyright 2001-2005, por object refinery limited. 31 32 * autor original: david gilbert (por object refinery limited); 33 * colaborador(es): -; 34 35 * $id: serialdatetests.java,v 1.6 2005/11/16 15:58:40 taqua exp $ 36 37 * cambios 38 * ----------- 39 * 15-nov-2001: version 1 (dg); 40 * 25-jun-2002: se elimina la importación innecesaria (dg); 41 * 24-oct-2002: errores indicados checkstyle corregidos (dg); 42 * 13-mar-2003: se añade prueba de serialización (dg); 43 * 05-jan-2005: se añade prueba para el informe de errores 1096282 (dg); 44 * 45 */ 46 47 package org.jfree.date.junit; 48 49 import java.io.bytearrayinputstream; 50 import java.io.bytearrayoutputstream; 51 import java.io.objectinput; 52 import java.io.objectinputstream; 53 import java.io.objectoutput; 54 import java.io.objectoutputstream; 55 46356 import junit.framework.test; 57 import junit.framework.testcase; 58 import junit.framework.testsuite; 59 60 import org.jfree.date.monthconstants; 61 import org.jfree.date.serialdate; 62 63 /** 64 * pruebas junit para la clase {@link serialdate}. 65 */ 66 public class serialdatetests extends testcase { 67 68 /** fecha que representa 9 de noviembre. 69 private serialdate nov9y2001; 70 71 /** 72 * crea un nuevo caso de prueba. 73 * 74 * @param name el nombre. 75 */ 76 public serialdatetests(final string name) { 77 super(name); 78 } 79 80 /** 81 * devuelve una suite de pruebas para el ejecutor de pruebas junit. 82 * 83 * @return la suite de pruebas. 84 */ 85 public static test suite() { 86 return new testsuite(serialdatetests.class); 87 } 88 89 /** 90 * problema. 91 */ 92 protected void setup() { 93 this.nov9y2001 = serialdate.createinstance(9, monthconstants.november, 2001); 94 } 95 96 /** 97 * 9 nov 2001 más dos meses debe ser 9 ene 2002. 98 */ 99 public void testaddmonthsto9nov2001() { 464100 final serialdate jan9y2002 = serialdate.addmonths(2, this.nov9y2001); 101 final serialdate answer = serialdate.createinstance(9, 1, 2002); 102 assertequals(answer, jan9y2002); 103 } 104 105 /** 106 * caso de prueba de un error, ya corregido. 107 */ 108 public void testaddmonthsto5oct2003() { 109 final serialdate d1 = serialdate.createinstance(5, monthconstants.october, 2003); 110 final serialdate d2 = serialdate.addmonths(2, d1); 111 assertequals(d2, serialdate.createinstance(5, monthconstants.december, 2003)); 112 } 113 114 /** 115 * caso de prueba de un error, ya corregido. 116 */ 117 public void testaddmonthsto1jan2003() { 118 final serialdate d1 = serialdate.createinstance(1, monthconstants.january, 2003); 119 final serialdate d2 = serialdate.addmonths(0, d1); 120 assertequals(d2, d1); 121 } 122 123 /** 124 * el lunes anterior al viernes 9 de noviembre de 2001 debe ser el 5 de noviembre. 125 */ 126 public void testmondayprecedingfriday9nov2001() { 127 serialdate mondaybefore = serialdate.getpreviousdayofweek( 128 serialdate.monday, this.nov9y2001 129 ); 130 assertequals(5, mondaybefore.getdayofmonth()); 131 } 132 133 /** 134 * el lunes posterior al viernes 9 de noviembre de 2001 debe ser el 12 de noviembre. 135 */ 136 public void testmondayfollowingfriday9nov2001() { 137 serialdate mondayafter = serialdate.getfollowingdayofweek( 138 serialdate.monday, this.nov9y2001 139 ); 465140 assertequals(12, mondayafter.getdayofmonth()); 141 } 142 143 /** 144 * el lunes más próximo al viernes 9 de noviembre de 2001 debe ser el 12 de noviembre. 145 */ 146 public void testmondaynearestfriday9nov2001() { 147 serialdate mondaynearest = serialdate.getnearestdayofweek( 148 serialdate.monday, this.nov9y2001 149 ); 150 assertequals(12, mondaynearest.getdayofmonth()); 151 } 152 153 /** 154 * el lunes más próximo al 22 de enero de 1970 cae en el 19. 155 */ 156 public void testmondaynearest22jan1970() { 157 serialdate jan22y1970 = serialdate.createinstance(22, monthconstants.january, 1970); 158 serialdate mondaynearest = serialdate.getnearestdayofweek(serialdate.monday, jan22y1970); 159 assertequals(19, mondaynearest.getdayofmonth()); 160 } 161 162 /** 163 * el problema es que la conversión de días en cadenas devuelva el resultado 164 * correcto. en realidad este resultado depende de la configuración regional. 165 */ 166 public void testweekdaycodetostring() { 167 168 final string test = serialdate.weekdaycodetostring(serialdate.saturday); 169 assertequals(“saturday”, test); 170 171 } 172 173 /** 174 * probar la conversión de una cadena en día de la semana. esta prueba falla si 175 * la configuración regional predeterminada no usa nombres de días en inglés 176 */ 177 public void teststringtoweekday() { 178 466179 int weekday = serialdate.stringtoweekdaycode(“wednesday”); 180 assertequals(serialdate.wednesday, weekday); 181 182 weekday = serialdate.stringtoweekdaycode(“ wednesday ”); 183 assertequals(serialdate.wednesday, weekday); 184 185 weekday = serialdate.stringtoweekdaycode(“wed”); 186 assertequals(serialdate.wednesday, weekday); 187 188 } 189 190 /** 191 * probar la conversión de una cadena en mes. esta prueba falla si la 192 * configuración regional predeterminada no usa nombres de días en inglés 193 */ 194 public void teststringtomonthcode() { 195 196 int m = serialdate.stringtomonthcode(“january”); 197 assertequals(monthconstants.january, m); 198 199 m = serialdate.stringtomonthcode(“ january ”); 200 assertequals(monthconstants.january, m); 201 202 m = serialdate.stringtomonthcode(“jan”); 203 assertequals(monthconstants.january, m); 204 205 } 206 207 /** 208 * probar la conversión de un código de mes en cadena. 209 */ 210 public void testmonthcodetostringcode() { 211 212 final string test = serialdate.monthcodetostring(monthconstants.december); 213 assertequals(“december”, test); 214 215 } 216 217 /** 218 * 1900 no es un año bisiesto. 219 */ 220 public void testisnotleapyear1900() { 221 asserttrue(!serialdate.isleapyear(1900)); 222 } 467223 224 /** 225 * 2000 es un año bisiesto. 226 */ 227 public void testisleapyear2000() { 228 asserttrue(serialdate.isleapyear(2000)); 229 } 230 231 /** 232 * el número de años bisiestos desde 1900 y hasta 1899 incluido es 0. 233 */ 234 public void testleapyearcount1899() { 235 assertequals(serialdate.leapyearcount(1899), 0); 236 } 237 238 /** 239 * el número de años bisiestos desde 1900 y hasta 1903 incluido es 0. 240 */ 241 public void testleapyearcount1903() { 242 assertequals(serialdate.leapyearcount(1903), 0); 243 } 244 245 /** 246 * el número de años bisiestos desde 1900 y hasta 1904 incluido es 1. 247 */ 248 public void testleapyearcount1904() { 249 assertequals(serialdate.leapyearcount(1904), 1); 250 } 251 252 /** 253 * el número de años bisiestos desde 1900 y hasta 1999 incluido es 24. 254 */ 255 public void testleapyearcount1999() { 256 assertequals(serialdate.leapyearcount(1999), 24); 257 } 258 259 /** 260 * el número de años bisiestos desde 1900 y hasta 2000 incluido es 25. 261 */ 262 public void testleapyearcount2000() { 263 assertequals(serialdate.leapyearcount(2000), 25); 264 } 265 266 /** 267 * serializar una instancia, restaurarla y comprobar la igualdad. 468268 */ 269 public void testserialization() { 270 271 serialdate d1 = serialdate.createinstance(15, 4, 2000); 272 serialdate d2 = null; 273 274 try { 275 bytearrayoutputstream buffer = new bytearrayoutputstream(); 276 objectoutput out = new objectoutputstream(buffer); 277 out.writeobject(d1); 278 out.close(); 279 280 objectinput in = new objectinputstream( new bytearrayinputstream(buffer.tobytearray())); 281 d2 = (serialdate) in.readobject(); 282 in.close(); 283 } 284 catch (exception e) { 285 system.out.println(e.tostring()); 286 } 287 assertequals(d1, d2); 288 289 } 290 291 /** 292 * prueba para el informe de error 1096282 (ya corregido). 293 */ 294 public void test1096282() { 295 serialdate d = serialdate.createinstance(29, 2, 2004); 296 d = serialdate.addyears(1, d); 297 serialdate expected = serialdate.createinstance(28, 2, 2005); 298 asserttrue(d.ison(expected)); 299 } 300 301 /** 302 * diversas pruebas para el método addmonths(). 303 */ 304 public void testaddmonths() { 305 serialdate d1 = serialdate.createinstance(31, 5, 2004); 307 serialdate d2 = serialdate.addmonths(1, d1); 308 assertequals(30, d2.getdayofmonth()); 309 assertequals(6, d2.getmonth()); 310 assertequals(2004, d2.getyyyy()); 311 312 serialdate d3 = serialdate.addmonths(2, d1); 469313 assertequals(31, d3.getdayofmonth()); 314 assertequals(7, d3.getmonth()); 315 assertequals(2004, d3.getyyyy()); 316 317 serialdate d4 = serialdate.addmonths(1, serialdate.addmonths(1, d1)); 318 assertequals(30, d4.getdayofmonth()); 319 assertequals(7, d4.getmonth()); 320 assertequals(2004, d4.getyyyy()); 321 } 322 } listado b-3 monthconstants.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ---------------------- 28 * monthconstants.java 47029 * ---------------------- 30 * (c) copyright 2002, 2003, de object refinery limited. 31 * 32 * autor original: david gilbert (para object refinery limited); 33 * colaborador(es): -; 34 * 35 * $id: monthconstants.java,v 1.4 2005/11/16 15:58:40 taqua exp $ 36 * 37 * cambios 38 * ---------- 39 * 29-may-2002 : version 1 (code moved from serialdate class) (dg); 40 * 41 */ 42 43 package org.jfree.date; 44 45 /** 46 * constantes útiles para los meses. no son equivalentes a las 47 * constantes definidas por java.util.calendar (donde january=0 y december=11). 48 * <p> 49 * se usa en las clases serialdate y regulartimeperiod. 50 * 51 * @author david gilbert 52 */ 53 public interface monthconstants { 54 55 /** constante para enero. */ 56 public static final int january = 1; 57 58 /** constante para febrero. */ 59 public static final int february = 2; 60 61 /** constante para marzo. */ 62 public static final int march = 3; 63 64 /** constante para abril. */ 65 public static final int april = 4; 66 67 /** constante para mayo. */ 68 public static final int may = 5; 69 70 /** constante para junio. */ 71 public static final int june = 6; 72 47173 /** constante para julio. */ 74 public static final int july = 7; 75 76 /** constante para agosto. */ 77 public static final int august = 8; 78 79 /** constante para septiembre. */ 80 public static final int september = 9; 81 82 /** constante para octubre. */ 83 public static final int october = 10; 84 85 /** constante para noviembre. */ 86 public static final int november = 11; 87 88 /** constante para diciembre. */ 89 public static final int december = 12; 90 91 } listado b-4 bobsserialdatetest.java 1 package org.jfree.date.junit; 2 3 import junit.framework.testcase; 4 import org.jfree.date.*; 5 import static org.jfree.date.serialdate.*; 6 7 import java.util.*; 8 9 public class bobsserialdatetest extends testcase { 10 11 public void testisvalidweekdaycode() throws exception { 12 for (int day = 1; day <= 7; day++) 13 asserttrue(isvalidweekdaycode(day)); 14 assertfalse(isvalidweekdaycode(0)); 15 assertfalse(isvalidweekdaycode(8)); 16 } 17 18 public void teststringtoweekdaycode() throws exception { 19 20 assertequals(-1, stringtoweekdaycode(“hello”)); 21 assertequals(monday, stringtoweekdaycode(“monday”)); 47222 assertequals(monday, stringtoweekdaycode(“mon”)); 23 //todo assertequals(monday,stringtoweekdaycode(“monday”)); 24 // assertequals(monday,stringtoweekdaycode(“monday”)); 25 // assertequals(monday, stringtoweekdaycode(“mon”)); 26 27 assertequals(tuesday, stringtoweekdaycode(“tuesday”)); 28 assertequals(tuesday, stringtoweekdaycode(“tue”)); 29 // assertequals(tuesday,stringtoweekdaycode(“tuesday”)); 30 // assertequals(tuesday,stringtoweekdaycode(“tuesday”)); 31 // assertequals(tuesday, stringtoweekdaycode(“tue”)); 32 // assertequals(tuesday, stringtoweekdaycode(“tues”)); 33 34 assertequals(wednesday, stringtoweekdaycode (“wednesday”)); 35 assertequals(wednesday, stringtoweekdaycode(“wed”)); 36 // assertequals(wednesday,stringtoweekdaycode(“wednesday”)); 37 // assertequals(wednesday,stringtoweekdaycode(“wednesday”)); 38 // assertequals(wednesday, stringtoweekdaycode(“wed”)); 39 40 assertequals(thursday, stringtoweekdaycode(“thursday”)); 41 assertequals(thursday, stringtoweekdaycode(“thu”)); 42 // assertequals(thursday,stringtoweekdaycode(“thursday”)); 43 // assertequals(thursday,stringtoweekdaycode(“thursday”)); 44 // assertequals(thursday, stringtoweekdaycode(“thu”)); 45 // assertequals(thursday, stringtoweekdaycode(“thurs”)); 46 47 assertequals(friday, stringtoweekdaycode(“friday”)); 48 assertequals(friday, stringtoweekdaycode(“fri”)); 49 // assertequals(friday,stringtoweekdaycode(“friday”)); 50 // assertequals(friday,stringtoweekdaycode(“friday”)); 51 // assertequals(friday, stringtoweekdaycode(“fri”)); 52 53 assertequals(saturday, stringtoweekdaycode(“saturday”)); 54 assertequals(saturday, stringtoweekdaycode(“sat”)); 55 // assertequals(saturday,stringtoweekdaycode(“saturday”)); 56 // assertequals(saturday,stringtoweekdaycode(“saturday”)); 57 // assertequals(saturday, stringtoweekdaycode(“sat”)); 58 59 assertequals(sunday, stringtoweekdaycode(“sunday”)); 60 assertequals(sunday, stringtoweekdaycode(“sun”)); 61 // assertequals(sunday,stringtoweekdaycode(“sunday”)); 62 // assertequals(sunday,stringtoweekdaycode(“sunday”)); 63 // assertequals(sunday, stringtoweekdaycode(“sun”)); 64 } 65 66 public void testweekdaycodetostring() throws exception { 47367 assertequals(“sunday”, weekdaycodetostring(sunday)); 68 assertequals(“monday”, weekdaycodetostring(monday)); 69 assertequals(“tuesday”, weekdaycodetostring(tuesday)); 70 assertequals(“wednesday”, weekdaycodetostring(wednesday)); 71 assertequals(“thursday”, weekdaycodetostring(thursday)); 72 assertequals(“friday”, weekdaycodetostring(friday)); 73 assertequals(“saturday”, weekdaycodetostring(saturday)); 74 } 75 76 public void testisvalidmonthcode() throws exception { 77 for (int i = 1; i <= 12; i++) 78 asserttrue(isvalidmonthcode(i)); 79 assertfalse(isvalidmonthcode(0)); 80 assertfalse(isvalidmonthcode(13)); 81 } 82 83 public void testmonthtoquarter() throws exception { 84 assertequals(1, monthcodetoquarter(january)); 85 assertequals(1, monthcodetoquarter(february)); 86 assertequals(1, monthcodetoquarter(march)); 87 assertequals(2, monthcodetoquarter(april)); 88 assertequals(2, monthcodetoquarter(may)); 89 assertequals(2, monthcodetoquarter(june)); 90 assertequals(3, monthcodetoquarter(july)); 91 assertequals(3, monthcodetoquarter(august)); 92 assertequals(3, monthcodetoquarter(september)); 93 assertequals(4, monthcodetoquarter(october)); 94 assertequals(4, monthcodetoquarter(november)); 95 assertequals(4, monthcodetoquarter(december)); 96 97 try { 98 monthcodetoquarter(-1); 99 fail(“invalid month code should throw exception”); 100 } catch (illegalargumentexception e) { 101 } 102 } 103 104 public void testmonthcodetostring() throws exception { 105 assertequals(“january”, monthcodetostring(january)); 106 assertequals(“february”, monthcodetostring(february)); 107 assertequals(“march”, monthcodetostring(march)); 108 assertequals(“april”, monthcodetostring(april)); 109 assertequals(“may”, monthcodetostring(may)); 110 assertequals(“june”, monthcodetostring(june)); 111 assertequals(“july”, monthcodetostring(july)); 474112 assertequals(“august”, monthcodetostring(august)); 113 assertequals(“september”, monthcodetostring(september)); 114 assertequals(“october”, monthcodetostring(october)); 115 assertequals(“november”, monthcodetostring(november)); 116 assertequals(“december”, monthcodetostring(december)); 117 118 assertequals(“jan”, monthcodetostring(january, true)); 119 assertequals(“feb”, monthcodetostring(february, true)); 120 assertequals(“mar”, monthcodetostring(march, true)); 121 assertequals(“apr”, monthcodetostring(april, true)); 122 assertequals(“may”, monthcodetostring(may, true)); 123 assertequals(“jun”, monthcodetostring(june, true)); 124 assertequals(“jul”, monthcodetostring(july, true)); 125 assertequals(“aug”, monthcodetostring(august, true)); 126 assertequals(“sep”, monthcodetostring(september, true)); 127 assertequals(“oct”, monthcodetostring(october, true)); 128 assertequals(“nov”, monthcodetostring(november, true)); 129 assertequals(“dec”, monthcodetostring(december, true)); 130 131 try { 132 monthcodetostring(-1); 133 fail(“invalid month code should throw exception”); 134 } catch (illegalargumentexception e) { 135 } 136 137 } 138 139 public void teststringtomonthcode() throws exception { 140 assertequals(january,stringtomonthcode(“1”)); 141 assertequals(february,stringtomonthcode(“2”)); 142 assertequals(march,stringtomonthcode(“3”)); 143 assertequals(april,stringtomonthcode(“4”)); 144 assertequals(may,stringtomonthcode(“5”)); 145 assertequals(june,stringtomonthcode(“6”)); 146 assertequals(july,stringtomonthcode(“7”)); 147 assertequals(august,stringtomonthcode(“8”)); 148 assertequals(september,stringtomonthcode(“9”)); 149 assertequals(october,stringtomonthcode(“10”)); 150 assertequals(november, stringtomonthcode(“11”)); 151 assertequals(december,stringtomonthcode(“12”)); 152 153 //todo assertequals(-1, stringtomonthcode(“0”)); 154 // assertequals(-1, stringtomonthcode(“13”)); 155 156 assertequals(-1,stringtomonthcode(“hello”)); 475157 158 for (int m = 1; m <= 12; m++) { 159 assertequals(m, stringtomonthcode(monthcodetostring(m, false))); 160 assertequals(m, stringtomonthcode(monthcodetostring(m, true))); 161 } 162 163 // assertequals(1,stringtomonthcode(“jan”)); 164 // assertequals(2,stringtomonthcode(“feb”)); 165 // assertequals(3,stringtomonthcode(“mar”)); 166 // assertequals(4,stringtomonthcode(“apr”)); 167 // assertequals(5,stringtomonthcode(“may”)); 168 // assertequals(6,stringtomonthcode(“jun”)); 169 // assertequals(7,stringtomonthcode(“jul”)); 170 // assertequals(8,stringtomonthcode(“aug”)); 171 // assertequals(9,stringtomonthcode(“sep”)); 172 // assertequals(10,stringtomonthcode(“oct”)); 173 // assertequals(11,stringtomonthcode(“nov”)); 174 // assertequals(12,stringtomonthcode(“dec”)); 175 176 // assertequals(1,stringtomonthcode(“jan”)); 177 // assertequals(2,stringtomonthcode(“feb”)); 178 // assertequals(3,stringtomonthcode(“mar”)); 179 // assertequals(4,stringtomonthcode(“apr”)); 180 // assertequals(5,stringtomonthcode(“may”)); 181 // assertequals(6,stringtomonthcode(“jun”)); 182 // assertequals(7,stringtomonthcode(“jul”)); 183 // assertequals(8,stringtomonthcode(“aug”)); 184 // assertequals(9,stringtomonthcode(“sep”)); 185 // assertequals(10,stringtomonthcode(“oct”)); 186 // assertequals(11,stringtomonthcode(“nov”)); 187 // assertequals(12,stringtomonthcode(“dec”)); 188 189 // assertequals(1,stringtomonthcode(“january”)); 190 // assertequals(2,stringtomonthcode(“february”)); 191 // assertequals(3,stringtomonthcode(“march”)); 192 // assertequals(4,stringtomonthcode(“april”)); 193 // assertequals(5,stringtomonthcode(“may”)); 194 // assertequals(6,stringtomonthcode(“june”)); 195 // assertequals(7,stringtomonthcode(“july”)); 196 // assertequals(8,stringtomonthcode(“august”)); 197 // assertequals(9,stringtomonthcode(“september”)); 198 // assertequals(10,stringtomonthcode(“october”)); 199 // assertequals(11,stringtomonthcode(“november”)); 200 // assertequals(12,stringtomonthcode(“december”)); 201 476202 // assertequals(1,stringtomonthcode(“january”)); 203 // assertequals(2,stringtomonthcode(“february”)); 204 // assertequals(3,stringtomonthcode(“mar”)); 205 // assertequals(4,stringtomonthcode(“april”)); 206 // assertequals(5,stringtomonthcode(“may”)); 207 // assertequals(6,stringtomonthcode(“june”)); 208 // assertequals(7,stringtomonthcode(“july”)); 209 // assertequals(8,stringtomonthcode(“august”)); 210 // assertequals(9,stringtomonthcode(“september”)); 211 // assertequals(10,stringtomonthcode(“october”)); 212 // assertequals(11,stringtomonthcode(“november”)); 213 // assertequals(12,stringtomonthcode(“december”)); 214 } 215 216 public void testisvalidweekinmonthcode() throws exception { 217 for (int w = 0; w <= 4; w++) { 218 asserttrue(isvalidweekinmonthcode(w)); 219 } 220 assertfalse(isvalidweekinmonthcode(5)); 221 } 222 223 public void testisleapyear() throws exception { 224 assertfalse(isleapyear(1900)); 225 assertfalse(isleapyear(1901)); 226 assertfalse(isleapyear(1902)); 227 assertfalse(isleapyear(1903)); 228 asserttrue(isleapyear(1904)); 229 asserttrue(isleapyear(1908)); 230 assertfalse(isleapyear(1955)); 231 asserttrue(isleapyear(1964)); 232 asserttrue(isleapyear(1980)); 233 asserttrue(isleapyear(2000)); 234 assertfalse(isleapyear(2001)); 235 assertfalse(isleapyear(2100)); 236 } 237 238 public void testleapyearcount() throws exception { 239 assertequals(0, leapyearcount(1900)); 240 assertequals(0, leapyearcount(1901)); 241 assertequals(0, leapyearcount(1902)); 242 assertequals(0, leapyearcount(1903)); 243 assertequals(1, leapyearcount(1904)); 244 assertequals(1, leapyearcount(1905)); 245 assertequals(1, leapyearcount(1906)); 246 assertequals(1, leapyearcount(1907)); 477247 assertequals(2, leapyearcount(1908)); 248 assertequals(24, leapyearcount(1999)); 249 assertequals(25, leapyearcount(2001)); 250 assertequals(49, leapyearcount(2101)); 251 assertequals(73, leapyearcount(2201)); 252 assertequals(97, leapyearcount(2301)); 253 assertequals(122, leapyearcount(2401)); 254 } 255 256 public void testlastdayofmonth() throws exception { 257 assertequals(31, lastdayofmonth(january, 1901)); 258 assertequals(28, lastdayofmonth(february, 1901)); 259 assertequals(31, lastdayofmonth(march, 1901)); 260 assertequals(30, lastdayofmonth(april, 1901)); 261 assertequals(31, lastdayofmonth(may, 1901)); 262 assertequals(30, lastdayofmonth(june, 1901)); 263 assertequals(31, lastdayofmonth(july, 1901)); 264 assertequals(31, lastdayofmonth(august, 1901)); 265 assertequals(30, lastdayofmonth(september, 1901)); 266 assertequals(31, lastdayofmonth(october, 1901)); 267 assertequals(30, lastdayofmonth(november, 1901)); 268 assertequals(31, lastdayofmonth(december, 1901)); 269 assertequals(29, lastdayofmonth(february, 1904)); 270 } 271 272 public void testadddays() throws exception { 273 serialdate newyears = d(1, january, 1900); 274 assertequals(d(2, january, 1900), adddays(1, newyears)); 275 assertequals(d(1, february, 1900), adddays(31, newyears)); 276 assertequals(d(1, january, 1901), adddays(365, newyears)); 277 assertequals(d(31, december, 1904), adddays(5 * 365, newyears)); 278 } 279 280 private static spreadsheetdate d(int day, int month, int year) { return new spreadsheetdate(day, month, year); } 281 282 public void testaddmonths() throws exception { 283 assertequals(d(1, february, 1900), addmonths(1, d(1, january, 1900))); 284 assertequals(d(28, february, 1900), addmonths(1, d(31, january, 1900))); 285 assertequals(d(28, february, 1900), addmonths(1, d(30, january, 1900))); 286 assertequals(d(28, february, 1900), addmonths(1, d(29, january, 1900))); 287 assertequals(d(28, february, 1900), addmonths(1, d(28, january, 4781900))); 288 assertequals(d(27, february, 1900), addmonths(1, d(27, january, 1900))); 289 290 assertequals(d(30, june, 1900), addmonths(5, d(31, january, 1900))); 291 assertequals(d(30, june, 1901), addmonths(17, d(31, january, 1900))); 292 293 assertequals(d(29, february, 1904), addmonths(49, d(31, january, 1900))); 294 295 } 296 297 public void testaddyears() throws exception { 298 assertequals(d(1, january, 1901), addyears(1, d(1, january, 1900))); 299 assertequals(d(28, february, 1905), addyears(1, d(29, february, 1904))); 300 assertequals(d(28, february, 1905), addyears(1, d(28, february, 1904))); 301 assertequals(d(28, february, 1904), addyears(1, d(28, february, 1903))); 302 } 303 304 public void testgetpreviousdayofweek() throws exception { 305 assertequals(d(24, february, 2006), getpreviousdayofweek(friday, d(1, march, 2006))); 306 assertequals(d(22, february, 2006), getpreviousdayofweek(wednesday, d(1, march, 2006))); 307 assertequals(d(29, february, 2004), getpreviousdayofweek(sunday, d(3, march, 2004))); 308 assertequals(d(29, december, 2004), getpreviousdayofweek(wednesday, d(5, january, 2005))); 309 310 try { 311 getpreviousdayofweek(-1, d(1, january, 2006)); 312 fail(“invalid day of week code should throw exception”); 313 } catch (illegalargumentexception e) { 314 } 315 } 316 317 public void testgetfollowingdayofweek() throws exception { 318 // assertequals(d(1, january, 2005),getfollowingdayofweek(saturday, d(25, december, 2004))); 319 assertequals(d(1, january, 2005), getfollowingdayofweek(saturday, d(26, december, 2004))); 320 assertequals(d(3, march, 2004), getfollowingdayofweek(wednesday, d(28, february, 2004))); 321 479322 try { 323 getfollowingdayofweek(-1, d(1, january, 2006)); 324 fail(“invalid day of week code should throw exception”); 325 } catch (illegalargumentexception e) { 326 } 327 } 328 329 public void testgetnearestdayofweek() throws exception { 330 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(16, april, 2006))); 331 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(17, april, 2006))); 332 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(18, april, 2006))); 333 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(19, april, 2006))); 334 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(20, april, 2006))); 335 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(21, april, 2006))); 336 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(22, april, 2006))); 337 338 //todo assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(16, april, 2006))); 339 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(17, april, 2006))); 340 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(18, april, 2006))); 341 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(19, april, 2006))); 342 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(20, april, 2006))); 343 assertequals(d(24, april, 2006), getnearestdayofweek(monday, d(21, april, 2006))); 344 assertequals(d(24, april, 2006), getnearestdayofweek(monday, d(22, april, 2006))); 345 346 // assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(16, april, 2006))); 347 // assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(17, april, 2006))); 348 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(18, april, 2006))); 349 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(19, april, 2006))); 350 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(20, april, 2006))); 351 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(21, 480april, 2006))); 352 assertequals(d(25, april, 2006), getnearestdayofweek(tuesday, d(22, april, 2006))); 353 354 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(16, april, 2006))); 355 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(17, april, 2006))); 356 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(18, april, 2006))); 357 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(19, april, 2006))); 358 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(20, april, 2006))); 359 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(21, april, 2006))); 360 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(22, april, 2006))); 361 362 // assertequals(d(13, april, 2006), getnearestdayofweek(thursday, d(16, april, 2006))); 363 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(17, april, 2006))); 364 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(18, april, 2006))); 365 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(19, april, 2006))); 366 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(20, april, 2006))); 367 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(21, april, 2006))); 368 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(22, april, 2006))); 369 370 // assertequals(d(14, april, 2006), getnearestdayofweek(friday, d(16, april, 2006))); 371 // assertequals(d(14, april, 2006), getnearestdayofweek(friday, d(17, april, 2006))); 372 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(18, april, 2006))); 373 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(19, april, 2006))); 374 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(20, april, 2006))); 375 assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(21, april, 2006))); 376 assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(22, april, 2006))); 377 378 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(16, 481april, 2006))); 379 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(17, april, 2006))); 380 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(18, april, 2006))); 381 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(19, april, 2006))); 382 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(20, april, 2006))); 383 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(21, april, 2006))); 384 assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(22, april, 2006))); 385 386 try { 387 getnearestdayofweek(-1, d(1, january, 2006)); 388 fail(“invalid day of week code should throw exception”); 389 } catch (illegalargumentexception e) { 390 } 391 } 392 393 public void testendofcurrentmonth() throws exception { 394 serialdate d = serialdate.createinstance(2); 395 assertequals(d(31, january, 2006), d.getendofcurrentmonth(d(1, january, 2006))); 396 assertequals(d(28, february, 2006), d.getendofcurrentmonth(d(1, february, 2006))); 397 assertequals(d(31, march, 2006), d.getendofcurrentmonth(d(1, march, 2006))); 398 assertequals(d(30, april, 2006), d.getendofcurrentmonth(d(1, april, 2006))); 399 assertequals(d(31, may, 2006), d.getendofcurrentmonth(d(1, may, 2006))); 400 assertequals(d(30, june, 2006), d.getendofcurrentmonth(d(1, june, 2006))); 401 assertequals(d(31, july, 2006), d.getendofcurrentmonth(d(1, july, 2006))); 402 assertequals(d(31, august, 2006), d.getendofcurrentmonth(d(1, august, 2006))); 403 assertequals(d(30, september, 2006), d.getendofcurrentmonth(d(1, september, 2006))); 404 assertequals(d(31, october, 2006), d.getendofcurrentmonth(d(1, october, 2006))); 405 assertequals(d(30, november, 2006), d.getendofcurrentmonth(d(1, november, 2006))); 406 assertequals(d(31, december, 2006), d.getendofcurrentmonth(d(1, december, 2006))); 407 assertequals(d(29, february, 2008), d.getendofcurrentmonth(d(1, february, 2008))); 482408 } 409 410 public void testweekinmonthtostring() throws exception { 411 assertequals(“first”,weekinmonthtostring(first_week_in_month)); 412 assertequals(“second”,weekinmonthtostring(second_week_in_month)); 413 assertequals(“third”,weekinmonthtostring(third_week_in_month)); 414 assertequals(“fourth”,weekinmonthtostring(fourth_week_in_month)); 415 assertequals(“last”,weekinmonthtostring(last_week_in_month)); 416 417 //todo try { 418 // weekinmonthtostring(-1); 419 // fail(“invalid week code should throw exception”); 420 // } catch (illegalargumentexception e) { 421 // } 422 } 423 424 public void testrelativetostring() throws exception { 425 assertequals(“preceding”,relativetostring(preceding)); 426 assertequals(“nearest”,relativetostring(nearest)); 427 assertequals(“following”,relativetostring(following)); 428 429 //todo try { 430 // relativetostring(-1000); 431 // fail(“invalid relative code should throw exception”); 432 // } catch (illegalargumentexception e) { 433 // } 434 } 435 436 public void testcreateinstancefromddmmyyyy() throws exception { 437 serialdate date = createinstance(1, january, 1900); 438 assertequals(1,date.getdayofmonth()); 439 assertequals(january,date.getmonth()); 440 assertequals(1900,date.getyyyy()); 441 assertequals(2,date.toserial()); 442 } 443 444 public void testcreateinstancefromserial() throws exception { 445 assertequals(d(1, january, 1900),createinstance(2)); 446 assertequals(d(1, january, 1901), createinstance(367)); 447 } 448 449 public void testcreateinstancefromjavadate() throws exception { 450 assertequals(d(1, january, 1900), createinstance(new gregoriancalendar(1900,0,1).gettime())); 451 assertequals(d(1, january, 2006), 483createinstance(new gregoriancalendar(2006,0,1).gettime())); 452 } 453 454 public static void main(string[] args) { 455 junit.textui.testrunner.run(bobsserialdatetest.class); 456 } 457 } 484listado b-5 spreadsheetdate.java. 1 /* ============================================================= 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * -------------------------- 28 * spreadsheetdate.java 29 * -------------------------- 30 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 31 * 32 * autor original: david gilbert (por object refinery limited); 33 * colaboradores(s): -; 34 * 35 * $id: speadsheetdate.java,v 1.8 2005/11/03 09:25:39 mungady exp $ 36 * 37 * cambios 38 * ---------- 39 * 11-oct-2001 : version 1 (dg); 48540 * 05-nov-2001 : se añaden los métodos getdescription() y setdescription() (dg); 41 * 12-nov-2001 : se cambia el nombre exceldate.java por spreadsheetdate.java (dg); 42 * se corrige un error a la hora de calcular el día, mes y año a 43 * partir del número de serie (dg); 44 * 24-jan-2002 : se corrige un error a la hora de calcular el número de serie a 45 * partir del día, mes y año. gracias a trevor kills por el informe (dg); 46 * 29-may-2002 : se añade el método equals(object) (sourceforge id 558850) (dg); 47 * 03-oct-2002 : se corrigen los errores detectados por checkstyle (dg); 48 * 13-mar-2003 : implementación de serializable (dg); 49 * 04-sep-2003 : métodos isinrange() completados (dg); 50 * 05-sep-2003 : implementación de comparable (dg); 51 * 21-oct-2003 : se añade el método hashcode() (dg); 52 * 53 /* 54 55 package org.jfree.date; 56 57 import java.util.calendar; 58 import java.util.date; 59 /** 60 61 * representa una con un entero, de forma similar a la 62 * implementación en microsoft excel. el intervalo de fechas admitido es 63 * 1-ene-1900 a 31-dic-9999. 64 * <p> 65 * recuerde que excel tiene un error que reconoce el año 66 * 1900 como bisiesto cuando en realidad no lo es. encontrará más 67 * información en el sitio web de microsoft, en el artículo q181370: 68 * <p> 69 * http://support.microsoft.com/support/kb/articles/q181/3/70.asp 70 * <p> 71 * excel usa como convención que el 1-ene-1900 = 1. esta clase usa la 72 * convención de que 1-ene-1900 = 2. 73 * como resultado, el número de día de esta clase será diferente al de 74 * excel para enero y febrero de 1900… pero excel añade un día 75 * más (29-feb-1900 que en realidad no existe) y a partir de ahí 76 * los números de los días coinciden. 77 * 78 * @author david gilbert 79 */ 80 public class spreadsheetdate extends serialdate { 81 48682 /** para serialización. */ 83 private static final long serialversionuid = -2039586705374454461l; 84 85 /** 86 * el número de día (1-ene-1900 = 2, 2-ene-1900 = 3…, 31-dic-9999 = 87 * 2958465). 88 */ 89 private int serial; 90 91 /** el día del mes (de 1 a 28, 29, 30 o 31 en función del mes). */ 92 private int day; 93 94 /** el mes del año (de 1 a 12). */ 95 private int month; 96 97 /** el año (de 1900 a 9999). */ 98 private int year; 99 100 /** una descripción opcional para la fecha. */ 101 private string description; 102 103 /** 104 * crear una nueva instancia de la fecha. 105 * 106 * @param day el día (entre 1 y 28/29/30/31). 107 * @param month el mes (entre 1 y 12). 108 * @param year el año (entre 1900 y 9999). 109 */ 110 public spreadsheetdate(final int day, final int month, final int year) { 111 112 if ((year >= 1900) && (year <= 9999)) { 113 this.year = year; 114 } 115 else { 116 throw new illegalargumentexception( 117 “the ‘year’ argument must be in range 1900 to 9999.” 118 ); 119 } 120 121 if ((month >= monthconstants.january) 122 && (month <= monthconstants.december)) { 123 this.month = month; 124 } 125 else { 487126 throw new illegalargumentexception( 127 “the ‘month’ argument must be in the range 1 to 12.” 128 ); 129 } 130 131 if ((day >= 1) && (day <= serialdate.lastdayofmonth(month, year))) { 132 this.day = day; 133 } 134 else { 135 throw new illegalargumentexception(“invalid ‘day’ argument.”); 136 } 137 138 // es necesario sincronizar el número de serie con el día-mes-año… 139 this.serial = calcserial(day, month, year); 140 141 this.description = null; 142 143 } 144 145 /** 146 * constructor estándar: crear un nuevo objeto de fecha que representa el 147 * número de día especificado (que debe estar comprendido entre 2 y 2958465). 148 * 149 * @param serial número de serie para el día (entre 2 y 2958465). 150 */ 151 public spreadsheetdate(final int serial) { 152 153 if ((serial >= serial_lower_bound) && (serial <= serial_upper_bound)) { 154 this.serial = serial; 155 } 156 else { 157 throw new illegalargumentexception( 158 “spreadsheetdate: serial must be in range 2 to 2958465.”); 159 } 160 161 // el día-mes-año debe estar sincronizado con el número de serie… 162 calcdaymonthyear(); 163 164 } 165 166 /** 167 * devuelve la descripción adjuntada a la fecha. no es 168 * obligatorio que la fecha tenga una descripción, pero resulta útil 488169 * en algunas aplicaciones. 170 * 171 * @return la descripción adjuntada a la fecha. 172 */ 173 public string getdescription() { 174 return this.description; 175 } 176 177 /** 178 * establece la descripción de la fecha. 179 * 180 * @param description la descripción de esta fecha (<code>null</code> 181 * se permite) 182 */ 183 public void setdescription(final string description) { 184 this.description = description; 185 } 186 187 /** 188 * devuelve el número de serie de la fecha, siendo el 1 de enero 1900 = 2 189 * (se corresponde, casi totalmente, al sistema de numeración empleado en 190 * microsoft excel para windows y lotus 1-2-3). 191 * 192 * @return el número de serie de la fecha. 193 */ 194 public int toserial() { 195 return this.serial; 196 } 197 198 /** 199 * devuelve una <code>java.util.date</code> equivalente a esta fecha. 200 * 201 * @return la fecha. 202 */ 203 public date todate() { 204 final calendar calendar = calendar.getinstance(); 205 calendar.set(getyyyy(), getmonth() - 1, getdayofmonth(), 0, 0, 0); 206 return calendar.gettime(); 207 } 208 209 /** 210 * devuelve el año (con un intervalo válido de 1900 a 9999). 211 * 212 * @return el año. 489213 */ 214 public int getyyyy() { 215 return this.year; 216 } 217 218 /** 219 * devuelve el mes (enero = 1, febrero = 2, marzo = 3). 220 * 221 * @return el mes del año. 222 */ 223 public int getmonth() { 224 return this.month; 225 } 226 227 /** 228 * devuelve el día del mes. 229 * 230 * @return el día del mes. 231 */ 232 public int getdayofmonth() { 233 return this.day; 234 } 235 236 /** 237 * devuelve un código que representa el día de la semana. 238 * <p> 239 * los códigos se definen en la clase {@link serialdate} como: 240 * <code>sunday</code>, <code>monday</code>, <code>tuesday</code>, 241 * <code>wednesday</code>, <code>thursday</code>, <code>friday</code>, y 242 * <code>saturday</code>. 243 * 244 * @return un código que representa el día de la semana. 245 */ 246 public int getdayofweek() { 247 return (this.serial + 6) % 7 + 1; 248 } 249 250 /** 251 * prueba la igualdad de esta fecha con un objeto arbitrario. 252 * <p> 253 * este método sólo devuelve true si el objeto es una instancia de la 254 * clase base {@link serialdate} y representa el mismo día que 255 * {@link spreadsheetdate}. 256 * 490257 * @param object el objeto que comparar (se permite <code>null</code>). 258 * 259 * @return un valor booleano. 260 */ 261 public boolean equals(final object object) { 262 263 if (object instanceof serialdate) { 264 final serialdate s = (serialdate) object; 265 return (s.toserial() == this.toserial()); 266 } 267 else { 268 return false; 269 } 270 271 } 272 273 /** 274 * devuelve un código hash para la instancia de este objeto. 275 * 276 * @return un código hash. 277 */ 278 public int hashcode() { 279 return toserial(); 280 } 281 282 /** 283 * devuelve la diferencia (en días) entre esta fecha y la 284 * ‘otra’ fecha especificada. 285 * 286 * @param other la fecha con la que se compara. 287 * 288 * @return la diferencia (en días) entre esta fecha y la 289 * otra’ fecha especificada. 290 */ 291 public int compare(final serialdate other) { 292 return this.serial – other.toserial(); 293 } 294 295 /** 296 * implementa el método necesario para la interfaz comparable. 297 * 298 * @param other el otro objeto (normalmente otro serialdate). 299 * 300 * @return un entero negativo, cero o un entero positivo si este objeto 301 * es menor que, igual o mayor que el objeto especificado. 491302 */ 303 public int compareto(final object other) { 304 return compare((serialdate) other); 305 } 306 307 /** 308 * devuelve true si esta serialdate representa la misma fecha que la 309 * serialdate especificada. 310 * 311 * @param other la fecha con la que se compara. 312 * 313 * @return <code>true</code> si esta serialdate representa la misma fecha que 314 * la otra serialdate especificada. 315 */ 316 public boolean ison(final serialdate other) { 317 return (this.serial == other.toserial()); 318 } 319 320 /** 321 * devuelve true si esta serialdate representa una fecha anterior a 322 * la serialdate especificada. 323 * 324 * @param other la fecha con la que se compara. 325 * 326 * @return <code>true</code> si esta serialdate representa una fecha anterior a 327 * la serialdate especificada. 328 */ 329 public boolean isbefore(final serialdate other) { 330 return (this.serial < other.toserial()); 331 } 332 333 /** 334 * devuelve true si esta serialdate representa la misma fecha que la 335 * serialdate especificada. 336 * 337 * @param other la fecha con la que se compara. 338 * 339 * @return <code>true</code> si esta serialdate representa la misma fecha 340 * que la serialdate especificada. 341 */ 342 public boolean isonorbefore(final serialdate other) { 343 return (this.serial <= other.toserial()); 344 } 492345 346 /** 347 * devuelve true si esta serialdate representa la misma fecha que la 348 * serialdate especificada. 349 * 350 * @param other la fecha con la que se compara. 351 * 352 * @return <code>true</code> si esta serialdate representa la misma fecha 353 * que la serialdate especificada. 354 */ 355 public boolean isafter(final serialdate other) { 356 return (this.serial > other.toserial()); 357 } 358 359 /** 360 * devuelve true si esta serialdate representa la misma fecha que la 361 * serialdate especificada. 362 * 363 * @param other la fecha con la que se compara. 364 * 365 * @return <code>true</code> si esta serialdate representa la misma fecha 366 * que la serialdate especificada. 367 */ 368 public boolean isonorafter(final serialdate other) { 369 return (this.serial >= other.toserial()); 370 } 371 372 /** 373 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 374 * intervalo especificado (inclusive). el orden de fecha de d1 y d2 no es 375 * importante. 376 * 377 * @param d1 una fecha límite para el rango. 378 * @param d2 la otra fecha límite para el rango. 379 * 380 * @return un valor booleano. 381 */ 382 public boolean isinrange(final serialdate d1, final serialdate d2) { 383 return isinrange(d1, d2, serialdate.include_both); 384 } 385 386 /** 387 * devuelve true si esta serialdate se encuentra en el intervalo 493especificado 388 * (el invocador especifica si los puntos finales se incluyen o no). el orden 389 * de d1 y d2 no es importante. 390 * 391 * @param d1 una fecha límite para el rango. 392 * @param d2 la otra fecha límite para el rango. 393 * @param include un código que controla si la fecha inicial y final 394 * se incluyen en el intervalo. 395 * 396 * @return <code>true</code> si esta serialdate se encuentra en el intervalo 397 * especificado. 398 */ 399 public boolean isinrange(final serialdate d1, final serialdate d2, 400 final int include) { 401 final int s1 = d1.toserial(); 402 final int s2 = d2.toserial(); 403 final int start = math.min(s1, s2); 404 final int end = math.max(s1, s2); 405 406 final int s = toserial(); 407 if (include == serialdate.include_both) { 408 return (s >= start && s <= end); 409 } 410 else if (include == serialdate.include_first) { 411 return (s >= start && s < end); 412 } 413 else if (include == serialdate.include_second) { 414 return (s > start && s <= end); 415 } 416 else { 417 return (s > start && s < end); 418 } 419 } 420 421 /** 422 * calcular el número de serie a partir del día, mes y año. 423 * <p> 424 * 1-ene-1900 = 2. 425 * 426 * @param d el día. 427 * @param m el mes. 428 * @param y el año. 429 * 430 * @return el número de serie a partir del día, mes y año. 494431 */ 432 private int calcserial(final int d, final int m, final int y) { 433 final int yy = ((y - 1900) * 365) + serialdate.leapyearcount(y - 1); 434 int mm = serialdate.aggregate_days_to_end_of_preceding_month[m]; 435 if (m > monthconstants.february) { 436 if (serialdate.isleapyear(y)) { 437 mm = mm + 1; 438 } 439 } 440 final int dd = d; 441 return yy + mm + dd + 1; 442 } 443 444 /** 445 * calcular el día, mes y año a partir del número de serie. 446 */ 447 private void calcdaymonthyear() { 448 449 // obtener el año a partir del número de serie de la fecha 450 final int days = this.serial - serial_lower_bound; 451 // sobrevalorado ya que ignoramos los días bisiestos 452 final int overestimatedyyyy = 1900 + (days / 365); 453 final int leaps = serialdate.leapyearcount(overestimatedyyyy); 454 final int nonleapdays = days - leaps; 455 // subestimado ya que sobrevaloramos los años 456 int underestimatedyyyy = 1900 + (nonleapdays / 365); 457 458 if (underestimatedyyyy == overestimatedyyyy) { 459 this.year = underestimatedyyyy; 460 } 461 else { 462 int ss1 = calcserial(1, 1, underestimatedyyyy); 463 while (ss1 <= this.serial) { 464 underestimatedyyyy = underestimatedyyyy + 1; 465 ss1 = calcserial(1, 1, underestimatedyyyy); 466 } 467 this.year = underestimatedyyyy - 1; 468 } 469 470 final int ss2 = calcserial(1, 1, this.year); 471 472 int[] daystoendofprecedingmonth 473 = aggregate_days_to_end_of_preceding_month; 474 475 if (isleapyear(this.year)) { 495476 daystoendofprecedingmonth 477 = leap_year_aggregate_days_to_end_of_preceding_month; 478 } 479 480 // get the month from the serial date 481 int mm = 1; 482 int sss = ss2 + daystoendofprecedingmonth[mm] - 1; 483 while (sss < this.serial) { 484 mm = mm + 1; 485 sss = ss2 + daystoendofprecedingmonth[mm] - 1; 486 } 487 this.month = mm - 1; 488 489 // el resto es d(+1); 490 this.day = this.serial - ss2 491 - daystoendofprecedingmonth[this.month] + 1; 492 493 } 494 495 } listado b-6 relativedayofweekrule.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 49619 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * -------------------------- 28 * relativedayofweekrule.java 29 * -------------------------- 30 * (c) copyright 2000-2003, de object refinery limited y colaboradores. 31 * 32 * autor original: david gilbert (por object refinery limited); 33 * colaboradores(s): -; 34 * 35 * $id: relativedayofweekrule.java,v 1.6 2005/11/16 15:58:40 taqua exp $ 36 * 37 * cambios (26-oct-2001) 38 * -------------------------- 39 * 26-oct-2001 : se cambió el paquete por com.jrefinery.date.*; 40 * 03-oct-2002 : se corrigen los errores detectados por checkstyle (dg); 41 * 42 */ 43 44 package org.jfree.date; 45 46 /** 47 * una regla de fechas anuales que devuelve una fecha por cada año en función de 48 * (a) una regla de referencia; (b) un día de la semana y (c) un parámetro de 49 * selección (serialdate.preceding, serialdate.nearest, serialdate.following). 50 * <p> 51 * por ejemplo, el viernes santo se puede especificado ‘el viernes anterior al 52 * domingo de resurrección. 53 * 54 * @author david gilbert 55 */ 56 public class relativedayofweekrule extends annualdaterule { 57 58 /** una referencia a la regla de fechas anuales sobre la que se basa esta regla. */ 59 private annualdaterule subrule; 49760 61 /** 62 * el día de la semana (serialdate.monday, serialdate.tuesday, etc). 63 */ 64 private int dayofweek; 65 66 /** indica que día de la semana (preceding, nearest o following). */ 67 private int relative; 68 69 /** 70 * constructor predeterminado: genera una regla para el lunes siguiente al 1 de enero. 71 */ 72 public relativedayofweekrule() { 73 this(new dayandmonthrule(), serialdate.monday, serialdate.following); 74 } 75 76 /** 77 * constructor estándar: genera una regla en función de la subregla proporcionada. 78 * 79 * @param subrule la regla que determina la fecha de referencia. 80 * @param dayofweek el día de la semana relativo a la fecha de referencia. 81 * @param relative indica “qué” día de la semana (anterior, más próximo 82 * o posterior). 83 */ 84 public relativedayofweekrule(final annualdaterule subrule, 85 final int dayofweek, final int relative) { 86 this.subrule = subrule; 87 this.dayofweek = dayofweek; 88 this.relative = relative; 89 } 90 91 /** 92 * devuelve la subregla (también denominada regla de referencia). 93 * 94 * @return la regla de fechas anuales que determina la fecha de referencia para 95 * esta regla. 96 */ 97 public annualdaterule getsubrule() { 98 return this.subrule; 99 } 100 498101 /** 102 * establece la subregla. 103 * 104 * @param subrule la regla de fechas anuales que determina la fecha de 105 * referencia para esta regla. 106 */ 107 public void setsubrule(final annualdaterule subrule) { 108 this.subrule = subrule; 109 } 110 111 /** 112 * devuelve el día de la semana de esta regla. 113 * 114 * @return el día de la semana de esta regla. 115 */ 116 public int getdayofweek() { 117 return this.dayofweek; 118 } 119 120 /** 121 * establece el día de la semana de esta regla. 122 * 123 * @param dayofweek el día de la semana de (serialdate.monday, 124 * serialdate.tuesday, etc.). 125 */ 126 public void setdayofweek(final int dayofweek) { 127 this.dayofweek = dayofweek; 128 } 129 130 /** 131 * devuelve el atributo ‘relativo’ que determina “qué” 132 * día de la semana nos interesa (serialdate.preceding, 133 * serialdate.nearest o serialdate.following). 134 * 135 * @return el atributo ‘relativo’. 136 */ 137 public int getrelative() { 138 return this.relative; 139 } 140 141 /** 142 * establece el atributo ‘relativo’ (serialdate.preceding, serialdate.nearest, 143 * serialdate.following). 144 * 499145 * @param relative determina “qué” día de la semana se selecciona con esta 146 * regla. 147 */ 148 public void setrelative(final int relative) { 149 this.relative = relative; 150 } 151 152 /** 153 * crea un clon de esta regla. 154 * 155 * @return un clon de esta regla. 156 * 157 * @throws clonenotsupportedexception nunca debe producirse. 158 */ 159 public object clone() throws clonenotsupportedexception { 160 final relativedayofweekrule duplicate 161 = (relativedayofweekrule) super.clone(); 162 duplicate.subrule = (annualdaterule) duplicate.getsubrule().clone(); 163 return duplicate; 164 } 165 166 /** 167 * devuelve la fecha generada por esta regla, para el año especificado. 168 * 169 * @param year el año (1900 &lt;= year &lt;= 9999). 170 * 171 * @return la fecha generada por esta regla para un año concreto (posiblemente 172 * <code>null</code>). 173 */ 174 public serialdate getdate(final int year) { 175 176 // comprobar argumento… 177 if ((year < serialdate.minimum_year_supported) 178 || (year > serialdate.maximum_year_supported)) { 179 throw new illegalargumentexception( 180 “relativedayofweekrule.getdate(): year outside valid range.”); 181 } 182 183 // calcular la fecha… 184 serialdate result = null; 185 final serialdate base = this.subrule.getdate(year); 186 187 if (base != null) { 188 switch (this.relative) { 500189 case(serialdate.preceding): 190 result = serialdate.getpreviousdayofweek(this.dayofweek, 191 base); 192 break; 193 case(serialdate.nearest): 194 result = serialdate.getnearestdayofweek(this.dayofweek, 195 base); 196 break; 197 case(serialdate.following): 198 result = serialdate.getfollowingdayofweek(this.dayofweek, 199 base); 200 break; 201 default: 202 break; 203 } 204 } 205 return result; 206 207 } 208 209 } listado b-7 daydate.java (final) 1 /* ============================================================= 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. … 36 */ 37 package org.jfree.date; 38 39 import java.io.serializable; 40 import java.util.*; 41 42 /** 43 * una clase abstracta que representa fechas inmutables con una precisión de 44 * un día. la implementación asigna cada fecha a un entero que 45 * representa un número ordinal de días de un origen fijo. 46 * 47 * ¿por qué no usar java.útil.date? lo haremos, cuando tenga sentido. en ocasiones, 50148 * java.util.date puede ser demasiado precisa; representa un instante en el tiempo, 49 * con una precisión de 1/1000 de segundo (y la fecha depende de la 50 * zona horaria). en ocasiones solo querremos representar un día concreto (como el 21 51 * de enero de 2015) sin preocuparnos de la hora del día, la 52 * zona horaria u otros aspectos. para eso hemos definido serialdate. 53 * 54 * usar daydatefactory.makedate para crear una instancia. 55 * 56 * @author david gilbert 57 * @author robert c. martin realizó gran parte de la refactorización. 58 */ 59 60 public abstract class daydate implements comparable, serializable { 61 public abstract int getordinalday(); 62 public abstract int getyear(); 63 public abstract month getmonth(); 64 public abstract int getdayofmonth(); 65 66 protected abstract day getdayofweekforordinalzero(); 67 68 public daydate plusdays(int days) { 69 return daydatefactory.makedate(getordinalday() + days); 70 } 71 72 public daydate plusmonths(int months) { 73 int thismonthasordinal = getmonth().toint() - month.january.toint(); 74 int thismonthandyearasordinal = 12 * getyear() + thismonthasordinal; 75 int resultmonthandyearasordinal = thismonthandyearasordinal + months; 76 int resultyear = resultmonthandyearasordinal / 12; 77 int resultmonthasordinal = resultmonthandyearasordinal % 12 + month.january.toint(); 78 month resultmonth = month.fromint(resultmonthasordinal); 79 int resultday = correctlastdayofmonth(getdayofmonth(), resultmonth, resultyear); 80 return daydatefactory.makedate(resultday, resultmonth, resultyear); 81 } 82 83 public daydate plusyears(int years) { 84 int resultyear = getyear() + years; 85 int resultday = correctlastdayofmonth(getdayofmonth(), getmonth(), resultyear); 86 return daydatefactory.makedate(resultday, getmonth(), resultyear); 87 } 50288 89 private int correctlastdayofmonth(int day, month month, int year) { 90 int lastdayofmonth = dateutil.lastdayofmonth(month, year); 91 if (day > lastdayofmonth) 92 day = lastdayofmonth; 93 return day; 94 } 95 96 public daydate getpreviousdayofweek(day targetdayofweek) { 97 int offsettotarget = targetdayofweek.toint() - getdayofweek().toint(); 98 if (offsettotarget >= 0) 99 offsettotarget -= 7; 100 return plusdays(offsettotarget); 101 } 102 103 public daydate getfollowingdayofweek(day targetdayofweek) { 104 int offsettotarget = targetdayofweek.toint() - getdayofweek().toint(); 105 if (offsettotarget <= 0) 106 offsettotarget += 7; 107 return plusdays(offsettotarget); 108 } 109 110 public daydate getnearestdayofweek(day targetdayofweek) { 111 int offsettothisweekstarget = targetdayofweek.toint() - getdayofweek().toint(); 112 int offsettofuturetarget = (offsettothisweekstarget + 7) % 7; 113 int offsettoprevioustarget = offsettofuturetarget - 7; 114 115 if (offsettofuturetarget > 3) 116 return plusdays(offsettoprevioustarget); 117 else 118 return plusdays(offsettofuturetarget); 119 } 120 121 public daydate getendofmonth() { 122 month month = getmonth(); 123 int year = getyear(); 124 int lastday = dateutil.lastdayofmonth(month, year); 125 return daydatefactory.makedate(lastday, month, year); 126 } 127 128 public date todate() { 129 final calendar calendar = calendar.getinstance(); 130 int ordinalmonth = getmonth().toint() - month.january.toint(); 503131 calendar.set(getyear(), ordinalmonth, getdayofmonth(), 0, 0, 0); 132 return calendar.gettime(); 133 } 134 135 public string tostring() { 136 return string.format(“%02d-%s-%d”, getdayofmonth(), getmonth(), getyear()); 137 } 138 139 public day getdayofweek() { 140 day startingday = getdayofweekforordinalzero(); 141 int startingoffset = startingday.toint() - day.sunday.toint(); 142 int ordinalofdayofweek = (getordinalday() + startingoffset) % 7; 143 return day.fromint(ordinalofdayofweek + day.sunday.toint()); 144 } 145 146 public int dayssince(daydate date) { 147 return getordinalday() - date.getordinalday(); 148 } 149 150 public boolean ison(daydate other) { 151 return getordinalday() == other.getordinalday(); 152 } 153 154 public boolean isbefore(daydate other) { 155 return getordinalday() < other.getordinalday(); 156 } 157 158 public boolean isonorbefore(daydate other) { 159 return getordinalday() <= other.getordinalday(); 160 } 161 162 public boolean isafter(daydate other) { 163 return getordinalday() > other.getordinalday(); 164 } 165 166 public boolean isonorafter(daydate other) { 167 return getordinalday() >= other.getordinalday(); 168 } 169 170 public boolean isinrange(daydate d1, daydate d2) { 171 return isinrange(d1, d2, dateinterval.closed); 172 } 173 174 public boolean isinrange(daydate d1, daydate d2, dateinterval interval) { 504175 int left = math.min(d1.getordinalday(), d2.getordinalday()); 176 int right = math.max(d1.getordinalday(), d2.getordinalday()); 177 return interval.isin(getordinalday(), left, right); 178 } 179 } listado b-8 month.java (final) 1 package org.jfree.date; 2 3 import java.text.dateformatsymbols; 4 5 public enum month { 6 january(1), february(2), march(3), 7 april(4), may(5), june(6), 8 july(7), august(8), september(9), 9 october(10),november(11),december(12); 10 private static dateformatsymbols dateformatsymbols = new dateformatsymbols(); 11 private static final int[] last_day_of_month = 12 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 13 14 private int index; 15 16 month(int index) { 17 this.index = index; 18 } 19 20 public static month fromint(int monthindex) { 21 for (month m : month.values()) { 22 if (m.index == monthindex) 23 return m; 24 } 25 throw new illegalargumentexception(“invalid month index ” + monthindex); 26 } 27 28 public int lastday() { 29 return last_day_of_month[index]; 30 } 31 32 public int quarter() { 33 return 1 + (index - 1) / 3; 50534 } 35 36 public string tostring() { 37 return dateformatsymbols.getmonths()[index - 1]; 38 } 39 40 public string toshortstring() { 41 return dateformatsymbols.getshortmonths()[index - 1]; 42 } 43 44 public static month parse(string s) { 45 s = s.trim(); 46 for (month m : month.values()) 47 if (m.matches(s)) 48 return m; 49 50 try { 51 return fromint(integer.parseint(s)); 52 } 53 catch (numberformatexception e) {} 54 throw new illegalargumentexception(“invalid month ” + s); 55 } 56 57 private boolean matches(string s) { 58 return s.equalsignorecase(tostring()) || 59 s.equalsignorecase(toshortstring()); 60 } 61 62 public int toint() { 63 return index; 64 } 65 } listado b-9 day.java (final) 1 package org.jfree.date; 2 3 import java.util.calendar; 4 import java.text.dateformatsymbols; 5 6 public enum day { 7 monday(calendar.monday), 8 tuesday(calendar.tuesday), 5069 wednesday(calendar.wednesday), 10 thursday(calendar.thursday), 11 friday(calendar.friday), 12 saturday(calendar.saturday), 13 sunday(calendar.sunday); 14 15 private final int index; 16 private static dateformatsymbols datesymbols = new dateformatsymbols(); 17 18 day(int day) { 19 index = day; 20 } 21 22 public static day fromint(int index) throws illegalargumentexception { 23 for (day d : day.values()) 24 if (d.index == index) 25 return d; 26 throw new illegalargumentexception( 27 string.format(“illegal day index: %d.”, index)); 28 } 29 30 public static day parse(string s) throws illegalargumentexception { 31 string[] shortweekdaynames = 32 datesymbols.getshortweekdays(); 33 string[] weekdaynames = 34 datesymbols.getweekdays(); 35 36 s = s.trim(); 37 for (day day : day.values()) { 38 if (s.equalsignorecase(shortweekdaynames[day.index]) || 39 s.equalsignorecase(weekdaynames[day.index])) { 40 return day; 41 } 42 } 43 throw new illegalargumentexception( 44 string.format(“%s is not a valid weekday string”, s)); 45 } 46 47 public string tostring() { 48 return datesymbols.getweekdays()[index]; 49 } 50 51 public int toint() { 52 return index; 53 } 50754 } listado b-10 dateinterval.java (final) 1 package org.jfree.date; 2 3 public enum dateinterval { 4 open { 5 public boolean isin(int d, int left, int right) { 6 return d > left && d < right; 7 } 8 }, 9 closed_left { 10 public boolean isin(int d, int left, int right) { 11 return d >= left && d < right; 12 } 13 }, 14 closed_right { 15 public boolean isin(int d, int left, int right) { 16 return d > left && d <= right; 17 } 18 }, 19 closed { 20 public boolean isin(int d, int left, int right) { 21 return d >= left && d <= right; 22 } 23 }; 24 25 public abstract boolean isin(int d, int left, int right); 26 } listado b-11 weekinmonth.java (final) 1 package org.jfree.date; 2 3 public enum weekinmonth { 4 first(1), second(2), third(3), fourth(4), last(0); 5 private final int index; 6 7 weekinmonth(int index) { 8 this.index = index; 5089 } 10 11 public int toint() { 12 return index; 13 } 14 } listado b-12 weekdayrange.java (final) 1 package org.jfree.date; 2 3 public enum weekdayrange { 4 last, nearest, next 5 } listado b-13 dateutil.java (final) 1 package org.jfree.date; 2 3 import java.text.dateformatsymbols; 4 5 public class dateutil { 6 private static dateformatsymbols dateformatsymbols = new dateformatsymbols(); 7 8 public static string[] getmonthnames() { 9 return dateformatsymbols.getmonths(); 10 } 11 12 public static boolean isleapyear(int year) { 13 boolean fourth = year % 4 == 0; 14 boolean hundredth = year % 100 == 0; 15 boolean fourhundredth = year % 400 == 0; 16 return fourth && (!hundredth || fourhundredth); 17 } 18 19 public static int lastdayofmonth(month month, int year) { 20 if (month == month.february && isleapyear(year)) 21 return month.lastday() + 1; 22 else 23 return month.lastday(); 50924 } 25 26 public static int leapyearcount(int year) { 27 int leap4 = (year - 1896) / 4; 28 int leap100 = (year - 1800) / 100; 29 int leap400 = (year - 1600) / 400; 30 return leap4 - leap100 + leap400; 31 } 32 } listado b-14 daydatefactory.java (final) 1 package org.jfree.date; 2 3 public abstract class daydatefactory { 4 private static daydatefactory factory = new spreadsheetdatefactory(); 5 public static void setinstance(daydatefactory factory) { 6 daydatefactory.factory = factory; 7 } 8 9 protected abstract daydate _makedate(int ordinal); 10 protected abstract daydate _makedate(int day, month month, int year); 11 protected abstract daydate _makedate(int day, int month, int year); 12 protected abstract daydate _makedate(java.util.date date); 13 protected abstract int _getminimumyear(); 14 protected abstract int _getmaximumyear(); 15 16 public static daydate makedate(int ordinal) { 17 return factory._makedate(ordinal); 18 } 19 20 public static daydate makedate(int day, month month, int year) { 21 return factory._makedate(day, month, year); 22 } 23 24 public static daydate makedate(int day, int month, int year) { 25 return factory._makedate(day, month, year); 26 } 27 28 public static daydate makedate(java.util.date date) { 29 return factory._makedate(date); 30 } 51031 32 public static int getminimumyear() { 33 return factory._getminimumyear(); 34 } 35 36 public static int getmaximumyear() { 37 return factory._getmaximumyear(); 38 } 39 } listado b-15 spreadsheetdatefactory.java (final) 1 package org.jfree.date; 2 3 import java.util.*; 4 5 public class spreadsheetdatefactory extends daydatefactory { 6 public daydate _makedate(int ordinal) { 7 return new spreadsheetdate(ordinal); 8 } 9 10 public daydate _makedate(int day, month month, int year) { 11 return new spreadsheetdate(day, month, year); 12 } 13 14 public daydate _makedate(int day, int month, int year) { 15 return new spreadsheetdate(day, month, year); 16 } 17 18 public daydate _makedate(date date) { 19 final gregoriancalendar calendar = new gregoriancalendar(); 20 calendar.settime(date); 21 return new spreadsheetdate( 22 calendar.get(calendar.date), 23 month.fromint(calendar.get(calendar.month) + 1), 24 calendar.get(calendar.year)); 25 } 26 27 protected int _getminimumyear() { 28 return spreadsheetdate.minimum_year_supported; 29 } 30 31 protected int _getmaximumyear() { 51132 return spreadsheetdate.maximum_year_supported; 33 } 34 } listado b-16 spreadsheetdate.java (final) 1 /* ============================================================== 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================== 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * … 52 * 53 */ 54 55 package org.jfree.date; 56 57 import static org.jfree.date.month.february; 58 59 import java.util.*; 60 61 /** 62 * representa una fecha con un entero, de forma similar a la 63 * implementación en microsoft excel. el intervalo de fechas admitido es 64 * del 1-ene-1900 al 31-dic-9999. 65 * <p/> 66 * recuerde que excel tiene un error que reconoce el año 67 * 1900 como bisiesto cuando en realidad no lo es. encontrará más 68 * información en el sitio de microsoft, en el artículo q181370: 69 * <p/> 70 * http://support.microsoft.com/support/kb/articles/q181/3/70.asp 71 * <p/> 72 * excel usa como convención que el 1-ene-1900 = 1. esta clase usa la 73 * convención de que el 1-ene-1900 = 2. 74 * como resultado, el número de día de esta clase será diferente al de 75 * excel para enero y febrero de 1900… pero excel añade un día 76 * más (29-feb-1900 que en realidad no existe) y a partir de ahí 77 * los números de los días coinciden. 78 * 79 * @author david gilbert 80 */ 81 public class spreadsheetdate extends daydate { 51282 public static final int earliest_date_ordinal = 2; // 1/1/1900 83 public static final int latest_date_ordinal = 2958465; // 12/31/9999 84 public static final int minimum_year_supported = 1900; 85 public static final int maximum_year_supported = 9999; 86 static final int[] aggregate_days_to_end_of_preceding_month = 87 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 88 static final int[] leap_year_aggregate_days_to_end_of_preceding_month = 89 {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 90 91 private int ordinalday; 92 private int day; 93 private month month; 94 private int year; 95 96 public spreadsheetdate(int day, month month, int year) { 97 if (year < minimum_year_supported || year > maximum_year_supported) 98 throw new illegalargumentexception( 99 “the ‘year’ argument must be in range ” + 100 minimum_year_supported + “ to ” + maximum_year_supported + “.”); 101 if (day < 1 || day > dateutil.lastdayofmonth(month, year)) 102 throw new illegalargumentexception(“invalid ‘day’ argument.”); 103 104 this.year = year; 105 this.month = month; 106 this.day = day; 107 ordinalday = calcordinal(day, month, year); 108 } 109 110 public spreadsheetdate(int day, int month, int year) { 111 this(day, month.fromint(month), year); 112 } 113 114 public spreadsheetdate(int serial) { 115 if (serial < earliest_date_ordinal || serial > latest_date_ordinal) 116 throw new illegalargumentexception( 117 “spreadsheetdate: serial must be in range 2 to 2958465.”); 118 119 ordinalday = serial; 120 calcdaymonthyear(); 121 } 122 123 public int getordinalday() { 124 return ordinalday; 125 } 513126 127 public int getyear() { 128 return year; 129 } 130 131 public month getmonth() { 132 return month; 133 } 134 135 public int getdayofmonth() { 136 return day; 137 } 138 139 protected day getdayofweekforordinalzero() {return day.saturday;} 140 141 public boolean equals(object object) { 142 if (!(object instanceof daydate)) 143 return false; 144 145 daydate date = (daydate) object; 146 return date.getordinalday() == getordinalday(); 147 } 148 149 public int hashcode() { 150 return getordinalday(); 151 } 152 153 public int compareto(object other) { 154 return dayssince((daydate) other); 155 } 156 157 private int calcordinal(int day, month month, int year) { 158 int leapdaysforyear = dateutil.leapyearcount(year - 1); 159 int daysuptoyear = (year - minimum_year_supported) * 365 + leapdaysforyear; 160 int daysuptomonth = aggregate_days_to_end_of_preceding_month[month.toint()]; 161 if (dateutil.isleapyear(year) && month.toint() > february.toint()) 162 daysuptomonth++; 163 int daysinmonth = day - 1; 164 return daysuptoyear + daysuptomonth + daysinmonth + earliest_date_ordinal; 165 } 166 167 private void calcdaymonthyear() { 168 int days = ordinalday - earliest_date_ordinal; 514169 int overestimatedyear = minimum_year_supported + days / 365; 170 int nonleapdays = days - dateutil.leapyearcount(overestimatedyear); 171 int underestimatedyear = minimum_year_supported + nonleapdays / 365; 172 173 year = huntforyearcontaining(ordinalday, underestimatedyear); 174 int firstordinalofyear = firstordinalofyear(year); 175 month = huntformonthcontaining(ordinalday, firstordinalofyear); 176 day = ordinalday - firstordinalofyear - daysbeforethismonth(month.toint()); 177 } 178 179 private month huntformonthcontaining(int anordinal, int firstordinalofyear) { 180 int daysintothisyear = anordinal - firstordinalofyear; 181 int amonth = 1; 182 while (daysbeforethismonth(amonth) < daysintothisyear) 183 amonth++; 184 185 return month.fromint(amonth - 1); 186 } 187 188 private int daysbeforethismonth(int amonth) { 189 if (dateutil.isleapyear(year)) 190 return leap_year_aggregate_days_to_end_of_preceding_month[amonth] - 1; 191 else 192 return aggregate_days_to_end_of_preceding_month[amonth] - 1; 193 } 194 195 private int huntforyearcontaining(int anordinalday, int startingyear) { 196 int ayear = startingyear; 197 while (firstordinalofyear(ayear) <= anordinalday) 198 ayear++; 199 200 return ayear - 1; 201 } 202 203 private int firstordinalofyear(int year) { 204 return calcordinal(1, month.january, year); 205 } 206 207 public static daydate createinstance(date date) { 208 gregoriancalendar calendar = new gregoriancalendar(); 209 calendar.settime(date); 210 return new spreadsheetdate(calendar.get(calendar.date), 515211 month.fromint(calendar.get(calendar.month) + 1), 212 calendar.get(calendar.year)); 213 214 } 215 } 516epílogo en 2005, mientras asistía a la conferencia agile en denver (ee.uu.), elisabeth hedrickson [125] me dio una pulsera verde parecida a la que lance armstrong popularizó hace unos años. en ésta se leía test obsessed (obsesionado por las pruebas). me la puse y la lucí con orgullo. desde que aprendí el tdd de kent beck en 1999, sin duda el desarrollo controlado por pruebas me ha obsesionado. pero sucedió algo extraño. no me podía quitar la pulsera. no porque se hubiera quedado físicamente pegada, sino porque estaba moralmente pegada. la pulsera resumía mi ética profesional. era un indicador visible de mi compromiso por crear el mejor código posible. si me la hubiera quitado habría traicionado a esa ética y a ese compromiso. y todavía la llevo en la muñeca. cuando escribo código, la veo ahí. es un recordatorio constante de la promesa que me hice de escribir código limpio. 517robert cecil “uncle bob” martin (palo alto california, estados unidos, 1952). es un prestigioso desarrollador de software desde 1970 y consultor internacional desde 1990. es fundador y presidente de object mentor, inc., un equipo de experimentados consultores que ayudan a clientes de todo el mundo en diferentes campos de la programación como c++, java, c#, ruby, programación orientada a objetos (poo), patrones de diseño, uml, metodologías ágiles y programación extreme. 518notas 519[1] [beck07]. << 520[2] cuando ignaz semmelweis recomendó en 1847 que los médicos se lavaran las manos, su propuesta fue rechazada aludiendo que los doctores estaban demasiado ocupados para hacerlo entre paciente y paciente. << 521[3] http://www.pragmaticprogrammer.com/booksellers/2004-12.html. << 522[4] [knuth92]. << 523[5] es una adaptación del mensaje de despedida de robert stephenson smyth baden-powell a los scouts: «intentad dejar este mundo un poco mejor de como os lo encontrasteis…». << 524[6] como veremos más adelante, aunque un contenedor sea una lista , no conviene codificar el tipo de contenedor en el nombre. << 525[7] imagine que se crea una variable con el nombre klass sólo porque el nombre class se ha usado en otro elemento. << 526[8] uncle bob solía hacerlo en c++ pero ha abandonado esta práctica ya que no es necesario en los ide modernos. << 527[9] http://java.sun.com/products/javabeans/docs/spec.html. << 528[10] una herramienta de pruebas de código abierto (www.fitnese.org). << 529[11] una herramienta de código abierto para probar unidades para java ( www.junit.org ). << 530[12] le pregunté a kent si todavía conservaba una copia, pero no la encontró. busqué en mis viejos ordenadores, pero nada. solamente se conserva el recuerdo de aquél programa. << 531[13] el lenguaje logo usaba la palabra clave to al igual que ruby y python usaban def . por tanto, todas las funciones comenzaban por to , lo que tenía un efecto interesante en cómo se diseñaban. << 532[14] [kp78], p. 37. << 533[15] y, por supuesto, se incluyen cadenas if/else. << 534[16] a. http://en.wikipedia.org/wiki/single_responsibility_principle b. http://www.objectmentor.com/resources/articles/srp.pdf << 535[17] a. http://en.wikipedia.org/wiki/open/closed_principle b. http://www.objectmentor.com/resources/articles/ocp.pdf << 536[18] [gof]. << 537[19] terminé la refactorización de un módulo que usaba la forma dinámica. conseguí convertir el módulo outputstream en un campo de la clase y las invocaciones de writefield a formato monódico. el resultado fue mucho más limpio. << 538[20] existen algunos que creen que pueden evitar volver a compilar e implementar, y nos hemos encargado de ellos. << 539[21] ejemplo de principio abierto/cerrado (ocp) [ppp02]. << 540[22] el principio dry. [prag]. << 541[23] [sp72]. << 542[24] [kp78], p. 144. << 543[25] la tendencia actual de los ide de comprobar la ortografía de los comentarios será un bálsamo para los que tenemos que leer gran cantidad de código. << 544[26] el cuadro muestra sigma/2 por encima y debajo de la media. asumo que la distribución de la longitud de archivos no es normal, por lo que la desviación estándar no es matemáticamente precisa. pero aquí el objetivo no es la precisión, sino la sensación. << 545[27] es lo contrario a lo que sucede en lenguajes como pascal, c y c++ que obligan a definir, o al menos a declarar, las funciones antes de usarlas. << 546[28] ¿a quien voy a engañar? sigo siendo programador de lenguajes de ensamblado. en este caso, el hábito sí hace al monje. << 547[29] siempre existe una solución conocida por los diseñadores orientados a objetos con experiencia: visitor o entrega dual, por ejemplo. pero son técnicas costosas y suelen devolver la estructura de un programa por procedimientos. << 548[30] http://es.wikipedia.org/wiki/ley_de_demeter. << 549[31] de la estructura apache. << 550[32] en ocasiones se denomina feature envy (envidia de las características), de [refactoring]. << 551[33] [martin]. << 552[34] [becktdd], pp. 136-137. << 553[35] véase el patrón del adaptador en [gof]. << 554[36] más información al respecto en [welc]. << 555[37]  professionalism and test-driven development , robert c. martin, object mentor, ieee software, mayo/junio 2007 (vol. 24, no. 3) pp. 32-36 http://doi.ieeecomputersociety.org/10.1109/ms.2007.85 << 556[38] http://fitnesse.org/fitnesse.acceptancetestpatterns. << 557[39] véase el apartado sobre asignaciones mentales del capítulo 2. << 558[40] véase la entrada de dave astel: http://www.artima.com/weblogs/viewpost.jsp?thread=35578 << 559[41] [rspec]. << 560[42] [gof]. << 561[43] ¡cíñase al código! << 562[44] materiales de formación de object mentor. << 563[45] [rdd]. << 564[46] encontrará más información sobre este principio en [ppp]. << 565[47] [knuth92]. << 566[48] [ppp]. << 567[49] [ppp]. << 568[50] [mezzaros07]. << 569[51] [gof]. << 570[52] véase, por ejemplo, [fowler]. << 571[53] véase [spring], también existe una estructura spring.net. << 572[54] no olvide que la creación de instancias/evaluación tardía es sólo una optimización, puede que prematura. << 573[55] sistema de administración de base de datos. << 574[56] consulte [aosd] si necesita información general sobre aspectos y [aspectj] y [colyer] para información concreta de aspectj. << 575[57] no se necesita la modificación manual del código fuente de destino. << 576[58] véase [cglib], [asm] y [javassist]. << 577[59] si necesita ejemplos más detallados de la api proxy y ejemplos de uso, consulte [goetz]. << 578[60] aop se suele confundir con técnicas empleadas para implementarlo, como la intercepción y envoltorio de métodos a través de proxies . el verdadero valor de un sistema aop es la capacidad para especificar comportamientos del sistema de forma concisa y modular. << 579[61] véase [spring] y [jboss]. java puro significa sin aspectj. << 580[62] adaptado de www.theserverside.com/tt/articles/article.tss? l=introtospring25. << 581[63] [gof]. << 582[64] el ejemplo se puede simplificar mediante mecanismos que usen convenciones y anotaciones de java 5 para reducir la cantidad necesaria de lógica de conexión explícita. << 583[65] adaptado de http://www.onjava.com/pub/a/onjava/2006/05/17/standardizing-with-ejb3- java-persistence-api.html. << 584[66] véase [aspectj] y [colyer]. << 585[67] no confundir con la práctica de diseño anticipado. bduf es la práctica de diseñar todo por adelantado antes de implementar nada. << 586[68] existe una cantidad significativa de exploración iterativa y detalles de análisis, incluso una vez iniciada la construcción. << 587[69] el término fue empleado por primera vez por [kolence]. << 588[70] el trabajo de [alexander] ha sido una gran influencia para la comunidad de software . << 589[71] véase, por ejemplo, [dsl]. [jmock] es un buen ejemplo de api de java que crea un dsl. << 590[72] [xpe]. << 591[73] [gof]. << 592[74] correspondencia privada. << 593[75] rayos cósmicos, repeticiones, etc. << 594[76] véase el apéndice a. << 595[77] véase el apéndice a. << 596[78] [ppp]. << 597[79] véase el apéndice a. << 598[80] [prag]. << 599[81] [lea99]. << 600[82] http://en.wikipedia.org/wiki/producer-consumer. << 601[83] http://en.wikipedia.org/wiki/readers-writers_problem. << 602[84] http://es.wikipedia.org/wiki/problema_de_la_cena_de_los_filósofos. << 603[85] véase el apéndice a. << 604[86] una sección crítica es cualquier sección de código que debe protegerse de usos simultáneos por parte del programa para que sea correcta. << 605[87] véase el apéndice a. << 606[88] véase el apéndice a. << 607[89] ¿sabía que el modelo de procesos de java no garantiza el procesamiento preventivo? los so modernos sí lo hacen, de modo que lo obtiene de forma gratuita. no obstante, la mvj no lo garantiza. << 608[90] no es estrictamente el caso. como la mvj no garantiza los procesos preventivos, un determinado algoritmo puede que siempre funcione en un so que no prevea los procesos. lo contrario también es posible, pero por distintos motivos. << 609[91] https://www.ibm.com/developerworks/community/groups/service/html/communityview? lang=es&communityuuid=18d10b14-e2c8-4780-bace-9af1fc463cc0. << 610[92] hace poco modifiqué este módulo para ruby. tenía una séptima parte del tamaño original y una mejor estructura. << 611[93] para evitar este tipo de sorpresas, añadí una nueva prueba de unidad que invocaba todas las pruebas de fitnesse. << 612[94]  junit pocket guide , kent beck, o’reilly. 2004. p. 43. << 613[95] véase el capítulo 1. << 614[96] una solución mejor sería que el javadoc presentara todos los comentarios con formato previo, para que tengan el mismo aspecto en el código y en el documento. << 615[97] algunos revisores de este texto no comparten esta decisión. sostienen que en una estructura de código abierto es más recomendable ejercer control manual sobre el id de serie para que los cambios mínimos del software no invaliden las fechas señalizadas antiguas. me parece justo. sin embargo, al menos el fallo, aunque sea inconveniente, tiene un motivo evidente. por otra parte, si el autor de la clase se olvida de actualizar el id, el modo de fallo será indefinido y puede que silencioso. creo que la moraleja es que no debe esperar a deserializar entre versiones. << 616[98] [gof]. << 617[99] ibid. << 618[100] ibid. << 619[101] [simmons04], p. 73. << 620[102] [refactoring]. << 621[103] [beck97]. << 622[104] [refactoring]. << 623[105] http://es.wikipedia.org/wiki/principio_de_la_mínima_sorpresa << 624[106] [prag]. << 625[107] [gof]. << 626[108] [gof]. << 627[109] [refactoring]. << 628[110] en concreto, el principio de responsabilidad única, el principio abierto/cerrado y el principio de cierre común. véase [ppp]. << 629[111] [beck97], p. 108. << 630[112] [beck07]. << 631[113] es distinto saber cómo funciona el código y saber si el algoritmo se encargará de realizar la tarea para la que se necesita. es habitual desconocer si un algoritmo es el adecuado. desconocer lo que hace el código es indolencia. << 632[114] o mejor todavía, una clase money que use enteros. << 633[115] [prag]. p. 138. << 634[116] véase la cita de ward cunningham del capítulo 1. << 635[117] [ddd]. << 636[118] puede comprobar personalmente el código antes y después, y revisar las versiones con y sin subprocesos, que veremos en un apartado posterior. << 637[119] es una comparación simplificada, pero para los objetivos de este ejercicio es un modelo válido. << 638[120] de hecho, la interfaz iterator es incompatible con subprocesos por naturaleza. no se diseñó para usar varios subprocesos, de modo que no debería sorprenderle. << 639[121] por ejemplo, alguien añade un resultado de depuración y el problema desaparece. el código de depuración corrige el problema, pero permanece en el sistema. << 640[122] siglas de there ain’t no such thing as a free lunch (todo tiene un precio). << 641[123] http://www.haifa.ibm.com/projects/verification/contest/index.html << 642[124] véase [lea99] p. 191. << 643[125] http://www.qualitytree.com/ << 644cada año, se invierten innumerables horas y se pierden numerosos recursos debido a código mal escrito, ralentizando el desarrollo, disminuyendo la productividad, generando graves fallos e incluso pudiendo acabar con la organización o empresa. el reconocido experto de software robert c. martin, junto con sus colegas de object mentor, nos presentan sus óptimas técnicas y metodologías ágiles para limpiar el código sobre la marcha y crearlo de forma correcta, de este modo mejorará como programador. esta obra se divide en tres partes. la primera describe los principios, patrones y prácticas para crear código limpio. la segunda incluye varios casos de estudio cuya complejidad va aumentando. cada ejemplo es un ejercicio de limpieza y transformación de código con problemas. la tercera parte del libro contiene una lista de heurística y síntomas de código erróneo (smells) confeccionada al crear los casos prácticos. el resultado es una base de conocimientos que describe cómo pensamos cuando creamos, leemos y limpiamos código. imprescindible para cualquier desarrollador, ingeniero de software, director de proyectos, jefe de equipo o analista de sistemas interesado en crear código de mejor calidad. ¡el libro que todo programador debe leer! 2robert cecil martin código limpio manual de estilo para el desarrollo ágil de software epub r1.1 xcuidi 21.03.2018 3título original: clean code: a handbook of agile software craftsmanship robert cecil martin, 2009 traducción: josé luis gómez celador ilustraciones: jeniffer kohnke & angela brooks editor digital: xcuidi colaborador: mario j. c. (pdf-español) epub base r1.2 este libro se ha maquetado siguiendo los estándares de calidad de www.epublibre.org. la página, y sus editores, no obtienen ningún tipo de beneficio económico por ello. si ha llegado a tu poder desde otra web debes saber que seguramente sus propietarios sí obtengan ingresos publicitarios mediante archivos como este 4para ann marie: el verdadero amor de mi vida. 5agradecimientos me gustaría dar las gracias a mis dos artistas, jeniffer kohnke y angela brooks. jennifer es la encargada de las impresionantes ilustraciones del inicio de cada capítulo y también de los retratos de kent beck, ward cunningham, bjarne stroustrup, ron jeffries, grady booch, dave thomas, michael feathers y el mío propio. angela se encarga de las ilustraciones internas de los capítulos. ha realizado muchos dibujos para mí en los últimos años, incluidos muchos de los del libro agile software development: principles, patterns, and practices . también es mi primogénita. un agradecimiento especial a los revisores bob bogetti, george bullock, jeffrey overbey y especialmente matt heusser. han sido increíbles. han sido inmisericordes. han sido minuciosos. me han forzado al máximo para realizar las mejoras necesarias. gracias a mi editor, chris guzikowski, por su apoyo, aliento y amistad. gracias a todo el personal de la editorial, incluida raina chrobak, que se encargó de que fuera honesto y cumpliera los plazos. gracias a micah martin y a todos los de 8th light (www.8thlight.com) por sus críticas y su apoyo. gracias a todos los object mentor, pasados, presentes y futuros, incluidos bob koss, michael feathers, michael hill, erik meade, jeff langr, pascal roy, david farber, brett schuchert, dean wampler, tim ottinger, dave thomas, james grenning, brian button, ron jeffries, lowell lindstrom, angelique martin, cindy sprague, libby ottinger, joleen craig, janice 6brown, susan rosso y el resto. gracias jim newkirk, mi amigo y socio, que me ha enseñado más de lo que cree. mi agradecimiento a kent beck, martin fowler, ward cunningham, bjarne stroustrup, grady booch y todos mis mentores, compatriotas y colegas. gracias a john vlissides por estar ahí cuando lo necesitaba. gracias a todos los de zebra por permitirme despotricar sobre la extensión que debe tener una función. y, por último, darle las gracias por leer estos agradecimientos. 7prólogo una de nuestras golosinas preferidas en dinamarca es ga-jol , con un fuerte sabor a regaliz, que constituye un complemento perfecto para nuestro húmedo y frío clima. parte del encanto de ga-jol para los daneses es la frase que suele incluir en el envoltorio. esta mañana compré un paquete de dos y me encontré con este antiguo dicho danés: ærlighed i små ting er ikke nogen lille ting. «la honestidad por las cosas pequeñas no es algo menor». perfecto para que lo que pensaba escribir. las cosas pequeñas importan. este libro trata sobre humildes preocupaciones cuyo valor dista mucho de ser menor. 8dios está en los detalles , afirmó el arquitecto ludwig mies van der rohe. esta cita recuerda argumentos contemporáneos sobre el papel de la arquitectura en el desarrollo de software , en especial en el universo ágil. bob y yo hemos tenido esta conversación muchas veces. y sí, mies van der rohe se fijaba en la utilidad y la forma atemporal de la construcción que subyace a las grandes creaciones arquitectónicas. por otra parte, seleccionaba personalmente los pomos de todas las puertas de todas las casas que diseñaba. ¿por qué? porque las cosas pequeñas importan. en nuestro interminable debate sobre tdd, bob y yo coincidimos en que la arquitectura del software desempeña una importante labor en el desarrollo, aunque tenemos diferentes visiones de lo que esto significa. estas diferencias carecen de importancia, ya que podemos aceptar que los profesionales responsables dedican parte de su tiempo a planificar un proyecto antes de comenzarlo. las nociones de diseño controlado únicamente por pruebas y el código, propias de finales de la década de 1990, ya no son válidas. y la atención al detalle es un pilar fundamental de los profesionales, casi como cualquier visión. por un lado, la práctica en los detalles otorga dominio a los profesionales, y aumenta su confianza para la práctica a mayor escala. por otra parte, el más mínimo fallo de construcción, una puerta que no cierre bien o un baldosín mal colocado, acaba con el encanto del todo. de eso se trata el código limpio. pero la arquitectura es sólo una metáfora del desarrollo de software y en concreto de la parte del software que ofrece el producto inicial, de la misma forma que un arquitecto entrega un edificio inmaculado. hoy en día, el objetivo es comercializar rápidamente los productos. queremos que las fábricas produzcan software a pleno rendimiento. se trata de fábricas humanas, programadores que piensan, que sienten y que trabajan para crear un producto. la metáfora de la manufacturación es incluso más evidente en este pensamiento. los aspectos productivos de las fábricas de automóviles japonesas fueron una gran inspiración para serum. pero incluso en la industria automovilística, gran parte del trabajo no radica en la fabricación sino en el mantenimiento, o más bien en cómo evitarlo. en el software , el 80 por 100 o más de lo que hacemos se denomina cuantitativamente mantenimiento, el acto de reparar. en lugar de optar por la 9típica costumbre occidental de crear software de calidad, debemos pensar como reparadores o mecánicos. ¿qué piensan los directores japoneses de todo esto? en 1951, un enfoque de calidad denominado tpm ( total productive maintenance o mantenimiento productivo total) apareció en escena. se centraba en el mantenimiento y no en la producción. uno de los pilares de tpm es el conjunto de principios denominados 5s, una serie de disciplinas. estos principios 5s son en realidad la base lean, otro conocido término en la escena occidental, y cada vez más presente en el mundo del software . estos principios no son opcionales. como indica uncle bob, la práctica del software correcto requiere disciplina. no siempre se trata de hacer, de producir a la velocidad óptima. la filosofía 5s incluye estos conceptos: seiri u organización : es fundamental saber dónde están las cosas, mediante enfoques como el uso de nombres correctos. ¿cree que los nombres de los identificadores no son relevantes? lea los siguientes capítulos. seiton o sistematización : existe un antiguo dicho norteamericano: un sitio para cada cosa y cada cosa en su sitio. un fragmento de código debe estar donde esperamos encontrarlo; en caso contrario, refactorice hasta conseguirlo. seiso o limpieza : mantenga limpio el lugar de trabajo. ¿qué dicen los autores sobre inundar el código de comentarios y líneas que capturan historias o deseos futuros? elimínelos. seiketsu o estandarización : el grupo decide cómo mantener limpio el lugar de trabajo. ¿cree que este libro habla sobre tener un estilo de código coherente y una serie de prácticas dentro del grupo? ¿de dónde provienen esos estándares? siga leyendo. shutsuke o disciplina : significa ser disciplinado en la aplicación de las prácticas y reflejarlas en el trabajo y aceptar los cambios. si acepta el reto, ha leído bien, el reto, de leer y llevar a la práctica este libro, podrá comprender y apreciar el último punto. aquí nos acercamos a la 10raíz de la profesionalidad responsable de una profesión que debería preocuparse del ciclo vital de un producto. al igual que mantenemos coches y otras máquinas, el mantenimiento divisible, esperar a que surjan los errores, es la excepción. por el contrario, ascendemos un nivel: inspeccionamos diariamente las máquinas y arreglamos los componentes gastados antes de que se rompan, o cambiamos el aceite cada varios miles de kilómetros para evitar problemas. en el código, debemos refactorizar sin compasión. puede ascender otro nivel más, como hizo el movimiento tpm hace 50 años: crear máquinas que se pueden mantener mejor. crear código legible es tan importante como crear código ejecutable. la práctica definitiva, que apareció en los círculos tpm en 1960, es la que se centra en introducir nuevas máquinas o sustituir las antiguas. como fred brooks nos advirtió, deberíamos rehacer el software cada siete años para eliminar los problemas latentes. tendríamos que actualizar este plazo por semanas, días e incluso horas en lugar de años. ahí es donde se encuentra el detalle. el detalle tiene un gran poder, y es un enfoque vital humilde y profundo, como es de esperar de cualquier enfoque de origen japonés. pero no es sólo la visión oriental de la vida; también lo encontramos en el pueblo norteamericano. la cita seiton anterior proviene de la pluma de un ministro de ohio que, literalmente, consideraba la limpieza como un remedio para todas las formas del mal. ¿y seiso ? la limpieza es la pureza . aunque una casa sea bella, el mobiliario inadecuado acaba con su encanto. ¿y la opinión de shutsuke al respecto? el que confíe en lo pequeño confiará en lo superior . ¿y la predisposición a refactorizar en el momento adecuado, reforzando nuestra posición para las posteriores grandes decisiones, en lugar de dejarlo pasar? una puntada a tiempo ahorra ciento. al que madruga, dios le ayuda. no dejes para mañana lo que puedas hacer hoy (éste era el sentido original de la frase «en el momento adecuado» de lean hasta que cayó en manos de consultores de software ). ¿y sobre calibrar la importancia de los pequeños esfuerzos individuales en un todo mayor? de pequeñas semillas crecen grandes árboles . ¿y la integración de sencillas tareas preventivas en la vida diaria? más vale prevenir que curar . el código limpio honra las raíces de la sabiduría popular, de antes o de ahora, y se puede aplicar con atención al detalle. 11incluso en la literatura arquitectónica encontramos ejemplos de estos detalles. piense en los pomos de mies van der rohe. eso es seiri . es la atención a todos los nombres de variables. debe bautizar a una variable con el mismo cuidado como si fuera su primogénito. y como todo sabemos, este cuidado no acaba nunca. el arquitecto christopher alexander, padre de patrones y lenguajes de patrones, considera todo acto de diseño como un pequeño acto local de reparación, y considera la maestría de la estructura como competencia única del arquitecto; las formas mayores se ceden a los patrones y su aplicación a los habitantes. el diseño es interminable no sólo al añadir una nueva habitación a una casa, sino al prestar atención a la pintura, a cambiar las alfombras o a instalar un nuevo fregadero en la cocina. otras artes muestran sentimientos análogos. en nuestra búsqueda por la importancia de los detalles, nos topamos con el autor francés del siglo xix gustav flaubert. el poeta francés paul valery afirma que un poema no se acaba nunca y que tiene que retocarse continuamente, y que dejar de trabajar en el poema es señal de abandono. tal preocupación por el detalle es común en todas las empresas de excelencia. puede que esto no sea nada nuevo, pero al leer este libro sentirá la necesidad de adoptar disciplinas rechazadas en su momento por apatía o por un deseo de espontaneidad o una simple respuesta al cambio. desafortunadamente, no solemos considerar estas preocupaciones la clave del arte de la programación. renunciamos pronto a nuestro código, no porque lo hayamos completado, sino porque nuestro sistema de valores se centra en el futuro más que en la sustancia de nuestros productos. esto tiene un precio final: hierba mala nunca muere . la investigación, ni en el mundo industrial ni en el académico, se reduce a mantener limpio el código. cuando trabajaba en la organización bell labs software production research (sin duda de producción) comprobamos que un estilo de sangrado coherente era uno de los mayores indicadores estadísticamente significativos de una baja densidad de errores. queremos que una arquitectura, un lenguaje de programación u otra noción superior sea el motivo de la calidad; como seres cuya supuesta profesionalidad se debe al dominio de herramientas y métodos de diseño, nos sentimos insultados por el valor que los programadores añaden con tan sólo aplicar un estilo de sangrado coherente. 12para citar mi propio libro de hace 17 años, dicho estilo distingue la excelencia de la simple competencia. la visión japonesa comprende el verdadero valor del trabajador cotidiano y, en especial, de los sistemas de desarrollo que dependen de las sencillas acciones diarias de tales trabajadores. la calidad es el resultado de un millón de acciones cuidadosas, no de un método magnífico caído del cielo. que dichas acciones sean simples no significa que sean simplistas, y mucho menos que sean sencillas. son la base de la grandeza y, cada vez más, de cualquier empresa humana. ignorarlas no es humano en absoluto. evidentemente, todavía defiendo el pensamiento global, en especial el valor de los enfoques arquitectónicos cimentados en el conocimiento de los dominios y la capacidad de uso del software . este libro no versa sobre esto, al menos no de forma evidente. este libro transmite un mensaje más sutil cuya profundidad no debe menospreciarse. coincide con la visión de gente como peter sommerlad, kevlin henney y giovanni asproni, cuyos mantras son «el código es el diseño» y «código simple». aunque debemos recordar que la interfaz es el programa y que sus estructuras dicen mucho sobre la propia estructura del programa, es fundamental adoptar de forma continuada la humilde posición de que el diseño vive en el código. y aunque los cambios y la metáfora de la fábrica supongan costes, los cambios de diseño suponen valor. debemos considerar al código como la articulación de los esfuerzos de diseño, visto como un proceso, no como algo estático. es en el código donde se desarrollan los conceptos arquitectónicos de conexión y cohesión. si escucha a larry constantine describir la conexión y la cohesión, lo hace en términos del código, no desde conceptos abstractos propios de uml. en su ensayo abstraction descant , richard gabriel afirma que la abstracción es el mal. el código es el remedio al mal y el código limpio puede que sea divino. volviendo a mi caja de ga-jol , considero importante recordar que la sabiduría danesa nos recomienda no sólo prestar atención a las pequeñas cosas, sino también ser honestos con ellas. esto significa ser honesto con el código, con nuestros colegas sobre el estado del código y, en especial, con nosotros mismos. ¿hemos hecho todo lo posible para dejar las cosas mejor que como las encontramos? ¿hemos refactorizado el código antes de terminarlo? no se trata de preocupaciones periféricas, sino que se encuentran 13en la base misma de los valores agile. en serum se recomienda que la refactorización sea parte del concepto de terminado. ni la arquitectura ni el código limpio insisten en la perfección, sino en la honestidad y en hacerlo lo mejor posible. errar es humano; perdonar es divino . en serum, todo lo hacemos de forma visible. aireamos los trapos sucios. somos honestos sobre el estado de nuestro código ya que nunca es perfecto. nos hemos hecho más humanos, más merecedores de lo divino y estamos más próximos a la grandeza de los detalles. en nuestra profesión, necesitamos desesperadamente toda la ayuda posible. si un suelo seco reduce el riesgo de resbalones y las herramientas bien organizadas aumentan la productividad, es nuestra meta. y en cuanto al libro, es la mejor aplicación pragmática de los principios lean de software que he visto nunca en formato impreso. no esperaba menos de este grupo de individuos que durante años se han esforzado no sólo por mejorar sino en ofrecer sus conocimientos a la industria mediante obras como la que ahora tiene entre manos. hace que el mundo sea un poco mejor que antes de que uncle bob me enviara el manuscrito. y tras completar este ejercicio, me dispongo a limpiar mi escritorio. james o. coplien mørdrup, dinamarca 14introducción reproducido con permiso de thom holwerda. http://www.osnews.com/story/19266/wtfs_m. © 2008 focus shift. ¿qué puerta representa su código? ¿qué puerta representa a su equipo o a su 15empresa? ¿por qué estamos en esa habitación? ¿es una sencilla revisión del código o hemos detectado un sinfín de problemas terribles? ¿depuramos presas del pánico el código que pensábamos que funcionaba? ¿los clientes huyen despavoridos y los directores nos pisan los talones? ¿cómo asegurarnos de que abrimos la puerta correcta cuando las cosas se ponen feas? la respuesta: la maestría . la maestría se consigue de dos formas: conocimientos y trabajo. debe adquirir el conocimiento de los principios, patrones, prácticas y heurística propios de un maestro, y dominar dichos conocimientos a través de la práctica. puedo enseñarle la teoría de montar en bicicleta. de hecho, los conceptos matemáticos clásicos son muy sencillos. gravedad, fricción, velocidad angular, centro de masa, etc., se pueden demostrar en menos de una página repleta de ecuaciones. con esas fórmulas, puedo demostrar que montar en bicicleta es práctico y proporcionarle los conocimientos necesarios para conseguirlo. pero la primera vez que se monte en una bici se caerá al suelo. el diseño de código no es diferente. podríamos enumerar todos los principios del código limpio y confiar en que se encargue del resto (es decir, dejar que se cayera de la bici) pero entonces la pregunta sería qué clase de profesores somos y qué clase de alumno sería. no. así no funciona este libro. aprender a crear código limpio es complicado . requiere algo más que conocer principios y patrones. tiene que sudar. debe practicarlo y fallar. debe ver cómo otros practican y fallan. debe observar cómo se caen y recuperan el paso. debe ver cómo agonizan en cada decisión y el precio que pagan por tomar decisiones equivocadas. para leer este libro, prepárese a trabajar duro. no es un libro que se pueda leer en un avión y terminarlo antes de aterrizar. este libro le hará trabajar, y mucho. ¿y qué tipo de trabajo? tendrá que leer código, en abundancia. y se le pedirá que piense en qué acierta el código y en qué falla. se le pedirá que siga nuestras descripciones mientras despedazamos módulos y los volvemos a ensamblar. para ello necesitará tiempo y esfuerzo, pero creemos que merece la pena. hemos dividido el libro en tres partes. los primeros capítulos describen 16los principios, patrones y prácticas para crear código limpio. incluyen abundante código y resultan difíciles de leer. sirven como preparación a la segunda parte. si abandona tras leer la primera sección, que tenga buena suerte. la segunda parte del libro es la más difícil. incluye varios casos de estudio cuya complejidad va aumentando. cada ejemplo es un ejercicio de limpieza de código, transformar código con problemas para que tenga menos problemas. el detalle de esta parte es abundante . tendrá que alternar entre el texto y los listados de código. tendrá que analizar y entender el código, y comprender el razonamiento de cada cambio realizado. piense en que esta parte le llevará varios días . la tercera parte del libro es un único capítulo que contiene una lista de heurística y síntomas de código erróneo ( smells ) confeccionada al crear los casos prácticos. al analizar y limpiar el código de los ejemplos, documentamos el motivo de todas nuestras acciones como heurística o síntoma. intentamos comprender nuestras reacciones al código que leíamos y modificábamos, y nos esforzamos por capturar las sensaciones que tuvimos y las decisiones que adoptamos. el resultado es una base de conocimientos que describe cómo pensamos cuando creamos, leemos y limpiamos código. esta base de conocimientos no le servirá de mucho si no lee atentamente los casos de la segunda parte del libro. en esos capítulos hemos anotado con precisión todos los cambios realizados con referencias a la heurística. estas referencias se muestran entre corchetes, como [h22]. de este modo puede ver el contexto en el que se ha aplicado y creado dicha heurística. no importa tanto el propio valor de las heurísticas sino la relación entre ellas y las decisiones adoptadas al limpiar el código en los ejemplos . si lee la primera y la tercera parte y se salta los casos prácticos, habrá leído otro libro distinto sobre cómo crear código correcto, pero si dedica tiempo a analizar los casos, sigue todos y cada uno de los pasos, cada una de las decisiones, si se pone en nuestro lugar y se obliga a pensar tal y como lo hicimos nosotros, entonces comprenderá mucho mejor todos los principios, patrones, prácticas y heurística. ya no será un conocimiento superficial. se convertirá en algo profundo. lo integrará de la misma forma que una bicicleta se convierte en una extensión propia una vez dominada la forma de 17montar. 18sobre la imagen de cubierta la imagen de la portada es m104: la galaxia del sombrero. m104 se encuentra en virgo, a unos 30 millones de años luz, y su núcleo es un súper agujero negro que pesa aproximadamente mil millones de masas solares. ¿la imagen le recuerda la explosión de la luna praxis de klingon? recuerdo la escena de star trek vi en la que se mostraba un anillo de restos flotando tras la explosión. tras esa escena, el anillo se ha convertido en un elemento habitual de las explosiones de ciencia ficción. incluso se añadió a la explosión de alderaan en ediciones posteriores de la primera película de la guerra de las galaxias. ¿qué provocó la formación de este anillo alrededor de m104? ¿por qué tiene un centro de tales dimensiones y un núcleo tan brillante y diminuto? parece como si el agujero negro central hubiera provocado un orificio de 30 000 años luz en el centro de la galaxia. la desgracia caería sobre las civilizaciones que se encontraran en el camino de este desastre cósmico. los súper agujeros negros desayunan estrellas y convierten parte de su masa en energía. e=mc 2 puede bastar, pero cuando m es una masa estelar hay que tener cuidado. ¿cuántas estrellas habrá engullido este monstruo antes de saciar su apetito? el tamaño del vacío central podría ser una pista. la imagen de m104 de la portada es una combinación de la famosa fotografía del hubble (imagen superior) y la reciente imagen de infrarrojos del observatorio orbital spitzer (inferior). esta última muestra claramente la forma de anillo de la galaxia. a la luz, sólo vemos el borde frontal de la silueta del anillo. 19imagen de portada: © spitzet space telescope. la masa central oculta el resto. pero en la imagen de infrarrojos, las partículas calientes del anillo brillan a través de la masa central. las dos imágenes combinadas nos ofrecen una vista desconocida hasta ahora e implican que hace tiempo era un auténtico infierno activo. 201 código limpio está leyendo este libro por dos motivos. por un lado, es programador. por otro, quiere ser mejor programador. perfecto. necesitamos mejores 21programadores. este libro trata sobre programación correcta. está repleto de código. lo analizaremos desde todas las direcciones. desde arriba, desde abajo y desde dentro. cuando terminemos, sabremos mucho sobre código y, en especial sabremos distinguir entre código correcto e incorrecto. sabremos cómo escribir código correcto y cómo transformar código incorrecto en código correcto. hágase el código se podría afirmar que un libro sobre código es algo obsoleto, que el código ya no es el problema y que deberíamos centrarnos en modelos y requisitos. hay quienes sugieren que el final del código está próximo. que los programadores ya no serán necesarios porque los empresarios generarán programas a partir de especificaciones. no es cierto. el código nunca desaparecerá, ya que representa los detalles de los requisitos. en algún nivel, dichos detalles no se pueden ignorar ni abstraer; deben especificarse, y para especificar requisitos de forma que un equipo pueda ejecutarlos se necesita la programación. dicha especificación es el código. espero que el nivel de abstracción de nuestros lenguajes siga aumentando. también espero que aumente el número de lenguajes específicos de dominios. será algo positivo, pero no eliminará el código. de hecho, todas las especificaciones creadas en estos lenguajes de nivel superior y específicos de los dominios serán código, y tendrá que ser riguroso, preciso, formal y detallado para que un equipo pueda entenderlo y ejecutarlo. el que piense que el código va a desaparecer es como el matemático que espera que un día las matemáticas no sean formales. esperan descubrir una forma de crear máquinas que hagan lo que queramos en lugar de lo que digamos. esas máquinas tendrían que entendernos de tal forma que puedan traducir necesidades ambiguas en programas perfectamente ejecutados que satisfagan dichas necesidades a la perfección. esto nunca sucederá. ni siquiera los humanos, con toda su intuición y 22creatividad, han sido capaces de crear sistemas satisfactorios a partir de las sensaciones de sus clientes. en realidad, si la disciplina de la especificación de requisitos nos ha enseñado algo es que los requisitos bien especificados son tan formales como el código y que pueden actuar como pruebas ejecutables de dicho código. recuerde que el código es básicamente el lenguaje en el que expresamos los requisitos en última instancia. podemos crear lenguajes que se asemejen a dichos requisitos. podemos crear herramientas que nos permitan analizar y combinar dichos requisitos en estructuras formales, pero nunca eliminaremos la precisión necesaria; por ello, siempre habrá código. código incorrecto recientemente leí el prólogo del libro implementation pattern [1] de kent beck, donde afirmaba que «…este libro se basa en una frágil premisa: que el código correcto es relevante…». ¿una frágil premisa? en absoluto. considero que es una de las más robustas, admitidas e importantes de nuestro sector (y creo que kent lo sabe). sabemos que el código correcto es relevante porque durante mucho tiempo hemos tenido que sufrir su ausencia. sé de una empresa que, a finales de la década de 1980, creó una magnífica aplicación, muy popular y que muchos profesionales compraron y utilizaron. pero los ciclos de publicación empezaron a distanciarse. no se corrigieron los errores entre una versión y la siguiente. crecieron los tiempos de carga y aumentaron los fallos. todavía recuerdo el día en que apagué el producto y nunca más lo volví a usar. poco después, la empresa desapareció. 23dos décadas después conocí a uno de los empleados de la empresa y le pregunté sobre lo que había pasado. la respuesta confirmó mis temores. habían comercializado el producto antes de tiempo con graves fallos en el código. al añadir nuevas funciones, el código empeoró hasta que ya no pudieron controlarlo. el código incorrecto fue el motivo del fin de la empresa . ¿en alguna ocasión el código incorrecto le ha supuesto un obstáculo? si es programador seguramente sí. de hecho, tenemos una palabra que lo describe: sortear . tenemos que sortear el código incorrecto. nos arrastramos por una maraña de zarzas y trampas ocultas. intentamos buscar el camino, una pista de lo que está pasando, pero lo único que vemos es más y más código sin sentido. sin duda el código incorrecto le ha supuesto un obstáculo. entonces, ¿por qué lo escribió? ¿tenía prisa? ¿plazos de entrega? seguramente. puede que pensara que no tenía tiempo para hacer un buen trabajo; que su jefe se enfadaría si necesitaba tiempo para limpiar su código. o puede que estuviera cansado de trabajar en ese programa y quisiera acabar cuanto antes. o que viera el trabajo pendiente y tuviera que acabar con un módulo para pasar al siguiente. a todos nos ha pasado. todos hemos visto el lío en el que estábamos y hemos optado por dejarlo para otro día. todos hemos sentido el alivio de ver cómo un programa incorrecto funcionaba y hemos decidido que un mal programa que funciona es mejor que nada. todos hemos dicho que lo solucionaríamos después. evidentemente, por aquel entonces, no conocíamos la ley de leblanc: después es igual a nunca . el coste total de un desastre si es programador desde hace dos o tres años, probablemente haya sufrido los desastres cometidos por otros en el código. si tiene más experiencia, lo habrá sufrido en mayor medida. el grado de sufrimiento puede ser significativo. en un periodo de un año o dos, los equipos que avancen rápidamente al inicio de 24un proyecto pueden acabar a paso de tortuga. cada cambio en el código afecta a dos o tres partes del mismo. ningún cambio es trivial. para ampliar o modificar el sistema es necesario comprender todos los detalles, efectos y consecuencias, para de ese modo poder añadir nuevos detalles, efectos y consecuencias. con el tiempo, el desastre aumenta de tal modo que no se puede remediar. es imposible. al aumentar este desastre, la productividad del equipo disminuye y acaba por desaparecer. al reducirse la productividad, el director hace lo único que puede: ampliar la plantilla del proyecto con la esperanza de aumentar la productividad. pero esa nueva plantilla no conoce el diseño del sistema. no conocen la diferencia entre un cambio adecuado al objetivo de diseño y otro que lo destroce. por tanto, todos se encuentran sometidos a una gran presión para aumentar la productividad. por ello, cometen más errores, aumenta el desastre y la productividad se acerca a cero cada vez más (véase la figura 1.1). figura 1.1. productividad frente a tiempo. el gran cambio de diseño en última instancia, el equipo se rebela. informan al director que no pueden seguir trabajando con ese código. exigen un cambio de diseño. la dirección no requiere invertir en un cambio de diseño del proyecto, pero no puede ignorar el bajo nivel de productividad. 25acaba por ceder a las exigencias de los programadores y autoriza el gran cambio de diseño. se selecciona un nuevo equipo. todos quieren formar parte del nuevo equipo por ser un lienzo en blanco. pueden empezar de cero y crear algo realmente bello, pero sólo los mejores serán elegidos para el nuevo equipo. los demás deben continuar con el mantenimiento del sistema actual. ahora los dos equipos compiten. el nuevo debe crear un sistema que haga lo que el antiguo no puede. además, deben asumir los cambios que continuamente se aplican al sistema antiguo. la dirección no sustituirá el sistema antiguo hasta que el nuevo sea capaz de hacer todo lo que hace el antiguo. esta competición puede durar mucho tiempo. conozco casos de casi 10 años. y cuando acaba, los miembros originales del equipo nuevo han desaparecido y los miembros actuales exigen un cambio de diseño del nuevo sistema porque es un desastre. si ha experimentado alguna fase de esta historia, ya sabrá que dedicar tiempo a que el código sea correcto no sólo es rentable, es una cuestión de supervivencia profesional. actitud ¿alguna vez ha tenido que superar un desastre tan grave que ha tardado semanas en lo que normalmente hubiera tardado horas? ¿ha visto un cambio que debería haberse realizado en una línea, aplicado en cientos de módulos distintos? son síntomas demasiado habituales. ¿por qué sucede en el código? ¿por qué el código de calidad se transforma tan rápidamente en código incorrecto? hay muchas explicaciones. nos quejamos de que los requisitos cambian de forma que comprometen el diseño original, de que los plazos de entrega son demasiado exigentes para hacer las cosas bien. culpamos a directores incompetentes, a usuarios intolerantes y a comerciales sin sentido. pero la culpa, querido dilbert, es nuestra. no somos profesionales. puede que resulte duro escucharlo. ¿cómo es posible que seamos responsables de tales desastres? ¿qué pasa con los requisitos? ¿y los plazos de entrega? ¿y los directores incompetentes y los comerciales sin sentido? 26¿no es también culpa suya? no. los directores y los comerciales nos exigen la información que necesitan para realizar sus promesas y compromisos, e incluso cuando no recurren a nosotros, no debemos tener miedo a decirles lo que pensamos. los usuarios acuden a nosotros para validar la forma de encajar los requisitos en el sistema. los directores de proyectos acuden a nosotros para determinar los objetivos. somos cómplices en la programación del proyecto y compartimos gran parte de la responsabilidad de los fallos, en especial si tienen que ver con código incorrecto. seguramente piense que, si no hace lo que su jefe le dice, le despedirán. es improbable. muchos jefes sólo quieren la verdad, aunque lo disimulen. muchos quieren código correcto, aunque estén obsesionados con los objetivos. pueden defender apasionadamente los objetivos y los requisitos, pero es su trabajo. el nuestro es defender el código con la misma intensidad. para resumir, imagine que es médico y un paciente le exige que no se lave las manos antes de una operación porque se pierde demasiado tiempo [2] . en este caso, el paciente es el jefe, pero el médico debe negarse a lo que pide. ¿por qué? porque el médico sabe más que el paciente sobre los riesgos de infecciones. no sería profesional (incluso sería ilegal) que el médico cediera a las exigencias del paciente. tampoco sería profesional que los programadores cedieran a la voluntad de los jefes que no entienden los riesgos de un posible desastre. el enigma los programadores se enfrentan a un enigma de valores básicos. los que tienen años de experiencia saben que un desastre ralentiza su trabajo, y aun así todos los programadores sienten la presión de cometer errores para poder cumplir los plazos de entrega. en definitiva, no toman el tiempo necesario para avanzar. los verdaderos profesionales saben que la segunda parte del enigma no es cierta. no se cumple un plazo de entrega cometiendo un error. de hecho, el error nos ralentiza de forma inmediata y hace que no lleguemos al plazo de entrega. la única forma de cumplirlo, la única forma de avanzar, es intentar 27que el código siempre sea limpio. ¿el arte del código limpio? imagine que cree que el código incorrecto es un obstáculo significativo. imagine que acepta que la única forma de avanzar es mantener el código limpio. entonces se preguntará cómo crear código limpio. no tiene sentido intentar crearlo si no sabe lo que es. la mala noticia es que crear código limpio es como pintar un cuadro. muchos sabemos si un cuadro se ha pintado bien o no, pero poder reconocer la calidad de una obra no significa que sepamos pintar. por ello, reconocer código limpio no significa que sepamos cómo crearlo. para crearlo se requiere el uso disciplinado de miles de técnicas aplicadas mediante un detallado sentido de la «corrección». este sentido del código es la clave. algunos nacen con este sentido. otros han de luchar para conseguirlo. no sólo permite distinguir entre código correcto e incorrecto, sino que también muestra la estrategia para aplicar nuestra disciplina y transformar código incorrecto en código correcto. un programador sin este sentido puede reconocer el desastre cometido en un módulo, pero no saber cómo solucionarlo. un programador con este sentido verá las posibles opciones y elegirá la variante óptima para definir una secuencia de cambios. en definitiva, un programador que cree código limpio es un artista que puede transformar un lienzo en blanco en un sistema de código elegante. concepto de código limpio existen tantas definiciones como programadores. por ello, he consultado la opinión de conocidos y experimentados programadores. bjarne stroustrup, inventor de c++ y autor de the c++ programming language 28me gusta que mi código sea elegante y eficaz. la lógica debe ser directa para evitar errores ocultos, las dependencias deben ser mínimas para facilitar el mantenimiento, el procesamiento de errores completo y sujeto a una estrategia articulada, y el rendimiento debe ser óptimo para que los usuarios no tiendan a estropear el código con optimizaciones sin sentido. el código limpio hace bien una cosa. bjarne usa la palabra «elegante». menuda palabra. según el diccionario, «elegante» significa « dotado de gracia, nobleza y sencillez ». aparentemente bjarne piensa que el código limpio es un placer a la hora de leerlo. su lectura debe hacernos sonreír, como una caja de música o un coche bien diseñado. bjarne también menciona la eficacia, en dos ocasiones . no debería sorprendemos viniendo del inventor de c++; pero considero que hay algo más que el mero deseo de velocidad. los ciclos malgastados no son elegantes, no son un placer. y fíjese en la palabra empleada por bjarne para describir la consecuencia de esta falta de elegancia. usa tiendan . una gran verdad. el código incorrecto tiende a aumentar el desastre. cuando otros cambian código incorrecto, tienden a empeorarlo. dave thomas y andy hunt lo expresan de forma diferente. usan la metáfora de las ventanas rotas [3] . un edificio con ventanas rotas parece abandonado. y hace que otros lo abandonen. dejan que se rompan otras ventanas. e incluso las rompen a propósito. la fachada se ensucia con pintadas y se acumula la basura. una ventana rota inicia el proceso de la decadencia. bjarne también menciona que el procesamiento de errores debe ser completo, lo que se relaciona con la disciplina de prestar atención a los detalles. el procesamiento de errores abreviado es una forma de ignorar los detalles. otras son las fugas de memoria, las condiciones de carrera o el uso 29incoherente de los nombres. en definitiva, el código limpio muestra gran atención al detalle. bjarne termina afirmando que el código limpio hace una cosa bien . no es accidental que existan tantos principios de diseño de software que se puedan reducir a esta sencilla máxima. muchos escritores han tratado de comunicar este pensamiento. el código incorrecto intenta hacer demasiadas cosas y su cometido es ambiguo y enrevesado. el código limpio es concreto . cada función, cada clase y cada módulo muestran una única actitud que se mantiene invariable y no se contamina por los detalles circundantes. grady booch, autor de object oriented analysis and design with applications el código limpio es simple y directo. el código limpio se lee como un texto bien escrito. el código limpio no oculta la intención del diseñador, sino que muestra nítidas abstracciones y líneas directas de control. grady mantiene las mismas ideas que bjarne, pero adopta una perspectiva de legibilidad . me gusta especialmente que el código limpio se pueda leer como un texto bien escrito. piense en un buen libro. recordará que las palabras desaparecen y se sustituyen por imágenes, como ver una película. mejor todavía. es ver los caracteres, escuchar los sonidos, experimentar las sensaciones. leer código limpio nunca será como leer el señor de los anillos . pero esta metáfora literaria no es incorrecta. como una buena novela, el código limpio debe mostrar de forma clara el suspense del problema que hay que resolver. debe llevar ese suspense hasta un punto álgido para después demostrar al lector que los problemas y el suspense se han solucionado de forma evidente. 30la frase «nítida abstracción» de grady es un oxímoron fascinante. nítido es casi un sinónimo de concreto, con un potente mensaje. el código debe ser específico y no especulativo. sólo debe incluir lo necesario. nuestros lectores deben percibir que hemos tomado decisiones. «big» dave thomas, fundador de oti, el padrino de la estrategia eclipse el código limpio se puede leer y mejorar por parte de un programador que no sea su autor original. tiene pruebas de unidad y de aceptación. tiene nombres con sentido. ofrece una y no varias formas de hacer algo. sus dependencias son mínimas, se definen de forma explícita y ofrece una api clara y mínima. el código debe ser culto en función del lenguaje, ya que no toda la información necesaria se puede expresar de forma clara en el código. big dave comparte el deseo de grady de la legibilidad, pero con una importante variante. dave afirma que el código limpio facilita las labores de mejora de otros . puede parecer evidente pero no debemos excedernos. después de todo, existe una diferencia entre el código fácil de leer y el código fácil de cambiar. dave vincula la limpieza a las pruebas. hace 10 años esto hubiera provocado cierta controversia. pero la disciplina del desarrollo controlado por pruebas ha tenido un gran impacto en nuestro sector y se ha convertido en uno de sus pilares. dave tiene razón. el código, sin pruebas, no es limpio. independientemente de su elegancia, legibilidad y accesibilidad, si no tiene pruebas, no será limpio. dave usa dos veces la palabra mínimo . valora el código de tamaño 31reducido, una opinión habitual en la literatura de software desde su concepción. cuanto más pequeño, mejor. también afirma que el código debe ser culto , una referencia indirecta a la programación de knuth [4] y que en definitiva indica que el código debe redactarse de una forma legible para los humanos. michael feathers, autor de working effectively with legacy code podría enumerar todas las cualidades del código limpio, pero hay una principal que engloba a todas ellas. el código limpio siempre parece que ha sido escrito por alguien a quien le importa. no hay nada evidente que hacer para mejorarlo. el autor del código pensó en todos los aspectos posibles y si intentamos imaginar alguna mejora, volvemos al punto de partida y sólo nos queda disfrutar del código que alguien a quien le importa realmente nos ha proporcionado. una palabra; dar importancia. es el verdadero tema de este libro, que incluso podría usar el subtítulo « cómo dar importancia al código ». michael ha acertado de pleno. el código limpio es aquél al que se le ha dado importancia. alguien ha dedicado su tiempo para que sea sencillo y ha prestado atención a los detalles. se ha preocupado. ron jeffries, autor de extreme programming installed y extreme programming adventures in c# 32ron comenzó su carrera como programador con fortran en strategic air command y ha escrito código para la práctica totalidad de lenguajes y equipos. merece la pena fijarse en sus palabras: en los últimos años, comencé y prácticamente terminé con las reglas de código simple de beck. en orden de prioridad, el código simple: ejecuta todas las pruebas. no contiene duplicados. expresa todos los conceptos de diseño del sistema. minimiza el número de entidades como clases, métodos, funciones y similares. de todos ellos, me quedo con la duplicación. cuando algo se repite una y otra vez, es una señal de que tenemos una idea que no acabamos de representar correctamente en el código. intento determinar cuál es y, después, expresar esa idea con mayor claridad. para mí, la expresividad debe incluir nombres con sentido y estoy dispuesto a cambiar los nombres de las cosas varias veces. con las modernas herramientas de creación de código como eclipse, el cambio de nombres es muy sencillo, por lo que no me supone problema alguno. la expresividad va más allá de los nombres. también me fijo si un objeto o un método hacen más de una cosa. si se trata de un objeto, probablemente tenga que dividirse en dos o más. si se trata de un método, siempre recurro a la refactorización de extracción de métodos para generar un método que exprese con mayor claridad su cometido y varios métodos secundarios que expliquen cómo lo hace. la duplicación y la expresividad son dos factores que permiten mejorar considerablemente código que no sea limpio. sin embargo, 33existe otra cosa que también hago conscientemente, aunque sea más difícil de explicar. tras años en este trabajo, creo que todos los programas están formados de elementos muy similares. un ejemplo es la búsqueda de elementos en una colección. independientemente de que sea una base de datos de registros de empleados o un mapa de claves y valores, o una matriz de elementos, por lo general tenemos que buscar un elemento concreto de esa colección. cuando esto sucede, suelo incluir esa implementación concreta en un método o una clase más abstractos. de ese modo disfruto de una serie de interesantes ventajas. puedo implementar la funcionalidad con algo sencillo, como un mapa hash, por ejemplo, pero como ahora todas las referencias a la búsqueda se ocultan en mi pequeña abstracción, puedo modificar la implementación siempre que desee. puedo avanzar rápidamente al tiempo que conservo la posibilidad de realizar cambios posteriores. además, la abstracción de la colección suele captar mi atención en lo que realmente sucede e impide que implemente comportamientos de colecciones arbitrarias si lo que realmente necesito es una forma sencilla de localizar un elemento. reducir los duplicados, maximizar la expresividad y diseñar sencillas abstracciones en las fases iniciales. para mí, es lo que hace que el código sea limpio. en estos breves párrafos, ron resume el contenido de este libro. nada de duplicados, un objetivo, expresividad y pequeñas abstracciones. todo está ahí. ward cunningham, inventor de wiki, fit, y uno de los inventores de la programación extreme. uno de los impulsores de los patrones de diseño. una de las mentes tras smalltalk y la programación orientada a objetos. el padrino de todos a los que les importa el código. 34sabemos que estamos trabajando con código limpio cuando cada rutina que leemos resulta ser lo que esperábamos. se puede denominar código atractivo cuando el código hace que parezca que el lenguaje se ha creado para el problema en cuestión. este tipo de afirmaciones son características de ward. las leemos, asentimos y pasamos a la siguiente. es tan razonable y evidente que apenas parece profundo. incluso podemos pensar que es lo que esperábamos. pero preste atención. «… resulta ser lo que esperábamos». ¿cuándo fue la última vez que vio un módulo que fuera más o menos lo que esperaba? ¿lo habitual no es ver módulos complicados y enrevesados? ¿no es esta falta de concreción lo habitual? ¿no está acostumbrado a intentar extraer el razonamiento de un sistema para llegar al módulo que está leyendo? ¿cuándo fue la última vez que leyó un código y asintió como seguramente haya hecho al leer la afirmación de ward? ward espera que al leer código limpio no le sorprenda. de hecho, ni siquiera tendrá que esforzarse. lo leerá y será prácticamente lo que esperaba. será evidente, sencillo y atractivo. cada módulo prepara el camino del siguiente. cada uno indica cómo se escribirá el siguiente. los programas limpios están tan bien escritos que ni siquiera se dará cuenta. el diseñador consigue simplificarlo todo enormemente, como sucede con todos los diseños excepcionales. ¿y la noción de atractivo de ward? todos hemos criticado que nuestros lenguajes no se hayan diseñado para nuestros problemas. pero la afirmación de ward hace que ahora la responsabilidad sea nuestra. afirma que el código atractivo hace que el lenguaje parezca creado para el problema . por tanto, somos responsables de que el lenguaje parezca sencillo. no es el lenguaje el que hace que los programas parezcan sencillos, sino el programador que consigue que el lenguaje lo parezca. 35escuelas de pensamiento ¿y yo (uncle bob)? ¿qué es para mí el código limpio? en este libro le contaremos, con todo detalle, lo que yo y mis colegas pensamos del código limpio. le contaremos lo que pensamos que hace que un nombre de variable, una función o una clase sean limpias. presentaremos estas opiniones de forma absoluta, sin disculparnos. en este punto de nuestra carrera, ya son absolutas. son nuestra escuela de pensamiento del código limpio. los especialistas de las artes marciales no se ponen de acuerdo sobre cuál es la mejor de todas, ni siquiera sobre cuál es la mejor técnica de un arte marcial. es habitual que los maestros de las artes marciales creen sus propias escuelas de pensamiento y los alumnos aprendan de ellos. de esta forma nació gracie jiu jitsu , creada e impartida por la familia gracie en brasil; hakkoryu jiu jitsu , fundada e impartida por okuyama ryuho en tokio o jeet kune do , fundada e impartida por bruce lee en estados unidos. los alumnos de estas disciplinas se sumergen en las enseñanzas del fundador. se dedican a aprender lo que su maestro les enseña y suelen excluir las enseñanzas de otros maestros. después, cuando han mejorado su arte, pueden convertirse en alumnos de otro maestro diferente para ampliar sus conocimientos y su experiencia. algunos seguirán mejorando sus habilidades, descubriendo nuevas técnicas y fundando sus propias escuelas. ninguna de estas escuelas tiene la razón absoluta pero dentro de cada una actuamos como si las enseñanzas y las técnicas fueran correctas. después de todo, existe una forma correcta de practicar hakkoryu jiu jitsu o jeet kune do, pero esta corrección dentro de una escuela determinada no anula las enseñanzas de otra diferente. 36imagine que este libro es una descripción de la escuela de mentores del código limpio . las técnicas y enseñanzas impartidas son la forma en la que practicamos nuestro arte. podemos afirmar que, si sigue nuestras enseñanzas, disfrutará de lo que hemos disfrutado nosotros, y aprenderá a crear código limpio y profesional. pero no cometa el error de pensar que somos los únicos que tenemos razón. existen otras escuelas y otros maestros tan profesionales como nosotros, y su labor es aprender de ellos también. de hecho, muchas de las recomendaciones del libro son controvertidas, seguramente no esté de acuerdo con muchas de ellas y puede que rechace algunas de forma definitiva. es correcto. no somos la autoridad final. pero, por otra parte, las recomendaciones del libro son algo en lo que hemos pensado mucho. las hemos aprendido tras décadas de experiencia y ensayo y error. por lo tanto, esté o no de acuerdo, sería una lástima que no apreciara, y respetara, nuestro punto de vista. somos autores el campo @author de un javadoc indica quiénes somos. somos autores. y los autores tienen lectores. de hecho, los autores son responsables de comunicarse correctamente con sus lectores. la próxima vez que escriba una línea de código, recuerde que es un autor y que escribe para que sus lectores juzguen su esfuerzo. seguramente se pregunte qué cantidad de código se lee realmente y si la mayor parte del esfuerzo no se concentra en crearlo. ¿alguna vez ha reproducido una sesión de edición? en las décadas de 1980 y 1990 teníamos editores como emacs que controlaban cada pulsación de tecla. se podía trabajar durante una hora y después reproducir la sesión de edición completa como una película a alta velocidad. cuando lo hice, los resultados fueron fascinantes. la mayor parte de la reproducción eran desplazamientos entre módulos. bob accede al módulo. se desplaza hasta la función que tiene que cambiar. 37se detiene y piensa en las posibles opciones. oh, vuelve al inicio del módulo para comprobar la inicialización de una variable. ahora vuelve a bajar y comienza a escribir. vaya, borra lo que había escrito. vuelve a escribirlo. lo vuelve a borrar. escribe algo diferente pero también lo borra. se desplaza a otra función que invoca la función que está modificando para comprobar cómo se invoca. vuelve a subir y escribe el mismo código que acaba de borrar. se detiene. vuelve a borrar el código. abre otra ventana y examina las subclases. ¿se ha reemplazado esa función? … se hace una idea. en realidad, la proporción entre tiempo dedicado a leer frente a tiempo dedicado a escribir es de más de 10:1. constantemente tenemos que leer código antiguo como parte del esfuerzo de crear código nuevo. al ser una proporción tan elevada, queremos que la lectura del código sea sencilla, aunque eso complique su creación. evidentemente, no se puede escribir código sin leerlo, de modo que si es más fácil de leer será más fácil de escribir . es una lógica sin escapatoria. no se puede escribir código si no se puede leer el código circundante. el código que intente escribir hoy será fácil o difícil de escribir en función de lo fácil o difícil de leer que sea el código circundante. si quiere avanzar rápidamente, terminar cuanto antes y que su código sea fácil de escribir, haga que sea fácil de leer. la regla del boy scout 38no basta con escribir código correctamente. el código debe limpiarse con el tiempo. todos hemos visto que el código se corrompe con el tiempo, de modo que debemos adoptar un papel activo para evitarlo. los boy scouts norteamericanos tienen una sencilla regla que podemos aplicar a nuestra profesión: dejar el campamento más limpio de lo que se ha encontrado [5] . si todos entregamos el código más limpio de lo que lo hemos recibido, no se corromperá. no hace falta que la limpieza sea masiva. cambie el nombre de una variable, divida una función demasiado extensa, elimine elementos duplicados, simplifique una instrucción if compuesta. ¿se imagina trabajar en un proyecto en el que el código mejorara con el tiempo? ¿cree que hay otras opciones que puedan considerarse profesionales? de hecho, ¿la mejora continuada no es una parte intrínseca de la profesionalidad? precuela y principios en muchos aspectos, este libro es una «precuela» de otro que escribí en 2002 titulado agile software development: principles, patterns, and practices (ppp). el libro ppp trata sobre los principios del diseño orientado a objetos y muchas de las técnicas empleadas por desarrolladores profesionales. si no ha leído ppp, comprobará que continúa la historia contada en este libro. si lo ha leído, encontrará muchas de las sensaciones de ese libro reproducidas en éste a nivel del código. en este libro encontrará referencias esporádicas a distintos principios de diseño como srp ( single responsibility principle o principio de responsabilidad única), ocp ( open closed principle o principio abierto/cerrado) y dip ( dependency inversion principle o principio de inversión de dependencias) entre otros. todos estos principios se describen detalladamente en ppp. 39conclusión los libros sobre arte no le prometen que se convertirá en artista. solamente pueden mostrarle herramientas, técnicas y procesos de pensamiento que otros artistas hayan utilizado. del mismo modo, este libro no puede prometer que se convierta en un buen programador, que tenga sentido del código. sólo puede mostrarle los procesos de pensamiento de buenos programadores y los trucos, técnicas y herramientas que emplean. al igual que un libro sobre arte, este libro está repleto de detalles. encontrará mucho código. verá código correcto y código incorrecto. verá código incorrecto transformado en código correcto. verá listas de heurística, disciplinas y técnicas. verá un ejemplo tras otro. y después de todo, será responsabilidad suya. ¿recuerda el chiste sobre el violinista que se pierde camino de un concierto? se cruza con un anciano y le pregunta cómo llegar al teatro real. el anciano mira al violinista y al violín que lleva bajo el brazo y le responde: «practique joven, practique». bibliografía [beck07] : implementation patterns , kent beck, addison-wesley, 2007. [knuth92] : literate programming , donald e. knuth, center for the study of language and information, leland stanford junior university, 1992. 402 nombres con sentido por tim ottinger introducción en el software , los nombres son omnipresentes. aparecen en variables, 41funciones, argumentos, clases y paquetes. asignamos nombres a archivos y a directorios, a archivos jar, war y ear. usamos nombres constantemente. por ello, debemos hacerlo bien. a continuación, veremos algunas reglas básicas para crear nombres correctos. usar nombres que revelen las intenciones es fácil afirmar que los nombres deben revelar nuestras intenciones. lo que queremos recalcar es la importancia de hacerlo. elegir nombres correctos lleva tiempo, pero también ahorra trabajo. por ello, preste atención a los nombres y cámbielos cuando encuentre otros mejores. todo el que lea su código se lo agradecerá. el nombre de una variable, función o clase debe responder una serie de cuestiones básicas. debe indicar por qué existe, qué hace y cómo se usa. si un nombre requiere un comentario, significa que no revela su cometido. int d; // tiempo transcurrido en días el nombre d no revela nada. no evoca una sensación de tiempo transcurrido, ni de días. debe elegir un nombre que especifique lo que se mide y la unidad de dicha medida: int elapsedtimeindays; int dayssincecreation; int dayssincemodification; int fileageindays; la elección de nombres que revelen intenciones facilita considerablemente la comprensión y la modificación del código. ¿para qué sirve el siguiente código? public list<int[]> getthem() { list<int[]> list1 = new arraylist<int[]>(); for (int[] x : thelist) if (x[0] == 4) list1.add(x); return list1; } ¿por qué es complicado saber la función de este código? no hay expresiones complejas. los espacios y el sangrado son razonables. sólo hay tres variables y dos constantes. ni siquiera contiene clases complejas o 42métodos polimórficos, sólo una lista de matrices (o eso parece). el problema no es la simplicidad del código sino su carácter implícito : el grado en el que el contexto no es explícito en el propio código. implícitamente, el código requiere que sepamos las respuestas a las siguientes preguntas: ¿qué contiene thelist ? ¿qué significado tiene el subíndice cero de un elemento de thelist ? ¿qué importancia tiene el valor 4 ? ¿cómo se usa la lista devuelta? las respuestas a estas preguntas no se encuentran en el código, pero se podrían haber incluido. imagine que trabaja en un juego de buscar minas. el tablero es una lista de celdas llamada thelist . cambiemos el nombre por gameboard . cada celda del teclado se representa por medio de una matriz. el subíndice cero es la ubicación de un valor de estado que, cuando es 4 , significa que se ha detectado. al asignar nombres a estos conceptos mejoramos considerablemente el código: public list<int[]> getflaggedcells() { list<int[]> flaggedcells = new arraylist<int[]>(); for (int[] cell : gameboard) if (cell[status_value] == flagged) flaggedcells.add(cell); return flaggedcells; } la simplicidad del código no ha cambiado. sigue teniendo los mismos operadores y constantes y el mismo número de niveles anidados, pero ahora es mucho más explícito. podemos crear una sencilla clase para celdas en lugar de usar una matriz de elementos int . puede incluir una función que revele el objetivo (con el nombre isflagged ) para ocultar los números. el resultado es una nueva versión de la función: public list<cell> getflaggedcells() { list<cell> flaggedcells = new arraylist<cell>(); for (cell cell : gameboard) if (cell.isflagged()) flaggedcells.add(cell); 43return flaggedcells; } con estos sencillos cambios de nombre, es fácil saber qué sucede. es la ventaja de seleccionar nombres adecuados. evitar la desinformación los programadores deben evitar dejar pistas falsas que dificulten el significado del código. debemos evitar palabras cuyo significado se aleje del que pretendemos. por ejemplo, hp , aix y sco son nombres de variables pobres ya que son los nombres de plataformas o variantes de unix. aunque se trate del código de una hipotenusa y hp parezca la abreviatura correcta, puede no serlo. no haga referencia a un grupo de cuentas como accountlist a menos que realmente sea una lista ( list ). la palabra lista tiene un significado concreto para los programadores. si el contenedor de las cuentas no es realmente una lista, puede provocar falsas conclusiones [6] . por tanto, resulta más adecuado usar accountgroup , bunchofaccounts o simplemente accounts . evite usar nombres con variaciones mínimas. ¿cuánto se tarda en apreciar la sutil diferencia entre xyzcontrollerforefficienthandlingofstrings y xyzcontrollerforefficientstorageofstrings en un módulo? ambas palabras tienen una forma similar. la ortografía similar de conceptos parecidos es información; el uso de ortografía incoherente es desinformación. en los entornos modernos de java, el código se completa de forma automática. escribimos varios caracteres de un nombre y pulsamos varias teclas para obtener una lista de posibles opciones de un nombre. es muy útil si los nombres de elementos similares se ordenan alfabéticamente de forma conjunta y si las diferencias son muy evidentes, ya que es probable que el programador elija un objeto por nombre sin fijarse en los comentarios o la lista de métodos proporcionados por una clase. 44un ejemplo de nombre desinformativo sería el uso de la l minúscula o la o mayúscula como nombres de variables, sobre todo combinados. el problema, evidentemente, es que se parecen a las constantes 1 y 0 respectivamente: int a = l; if ( o == l ) a = o1; else l = 01; el lector puede pensar que es una invención, pero hemos visto código con abundancia de estos elementos. en un caso, el autor del código, sugirió usar una fuente distinta para que las diferencias fueran más evidentes, una solución que se hubiera transmitido a todos los futuros programadores como tradición oral o en un documento escrito. el problema se resolvió con carácter definitivo y sin necesidad de crear nuevos productos, con tan sólo cambiar los nombres. realizar distinciones con sentido los programadores se crean un problema al crear código únicamente dirigido a un compilador o intérprete. por ejemplo, como se puede usar el mismo nombre para hacer referencia a dos elementos distintos en el mismo ámbito, puede verse tentado a cambiar un nombre de forma arbitraria. en ocasiones se hace escribiéndolo incorrectamente, lo que provoca que los errores ortográficos impidan la compilación [7] . no basta con añadir series de números o palabras adicionales, aunque eso satisfaga al compilador. si los nombres tienen que ser distintos, también deben tener un significado diferente. los nombres de series numéricas ( a1 , a2 … an ) son lo contrario a los nombres intencionados. no desinforman, simplemente no ofrecen información; son una pista sobre la intención del autor. fíjese en lo siguiente: 45public static void copychars(char a1[], char a2[]) { for (int i = 0; i < a1.length; i++) { a2[i] = a1[i]; } } esta función se lee mejor cuando se usa source y destination como nombres de argumentos. las palabras adicionales son otra distinción sin sentido. imagine que tiene la clase product. si tiene otra clase con el nombre productinfo o productdata , habrá creado nombres distintos, pero con el mismo significado. info y data son palabras adicionales, como a , an y the . no es incorrecto usar prefijos como a y the mientras la distinción tenga sentido. imagine que usa a para variables locales y for para argumentos de funciones [8] . el problema aparece cuando decide invocar la variable thezork porque ya tiene otra variable con el nombre zork . las palabras adicionales son redundantes. la palabra variable no debe incluirse nunca en el nombre de una variable. la palabra table no debe incluirse nunca en el nombre de una tabla. ¿es mejor namestring que name ? ¿podría ser name un número de coma flotante? en caso afirmativo, incumple la regla anterior sobre desinformación. imagine que encuentra una clase con el nombre customer y otra con el nombre customerobject . ¿cuál sería la distinción? ¿cuál representa mejor el historial de pagos de un cliente? existe una aplicación que lo ilustra. hemos cambiado los nombres para proteger al culpable. veamos el error exacto: getactiveaccount(); getactiveaccounts(); getactiveaccountinfo(); ¿cómo saben los programadores de este proyecto qué función deben invocar? en ausencia de convenciones concretas, la variable moneyamount no se distingue de money , customerinfo no se distingue de customer , accountdata no se distingue de account y themessage no se distingue de message . debe diferenciar los nombres de forma que el lector aprecie las diferencias. 46usar nombres que se puedan pronunciar a los humanos se nos dan bien las palabras. gran parte de nuestro cerebro se dedica al concepto de palabras. y, por definición, las palabras son pronunciables. sería una pena malgastar esa parte de nuestro cerebro dedicada al lenguaje hablado. por tanto, cree nombres pronunciables. si no lo puede pronunciar, no podrá explicarlo sin parecer tonto. es un factor importante, ya que la programación es una actividad social. conozco una empresa que usa genymdhms (fecha de generación, año, mes, día, hora, minuto y segundo) y lo pronuncian tal cual. yo tengo la costumbre de pronunciar todo tal y como lo veo escrito, de forma que muchos analistas y diseñadores acabaron por llamarme algo como «genimedemes». era un chiste y nos parecía divertido, pero en realidad estábamos tolerando el uso de nombres pobres. teníamos que explicar las variables a los nuevos programadores y cuando las pronunciaban, usaban palabras inventadas en lugar de nombres correctos. compare: class dtarcrd102 { private date genymdhms; private date modymdhms; private final string pszqint = “102”; /*… */ }; con: class customer { private date generationtimestamp; private date modificationtimestamp; private final string recordid = “102”; /*… */ }; ahora se puede mantener una conversación inteligente: «eh, mikey, fíjate en este registro. la marca de tiempo de generación es para mañana. ¿cómo es posible?» usar nombres que se puedan buscar 47los nombres de una letra y las constantes numéricas tienen un problema: no son fáciles de localizar en el texto. se puede detectar max_classes_per_student , pero el número 7 resulta más complicado. las búsquedas pueden devolver el dígito como parte de nombres de archivo, otras definiciones de constantes o expresiones en las que se use con otra intención. mucho peor si la constante es un número extenso y alguien ha intercambiado los dígitos, lo que genera un error inmediato y no aparece en la búsqueda. del mismo modo, el nombre e es una opción muy pobre para variables que el programador tenga que buscar. es la letra más usada en inglés y aparece en la práctica totalidad de los textos de un programa. a este respecto, los nombres extensos superan a los breves y cualquier nombre que se pueda buscar supera a una constante en el código. personalmente prefiero nombres de una letra que sólo se puedan usar como variables locales dentro de métodos breves. la longitud de un nombre debe corresponderse al tamaño de su ámbito [n5]. si una variable o constante se usa en varios puntos del código, debe asignarle un nombre que se pueda buscar. compare: for (int j=0; j<34; j++) { s += (t[j]*4)/5; } con: int realdaysperidealday = 4; const int work_days_per_week = 5; int sum = 0; for (int j = 0; j < number_of_tasks; j++) { int realtaskdays = taskestimate[j] * realdaysperidealday; int realtaskweeks = (realdays / work_days_per_week); sum += realtaskweeks; } en este ejemplo, sum no es un nombre especialmente útil, pero al menos se puede buscar. se usa una función más extensa, pero comprobará que resulta mucho más fácil buscar work_days_per_week que todas las instancias de 5 y filtrar la lista a los casos con el significado adecuado. evitar codificaciones 48ya tenemos suficientes codificaciones como para tener que añadir otras nuevas. al codificar información de tipos o ámbitos en un nombre se dificulta la descodificación. no parece razonable que todos los nuevos empleados tengan que aprender otro lenguaje de codificación además del código con el que van a trabajar. es una carga mental innecesaria a la hora de intentar solucionar un problema. los nombres codificados resultan impronunciables y suelen escribirse de forma incorrecta. notación húngara antiguamente, cuando trabajábamos con lenguajes en los que la longitud de los nombres era un reto, incumplíamos esta regla a nuestro pesar. fortran forzaba las codificaciones convirtiendo la primera letra de un tipo en código. en sus primeras versiones, basic sólo se permitía una letra y un dígito. la notación húngara (hn) lo llevó a un nuevo nivel. hn se consideraba muy importante en el api c de windows, donde todo era un control entero, un puntero long , un puntero void o una de varias implementaciones de string (con diferentes usos y atributos). por aquel entonces, el compilador no comprobaba los tipos, de modo que los programadores tenían que recordarlos. en los lenguajes modernos disponemos de sistemas de tipos más completos y los compiladores recuerdan los tipos y los aplican. es más, existe una tendencia a usar clases y funciones más breves para que los usuarios aprecien la declaración de las variables que usan. los programadores de java no tienen que codificar tipos. los objetos son de tipos fuertes y los entornos de edición han avanzado tanto que detectan un error de tipo antes de ejecutar la compilación. por ello, en la actualidad hn y otras formas de codificación de tipos no son más que un impedimento. hacen que sea más complicado cambiar el nombre o el tipo de una variable o clase. dificultan la legibilidad del código y pueden hacer que el sistema de codificación confunda al lector: phonenumber phonestring; // el nombre no cambia cuando cambia el tipo 49prefijos de miembros tampoco es necesario añadir m_ como prefijo a los nombres de variables. las clases y funciones tienen el tamaño necesario para no tener que hacerlo, y debe usar un entorno de edición que resalte o coloree los miembros para distinguirlos. public class part { private string m_dsc; // la descripción textual void setname(string name) { m_dsc = name; } } public class part { string description; void setdescription(string description) { this.description = description; } } además, los usuarios aprenden rápidamente a ignorar el prefijo (o sufijo) y fijarse en la parte con sentido del nombre. cuanto más código leemos, menos nos fijamos en los prefijos. en última instancia, los prefijos son un indicio de código antiguo. interfaces e implementaciones existe un caso especial para usar codificaciones. imagine por ejemplo que crea una factoría abstracta para crear formas. esta factoría será una interfaz y se implementará por medio de una clase concreta. ¿qué nombres debe asignar? ¿ ishapefactory y shapefactory ? prefiero las interfaces sin adornos. la i inicial, tan habitual en los archivos de legado actuales es, en el mejor de los casos, una distracción, y en el peor, un exceso de información. no quiero que mis usuarios sepan que se trata de una interfaz, solamente que se trata de shapefactory . si tengo que codificar la interfaz o la implementación, opto por ésta última. es mejor usar shapefactoryimp o incluso cshapefactory , que codificar la interfaz. 50evitar asignaciones mentales los lectores no tienen que traducir mentalmente sus nombres en otros que ya conocen. este problema suele aparecer al elegir entre no usar términos de dominio de problemas o de soluciones. es un problema de los nombres de variables de una sola letra. un contador de bucles se podría bautizar como i , j o k (pero nunca l ) si su ámbito es muy reducido y no hay conflictos con otros nombres, ya que los nombres de una letra son tradicionales en contadores de bucles. sin embargo, en otros contextos, un nombre de una letra es una opción muy pobre: es como un marcador de posición que el lector debe asignar mentalmente a un concepto real. no hay peor motivo para usar el nombre c que a y b ya estén seleccionados. por lo general, los programadores son gente inteligente. a la gente inteligente le gusta presumir de sus habilidades mentales. si puede recordar que r es la versión en minúscula de una url sin el host y el sistema, debe ser muy listo. una diferencia entre un programador inteligente y un programador profesional es que este último sabe que la claridad es lo que importa . los profesionales usan sus poderes para hacer el bien y crean código que otros puedan entender. nombres de clases las clases y los objetos deben tener nombres o frases de nombre como customer , wikipage , account y addressparser . evite palabras como manager , processor , data , o info en el nombre de una clase. el nombre de una clase no debe ser un verbo. nombres de métodos 51los métodos deben tener nombres de verbo como postpayment , deletepage o save . los métodos de acceso, de modificación y los predicados deben tener como nombre su valor y usar como prefijo get , set e is de acuerdo al estándar de javabean [9] . string name = employee.getname(); customer.setname(“mike”); if (paycheck.isposted())… al sobrecargar constructores, use métodos de factoría estáticos con nombres que describan los argumentos. por ejemplo: complex fulcrumpoint = complex.fromrealnumber(23.0); es mejor que: complex fulcrumpoint = new complex(23.0); refuerce su uso convirtiendo en privados sus constructores correspondientes. no se exceda con el atractivo si los nombres son demasiado inteligentes, sólo los recordarán los que compartan el sentido del humor de su autor, y sólo mientras se acuerden del chiste. ¿sabrán qué significa la función holyhandgrenade ? sin duda es atractiva, pero en este caso puede que deleteitems fuera más indicado. opte por la claridad antes que por el entretenimiento. en el código, el atractivo suele aparecer como formas coloquiales o jergas. por ejemplo, no use whack() en lugar de kill() . no recurra a bromas culturales como eatmyshorts() si quiere decir abort() . diga lo que piense. piense lo que diga. una palabra por concepto elija una palabra por cada concepto abstracto y manténgala. por ejemplo, 52resulta confuso usar fetch , retrieve y get como métodos equivalentes de clases distintas. ¿cómo va a recordar qué método se corresponde a cada clase? desafortunadamente, tendrá que recordar qué empresa, grupo o individuo ha creado la biblioteca o clase en cuestión para recordar qué término se ha empleado. en caso contrario, perderá mucho tiempo buscando en encabezados y fragmentos de código. los entornos de edición modernos como eclipse e intellij ofrecen pistas sensibles al contexto, como la lista de métodos que puede invocar en un determinado objeto. pero esta lista no suele incluir los comentarios de nombres de funciones y listas de parámetros. tendrá suerte si muestra los nombres de parámetros de las declaraciones de funciones. los nombres de funciones deben ser independientes y coherentes para que pueda elegir el método correcto sin necesidad de búsquedas adicionales. del mismo modo, resulta confuso tener un controlador, un administrador y un control en la misma base de código. ¿cuál es la diferencia entre devicemanager y protocolcontroller ? ¿por qué no son los dos controladores o administradores? ¿son controladores? el nombre hace que espere que dos objetos tengan un tipo diferente y clases diferentes. un léxico coherente es una gran ventaja para los programadores que tengan que usar su código. no haga juegos de palabras evite usar la misma palabra con dos fines distintos. suele hacerse en juegos de palabras. si aplica la regla de una palabra por conceptos, acabará con muchas clases que por ejemplo tengan un método add . mientras las listas de parámetros y los valores devueltos de los distintos métodos add sean semánticamente equivalentes, no hay problema. sin embargo, alguien puede decidir usar la palabra add por motivos de coherencia, aunque no sea en el mismo sentido. imagine que hay varias clases en las que add crea un nuevo valor sumando o concatenando dos valores existentes. imagine ahora que crea una nueva clase con un método 53que añada su parámetro a una colección. ¿este método debe tener el método add ? parece coherente ya que hay otros muchos métodos add , pero en este caso hay una diferencia semántica, de modo que debemos usar un nombre como insert o append . llamar add al nuevo método sería un juego de palabras. nuestro objetivo, como autores, es facilitar la comprensión del código. queremos que el código sea algo rápido, no un estudio exhaustivo. queremos usar un modelo en el que el autor sea el responsable de transmitir el significado, no un modelo académico que exija investigar el significado mostrado. usar nombres de dominios de soluciones recuerde que los lectores de su código serán programadores. por ello, use términos informáticos, algoritmos, nombres de patrones, términos matemáticos y demás. no conviene extraer todos los nombres del dominio de problemas ya que no queremos que nuestros colegas tengan que preguntar el significado de cada nombre en especial cuando ya conocen el concepto bajo otro nombre diferente. el nombre accountvisitor tiene mucho significado para un programador familiarizado con el patrón visitor . ¿qué programador no sabe lo que es jobqueue ? hay cientos de cosas técnicas que los programadores tienen que hacer y elegir nombres técnicos para dichas cosas suele ser lo más adecuado. usar nombres de dominios de problemas cuando no exista un término de programación para lo que esté haciendo, use el nombre del dominio de problemas. al menos el programador que mantenga su código podrá preguntar el significado a un experto en dominios. separar los conceptos de dominio de soluciones y de problemas es parte del trabajo de un buen programador y diseñador. el código que tenga más relación con los conceptos del dominio de problemas tendrá nombres 54extraídos de dicho dominio. añadir contexto con sentido algunos nombres tienen significado por sí mismos, pero la mayoría no. por ello, debe incluirlos en un contexto, en clases, funciones y espacios de nombres con nombres adecuados. cuando todo lo demás falle, pueden usarse prefijos como último recurso. imagine que tiene las variables firstname , lastname , street , housenumber , city , state y z ipcode . si las combina, es evidente que forman una dirección. pero si la variable state se usa de forma aislada en un método, ¿sabría que forma parte de una dirección? puede añadir contexto por medio de prefijos: addrfirstname , addrlastname , addrstate , etc. al menos los lectores comprenderán que estas variables forman parte de una estructura mayor. evidentemente, es mejor crear la clase address . de ese modo, incluso el compilador sabrá que las variables pertenecen a un concepto más amplio. fíjese en el método del listado 2-1. ¿las variables necesitan un contexto con más sentido? el nombre de la función sólo ofrece parte del contexto, el resto se obtiene del algoritmo. tras leer la función, verá que las tres variables number , verb y pluralmodifier forman parte del mensaje guess statistics . desafortunadamente, es necesario inferir el contexto. al leer el método, el significado de las variables no es evidente. listado 2-1 variables en un contexto ambiguo. private void printguessstatistics(char candidate, int count) { string number; string verb; string pluralmodifier; if (count == 0) { number = “no”; verb = “are”; pluralmodifier = “s”; } else if (count == 1) { number = “1”; 55verb = “is”; pluralmodifier = “”; } else { number = integer.tostring(count); verb = “are”; pluralmodifier = “s”; } string guessmessage = string.format( “there %s %s %s%s”, verb, number, candidate, pluralmodifier ); print(guessmessage); } la función es demasiado extensa y las variables aparecen por todas partes. para dividir la función en fragmentos más reducidos necesitamos crear una clase guessstatisticsmessage y convertir a las tres variables en campos de la misma. de este modo contamos con un contexto más obvio para las tres variables. forman parte sin duda de guessstatisticsmessage . la mejora del contexto también permite que el algoritmo sea más limpio y se divida en funciones más reducidas (véase el listado 2-2). listado 2-2 variables con un contexto. public class guessstatisticsmessage ( private string number; private string verb; private string pluralmodifier; public string make(char candidate, int count) { createpluraldependentmessageparts(count); return string.format( “there %s %s %s%s, verb, number, candidate, pluralmodifier); } private void createpluraldependentmessageparts(int count) { if (count == 0) { therearenoletters(); } else if (cout == 1) { thereisoneletter(); } else { therearemanyletters(count); } } private void therearemanyletters(int count) { number = “1”; 56verb = “is”; pluralmodifier = “”; } private void thereisoneletter() { number = “1”; verb = “is”; pluralmodifier = “”; } private void therearenoletters() { number = “no”; verb = “are”; pluralmodifier = “s”; } } no añadir contextos innecesarios en la aplicación imaginaria gas station deluxe, no es aconsejable usar el prefijo gsd en todas las clases. es trabajar contra las herramientas proporcionadas. introduzca g y pulse la tecla de finalización para acceder a una lista interminable de todas las clases del sistema. ¿es lo correcto? ¿por qué dificultar la ayuda del ide? del mismo modo, imagine que ha creado la clase mailingaddress en un módulo de contabilidad de gsd , con el nombre gsdaccountaddress . después, necesita una dirección de correo para la aplicación de contacto con el cliente. ¿usará gsdaccountaddress ? ¿le parece el nombre correcto? 10 de los 17 caracteres son redundantes o irrelevantes. los nombres breves suelen ser más adecuados que los extensos, siempre que sean claros. no añada más contexto del necesario a un nombre. los nombres accountaddress y customeraddress son perfectos para instancias de la clase address pero no sirven como nombres de clase. address sirve como nombre de clase. para distinguir entre direcciones mac, direcciones de puertos y direcciones web, podría usar postaladdress , mac y uri . los nombres resultantes son más precisos, el objetivo de cualquier nombre. 57conclusión lo más complicado a la hora de elegir un buen nombre es que requiere habilidad descriptiva y acervo cultural. es un problema de formación más que técnico, empresarial o administrativo. como resultado, mucha gente del sector no aprende a hacerlo bien. la gente teme que al cambiar los nombres otros programadores se quejen. nosotros no compartimos ese temor y agradecemos los cambios de nombre (siempre que sean a mejor). en muchos casos no memorizamos los nombres de clases y métodos. usamos herramientas modernas para estos detalles y así poder centrarnos en si el código se lee como frases o párrafos, o al menos como tablas y estructuras de datos (una frase no siempre es la mejor forma de mostrar datos). seguramente acabará sorprendiendo a alguien cuando cambie los nombres, como puede suceder con cualquier otra mejora del código. no deje que le detenga. aplique estas reglas y compruebe si mejora o no la legibilidad de su código. si es el encargado de mantener código de terceros, use herramientas para solucionar estos problemas. obtendrá recompensas a corto y largo plazo. 583 funciones 59en los inicios de la programación, creábamos sistemas a partir de rutinas y subrutinas. después, en la época de fortran y pl/1, creábamos nuestros sistemas con programas, subprogramas y funciones. en la actualidad, sólo las funciones han sobrevivido. son la primera línea organizativa en cualquier programa. en este capítulo veremos cómo crearlas. fíjese en el código del listado 3-1. es complicado encontrar una función extensa en fitnesse [10] , pero acabé encontrando ésta. no sólo es extensa, sino que también contiene código duplicado, muchas cadenas y tipos de datos extraños, además de api poco habituales y nada evidentes. intente 60comprenderlo en los próximos tres minutos. listado 3-1 htmlutil.java (fitnesse 20070619). public static string testablehtml { pagedata pagedata, boolean includesuitesetup } throws exception { wikipage wikipage = pagedata.getwikipage(); stringbuffer buffer = new stringbuffer(); if (pagedata.hasattribute(“test”)) { if (includesuitesetup) { wikipage suitesetup = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_setup_name, wikipage ); if (suitesetup != null) { wikipagepath pagepath = suitesetup.getpagecrawler().getfullpath (suitesetup); string pagepathname = pathparser.render(pagepath); buffer.append(“!include -setup .”) .append(pagepathname) .append(“\n”); } } wikipage setup = pagecrawlerimpl.getinheritedpage(“setup”, wikipage); if (setup != null) { wikipagepath setuppath = wikipage.getpagecrawler().getfullpath(setup); string setuppathname = pathparser.render(setuppath); buffer.append(“!include -setup .”) .append(setuppathname) .append(“\n”); } } buffer.append(pagedata.getcontent()); if (pagedata.hasattribute(“test”)) { wikipage teardown = pagecrawlerimpl.getinheritedpage(“teardown”, wikipage); if (teardown != null) { wikipagepath teardownpath = wikipage.getpagecrawler().getfullpath(teardown); string teardownpathname = pathparser.render(teardownpath); buffer.append(“\n”) .append(“!include -teardown .”) .append(teardownpathname) .append(“\n”); } if (includesuitesetup) { 61wikipage suiteteardown = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_teardown_name, wikipage ); if (suiteteardown != null) { wikipagepath pagepath = suiteteardown.getpagecrawler().getfullpath (suiteteardown); string pagepathname = pathparser.render(pagepath); buffer.append(“!include -teardown .”) .append(pagepathname) .append(“\n”); } } } pagedata.setcontent(buffer.tostring()); return pagedata.gethtml(); } ¿tras tres minutos entiende la función? seguramente no. pasan demasiadas cosas y hay demasiados niveles de abstracción diferentes. hay cadenas extrañas e invocaciones de funciones mezcladas en instrucciones if doblemente anidadas controladas por indicadores. sin embargo, con sencillas extracciones de código, algún cambio de nombres y cierta reestructuración, pude capturar la intención de la función en las nueve líneas del listado 3-2. compruebe si ahora la entiende. listado 3-2 htmlutil.java (refactorización). public static string renderpagewithsetupsandteardowns( pagedata pagedata, boolean issuite ) throws exception { boolean istestpage = pagedata.hasattribute(“test”); if (istestpage) { wikipage testpage = pagedata.getwikipage(); stringbuffer newpagecontent = new stringbuffer(); includesetuppages (testpage, newpagecontent, issuite); newpagecontent.append(pagedata.getcontent()); includeteardownpages(testpage, newpagecontent, issuite); pagedata.setcontent(newpagecontent.tostring()); } return pagedata.gethtml(); } a menos que sea un alumno de fitnesse, seguramente no entienda los 62detalles. entenderá que la función se encarga de añadir páginas de configuración y detalles en una página de prueba, que después muestra en html. si está familiarizado con junit [11] , verá que esta función pertenece a algún tipo de estructura de pruebas basada en la web y, evidentemente, es correcto. resulta sencillo adivinar esta información del listado 3-2 pero no del listado 3-1. ¿qué tiene la función del listado 3-2 para que resulte sencilla de leer y entender? ¿qué hay que hacer para que una función transmita su intención? ¿qué atributos podemos asignar a nuestras funciones para que el lector pueda intuir el tipo de programa al que pertenecen? tamaño reducido la primera regla de las funciones es que deben ser de tamaño reducido. la segunda es que deben ser todavía más reducidas . no es una afirmación que pueda justificar. no puedo mostrar referencias a estudios que demuestren que las funciones muy reducidas sean mejores. lo que sí puedo afirmar es que durante casi cuatro décadas he creado funciones de diferentes tamaños. he creado monstruos de casi 3000 líneas y otras muchas funciones de entre 100 y 300 líneas. también he creado funciones de 20 a 30 líneas de longitud. esta experiencia me ha demostrado, mediante ensayo y error, que las funciones deben ser muy reducidas. en la década de 1980 se decía que una función no debía superar el tamaño de una pantalla. por aquel entonces, las pantallas vt100 tenían 24 líneas por 80 columnas, y nuestros editores usaban 4 líneas para tareas administrativas. en la actualidad, con una fuente mínima y un monitor de gran tamaño, se pueden encajar 150 caracteres por línea y 100 líneas o más en una pantalla. las líneas no deben tener 150 caracteres. las funciones no deben tener 100 líneas de longitud. las funciones deben tener una longitud aproximada de 20 líneas. ¿qué tamaño mínimo debe tener una función? en 1999 visité a kent beck en su casa de oregon. nos sentamos y comenzamos a programar. me enseñó un atractivo programa de java/swing que había llamado sparkle . generaba un efecto visual en pantalla, similar a la varita mágica del hada de 63cenicienta. al mover el ratón, salían estrellitas del cursor, y descendían a la parte inferior de la pantalla en un campo gravitatorio simulado. cuando kent me enseñó el código, me sorprendió la brevedad de las funciones. estaba acostumbrado a ver programas de swing con funciones que ocupaban kilómetros de espacio vertical. en este programa, las funciones tenían dos, tres o cuatro líneas de longitud. todas eran obvias. todas contaban una historia y cada una llevaba a la siguiente en un orden atractivo. ¡así de breves deberían ser todas las funciones! [12] ¿qué tamaño mínimo deben tener sus funciones? deberían ser más breves que las del listado 3-2. de hecho, el listado 3-2 debería reducirse como el listado 3-3. listado 3-3 htmlutil.java (nueva refactorización). public static string renderpagewithsetupsandteardowns( pagedata pagedata, boolean issuite) throws exception { if (istestpage(pagedata)) includesetupandteardownpages(pagedata, issuite); return pagedata.gethtml(); } bloques y sangrado esto implica que los bloques en instrucciones if , else , while y similares deben tener una línea de longitud que, seguramente, sea la invocación de una función. de esta forma, no sólo se reduce el tamaño de la función, sino que también se añade valor documental ya que la función invocada desde el bloque puede tener un nombre descriptivo. también implica que las funciones no deben tener un tamaño excesivo que albergue estructuras anidadas. por tanto, el nivel de sangrado de una función no debe ser mayor de uno o dos. evidentemente, de esta forma las funciones son más fáciles de leer y entender. hacer una cosa 64es evidente que el listado 3-1 hace más de una cosa. crea búferes, obtiene páginas, busca páginas heredadas, añade cadenas antiguas y genera html. el listado 3-1 está muy ocupado realizando varias tareas. por su parte, el listado 3-3 sólo hace una cosa: incluye configuraciones y detalles en páginas de prueba. el siguiente consejo lleva vigente, de una u otra forma, durante más de 30 años: las funciones sólo deben hacer una cosa. deben hacerlo bien y debe ser lo único que hagan. el problema de esta afirmación es saber qué es una cosa. ¿el listado 3-3 hace una cosa? se podría pensar que hace tres: 1 . determinar si la página es una página de prueba. 2 . en caso afirmativo, incluir configuraciones y detalles. 3 . representar la página en html. ¿cuál será de las tres? ¿la función hace una o tres cosas? los tres pasos de la función se encuentran un nivel de abstracción por debajo del nombre de la función. podemos describir la función como un breve párrafo to (para) [13] : para renderpagewithsetupsandteardowns , comprobamos si la página es de prueba y, en caso afirmativo, incluimos las configuraciones y los detalles. en ambos casos, la representamos en html. si una función sólo realiza los pasos situados un nivel por debajo del nombre de la función, entonces hace una cosa. en definitiva, creamos funciones para descomponer conceptos más amplios (es decir, el nombre de 65la función) en un conjunto de pasos en el siguiente nivel de abstracción. es evidente que el listado 3-1 contiene pasos en distintos niveles de abstracción, por lo que es obvio que hace más de una cosa. incluso el listado 3-2 tiene tres niveles de abstracción, como ha demostrado la capacidad de reducirlo, pero sería complicado reducir con sentido el listado 3-3. podríamos extraer la instrucción if en la función includesetupsandteardownsiftestpage , pero sólo reduciríamos el código sin cambiar el nivel de abstracción. por ello, otra forma de saber que una función hace más de una cosa es extraer otra función de la misma con un nombre que no sea una reducción de su implementación [g34]. secciones en funciones fíjese en el listado 4-7. verá que la función generateprimes se divide en secciones como declaraciones, inicializaciones y filtros. es un síntoma evidente de que hace más de una cosa. las funciones que hacen una sola cosa no se pueden dividir en secciones. un nivel de abstracción por función para que las funciones realicen «una cosa», asegúrese de que las instrucciones de la función se encuentran en el mismo nivel de abstracción. el listado 3-1 incumple esta regla. incluye conceptos a un elevado nivel de abstracción, como gethtml(); otros se encuentran en un nivel intermedio, como stringpagepathname = pathparser.render(pagepath) y hay otros en un nivel especialmente bajo, como .append(“\n”). la mezcla de niveles de abstracción en una función siempre resulta confusa. los lectores no sabrán si una determinada expresión es un concepto esencial o un detalle. peor todavía, si se mezclan detalles con conceptos esenciales, aumentarán los detalles dentro de la función. 66leer código de arriba a abajo: la regla descendente el objetivo es que el código se lea como un texto de arriba a abajo [14] . queremos que tras todas las funciones aparezcan las del siguiente nivel de abstracción para poder leer el programa, descendiendo un nivel de abstracción por vez mientras leemos la lista de funciones. es lo que denomino la regla descendente. para decirlo de otra forma, queremos leer el programa como si fuera un conjunto de párrafos to , en el que cada uno describe el nivel actual de abstracción y hace referencia a los párrafos to posteriores en el siguiente nivel. para incluir configuraciones y detalles, incluimos configuraciones, después del contenido de la página de prueba, y por último los detalles. para incluir las configuraciones, incluimos la configuración de suite si se trata de una suite , y después la configuración convencional. para incluir la configuración de suite ; buscamos la jerarquía principal de la página suitesetup y añadimos una instrucción include con la ruta de dicha página. para buscar la jerarquía principal… a los programadores les resulta complicado aprender esta regla y crear funciones en un único nivel de abstracción, pero es un truco importante. es la clave para reducir la longitud de las funciones y garantizar que sólo hagan una cosa. al conseguir que el código se lea de arriba a abajo, se mantiene la coherencia de los niveles de abstracción. fíjese en el listado 3-7 del final del capítulo. muestra la función testablehtml modificada de acuerdo a estos principios. cada función presenta a la siguiente y se mantiene en un nivel de abstracción coherente. instrucciones switch 67es complicado usar una instrucción switch de tamaño reducido [15] . aunque sólo tenga dos casos, es mayor de lo que un bloque o función debería ser. también es complicado crear una instrucción switch que haga una sola cosa. por su naturaleza, las instrucciones switch siempre hacen n cosas. desafortunadamente, no siempre podemos evitar las instrucciones switch pero podemos asegurarnos de incluirlas en una clase de nivel inferior y de no repetirlas. para ello, evidentemente, recurrimos al polimorfismo. fíjese en el listado 3-4. muestra una de las operaciones que pueden depender del tipo de empleado. listado 3-4 payroll.java. public money calculatepay(employee e) throws invalidemployeetype ( switch (e.type) { case commissioned: return calculatecommissionedpay(e); case hourly: return calculatehourlypay(e); case salaried: return calculatesalariedpay(e); default: throw new invalidemployeetype(e.type); } } esta función tiene varios problemas. por un lado, es de gran tamaño y cuando se añadan nuevos tipos de empleado, aumentará más. por otra parte, hace más de una cosa. también incumple el principio de responsabilidad única ( single responsibility principie o srp) [16] ya que hay más de un motivo para cambiarla. además, incumple el principio de abierto/cerrado ( open closed principle u ocp) [17] , ya que debe cambiar cuando se añadan nuevos tipos, pero posiblemente el peor de los problemas es que hay un número ilimitado de funciones que tienen la misma estructura. por ejemplo, podríamos tener: ispayday(employee e, date date), o 68deliverpay(employee e, date date), o muchas otras, todas con la misma estructura. la solución al problema (véase el listado 3-5) consiste en ocultar la instrucción switch en una factoría abstracta [18] e impedir que nadie la vea. la factoría usa la instrucción switch para crear las instancias adecuadas de los derivados de employee y las distintas funciones, como calculatepay , ispayday y deliverpay , se entregarán de forma polimórfica a través de la interfaz employee . listado 3-5 employee y factory. public abstract class employee { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } public interface employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype; } public class employeefactoryimpl implements employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype { switch (r.type) { case commissioned: return new commissionedemployee(r); case hourly: return new hourlyemployee(r); case salaried: return new salariedemployee(r); default: throw new invalidemployeetype(r.type); } } } mi regla general para las instrucciones switch es que se pueden tolerar si sólo aparecen una vez, se usan para crear objetos polimórficos y se ocultan tras una relación de herencia para que el resto del sistema no las pueda ver [g23]. evidentemente, cada caso es diferente y en ocasiones se puede 69incumplir una o varias partes de esta regla. usar nombres descriptivos en el listado 3-7, hemos cambiado el nombre de la función de ejemplo de testablehtml a setupteardownincluder.render . es un nombre más apropiado ya que describe mejor el cometido de la función. también hemos asignado a los métodos privados un nombre descriptivo como istestable o includesetupandteardownpages . no hay que olvidar el valor de los nombres correctos. recuerde el principio de ward: «sabemos que trabajamos con código limpio cuando cada rutina es más o menos lo que esperábamos». para alcanzar este principio, gran parte del esfuerzo se basa en seleccionar nombres adecuados para pequeñas funciones que hacen una cosa. cuanto más reducida y concreta sea una función, más sencillo será elegir un nombre descriptivo. no tema los nombres extensos. un nombre descriptivo extenso es mucho mejor que uno breve pero enigmático. use una convención de nombres que permita leer varias palabras en los nombres de las funciones y use esas palabras para asignar a la función un nombre que describa su cometido. no tema dedicar tiempo a elegir un buen nombre. de hecho, debería probar con varios nombres y leer el código con todos ellos. los ide modernos como eclipse o intellij facilitan el cambio de nombres. use uno de estos ide y experimente con diferentes nombres hasta que encuentre uno que sea lo bastante descriptivo. la elección de nombres descriptivos clarifica el diseño de los módulos y le permite mejorarlos. no es extraño que la búsqueda de nombres adecuados genere una reestructuración favorable del código. sea coherente con los nombres. use las mismas frases, sustantivos y verbos en los nombres de función que elija para los módulos. pruebe, por ejemplo, con includesetupandteardownpages , includesetuppages , includesuitesetuppage e includesetuppage . la estructura similar de estos nombres permite que la secuencia cuente una historia. en realidad, si ve la secuencia anterior, seguramente se pregunte qué ha pasado con 70includeteardownpages , includesuiteteardownpage e includeteardownpage . argumentos de funciones el número ideal de argumentos para una función es cero. después uno (monádico) y dos (diádico). siempre que sea posible, evite la presencia de tres argumentos (triádico). más de tres argumentos (poliádico) requiere una justificación especial y no es muy habitual. los argumentos son complejos ya que requieren un gran poder conceptual. por ello suelo evitarlos en los ejemplos. fíjese en stringbuffer . podríamos haberlo pasado como argumento en lugar de como variable de instancia, pero los lectores habrían tenido que interpretarlo cada vez que lo vieran. al leer la historia que cuenta el módulo, includesetuppage() es más sencillo de interpretar que includesetuppageinto(newpagecontent) . el argumento se encuentra en un nivel de abstracción diferente que el nombre de la función y nos obliga a conocer un detalle ( stringbuffer ) que no es especialmente importante en ese momento. los argumentos son todavía más complicados desde un punto de vista de pruebas. imagine la dificultad de crear todos los casos de prueba para garantizar el funcionamiento de las distintas combinaciones de argumentos. si no hay argumentos, todo es más sencillo. si hay uno, no es demasiado difícil. con dos argumentos el problema es más complejo. con más de dos argumentos, probar cada combinación de valores adecuados es todo un reto. los argumentos de salida son más difíciles de entender que los de entrada. al leer una función, estamos acostumbrados al concepto de información añadida 71a la función a través de argumentos y extraída a través de un valor devuelto. no esperamos que la información se devuelva a través de los argumentos. por ello, los argumentos de salida suelen obligamos a realizar una comprobación doble. un argumento de salida es la mejor opción, después de la ausencia de argumentos. setupteardownincluder.render(pagedata) se entiende bien. evidentemente, vamos a representar los datos en el objeto pagedata . formas monádicas habituales hay dos motivos principales para pasar un solo argumento a una función. puede que realice una pregunta sobre el argumento, como en boolean fileexists(“myfile”), o que procese el argumento, lo transforme en otra cosa y lo devuelva. por ejemplo, inputstream fileopen(“myfile”) transforma un nombre de archivo string en un valor devuelto inputstream . los usuarios esperan estos dos usos cuando ven una función. debe elegir nombres que realicen la distinción con claridad y usar siempre ambas formas en un contexto coherente (consulte el apartado sobre separación de consultas de comandos). una forma menos habitual pero muy útil para un argumento es un evento. en esta forma, hay argumento de entrada pero no de salida. el programa debe interpretar la invocación de la función como evento y usar el argumento para alterar el estado del sistema, por ejemplo, void passwordattemptfailedntimes(int attempts) . use esta forma con precaución. debe ser claro para el lector que se trata de un evento. elija nombres y contextos con atención. intente evitar funciones monádicas que no tengan estas formas, por ejemplo, void includesetuppageinto(stringbuffer pagetext) . el uso de un argumento de salida en lugar de un valor devuelto para realizar transformaciones resulta confuso. si una función va a transformar su argumento de entrada, la transformación debe aparecer como valor devuelto. sin duda stringbuffertransform(stringbuffer in) es mejor que void 72transform(stringbuffer out) , aunque la implementación del primer caso devuelva solamente el argumento de entrada. al menos se ajusta a la forma de la transformación. argumentos de indicador los argumentos de indicador son horribles. pasar un valor booleano a una función es una práctica totalmente desaconsejable. complica inmediatamente la firma del método e indica que la función hace más de una cosa. hace algo si el indicador es true y otra cosa diferente si es false . en el listado 3-7 no se puede evitar, porque los invocadores ya pasan el indicador y el objetivo era limitar el ámbito a la función y después, pero la invocación de render (true) es confusa para el lector. si se desplaza el ratón sobre la invocación vemos que render (boolean issuite) puede ayudar, pero no demasiado. tendremos que dividir la función en dos: renderforsuite() y renderforsingletest() . funciones diádicas una función con dos argumentos es más difícil de entender que una función monádica. por ejemplo writefield(name) es más fácil de entender que writefield (outputstream, name) [19] . aunque en ambos casos el significado es evidente, la primera se capta mejor visualmente. la segunda requiere una breve pausa hasta que ignoramos el segundo parámetro, lo que en última instancia genera problemas ya que no debemos ignorar esa parte del código. las partes que ignoramos son las que esconden los errores. pero en ocasiones se necesitan dos argumentos. por ejemplo. point p = new point(0,0); es totalmente razonable. los puntos cartesianos suelen adoptar dos argumentos. de hecho, sería muy sorprendente ver point(0) . sin embargo, en este caso ambos argumentos son componentes ordenados de un mismo valor, mientras que outputstream y name carecen de una cohesión o un orden natural. 73incluso funciones diádicas evidentes como assertequals(expected, actual) resultan problemáticas. ¿cuántas veces ha incluido el valor real en su posición esperada? los dos argumentos carecen de un orden natural. el orden real y esperado es una convención que se adquiere gracias a la práctica. las combinaciones diádicas no son el mal en persona y tendrá que usarlas. sin embargo, recuerde que tienen un precio y que debe aprovechar los mecanismos disponibles para convertirlas en unitarias. por ejemplo, puede hacer que el método writefield sea un miembro de outputstream para poder usar outputstream.writefield(name) , o podría convertir outputstream en una variable miembro de la clase actual para no tener que pasarla. incluso podría extraer una nueva clase como fieldwriter que usara outputstream en su constructor y tuviera un método write . triadas las funciones que aceptan tres argumentos son sin duda mucho más difíciles de entender que las de dos. los problemas a la hora de ordenar, ignorar o detenerse en los argumentos se duplican. piense atentamente antes de crear una triada. por ejemplo, fíjese en la sobrecarga de assertequals que acepta tres argumentos: assertequals(message, expected, actual) . ¿cuántas veces lee el mensaje y piensa que es lo esperado? he visto esta triada en concreto muchas veces. de hecho, siempre que la veo, tengo que repasarla antes de ignorar el mensaje. por otra parte, hay otra triada que no es tan negativa: assertequals(1.0, amount, .001) . aunque también exija doble atención, merece la pena. conviene recordar siempre que la igualdad de los valores de coma flotante es algo relativo. objeto de argumento cuando una función parece necesitar dos o más argumentos, es probable que 74alguno de ellos se incluya en una clase propia. fíjese en la diferencia entre las dos siguientes declaraciones: circle makecircle (double x, double y, double radius); circle makecircle(point center, double radius); la reducción del número de argumentos mediante la creación de objetos puede parecer una trampa pero no lo es. cuando se pasan grupos de variables de forma conjunta, como x e y en el ejemplo anterior, es probable que formen parte de un concepto que se merece un nombre propio. listas de argumentos en ocasiones tendremos que pasar un número variable de argumentos a una función. fíjese en el método string.format : string.format (“%s worked %.2f hours.”, name, hours); si los argumentos variables se procesan de la misma forma, como en el ejemplo anterior, serán equivalentes a un único argumento de tipo list . por tanto, string.format es en realidad diádico. de hecho, la siguiente declaración de string.format es claramente diádica. public string format(string format, object… args) así pues, se aplican las mismas reglas. las funciones que aceptan argumentos variables pueden ser monádicas, diádicas o incluso triádicas, pero sería un error asignar más argumentos. void monad(integer… args); void dyad(string name, integer… args); void triad(string name, int count, integer… args); verbos y palabras clave la selección de nombres correctos para una función mejora la explicación de su cometido, así como el orden y el cometido de los argumentos. en formato monádico, la función y el argumento deben formar un par de verbo y sustantivo. por ejemplo, write(name) resulta muy evocador. sea lo que sea name , sin duda se escribe (write) . 75un nombre más acertado podría ser writefield(name) , que nos dice que name es un campo (field) . éste es un ejemplo de palabra clave como nombre de función. con este formato codificamos los nombres de los argumentos en el nombre de la función. por ejemplo, assertequals se podría haber escrito como assertexpectedequalsactual(expected, actual) , lo que mitiga el problema de tener que recordar el orden de los argumentos. sin efectos secundarios los efectos secundarios son mentiras. su función promete hacer una cosa, pero también hace otras cosas ocultas. en ocasiones realiza cambios inesperados en las variables de su propia clase. en ocasiones las convierte en las variables pasadas a la función o a elementos globales del sistema. en cualquier caso, se comete un engaño que suele provocar extrañas combinaciones temporales y dependencias de orden. fíjese en la función del listado 3-6, aparentemente inofensiva. usa un algoritmo estándar para comparar username con password . devuelve true si coinciden y false si hay algún problema, pero también hay un efecto secundario. ¿lo detecta? listado 3-6 uservalidator.java. public class uservalidator { private cryptographer cryptographer; public boolean checkpassword(string username, string password) { user user = usergateway.findbyname(username); if (user != user.null) { string codedphrase = user.getphraseencodedbypassword(); string phrase = cryptographer.decrypt(codedphrase, password); if (“valid password”.equals(phrase)){ session.initialize(); return true; } } return false; } 76} el efecto secundario es la invocación de session.initialize() . la función checkpassword , por su nombre, afirma comprobar la contraseña. el nombre no implica que inicialice la sesión. por tanto, un invocador que se crea lo que dice el nombre de la función se arriesga a borrar los datos de sesión actuales cuando decida comprobar la validez del usuario. este efecto secundario genera una combinación temporal. es decir, sólo se puede invocar checkpassword en determinados momentos (cuando se pueda inicializar la sesión). si no se invoca en orden, se pueden perder los datos de la sesión. las combinaciones temporales son confusas, en especial cuando se ocultan como efecto secundario. si tiene que realizar una combinación temporal, hágalo de forma clara en el nombre de la función. en este caso, podríamos cambiar el nombre de la función por checkpasswordandinitializesession , pero incumpliría la norma de hacer una sola cosa. argumentos de salida los argumentos suelen interpretarse como entradas de una función. si lleva varios años programando, estoy seguro de que habrá visto un argumento que en vez de ser de entrada era de salida. por ejemplo; appendfooter(s); ¿está función añade s al final de algo? ¿o añade el final de algo a s ? ¿ s es una entrada o una salida? lo sabemos al ver la firma de la función: public void appendfooter(stringbuffer report) esto lo aclara todo, pero para ello hay que comprobar la declaración de la función. todo lo que le obligue a comprobar la firma de la función es un esfuerzo doble. es una pausa cognitiva y debe evitarse. antes de la programación orientada a objetos, era necesario tener argumentos de salida. sin embargo, gran parte de su necesidad desaparece en los lenguajes orientados a objetos, pensados para actuar como argumento de salida. es decir, sería más indicado invocar appendfooter como report.appendfooter();. por lo general, los argumentos de salida deben evitarse. si su función 77tiene que cambiar el estado de un elemento, haga que cambie el estado de su objeto contenedor. separación de consultas de comando las funciones deben hacer algo o responder a algo, pero no ambas cosas. su función debe cambiar el estado de un objeto o devolver información sobre el mismo, pero ambas operaciones causan confusión. fíjese en la siguiente función: public boolean set(string attribute, string value); esta función establece el valor de un atributo y devuelve true en caso de éxito o false si el atributo no existe. esto provoca la presencia de una extraña instrucción como la siguiente: if (set(“username”, “unclebob”))… imagínelo desde el punto de vista del lector. ¿qué significa? ¿pregunta si el atributo « username » se ha establecido antes en « unclebob », o si el atributo «username» se ha establecido correctamente en « unclebob »? es complicado saberlo por la invocación ya que no es evidente si set es un verbo o un adjetivo. el autor pretendía que set fuera un verbo, pero el contexto de la instrucción if parece un adjetivo. la instrucción se lee como «si el atributo username se ha establecido previamente en unclebob », no como «establecer el atributo username en unclebob y si funciona, entonces…». podríamos solucionarlo si cambiamos el nombre de la función set por setandcheckifexists , pero no mejoraría la legibilidad de la instrucción if . la verdadera solución es separar el comando de la consulta para evitar la ambigüedad. if (attributeexists(“username”)) { setattribute(“username”, “unclebob”); … } 78mejor excepciones que devolver códigos de error devolver códigos de error de funciones de comando es un sutil incumplimiento de la separación de comandos de consulta. hace que los comandos usados asciendan a expresiones en los predicados de las instrucciones if . if (deletepage(page) == e_ok) no padece la confusión entre verbo y adjetivo, pero genera estructuras anidadas. al devolver un código de error se crea un problema: el invocador debe procesar el error de forma inmediata. if (deletepage(page) == e_ok) { if (registry.deletereference(page.name) == e_ok) { if (configkeys.deletekey(page.name.makekey()) == e_ok) { logger.log(“page deleted”); } else { logger.log(“configkey not deleted”); } } else { logger.log(“deletereference from registry failed”); } } else { logger.log(“delete failed”); return e_error; } por otra parte, si usa excepciones en lugar de códigos de error, el código de procesamiento del error se puede separar del código de ruta y se puede simplificar: try { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } catch (exception e) { logger.log(e.getmessage()); } extraer bloques try/catch los bloques try/catch no son atractivos por naturaleza. confunden la estructura del código y mezclan el procesamiento de errores con el normal. 79por ello, conviene extraer el cuerpo de los bloques try y catch en funciones individuales. public void delete(page page) { try { deletepageandallreferences(page); } catch (exception e) { logerror(e); } } private void deletepageandallreferences(page page) throws exception { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } private void logerror(exception e) { logger.log(e.getmessage()); } en este caso, la función delete es de procesamiento de errores. es fácil de entender e ignorar. la función deletepageandallreferences es para los procesos de borrar una página. el procesamiento de errores se puede ignorar. de este modo, la separación facilita la comprensión y la modificación del código. el procesamiento de errores es una cosa las funciones sólo deben hacer una cosa y el procesamiento de errores es un ejemplo. por tanto, una función que procese errores no debe hacer nada más. esto implica (como en el ejemplo anterior) que, si una función incluye la palabra clave try , debe ser la primera de la función y que no debe haber nada más después de los bloques catch/finally . el imán de dependencias error.java la devolución de códigos de error suele implicar que existe una clase o enumeración en la que se definen los códigos de error. public enum error { 80ok, invalid, no_such, locked, out_of_resources, waiting_for_event; } clases como ésta son un imán para las dependencias ; otras muchas clases deben importarlas y usarlas. por ello, cuando cambia la enumeración error , es necesario volver a compilar e implementar dichas clases [20] . esto añade presión a la clase error . los programadores no quieren añadir nuevos errores porque tendrán que volver a generar e implementarlo todo. por ello, reutilizan códigos de error antiguos en lugar de añadir otros nuevos. al usar excepciones en lugar de códigos de error, las nuevas excepciones son derivaciones de la clase de la excepción. se pueden añadir sin necesidad de volver a compilar o implementar [21] . no repetirse [22] fíjese de nuevo en el listado 3-1; verá que hay un algoritmo que se repite cuatro veces, en los casos setup , suitesetup , teardown y suiteteardown . no es fácil detectar esta repetición ya que las cuatro instancias se mezclan con otro código, pero la duplicación es un problema ya que aumenta el tamaño del código y requerirá una modificación cuádruple si alguna vez cambia el algoritmo. también se cuadriplica el riesgo de errores. esta duplicación se remedia gracias al método include del listado 3-7. vuelva a leer el código y fíjese en cómo se ha mejorado la legibilidad del código reduciendo la duplicación. la duplicación puede ser la raíz de todos los problemas del software . existen numerosos principios y prácticas para controlarla o eliminarla. imagine que todas las formas normales de la base de datos de codd sirvieran 81para eliminar la duplicación de datos. imagine también cómo la programación orientada a objetos concentra el código en clases base que en otros casos serian redundantes. la programación estructurada, la programación orientada a aspecto y la orientada a componentes son, en parte, estrategias para eliminar duplicados. parece que, desde la aparición de las subrutinas, las innovaciones en desarrollo de software han sido un intento continuado por eliminar la duplicación de nuestro código fuente. programación estructurada algunos programadores siguen las reglas de programación estructurada de edsger dijkstra [23] . dijkstra afirma que todas las funciones y todos los bloques de una función deben tener una entrada y una salida. estas reglas implican que sólo debe haber una instrucción return en una función, que no debe haber instrucciones break o continue en un bucle y nunca, bajo ningún concepto, debe haber instrucciones goto . aunque apreciemos los objetivos y disciplinas de la programación estructurada, no sirven de mucho cuando las funciones son de reducido tamaño. su verdadero beneficio se aprecia en funciones de gran tamaño. por tanto, si sus funciones son de tamaño reducido, una instrucción return , break o continue no hará daño alguno y en ocasiones puede resultar más expresiva que la regla de una entrada y una salida. por otra parte, goto sólo tiene sentido en funciones de gran tamaño y debe evitarse. cómo crear este tipo de funciones la creación de software es como cualquier otro proceso creativo. al escribir un informe o un artículo, primero se estructuran las ideas y después el mensaje hasta que se lea bien. el primer borrador puede estar desorganizado, de modo que lo retoca y mejora hasta que se lea de la forma adecuada. cuando creo funciones, suelen ser extensas y complicadas, con abundancia de sangrados y bucles anidados. con extensas listas de 82argumentos, nombres arbitrarios y código duplicado, pero también cuento con una serie de pruebas de unidad que abarcan todas y cada una de las líneas de código. por tanto, retoco el código, divido las funciones, cambio los nombres y elimino los duplicados. reduzco los métodos y los reordeno. en ocasiones, elimino clases enteras, mientras mantengo las pruebas. al final, consigo funciones que cumplen las reglas detalladas en este capítulo. no las escribo al comenzar y dudo que nadie pueda hacerlo. conclusión todo sistema se crea a partir de un lenguaje específico del dominio diseñado por los programadores para describir dicho sistema. las funciones son los verbos del lenguaje y las clases los sustantivos. no es volver a la noción de que los sustantivos y verbos de un documento de requisitos son las clases y funciones de un sistema. es una verdad mucho más antigua. el arte de la programación es, y ha sido siempre, el arte del diseño del lenguaje. los programadores experimentados piensan en los sistemas como en historias que contar, no como en programas que escribir. recurren a las prestaciones del lenguaje de programación seleccionado para crear un lenguaje expresivo mejor y más completo que poder usar para contar esa historia. parte de ese lenguaje es la jerarquía de funciones que describen las acciones que se pueden realizar en el sistema. dichas acciones se crean para usar el lenguaje de dominio concreto que definen para contar su pequeña parte de la historia. en este capítulo hemos visto la mecánica de la creación de funciones correctas. si aplica estas reglas, sus funciones serán breves, con nombres correctos, y bien organizadas, pero no olvide que su verdadero objetivo es contar la historia del sistema y que las funciones que escriba deben encajar en un lenguaje claro y preciso que le sirva para contar esa historia. setupteardownincluder 83listado 3-7 setupteardownincluder.java. package fitnesse.html; import fitnesse.responders.run.suiteresponder; import fitnesse.wiki.*; public class setupteardownincluder { private pagedata pagedata; private boolean issuite; private wikipage testpage; private stringbuffer newpagecontent; private pagecrawler pagecrawler; public static string render(pagedata pagedata) throws exception { return render(pagedata, false); } public static string render(pagedata pagedata, boolean issuite) throws exception { return new setupteardownincluder(pagedata).render(issuite); } private setupteardownincluder(pagedata pagedata) { this.pagedata = pagedata; testpage = pagedata.getwikipage(); pagecrawler = testpage.getpagecrawler(); newpagecontent = new stringbuffer(); } private string render(boolean issuite) throws exception { this.issuite = issuite; if (istestpage()) includesetupandteardownpages(); return pagedata.gethtml(); } private boolean istestpage() throws exception { return pagedata.hasattribute(“test”); } private void includesetupandteardownpages() throws exception { includesetuppages(); includepagecontent(); includeteardownpages(); updatepagecontent(); } private void includesetuppages() throws exception { if (issuite) includesuitesetuppage(); includesetuppage(); } 84private void includesuitesetuppage() throws exception { include(suiteresponder.suite_setup_name, “-setup”); } private void includesetuppage() throws exception { include(“setup”, “-setup”); } private void includepagecontent() throws exception { newpagecontent.append(pagedata.getcontent()); } private void includeteardownpages() throws exception { includeteardownpage(); if (issuite) includesuiteteardownpage(); } private void includeteardownpage() throws exception { include(“teardown”, “-teardown”); } private void includesuiteteardownpage() throws exception { include(suiteresponder.suite_teardown_name, “-teardown”); } private void updatepagecontent() throws exception { pagedata.setcontent(newpagecontent.tostring()); } private void include(string pagename, string arg) throws exception ( wikipage inheritedpage = findinheritedpage(pagename); if (inheritedpage != null) { string pagepathname = getpathnameforpage(inheritedpage); buildincludedirective(pagepathname, arg); } } private wikipage findinheritedpage(string pagename) throws exception { return pagecrawlerimpl.getinheritedpage(pagename, testpage); } private string getpathnameforpage(wikipage page) throws exception { wikipagepath pagepath = pagecrawler.getfullpath(page); return pathparser.render(pagepath); } private void buildincludedirective(string pagepathname, string arg) { newpagecontent .append(“\n!include ”) .append(arg) .append(“ .”) .append(pagepathname) .append(“\n”); } 85} bibliografía [kp78] : kernighan and plaugher, the elements of programming style , 2d. ed., mcgraw-hill, 1978. [ppp02] : robert c. martin, agile software development: principles, patterns, and practices, prentice hall, 2002. [gof] : design patterns: elements of reusable object oriented software, gamma et al., addison wesley, 1996. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. [sp72] : structured programming , o. j. dahl, e. w. dijkstra, c. a. r. hoare, academic press, london, 1972. 864 comentarios «no comente el código incorrecto, reescríbalo». brian w. kernighan y p. j. plaugher [24] no hay nada más útil que un comentario bien colocado. no hay nada que colapse más un módulo que comentarios dogmáticos innecesarios. no hay nada más dañino que un comentario antiguo que propague mentiras y desinformación. los comentarios no son como la lista de schindler. no son pura bondad. de hecho, en el mejor de los casos, son un mal necesario. si los lenguajes de 87programación fueran más expresivos o si pudiéramos dominarlos para expresar nuestras intenciones, no necesitaríamos demasiados comentarios, puede que incluso ninguno. el uso correcto de los comentarios permite compensar nuestra incapacidad para expresarnos en el código. he usado la palabra incapacidad, a propósito. los comentarios siempre son fallos. debemos usarlos porque no siempre sabemos cómo expresarnos sin ellos pero su uso no es motivo de celebración. cuando tenga que escribir un comentario, piense si no existe otra forma de expresarse en el código. siempre que se exprese en el código, debe felicitarse. siempre que escriba un comentario, debe hacer un gesto de desaprobación y sentir su incapacidad para expresarse. ¿por qué estoy en contra de los comentarios? porque mienten. no siempre y no siempre intencionadamente, pero lo hacen. cuando más antiguo es un comentario y más se aleja del código que describe, mayor es la probabilidad de que sea equivocado. el motivo es sencillo. los programadores no los pueden mantener. el código cambia y evoluciona. los fragmentos cambian de lugar, se bifurcan, se reproducen y se vuelven a combinar para crear quimeras. desafortunadamente, los comentarios no siempre siguen el ritmo, no siempre pueden hacerlo y suelen separarse del código que describen y se convierten en huérfanos sin precisión alguna. por ejemplo, fíjese en lo que sucede con este comentario y la línea que pretendía describir: mockrequest request; private final string http_date_regexp = “[smtwf][a-z]{2}\\,\\s[0-9]{2}\\s[jfmasond][a-z]{2}\\s” + “[0-9]{4}\\s[0-9]{2}\\:[0-9]{2}\\:[0-9]{2}\\sgmt”; private response response; private fitnessecontext context; private fileresponder responder; private locale savelocale; // ejemplo: «tue, 02 apr 2003 22:18:49 gmt» seguramente se añadieron después otras variables de instancia entre la constante http_date_regexp y su comentario explicativo. se podría afirmar que los programadores deben ser lo bastante disciplinados como para mantener los comentarios actualizados, relevantes y precisos. de acuerdo, debería, pero esa energía debería invertirse en crear 88código claro y expresivo que no necesite comentario alguno. los comentarios imprecisos son mucho peor que la ausencia de comentarios. suelen confundir al usuario. generan expectativas que nunca se cumplen. definen reglas que no deben seguirse en absoluto. la verdad sólo se encuentra en un punto: el código. sólo el código puede contar lo que hace. es la única fuente de información precisa. por tanto, aunque los comentarios sean necesarios en ocasiones, dedicaremos nuestra energía a minimizarlos. los comentarios no compensan el código incorrecto una de las principales motivaciones para crear comentarios es el código incorrecto. creamos un módulo y sabemos que es confuso y está desorganizado. sabemos que es un desastre y entonces decidimos comentarlo. error. mejor límpielo. el código claro y expresivo sin apenas comentarios es muy superior al código enrevesado y complejo con multitud de comentarios. en lugar de perder tiempo escribiendo comentarios que expliquen el desastre cometido, dedíquelo a solucionarlo. explicarse en el código en ocasiones, el código es un pobre vehículo de expresión. desafortunadamente, muchos programadores lo entienden como que el código no es un buen medio de expresión. esto es falso. ¿qué prefiere ver? esto: // comprobar si el empleado tiene derecho a todos los beneficios if ((employee.flags & hourly_flag) && (employee.age > 65)) o esto otro: if (employee.iseligibleforfullbenefits()) apenas se tardan unos segundos en explicar nuestras intenciones en el código. en muchos casos, basta con crear una función que diga lo mismo que 89el comentario que pensaba escribir. comentarios de calidad algunos comentarios son necesarios o beneficiosos. veremos algunos de los que considero válidos. no obstante, recuerde que el único comentario realmente bueno es el que no tiene que escribir. comentarios legales en ocasiones, nuestros estándares corporativos de creación de código nos obligan a crear determinados comentarios por motivos legales. por ejemplo, los comentarios de derechos de autor son necesarios y deben incluirse al inicio de cada archivo. el siguiente encabezado de comentario se incluye de forma estándar al inicio de todos los archivos fuente de fitnesse. nuestro ide evita que este comentario parezca sobrante replegándolo de forma automática. // copyright (c) 2003,2004,2005 de object mentor, inc. todos los derechos reservados. // publicado bajo las condiciones de la licencia pública general gnu versión 2 o posterior. este tipo de comentarios no deben ser contratos ni tomos legales. siempre que sea posible, haga referencia a una licencia estándar o a otro documento externo en lugar de incluir todos los términos y condiciones en el comentario. comentarios informativos en ocasiones es útil proporcionar información básica con un comentario. por ejemplo, el siguiente comentario explica el valor devuelto por un método abstracto: // devuelve una instancia del elemento responder probado. protected abstract responder responderinstance(); estos comentarios pueden ser útiles, pero es mejor usar el nombre de la función para transmitir la información siempre que sea posible. por ejemplo, 90en este caso el comentario sería redundante si cambiamos el nombre de la función por responderbeingtested. veamos un ejemplo mejor: // el formato coincide con kk:mm:ss eee, mmm dd, yyyy pattern timematcher = pattern.compile( “\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*”); en este caso, el comentario nos indica que la expresión regular debe coincidir con una fecha y una hora con el formato aplicado por la función simpledateformat.format con la cadena de formato especificada. hubiera resultado mejor y más claro si el código se hubiera cambiado a una clase especial que convirtiera los formatos de fechas y horas. de ese modo el comentario habría sido superfluo. explicar la intención en ocasiones, un comentario es algo más que información útil sobre la implementación y proporciona la intención de una decisión. en el siguiente caso, vemos una interesante decisión documentada por un comentario. al comparar dos objetos, el autor decidió ordenar los objetos de su clase por encima de los objetos de otra. public int compareto(object o) { if (o instanceof wikipagepath) { wikipagepath p = (wikipagepath) o; string compressedname = stringutil.join(names, “”); string compressedargumentname = stringutil.join(p.names, “”); return compressedname.compareto(compressedargumentname); } return 1; // somos mayores porque somos el tipo correcto. } veamos otro ejemplo mejor. puede que no esté de acuerdo con la solución del programador, pero al menos sabe lo que intentaba hacer. public void testconcurrentaddwidgets() throws exception { widgetbuilder widgetbuilder = new widgetbuilder(new class[](boldwidget.class)); string text = “‘‘‘bold text’’’”; parentwidget parent = new boldwidget(new mockwidgetroot(), “‘‘‘bold text’’’”); atomicboolean failflag = new atomicboolean(); failflag.set(false); 91//nuestro mejor intento de obtener una condición de carrera //creando un gran número de procesos. for (int i = 0; i < 25000; i++) { widgetbuilderthread widgetbuiiderthread = new widgetbuilderthread(widgetbuilder, text, parent, failflag); thread thread = new thread(widgetbuilderthread); thread.start(); } assertequals(false, failflag.get()); } clarificación en ocasiones, basta con traducir el significado de un argumento o valor devuelto en algo más legible. por lo general, conviene buscar la forma de que el argumento o el valor devuelto sean claros por sí mismos; pero cuando forma parte de una biblioteca estándar o de código que no se puede alterar, un comentario aclarativo puede ser muy útil. public void testcompareto() throws exception { wikipagepath a = pathparser.parse(“pagea”); wikipagepath ab = pathparser.parse(“pagea.pageb”); wikipagepath b = pathparser.parse(“pageb”); wikipagepath aa = pathparser.parse(“pagea.pagea”); wikipagepath bb = pathparser.parse(“pageb.pageb”); wikipagepath ba = pathparser.parse(“pageb.pagea”); asserttrue(a.compareto(a) == 0); // a == a asserttrue(a.compareto(b) != 0); // a != b asserttrue(ab.compareto(ab) == 0); // ab == ab asserttrue(a.compareto(b) == -1); // a < b asserttrue(aa.compareto(ab) == -1); // aa < ab asserttrue(ba.compareto(bb) == -1); // ba < bb asserttrue(b.compareto(a) == 1); // b > a asserttrue(ab.compareto (aa) == 1); // ab > aa asserttrue(bb.compareto(ba) == 1); // bb > ba } pero también existe el riesgo de que un comentario aclarativo sea incorrecto. en el ejemplo anterior, compruebe lo difícil que resulta comprobar si los comentarios son correctos. esto explica por qué la clarificación es necesaria y también arriesgada. por ello, antes de escribir estos comentarios, asegúrese de que no hay una solución mejor y también de que sean precisos. 92advertir de las consecuencias en ocasiones es muy útil advertir a otros programadores de determinadas consecuencias. por ejemplo, el siguiente comentario explica por qué un determinado caso de prueba está desactivado: // no ejecutar a menos // que le sobre tiempo. public void _testwithreallybigfile() { writelinestofile(10000000); response.setbody(testfile); response.readytosend(this); string responsestring = output.tostring(); assertsubstring(“content-length: 1000000000”, responsestring); asserttrue(bytessent > 1000000000); } en la actualidad, evidentemente, desactivaríamos la prueba por medio del atributo @ignore con la correspondiente cadena explicativa: @ignore(“takes too long to run”) , pero antes de la aparición de junit 4, era habitual añadir un guion bajo delante del nombre del método. el comentario realizaba su cometido. veamos otro ejemplo: public static simpledateformat makestandardhttpdateformat() { //simpledataformat no es compatible con procesos, //por lo que debe crear cada instancia de forma independiente. simpledateformat df = new simpledateformat(“eee, dd mmm yyyy hh:mm:ss z”); df.settimezone (timezone.gettimezone (“gmt”)); return df; } seguramente conozca soluciones mejores para este problema. estoy de acuerdo, pero el comentario es perfectamente razonable. evita que un programador use un inicializador estático por motivos de eficacia. comentarios todo en ocasiones conviene usar notas con forma de comentarios //todo . en el 93siguiente caso, el comentario todo explica por qué la función tiene una implementación incorrecta y cuál debe ser su futuro. // todo-mdm no son necesarios // esperamos que desaparezca en el modelo definitivo protected versioninfo makeversion() throws exception { return null; } todo son tareas que el programador piensa que debería haber hecho pero que no es así. pueden ser un recordatorio para eliminar una función obsoleta o una petición para resolver un problema. pueden ser una solicitud para buscar un nombre más adecuado o para realizar un cambio que dependa de un evento planeado. sea lo que sea, no es excusa para mantener código incorrecto en el sistema. en la actualidad, muchos ide cuentan con funciones especiales para localizar comentarios todo , por lo que seguramente no se pierda. sin embargo, no colapse el código con estos comentarios. examínelos y elimine todos los que pueda. amplificación se puede usar un comentario para amplificar la importancia de algo que, en caso contrario, parecería irrelevante. string listitemcontent = match.group(3).trim(); // el recorte es importante. elimina los espacios iniciales // que harían que el elemento se reconociera como // otra lista. new listitemwidget(this, listitemcontent, this.level + 1); return buildlist(text.substring(match.end())); javadoc en api públicas no hay nada más útil y satisfactorio que una api pública bien descrita. los javadoc de la biblioteca estándar de java son un ejemplo. sería muy complicado crear programas de java sin ellos. si usa una api pública, debe crear javadoc de calidad para la misma, pero recuerde el siguiente consejo a lo largo del capítulo: los javadoc pueden ser 94tan ambiguos, amplios y descorteses como cualquier otro tipo de documento. comentarios incorrectos muchos comentarios pertenecen a esta categoría. suelen ser excusas de código pobre o justificaciones de decisiones insuficientes, algo así como si el programador se hablara a sí mismo. balbucear añadir un comentario sin razón o porque el proceso lo requiere es un error. si decide escribir un comentario, tómese el tiempo necesario para asegurarse de que sea el mejor que puede redactar. el siguiente ejemplo es de fitnesse, donde un comentario sin duda sería de utilidad, pero el autor tenía prisa o no prestó demasiada atención. su balbuceo generó un enigma: public void loadproperties() { try { string propertiespath = propertieslocation + “/” + properties_file; fileinputstream propertiesstream = new fileinputstream(propertiespath); loadedproperties.load(propertiesstream); } catch(ioexception e) { // si no hay archivos de propiedades significan que cargan las predeterminadas } } ¿qué significa el comentario del bloque catch ? seguro que algo para el autor, pero el significado no está claro. aparentemente, si se genera ioexception , significa que no hay archivo de propiedades y, en ese caso, se cargan los valores predeterminados. ¿pero quién carga los valores predeterminados? ¿se cargan antes de la invocación de loadproperties.load o loadproperties.load captura la excepción, carga los valores predeterminados y después nos pasa la excepción para que la ignoremos? ¿o será que loadproperties.load carga todos los valores 95predeterminados antes de intentar abrir el archivo? ¿intentaba el autor consolarse por dejar el bloque catch vacío? ésta es la posibilidad más temida, ¿se estaba diciendo que volviera más tarde para crear el código para cargar los valores predeterminados? nuestro único recurso es examinar el código en otras partes del sistema para determinar qué sucede. cualquier comentario que le obligue a buscar su significado en otro módulo ha fallado en su intento de comunicación y no merece los bits que consume. comentarios redundantes el listado 4-1 muestra una sencilla función con un comentario de encabezado totalmente redundante. seguramente se tarde más en leer que el propio código. listado 4-1 waitforclose. // método de utilidad devuelto cuando this.closed es true. genera una excepción // si se alcanza el tiempo de espera. public synchronized void waitforclose(final long timeoutmillis) throws exception { if (!closed) { wait(timeoutmillis); if(!closed) throw new exception (“mockresponsesender could not be closed”); } } ¿para qué sirve este comentario? no es más informativo que el código. no lo justifica ni transmite la intención ni la lógica. no es más fácil de leer que el código. de hecho, es menos preciso y obliga al lector a aceptar la falta de precisión en lugar de a entenderlo. es como un vendedor de coches de segunda menos que le asegura que no hace falta revisar el motor. fíjese ahora en la legión de javadoc inútiles y redundantes del listado 4- 2, obtenido de tomcat. estos comentarios únicamente ensucian y oscurecen el código. no tienen ninguna función documental. para empeorar las cosas, 96sólo le mostramos algunos. el módulo tiene muchos más. listado 4-2 containerbase.java (tomcat). public abstract class containerbase implements container, lifecycle, pipeline, mbeanregistration, serializable { /** * retardo del procesador para este componente. */ protected int backgroundprocessordelay = -1; /** * compatibilidad con eventos de ciclo vital de este componente. */ protected lifecyclesupport lifecycle = new lifecyclesupport(this); /** * escuchadores de eventos de contenedor de este contenedor. */ protected arraylist listeners = new arraylist(); /** * implementación loader a la que se asocia este contenedor. */ protected loader loader = null; /** * implementación logger a la que se asocia este contenedor. */ protected log logger = null; /** * nombre de registrador asociado. */ protected string logname = null; /** * implementación manager a la que se asocia este contenedor. */ protected manager manager = null; /** * clúster al que se asocia este contenedor. */ protected cluster cluster = null; /** * nombre legible de este contenedor. 97*/ protected string name = null; /** * contenedor principal de este contenedor. */ protected container parent = null; /** * cargador de clase principal que configurar al instalar un elemento * loader. */ protected classloader parentclassloader = null; /** * objeto pipeline al que se asocia este contenedor. */ protected pipeline pipeline = new standardpipeline(this); /** * objeto realm al que se asocia este contenedor. */ protected realm realm = null; /** * objeto dircontext de recursos al que se asocia este contenedor. */ protected dircontext resources = null; comentarios confusos en ocasiones, a pesar de las buenas intenciones, un programador realiza una afirmación en sus comentarios que no es del todo precisa. fíjese otra vez en el comentario redundante y confuso del listado 4-1. ¿sabe por qué es confuso? el método no devuelve nada cuando this.closed se convierte en true . devuelve algo si this.closed es true ; en caso contrario, espera y genera una excepción si this.closed no es true . este sutil fragmento, oculto en un comentario más difícil de leer que el cuerpo del código, puede hacer que otro programador invoque la función con la esperanza de que devuelva algo cuando this.closed sea true . ese pobre programador se encontrará en una sesión de depuración intentando determinar por qué el código se ejecuta tan lentamente. 98comentarios obligatorios es una locura tener una regla que afirme que todas las funciones deben tener un javadoc o que todas las variables deben tener un comentario. este tipo de comentarios ensucian el código y generan confusión y desorganización. por ejemplo, los javadoc obligatorios para todas las funciones crean abominaciones como el listado 4-3. no sirven de nada, complican el código y constituyen posibles engaños y desorientaciones. listado 4-3 /** * * @param title el título del cd * @param author el autor del cd * @param tracks el número de pistas del cd * @param durationinminutes la duración del cd en minutos */ public void addcd(string title, string author, int tracks, int durationinminutes) { cd cd = new cd(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = duration; cdlist.add(cd); } comentarios periódicos en ocasiones, se añade un comentario al inicio de un módulo cada vez que se edita. estos comentarios acumulan una especie de registro de todos los cambios realizados. he visto módulos con decenas de páginas con estas entradas. * cambios (11-oct-2001) * ----------------------------- * 11-oct- 2001 : reorganización de la clase y cambio a un nuevo paquete * com.jrefinery.date (dg); * 05-nov- 2001 : se añade un método getdescription() y se elimina la clase notabledate (dg); 99* 12-nov- 2001 : ibd requiere el método setdescription(), una vez eliminada la clase notabledate * (dg); se cambian getpreviousdayofweek(), getfollowingdayofweek() * y getnearestdayofweek() para corregir errores (dg); * 05-dic- 2001 : error corregido en la clase spreadsheetdate (dg); * 29-may- 2002 : se transfieren todas las constantes de mes a una interfaz * independiente (monthconstants) (dg); * 27-ago- 2002 : error corregido en el método addmonths(), gracias a nálevka petr (dg); * 03-oct- 2002 : errores indicados por checkstyle (dg) corregidos; * 13-mar- 2003 : implementación de serializable (dg); * 29-may- 2003 : error corregido en el método addmonths (dg); * 04-sep- 2003 : implementación de comparable. actualización de los javadoc isinrange (dg); * 05-ene- 2005 : error corregido en el método addyears() (1096202) (dg); hace tiempo hubo una buena razón para crear y mantener estas entradas de registro al inicio de cada módulo. carecíamos de sistemas de control de código fuente que se encargaran de ello, pero en la actualidad, estas entradas son elementos sobrantes que complican los módulos. debe eliminarlas totalmente. comentarios sobrantes en ocasiones vemos comentarios que simplemente sobran. restan importancia a lo evidente y no ofrecen información nueva. /** * constructor predeterminado. */ protected annualdaterule() { } ¿en serio? ¿y este otro?: /** día del mes. */ private int dayofmonth; y aquí el parangón de la redundancia: /** * devuelve el día del mes. 100* * @return el día del mes. */ public int getdayofmonth() { return dayofmonth; } estos comentarios son tan inservibles que aprendemos a ignorarlos. al leer el código, la vista los salta. con el tiempo, los comentarios empiezan a mentir cuando cambia el código que les rodea. el primer comentario del listado 4-4 parece correcto [25] . explica por qué se ignora el bloque catch , pero el segundo comentario sobra. parece que el programador estaba tan frustrado con crear bloques try/catch en la función que necesitaba explotar. listado 4-4 startsending. private void startsending() { try { dosending(); } catch(socketexception e) { // normal, alguien ha detenido la solicitud. } catch(exception e) { try { response.add(errorresponder.makeexceptionstring(e)); response.closeall(); } catch(exception e1) { //¡un respiro! } } } en lugar de explotar en un comentario sin sentido, el programador debería haber sabido que su frustración se podría aliviar mejorando la estructura del código. tendría que haber centrado su energía en extraer el último bloque try/catch en una función independiente, como muestra el 101listado 4-5. listado 4-5 startsending (refactorizado). private void startsending() { try { dosending(); } catch(socketexception e) { // normal. alguien ha detenido la solicitud. } catch(exception e) { addexceptionandcloseresponse(e); } } private void addexceptionandcloseresponse(exception e) { try { response.add(errorresponder.makeexceptionstring(e)); response.closeall(); } catch(exception e1) { } } cambie la tentación de crear elementos sobrantes por la determinación de limpiar su código. mejorará como programador y será más fácil. comentarios sobrantes espeluznantes los javadoc también pueden ser innecesarios. ¿para qué sirven los siguientes javadoc (de una conocida biblioteca) de código abierto? la respuesta: para nada. son comentarios redundantes creados en un intento equivocado de redactar documentación. /** el nombre. */ private string name; /** la versión. */ 102private string version; /** el licencename. */ private string licencename; /** la versión. */ private string info; vuelva a leer los comentarios. ¿detecta el error de corta y pega? si los autores no prestan atención al escribir sus comentarios (o al pegarlos), ¿por qué se espera que sean de utilidad para los lectores? no usar comentarios si se puede usar una función o una variable fíjese en el siguiente código: // ¿el módulo de la lista global <mod> depende del // subsistema del que formamos parte? if (smodule.getdependsubsystems().contains(subsysmod.getsubsystem())) se podría cambiar sin el comentario de esta forma: arraylist moduledependees = smodule.getdependsubsystems(); string oursubsystem = subsysmod.getsubsystem(); if (moduledependees.contains(oursubsystem)) el autor del código original seguramente escribió primero el comentario (improbable) y después el código para ajustarlo al comentario. sin embargo, el autor tendría que haber refactorizado el código, como hice yo, para poder eliminar el comentario. marcadores de posición en ocasiones los programadores marcan una determinada posición en un archivo. por ejemplo, recientemente encontré esto en un programa: // acciones ////////////////////////////////// son escasas las ocasiones en las que tiene sentido agrupar funciones bajo esta estructura. por lo general, debe eliminarse, sobre todo la molesta hilera de barras al final. piénselo de esta forma. estas estructuras son atractivas si no las usa demasiado. por ello, úselas esporádicamente y sólo cuando el beneficio sea 103significativo. si las usa en exceso, acabarán por ser ignoradas. comentarios de llave de cierre en ocasiones, los programadores incluyen comentarios especiales en llaves de cierre, como en el listado 4-6. aunque pueda tener sentido en funciones extensas con estructuras anidadas, únicamente estorba a las funciones encapsuladas y de pequeño tamaño que nos gustan. por ello, si siente el deseo de marcar sus llaves de cierre, pruebe a reducir el tamaño de sus funciones. listado 4-6 wc.java. public class wc { public static void main(string[] args) { bufferedreader in = new bufferedreader(new inputstreamreader(system.in)); string line; int linecount = 0; int charcount = 0; int wordcount = 0; try { while ((line = in.readline()) != null) { linecount++; charcount += line.length(); string words[] = line.split(“\\w”); wordcount += words.length; } //while system.out.println(“wordcount = ” + wordcount); system.out.println(“linecount = ” + linecount); system.out.println(“charcount = ” + charcount); } // try catch (ioexception e) { system.err.println(“error: ” + e.getmessage()); } //catch } //main } asignaciones y menciones /* añadido por rick */ los sistemas de control de código fuente recuerdan a la perfección quién ha añadido qué y cuándo. no es necesario plagar el código con pequeñas 104menciones. puede pensar que estos comentarios son útiles y que ayudan a otros a hablar sobre el código, pero en realidad sobreviven durante años y cada vez son menos precisos y relevantes. el sistema de control de código fuente es el punto idóneo para este tipo de información. código comentado no hay nada más odioso que el código comentado. ¡no lo haga! inputstreamresponse response = new inputstreamresponse(); response.setbody(formatter.getresultstream(), formatter.getbytecount()); // inputstream resultsstream = formatter.getresultstream(); // streamreader reader = new streamreader(resultsstream); // response.setcontent(reader.read(formatter.getbytecount())); los lectores que vean código comentado no tendrán el valor de borrarlo. pensarán que está ahí por algo y que es demasiado importante para borrarlo. por ello, el código comentado se acumula como los sedimentos en una botella de vino malo. fíjese en este fragmento de apache commons: this.bytepos = writebytes(pngidbytes, 0); //hdrpos = bytepos; writeheader(); writeresolution(); //datapos = bytepos; if (writeimagedata()) { writeend(); this.pngbytes = resizebytearray(this.pngbytes, this.maxpos); } else { this.pngbytes = null; } return this.pngbytes; ¿por qué hay dos líneas comentadas? ¿son importantes? ¿se han conservado como recordatorio de un cambio inminente o es algo que alguien comentó hace años y no se ha preocupado de limpiar? hubo una época, en la década de 1960, en la que el código comentado pudo ser útil, pero hace tiempo que contamos con buenos sistemas de control de código fuente, sistemas que recuerdan el código por nosotros. ya no tenemos que comentarlo. elimínelo. no lo perderá. se lo aseguro. 105comentarios html el html en comentarios de código fuente es una aberración, como puede apreciar en el siguiente fragmento. dificulta la lectura de los comentarios donde debería ser más fácil; el editor o ide. si los comentarios se van a extraer con una herramienta (como javadoc) para mostrarlos en una página web, debe ser responsabilidad de dicha herramienta y no del programador el adornar los comentarios con el correspondiente html. /** * tarea para ejecutar pruebas de aceptación. * esta tarea ejecuta pruebas de aceptación y publica los resultados. * <p/> * <pre> * uso: * &lt;taskdef name=&quot;execute-fitnesse-tests&quot; * classname=&quot;fitnesse.ant.executefitnesseteststask&quot; * classpathref=&quot;classpath&quot; /&gt; * or * &lt;taskdef classpathref=&quot;classpath&quot; * resource=&quot;tasks.properties&quot; /&gt; * <p/> * &lt;execute-fitnesse-tests * suitepage=&quot;fitnesse.suiteacceptancetests&quot; * fitnesseport=&quot;8082&quot; * resultsdir=&quot;$(results.dir)&quot; * resultshtmlpage=&quot;fit-results.html&quot; * classpathref=&quot;classpath&quot; /&gt; * </pre> */ información no local si tiene que escribir un comentario, asegúrese de que describa el código que le rodea. no ofrezca información global del sistema en el contexto de un comentario local. fíjese en el siguiente comentario javadoc. aparte de su terrible redundancia, también ofrece información sobre el puerto predeterminado y la función no tiene control alguno sobre el puerto predeterminado. el comentario no describe la función sino otra parte distinta 106del sistema. evidentemente, no hay garantías de que el comentario cambie cuando lo haga el código que contiene el valor predeterminado. /** * puerto para ejecutar fitnesse. el predeterminado es <b>8082</b>. * * @param fitnesseport */ public void setfitnesseport(int fitnesseport) { this.fitnesseport = fitnesseport; } demasiada información no incluya en sus comentarios interesantes reflexiones históricas ni irrelevantes descripciones de detalles. el siguiente comentario se ha extraído de un módulo diseñado para probar que una función puede codificar y descodificar base64. aparte del número rfc, el lector de este código no necesita la información obsoleta que contiene el comentario. /* rfc 2045 - extensiones multipropósito de correo de internet (mime) primera parte: formato del cuerpo de los mensajes de internet sección 6.8. codificación de transferencia de contenidos base64 el proceso de codificación representa grupos de 24 bits de la entrada como cadenas de salida de 4 caracteres codificados. procediendo de izquierda a derecha, se forma un grupo de 24 bits de entrada concatenando 3 grupos de 8 bits de entrada. estos 24 bits se tratan como 4 grupos concatenados de 6 bits, cada uno de los cuales se traduce en un solo dígito del alfabeto base64. cuando se codifica un flujo de bits mediante la codificación base64, el flujo de bits se debe considerar ordenado con el bit más significativo primero. esto es, el primer bit del flujo será el bit de orden más alto en el primer byte de 8 bits, y el octavo bit será el de orden más bajo en el primer byte de 8 bits, y así sucesivamente. */ conexiones no evidentes la conexión entre un comentario y el código que describe debe ser evidente. si se ha preocupado de escribir un comentario, lo mínimo es que el lector que lo vea entienda a qué se refiere. fíjese en este comentario obtenido de apache commons: 107/* * comienza con una matriz de tamaño suficiente para albergar todos los pixeles * (más bytes de filtro), y 200 bytes adicionales para la información de encabezado */ this.pngbytes = new byte[((this.width + 1) * this.height * 3) + 200]; ¿qué es un byte de filtro? ¿está relacionado con +1 ? ¿o con *3 ? ¿con ambos? ¿es un pixel un byte ? ¿por qué 200? la función de un comentario es explicar código que no se explica por sí mismo. es una lástima que un comentario requiera su propia explicación. encabezados de función las funciones breves apenas requieren explicación. un nombre bien elegido para una función que hace una cosa suele ser mejor que un encabezado de comentario. javadocs en código no público a pesar de la utilidad de los javadoc para las api públicas, no sirven para código no dirigido a consumo público. la generación de páginas javadoc para clases y funciones de un sistema no suele ser útil y la formalidad adicional de los comentarios javadoc no es más que una distracción. ejemplo escribí el módulo del listado 4-7 para la primera versión de xp immersion . debía ser un ejemplo de estilo incorrecto de creación de código y comentarios. después, kent beck refactorizó este código en algo mucho más atractivo delante de varios alumnos. posteriormente, adapté el ejemplo para mi libro agile software development, principles, patterns, and practices y para el primero de mis artículos craftsman publicados en la revista software development . lo que me fascina de este módulo es que hubo un tiempo en que muchos 108lo hubiéramos considerado bien documentado. ahora vemos que es un auténtico desastre. a ver cuántos problemas detecta en los comentarios. listado 4-7 generateprimes.java. /** * esta clase genera números primos hasta la cantidad máxima especificada por el * usuario. el algoritmo usado es la criba de eratóstenes. * <p> * eratóstenes de cirene, 276 a. c., cirene, libia - * 194 a. c., alejandría. el primer hombre en calcular la * circunferencia de la tierra. también trabajó con calendarios * con años bisiestos y fue responsable de la biblioteca de alejandría. * <p> * el algoritmo es muy simple. dada una matriz de enteros * empezando por el 2, se tachan todos los múltiplos de 2. se busca el siguiente * entero sin tachar y se tachan todos sus múltiplos. * repetir hasta superar la raíz cuadrada del valor * máximo. * * ©author alphonse * ©version 13 feb 2002 atp */ import java.util.*; public class generateprimes { /** * @param maxvalue es el límite de generación. */ public static int[] generateprimes(int maxvalue) { if (maxvalue >= 2) //el único caso válido { // declaraciones int s = maxvalue + 1; // tamaño de la matriz boolean[] f = new boolean[s]; int i; // inicializar la matriz en true. for (i = 0; i < s; i++) f[i] = true; // eliminar los números no primos conocidos f[0] = f[1] = false; // cribar int j; 109for (i = 2; i < math.sqrt(s) + 1; i++) { if (f[i]) // si no está tachado, tachar sus múltiplos. { for (j = 2 * i; j < s; j += i) f[j] = false; // el múltiplo no es primo } } // ¿cuántos primos hay? int count = 0; for (i = 0; i < s; i++) { if (f[i]) count++; // contador. } int[] primes = new int[count]; // enviar primos al resultado for (i = 0, j = 0; i < s; i++) { if (f[i]) // si es primo primes[j++] = i; } return primes; // devolver los primos } else // maxvalue < 2 return new int[0]; // devolver matriz null si la entrada no es correcta. } } en el listado 4-8 puede ver una versión refactorizada del mismo módulo. se ha limitado considerablemente el uso de comentarios. hay sólo dos en todo el módulo y ambos claramente descriptivos. listado 4-8 primegenerator.java (refactorizado). /** * esta clase genera números primos hasta la cantidad máxima especificada por el * usuario. el algoritmo usado es la criba de eratóstenes. dada una matriz de enteros * empezando por el 2: buscar el primer entero sin tachar y tachar todos sus * múltiplos. repetir hasta que no haya más múltiplos en la matriz. */ public class primegenerator { 110private static boolean[] crossedout; private static int[] result; public static int[] generateprimes(int maxvalue) { if (maxvalue < 2) return new int[0]; else { uncrossintegersupto(maxvalue); crossoutmultiples(); putuncrossedintegersintoresult(); return result; } } private static void uncrossintegersupto(int maxvalue) { crossedout = new boolean[maxvalue + 1]; for (int i = 2; i < crossedout.length; i++) crossedout[i] = false; } private static void crossoutmultiples() { int limit = determineiterationlimit(); for (int i = 2; i <= limit; i++) if (notcrossed(i)) crossoutmultiplesof(i); } private static int determineiterationlimit() { // cada múltiplo en la matriz tiene un factor primordial que // es menor o igual que la raíz del tamaño de la matriz, // entonces no tenemos que tachar múltiplos de números // más grande que esa raíz. double iterationlimit = math.sqrt(crossedout.length); return (int) iterationlimit; } private static void crossoutmultiplesof (int i) { for (int multiple = 2 * i; multiple < crossedout.length; multiple += i) crossedout[multiple] = true; } private static boolean notcrossed(int i) { return crossedout[i] == false; } private static void putuncrossedintegersintoresult() 111{ result = new int[numberofuncrossedintegers()]; for (int j = 0, i = 2; i < crossedout.length; i++) if (notcrossed(i)) result[j++] = i; } private static int numberofuncrossedintegers() { int count = 0; for (int i = 2; i < crossedout.length; i++) if (notcrossed(i)) count++; return count; } } se podría decir que el primer comentario es redundante ya que es muy similar a la función generateprimes , pero creo que muestra mejor el algoritmo al lector, motivo por el que lo he mantenido. el segundo argumento es sin duda necesario. explica la lógica del uso de la raíz cuadrada como límite del bucle. no encontré otro nombre de variable más sencillo ni otra estructura de código que lo aclarara más. por otra parte, el uso de la raíz cuadrada podría resultar presuntuoso. ¿realmente se ahorra tanto tiempo limitando la iteración a la raíz cuadrada? ¿el cálculo de la raíz cuadrada llevaría más tiempo del que se ahorra? conviene analizarlo. el uso de la raíz cuadrada como límite de iteración satisface al viejo hacker de c y de lenguajes de ensamblado de mi interior, pero no estoy convencido de que merezca el tiempo y el esfuerzo que los demás puedan dedicar a entenderlo. bibliografía [kp78] : kernighan and plaugher, the elements of programming style , 2d. ed., mcgraw-hill, 1978. 1125 formato cuando los usuarios miran entre bastidores, queremos que queden 113impresionados por el atractivo, la coherencia y la atención al detalle que perciben. queremos que el orden les sorprenda, que abran los ojos con asombro cuando se desplacen por los módulos. queremos que aprecien que se trata de un trabajo de profesionales. si ven una masa amorfa de código que parece escrito por un grupo de marineros borrachos, es probable que piensen que sucederá lo mismo en otros aspectos del proyecto. debe preocuparse por el formato de su código. debe elegir una serie de reglas sencillas que controlen el formato del código y después aplicarlas de forma coherente. si trabaja en equipo, debe acordar una serie de reglas que todos los miembros deben cumplir. también es muy útil usar una herramienta automatizada que se encargue de aplicar las reglas. la función del formato en primer lugar, debe ser claro. el formato de código es importante, demasiado importante como para ignorarlo y también demasiado importante como para tratarlo de forma religiosa. el formato del código se basa en la comunicación y la comunicación debe ser el principal pilar de un desarrollador profesional. puede que piense que conseguir que algo funcione es la principal preocupación de un programador profesional. espero que este libro le haga cambiar de idea. la funcionalidad que cree hoy es muy probable que cambie en la siguiente versión, pero la legibilidad de su código afectará profundamente a todos los cambios que realice. el estilo del código y su legibilidad establecen los precedentes que afectan a la capacidad de mantenimiento y ampliación mucho después de que el código cambie. su estilo y su disciplina sobrevivirán, aunque el código no lo haga. veamos qué aspectos del formato nos permiten comunicarnos mejor. formato vertical comencemos por el tamaño vertical. ¿qué tamaño debe tener un archivo 114fuente? en java, el tamaño de los archivos está relacionado con el tamaño de las clases, como veremos más adelante. por el momento, nos detendremos en el tamaño de los archivos. ¿qué tamaño tienen la mayoría de archivos fuente de java? existe una amplia gama de tamaños e importantes diferencias de estilo, como se aprecia en la figura 5.1. figura 5.1. escala log de distribuciones de longitud de archivos (altura del cuadro = sigma). se describen siete proyectos: junit, fitnesse, testng, time and money, jdepend, ant y tomcat. las líneas que cruzan los cuadros muestran la longitud máxima y mínima de cada proyecto. el cuadro muestra aproximadamente un tercio (una desviación estándar [26] ) de los archivos. la parte central del cuadro es la media. por tanto, el tamaño de archivo medio del proyecto fitnesse es de 65 líneas y un tercio de los archivos ocupan entre 40 y 100+ líneas. el mayor archivo de fitnesse tiene unas 400 líneas y el de menor tamaño, 6. es una escala de registro, de modo que la pequeña diferencia de posición vertical supone una gran diferencia en tamaño absoluto. junit, fitnesse y time and money tienen archivos relativamente pequeños. ninguno supera las 500 líneas y la mayoría tienen menos de 200. tomcat y ant, por su parte, tienen archivos con varios miles de líneas de 115longitud y más de la mitad superan las 200. ¿qué significa todo esto? aparentemente se pueden crear sistemas (fitnesse se aproxima a las 50 000 líneas) a partir de archivos de unas 200 líneas de longitud, con un límite máximo de 500. aunque no debería ser una regla, es un intervalo aconsejable. los archivos de pequeño tamaño se entienden mejor que los grandes. la metáfora del periódico piense en un artículo de periódico bien escrito. en la parte superior espera un titular que indique de qué se trata la historia y le permita determinar si quiere leerlo o no. el primer párrafo ofrece una sinopsis de la historia, oculta los detalles y muestra conceptos generales. al avanzar la lectura, aumentan los detalles junto con todas las fechas, nombres, citas y otros elementos. un archivo de código debe ser como un artículo de periódico. el nombre debe ser sencillo pero claro. por sí mismo, debe bastar para indicarnos si estamos o no en el módulo correcto. los elementos superiores del archivo deben proporcionar conceptos y algoritmos de nivel superior. los detalles deben aumentar según avanzamos, hasta que en la parte final encontremos las funciones de nivel inferior del archivo. un periódico se compone de varios artículos, algunos muy reducidos y otros de gran tamaño. no hay muchos que ocupen toda la página con texto, para que el periódico sea manejable. si el periódico fuera un único y extenso texto con una aglomeración desorganizada de hechos, fechas y nombres, no lo leeríamos. apertura vertical entre conceptos la práctica totalidad del código se lee de izquierda a derecha y de arriba a abajo. cada línea representa una expresión o una cláusula, y cada grupo de líneas representa un pensamiento completo. estos pensamientos deben separarse mediante líneas en blanco. fíjese en el listado 5-1. hay líneas en blanco que separan la declaración 116del paquete, las importaciones y las funciones. es una regla muy sencilla con un profundo efecto en el diseño visual del código. cada línea en blanco es una pista visual que identifica un nuevo concepto independiente. al avanzar por el listado, la vista se fija en la primera línea que aparece tras una línea en blanco. listado 5-1 boldwidget.java package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = “‘‘‘.+?’’’”; private static final pattern pattern = pattern.compile (“‘‘‘(.+?)’’’”, pattern.multiline + pattern.dotall ); public boldwidget(parentwidget parent, string text) throws exception { super(parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group(1)); } public string render() throws exception { stringbuffer html = new stringbuffer(“<b>”); html.append(childhtml()).append (“</b>”); return html.tostring(); } } si eliminamos las líneas en blanco, como en el listado 5-2, se oscurece la legibilidad del código. listado 5-2 boldwidget.java package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = “‘‘‘.+?’’’”; private static final pattern pattern = pattern.compile(“‘‘‘(.+?)’’’”, pattern.multiline + pattern.dotall); public boldwidget(parentwidget parent, string text) throws exception { 117super(parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group(1));} public string render() throws exception { stringbuffer html = new stringbuffer(“<b>”); html.append(childhtml()).append(“</b>”); return html.tostring(); } } este efecto aumenta todavía más si no centramos la vista. en el primer ejemplo, los distintos grupos de líneas saltan a la vista, mientras que en el segundo es una mezcla amorfa. la diferencia entre ambos listados es una ligera apertura vertical. densidad vertical si la apertura separa los conceptos, la densidad vertical implica asociaciones. por tanto, las líneas de código con una relación directa deben aparecer verticalmente densas. fíjese en cómo los comentarios sin sentido del listado 5-3 anulan la asociación entre las dos variables de instancia. listado 5-3 public class reporterconfig { /** * nombre de clase del escuchador */ private string m_classname; /** * propiedades del escuchador */ private list<property> m_properties = new arraylist<property>(); public void addproperty(property property) { m_properties.add(property); } el listado 5-4 es mucho más fácil de leer. lo apreciamos a simple vista o al menos yo lo hago. al mirarlo, veo que es una clase con dos variables y un método, sin tener que mover la cabeza ni la vista. el listado anterior nos 118obliga a forzar la vista y a mover la cabeza para alcanzar el mismo nivel de comprensión. listado 5-4 public class reporterconfig { private string m_classname; private list<property> m_properties = new arraylist<property>(); public void addproperty(property property) { m_properties.add(property); } distancia vertical ¿alguna vez ha tenido que recorrer una clase, saltando de una función a otra, desplazándose por el código para intentar adivinar la relación y el funcionamiento de las funciones, y acabar totalmente confundido? ¿alguna vez ha escudriñado la cadena de herencia buscando la definición de una variable o función? resulta frustrante porque intenta comprender lo que hace el sistema, pero pierde el tiempo y su energía mental en intentar localizar y recordar sus elementos. los conceptos relacionados entre sí deben mantenerse juntos verticalmente [g10]. esta regla no funciona con conceptos de archivos independientes. por lo tanto, no debe separar conceptos relacionados en archivos independientes a menos que tenga un motivo de peso. de hecho, es uno de los motivos por los que se debe evitar el uso de variables protegidas. para los conceptos relacionados que pertenecen al mismo archivo, su separación vertical debe medir su importancia con respecto a la legibilidad del otro. debe evitar que el lector deambule entre archivos y clases. declaraciones de variables las variables deben declararse de la forma más aproximada a su uso. como las funciones son muy breves, las variables locales deben aparecer en la parte superior de cada función, como en este ejemplo de junit4.3.1. 119private static void readpreferences() { inputstream is = null; try { is = new fileinputstream(getpreferencesfile()); setpreferences(new properties(getpreferences())); getpreferences().load(is); } catch (ioexception e) { try { if (is != null) is.close(); } catch (ioexception e1) { } } } las variables de control de bucles deben declararse en la instrucción del bucle, como en esta pequeña función del mismo código fuente: public int counttestcases() { int count= 0; for ( test each : tests) count += each.counttestcases(); return count; } en casos excepcionales, una variable puede declararse en la parte superior de un bloque o antes de un bucle en una función extensa. puede ver este tipo de variable en la siguiente función de testng. … for (xmltest test: m_suite.gettests()) { testrunner tr = m_runnerfactory.newtestrunner(this, test); tr.addlistener(m_textreporter); m_testrunners.add(tr); invoker = tr.getinvoker(); for (itestngmethod m : tr.getbeforesuitemethods()) { beforesuitemethods.put(m.getmethod(), m); } for (itestngmethod m : tr.getaftersuitemethods()) { aftersuitemethods.put(m.getmethod(), m); } } … variables de instancia las variables de instancia, por su parte, deben declararse en la parte superior de la clase. esto no debe aumentar la distancia vertical de las variables, ya 120que en una clase bien diseñada se usan en muchos sino en todos sus métodos. existen discrepancias sobre la ubicación de las variables de instancia. en c++ suele aplicarse la denominada regla de las tijeras, que sitúa todas las variables de instancia en la parte inferior. en java, sin embargo, es habitual ubicarlas en la parte superior de la clase. no veo motivos para no hacerlo. lo importante es declarar las variables de instancia en un punto conocido para que todo el mundo sepa dónde buscarlas. fíjese en el extraño caso de la clase testsuite de junit 4.3.1. he atenuado considerablemente esta clase para ilustrar este concepto. si se fija en la mitad del listado, verá dos variables de instancia declaradas. resultaría complicado ocultarlas en un punto mejor. cualquiera que lea este código tendría que toparse con las declaraciones por casualidad (como me pasó a mí). public class testsuite implements test { static public test createtest(class<? extends testcase> theclass, string name) { … } public static constructor<? extends testcase> gettestconstructor(class<? extends testcase> theclass) throws nosuchmethodexception { … } public static test warning(final string message) { … } private static string exceptiontostring(throwable t) { … } private string fname; private vector<test> ftests = new vector<test>(10); public testsuite() { } public testsuite(final class<? extends testcase> theclass) { … } public testsuite(class<? extends testcase> theclass, string name) { … } 121… … … … } funciones dependientes si una función invoca otra, deben estar verticalmente próximas, y la función de invocación debe estar por encima de la invocada siempre que sea posible. de este modo el programa fluye con normalidad. si la convención se sigue de forma fiable, los lectores sabrán que las definiciones de función aparecen después de su uso. fíjese en el fragmento de fitnesse del listado 5-5. la función superior invoca las situadas por debajo que, a su vez, invocan a las siguientes. esto facilita la detección de las funciones invocadas y mejora considerablemente la legibilidad del módulo completo. listado 5-5 wikipageresponder.java. public class wikipageresponder implements secureresponder { protected wikipage page; protected pagedata pagedata; protected string pagetitle; protected request request; protected pagecrawler crawler; public response makeresponse(fitnessecontext context, request request) throws exception { string pagename = getpagenameordefault(request, “frontpage”); loadpage(pagename, context); if (page == null) return notfoundresponse(context, request); else return makepageresponse(context); } private string getpagenameordefault(request request, string defaultpagename) { string pagename = request.getresource(); if (stringutil.isblank(pagename)) pagename = defaultpagename; return pagename; } protected void loadpage(string resource, fitnessecontext context) throws exception { wikipagepath path = pathparser.parse(resource); 122crawler = context.root.getpagecrawler(); crawler.setdeadendstrategy(new virtualenabledpagecrawler()); page = crawler.getpage(context.root, path); if (page != null) pagedata = page.getdata(); } private response notfoundresponse(fitnessecontext context, request request) throws exception { return new notfoundresponder().makeresponse(context, request); } private simpleresponse makepageresponse(fitnessecontext context) throws exception { pagetitle = pathparser.render(crawler.getfullpath(page)); string html = makehtml(context); simpleresponse response = new simpleresponse(); response.setmaxage(0); response.setcontent(html); return response; } … además, este fragmento es un buen ejemplo de ubicación de constantes en un nivel correcto [g35]. la constante frontpage se podría haber ocultado en la función getpagenameordefault , pero eso habría ocultado una constante conocida y esperada en una función de nivel inferior de forma incorrecta. es mejor pasar la constante desde un punto en el que tiene sentido a la posición en la que realmente se usa. afinidad conceptual determinados conceptos de código deben estar próximos a otros. tienen una afinidad conceptual concreta. cuanto mayor sea esta afinidad, menor distancia vertical debe existir entre ellos. como hemos visto, esta afinidad se puede basar en una dependencia directa, como cuando una función invoca a otra, o cuando usa una variable. pero hay otras causas de afinidad. puede generarse porque un grupo de funciones realice una operación similar. fíjese en este fragmento de código de junit 4.3.1: public class assert { static public void asserttrue(string message, boolean condition) { 123if (!condition) fail(message); } static public void asserttrue(boolean condition) { asserttrue (null, condition); } static public void assertfalse(string message, boolean condition) { asserttrue(message, !condition); } static public void assertfalse(boolean condition) { assertfalse(null, condition); } … estas funciones tienen una elevada afinidad conceptual ya que comparten un sistema de nombres común y realizan variantes de la misma tarea básica. el hecho de que se invoquen unas a otras es secundario. aunque no lo hicieran, deberían seguir estando próximas entre ellas. orden vertical por lo general, las dependencias de invocaciones de funciones deben apuntar hacia abajo. es decir, la función invocada debe situarse por debajo de la que realice la invocación [27] . esto genera un agradable flujo en el código fuente, de los niveles superiores a los inferiores. como sucede en los artículos del periódico, esperamos que los conceptos más importantes aparezcan antes y que se expresen con la menor cantidad de detalles sobrantes. esperamos que los detalles de nivel inferior sean los últimos. de este modo, podemos ojear los archivos de código y captar el mensaje en las primeras funciones sin necesidad de sumergirnos en los detalles. el listado 5-5 se organiza de esta forma. puede que otros ejemplos mejores sean los listados 15-5 y 3-7. formato horizontal 124¿qué ancho debe tener una línea? para responderlo, fíjese en la anchura de las líneas de un programa convencional. de nuevo, examinamos siete proyectos diferentes. en la figura 5.2 puede ver la distribución de longitud de todos ellos. la regularidad es impresionante, en especial en tomo a los 45 caracteres. de hecho, los tamaños entre 20 y 60 representan un uno por cien del número total de líneas. ¡eso es un 40 por 100! puede que otro 30 por 100 sea menos de 10 caracteres de ancho. recuerde que es una escala de registro, de modo que la apariencia lineal es muy significativa. es evidente que los programadores prefieren líneas menos anchas. figura 5.2. distribución de anchura de líneas en java. esto sugiere que debemos intentar reducir las líneas de código. el antiguo límite hollerith de 80 es un tanto arbitrario y no me opongo a líneas que tienen 100 o incluso 120, pero no más. como norma, no debe tener que desplazarse hacia la derecha. los monitores modernos son más anchos y los programadores noveles pueden reducir la fuente para encajar hasta 200 caracteres en la pantalla. no lo haga. mi límite personal es de 120. apertura y densidad horizontal 125usamos el espacio en blanco horizontal para asociar elementos directamente relacionados y separar otros con una relación menos estrecha. fíjese en la siguiente función: private void measureline(string line) { linecount++; int linesize = line.length(); totalchars += linesize; linewidthhistogram.addline(linesize, linecount); recordwidestline(linesize); } hemos rodeado los operadores de asignación con espacios en blanco para destacarlos. las instrucciones de asignación tienen dos elementos principales: el lado izquierdo y el derecho. los espacios acentúan esta separación. por otra parte, no hemos incluido espacios entre los nombres de las funciones y el paréntesis de apertura, ya que la función y sus argumentos están estrechamente relacionados. su separación los desconectaría. separo los argumentos en los paréntesis de invocación de la función para acentuar la coma e indicar que los argumentos son independientes. el espacio en blanco también se usa para acentuar la precedencia de los operadores: public class quadratic { public static double root1(double a, double b, double c) { double determinant = determinant(a, b, c); return (-b + math.sqrt(determinant)) / (2*a); } public static double root2(int a, int b, int c) { double determinant = determinant(a, b, c); return (-b - math.sqrt(determinant)) / (2*a); } private static double determinant(double a, double b, double c) { return b*b - 4*a*c; } } fíjese en lo bien que se leen las ecuaciones. los factores carecen de espacios en blanco ya que tienen una mayor precedencia. los términos se separan mediante espacios en blanco ya que la suma y la resta son de precedencia inferior. desafortunadamente, muchas herramientas de formato de código ignoran la precedencia de los operadores e imponen un espaciado uniforme. por ello, separaciones sutiles como las anteriores suelen perderse tras modificar el 126formato del código. alineación horizontal cuando era programador de lenguajes de ensamblado [28] , usaba la alineación horizontal para acentuar determinadas estructuras. cuando comencé a programar en c, c++ y java, seguía intentando alinear los nombres de variables en un conjunto de declaraciones o todos los valores en un grupo de instrucciones de asignación. el aspecto de mi código era el siguiente: public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long requestprogress; private long requestparsingdeadline; private boolean haserror; public fitnesseexpediter( socket s, fitnessecontext context) throws exception { this.context = context; socket = s; input = s.getinputstream(); output = s.getoutputstream(); requestparsingtimelimit = 10000; } sin embargo, este tipo de alineación no es útil. parece enfatizar los elementos incorrectos y aleja la vista de la verdadera intención. por ejemplo, en la lista anterior de declaraciones, nos vemos tentados a leer la lista de nombres de variables sin fijarnos en sus tipos. del mismo modo, en la lista de instrucciones de asignación, nos fijamos en los valores sin ver el operador. para empeorarlo todo, las herramientas automáticas de formato suelen eliminar este tipo de alineación. por tanto, al final, ya no lo uso. ahora prefiero declaraciones y asignaciones sin alinear, como se muestra a 127continuación, ya que resaltan una deficiencia importante. si tengo listas extensas que deben alinearse, el problema es la longitud de las listas, no la falta de alineación. la longitud de la siguiente lista de declaraciones de fitnesseexpediter sugiere que esta clase debe dividirse. public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long request progress; private long requestparsingdeadline; private boolean haserror; public fitnesseexpediter(socket s, fitnessecontext context) throws exception { this.context = context; socket = s; input = s.getinputstream(); output = s.getoutputstream(); requestparsingtimelimit = 10000; } sangrado un archivo de código es una jerarquía más que un contorno. incluye información que pertenece a la totalidad del archivo, a sus clases individuales, a los métodos de las clases, a los bloques de los métodos y a los bloques de los bloques. cada nivel de esta jerarquía es un ámbito en el que se pueden declarar nombres y en el que se interpretan declaraciones e instrucciones ejecutables. para que esta jerarquía de ámbitos sea visible, sangramos las líneas de código fuente de acuerdo a su posición en la jerarquía. las instrucciones al nivel del archivo, como las declaraciones de clases, no se sangran. los métodos de una clase se sangran un nivel a la derecha de la clase. las implementaciones de dichos métodos se implementan un nivel a la derecha de la declaración de los métodos. las implementaciones de bloques se 128implementan un nivel a la derecha de su bloque contenedor y así sucesivamente. los programadores dependen de este sistema de sangrado. alinean visualmente las líneas a la izquierda para ver el ámbito al que pertenece. de este modo pueden acceder rápidamente a los ámbitos, como por ejemplo a implementaciones de instrucciones if o while , que no son relevantes para la situación actual. buscan en la izquierda nuevas declaraciones de métodos, variables e incluso clases. sin el sangrado, los programas serian prácticamente ilegibles. fíjese en los siguientes programas, sintáctica y semánticamente idénticos: public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket s) { serve(s, 10000); } public void serve(socket s, long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(s, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch(exception e) { e.printstacktrace(); } } } public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket s) { serve (s, 10000); } public void serve(socket s, long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(s, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch (exception e) { e.printstacktrace(); } } } a la vista puede incluso apreciar la estructura del archivo sangrado. detectamos inmediatamente las variables, constructores y métodos de acceso. en cuestión de segundos vemos que es una especie de interfaz de conexión, 129con un tiempo de espera. la versión sin sangrar, por su parte, es prácticamente impenetrable. romper el sangrado en ocasiones tenemos la tentación de romper la regla de sangrado con instrucciones if breves, bucles while breves o funciones breves. siempre que he sucumbido a esta tentación, he acabado por volver a aplicar el sangrado. por ello, evito replegar ámbitos a una línea, como en este ejemplo: public class commentwidget extends textwidget { public static final string regexp = “^#[^\r\n]*(?:(?:\r\n)|\n|\r)?”; public commentwidget(parentwidget parent, string text){super (parent, text);} public string render() throws exception { return “”; } } prefiero desplegar y sangrar los ámbitos: public class commentwidget extends textwidget { public static final string regexp = “^#[^\r\n]*(?:(?:\r\n)|\n|\r)?”; public commentwidget(parentwidget parent, string text) { super(parent, text); } public string render() throws exception { return “”; } } ámbitos ficticios en ocasiones, el cuerpo de una instrucción while o for es ficticio, como se muestra a continuación. no me gustan estas estructuras y prefiero evitarlas. en caso de no poder hacerlo, me aseguro de sangrar el cuerpo ficticio y de incluirlo entre paréntesis. no sabría decir cuántas veces me ha engañado un punto y coma situado al final de un bucle while en la misma línea. a menos que lo haga visible y lo sangre en una línea propia, es difícil de ver. while (dis.read(buf, 0, readbuffersize) != -1) ; 130reglas de equipo todo programador tiene sus reglas de formato preferidas, pero si forma parte de un equipo, el equipo manda. un equipo de programadores debe acordar un único estilo de formato y todos los integrantes del equipo deben aplicarlo. el objetivo es que el software tenga un estilo coherente. no queremos que parezca escrito por individuos enfrentados. cuando comencé el proyecto fitnesse en 2002, me reuní con el equipo para definir un estilo de código. tardamos 10 minutos. decidimos dónde añadir las llaves, qué tamaño de sangrado utilizar, los nombres de clases, variables y métodos, y demás. tras ello, codificamos las reglas en el ide y las cumplimos desde entonces. no son las reglas que prefiero, son las que el equipo decidió. y como miembro de ese equipo, las apliqué cuando creamos el código del proyecto fitnesse. recuerde que un buen sistema de software se compone de una serie de documentos que se leen fácilmente. deben tener un estilo coherente y dinámico. el lector debe confiar en que los formatos que ve en nuestro archivo de código significarán lo mismo para otros. lo último que queremos es aumentar la complejidad del código creando una mezcla de estilos diferentes. reglas de formato de uncle bob las reglas que uso personalmente son sencillas y se ilustran en el código del listado 5-6. considérelo un ejemplo de documento estándar de código óptimo. listado 5-6 131codeanalyzer.java. public class codeanalyzer implements javafileanalysis { private int linecount; private int maxlinewidth; private int widestlinenumber; private linewidthhistogram linewidthhistogram; private int totalchars; public codeanalyzer() { linewidthhistogram = new linewidthhistogram(); } public static list<file> findjavafiles(file parentdirectory) { list<file> files = new arraylist<file>(); findjavafiles(parentdirectory, files); return files; } private static void findjavafiles(file parentdirectory, list<file> files) { for (file file : parentdirectory.listfiles()) { if (file.getname().endswith(“.java”)) files.add(file); else if (file.isdirectory()) findjavafiles(file, files); } } public void analyzefile(file javafile) throws exception { bufferedreader br = new bufferedreader(new filereader(javafile)); string line; while ((line = br.readline()) != null) measureline(line); } private void measureline(string line) { linecount++; int linesize = line.length(); totalchars += linesize; linewidthhistogram.addline(linesize, linecount); recordwidestline(linesize); } private void recordwidestline(int linesize) { if (linesize > maxlinewidth) { maxlinewidth = linesize; widestlinenumber = linecount; } } public int getlinecount() { return linecount; } 132public int getmaxlinewidth() { return maxlinewidth; } public int getwidestlinenumber() { return widestlinenumber; } public linewidthhistogram getlinewidthhistogram() { return linewidthhistogram; } public double getmeanlinewidth() { return (double)totalchars/linecount; } public int getmedianlinewidth() { integer[] sortedwidths = getsortedwidths(); int cumulativelinecount = 0; for (int width : sortedwidths) { cumulativelinecount += linecountforwidth(width); if (cumulativelinecount > linecount/2) return width; } throw new error (“cannot get here”); } private int linecountforwidth(int width) { return linewidthhistogram.getlinesforwidth(width).size(); } private integer[] getsortedwidths() { set<integer> widths = linewidthhistogram.getwidths(); integer[] sortedwidths = (widths.toarray(new integer[0])); arrays.sort(sortedwidths); return sortedwidths; } } 1336 objetos y estructuras de datos 134hay una razón para que las variables sean privadas. no queremos que nadie más dependa de ellas. queremos poder cambiar su tipo o implementación cuando deseemos. entonces, ¿por qué tantos programadores añaden automáticamente métodos de establecimiento y recuperación que muestran sus variables privadas como si fueran públicas? abstracción de datos fíjese en la diferencia entre los listados 6-1 y 6-2. ambos representan los datos de un punto cartesiano, pero uno muestra su implementación y otro la oculta totalmente. listado 6-1 punto concreto. public class point { public double x; public double y; } listado 6-2 punto abstracto. public interface point { double getx(); double gety(); void setcartesian(double x, double y); double getr(); double gettheta(); void set polar(double r, double theta); } lo mejor del listado 6-2 es que no hay forma de saber si la implementación está en coordenadas rectangulares o polares. ¡puede que en ninguna! y aun así la interfaz representa sin lugar a dudas una estructura de datos. pero representa algo más que una estructura de datos. los métodos refuerzan una política de acceso. puede leer las coordenadas de forma 135independiente, pero debe establecerlas de forma conjunta como operación atómica. el listado 6-1, por su parte, se implementa claramente en coordenadas rectangulares y nos obliga a manipularlas de forma independiente, lo que muestra la implementación. de hecho, la mostraría igualmente, aunque las variables fueran privadas y usáramos métodos variables de establecimiento y recuperación. para ocultar la implementación no basta con añadir una capa de funciones entre las variables. se basa en la abstracción. una clase no fuerza sus variables a través de métodos de establecimiento y recuperación. por el contrario, muestra interfaces abstractas que permiten a sus usuarios manipular la esencia de los datos sin necesidad de conocer su implementación. fíjese en los listados 6-3 y 6-4. el primero usa términos concretos para indicar el nivel de combustible de un vehículo mientras que el segundo lo hace con la abstracción del porcentaje. en el caso concreto, podemos estar seguros de que se trata de métodos de acceso de variables. en el caso abstracto, desconocemos la forma de los datos. listado 6-3 vehículo concreto. public interface vehicle { double getfueltankcapacityingallons(); double getgallonsofgasoline(); } listado 6-4 vehículo abstracto. public interface vehicle { double getpercentfuelremaining(); } en ambos casos, la segunda opción es preferible. no queremos mostrar los detalles de los datos, sino expresarlos en términos abstractos. esto no se consigue simplemente mediante interfaces o métodos de establecimiento y recuperación. hay que meditar seriamente la forma óptima de representar los datos que contiene un objeto. la peor opción es añadir métodos de 136establecimiento y recuperación a ciegas. antisimetría de datos y objetos estos dos ejemplos ilustran la diferencia entre objetos y estructuras de datos. los objetos ocultan sus datos tras abstracciones y muestran funciones que operan en dichos datos. la estructura de datos muestra sus datos y carece de funciones con significado. vuelva a leerlos. fíjese en la naturaleza complementaria de las dos definiciones. son virtualmente opuestas. puede parecer una diferencia menor, pero tiene importantes implicaciones. fíjese en el ejemplo del listado 6-5. la clase geometry opera en las tres clases de formas, que son sencillas estructuras de datos sin comportamiento. todo el comportamiento se encuentra en la clase geometry. listado 6-5 forma mediante procedimientos. public class square { public point topleft; public double side; } public class rectangle { public point topleft; public double height; public double width; } public class circle { public point center; public double radius; } public class geometry { public final double pi = 3.141592653589793; public double area(object shape) throws nosuchshapeexception { if (shape instanceof square) { square s = (square)shape; return s.side * s.side; } else if (shape instanceof rectangle) { 137rectangle r = (rectangle)shape; return r.height * r.width; } else if (shape instanceof circle) { circle c = (circle)shape; return pi * c.radius * c.radius; } throw new nosuchshapeexception(); } } los programadores orientados a objetos se quejarán de que es un ejemplo de procedimiento, y tienen razón. imagine qué pasaría si añadimos la función perimeter() a geometry . ¡las clases de formas no se verían afectadas! ¡y las demás clases que dependieran de las formas tampoco! por otra parte, si añado una nueva forma, tendría que cambiar todas las funciones de geometry . vuélvalo a leer. comprobará que las dos condiciones son diametralmente opuestas. fíjese ahora en la solución orientada a objetos del listado 6-6. aquí, el método area() es polimórfico. no se necesita una clase geometry . por tanto, si añado una nueva forma, ninguna de las funciones existentes se ven afectadas, pero si añado otra función, habrá que cambiar todas las formas [29] . listado 6-6 formas polimórficas. public class square implements shape { private point topleft; private double side; public double area() { return side*side; } public class rectangle implements shape { private point topleft; private double height; private double width; public double area() { return height * width; } } public class circle implements shape { private point center; 138private double radius; public final double pi = 3.141592653589793; public double area() { return pi * radius * radius; } } de nuevo, vemos la naturaleza complementaria de estas dos definiciones; totalmente contrarias. esto ilustra la dicotomía fundamental entre objetos y estructuras de datos: el código por procedimientos (el que usa estructuras de datos) facilita la inclusión de nuevas funciones sin modificar las estructuras de datos existentes. el código orientado a objetos, por su parte, facilita la inclusión de nuevas clases sin cambiar las funciones existentes. el complemento también es cierto: el código por procedimientos dificulta la inclusión de nuevas estructuras de datos ya que es necesario cambiar todas las funciones. el código orientado a objetos dificulta la inclusión de nuevas funciones ya que es necesario cambiar todas las clases. por tanto, lo que es difícil para la programación orientada a objetos es fácil para los procedimientos, y viceversa. en cualquier sistema complejo habrá ocasiones en las que queramos añadir nuevos tipos de datos en lugar de nuevas funciones. en dichos casos, los objetos y la programación orientada a objetos es lo más adecuado. por otra parte, en ocasiones tendremos que añadir nuevas funciones en lugar de tipos de datos, para lo que resulta más adecuado usar código por procedimientos y estructuras de datos. los programadores experimentados saben que la idea de que todo es un objeto es un mito. en ocasiones solamente queremos sencillas estructuras de datos con procedimientos que operen en las mismas. 139la ley de demeter existe una conocida heurística denominada ley de demeter [30] que afirma que un módulo no debe conocer los entresijos de los objetos que manipula. como vimos en el apartado anterior, los objetos ocultan sus datos y muestran operaciones, lo que significa que un objeto no debe mostrar su estructura interna a través de métodos de acceso ya que, si lo hace, mostraría, no ocultaría, su estructura interna. en concreto, la ley de demeter afirma que un método de una clase c sólo debe invocar los métodos de: c . un objeto creado por f . un objeto pasado como argumento a f . un objeto en una variable de instancia de c . el método no debe invocar métodos de objetos devueltos por ninguna de las funciones permitidas. es decir, no hable con desconocidos, sólo con amigos. el siguiente código [31] parece incumplir la ley de demeter (entre otras cosas) ya que invoca la función getscratchdir() en el valor devuelto de getoptions() y después invoca getabsolutepath() en el valor devuelto de getscratchdir() . final string outputdir = ctxt.getoptions().getscratchdir().getabsolutepath(); choque de trenes ese tipo de código suele denominarse choque de trenes ya que se asemeja a un grupo de vagones de tren. estas cadenas de invocaciones suelen considerarse un estilo descuidado y deben evitarse [g36]. conviene dividirlas de esta forma: options opts = ctxt.getoptions(); file scratchdir = opts.getscratchdir(); 140final string outputdir = scratchdir.getabsolutepath(); ¿incumplen estos dos fragmentos de código la ley de demeter? sin duda el módulo contenedor sabe que el objeto ctxt contiene opciones, que contienen un directorio scratch , que tiene una ruta absoluta. la función sabe demasiado. la función que realiza la invocación sabe cómo desplazarse por numerosos objetos diferentes. si incumple o no la ley de demeter depende de si ctxt , options y scratchdir son objetos o estructuras de datos. si son objetos, debería ocultarse su estructura interna, no mostrarse, y conocer sus detalles internos sería un claro incumplimiento de la ley de demeter. por otra parte, si ctxt , options y scratchdir son simples estructuras de datos, mostrarán su estructura interna con naturalidad y la ley de demeter no se aplica. el uso de funciones de acceso complica el problema. si el código se hubiera escrito de esta otra forma, probablemente no nos preocuparíamos de si se incumple la ley de demeter o no. final string outputdir = ctxt.options.scratchdir.absolutepath; el problema sería menos confuso si las estructuras de datos tuvieran variables públicas y no funciones, y los objetos tuvieran variables privadas y funciones públicas. sin embargo, existen estructuras y estándares (como los bean ) que exigen que incluso una sencilla estructura de datos tenga elementos de acceso y mutación. híbridos esta confusión genera ocasionalmente desafortunadas estructuras híbridas mitad objeto y mitad estructura de datos. tienen funciones que realizan tareas significativas y también variables públicas o método públicos de acceso y mutación que hacen que las variables privadas sean públicas, y tientan a otras funciones externas a usar dichas variables de la misma forma que un programa por procedimientos usaría una estructura de datos [32] . estos 141híbridos dificultan la inclusión de nuevas funciones y también de nuevas estructuras de datos. son lo peor de ambos mundos. evítelos. indican un diseño descuidado cuyos autores dudan, o peor todavía, desconocen, si necesitan protegerse de funciones o tipos. ocultar la estructura ¿qué pasaría si ctxt , options y scratchdir fueran objetos con un comportamiento real? como los objetos deben ocultar su estructura interna, no podríamos desplazarnos por los mismos. entonces, ¿cómo obtendríamos la ruta absoluta del directorio scratch ? ctxt.getabsolutepathofscratchdirectoryoption(); o ctxt.getscratchdirectoryoption().getabsolutepath() la primera opción provocaría una explosión de métodos en el objeto ctxt . la segunda asume que getscratchdirectoryoption() devuelve una estructura de datos, no un objeto. ninguna de las opciones parece correcta. si ctxt es un objeto, deberíamos indicarle que hiciera algo, no preguntar sobre sus detalles internos. entonces, ¿para qué queremos la ruta absoluta del directorio scratch ? ¿cómo vamos a usarla? fíjese en este código del mismo módulo (muchas líneas después): string outfile = outputdir + “/” + classname.replace(‘.’, ‘/’) + “.class”; fileoutputstream fout = new fileoutputstream(outfile); bufferedoutputstream bos = new bufferedoutputstream(fout); la mezcla de distintos niveles de detalle [g34][g6] es preocupante. puntos, guiones, extensiones de archivo y objetos file no deben mezclarse de esta forma, junto al código contenedor. si lo ignoramos, vemos que la intención de obtener la ruta absoluta del directorio scratch es crear un archivo de borrador de un nombre concreto. ¿y si le dijéramos al objeto ctxt que hiciera esto? bufferedoutputstream bos = ctxt.createscratchfilestream(classfilename); parece algo razonable para un objeto. permite a ctxt ocultar sus detalles internos e impide que la función actual incumpla la ley de demeter y se 142desplace por objetos que no debería conocer. objetos de transferencia de datos la quintaesencia de una estructura de datos es una clase con variables públicas y sin funciones. en ocasiones se denomina objeto de transferencia de datos ( data transfer object u otd). los otd son estructuras muy útiles, en especial para comunicarse con bases de datos o analizar mensajes de conexiones, etc. suelen ser los primeros de una serie de fases de traducción que convierten datos sin procesar en objetos en el código de la aplicación. más común es la forma de bean mostrada en el listado 6-7. los bean tienen variables privadas manipuladas por métodos de establecimiento y recuperación. la cuasi-encapsulación de bean hace que algunos puristas de la programación orientada a objetos se sientan mejor pero no ofrece ningún otro beneficio. listado 6-7 address.java public class address { private string street; private string streetextra; private string city; private string state; private string zip; public address(string street, string streetextra, string city, string state, string zip) { this.street = street; this.streetextra = streetextra; this.city = city; this.state = state; this.zip = zip; } public string getstreet() { return street; } public string getstreetextra() { return streetextra; } 143public string getcity() { return city; } public string getstate() { return getstate; } public string getzip() { return zip; } } registro activo los registros activos son una forma especial de otd. son estructuras de datos con variables públicas (o de acceso por bean) pero suelen tener métodos de navegación como save y find . por lo general, estos registros activos son traducciones directas de tablas de base de datos u otros orígenes de datos. desafortunadamente, muchos programadores intentan procesar estas estructuras de datos como si fueran objetos y les añaden métodos de reglas empresariales. es algo extraño ya que crea un híbrido entre una estructura de datos y un objeto. la solución, evidentemente, consiste en considerar al registro activo una estructura de datos y crear objetos independientes que contengan las reglas empresariales y que oculten sus datos internos (que probablemente sean instancias del propio registro activo). conclusión los objetos muestran comportamiento y ocultan datos. esto facilita la inclusión de nuevos tipos de objetos sin necesidad de cambiar los comportamientos existentes. también dificulta la inclusión de nuevos comportamientos en objetos existentes. las estructuras de datos muestran datos y carecen de comportamiento significativo. esto facilita la inclusión de nuevos comportamientos en las estructuras de datos existentes, pero dificulta la inclusión de nuevas estructuras de datos en funciones existentes. 144en un sistema, en ocasiones necesitaremos la flexibilidad de añadir nuevos tipos de datos, por lo que preferimos objetos para esa parte del sistema. en otros casos, querremos añadir nuevos comportamientos, para lo que preferimos tipos de datos y procedimientos en esa parte del sistema. los buenos programadores de software entienden estos problemas sin prejuicios y eligen el enfoque más adecuado para cada tarea concreta. bibliografía [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. 1457 procesar errores por michael feathers le parecerá extraño encontrar una sección de control de errores en un libro sobre código limpio. el control de errores es algo que todos tenemos que hacer al programar. las entradas pueden ser incorrectas y los dispositivos pueden fallar, y cuando lo hacen, los programadores somos responsables de comprobar que el código hace lo que debe hacer. no obstante, la conexión con el código limpio debe ser evidente. muchas bases de código están totalmente dominadas por el control de errores. cuando digo que están dominadas, no quiero decir que únicamente realicen control de 146código, sino que es prácticamente imposible ver lo que el código hace debido a todo ese control de errores. el control de errores es importante, pero si oscurece la lógica, es incorrecto . en este capítulo detallaremos diversas técnicas y consideraciones que puede usar para crear código limpio y robusto, código que procese los errores con elegancia y estilo. usar excepciones en lugar de códigos devueltos en el pasado, muchos lenguajes carecían de excepciones. las técnicas para procesar e informar de errores eran limitadas. se definía un indicador de error o se devolvía un código de error que el invocador podía comprobar. el código del listado 7-1 ilustra estos enfoques. listado 7-1 devicecontroller.java. public class devicecontroller { … public void sendshutdown() { devicehandle handle = gethandle(dev1); // comprobar el estado del dispositivo if (handle != devicehandle.invalid) { // guardar el estado del dispositivo en el campo de registro retrievedevicerecord(handle); // si no está suspendido, cerrarlo if { record.getstatus() != device_suspended) { pausedevice(handle); cleardeviceworkqueue(handle); closedevice(handle); } else { logger.log(“device suspended. unable to shut down”); } } else { logger.log(“invalid handle for: ” + dev1.tostring()); } } … } el problema de estos enfoques es que confunden al invocador. el invocador debe comprobar inmediatamente los errores después de la 147invocación. desafortunadamente, es algo que se suele olvidar. por ello, es más recomendable generar una excepción al detectar un error. el código de invocación es más limpio. su lógica no se oscurece por el control de errores. el listado 7-2 muestra el código tras generar una excepción en los métodos que pueden detectar errores. listado 7-2 devicecontroller.java (con excepciones). public class devicecontroller { … public void sendshutdown() { try { trytoshutdown(); } catch (deviceshutdownerror e) { logger.log(e); } } private void trytoshutdown() throws deviceshutdownerror { devicehandle handle = gethandle(dev1); devicerecord record = retrievedevicerecord(handle); pausedevice(handle); cleardeviceworkqueue(handle); closedevice(handle); } private devicehandle gethandle(deviceid id) { … throw new deviceshutdownerror(“invalid handle for: ” - id.tostring()); … } … } comprobará que es mucho más limpio. no es cuestión de estética. el código es mejor porque se solventan dos preocupaciones: el algoritmo para apagar el dispositivo y el control de errores ahora se encuentran separados. puede ver cada uno de ellos y entenderlos de forma independiente. crear primero la instrucción try-catch-finally 148uno de los aspectos más interesantes de las excepciones es que definen un ámbito en el programa. al ejecutar código en la parte try de una instrucción try-catch-finally , indicamos que la ejecución se puede cancelar en cualquier momento y después retomar en catch . los bloques try son como las transacciones, catch debe salir del programa en un estado coherente, independientemente de lo que suceda en try . por este motivo, es aconsejable iniciar con una instrucción try-catch- finally el código que genere excepciones. de este modo define lo que debe esperar el usuario del código, independientemente de que se produzca un error en el código ejecutado en la cláusula try . veamos un ejemplo. imagine que tiene que crear un código que acceda a un archivo y lea objetos serializados. comenzamos con una prueba de unidad que muestra que obtendremos una excepción cuando el archivo no exista: @test(expected = storageexception.class) public void retrievesectionshouldthrowoninvalidfilename() { sectionstore.retrievesection(“invalid - file”); } la prueba nos lleva a crear lo siguiente: public list<recordedgrip> retrievesection(string sectionname) { // se devuelve un resultado ficticio hasta tener una implementación real return new arraylist<recordedgrip>(); } nuestra prueba falla ya que no genera una excepción. tras ello, cambiamos la implementación para que intente acceder a un archivo no válido. esta operación genera una excepción: public list<recordedgrip> retrievesection (string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname) } catch (exception e) { throw new storageexception(“retrieval error”, e); } return new arraylist<recordedgrip>(); } ahora la prueba es correcta ya que capturamos la excepción y ya podemos refactorizar. podemos reducir el tipo de la excepción capturada para que coincida con el tipo generado desde el constructor fileinputstream: 149filenotfoundexception : public list<recordedgrip> retrievesection(string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname); stream.close(); } catch (filenotfoundexception e) { throw new storageexception(“retrieval error”, e); } return new arraylist<recordedgrip>(); } ahora que hemos definido el ámbito con una estructura try-catch , podemos usar tdd para diseñar el resto de la lógica necesaria. dicha lógica se añade entre la creación de fileinputstream y el cierre, y podemos pretender que no pasa nada incorrecto. intente crear pruebas que fuercen las excepciones, para después añadir al controlador un comportamiento que satisfaga dichas pruebas. de este modo primero creará el ámbito de transacción del bloque try y podrá mantener la naturaleza de transacción del ámbito. usar excepciones sin comprobar el debate ha terminado. durante años, los programadores de java han debatido las ventajas y los problemas de las excepciones comprobadas. cuando aparecieron en la primera versión de java, parecían una gran idea. la firma de todos los métodos enumeraría todas las excepciones que se podían pasar a su invocador. es más, estas excepciones formaban parte del tipo del método. el código no se compilaría si la firma no coincidía con lo que el código iba a hacer. en aquel momento, pensábamos que las excepciones comprobadas eran una gran idea y sí, ofrecían ciertas ventajas. sin embargo, ahora es evidente que no se necesitan para crear software robusto. c# carece de excepciones comprobadas y, a pesar de los intentos, c++ tampoco, como sucede en python o ruby. y en todos estos lenguajes se puede crear software robusto. por ello, debemos decidir si las excepciones comprobadas valen su precio. ¿qué precio? el precio de las excepciones comprobadas es un 150incumplimiento del principio abierto/cerrado [33] . si genera una excepción comprobada desde un método de su código y la cláusula catch se encuentra tres niveles por debajo, debe declarar dicha excepción en la firma de todos los métodos comprendidos entre su posición y catch . esto significa que un cambio en un nivel inferior del software puede forzar cambios de firma en muchos niveles superiores. será necesario volver a generar e implementar los módulos cambiados, aunque no cambien los elementos a los que hacen referencia. piense en la jerarquía de invocación de un sistema. las funciones de la parte superior invocan a las funciones situadas debajo, que invocan a otras funciones inferiores y así sucesivamente. imagine que una de las funciones de nivel inferior se modifica de forma que debe generar una excepción. si la excepción se comprueba, la firma de la función tendrá que añadir una cláusula throws . pero esto significa que todas las funciones que invoquen nuestra función modificada también tendrán que cambiarse para capturar la nueva excepción o para añadir la correspondiente cláusula throws en su firma. y así indefinidamente. el resultado final es una cascada de cambios que pasan desde los niveles inferiores del software hasta los superiores. la encapsulación se rompe ya que todas las funciones en la ruta de throw deben conocer detalles de la excepción de nivel inferior. como el cometido de las excepciones es permitimos procesar errores a distancia, es una lástima que las excepciones comprobadas rompan la encapsulación de esta forma. las excepciones comprobadas pueden ser útiles si tiene que crear una biblioteca crítica: tendrá que capturarlas. pero en el desarrollo de aplicaciones generales, los costes de dependencia superan las ventajas. ofrecer contexto junto a las excepciones las excepciones que genere deben proporcionar el contexto adecuado para determinar el origen y la ubicación de un error. en java, puede obtener un rastreo de pila de cualquier excepción; sin embargo, no le indicará el cometido de la función fallida. redacte mensajes de error informativos y páselos junto a sus 151excepciones. mencione la operación fallida y el tipo de fallo. si guarda registros en su aplicación, incluya información suficiente para poder registrar el error en la cláusula catch . definir clases de excepción de acuerdo a las necesidades del invocador existen varias formas de clasificar los errores. podemos hacerlo por origen (¿provienen de uno u otro componente?) o por tipo (¿son fallos del dispositivo, de la red o errores de programación?). sin embargo, al definir clases de excepción en una aplicación, debemos preocuparnos principalmente en cómo se capturan . veamos un pobre ejemplo de clasificación de excepciones. es una instrucción try-catch-finally de la invocación de una biblioteca de terceros. abarca todas las excepciones que las invocaciones pueden generar: acmeport port = new acmeport(12); try { port.open(); } catch (deviceresponseexception e) { reportporterror(e); logger.log{“device response exception”, e); } catch (atm1212unlockedexception e) { reportporterror(e); logger.log(“unlock exception”, e); } catch (gmxerror e) { reportporterror(e); logger.log(“device response exception”); } finally { … } esta instrucción contiene elementos duplicados, algo que no debería sorprendernos. en muchos casos de control de excepciones, el trabajo que realizamos es relativamente estándar independientemente de la causa real. debemos registrar un error y asegurarnos de poder continuar. en este caso, como sabemos que el trabajo es el mismo independientemente de la excepción, podemos simplificar el código si incluimos la api invocada y nos aseguramos de que devuelve un tipo de 152excepción común: localport port = new localport(12); try { port.open(); } catch (portdevicefailure e) { reporterror(e); logger.log(e.getmessage(), e); } finally { … } nuestra clase localport es un simple envoltorio que captura y traduce excepciones generadas por la clase acmeport : public class localport { private acmeport innerport; public localport(int portnumber) { innerport = new acmeport(portnumber); } public void open() { try { innerport.open(); } catch (deviceresponseexception e) { throw new portdevicefailure(e); } catch (atm1212unlockedexception e) { throw new portdevicefailure(e); } catch (gmxerror e) { throw new portdevicefailure(e); } } … } los envoltorios como el definido para acmeport pueden ser muy útiles. de hecho, es recomendable envolver api de terceros. al hacerlo, se minimizan las dependencias: puede cambiar a otra biblioteca diferente sin apenas problemas y el envoltorio también facilita imitar invocaciones de terceros cuando se prueba el código. una última ventaja es que no estamos limitados a las decisiones de diseño de api de un determinado fabricante. puede definir una api que le resulte cómoda. en el ejemplo anterior, definimos un único tipo de excepción para el fallo de puertos y podemos escribir un código mucho más limpio. a menudo, una única clase de excepción es suficiente para una zona concreta del código. la información enviada con la excepción puede distinguir los errores. use clases diferentes 153sólo para capturar una excepción y permitir el paso de otra distinta. definir el flujo normal si sigue los consejos de apartados anteriores, realizará una importante separación entre la lógica empresarial y el control de errores. la mayoría de su código parecerá un algoritmo limpio y sin adornos. sin embargo, el proceso desplaza la detección de errores hacia los bordes del programa. debe envolver api externas para poder generar sus propias excepciones y definir un controlador por encima del código para poder procesar cálculos cancelados. en muchos casos es el enfoque más acertado, pero en ocasiones conviene no cancelar. veamos un ejemplo, un código extraño que suma gastos en una aplicación de facturación: try { mealexpenses expenses = expensereportdao.getmeals(employee.getid()); m_total += expenses.gettotal(); } catch(mealexpensesnotfound e) { m_total += getmealperdiem(); } en esta empresa, si las comidas son gastos, pasan a formar parte del total. si no lo son, los trabajadores reciben una cantidad diaria para la comida. la excepción entorpece la lógica. sería más adecuado no tener que procesar el caso especial y el código sería mucho más sencillo: mealexpenses expenses = expensereportdao.getmeals(employee.getid()); m_total += expenses.gettotal(); ¿de verdad que el código puede ser tan simple? pues sí. podemos cambiar expensereportdao para que siempre devuelva un objeto mealexpense . si no hay gastos de comida, devuelve un objeto mealexpense que devuelve la dieta diaria como total: public class perdiemmealexpenses implements mealexpenses { public int gettotal() { // devolver la dieta diaria predeterminada 154} } es lo que se denomina patrón de caso especial [fowler]. se crea una clase o se configura un objeto que procese un caso especial. al hacerlo, el código cliente no tiene que procesar comportamientos excepcionales. dichos comportamientos se encapsulan en un objeto de caso especial. no devolver null creo que toda descripción del control de errores debe mencionar los elementos proclives a errores. el primero es devolver null. he perdido la cuenta de la cantidad de aplicaciones en que las que línea sí y línea también se comprueba null: public void registeritem(item item) { if (item != null) { itemregistry registry = peristentstore.getitemregistry(); if (registry != null) { item existing = registry.getitem(item.getid()); if (existing.getbillingperiod().hasretailowner()) { existing.register(item); } } } } si trabaja en una base de código como ésta, puede que no le parezca tan mala, pero lo es. al devolver null , básicamente nos creamos trabajo y generamos problemas para los invocadores. basta con que falte una comprobación de null para que la aplicación pierda el control. ¿se ha fijado en que no hay una comprobación de null en la segunda línea de la instrucción if anidada? ¿qué sucedería en tiempo de ejecución si persistentstore fuera null ? se generaría nullpointerexception en tiempo de ejecución y se capturaría nullpointerexception en el nivel superior o no. en ambos casos es incorrecto. ¿qué debería hace como respuesta a la generación de nullpointerexception desde el interior de su aplicación? se puede afirmar que el problema de este código es la ausencia de una comprobación de null pero en realidad el problema es su exceso. si 155siente la tentación de devolver null desde un método, pruebe a generar una excepción o a devolver un objeto de caso especial. si invoca un método que devuelva null desde una api de terceros, envuélvalo en un método que genere una excepción o devuelva un objeto de caso especial. en muchos casos, los objetos de caso especial son un remedio sencillo. imagine que tiene el siguiente código: list<employee> employees = getemployees(); if (employees != null) { for(employee e : employees) { totalpay += e.getpay(); } } ahora, getemployees puede devolver null , ¿pero es necesario? si cambiamos getemployee para que devuelva una lista vacía, podremos limpiar el código: list<employee> employees = getemployees(); for(employee e : employees) { totalpay += e.getpay(); } afortunadamente, java dispone de collections.emptylist() y devuelve una lista inmutable predefinida que podemos usar para este cometido: public list<employee> getemployees() { if (… there are no employees …) return collections.emptylist(); } si usa este tipo de código, minimizará la presencia de nullpointerexception y su código será más limpio. no pasar null devolver null desde métodos es incorrecto, pero es peor pasar null a métodos. a menos que trabaje con una api que espere que pase null , debe evitarlo siempre que sea posible. veamos otro ejemplo, un sencillo método que calcula una métrica para dos puntos: public class metricscalculator 156{ public double xprojection(point p1, point p2) { return (p2.x – p1.x) * 1.5; } … } ¿qué sucede cuando alguien pasa null como argumento? calculator.xprojection(null, new point (12, 13)); se genera nullpointerexception , evidentemente. ¿cómo solucionarlo? podríamos crear un nuevo tipo de excepción y generarla: public class metricscalculator { public double xprojection(point p1, point p2) { if (p1==null || p2==null) { throw invalidargumentexception( “invalid argument for metricscalculator.xprojection”); } return (p2.x – p1.x) * 1.5; } } } ¿mejor? puede que sea mejor que una excepción de puntero nulo, pero recuerde que debe definir un controlador para invalidargumentexception . ¿qué debe hacer el controlador? ¿hay alguna forma correcta de hacerlo? existe otra alternativa, usar un grupo de afirmaciones: public class metricscalculator ( public double xprojection{point p1, point p2) { assert p1 != null : “p1 should not be null”; assert p2 != null : “p2 should not be null”; return (p2.x - pl.x) * 1.5; } } es documentación correcta pero no soluciona el problema. si alguien pasa null , seguirá produciéndose un error de tiempo de ejecución. en la mayoría de lenguajes de programación no hay una forma correcta de procesar un null pasado por accidente. como éste es el caso, el enfoque racional es impedir que se pase null de forma predeterminada. si lo hace, puede diseñar código sabiendo que null en una lista de argumentos indica un problema y los errores serán menores. 157conclusión el código limpio es legible pero también debe ser robusto. no son objetivos opuestos. podemos crear código limpio y robusto si consideramos el control de errores una preocupación diferente, algo que vemos de forma independiente desde nuestra lógica principal. si somos capaces de lograrlo, razonaremos de forma independiente y podemos aumentar la capacidad de mantenimiento de nuestro código. bibliografía [martin] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. 1588 límites por james grenning no es habitual que controlemos todo el software de nuestros sistemas. en ocasiones, adquirimos paquetes de terceros o usamos código abierto. en otros casos, dependemos de equipos de nuestra propia empresa para producir 159componentes o subsistemas que utilizamos. de algún modo debemos integrar este código externo con el nuestro. en este capítulo veremos prácticas y técnicas para definir con claridad los límites de nuestro software . utilizar código de terceros existe una tensión natural entre el proveedor de una interfaz y el usuario de la misma. los proveedores de paquetes y estructuras de terceros abogan por una capacidad de aplicación global para poder trabajar en diversos entornos y atraer a un público más amplio. los usuarios, por su parte, desean una interfaz centrada en sus necesidades concretas. esta tensión puede provocar problemas en los límites de nuestros sistemas. analicemos java.util.map como ejemplo. como puede apreciar en la siguiente lista. map tiene una amplia interfaz con numerosas prestaciones. esta potencia y flexibilidad es muy útil, pero también puede ser un problema. por ejemplo, nuestra aplicación puede generar un map y compartirlo. nuestra intención puede que sea que ninguno de los receptores del mapa borre sus elementos. pero en la parte superior de la lista encontramos el método clear() . cualquier usuario del mapa puede borrarlo. o puede que nuestra convención de diseño determine que sólo se puedan almacenar objetos concretos en el mapa, pero map no limita de forma fiable los tipos de objetos que admite. cualquier usuario puede añadir elementos de cualquier tipo a cualquier mapa. clear() void - map containskey (object key) boolean - map containsvalue (object value) boolean - map entryset() set - map equals(object o) boolean - map get(object key) object - map getclass() class<? extends object> - object hashcode() int - map isempty() boolean - map keyset() set - map notify() void - object 160notifyall() void - object put(object key, object value) object - map putall(map t) void - map remove(object key) object - map size() int - map tostring() string - object values() collection - map wait() void - object wait(long timeout) void - object wait(long timeout, int nanos) void - object figura 8.1. los métodos de map si nuestra aplicación necesita un mapa de sensor , comprobará que los sensores se definen de esta forma: map sensors = new hashmap(); tras ello, cuando otra parte del código necesite acceder a sensor, vemos este código: sensor s = (sensor)sensors.get(sensorid); no lo vemos una sola vez, sino repetidamente a lo largo del código. el cliente de este código es responsable de obtener un objeto de map y convertirlo al tipo correcto. funciona, pero no es código limpio. además, este código no cuenta su historia como debería. la legibilidad del código se podría mejorar mediante el uso de genéricos, como se indica a continuación: map<sensor> sensors = new hashmap<sensor>(); … sensor s = sensors.get(sensorid); sin embargo, esto no soluciona el problema de que map<sensor> ofrezca más prestaciones de las que necesitamos o deseamos. al pasar una instancia de map<sensor> en el sistema, significa que habrá muchos puntos que corregir si la interfaz de map cambia. seguramente piense que son cambios improbables, pero recuerde que se han producido al añadir compatibilidad con genéricos en java 5. sin duda hemos visto sistemas que impiden el uso de genéricos debido a la gran cantidad de cambios necesarios para compensar el uso liberal de map . una forma más limpia de usar map sería la siguiente. a ningún usuario 161sensor le importa si se usan genéricos o no. esa opción se ha convertido (y siempre debería serlo) en un detalle de implementación. public class sensors { private map sensors = new hashmap(); public sensor getbyid(string id) { return (sensor) sensors.get(id); } //corte } la interfaz en el límite (map) está oculta. ha conseguido evolucionar sin apenas impacto en el resto de la aplicación. el uso de genéricos ya no es un problema ya que la conversión y la administración de tipos se procesa dentro de la clase sensors . esta interfaz también se ha ajustado y limitado a las necesidades de la aplicación. genera código más fácil de entender y con menor probabilidad de errores. la clase sensors puede aplicar las reglas empresariales y de diseño. no sugerimos que se encapsulen de esta forma todos los usos de map, sino que no se pase map (ni otras interfaces en el límite) por el sistema. si usa una interfaz de límite como map , manténgala dentro de la clase o la familia de clases en la que se use. evite devolverla o aceptarla como argumento de api públicas. explorar y aprender límites el código de terceros nos permite obtener mayor funcionalidad en menos tiempo. ¿por dónde empezamos cuando queremos utilizar un paquete de terceros? nuestra labor no es probar el código, pero sí crear pruebas para el código de terceros que utilicemos. imagine que no es evidente cómo usar una biblioteca de terceros. podríamos perder uno o varios días en leer la documentación y decidir cómo usarla. tras ello, podríamos escribir el código para usar el código de terceros y comprobar si se comporta de la forma esperada. no deberíamos sorprendernos por tener que realizar extensas sesiones de depuración intentando localizar errores en nuestro código o en el suyo. 162aprender el código de terceros es complicado, y también integrarlo. hacer ambas cosas al mismo tiempo es el doble de complicado. necesitamos un enfoque diferente. en lugar de experimentar y probar el nuevo material en nuestro código de producción, podríamos crear pruebas que analicen nuestro entendimiento del código de terceros. jim newkirk las denomina pruebas de aprendizaje [34] . en las pruebas de aprendizaje, invocamos la api de terceros como supuestamente la usaríamos en nuestra aplicación. básicamente realizamos experimentos controlados para comprobar si la entendemos. las pruebas se centran en lo que queremos obtener de la api. aprender log4j imagine que desea usar el paquete de apache log4j en lugar de su propio dispositivo de registro personalizado. lo descarga y abre la página inicial de la documentación. sin una lectura exhaustiva, crea el primer caso de prueba con la esperanza de que escriba hello en la consola. @test public void testlogcreate() { logger logger = logger.getlogger(“mylogger”); logger.info(“hello”); } al ejecutarlo, el registrador genera un error que nos indica que necesitamos algo denominado appender . tras investigar, descubrimos que existe un elemento consoleappender . creamos consoleappender y comprobamos si hemos conseguido revelar los secretos del registro en la consola. @test public void testlogaddappender() { logger logger = logger.getlogger (“mylogger”); consoleappender appender = new consoleappender(); logger.addappender(appender); logger.info(“hello”); } en esta ocasión descubrimos que appender carece de flujo de salida, algo extraño, ya que parece lógico que lo tuviera. tras recurrir a google, 163probamos lo siguiente: @test public void testlogaddappender() { logger logger = logger.getlogger(“mylogger”); logger.removeallappenders(); logger.addappender(new consoleappender( new patternlayout(“%p %t %m%n”), consoleappender.system_out)); logger.info(“hello”); } funciona; en la consola aparece un mensaje con la palabra hello . resulta extraño tener que indicarle a consoleappender que escriba en la consola. al eliminar el argumento consoleappender.systemout , vemos que hello sigue impreso. pero al eliminar patternlayout , de nuevo vemos la queja de la falta de un flujo de salida. es un comportamiento muy extraño. si nos fijamos en la documentación, vemos que el constructor consoleappender predeterminado no está configurado, lo que no parece demasiado obvio ni útil. parece más bien un error o una incoherencia de log4j . tras nuevas búsquedas en google, investigaciones y pruebas, conseguimos el listado 8-1. hemos descubierto cómo funciona log4j y hemos codificado esos conocimientos en un grupo de sencillas pruebas de unidad. listado 8-1 logtest.java. public class logtest ( private logger logger; @before public void initialize() { logger = logger.getlogger(“logger”); logger.removeallappenders(); logger.getrootlogger().removeallappenders(); } @test public void basiclogger() { basicconfigurator.configure(); logger.info(“basiclogger”); } 164@test public void addappenderwithstream() { logger.addappender(new consoleappender( new patternlayout (“%p %t %m%n”), consoleappender.system_out)); logger.info(“addappenderwithstream”); } @test public void addappenderwithoutstream() { logger.addappender(new consoleappender( new patternlayout(“%p %t %m%n”))); logger.info(“addappenderwithoutstream”); } } ahora sabemos cómo inicializar un sencillo registrador de consola y encapsular ese conocimiento en nuestra propia clase de registro para que el resto de la aplicación se aísle de la interfaz de límite log4j . las pruebas de aprendizaje son algo más que gratuitas las pruebas de aprendizaje no cuestan nada. de todas formas, hemos tenido que aprender la api y crear las pruebas fue una forma sencilla y aislada de adquirir esos conocimientos. las pruebas de aprendizaje fueron experimentos precisos que permitieron aumentar nuestros conocimientos. las pruebas no sólo son gratuitas, sino también rentables. cuando aparezcan nuevas versiones del paquete de terceros, ejecutamos las pruebas de aprendizaje para comprobar si hay diferencias de comportamiento. las pruebas de aprendizaje demuestran que los paquetes de terceros que usamos funcionan de la forma esperada. una vez integrados, no hay garantía de que el código de terceros sea compatible con nuestras necesidades. los autores originales se verán presionados para cambiar el código y ajustarlo a sus propias necesidades. corregirán errores y añadirán nuevas funciones. en cada versión surgirán nuevos riesgos. si el paquete de terceros cambia de una forma incompatible con nuestras pruebas, lo sabremos al instante. independientemente de que necesite los conocimientos proporcionados por las pruebas de aprendizaje, un límite claro debe estar respaldado por un conjunto de pruebas que ejerciten la interfaz de la misma forma que hace el 165código de producción. sin estas pruebas de límites para facilitar la transición, podríamos conservar la versión antigua más tiempo del necesario. usar código que todavía no existe existe otro tipo de límite, que separa lo conocido de lo desconocido. en ocasiones, nuestro conocimiento del código parece desvanecerse. lo que hay al otro lado del límite es desconocido (al menos por el momento). en ocasiones, decidimos no mirar más allá del límite. hace años formé parte de un equipo de desarrollo de software para un sistema de comunicación por radio. había un subsistema, el transmisor, que apenas conocíamos y cuya interfaz todavía no se había diseñado. como no queríamos quedarnos parados, comenzamos a trabajar alejándonos de la parte desconocida del código. sabíamos perfectamente dónde acababa nuestro mundo y comenzaba el nuevo. mientras avanzábamos, en ocasiones nos topábamos con este límite. aunque la ignorancia ocultaba nuestra visión más allá del límite, sabíamos cómo queríamos que fuera la interfaz. queríamos decirle al transmisor algo como lo siguiente: ajustar el transmisor en la frecuencia proporcionada y emitir una representación analógica de los datos que provienen de este flujo. no sabíamos cómo hacerlo ya que todavía no se había diseñado la api. por ello decidimos determinar después los detalles. para no quedarnos bloqueados, definimos nuestra propia interfaz. le dimos un nombre sencillo, transmitter . le asignamos el método transmit que aceptaba una frecuencia y un flujo de datos. es la interfaz que deseábamos haber tenido. lo mejor de escribir la interfaz que deseábamos haber tenido era que la controlábamos. esto hace que el código cliente sea más legible y se ciña a los objetivos previstos. en la figura 8.1 se aprecia que aislamos las clases 166communicationscontroller de la api del transmisor (que no controlábamos y estaba por definir). al usar nuestra propia interfaz específica de la aplicación, el código de communicationscontroller era limpio y expresivo. una vez definida la api del transmisor, creamos transmitteradapter para reducir las distancias. el adaptador [35] encapsulaba la interacción con la api y ofrecía un único punto en el que evolucionaba. figura 8.1. predicción del transmisor este diseño también nos ofrece un sello [36] en el código para realizar pruebas. con un elemento faketransmitter , podemos probar las clases communicationscontroller . también podemos crear pruebas de límite una vez diseñada la api transmitter para asegurarnos de que la utilizamos correctamente. límites limpios en los límites suceden cosas interesantes. los cambios es una de ellas. los diseños de código correctos acomodan los cambios sin necesidad de grandes modificaciones. cuando usamos código que no controlamos, hay que prestar especial atención a proteger nuestra inversión y asegurarnos de que los cambios futuros no son demasiado costosos. el código en los límites requiere una separación evidente y pruebas que definan expectativas. debemos evitar que el código conozca los detalles de terceros. es más aconsejable depender de algo que controlemos que de algo que no controlemos, y menos todavía si nos controla. los límites de terceros se gestionan gracias a la presencia de 167puntos mínimos en el código que hagan referencia a los mismos. podemos envolverlos como hicimos con map o usar un adaptador para convertir nuestra interfaz perfecta en la interfaz proporcionada. en cualquier caso, el código se lee mejor, promueve el uso coherente e interno en el límite y hay menos puntos de mantenimiento cuando cambie el código de terceros. bibliografía [becktdd] : test driven development , kent beck, addison-wesley, 2003. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison wesley, 19%. [welc] : working effectively with legacy code , addison-wesley, 2004. 1689 pruebas de unidad nuestra profesión ha evolucionado mucho en los últimos 10 años. en 1997 nadie había oído hablar del desarrollo guiado por pruebas (dgp). para la mayoría, las pruebas de unidad eran pequeños fragmentos de código 169desechable que creábamos para asegurarnos de que nuestros programas funcionaban. escribíamos clases y métodos, y después código ad hoc para probarlos, lo que implicaba algún tipo de programa controlador que nos permitiera interactuar manualmente con el programa que habíamos escrito. recuerdo crear un programa de c++ para un sistema incrustado de tiempo real a mediados de la década de 1990. el programa era un sencillo temporizador con la siguiente firma: void timer::schedulecommand(command* thecommand, int milliseconds) la idea era sencilla; el método execute de command se ejecutaba en un nuevo subproceso tras el número especificado de milisegundos. el problema era cómo probarlo. confeccioné un sencillo programa controlador que escuchaba al teclado. cada vez que se introducía un carácter, se programaba un comando que escribía el mismo carácter cinco segundos después. introduje una rítmica melodía en el teclado y esperé a que se reprodujera en pantalla cinco segundos después: «i… want-a-girl… just… like-the-girl-who-marr… ied… dear… old… dad.» incluso tarareé la melodía mientras pulsaba la tecla, y la volví a cantar cuando aparecieron los puntos en la pantalla. ésa fue mi prueba. cuando vi que funcionaba y se lo mostré a mis compañeros, me deshice del código de prueba. como he afirmado, nuestra profesión ha evolucionado mucho. ahora crearía una prueba que garantizara el funcionamiento de hasta el más mínimo detalle del código. aislaría el código del sistema operativo en lugar de invocar las funciones estándar de temporización. las imitaría para tener control total sobre el tiempo. programaría comandos que definieran indicadores booleanos y avanzaría el tiempo, para observar los indicadores y asegurarme de que pasaran de false a true al cambiar el tiempo al valor correcto. cuando superara una serie de pruebas, comprobaría que fueran adecuadas para todo el que tuviera que trabajar con el código. me aseguraría de comprobar las pruebas y el código en el mismo paquete. sí, hemos 170avanzado mucho, pero nos queda mucho por avanzar. los movimientos agile y tdd han animado a muchos programadores a crear pruebas de unidad automatizadas y cada vez son más. pero en esta alocada carrera por añadir pruebas a nuestra disciplina, muchos programadores han pasado por alto dos de los aspectos más sutiles e importantes de diseñar pruebas de calidad. las tres leyes del dgp todos sabemos que el dgp nos pide que primero creemos las pruebas de unidad, antes que el código de producción. pero esa norma es sólo la punta del iceberg. tenga en cuenta las tres siguientes leyes [37] : primera ley : no debe crear código de producción hasta que haya creado una prueba de unidad que falle. segunda ley : no debe crear más de una prueba de unidad que baste como fallida, y no compilar se considera un fallo. tercera ley : no debe crear más código de producción que el necesario para superar la prueba de fallo actual. estas tres leyes generan un ciclo de unos 30 segundos de duración. las pruebas y el código de producción se crean de forma conjunta, las pruebas unos segundos antes que el código. si trabajamos de esta forma, crearemos decenas de pruebas al día, cientos al mes y miles al año. si trabajamos de esta forma, las pruebas abarcarán todos los aspectos de nuestro código de producción. el tamaño de dichas pruebas, que puede ser similar al del código de producción, puede suponer un problema de administración. realizar pruebas limpias hace unos años me pidieron que dirigiera un equipo que había decidido explícitamente que su código de prueba no debía mantenerse con los mismos estándares de calidad que su código de producción. podían incumplir las 171reglas en sus pruebas de unidad. la premisa era «rápido y directo». no era necesario que las variables tuvieran nombres adecuados, ni que las funciones de prueba fueran breves y descriptivas. no era necesario que el código de prueba estuviera bien diseñado. bastaba con que funcionara y abarcara el código de producción. puede que algunos lectores empaticen con esta decisión. puede que en el pasado creara el tipo de pruebas que cree para la clase timer . supone un gran paso crear ese tipo de pruebas desechables a diseñar una suite de pruebas de unidad automatizadas. por ello, como el equipo que dirigía, puede decidir que pruebas incorrectas sea mejor que no tener pruebas. pero el equipo no se daba cuenta que tener pruebas incorrectas era igual o peor que no tener prueba alguna. el problema es que las pruebas deben cambiar de acuerdo a la evolución del código. cuanto menos limpias sean, más difícil es cambiarlas. cuando más enrevesado sea el código de prueba, más probabilidades de que dedique más tiempo a añadir nuevas pruebas a la suite que el empleado en crear el nuevo código de producción. al modificar el código de producción, las pruebas antiguas comienzan a fallar y el desastre impide que las pruebas se superen, por lo que acaban por convertirse en un obstáculo interminable. entre versiones, aumentó el coste de mantener la suite de pruebas de mi equipo. acabó por convertirse en la principal queja entre los desarrolladores. cuando los directores preguntaron sobre este aumento, los desarrolladores culparon a las pruebas. al final, se vieron obligados a descartar la suite de pruebas completa. pero sin una suite de pruebas perdieron la posibilidad de garantizar el funcionamiento esperado de los cambios en el código. sin una suite de pruebas no podían asegurar que los cambios en una parte del sistema no afectaran a otras diferentes. los defectos aumentaron, lo que propició que temieran realizar cambios. dejaron de limpiar su código de producción por miedo a que los cambios fueran dañinos. el código de producción comenzó a corromperse. al final, se quedaron sin pruebas, con un código de producción enmarañado y defectuoso, clientes frustrados y la sensación de que su esfuerzo les había fallado. en cierto modo tenían razón. su esfuerzo les había fallado. pero fue su 172decisión de permitir que las pruebas fueran incorrectas lo que provocó el fallo. si hubieran empleado pruebas limpias, su esfuerzo no habría fallado. puedo afirmarlo con cierta seguridad porque he participado y dirigido muchos equipos que han tenido éxito gracias a pruebas de unidad limpias. la moraleja de la historia es sencilla: el código de prueba es tan importante como el de producción. no es un ciudadano de segunda. requiere concentración, diseño y cuidado. debe ser tan limpio como el código de producción. las pruebas propician posibilidades si sus pruebas no son limpias, las perderá. y sin ellas pierde lo mismo que hace que su código de producción sea flexible. sí, ha leído bien. las pruebas de unidad son las que hacen que el código sea flexible y se pueda mantener y reutilizar. la razón es sencilla. si tiene pruebas, no tendrá miedo a realizar cambios en el código. sin pruebas, cada cambio es un posible error. independientemente de la flexibilidad de su arquitectura, de la división del diseño, sin pruebas tendrá miedo a realizar cambios por la posibilidad de añadir errores no detectados. pero con las pruebas ese miedo desaparece. cuanto mayor sea el alcance de sus pruebas, menos miedo tendrá. podrá modificar el código con total impunidad, aunque su arquitectura no sea la mejor y el diseño sea mediocre. podrá mejorar la arquitectura y el diseño sin miedo alguno. por tanto, disponer de una suite automatizada de pruebas de unidad que cubran el código de producción es la clave para mantener limpio el diseño y la arquitectura. las pruebas proporcionan las posibilidades, ya que permiten el cambio. si sus pruebas no son limpias, la capacidad de modificar el código se verá limitada y perderá la posibilidad de mejorar la estructura de dicho código. cuanto menos limpias sean las pruebas, menos lo será el código. en última instancia perderá las pruebas y el código se corromperá. pruebas limpias 173¿qué hace que una prueba sea limpia? tres elementos: legibilidad, legibilidad y legibilidad. la legibilidad es sin duda más importante en las pruebas de unidad que en el código de producción. ¿qué hace que una prueba sea legible? lo mismo que en el código: claridad, simplicidad y densidad de expresión. en una prueba debe decir mucho con el menor número de expresiones posible. fíjese en el código de fitnesse del listado 9-1. estas tres pruebas son difíciles de entender y sin duda se pueden mejorar. por un lado, hay mucho código duplicado [g5] en las invocaciones repetidas a addpage y assertsubstring . sobre todo, este código se carga con detalles que interfieren con la expresividad de la prueba. listado 9-1 serializedpagerespondertest.java. public void testgetpagehieratchyasxml() throws exception { crawler.addpage(root, pathparser.parse(“pageone”)); crawler.addpage(root, pathparser.parse(“pageone.childone”)); crawler.addpage(root, pathparser.parse(“pagetwo”)); request.setresource(“root”); request.addinput(“type”, “pages”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“<name>pageone</name>”, xml); assertsubstring(“<name>pagetwo</name>”, xml); assertsubstring(“<name>childone</name>”, xml); } public void testgetpagehieratchyasxmldoesntcontainsymboliclinks() throws exception { wikipage pageone = crawler.addpage(root, pathparser.parse(“pageone”)); crawler.addpage(root, pathparser.parse(“pageone.childone”)); crawler.addpage(root, pathparser.parse(“pagetwo”)); pagedata data = pageone.getdata(); wikipageproperties properties = data.getproperties(); 174wikipageproperty symlinks = properties.set(symbolicpage.property_name); symlinks.set(“sympage”, “pagetwo”); pageone.commit(data); request.setresource(“root”); request.addinput(“type”, “pages”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“<name>pageone</name>”, xml); assertsubstring(“<name>pagetwo</name>”, xml); assertsubstring(“<name>childone</name>”, xml); assertnotsubstring(“sympage”, xml); } public void testgetdataashtml() throws exception { crawler.addpage(root, pathparser.parse(“testpageone”), “test page”); request.setresource(“testpageone”); request.addinput(“type”, “data”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“test page”, xml); assertsubstring(“<test”, xml); } fíjese en las invocaciones de pathparser . transforman cadenas en instancias de pagepath usadas por las arañas. esta transformación es totalmente irrelevante para la prueba y únicamente complica su cometido. los detalles circundantes a la creación del respondedor y la obtención y conversión de la respuesta también sobran. también la forma de crear la url de solicitud a partir de un recurso y un argumento (contribuí a crear este código, por lo que tengo todo el derecho a criticarlo). al final, el código no se ha diseñado de forma legible. el lector se ve rodeado de miles de detalles que debe comprender antes de que las pruebas tengan sentido. fíjese ahora en las pruebas mejoradas del listado 9-2. hacen exactamente lo mismo, pero se han refactorizado de forma más clara y 175descriptiva. listado 9-2 serializedpagerespondertest.java (refactorizado) public void testgetpagehierarchyasxml() throws exception { makepages(“pageone”, “pageone.childone”, “pagetwo”); submitrequest(“root”, “type:pages”); assertresponseisxml(); assertresponsecontains( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); } public void testsymboliclinksarenotinxmlpagehierarchy() throws exception { wikipage page = makepage(“pageone”); makepages(“pageone.childone”, “pagetwo”); addlinkto(page, “pagetwo”, “sympage”); submitrequest(“root”, “type:pages”); assertresponseisxml(); assertresponsecontains( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); assertresponsedoesnotcontain(“sympage”); } public void testgetdataasxml() throws exception { makepagewithcontent(“testpageone”, “test page”); submitrequest(“testpageone”, “type:data”); assertresponseisxml(); assertresponsecontains(“test page”, “<test”); } el patrón generar-operar-comprobar [38] es evidente en la estructura de las pruebas. cada una se divide claramente en tres partes. la primera crea los datos de prueba, la segunda opera en dichos datos y la tercera comprueba que la operación devuelva los resultados esperados. comprobará que se ha eliminado gran parte de los detalles molestos. las pruebas son concisas y sólo usan los tipos de datos y funciones que realmente necesitan. todo el que lea estas pruebas sabrá rápidamente para qué sirven y no se perderá entre detalles irrelevantes. 176lenguaje de pruebas específico del dominio las pruebas del listado 9-2 ilustran la creación de un lenguaje específico del dominio para sus pruebas. en lugar de usar las api que los programadores emplean para manipular el sistema, creamos una serie de funciones y utilidades que usan dichas api y que facilitan la escritura y la lectura de las pruebas. estas funciones y utilidades se convierten en una api especializada usada por las pruebas. son un lenguaje de pruebas que los programadores usan personalmente para crear sus pruebas y para ayudar a los que después las lean. esta api de pruebas no se diseña con antelación, sino que evoluciona con la refactorización continuada del código de prueba. al igual que refactorizamos el listado 9-1 en el listado 9-2, los programadores disciplinados refactorizan su código de prueba en versiones más sucintas y expresivas. un estándar dual en un sentido, el equipo que mencionamos antes tenía razón. el código de la api de pruebas tiene un conjunto de estándares de ingeniería diferentes al código de producción. también tiene que ser sencillo, sucinto y expresivo, pero no tan eficaz como el código de producción. después de todo, se ejecuta en un entorno de prueba, no de producción, y cada entorno tiene sus propias necesidades. fíjese en la prueba del listado 9-3. la creé como parte de un prototipo de sistema de control medioambiental. sin entrar en detalles, se aprecia que esta prueba comprueba que la alarma de baja temperatura, el calentador y el fuelle estén activados cuando la temperatura sea demasiado fría. listado 9-3 environmentcontrollertest.java @test public void turnonlotempalarmatthreashold() throws exception { hw.settemp(way_too_cold); 177controller.tic(); asserttrue(hw.heaterstate()); asserttrue(hw.blowerstate()); assertfalse(hw.coolerstate()); assertfalse(hw.hitempalarm()); asserttrue(hw.lotempalarm()); } aquí hay muchos detalles. por ejemplo, ¿para qué sirve la función tic ? de hecho, la ignoraría mientras leemos esta prueba. intente centrarse en saber si está de acuerdo en que el estado final del sistema tiene que ver con que la temperatura sea demasiado baja. al leer la prueba, la vista tiene que cambiar entre el nombre del estado comprobado y el sentido del estado comprobado. vemos heaterstate y después la vista salta a asserttrue . vemos coolerstate y nos fijamos en assertfalse . resulta tedioso y dificulta la lectura de la prueba. he conseguido mejorar la legibilidad de la prueba transformándola en el listado 9-4. listado 9-4 environmentcontrollertest.java (refactorizado) @test public void turnonlotempalarmatthreshold() throws exception { waytoocold(); assertequals(“hbchl”, hw.getstate()); } evidentemente, he ocultado el detalle de la función tic creando una función waytoocold . pero lo importante es la extraña cadena de assertequals . las mayúsculas significan activado y las minúsculas desactivado, y las letras siempre aparece en este orden: {heater, blower, cooler, hi-temp-alarm, lo-temp-alarm} . aunque prácticamente sea un incumplimiento de las reglas de asignación mental [39] , en este caso parece apropiado. una vez que conocemos el significado, la vista pasa por la cadena y podemos interpretar los resultados. la lectura de la prueba es casi un placer. fíjese en el listado 9-5 y compruebe con qué facilidad entiende las pruebas. 178listado 9-5 environmentcontrollertest.java (una selección mayor). @test public void turnoncoolerandbloweriftoohot() throws exception { toohot(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonheaterandbloweriftoocold() throws exception { toocold(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonhitempalarmatthreshold() throws exception { waytoohot(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonlotempalarmatthreshold() throws exception { waytoocold(); assertequals(“hbchl”, hw.getstate()); } la función getstate se reproduce en el listado 9-6. no es un código muy eficaz. para que lo sea, deberíamos haber usado stringbuffer . listado 9-6 mockcontrolhardware.java. public string getstate() { string state = “”; state += heater ? “h” : “h”; state += blower ? “b” : “b”; state += cooler ? “c” : “c”; state += hitempalarm ? “h” : “h”; state += lotempalarm ? “l” : “l”; return state; } stringbuffer es poco atractivo. incluso en código de producción, intento evitarlo si el coste es mínimo, como podría suceder en el listado 9-6. pero esta aplicación es claramente un sistema incrustado en tiempo real y es probable que los recursos del equipo y la memoria estén limitados. sin 179embargo, el entorno de pruebas es improbable que lo esté. es la naturaleza del estándar dual. hay cosas que nunca haría en un entorno de producción totalmente válidas para un entorno de prueba. suelen ser problemas de memoria o eficacia de la cpu, pero nunca problemas de limpieza. una afirmación por prueba existe una escuela de pensamiento [40] que afirma que todas las funciones de prueba de una prueba junit sólo deben tener una instrucción de afirmación. puede parecer una regla draconiana pero la ventaja se aprecia en el listado 9- 5. las pruebas llegan a una misma conclusión, que se entiende de forma rápida y sencilla. ¿pero qué sucede con el listado 9-2? no parece razonable afirmar que el resultado es xml y que contiene determinadas subcadenas. sin embargo, podemos dividir la prueba en dos, cada una con una afirmación concreta, como se muestra en el listado 9-7. listado 9-7 serializedpagerespondertest.java (una sola afirmación). public void testgetpagehierarchyasxml() throws exception { givenpages(“pageone”, “pageone.childone”, “pagetwo”); whenrequestisissued(“root”, “type:pages”); thenresponseshouldbexml(); } public void testgetpagehierarchyhasrighttags() throws exception { givenpages(“pageone”, “pageone.childone”, “pagetwo”); whenrequestisissued(“root”, “type:pages”); thenresponseshouldcontain( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); } he cambiado los nombres de las funciones para usar la convención dado- cuando-entonces [41] . de este modo las pruebas son más fáciles de leer. desafortunadamente, al dividir las pruebas se genera código duplicado. 180podemos eliminar los duplicados por medio del patrón método de plantilla [42] e incluir las partes dado/cuando en la clase base, y las partes entonces en derivaciones diferentes. o podríamos crear una clase de prueba independiente e incluir las partes dado y cuando en la función @before y las partes entonces en cada función @test . pero parece un mecanismo excesivo para un problema tan menor. al final, opto por las afirmaciones múltiples del listado 9-2. considero que la regla de una sola afirmación es una directriz adecuada [43] . siempre intento crear un lenguaje de pruebas específico del dominio que la complemente, como en el listado 9-5, pero no rechazo incluir más de una afirmación en una prueba. creo que lo mejor que podemos decir es que el número de afirmaciones de una prueba debe ser mínimo. un solo concepto por prueba puede que una regla más indicada sea probar un único concepto en cada función de prueba. no queremos extensas funciones que prueben una cosa diferente tras otra, como sucede en el listado 9-8. esta prueba debería dividirse en tres diferentes que probaran tres cosas distintas. al combinarlas en la misma función se obliga al lector a determinar por qué cada sección se ubica en ese punto y qué prueba dicha sección. listado 9-8 /** * varias pruebas para el método addmonths(). */ public void testaddmonths() { serialdate d1 = serialdate.createinstance(31, 5, 2004); serialdate d2 = serialdate.addmonths(1, d1); assertequals(30, d2.getdayofmonth()); assertequals(6, d2.getmonth()); assertequals(2004, d2.getyyyy()); serialdate d3 = serialdate.addmonths(2, d1); assertequals(31, d3.getdayofmonth()); assertequals(7, d3.getmonth()); assertequals(2004, d3.getyyyy()); 181serialdate d4 = serialdate.addmonths(1, serialdate.addmonths(1, d1)); assertequals(30, d4.getdayofmonth()); assertequals(7, d4.getmonth()); assertequals(2004, d4.getyyyy()); } las tres funciones deberían ser las siguientes: dado el último día de un mes con 31 días (como mayo): 1 . cuando se añade un mes, si el último día de ese mes es el 30 (como en junio), entonces la fecha debe ser el día 30 de ese mes, no el 31. 2 . cuando se añaden dos meses a esa fecha, si el último mes tiene 31 días, entonces la fecha debe ser el día 31. dado el último día de un mes con 30 días (como junio): 1 . cuando se añade, si el último día de ese mes tiene 31 días, entonces la fecha debe ser el 30, no el 31. expresado de esta forma, se aprecia que existe una regla general entre las distintas pruebas. al incrementar el mes, la fecha no puede ser mayor que su último día. esto implica que al incrementar el mes en el 28 de febrero debe generarse el 28 de marzo. falta esa prueba y convendría que la escribiéramos. así pues, no son las múltiples afirmaciones del listado 9-8 las causantes del problema, sino el hecho de que se prueba más de un concepto. probablemente la regla óptima sea minimizar el número de activos por concepto y probar un solo concepto por función de prueba. f.i.r.s.t. [44] las pruebas limpias siguen otras cinco reglas, cuyas iniciales forman las siglas first en inglés: rapidez ( fast ): las reglas deben ser rápidas y ejecutarse de forma rápida. si lo hacen lentamente, no las ejecutará con frecuencia. al no hacerlo, no detectará los problemas con la suficiente antelación como para solucionarlos. no se sentirá con libertad para limpiar el código, que acabará corrompiéndose. 182independencia ( independent ): las pruebas no deben depender entre ellas. una prueba no debe establecer condiciones para la siguiente. debe poder ejecutar cada prueba de forma independiente y en el orden que desee. si las pruebas dependen unas de otras, la primera que falle provocará una sucesión de fallos, dificultará el diagnóstico y ocultará efectos posteriores. repetición ( repeatable ): las pruebas deben poder repetirse en cualquier entorno. debe poder ejecutarlas en el entorno de producción, en el de calidad y en su portátil de camino a casa en un tren sin red. si no puede repetir las pruebas en cualquier entorno, siempre tendrá una excusa de su fallo. también verá que no puede ejecutar las pruebas si el entorno no está disponible. validación automática ( self-validating ): las pruebas deben tener un resultado booleano: o aciertan o fallan. no debe tener que leer un extenso archivo de registro para saber si una prueba ha acertado, ni comparar manualmente dos archivos de texto distintos para ello. si las pruebas no se validan automáticamente, el fallo puede ser subjetivo y la ejecución de las pruebas puede requerir una extensa evaluación manual. puntualidad ( timely ): las pruebas deben crearse en el momento preciso: antes del código de producción que hace que acierten. si crea las pruebas después del código de producción, puede que resulte difícil probarlo. puede decidir qué parte del código de producción sea demasiado difícil de probar. no diseñe código de producción que no se pueda probar. conclusión apenas hemos abordado la superficie de este tema. de hecho, se podría crear un libro entero sobre pruebas limpias. las pruebas son tan importantes para la salud de un proyecto como el código de producción. puede que incluso más, ya que conservan y mejoran la flexibilidad, capacidad de mantenimiento y reutilización del código de producción. por ello, intente que sean limpias. trabaje para que resulten expresivas y concisas. invente api de prueba que actúen como lenguaje específico del dominio que le ayude a crear las pruebas. si deja que las pruebas se corrompan, sucederá lo mismo con el código de 183producción. mantenga limpias las pruebas. bibliografía [rspec] : rspec: behavior driven development for ruby programmers , aslak hellesay, david chelimsky, pragmatic bookshelf, 2008. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 18410 clases con jeff langr hasta ahora nos hemos centrado en escribir bien líneas y bloques de código. nos hemos adentrado en la correcta composición de las funciones y en su interrelación. pero a pesar de la atención dedicada a la expresividad de las instrucciones y las funciones, no tendremos código limpio hasta que nos fijemos en los niveles superiores de su organización. hablemos sobre clases. 185organización de clases de acuerdo a la convención estándar de java, una clase debe comenzar con una lista de variables. las constantes estáticas públicas, si existen, deben aparecer primero. tras ello, las variables estáticas privadas y después las variables de instancia privadas. no suele ser necesario usar variables públicas. las funciones públicas deben seguir a la lista de variables. incluimos las utilidades públicas invocadas por una función pública tras la propia función pública. este sistema cumple la regla descendente y permite que el programa se lea como un artículo de periódico. encapsulación queremos que nuestras variables y funciones de utilidad sean privadas, pero no es imprescindible. en ocasiones podemos proteger una variable o función de utilidad para que sea accesible para una prueba. las reglas mandan. si una regla del mismo paquete tiene que invocar una función o acceder a una variable, hacemos que tenga ámbito protected o de paquete. sin embargo, primero veremos una forma de mantener la privacidad. la relajación de la encapsulación siempre es un último resorte. las clases deben ser de tamaño reducido la primera regla de las clases es que deben ser de tamaño reducido. la segunda regla es que deben ser todavía más reducidas. no, no vamos a repetir el mismo texto en el capítulo sobre las funciones, pero como sucede con las funciones, el tamaño reducido es lo principal a la hora de diseñar una clase. y la pregunta inmediata es qué nivel de reducción. con las funciones medimos el tamaño contando líneas físicas. con las clases usamos otra medida distinta: las responsabilidades [45] . el listado 10-1 muestra una clase, superdashboard , que muestra 70 186métodos públicos. muchos programadores estarán de acuerdo en que es un tamaño excesivo. algunos denominarían a superdashboard una clase dios. listado 10-1 demasiadas responsabilidades. public class superdashboard extends jframe implements metadatauser public string getcustomizerlanguagepath() public void setsystemconfigpath(string systemconfigpath) public string getsystemconfigdocument() public void setsystemconfigdocument(string systemconfigdocument) public boolean getgurustate() public boolean getnovicestate() public boolean getopensourcestate() public void showobject(metaobject object) public void showprogress(string s) public boolean ismetadatadirty() public void setismetadatadirty(boolean ismetadatadirty) public component getlastfocusedcomponent() public void setlastfocused(component lastfocused) public void setmouseselectstate(boolean ismouseselected) public boolean ismouseselected() public languagemanager getlanguagemanager() public project getproject() public project getfirstproject() public project getlastproject() public string getnewprojectname() public void setcomponentsizes(dimension dim) public string getcurrentdir() public void setcurrentdir(string newdir) public void updatestatus(int dotpos, int markpos) public class[] getdatabaseclasses() public metadatafeeder getmetadatafeeder() public void addproject(project project) public boolean setcurrentproject(project project) public boolean removeproject(project project) public metaprojectheader getprogrammetadata() public void resetdashboard() public project loadproject(string filename, string projectname) public void setcansavemetadata(boolean cansave) public metaobject getselectedobject() public void deselectobjects() public void setproject(project project) public void editoraction(string actionname, actionevent event) public void setmode(int mode) public filemanager getfilemanager() public void setfilemanager(filemanager filemanager) public configmanager getconfigmanager() public void setconfigmanager(configmanager configmanager) public classloader getclassloader() 187public void setclassloader(classloader classloader) public properties getprops() public string getuserhome() public string getbasedir() public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() public metaobject pasting( metaobject target, metaobject pasted, metaproject project) public void processmenuitems(metaobject metaobject) public void processmenuseparators(metaobject metaobject) public void processtabpages(metaobject metaobject) public void processplacement(metaobject object) public void processcreatelayout(metaobject object) public void updatedisplaylayer(metaobject object, int layerindex) public void propertyeditedrepaint(metaobject object) public void processdeleteobject(metaobject object) public boolean getattachedtodesigner() public void processprojectchangedstate(boolean hasprojectchanged) public void processobjectnamechanged(metaobject object) public void runproject() public void setallowdragging(boolean allowdragging) public boolean allowdragging() public boolean iscustomizing() public void settitle(string title) public idemenubar getidemenubar() public void showhelper(metaobject metaobject, string propertyname) //… y otros muchos métodos no públicos… } ¿y si superdashboard sólo incluyera los métodos mostrados en el listado 10-2? listado 10-2 ¿suficientemente reducido? public class superdashboard extends jframe implements metadatauser public component getlastfocusedcomponent() public void setlastfocused(component lastfocused) public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() } cinco métodos no es demasiado, ¿verdad? en este caso sí ya que a pesar del reducido número de métodos, superdashboard también tiene demasiadas responsabilidades. el nombre de una clase debe describir las responsabilidades que 188desempeña. de hecho, el nombre es la primera forma para determinar el tamaño de una clase. si no podemos derivar un nombre conciso para una clase, seguramente sea demasiado extenso. cuanto más ambiguo sea el nombre de la clase, más probabilidades hay de que tenga demasiadas responsabilidades. por ejemplo, los nombres de clase con palabras como processor , manager o super suelen indicar una desafortunada acumulación de responsabilidades. también debemos ser capaces de escribir una breve descripción de la clase en unas 25 palabras, sin usar las palabras « si », « o », « y » o « pero ». ¿cómo describiríamos superdashboard ?: superdashboard permite acceder al componente con el enfoque y nos permite controlar los números de versión y producto. el primer y indica que superdashboard tiene demasiadas responsabilidades. el principio de responsabilidad única el principio de responsabilidad única ( single responsibility principle , srp) [46] indica que una clase o módulo debe tener uno y sólo un motivo para cambiar. este principio nos indica la definición de responsabilidad y una directriz para el tamaño de la clase. las clases sólo deben tener una responsabilidad, un motivo para cambiar. la clase superdashboard aparentemente reducida del listado 10-2 tiene dos motivos para cambiar. primero, controla información de versión que supuestamente debe actualizarse cada vez que se comercialice el software . por otra parte, gestiona componentes de java swing (un derivado de jframe, la representación swing de una ventana de igu de nivel superior). sin duda, querremos cambiar el número de versión si cambiamos el código swing, pero lo contrario no es necesario: podríamos cambiar la información de versión en función de los cambios de otro código del sistema. la identificación de responsabilidades (los motivos del cambio) nos permite reconocer y mejorar las abstracciones en nuestro código. podemos extraer los tres métodos de superdashboard relacionados con la información de versiones en una clase independiente como version (véase el listado 10-3.) la clase version es una construcción 189que se puede reutilizar en otras aplicaciones. listado 10-3 una clase con una única responsabilidad. public class version { public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() } srp es uno de los conceptos más importantes del diseño orientado a objetos y también uno de los más sencillos de entender y cumplir, pero también es uno de los que más se abusa al diseñar clases. habitualmente nos encontramos clases que hacen demasiadas cosas. ¿por qué? crear software que funcione y crear software limpio son dos actividades diferentes. muchos tenemos un cerebro limitado, de modo que nos centramos en que el código funcione más que en su organización y limpieza. es algo totalmente válido. mantener objetivos separados es tan importante en nuestras actividades de programación como en nuestros programas. el problema es que muchos creemos que hemos terminado cuando el programa funciona. no cambiamos al otro objetivo de organización y limpieza. pasamos al siguiente problema en lugar de retroceder y dividir las clases en unidades independientes con una única responsabilidad. al mismo tiempo, muchos programadores temen que un elevado número de pequeñas clases con un único propósito dificulten la comprensión del conjunto. les preocupa que tengan que desplazarse entre las clases para determinar cómo funciona un aspecto concreto. sin embargo, un sistema con muchas clases reducidas no tiene más elementos móviles que un sistema con algunas clases enormes. en ambos hay que entender lo mismo. la pregunta es si quiere organizar sus herramientas en cajas con muchos pequeños cajones que contengan componentes bien definidos y etiquetados, o usar varios cajones grandes en los que mezcle todo. todos los sistemas tienen una gran lógica y complejidad. el objetivo principal para gestionar dicha complejidad es organizarla para que un programador sepa dónde buscar y comprenda la complejidad directamente afectada en cada momento concreto. por el contrario, un sistema con clases 190multipropósito de mayor tamaño nos obliga a buscar entre numerosos elementos que no siempre necesitamos conocer. para reformular los puntos anteriores, diremos que los sistemas deben estar formados por muchas claves reducidas, no por algunas de gran tamaño. cada clase reducida encapsula una única responsabilidad, tiene un solo motivo para cambiar y colabora con algunas otras para obtener los comportamientos deseados del sistema. cohesión las clases deben tener un número reducido de variables de instancia. los métodos de una clase deben manipular una o varias de dichas variables. por lo general, cuantas más variables manipule un método, más cohesión tendrá con su clase. una clase en la que cada variable se usa en cada método tiene una cohesión máxima. por lo general, no es recomendable ni posible crear este tipo de clases pero queremos que la cohesión de nuestras clases sea elevada. si lo logramos, significa que los métodos y variables de la clase dependen unos de otros y actúan como un todo lógico. fíjese en la implementación de stack en el listado 10-4. es una clase muy consistente. de los tres métodos, sólo size() no usa ambas variables. listado 10-4 stack.java, una clase consistente. public class stack { private int topofstack = 0; list<integer> elements = new linkedlist<integer>(); public int size() { return topofstack; } public void push(int element) { topofstack++; elements.add(element); } public int pop() throws poppedwhenempty { 191if (topofstack == 0) throw new poppedwhenempty(); int element = elements.get(--topofstack); elements.remove(topofstack); return element; } } la estrategia de reducir el tamaño de las funciones y de las listas de parámetros suele provocar la proliferación de variables de instancia usadas por un subconjunto de los métodos. si esto sucede, siempre existe al menos una clase que intenta huir de la clase de mayor tamaño. debe intentar separar las variables y métodos en dos o más clases para que las nuevas sean más consistentes. mantener resultados consistentes en muchas clases de tamaño reducido la división de grandes funciones en otras más pequeñas aumenta la proliferación de clases. imagine una gran función con numerosas variables declaradas. imagine que desea extraer una pequeña parte de esa función en otra independiente. sin embargo, el código que extrae usa cuatro de las variables declaradas en la función. ¿debe pasar las cuatro variables como argumentos a la nueva función? en absoluto. si ascendemos estas cuatro variables a variables de instancia de la clase, podremos extraer el código sin pasar las variables. resultaría más sencillo dividir la función en pequeños fragmentos. desafortunadamente, eso significaría que nuestras clases perderían cohesión ya que acumularían más y más variables de instancia que sólo existen para que otras funciones las compartan. pero un momento. si apenas existen funciones que compartan determinadas variables, ¿no son entonces una clase con derecho propio? por supuesto. cuando las clases pierdan cohesión, divídalas. por tanto, dividir una gran función en otras más reducidas también nos permite dividir varias clases más reducidas. de este modo mejora la organización del programa y su estructura resulta más transparente. como ejemplo, usaremos un ejemplo obtenido del libro de knuth literate 192programming [47] . el listado 10-5 muestra una traducción a java del programa printprimes de knuth. para hacerle justicia, no es el programa que creó sino el resultado generado por su herramienta web. lo usamos aquí por ser un magnífico punto de partida para dividir una función de gran tamaño en varias funciones y clases más reducidas. listado 10-5 printprimes.java package literateprimes; public class printprimes { public static void main(string[] args) { final int m = 1000; final int rr = 50; final int cc = 4; final int ww = 10; final int ordmax = 30; int p[] = new int[m + 1]; int pagenumber; int pageoffset; int rowoffset; int c; int j; int k; boolean jprime; int ord; int square; int n; int mult[] = new int[ordmax + 1]; j = 1; k = 1; p[1] = 2; ord = 2; square = 9; while (k < m) { do { j = j + 2; if (j == square) { ord = ord + 1; square = p[ord] * p[ord]; mult[ord - 1] = j; } n = 2; jprime = true; while (n < ord && jprime) { while (mult[n] < j) 193mult[n] = mult[n] + p[n] + p[n]; if (mult[n] == j) jprime = false; n = n + 1; } } while (!jprime); k = k + 1; p[k] = j; } { pagenumber = 1; pageoffset = 1; while (pageoffset <= m) { system.out.println(“the first ” + m + “ prime numbers --- page ” + pagenumber); system.out.println(“”); for (rowoffset = pageoffset; rowoffset < pageoffset + rr; rowoffset++) { for (c = 0; c < cc;c++) if (rowoffset + c * rr <= m) system.out.format(“%10d”, p[rowoffset + c * rr]); system.out.println(“”); } system.out.println(“\f”); pagenumber = pagenumber + 1; pageoffset = pageoffset + rr * cc; } } } } este programa, escrito como una sola función, es un desastre. el sangrado de su estructura es excesivo y hay demasiadas variables extrañas. como mínimo, la función debería dividirse en otras más pequeñas. los listados del 10-6 al 10-8 muestran la división del código del listado 10-5 en clases y funciones de menor tamaño, además de los nombres elegidos para dichas clases, funciones y variables. listado 10-6 primeprinter.java (refactorizado) package literateprimes; public class primeprinter ( public static void main(string[] args) { final int number_of_prime5 = 1000; int[] primes = primegenerator.generate(number_of_primes); final int rows_per_page = 50; 194final int columns_per_page = 4; rowcolumnpageprinter tableprinter = new rowcolumnpageprinter(rows_per_page, columns_per_page, “the first ” + number_of_primes + “ prime numbers”); tableprinter.print(primes); } } listado 10-7 rowcolumnpageprinter.java. package literateprimes; import java.io.printstream; public class rowcolumnpageprinter { private int rowsperpage; private int columnsperpage; private int numbersperpage; private string pageheader; private printstream printstream; public rowcolumnpageprinter(int rowsperpage, int columnsperpage, string pageheader) { this.rowsperpage = rowsperpage; this.columnsperpage = columnsperpage; this.pageheader = pageheader; numbersperpage = rowsperpage * columnsperpage; printstream = system.out; } public void print(int data[]) { int pagenumber = 1; for (int firstindexonpage = 0; firstindexonpage < data.length; firstindexonpage += numbersperpage) { int lastindexonpage = math.min(firstindexonpage + numbersperpage - 1, data.length - 1); printpageheader(pageheader, pagenumber); printpage(firstindexonpage, lastindexonpage, data); printstream.println(“\f”); pagenumber++; } } private void printpage (int firstindexonpage, int lastindexonpage, int[] data) { 195int firstindexoflastrowonpage = firstindexonpage + rowsperpage - 1; for (int firstindexinrow = firstindexonpage; firstindexinrow <= firstindexoflastrowonpage; firstindexinrow++) { printrow(firstindexinrow, lastindexonpage, data); printstream.println(“”); } } private void printrow(int firstindexinrow, int lastindexonpage, int[] data) { for (int column = 0; column < columnsperpage; column++) { int index = firstindexinrow + column * rowsperpage; if (index <= lastindexonpage) printstream.format(“%10d”, data[index]); } } private void printpageheader(string pageheader, int pagenumber) { printstream.println(pageheader + “ --- page ” + pagenumber); printstream.println(“”); } public void setoutput(printstream printstream) { this.printstream = printstream; } } listado 10-8 primegenerator.java package literateprimes; import java.util.arraylist; public class primegenerator { private static int[] primes; private static arraylist<integer> multiplesofprimefactors; protected static int[] generate(int n) { primes = new int[n]; multiplesofprimefactors = new arraylist<integer>(); set2asfirstprime(); checkoddnumbersforsubsequentprimes(); return primes; } private static void set2asfirtsprime() { primes[0] = 2; multiplesofprimefactors.add(2); 196} private static void checkoddnumbersforsubsequentprimes() { int primeindex = 1; for (int candidate = 3; primeindex < primes.length; candidate += 2) { if (isprime(candidate)) primes[primeindex++] = candidate; } } private static boolean isprime(int candidate) { if (isleastrelevantmultipleofnextlargerprimefactor(candidate)) { multiplesofprimefactors.add(candidate); return false; } return isnotmultipleofanypreviousprimefactor(candidate); } private static boolean isleastrelevantmultipleofnextlargerprimefactor(int candidate) { int nextlargerprimefactor = primes[multiplesofprimefactors.size()]; int leastrelevantmultiple = nextlargerprimefactor * nextlargerprimefactor; return candidate == leastrelevantmultiple; } private static boolean isnotmultipleofanypreviousprimefactor(int candidate) { for (int n = 1; n < multiplesofprimefactors.size(); n++) { if (ismultipleofnthprimefactor(candidate, n)) return false; } return true; } private static boolean ismultipleofnthprimefactor(int candidate, int n) { return candidate == smallestoddnthmultiplenotlessthancandidate(candidate, n); } private static int smallestoddnthmultiplenotlessthancandidate(int candidate, int n) { int multiple = multiplesofprimefactors.get(n); while (multiple < candidate) multiple += 2 * primes[n]; multiplesofprimefactors.set(n, multiple); return multiple; } } lo primero que apreciará es que ha aumentado la longitud del programa, 197de una a casi tres páginas. este aumento se debe a varios motivos. en primer lugar, el programa refactorizado usa nombres de variable más extensos y descriptivos. por otra parte, usa declaraciones de funciones y clases como comentarios del código. por último, usamos espacios en blanco y técnicas de formato para mantener la legibilidad. el programa se ha dividido en tres responsabilidades principales. la parte principal se incluye en la clase primeprinter , responsable de controlar el entorno de ejecución. cambia si se modifica el método de invocación. por ejemplo, si este programa se convierte en un servicio soa, es la clase que se verá afectada. rowcolumnpageprinter sabe cómo aplicar formato a una lista de números con una determinada cantidad de filas y columnas. si es necesario cambiar el formato del resultado, es la clase que se verá afectada. la clase primegenerator sabe cómo generar una lista de números primos. no se creará una instancia como objeto. la clase es sólo un ámbito útil en el que declarar y ocultar sus variables. esta clase cambia si se modifica el algoritmo para calcular números primos. no hemos reescrito el programa. no hemos empezado de cero y los hemos vuelto a diseñar. en realidad, si se fija atentamente en los dos programas, verá que usan los mismos algoritmos y mecanismos. el cambio se ha realizado creando una suite de pruebas que verifican el comportamiento preciso del primer programa. tras ello, se aplican numerosos cambios mínimos, de uno en uno. tras cada cambio, se ejecuta el programa para garantizar que el comportamiento no varía. paso a paso, el primer programa se limpia y se transforma en el segundo. organizar los cambios en muchos sistemas, el cambio es continuo. cada cambio supone un riesgo de que el resto del sistema no funcione de la forma esperada. en un sistema limpio organizamos las clases para reducir los riesgos de los cambios. la clase sql del listado 10-9 se usa para generar cadenas sql de forma correcta con los metadatos adecuados. es un trabajo continuo y, como tal, no 198admite funciones sql como instrucciones update . cuando la clase sql tenga que admitir una instrucción update , tendremos que abrirla para realizar modificaciones. el problema de abrir una clase es el riesgo que conlleva. cualquier modificación puede afectar a otro código de la clase. debe probarse concienzudamente. listado 10-9 clase que debemos abrir para realizar cambios. public class sql { public sql(string table, column[] columns) public string create() public string insert(object[] fields) public string selectall() public string findbykey(string keycolumn, string keyvalue) public string select(column column, string pattern) public string select(criteria criteria) public string preparedinsert() private string columnlist(column[] columns) private string valueslist(object[] fields, final column[] columns) private string selectwithcriteria(string criteria) private string placeholderlist(column[] columns) } la clase sql debe cambiar al añadir un nuevo tipo de instrucción. también debe cambiar cuando variemos los detalles de un tipo de instrucción concreto; por ejemplo, si tenemos que modificar la funcionalidad select para admitir selecciones secundarias. estos dos motivos de cambio significan que la clase sql incumple srp. podemos detectar este incumplimiento desde un punto de vista organizativo. el método outline de sql muestra que hay métodos privados, como selectwithcriteria , que parecen relacionarse únicamente con instrucciones select . el comportamiento de métodos privados aplicados a un pequeño subconjunto de una clase puede ser una heurística útil para detectar zonas que mejorar. sin embargo, la verdadera razón debe ser el cambio del sistema. si la clase sql se considera totalmente lógica, no debemos preocuparnos por separar las responsabilidades. si no necesitamos funcionalidad de actualización en el futuro, podemos olvidarnos de sql . pero si tenemos que 199abrir una clase, debemos corregir el diseño. ¿y si optamos por una solución como la del listado 10-10? los métodos públicos de interfaz definidos en sql en el listado 10-9 se refactorizan en sus propias variantes de la clase sql . los métodos privados, como valueslist , se mueven directamente a las posiciones necesarias. el comportamiento privado se reduce a un par de clases de utilidad: where y columnlist . listado 10-10 un grupo de clases cerradas. abstract public class sql { public sql(string table, column[] columns) abstract public string generate(); } public class createsql extends sql { public createsql(string table, column[] columns) @override public string generate() } public class selectsql extends sql { public selectsql(string table, column[] columns) @override public string generate() } public class insertsql extends sql { public selectsql(string table, column[] columns, object[] fields) @override public string generate() private string valueslist(object[] fields, final column[] columns) } public class selectwithcriteriasql extends sql { public selectwithcriteriasql( string table, column[] columns, criteria criteria) @override public string generate() } public class selectwithmatchsql extends sql { public selectwithmatchsql( string table, column[] columns, column column, string pattern) @override public string generate() } public class findbykeysql extends sql { public findbykeysql( string table, column[] columns, string keycolumn, string keyvalue) @override public string generate() } 200public class preparedinsertsql extends sql { public preparedinsertsql(string table, column[] columns) @override public string generate() private string placeholderlist(column[] columns) } public class where { public where(string criteria) public string generate() } public class columnlist { public columnlist(column[] columns) public string generate() } el código de cada clase se simplifica enormemente. el tiempo necesario para entender las clases se reduce al mínimo. el riesgo de que una función afecte a otra desaparece casi por completo. desde el punto de vista de las pruebas, resulta más sencillo probar la lógica de esta solución, ya que las clases se aíslan unas de otras. además, cuando llegue el momento de añadir las instrucciones update , no cambia ninguna de las clases existentes. añadimos la lógica para generar instrucciones update a una nueva subclase de sql , updatesql . este cambio no afecta a otro código del sistema. nuestra lógica sql reestructurada representa lo mejor de ambos mundos. cumple con srp y también con otro principio clave del diseño de clases orientadas a objetos, denominado principio abierto/cerrado [48] : las clases deben abrirse para su ampliación para cerrarse para su modificación. la nueva clase sql se abre a nuevas funcionalidades mediante la creación de subclases pero podemos realizar estos cambios y mantener cerradas las demás clases. basta con añadir nuestra clase updatesql . debemos estructurar nuestros sistemas para ensuciarlos lo menos posible cuando los actualicemos con nuevas funciones o cambios. en un sistema ideal, incorporamos nuevas funciones ampliándolo, no modificando el código existente. aislarnos de los cambios 201las necesidades cambiarán y también lo hará el código. en la programación orientada a objetos aprendemos que hay clases concretas que contienen detalles de implementación (el código) y clases abstractas que sólo representan conceptos. una clase cliente que dependa de detalles concretos está en peligro si dichos detalles cambian. podemos recurrir a interfaces y clases abstractas para aislar el impacto de dichos detalles. las dependencias de detalles de concretos crean retos para nuestro sistema. si tenemos que crear la clase portfolio y ésta depende de una api tokyostockexchange externa para obtener su valor, nuestros casos de prueba se verán afectados por la volatilidad de esta búsqueda. resulta complicado crear una prueba cuando se obtiene una respuesta diferente cada cinco minutos. en lugar de diseñar portfolio para que dependa directamente de tokyostockexchange , creamos una interfaz, stockexchange , que declara un único método: public interface stockexchange { money currentprice(string symbol); } diseñamos tokyostockexchange para implementar esta interfaz. también nos aseguramos de que el constructor de portfolio adopte como argumento una referencia a stockexchange: public portfolio { private stockexchange exchange; public portfolio(stockexchange exchange) { this.exchange = exchange; } //… } ahora la prueba puede crear una implementación de la interfaz stockexchange que emule tokyostockexchange . esta implementación de prueba fijará el valor actual del símbolo que usemos en la prueba. si nuestra prueba demuestra la adquisición de cinco acciones de microsoft para nuestra cartera de valores, diseñe el código de la implementación de prueba para que siempre devuelva 100 dólares por acción de microsoft. nuestra implementación de prueba de la interfaz stockexchange se reduce a una sencilla búsqueda de tabla. de este modo 202podemos crear una prueba que espere un valor de cartera total de 500 dólares: public class portfoliotest { private fixedstockexchangestub exchange; private portfolio portfolio; @before protected void setup() throws exception { exchange = new fixedstockexchangestub(); exchange.fix(“msft”, 100); portfolio = new portfolio(exchange); } @test public void givenfivemsfttotalshouldbe500() throws exception { portfolio.add(5, “msft”); assert.assertequals(500, portfolio.value()); } } si diseccionamos un sistema para poder probarlo de esta forma, resultará más flexible y se podrá reutilizar. la ausencia de conexiones significa que los elementos del sistema se aíslan entre ellos y de otros cambios. este aislamiento hace que comprendamos mejor los elementos del sistema. al minimizar las conexiones de esta forma, nuestras clases cumplen otro principio de diseño: dependency inversion principle (dip) o principio de inversión de dependencias [49] . básicamente afirma que nuestras clases deben depender de abstracciones, no de detalles concretos. en lugar de depender de los detalles de implementación de la clase tokyostockexchange , nuestra clase portfolio depende de la interfaz stockexchange , que representa el concepto abstracto de solicitar el precio actual de una acción. esta abstracción aísla todos los datos concretos de la obtención de dicho precio, incluyendo de dónde se obtiene. bibliografía [rdd] : object design: roles, responsibilities, and collaborations , rebecca wirfs-brock et al., addison-wesley, 2002. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. 203[knuth92] : literate programming , donald e. knuth, center for the study of language and information, leland stanford junior university, 1992. 20411 sistemas por el dr. kevin dean wampler 205«la complejidad es letal. acaba con los desarrolladores y dificulta la planificación, generación y pruebas de los productos». —ray ozzie, cto, microsoft corporation cómo construir una ciudad ¿podría encargarse de todos los detalles por su cuenta? seguramente no. incluso la gestión de una ciudad existente sería demasiado para una sola persona. y aun así, las ciudades funcionan (en la mayoría de los casos). funcionan porque tienen equipos que controlan partes concretas de la ciudad, el alcantarillado, la red eléctrica, el tráfico, la seguridad, las normativas 206urbanísticas, etc. algunos se encargan de aspectos generales y otros se centran en los detalles. las ciudades también funcionan porque disponen de evolucionados niveles de abstracción y modularidad que permiten a individuos y componentes trabajar de forma eficaz, sin necesidad de entender el trasfondo general. aunque los equipos de software se suelen organizar de esta forma, los sistemas en los que trabajan no suelen contar con la misma separación de aspectos y niveles de abstracción. en este capítulo veremos cómo mantener la limpieza en niveles superiores de abstracción, en el sistema. separar la construcción de un sistema de su uso en primer lugar, recuerde que la construcción es un proceso muy diferente al uso. mientras escribo estas líneas, a través de la ventana veo un nuevo hotel en construcción en chicago. hoy instalarán una gran grúa. todos los obreros llevan casco. dentro de un año habrán acabado el hotel. la grúa desaparecerá. el edificio estará terminado, con su reluciente fachada de cristal y su atractiva decoración. la gente que trabajará en él también será diferente. los sistemas de software deben separar el proceso de inicio, en el que se crean los objetos de la aplicación y se conectan las dependencias, de la lógica de ejecución que toma el testigo tras el inicio. el proceso de inicio es un aspecto que toda aplicación debe abordar. es el primero que veremos en este capítulo. la separación de aspectos es una de las técnicas de diseño más antiguas e importantes de nuestra profesión. desafortunadamente, muchas aplicaciones no lo hacen. el código del proceso de inicio se mezcla con la lógica de tiempo de ejecución. veamos un ejemplo típico: public service getservice() { if (service == null) service = new myserviceimpl (…); //¿lo bastante predeterminado para la 207mayoría de los casos? return service; } es la técnica de inicialización/evaluación tardía y tiene sus méritos. no incurrimos en la sobrecarga de la construcción a menos que usemos el objeto realmente, y como resultado el tiempo de inicio se puede acelerar. también evitamos que se devuelva null . sin embargo, ahora tenemos una dependencia en myserviceimpl y todo lo que su constructor requiere (que he omitido). no podemos compilar sin resolver estas dependencias, aunque nunca usemos un objeto de este tipo en tiempo de ejecución. las pruebas también pueden ser un problema. si myserviceimpl es un objeto pesado, tendremos que asegurarnos de asignar el correspondiente test double [50] u objeto simulado al campo de servicio antes de invocar este método en las pruebas de unidad. como la lógica de la construcción se mezcla con el procesamiento normal de tiempo de ejecución, debemos probar todas las rutas de ejecución (como la prueba null y su bloque). al contar con ambas responsabilidades, el método hace más de una cosa, por lo que se incumple el principio de responsabilidad única. lo peor de todo es que no sabemos si myserviceimpl es el objeto correcto en todos los casos. ¿por qué la clase con este método tiene que conocer el contexto global? ¿podemos saber realmente cuál es el objeto correcto que usar aquí? ¿es posible que un mismo tipo sea el correcto para todos los contextos posibles? un caso de inicialización tardía no es un problema serio. sin embargo, suele haber muchos casos de este tipo de configuración en las aplicaciones. por tanto, la estrategia de configuración global (si existe) se disemina por la aplicación, sin apenas modularidad y con una significativa duplicación. si somos diligentes sobre el diseño de sistemas robustos y bien formados, no debemos permitir fallos de modularidad. el proceso de inicio de la construcción y conexión de objetos no es una excepción. debemos modularizar este proceso y asegurarnos de contar con una estrategia global y coherente para resolver las dependencias principales. 208separar main una forma de separar la construcción del uso consiste en trasladar todos los aspectos de la construcción a main o a módulos invocados por main , y diseñar el resto del sistema suponiendo que todos los objetos se han creado y conectado correctamente (véase la figura 11.1). el flujo de control es fácil de seguir. la función main crea los objetos necesarios para el sistema, los pasa a la aplicación y ésta los utiliza. verá que las flechas de dependencia atraviesan la barrera entre main y la aplicación. todas van en la misma dirección, alejándose de main , lo que significa que la aplicación no tiene conocimiento de main ni del proceso de construcción. simplemente espera que todo se haya construido correctamente. figura 11.1. separación de la construcción en main() . factorías en ocasiones, la aplicación tendrá que ser responsable de la creación de un objeto. por ejemplo, en un sistema de procesamiento de pedidos, la aplicación debe crear las instancias lineitem que añadir a order . en este caso, podemos usar el patrón de factoría abstracta [51] para que la aplicación controle cuándo crear lineitem , pero mantener los detalles de dicha construcción separados del código de la aplicación (véase la figura 11.2). 209de nuevo vemos que todas las dependencias se desplazan desde main a la aplicación orderprocessing , lo que significa que la aplicación se desconecta de los detalles de creación de lineitem . esta capacidad se incluye en lineitemfactoryimplementation , en el extremo main de la línea. y sin embargo, la aplicación tiene control total sobre cuándo se crean las instancias lineitem e incluso puede proporcionar argumentos de constructor específicos de la aplicación. figura 11.2. separación de la construcción con una factoría. inyectar dependencias un potente mecanismo para separar la construcción del uso es la inyección de dependencias, la aplicación de inversión de control ( inversion of control o ioc) a la administración de dependencias [52] . la inversión de control pasa responsabilidades secundarias de un objeto a otros dedicados a ese cometido, por lo que admite el principio de responsabilidad única. en el contexto de la administración de dependencias, un objeto no debe ser responsable de instanciar dependencias, sino que debe delegar esta responsabilidad en otro mecanismo autorizado, de modo que se invierte el control. como la configuración es un aspecto global, este mecanismo autorizado suele ser la 210rutina main o un contenedor de propósito especial. las búsquedas jndi son una implementación parcial de la inyección de dependencias, en las que un objeto solicita a un servidor de directorios un servicio que coincida con un nombre concreto. myservice myservice = (myservice)(jndicontext.lookup(“nameofmyservice”)); el objeto invocador no controla el tipo de objeto devuelto (siempre que implemente la interfaz correcta, evidentemente), pero es el que resuelve la dependencia de forma activa. la verdadera inyección de dependencias va un paso más allá. la clase no hace nada directamente para resolver sus dependencias, es totalmente pasiva. por el contrario, ofrece métodos de establecimiento o argumentos de constructor (o ambos) que se usan para inyectar las dependencias. en el proceso de construcción, el contenedor de inyección de dependencias crea instancias de los objetos necesarios (normalmente bajo demanda) y usa los argumentos de constructor o métodos de establecimiento proporcionados para conectar las dependencias. los objetos dependientes empleados suelen especificarse a través de un archivo de configuración o mediante programación en un módulo de construcción de propósito especial. la estructura spring proporciona el contenedor de inyección de dependencias más conocido para java [53] . los objetos que se van a conectar se definen en un archivo de configuración xml y después se solicitan objetos concretos por nombre en código de java. veremos un ejemplo en breve. ¿y qué sucede con las virtudes de la inicialización tardía? en ocasiones es útil con la inyección de dependencias. por un lado, muchos contenedores de inyección de dependencias no crean un objeto hasta que es necesario. por otra parte, muchos de estos contenedores cuentan con mecanismos para invocar factorías o crear proxies que se pueden usar para evaluación tardía y optimizaciones similares [54] . evolucionar las ciudades nacen de pueblos, que nacen de asentamientos. inicialmente, los 211caminos son estrechos y prácticamente inexistentes, después se asfaltan y aumentan de tamaño. los pequeños edificios y solares vacíos se llenan de otros mayores que acaban convirtiéndose en rascacielos. al principio no hay servicios, electricidad, agua, alcantarillado o internet (¡vaya!). estos servicios se añaden cuando aumenta la densidad de población. este crecimiento no es fácil. cuántas veces mientras conduce por una carretera llena de baches y ve una señal de obras no se ha preguntado por qué no la hicieron más ancha desde un principio. no se podía haber hecho de otra forma. ¿quién puede justificar el gasto en una autopista de seis carriles que atraviese un pequeño pueblo como anticipación a un supuesto crecimiento? ¿quién querría una autopista así en su ciudad? conseguir sistemas perfectos a la primera es un mito. por el contrario, debemos implementar hoy, y refactorizar y ampliar mañana. es la esencia de la agilidad iterativa e incremental. el desarrollo controlado por pruebas, la refactorización y el código limpio que generan hace que funcione a nivel del código. ¿pero qué sucede en el nivel del sistema? ¿la arquitectura del sistema no requiere una planificación previa? sin duda no puede aumentar incrementalmente algo sencillo a algo complejo, ¿o sí? los sistemas de software son únicos si los comparamos con los sistemas físicos. sus arquitecturas pueden crecer incrementalmente, si mantenemos la correcta separación de los aspectos. la naturaleza efímera de los sistemas de software hace que sea posible, como veremos. primero nos centraremos en una arquitectura que no separa correctamente los aspectos. las arquitecturas ejb1 y ejb2 originales no separaban correctamente los aspectos y por tanto imponían barreras innecesarias al crecimiento orgánico. imagine un bean de entidad para una clase bank persistente. un bean de entidad es una representación en memoria de datos relacionales, es decir, una fila de una tabla. primero, debe definir una interfaz local (en proceso) o remota (mvj 212independiente), que los clientes usen. el listado 1-1 muestra una posible interfaz local: listado 11-1 una interfaz local ejb2 para el ejb bank. package com.example.banking; import java.util.collections; import javax.ejb.*; public interface banklocal extends java.ejb.ejblocalobject { string getstreetaddrl{} throws ejbexception; string getstreetaddr2{} throws ejbexception; string getcity() throws ejbexception; string getstate() throws ejbexception; string getzipcode() throws ejbexception; void setstreetaddr1(string street1) throws ejbexception; void setstreetaddr2(string street2) throws ejbexception; void setcity(string city) throws ejbexception; void setstate(string state) throws ejbexception; void setzipcode(string zip) throws ejbexception; collection getaccounts() throws ejbexception; void setaccounts(collection accounts) throws ejbexception; void addaccount(accountdto accountdto) throws ejbexception; } mostramos diversos atributos de la dirección de bank y una colección de cuentas del banco, cuyos datos se procesarán por un ejb account diferente. el listado 11-2 muestra la correspondiente clase de implementación del bean bank . listado 11-2 implementación del bean de entidad ejb2. package com.example.banking; import java.util.collections; import javax.ejb.*; public abstract class bank implements javax.ejb.entitybean { // lógica empresarial… public abstract string getstreeraddr1(); public abstract string getstreetaddr2(); public abstract string getcity(); public abstract string getstate(); public abstract string getzipcode(); public abstract void setstreetaddr1(string street1); 213public abstract void setstreetaddr2(string street2); public abstract void setcity(string city); public abstract void setstate(string state); public abstract void setzipcode(string zip); public abstract collection getaccounts(); public abstract void setaccounts(collection accounts); public void addaccount(accountpto accountdto) { initialcontext context = new initialcontext(); accounthomelocal accounthome = context.lookup(“accounthomelocal”); accountlocal account = accounthome.create(accountdto); collection accounts = getaccounts(); accounts.add(account); } // lógica del contenedor ejb public abstract void setid(integer id); public abstract integer getid(); public integer ejbcreate(integer id) {…} public void ejbpostcreate(integer id) {…} // el resto tendría que implementarse pero se deja vacío: public void setentitycontext(entitycontext ctxt) {} public void unsetentitycontext() {} public void ejbactivate() {} public void ejbpassivate() {} public void ejbload() {} public void ejbstore() {} public void ejbremove() {} } no mostramos la correspondiente interfaz localhome , básicamente una factoría usada para crear objetos, no los métodos de consulta bank que pueda añadir. por último, debemos crear uno o varios descriptores de implementación xml que especifiquen los detalles de asignación relacional de objetos en un almacén persistente, el comportamiento deseado de la transacción, limitaciones de seguridad y demás. la lógica empresarial está directamente conectada al contenedor de la aplicación ejb2. debe crear subclases de tipos de contenedor y proporcionar los métodos de ciclo vital necesarios para el contenedor. debido a esta conexión al contenedor pesado, las pruebas de unidad aisladas son complicadas. es necesario imitar el contenedor, algo difícil, o perder demasiado tiempo en la implementación de ejb y pruebas en un servidor real. la reutilización fuera de la arquitectura ejb2 es imposible, debido a esta estrecha conexión. por último, incluso la programación orientada a objetos se ve afectada. un bean no se puede heredar de otro. fíjese en la lógica para 214añadir una nueva cuenta. en bean ejb2 es habitual definir objetos de transferencia de datos ( data transfer objects o dto), estructuras sin comportamiento. esto suele generar tipos redundantes con los mismos datos y requiere código predefinido para copiar datos entre objetos. aspectos transversales la arquitectura ejb2 se acerca a la verdadera separación de aspectos en determinados aspectos. por ejemplo, los comportamientos transaccionales, de seguridad y comportamiento deseados se declaran en los descriptores de implementación, independientemente del código fuente. aspectos como la persistencia suelen cruzar los límites de objeto naturales de un dominio. por lo general intentará mantener todos sus objetos mediante la misma estrategia, por ejemplo con un determinado dbms [55] y no archivos planos, usando determinadas convenciones de nomenclatura para tablas y columnas, una semántica transaccional coherente, etc. en principio, puede razonar su estrategia de persistencia de una forma modular y encapsulada, pero en la práctica tendrá que distribuir el mismo código que implemente la estrategia de persistencia entre varios objetos. usamos el término transversales para este tipo de aspectos. de nuevo, la estructura de persistencia podría ser modular y la lógica de dominios, aislada, también. el problema es la intersección entre ambos dominios. de hecho, la forma en que la arquitectura ejb procesa persistencia, seguridad y transacciones es una programación orientada a aspectos ( aspect oriented programming o aop) [56] anticipada, un enfoque de carácter general para restaurar la modularidad en aspectos transversales. en aop, construcciones modulares denominadas aspectos especifican qué puntos del sistema deben modificar su comportamiento de forma coherente para admitir un determinado aspecto. esta especificación se realiza mediante un sucinto mecanismo de declaración o programación. si usamos la persistencia como ejemplo, podría declarar qué objetos y atributos (o patrones) deben conservarse y después delegar las tareas de persistencia a su estructura de persistencia. las modificaciones de 215comportamiento no son invasivas [57] para el código de destino. veamos tres aspectos o mecanismos similares en java. proxies de java los proxies de java son útiles en casos sencillos, como envolver invocaciones de métodos en objetos o clases concretas. sin embargo, los proxies dinámicos proporcionados en el jdk sólo funcionan con interfaces. para aplicarlos a clases, debe usar una biblioteca de manipulación de código de bytes , como cglib, asm o javassist [58] . el listado 11-3 muestra la estructura de un proxy jdk para ofrecer asistencia de persistencia a nuestra aplicación bank; únicamente abarca los métodos para obtener y establecer la lista de cuentas. listado 11-3 ejemplo de proxy del jdk. // bank.java (eliminando nombres de paquetes…) import java.utils.*; // la abstracción de un banco. public interface bank { collection<account> getaccounts(); void setaccounts(collection<accounts> accounts); } // bankimpl.java import java.utils.*; // “plain old java object” pojo que implementa la abstracción. public class bankimpl implements bank { private list<account> accounts; public collection<account> getaccounts() { return accounts; } public void setaccounts(collections<accounts> accounts) { this.accounts = new arraylist<accounts>(); for (account account: accounts) { this.accounts.add(account); } } } 216// bankproxyhandler.java import java.lang.reflect.*; import java.util.*; // «invocationhandler» necesario para la api de proxy. public class bankproxyhandler implements invocationhandler { private bank bank; public bankhandler (bank bank) { this.bank = bank; } // método definido en invocationhandler public object invoke(object proxy, method method, object[] args) throws throwable { string methodname = method.getname(); if (methodname.equals(“getaccounts”)) { bank.setaccounts(getaccountsfromdatabase()); return bank.getaccounts(); } else if (methodname.equals(“setaccounts”)) { bank.setaccounts((collection<account>) args[0]); setaccountstodatabase(bank.getaccounts()); return null; } else { … } } // muchos detalles: protected collection<account> getaccountsfromdatabase() {…} protected void setaccountstodatabase(collection<account> accounts) {…} } //en otra parte… bank bank = (bank) proxy.newproxyinstance( bank.class.getclassloader(), new class[] { bank.class }, new bankproxyhandler(new bankimpl())); definimos la interfaz bank , que envolvemos en el proxy y un pojo ( plain-old object u objeto sencillo de java), bankimpl , que implementa la lógica empresarial (encontrará más información sobre pojo en un apartado posterior). la api proxy requiere un objeto invocationhandler que invocar para implementar las invocaciones de métodos bank realizadas en el proxy. bankproxyhandler usa la api de reflexión de java para asignar las invocaciones de métodos genéricos a los métodos correspondientes de 217bankimpl , y así sucesivamente. el código es abundante y complejo, incluso para este sencillo caso [59] . el uso de una de las bibliotecas de manipulación de bytes es igualmente complicado. el volumen y la complejidad de este código son dos de los inconvenientes de los proxies . dificultan la creación de código limpio. además, los proxies no ofrecen un mecanismo para especificar puntos de ejecución globales del sistema, imprescindibles para una verdadera solución aop [60] . estructuras aop java puras afortunadamente, gran parte del código predefinido de proxy se puede procesar de forma automática mediante herramientas. los proxies se usan internamente en varias estructuras de java como spring aop y jboss aop, para implementar aspectos en java [61] . en spring, se crea la lógica empresarial en forma de pojo, específicos de su dominio. no dependen de estructuras empresariales (ni de otros dominios). por tanto, son conceptualmente más sencillos y más fáciles de probar. su relativa simplicidad garantiza que se implementen correctamente las correspondientes historias y el mantenimiento y evolución del código en historias futuras. la infraestructura necesaria de la aplicación, incluidos aspectos transversales como persistencia, transacciones, seguridad, almacenamiento en caché y recuperación ante fallos, se incorpora por medio de archivos de configuración declarativos o api. en muchos casos, se especifican aspectos de bibliotecas spring o jboss, en los que la estructura controla el uso de proxies de java o bibliotecas de código de bytes de forma transparente al usuario. estas declaraciones controlan el contenedor de inyección de dependencias, que crea instancias de los principales objetos y las conecta bajo demanda. el listado 11-4 muestra un fragmento tipo de un archivo de configuración de spring v2.5, app.xml [62] . 218listado 11-4 archivo de configuración de spring 2.x <beans> … <bean id=“appdatasource” class=“org.apache.commons.dbcp.basicdatasource” destroy-method=“close” p:driverclassname=“com.mysql.jdbc.driver” p:url=“jdbc:mysql://localhost:3306/mydb” p:username=“me”/> <bean id=“bankdataaccessobject” class=“com.example.banking.persistence.bankdataaccessobject” p:datasource-ref=“appdatasource”/> <bean id=“bank” class=“com.example.banking.model.bank” p:dataaccessobject-ref=“bankdataaccessobject”/> … </beans> cada bean es como una parte de una muñeca rusa anidada, con un objeto de domino de un proxy bank (envuelto) por un objeto de acceso a datos ( data accessor object , dao), que también se procesa a través de un proxy por medio de un origen de datos de controlador jdbc (véase la figura 11.3). figura 11.3. la “muñeca rusa” de elementos de decoración. el cliente cree que invoca getaccounts() en un objeto bank , pero en realidad se comunica con el objeto decorator [63] más externo de un grupo, un objeto que amplía el comportamiento básico del pojo bank . podríamos añadir otros objetos de decoración para transacciones, almacenamiento en caché y demás. en la aplicación, bastan unas líneas para solicitar al contenedor de id los objetos de nivel superior del sistema, como se especifica en el archivo xml. 219xmlbeanfactory bf = new xmlbeanfactory(new classpathresource(“app.xml”, getclass())); bank bank = (bank) bf.getbean(“bank”); como apenas se necesitan líneas de código java específico de spring, la aplicación se desconecta casi por completo de spring y desaparecen los problemas de conexión de sistemas como ejb2. aunque xml puede ser difícil de leer [64] , la directiva especificada en estos archivos de configuración es más sencilla que la complicada lógica de proxy y aspectos oculta a la vista y creada de forma automática. es una arquitectura tan atractiva que sistemas como spring modificaron totalmente el estándar ejb para la versión 3. ejb3 sigue el modelo de spring de aspectos transversales admitidos mediante declaraciones con archivos de configuración xml y/o anotaciones de java 5. el listado 11-5 muestra nuestro objeto bank reescrito en ejb3 [65] . listado 11-5 un ejb bank ejb3. package com.example.banking.model; import javax.persistence; import java.util.arraylist; import java.util.collection; @entity @table(name = “banks”) public class bank implements java.io.serializable { @id @generatedvalue(strategy=generationtype.auto) private int id; @embeddable // un objeto en línea en la fila db de bank public class address { protected string streetaddr1; protected string streetaddr2; protected string city; protected string state; protected string zipcode; } @embedded private address address; @onetomany (cascade = cascadetype.all, fetch = fetchtype.eager, mappedby=“bank”) private collection<account> accounts = new arraylist<account>(); 220public int getid() { return id; } public void setid(int id) { this.id = id; } public void addaccount(account account) { account.setbank(this); accounts.add(account); } public collection<account> getaccounts() { return accounts; } public void setaccounts(collection<account> accounts) { this.accounts = accounts; } } este código es mucho más limpio que el código ejb2 original. se conservan algunos detalles de entidades, en las anotaciones. sin embargo, como no hay información fuera de las anotaciones, el código es limpio y fácil de probar, mantener y demás. parte de la información de persistencia de las anotaciones se puede cambiar a descriptores de implementación xml si es necesario, dejando un pojo puro. si los detalles de asignación de persistencia no cambian con frecuencia, muchos equipos pueden optar por mantener las anotaciones pero con menos obstáculos que si usaran ejb2. aspectos de aspectj por último, la herramienta más completa de separación a través de aspectos es el lenguaje aspectj [66] , una extensión de java que ofrece compatibilidad de primer nivel para aspectos como construcciones de modularidad. los enfoques puros de java proporcionados por spring aop y jboss aop son suficientes en el 80-90 por 100 de los casos en los que los aspectos son útiles. sin embargo, aspectj ofrece un conjunto de herramientas avanzadas y completas para la separación de aspectos. el inconveniente de aspectj es la necesidad de adoptar nuevas herramientas y aprender nuevas construcciones 221del lenguaje. los problemas de adopción se han mitigado parcialmente gracias a la introducción de un formato de anotación de aspectj, en el que se usan anotaciones de java 5 para definir aspectos con código puro de java. además, la estructura spring dispone de funciones que facilitan la incorporación de aspectos basados en anotaciones en un equipo con experiencia limitada con aspectj. el análisis completo de aspectj supera los objetivos de este libro. si necesita más información al respecto, consulte [aspectj], [colyer] y [spring]. pruebas de unidad de la arquitectura del sistema la separación a través de enfoques similares a aspectos no se puede menospreciar. si puede crear la lógica de dominios de su aplicación mediante pojo, sin conexión con los aspectos arquitectónicos a nivel del código, entonces se podrá probar realmente la arquitectura. puede evolucionar de simple a sofisticado, de acuerdo a las necesidades, adoptando nuevas tecnologías bajo demanda. no es necesario realizar un buen diseño por adelantado (big design up front [67] , bduf). de hecho, bduf puede ser negativo ya que impide la adaptación al cambio, debido a la resistencia fisiológica a descartar esfuerzos previos y a la forma en que las decisiones arquitectónicas influyen en la concepción posterior del diseño. los arquitectos deben realizar bduf ya que no resulta factible aplicar cambios arquitectónicos radicales a una estructura física una vez avanzada la construcción [68] . aunque el software se rige por una física propia [69] , es económicamente factible realizar cambios radicales si la estructura del software separa sus aspectos de forma eficaz. esto significa que podemos iniciar un proyecto de software con una arquitectura simple pero bien desconectada, y ofrecer historias funcionales de forma rápida, para después aumentar la infraestructura. algunos de los principales sitios web del mundo han alcanzado una gran disponibilidad y rendimiento por medio de sofisticadas técnicas de almacenamiento en caché, seguridad, virtualización y demás, todo ello de forma eficaz y flexible ya que los diseños mínimamente conectados son adecuadamente simples en cada 222nivel de abstracción y ámbito. evidentemente, no quiere decir que acometamos los proyectos sin timón. debemos tener expectativas del ámbito general, objetivos y un programa, así como la estructura general del sistema resultante. sin embargo, debemos mantener la capacidad de cambiar de rumbo en respuesta a las circunstancias. la arquitectura ejb inicial es una de las api conocidas con un exceso de ingeniería y que compromete la separación de aspectos. incluso las api bien diseñadas pueden ser excesivas cuando no resultan necesarias. una api correcta debe desaparecer de la vista en la mayoría de los casos, para que el equipo dedique sus esfuerzos creativos a las historias implementadas. en caso contrario, las limitaciones arquitectónicas impedirán la entrega eficaz de un valor óptimo para el cliente. para recapitular: una arquitectura de sistema óptima se compone de dominios de aspectos modularizados, cada uno implementado con pojo. los distintos dominios se integran mediante aspectos o herramientas similares mínimamente invasivas. al igual que en el código, en esta arquitectura se pueden realizar pruebas. optimizar la toma de decisiones la modularidad y separación de aspectos permite la descentralización de la administración y la toma de decisiones. en un sistema suficientemente amplio, ya sea una ciudad o un proyecto de software , no debe haber una sola persona que adopte todas las decisiones. sabemos que conviene delegar las responsabilidades en las personas más cualificadas. solemos olvidar que también conviene posponer decisiones hasta el último momento. no es falta de responsabilidad; nos permite tomar decisiones con la mejor información posible. una decisión prematura siempre es subjetiva. si decidimos demasiado pronto, tendremos menos información del cliente, reflexión mental sobre el proyecto y experiencia con las opciones de implementación. 223la agilidad que proporciona un sistema pojo con aspectos modularizados nos permite adoptar decisiones óptimas a tiempo, basadas en los conocimientos más recientes. además, se reduce la complejidad de estas decisiones. usar estándares cuando añadan un valor demostrable la construcción de edificios es una maravilla para la vista debido al ritmo empleado (incluso en invierno) y los extraordinarios diseños posibles gracias a la tecnología actual. la construcción es un sector maduro con elementos, métodos y estándares optimizados que han evolucionado bajo presión durante siglos. muchos equipos usaron la arquitectura ejb2 por ser un estándar, aunque hubiera bastado con diseños más ligeros y sencillos. he visto equipos obsesionados con estándares de moda y que se olvidaron de implementar el valor para sus clientes. los estándares facilitan la reutilización de ideas y componentes, reclutan individuos con experiencia, encapsulan buenas ideas y conectan componentes. sin embargo, el proceso de creación de estándares puede tardar demasiado para el sector, y algunos pierden el contacto con las verdaderas necesidades de aquello para los que están dirigidos. los sistemas necesitan lenguajes específicos del dominio la construcción de edificios, como muchos dominios, ha desarrollado un rico lenguaje con vocabularios, frases y patrones [70] que comunican información esencial de forma clara y concisa. en el mundo del software , ha renacido el interés por crear lenguajes específicos del dominio ( domain-specific languages o dsl) [71] , pequeños lenguajes independientes de creación de secuencias de comandos o api de lenguajes estándar que permiten crear 224código que se lea de una forma estructurada, como lo escribiría un experto del dominio. un buen dsl minimiza el vacío de comunicación entre un concepto de dominio y el código que lo implementa, al igual que las prácticas ágiles optimizan la comunicación entre un equipo y los accionistas del proyecto. si tiene que implementar la lógica de dominios en el mismo lenguaje usado por un experto del dominio, hay menos riesgo de traducir incorrectamente el dominio en la implementación. los dsl, si se usan de forma eficaz, aumentan el nivel de abstracción por encima del código y los patrones de diseño. permiten al desarrollador revelar la intención del código en el nivel de abstracción adecuado. los lenguajes específicos del dominio permiten expresar como pojo todos los niveles de abstracción y todos los dominios de la aplicación, desde directivas de nivel superior a los detalles más mínimos. conclusión los sistemas también deben ser limpios. una arquitectura invasiva afecta a la lógica de dominios y a la agilidad. si la lógica de dominios se ve afectada, la calidad se resiente, ya que los errores se ocultan y las historias son más difíciles de implementar. si la agilidad se ve comprometida, la productividad sufre y las ventajas de tdd se pierden. en todos los niveles de abstracción, los objetivos deben ser claros. esto sólo sucede si crea pojo y usa mecanismos similares a aspectos para incorporar otros aspectos de implementación de forma no invasiva. independientemente de que diseñe sistemas o módulos individuales, no olvide usar los elementos más sencillos que funcionen. bibliografía [alexander] : christopher alexander, a timeless way of building , oxford university press, new york, 1979. 225[aosd] : puerto de desarrollo de software orientado a aspectos, http://aosd.net. [asm] : página de asm, http://asm.objectweb.org/. [aspectj] : http: //eclipse.org/aspectj. [cglib] : biblioteca de generación de código, http://cglib.sourceforge.net/. [colyer] : adrian colyer, andy clement, george hurley, mathew webster, eclipse aspectj , person education, inc., upper saddle river, nj, 2005. [dsl] : lenguaje de programación específico del dominio, http://es.wikipedia.org/wiki/lenguaje_espec%c3%adfico_del_dominio. [fowler] : inversión de contenedores de control y el patrón de inyección de dependencias (http://martinfowler.com/articles/injection.html). [goetz] : brian goetz, java theory and practice: decorating with dynamic proxies , http://www.ibm.com/developerworks/java/library/j- jtp08305.html. [javassist] : página de javassist, http://www.csg.is.titech.ac.jp/chiba/javassist/. [jboss] : página de jboss, http: //jboss.org. [jmock] : jmock: una biblioteca de objetos mock ligeros para java, http://jmock.org. [kolence] : kenneth w. kolence, software physics and computer performance measurements, proceedings of the acm annual conference-volume 2, boston, massachusetts, pp. 1024-1040,1972. [spring] : the spring framework , http://www.springframework.org. [mezzaros07] : xunit patterns , gerard mezzaros, addison-wesley, 2007. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 22612 emergencia con jeff langr limpieza a través de diseños emergentes 227imagine que existieran cuatro sencillas reglas para crear diseños de calidad. imagine que siguiéndolas accediera a la estructura y al diseño de su código y facilitara la aplicación de principios como srp y dip. imagine que estas cuatro reglas facilitaran la emergencia de diseños de calidad. muchos consideramos que las cuatro reglas de kent beck de diseño sencillo [72] son fundamentales para crear un software bien diseñado. según kent, un diseño es sencillo si cumple estas cuatro reglas: ejecuta todas las pruebas. no contiene duplicados. expresa la intención del programador. minimiza el número de clases y métodos. describiremos estas reglas en orden de importancia. primera regla del diseño sencillo: ejecutar todas las pruebas en primer lugar, un diseño debe generar un sistema que actúe de la forma prevista. un sistema puede tener un diseño perfecto sobre el papel pero si no existe una forma sencilla de comprobar que realmente funciona de la forma esperada, el esfuerzo sobre el papel es cuestionable. un sistema minuciosamente probado y que supera todas las pruebas en todo momento se denomina sistema testable. es una afirmación obvia, pero importante. los sistemas que no se pueden probar no se pueden verificar, y un sistema que no se puede verificar no debe implementarse. afortunadamente, crear sistemas testables hace que diseñemos clases de tamaño reducido y un solo cometido. resulta más sencillo probar clases que cumplen el srp. cuantas más pruebas diseñemos, más nos acercaremos a elementos más fáciles de probar. por lo tanto, hacer que nuestro sistema se pueda probar nos ayuda a crear mejores diseños. las conexiones rígidas dificultan la creación de pruebas. del mismo modo, cuantas más pruebas creemos, más usaremos principios como dip y 228herramientas con inyección de dependencias, interfaces y abstracción para minimizar dichas conexiones. nuestros diseños mejorarán todavía más. en especial, seguir una sencilla regla que afirme que debemos realizar pruebas y ejecutarlas continuamente afecta el cumplimiento por parte de nuestro sistema de los principales objetivos de la programación orientada a objetos de baja conexión y elevada cohesión. la creación de pruebas conduce a obtener mejores diseños. reglas 2 a 4 del diseño sencillo: refactorizar una vez creadas las pruebas, debemos mantener limpio el código y las clases. para ello, refactorizamos el código progresivamente. tras añadir unas líneas, nos detenemos y reflejamos el nuevo diseño. ¿ha empeorado? en caso afirmativo, lo limpiamos y ejecutamos las pruebas para comprobar que no hay elementos afectados. la presencia de las pruebas hace que perdamos el miedo a limpiar el código y que resulte dañado . en la fase de refactorización, podemos aplicar todos los aspectos del diseño de software correcto. podemos aumentar la cohesión, reducir las conexiones, separar las preocupaciones, modularizar aspectos del sistema, reducir el tamaño de funciones y clases, elegir nombres más adecuados, etc. aquí también aplicamos las tres últimas reglas del diseño correcto: eliminar duplicados, garantizar la capacidad de expresión y minimizar el número de clases y métodos. eliminar duplicados los duplicados son los mayores enemigos de un sistema bien diseñado. suponen un esfuerzo adicional, riesgos añadidos y una complejidad a mayores innecesaria. los duplicados se manifiestan de diversas formas. las líneas de código similar pueden modificarse para que parezcan refactorizadas, y hay otras formas de duplicación como la de implementación. por ejemplo, podríamos tener dos métodos en una clase de colección: 229int size() {} boolean isempty() {} podríamos tener implementaciones separadas para cada método. el método isempty podría controlar un valor booleano y size un contador, o podemos eliminar la duplicación y vincular isempty a la definición de size : boolean isempty() { return 0 == size(); } la creación de un sistema limpio requiere la eliminación de duplicados, aunque sean unas cuantas líneas de código. fíjese en el siguiente ejemplo: public void scaletoonedimension { float desireddimension, float imagedimension) { if (math.abs(desireddimension - imagedimension) < errorthreshold) return; float scalingfactor = desireddimension / imagedimension; scalingfactor = (float)(math.floor(scalingfactor * 100) * 0.01f); renderedop newimage = imageutilities.getscaledimage( image, scalingfactor, scalingfactor); image.dispose(); system.gc(); image = newimage; } public synchronized void rotate(int degrees) { renderedop newimage = imageutilities.getrotatedimage( image, degrees); image.dispose(); system.gc(); image = newimage; } para mantener limpio este sistema, debemos eliminar la pequeña cantidad de duplicación entre los métodos scaletoonedimension y rotate : public void scaletoonedimension ( float desireddimension, float imagedimension) { if (math.abs(desireddimension - imagedimension) < errorthreshold) return; float scalingfactor = desireddimension / imagedimension; scalingfactor = (float)(math.floor(scalingfactor * 100) * 0.01f); replaceimage(imageutilities.getscaledimage( image, scalingfactor, scalingfactor)); } public synchronized void rotate (int degrees) { replaceimage(imageutilities.getrotatedimage(image, degrees)); } private void replaceimage(renderedop newimage) ( 230image.dispose(); system.gc(); image = newimage; } al extraer a este reducido nivel, comenzamos a detectar incumplimientos de srp. por ello, podríamos cambiar un nuevo método extraído a otra clase. esto aumenta su visibilidad. otro miembro del equipo puede ver la necesidad de volver a extraer el nuevo método y usarlo en otro contexto diferente. esta reutilización mínima puede reducir considerablemente la complejidad del sistema. saber cómo lograrlo es fundamental para alcanzar la reutilización a gran escala. el patrón método de plantilla [73] es una técnica muy utilizada para eliminar duplicados de nivel superior. por ejemplo: public class vacationpolicy { public void accrueusdivisionvacation() { // código para calcular las vacaciones en función de las horas trabajadas //… // código para garantizar que las vacaciones cumplen los mínimos legales //… // código para aplicar vacation al registro payroll //… } public void accrueeudivisionvacation() { // código para calcular las vacaciones en función de las horas trabajadas //… // código para garantizar que las vacaciones cumplen los mínimos legales //… // código para aplicar vacation al registro payroll //… } } el código entre accrueusdivisionvacation y accrueeuropeandivisionvacation es prácticamente idéntico, a excepción del cálculo de mínimos legales. esa parte del algoritmo cambia en función del tipo de empleado. podemos eliminar la duplicación evidente si aplicamos el patrón de método de plantilla : abstract public class vacationpolicy { public void accruevacation() { calculatebasevacationhours(); alterforlegalminimums(); applytopayroll(); } 231private void calculatebasevacationhours() { /* … */ }; abstract protected void alterforlegalminimums(); private void applytopayroll(); { /* … */ }; } public class usvacationpolicy extends vacationpolicy { @override protected void alterforlegalminimums() { // lógica específica de ee.uu. } } public class euvacationpolicy extends vacationpolicy { @override protected void alterforlegalminimums() { // lógica específica de la ue. } } las subclases ocupan el vacío generado en el algoritmo accruevacation y solamente proporcionan los datos que no están duplicados. expresividad muchos tenemos experiencia con código enrevesado. muchos lo hemos creado. es fácil crear código que entendamos, ya que durante su creación nos centramos en comprender el problema que intentamos resolver. los encargados de mantener el código no lo comprenderán de la misma forma. el principal coste de un proyecto de software es su mantenimiento a largo plazo. para minimizar los posibles defectos al realizar cambios, es fundamental que comprendamos el funcionamiento del sistema. al aumentar la complejidad de los sistemas, el programador necesita más tiempo para entenderlo y aumentan las posibilidades de errores. por tanto, el código debe expresar con claridad la intención de su autor. cuando más claro sea el código, menos tiempo perderán otros en intentar comprenderlo. esto reduce los defectos y el coste de mantenimiento. puede expresarse si elige nombres adecuados. el objetivo es ver el nombre de una clase y función, y que sus responsabilidades no nos sorprendan. también puede expresarse si reduce el tamaño de funciones y clases. al hacerlo, resulta más sencillo asignarles nombres, crearlas y comprenderlas. 232otra forma de expresarse es usar una nomenclatura estándar. los patrones de diseño, por ejemplo, se basan en la comunicación y en la capacidad de expresión. al usar los nombres de patrones estándar, como command o visitor , en los nombres de las clases que implementan dichos patrones puede describir sucintamente su diseño a otros programadores. las pruebas de unidad bien escritas también son expresivas. uno de los principales objetivos de una prueba es servir de documentación mediante ejemplos. los que lean las pruebas deben entender con facilidad para qué sirve una clase. pero la forma más importante de ser expresivo es la práctica. a menudo, conseguimos que el código funcione y pasamos al siguiente problema sin detenernos en facilitar la lectura del código para otros. no olvide que seguramente sea el próximo que lea el código. por tanto, afronte su creación con orgullo. dedique tiempo a sus funciones y clases. seleccione nombres mejores, divida las funciones extensas en otras más reducidas y cuide su obra. el cuidado es un recurso precioso. clases y métodos mínimos incluso conceptos tan básicos como la eliminación de código duplicado, la expresividad del código y srp pueden exagerarse. en un esfuerzo por reducir el tamaño de clases y métodos, podemos crear demasiadas clases y métodos reducidos. esta regla también sugiere minimizar la cantidad de funciones y clases. una gran cantidad de clases y métodos suele indicar un dogmatismo sin sentido. imagine un estándar de código que insista en la creación de una interfaz para todas las clases, o a programadores que insisten en qué campos y comportamientos siempre deben separarse en clases de datos y clases de comportamiento. este dogma debe evitarse y cambiarse por un enfoque más pragmático. nuestro objetivo es reducir el tamaño general del sistema además del tamaño de clases y funciones, pero recuerde que esta regla es la de menor 233prioridad de las cuatro. por ello, aunque sea importante reducir la cantidad de clases y funciones, es más importante contar con pruebas, eliminar duplicados y expresarse correctamente. conclusión ¿existen prácticas sencillas que puedan reemplazar a la experiencia? por supuesto que no. sin embargo, las prácticas descritas en este capítulo y en el libro son una forma cristalizada de décadas de experiencia de muchos autores. la práctica del diseño correcto anima y permite a los programadores adoptar principios y patrones que en caso contrario tardarían años en aprender. bibliografía [xpe] : extreme programming explained: embrace change , kent beck, addison wesley, 1999. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 23413 concurrencia por brett l. schuchert 235“los objetos son abstracciones de procesamiento. los subprocesos son abstracciones de programaciones”. —james o. coplien [74] la creación de programas concurrentes limpios es complicada, muy complicada. es mucho más sencillo crear código que se ejecute en un mismo proceso. también es fácil crear código de subprocesamiento múltiple que parezca correcto en la superficie pero que esté dañado a niveles más profundos. este código funciona correctamente hasta que el sistema se somete a determinadas presiones. en este capítulo analizaremos la necesidad de la programación concurrente y sus dificultades. tras ello, presentaremos diversas recomendaciones para superar dichas dificultades y crear código concurrente limpio. por último, finalizaremos con los problemas relacionados con la prueba de código concurrente. la concurrencia limpia es un tema complejo, merecedor de un libro propio. aquí, intentaremos ofrecer una visión general, que después ampliaremos en el apéndice a. si simplemente tiene curiosidad por el tema, le bastará con este capítulo. si necesita entender la concurrencia a un nivel más profundo, consulte también el apéndice. ¿por qué concurrencia? la concurrencia es una estrategia de desvinculación. nos permite desvincular lo que se hace de dónde se hace. en aplicación de un solo proceso, el qué y el cuándo están tan firmemente vinculados que el estado de la aplicación se puede determinar analizando la huella de la pila. un programador que depure este tipo de sistemas puede definir un punto de interrupción (o varios) y saber el estado de la aplicación en función del punto al que se llegue. la desvinculación del qué del dónde puede mejorar considerablemente el rendimiento y la estructura de una aplicación. desde un punto de vista estructural, la aplicación parece una serie de equipos colaboradores y no un gran bucle principal. esto puede hacer que el sistema sea más fácil de 236comprender y ofrece diversas formas de separar las preocupaciones. pongamos por caso el modelo servlet estándar de aplicaciones web. estos sistemas se ejecutan bajo un contenedor web o ejb que gestiona parcialmente la concurrencia. los servlet se ejecutan de forma asíncrona cuando se reciben solicitudes web. el programador de los servlet no tiene que gestionar todas las solicitudes entrantes. en principio, la ejecución de cada servlet vive en un mundo propio y se desvincula del resto. evidentemente, si fuera tan sencillo, no necesitaríamos este capítulo. de hecho, la desvinculación proporcionada por los contenedores web dista mucho de ser perfecta. los programadores de servlet deben asegurarse de que sus programas sean correctos. no obstante, las ventajas estructurales del modelo de servlet son significativas. pero la estructura no es el único motivo para adoptar la concurrencia. algunos sistemas tienen limitaciones de tiempo de respuesta y producción que requieren soluciones concurrentes manuales. imagine un dispositivo para añadir información, con un solo proceso, que obtiene datos de distintos sitios web y los combina en un resumen diario. al tener un solo proceso, accede por turnos a cada sitio web y siempre termina uno antes de comenzar el siguiente. su recorrido diario debe ejecutarse en menos de 24 horas. sin embargo, al añadir nuevos sitios web, el tiempo aumenta hasta necesitarse más de 24 horas para recopilar todos los datos. el único proceso implica una prolongada espera para completar la e/s. podríamos mejorar el rendimiento con ayuda de un algoritmo de subprocesamiento múltiple que visite más de un sitio web por vez. imagine un sistema que procesa un usuario por vez y sólo requiere un segundo por cada uno. su capacidad de respuesta es válida para un número reducido de usuarios pero si aumenta, también lo hace el tiempo de respuesta del sistema. ningún usuario querrá esperar a otros 150. podríamos mejorar el tiempo de respuesta de este sistema procesando varios usuarios a la vez. imagine un sistema que interprete grandes conjuntos de datos pero que sólo ofrezca una solución completa tras procesarlos todos. se podría procesar cada conjunto de datos en un equipo distinto, para poder procesarlos todos en paralelo. 237mitos e imprecisiones también existen motivos evidentes para adoptar la concurrencia aunque, como indicamos antes, sea complicada. si no presta la suficiente atención, pueden darse casos desagradables. veamos los mitos e imprecisiones más habituales: la concurrencia siempre mejora el rendimiento : en ocasiones lo hace pero sólo cuando se puede compartir tiempo entre varios procesos o procesadores. ninguna situación es trivial. el diseño no cambia al crear programas concurrentes : de hecho, el diseño de un algoritmo concurrente puede ser muy distinto al de un sistema de un solo proceso. la desvinculación entre el qué y el cuándo suele tener un efecto importante en la estructura del sistema. no es importante entender los problemas de concurrencia al trabajar con un contenedor web o ejb : en realidad, debe saber lo que hace su contenedor y protegerlo de problemas de actualizaciones concurrentes y bloqueo, como veremos después. veamos otros aspectos relacionados con la creación de software concurrente: la concurrencia genera cierta sobrecarga , tanto en rendimiento como en la creación de código adicional. la concurrencia correcta es compleja , incluso para problemas sencillos. los errores de concurrencia no se suelen repetir , de modo que se ignoran [75] en lugar de considerarse verdaderos problemas. la concurrencia suele acarrear un cambio fundamental de la estrategia de diseño . desafíos ¿qué hace que la programación concurrente sea tan complicada? fíjese en la 238siguiente clase: public class x { private int lastidused; public int getnextid() { return ++lastidused; } } imagine que creamos una instancia x , establecemos el campo lastidused en 42 y después compartimos la instancia entre dos procesos. imagine ahora que esos dos procesos invocan el método getnextid() ; hay tres resultados posibles: el primer proceso obtiene el valor 43, el segundo el valor 44 y lastidused es 44. el primer proceso obtiene el valor 44, el segundo el valor 43 y lastidused es 44. el primer proceso obtiene el valor 43, el segundo el valor 43 y lastidused es 43. el sorprendente tercer resultado [76] se produce cuando los dos procesos coinciden. se debe a que pueden adoptar varias rutas posibles en una línea de código de java y algunas generan resultados incorrectos. ¿cuántas rutas distintas existen? para responder, debemos entender lo que hace el compilador justo a tiempo con el código de bytes generado, y lo que el modelo de memoria de java considera atómico. una rápida respuesta, con el código de bytes generado, es que existen 12 870 rutas de ejecución diferentes [77] para los dos procesos ejecutados en el método getnextid . si el tipo de lastidused cambia de int a long , el número de rutas asciende a 2 704 156. evidentemente, muchas generan resultados válidos. el problema es que algunas no lo hacen . principios de defensa de la concurrencia a continuación le mostramos una serie de principios y técnicas para proteger 239a sus sistemas de los problemas del código concurrente. principio de responsabilidad única (srp) srp [78] establece que un método, clase o componente sólo debe tener un motivo para cambiar. el diseño de concurrencia es lo bastante complejo como para ser un motivo de cambio con derecho propio y, por tanto, debe separarse del resto del código. desafortunadamente, es habitual incrustar los detalles de la implementación de concurrencia directamente en otro código de producción. tenga en cuenta los siguientes aspectos: el código relacionado con la concurrencia tiene su propio ciclo de desarrollo , cambios y ajustes. el código relacionado con la concurrencia tiene sus propios desafíos , diferentes y más complicados, que los del código no relacionado con la concurrencia. el número de formas en las que el código incorrecto basado en la concurrencia puede fallar lo complica ya de por sí, sin la carga añadida del código de aplicación circundante. recomendación : separe el código de concurrencia del resto del código [79] . corolario: limitar el ámbito de los datos como hemos visto, dos procesos que modifican el mismo campo u objeto compartido pueden interferir entre ellos y provocar un comportamiento inesperado. una solución consiste en usar la palabra clave synchronized para proteger una sección importante del código que use el objeto compartido, aunque conviene limitar la cantidad de estas secciones. cuantos más puntos actualicen datos compartidos, es más probable que: 240se olvide de proteger uno o varios de esos puntos, y se dañe el código que modifica los datos compartidos. se duplique el esfuerzo necesario para garantizar la protección de todos los elementos (incumplimiento de dry [80] ). resulta complicado determinar el origen de los fallos, que por naturaleza son difíciles de detectar. recomendación : encapsule los datos y limite el acceso a los datos compartidos . corolario: usar copias de datos una forma de evitar datos compartidos es no compartirlos. en algunos casos se pueden copiar objetos y procesarlos como si fueran de sólo lectura. en otros, se pueden copiar objetos, recopilar los resultados de varios procesos en las copias y después combinar los resultados en un mismo proceso. si existe una forma sencilla de evitar los objetos compartidos, el código resultante tendrá menos problemas. puede que le preocupe el coste de la creación de objetos adicionales. merece la pena experimentar y comprobar si es un problema real. no obstante, si el uso de copias de objetos permite al código evitar la sincronización, las ventajas de evitar el bloque compensan la creación adicional y la sobrecarga de la recolección de elementos sin usar. corolario: los procesos deben ser independientes pruebe a crear el código de sus procesos de forma que cada uno sea independiente y no comparta datos con otros. cada uno procesa una solicitud cliente y todos los datos necesarios provienen de un origen sin compartir y se almacenan como variables locales. de este modo, los procesos se comportan como si fueran los únicos del mundo y no existieran requisitos de sincronización. por ejemplo, las subclases de httpservlet reciben toda su información como parámetros pasados en los métodos doget y dopost . esto hace que cada servlet actúe como si dispusiera de su propio equipo. mientras 241el código del servlet sólo use variables locales, es imposible que cause problemas de sincronización. evidentemente, muchas aplicaciones que usan servlet se topan con recursos compartidos como conexiones de base de datos. recomendación : intente dividir los datos en subconjuntos independientes que se puedan procesar en procesos independientes, posiblemente en distintos procesadores . conocer las bibliotecas java 5 ofrece muchas mejoras para el desarrollo concurrente con respecto a versiones anteriores. existen diversos aspectos que tener en cuenta a la hora de crear código de procesos en java 5: usar las colecciones compatibles con procesos proporcionadas. usar la estructura de ejecución de tareas no relacionadas. usar soluciones antibloqueo siempre que sea posible. varias clases de bibliotecas no son compatibles con procesos. colecciones compatibles con procesos en los albores de java, doug lea escribió el conocido libro [81]  concurrent programming in java . al mismo tiempo, desarrolló varias colecciones compatibles con procesos, que posteriormente pasaron a formar parte del jdk en el paquete java.util.concurrent . las colecciones de dicho paquete son compatibles con casos de procesos múltiples y tienen un rendimiento adecuado. de hecho, la implementación concurrenthashmap tiene mejor rendimiento que hashmap en la mayoría de los casos. también permite lecturas y escrituras simultáneas, y dispone de métodos que admiten operaciones de composición habituales que en caso contrario serian incompatibles con subprocesos. si java 5 es su entorno de desarrollo, comience con concurrenthashmap . 242existen otras clases añadidas para admitir diseño avanzado de concurrencia. veamos algunos ejemplos: reentrantlock bloqueo que se puede adquirir en un método y liberar en otro. semaphore una implementación del clásico semáforo, un bloqueo con un contador. countdownlatch bloqueo que espera un número de eventos antes de liberar todos los subprocesos retenidos. de este modo todos tienen la misma oportunidad de iniciarse al mismo tiempo. recomendación : revise las clases de las que disponga. en el caso de java, debe familiarizarse con java.util.concurrent, java.util.concurrent.atomic y java.util.concurrent.locks . conocer los modelos de ejecución existen diversas formas de dividir el comportamiento de una aplicación concurrente. para describirlos debe conocer ciertas definiciones básicas. recursos vinculados recursos de tamaño o número fijo usados en un entorno concurrente, como por ejemplo conexiones de base de datos y búfer de lectura/escritura de tamaño fijo. exclusión mutua sólo un proceso puede acceder a datos o a un recurso compartido por vez. inanición se impide que un proceso o grupo de procesos continúen demasiado tiempo o indefinidamente. por ejemplo, si permite primero la ejecución de los procesos más rápidos, los que se ejecutan durante más tiempo pueden perecer de inanición si los primeros no terminan nunca. bloqueo dos o más procesos esperan a que ambos terminen. cada proceso tiene un recurso y ninguno puede terminar hasta que obtenga el otro recurso. bloqueo procesos bloqueados, intentando realizar su labor pero 243activo estorbándose unos a otros. por motivos de resonancia, los procesos siguen intentando avanzar pero no pueden durante demasiado tiempo, o de forma indefinida. tras mostrar estas definiciones, ya podemos describir los distintos modelos de ejecución empleados en la programación concurrente. productor-consumidor [82] uno o varios procesos productores crean trabajo y lo añaden a un búfer o a una cola. uno o varios procesos consumidores adquieren dicho trabajo de la cola y lo completan. la cola entre productores y consumidores es un recurso vinculado, lo que significa que los productores deben esperar a que se libere espacio en la cola antes de escribir y los consumidores deben esperar hasta que haya algo que consumir en la cola. la coordinación entre productores y consumidores a través de la cola hace que unos emitan señales a otros. los productores escriben en la cola e indican que ya no está vacía. los consumidores leen de la cola e indican que ya no está llena. ambos esperan la notificación para poder continuar. lectores-escritores [83] cuando un recurso compartido actúa básicamente como fuente de información para lectores pero ocasionalmente se actualiza por parte de escritores, la producción es un problema. el énfasis de la producción puede provocar la inanición y la acumulación de información caducada. las actualizaciones pueden afectar a la producción. la coordinación de lectores para que no lean algo que un escritor está actualizando y viceversa es complicada. los escritores tienden a bloquear a los lectores durante periodos prolongados, lo que genera problemas de producción. el desafío consiste en equilibrar las necesidades de ambos para satisfacer un funcionamiento correcto, proporcionar una producción razonable y evitar la inanición. una sencilla estrategia hace que los escritores esperen hasta que deje de haber lectores antes de realizar una actualización. si hay lectores 244continuos, los escritores perecen de inanición. por otra parte, si hay escritores frecuentes y se les asigna prioridad, la producción se ve afectada. determinar el equilibrio y evitar problemas de actualización concurrente es el objetivo de este modelo. la cena de los filósofos [84] imagine varios filósofos sentados alrededor de una mesa redonda. a la izquierda de cada uno hay un tenedor. en el centro de la mesa, una gran fuente de espaguetis. los filósofos pasan el tiempo pensando a menos que tengan hambre. cuando tienen hambre, utilizan los tenedores situados a ambos lados para comer. no pueden comer a menos que tengan dos tenedores. si el filósofo situado a la derecha o izquierda de otros ya tiene uno de los tenedores que necesita, tendrá que esperar a que termine de comer y deje los tenedores. cuando un filósofo termina de comer, vuelve a colocar los tenedores en la mesa hasta que vuelve a tener hambre. cambie los filósofos por procesos y los tenedores por recursos y tendrá un problema habitual en muchas aplicaciones en las que los procesos compiten por recursos. a menos que se diseñen correctamente, los sistemas que compiten de esta forma experimentan problemas de bloqueo, bloqueo mutuo, producción y degradación de la eficacia. la mayoría de problemas de concurrencia que encontrará serán alguna variante de éstos. analice los algoritmos y cree soluciones propias para estar preparado cuando surjan problemas de concurrencia. recomendación : aprenda estos algoritmos básicos y comprenda sus soluciones . dependencias entre métodos sincronizados las dependencias entre métodos sincronizados generan sutiles errores en el código concurrente. java cuenta con synchronized , que protege métodos individuales. no obstante, si hay más de un método sincronizado en la misma clase compartida, puede que su sistema sea incorrecto [85] . 245recomendación : evite usar más de un método en un objeto compartido . en ocasiones tendrá que usar más de un método en un objeto compartido. en ese caso, hay tres formas de crear código correcto: bloqueo basado en clientes : el cliente debe bloquear al servidor antes de invocar el primer método y asegurarse de que el alcance del bloque incluye el código que invoque el último método. bloqueo basado en servidores : debe crear un método en el servidor que bloquee el servidor, invoque todos los métodos y después anule el bloqueo. el cliente debe invocar el nuevo método. servidor adaptado : cree un intermediario que realice el bloque. es un ejemplo de bloqueo basado en servidores en el que el servidor original no se puede modificar. reducir el tamaño de las secciones sincronizadas la palabra clave synchronized presenta un bloqueo. todas las secciones de código protegidas por el mismo bloque sólo tendrán un proceso que las ejecute en un momento dado. los bloqueos son costosos ya que generan retrasos y añaden sobrecarga. por ello, no conviene colapsar el código con instrucciones synchronized . por otra parte, las secciones críticas [86] deben protegerse, de modo que debemos diseñar nuestro código con el menor número posible de secciones críticas. algunos programadores intentan lograrlo ampliando el tamaño de sus secciones críticas. sin embargo, al ampliar la sincronización más allá de la sección crítica mínima aumentan los problemas y afecta negativamente al rendimiento [87] . recomendación : reduzca al máximo el tamaño de las secciones synchronized . crear código de cierre correcto es complicado 246crear un sistema activo y que se ejecute indefinidamente es distinto a crear algo que funcione de forma temporal y después se cierre correctamente. entre los problemas más habituales destacan los bloqueos [88] , con procesos que esperan una señal para continuar que nunca se produce. imagine, por ejemplo, un sistema con un proceso principal que genera varios procesos secundarios y que espera a que todos terminen antes de liberar sus recursos y cerrarse. ¿qué sucede si uno de los procesos secundarios está bloqueado? el principal esperará indefinidamente y el sistema nunca se cerrará. imagine ahora un sistema similar al que se le indica que se cierre. el proceso principal indica a todos los secundarios que abandonen sus tareas y terminen. pero imagine que dos procesos secundarios funcionan como par productor/consumidor y que el productor recibe una señal del principal y se cierra rápidamente. el consumidor espera un mensaje del productor y puede quedar bloqueado en un estado en el que no recibe la señal del principal, lo que también impide que éste finalice. son situaciones habituales. por tanto, si tiene que crear código concurrente con cierres correctos, tendrá que dedicar tiempo a que el cierre se produzca de forma correcta. recomendación : planifique con antelación el proceso de cierre y pruébelo hasta que funcione. le llevará más tiempo del que espera. repase los algoritmos existentes porque será complicado . probar código con procesos demostrar que el código es correcto no resulta práctico. las pruebas no garantizan su corrección. sin embargo, las pruebas adecuadas pueden minimizar los riesgos, en especial en aplicaciones de un solo proceso. cuando hay dos o más procesos que usan el mismo código y trabajan con datos compartidos, la situación se vuelve más compleja. recomendación : cree pruebas que puedan detectar problemas y ejecútelas periódicamente, con distintas configuraciones de programación y del sistema, y cargas. si las pruebas fallan, identifique el fallo. no lo ignore 247porque las pruebas superen una ejecución posterior . hay muchos factores que tener en cuenta. veamos algunas recomendaciones concretas: considere los fallos como posibles problemas de los procesos. consiga que primero funcione el código sin procesos. el código con procesos se debe poder conectar a otros elementos. el código con procesos debe ser modificable. ejecute con más procesos que procesadores. ejecute en diferentes plataformas. diseñe el código para probar y forzar fallos. considerar los fallos como posibles problemas de los procesos el código con procesos hace que fallen elementos que no deberían fallar. muchos desarrolladores desconocen cómo interactúan los procesos con otro tipo de código. los problemas del código con procesos pueden mostrar sus síntomas una vez cada mil o un millón de ejecuciones. los intentos por repetir los sistemas pueden resultar frustrantes, lo que suele provocar que los programadores consideren el fallo como algo aislado. es recomendable asumir que los fallos aislados no existen. cuanto más los ignore, mayor será la cantidad de código que se acumule sobre un enfoque defectuoso. recomendación : no ignore los fallos del sistema como algo aislado . conseguir que primero funcione el código sin procesos puede parecer evidente pero no está de más recordarlo. asegúrese de que el código funciona fuera de sus procesos. por lo general, esto significa crear algunos pojo que los procesos deban invocar. los pojo no son compatibles con los procesos y por tanto se pueden probar fuera de su entorno. conviene 248incluir en los pojo la mayor cantidad posible del sistema. recomendación : no intente identificar fallos de procesos y que no sean de procesos al mismo tiempo. asegúrese de que su código funciona fuera de los procesos . el código con procesos se debe poder conectar a otros elementos cree el código compatible con la concurrencia de forma que se pueda ejecutar en distintas configuraciones: un proceso, varios procesos y variarlo durante la ejecución. el código con procesos interactúa con algo que puede ser real o probado. ejecutar con pruebas dobles ejecutadas de forma rápida, lenta y variable. configurar pruebas que ejecutar en diferentes iteraciones. recomendación : el código con procesos debe poder conectar a otros elementos y ejecutar en distintas configuraciones . el código con procesos debe ser modificable la obtención del equilibrio adecuado de procesos suele requerir operaciones de ensayo y error. en las fases iniciales, compruebe el rendimiento del sistema bajo diferentes configuraciones. permita que se puedan modificar los distintos procesos y también durante la ejecución del sistema. también puede permitir la modificación automática en función de la producción y la utilización del sistema. ejecutar con más procesos que procesadores cuando el sistema cambia de tarea, se producen reacciones. para promover el intercambio de tareas, realice la ejecución con más procesos que procesadores o núcleos. cuanto mayor sea la frecuencia de intercambio de las 249tareas, más probabilidades existen de que el código carezca de una sección crítica o se produzcan bloqueos. ejecutar en diferentes plataformas en 2007 diseñamos un curso sobre programación concurrente, principalmente en os x. la clase se presentó con windows xp ejecutado en una mv. se crearon pruebas para ilustrar condiciones de fallo que fallaban con más frecuencia en os x que en xp. en todos los casos, el código probado era incorrecto. esto refuerza el hecho de que cada sistema operativo tiene una política de procesos diferente que afecta a la ejecución del código. el código con procesos múltiples se comporta de forma distinta en cada entorno [89] . debe ejecutar sus pruebas en todos los entornos de implementación posibles. recomendación : ejecute el código con procesos en todas las plataformas de destino con frecuencia y en las fases iniciales . diseñar el código para probar y forzar fallos es habitual que los fallos del código concurrente se oculten. las pruebas sencillas no suelen mostrarlos. en realidad, suelen ocultarse durante el procesamiento normal. pueden aparecer horas, días o semanas después. la razón de que los problemas de procesos sean infrecuentes, esporádicos y apenas se repitan es que sólo fallan algunas de las miles de rutas posibles que recorren una sección vulnerable. por tanto, la probabilidad de adoptar una ruta fallida es realmente baja, lo que dificulta la detección y la depuración. se preguntará cómo aumentar las posibilidades de capturar estos casos. puede diseñar el código y forzarle a que se ejecute en diferentes órdenes añadiendo métodos como object.wait() , object.sleep() , object.yield() y object.priority() . estos métodos afectan al orden de ejecución y, por tanto, aumentan las posibilidades de detectar un error. resulta más adecuado que el código 250incorrecto falle lo antes posible y con frecuencia. hay dos opciones de instrumentación de código: manual. automática. manual puede añadir invocaciones de wait() , sleep() , yield() y priority() manualmente a su código, en especial si tiene que probar un fragmento especialmente escabroso. veamos un ejemplo: public synchronized string nexturlornull() { if (hasnext()) { string url = urlgenerator.next(); thread.yield(); // se añade para pruebas. updatehasnext(); return url; } return null; } la invocación de yield() cambia la ruta de ejecución adoptada por el código y posiblemente hace que el código falla donde no lo hacía antes. si el código falla, no se debe a la invocación de yield() añadida [90] . se debe a que el código es incorrecto y hemos hecho que el fallo sea más evidente. este enfoque presenta varios problemas: tendrá que buscar manualmente los puntos adecuados donde hacerlo. ¿cómo sabe dónde incluir la invocación y qué tipo de invocación usar? la presencia de este código en un entorno de producción ralentiza innecesariamente el código. es un enfoque que puede o no detectar los fallos; de hecho, no las tiene todas consigo. lo que necesitamos es una forma de hacerlo durante la fase de pruebas, no de producción. también debemos poder mezclar configuraciones entre ejecuciones, lo que aumenta las probabilidades de detectar los errores. 251evidentemente, si dividimos el sistema pojo que no sepa nada los procesos en clases que controlen los procesos, resultará más sencillo ubicar los puntos en los que instrumentar el código. es más, podríamos crear diferentes pruebas que invoquen los pojo bajo distintos regímenes de invocaciones a sleep , yield y demás. automática puede usar herramientas como la estructura orientada a aspectos, cglib o asm para instrumentar su código mediante programación. por ejemplo, podría usar una clase con un único método: public class threadjigglepoint { public static void jiggle() { } } puede añadir invocaciones en distintos puntos del código: public synchronized string nexturlornull() { if(hasnext()) { threadjigglepoint.jiggle(); string url = urlgenerator.next(); threadjigglepoint.jiggle(); updatehasnext(); threadjigglepoint.jiggle(); return url; } return null; } tras ello, use un sencillo aspecto que seleccione aleatoriamente entre no hacer nada, pausar o generar un resultado. imagine que la clase threadjigglepoint tiene dos implementaciones. la primera implementa jiggle para no hacer nada y se usa en producción. la segunda genera un número aleatorio para elegir entre sleep , yield o nada. si ejecuta sus pruebas mil veces con jiggle de forma aleatoria, puede descubrir algunos fallos. si la prueba es satisfactoria, al menos puede felicitarse por haber actuado correctamente. aunque sea un tanto simple, puede resultar una opción razonable en lugar de recurrir a una herramienta más sofisticada. la herramienta contest [91] , desarrollada por ibm, tiene un funcionamiento 252similar pero es más sofisticada. el objetivo es que los procesos del código se ejecuten en distinto orden en momentos diferentes. la combinación de pruebas bien escritas y ejecuciones aleatorias puede aumentar considerablemente la capacidad de detectar errores. recomendación : use estas estrategias para detectar errores . conclusión es complicado conseguir código concurrente correcto. el código sencillo se puede complicar al añadir varios procesos y datos compartidos. si tiene que crear código concurrente, tendrá que hacerlo con rigor o se enfrentará a sutiles y esporádicos fallos. en primer lugar, siga el principio de responsabilidad única. divida su sistema en varios pojo que separen el código compatible con procesos del resto. asegúrese de probar únicamente el código compatible con procesos y nada más, por lo que este código debe ser de tamaño reducido y específico. conozca los orígenes de los problemas de concurrencia: varios procesos que operen en datos compartidos o usen una agrupación de recursos común. los casos de límites, como el cierre correcto o la conclusión de la iteración de un bucle, pueden ser especialmente espinosos. conozca su biblioteca y los algoritmos fundamentales. debe comprender cómo las funciones de la biblioteca permiten resolver problemas similares a los de los algoritmos fundamentales. aprenda a localizar regiones del código que se puedan bloquear y bloquéelas. no bloquee otras regiones que no lo necesiten. evite invocar una sección bloqueada desde otra. para ello debe saber si un elemento está compartido o no. reduzca la cantidad de objetos compartidos y su ámbito. cambie los diseños de los objetos con datos compartidos para acomodar clientes en lugar de obligar a los clientes a gestionar el estado compartido. los problemas se acumularán. los que no aparezcan inicialmente suelen considerarse esporádicos y suelen producirse en la fase de carga o de modo aparentemente aleatorio. por tanto, debe poder ejecutar su código con 253procesos en diferentes configuraciones y plataformas de forma repetida y continua. la capacidad de prueba, algo natural si aplica las tres leyes de tdd, implica cierto nivel de conectividad, lo que ofrece la compatibilidad necesaria para ejecutar código en distintas configuraciones. la probabilidad de detectar errores mejora si se toma el tiempo necesario para instrumentar su código. puede hacerlo manualmente o mediante tecnologías automatizadas. hágalo en las fases iniciales. es aconsejable ejecutar el código basado en procesos durante el mayor tiempo posible antes de pasarlo a producción. si adopta un enfoque limpio, aumentarán las probabilidades de hacerlo de forma correcta. bibliografía [lea99] : concurrent programming in java: design principles and patterns , 2d. ed., doug lea, prentice hall, 1999. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. 25414 refinamiento sucesivo caso práctico de un analizador de argumentos de línea de comandos este capítulo es un caso práctico de refinamiento sucesivo. veremos un 255módulo que comienza correctamente pero no mantiene dicha corrección. tras ello, veremos cómo se refactoriza y se limpia. muchos hemos tenido que analizar argumentos de línea de comando. si no disponemos de una utilidad para ello, recorremos la matriz de cadenas pasadas a la función principal. puede encontrar utilidades de calidad pero ninguna hace exactamente lo que necesitamos. por ello, decidí crear una propia, a la que he denominado args . args es muy fácil de usar. basta crearla con los argumentos de entrada y una cadena de formato, y después consultar a la instancia de args los valores de los argumentos. fíjese en el siguiente ejemplo: listado 14-1 uso de args public static void main(string[] args) { try { args arg = new args(“l,p#,d*”, args); boolean logging = arg.getboolean(‘l’); int port = arg.getint(‘p’); string directory = arg.getstring(‘d’); executeapplication(logging, port, directory); } catch (argsexception e) { system.out.printf(“argument error: %s\n”, e.errormessage()); } } comprobará lo sencillo que es. creamos una instancia de la clase args con dos parámetros. el primero es la cadena de formato o esquema: “l,p#,d*” . define tres argumentos de línea de comandos. el primero, -l , es un argumento booleano. el segundo, -p , es un argumento entero. el tercero, - d , es un argumento de cadena. el segundo parámetro del constructor args es la matriz de argumentos de línea de comandos pasada a main . si el constructor no genera argsexception , la línea de comandos entrante se ha analizado y se puede consultar la instancia args . se usan métodos como getboolean , getinteger y getstring para acceder a los valores de los argumentos por sus nombres. si hay un problema, ya sea en la cadena de formato o en los argumentos de línea de comandos, se genera argsexception . la descripción del error se 256puede recuperar del método errormessage de la excepción. implementación de args el listado 14-2 es la implementación de la clase args . examínela con atención. el estilo y la estructura se han trabajado concienzudamente y espero que los imite. listado 14-2 args.java package com.objectmentor.utilities.args; import static com.objectmentor.utilities.args.argsexception.errorcode.*; import java.util.*; public class args { private map<character, argumentmarshaler> marshalers; private set<character> argsfound; private listiterator<string> currentargument; public args(string schema, string[] args) throws argsexception { marshalers = new hashmap<character, argumentmarshaler>(); argsfound = new hashset<character>(); parseschema(schema); parseargumentstrings(arrays.aslist(args)); } private void parseschema(string schema) throws argsexception { for (string element : schema.split(“,”)) if (element.length() > 0) parseschemaelement(element.trim()); } private void parseschemaelement(string element) throws argsexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(element id); if (elementtail.length() == 0) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail.equals(“*”)) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail.equals(“#”)) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); 257else if (elementtail.equals(“[*]”)) marshalers.put(elementid, new stringarrayargumentmarshaler()); else throw new argsexception(invalid_argument_format, elementid, elementtail); } private void validateschemaelementid(char elementid) throws argsexception { if {!character.isletter(elementid)) throw new argsexception(invalid_argument_name, elementid, null); } private void parseargumentstrings(list<string> argslist) throws argsexception { for (currentargument = argslist.listiterator(); currentargument.hasnext();) { string argstring = currentargument.next(); if (argstring.startswith(“-”)) { parseargumentcharacters(argstring.substring(1)); } else { currentargument.previous(); break; } } } private void parseargumentcharacters(string argchars) throws argsexception { for (int i = 0; i < argchars.length(); i++) parseargumentcharacter(argchars.charat(i)); } private void parseargumentcharacter(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) { throw new argsexception (unexpected_argument, argchar, null); } else { argsfound.add(argchar); try { m.set(currentargument); } catch (argsexception e) { e.seterrorargumentid(argchar); throw e; } } } public boolean has(char arg) { return argsfound.contains(arg); } public int nextargument() { 258return currentargument.nextindex(); } public boolean getboolean(char arg) { return booleanargumentmarshaler.getvalue(marshalers.get(arg)); } public string getstring(char arg) { return stringargumentmarshaler.getvalue(marshalers.get(arg)); } public int getint(char arg) { return integerargumentmarshaler.getvalue (marshalers.get(arg)); } public double getdouble(char arg) { return doubleargumentmarshaler.getvalue(marshalers.get(arg)); } public string[] getstringarray(char arg) { return stringarrayargumentmarshaler.getvalue(marshalers.get(arg)); } } puede leer el código de arriba a abajo sin necesidad de saltar de un punto a otro ni buscar hacia adelante. lo que seguramente busque es la definición de argumentmarshaler , que hemos omitido intencionadamente. tras leer el código, comprenderá la interfaz argumentmarshaler y la función de sus variantes. veamos algunas de ellas (entre los listados 14-3 y 14-6). listado 14-3 argumentmarshaler.java public interface argumentmarshaler { void set(iterator<string> currentargument) throws argsexception; } listado 14-4 booleanargumentmarshaler.java public class booleanargumentmarshaler implements argumentmarshaler { private boolean booleanvalue = false; public void set (iterator<string> currentargument) throws argsexception { booleanvalue = true; } public static boolean getvalue(argumentmarshaler am) { 259if (am != null && am instanceof booleanargumentmarshaler) return ((booleanargumentmarshaler) am).booleanvalue; else return false; } } listado 14-5 stringargumentmarshaler.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class stringargumentmarshaler implements argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { throw new argsexception(missing_string); } } public static string getvalue(argumentmarshaler am) { if (am != null && am instanceof stringargumentmarshaler) return ((stringargumentmarshaler) am).stringvalue; else return “”; } } listado 14-6 integerargumentmarshaler.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class integerargumentmarshaler implements argumentmarshaler { private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); intvalue = integer.parseint(parameter); } catch (nosuchelementexception e) { throw new argsexception(missing_integer); } catch (numberformatexception e) { throw new argsexception(invalid_integer, parameter); } } 260public static int getvalue (argumentmarshaler am) { if (am != null && am instanceof integerargumentmarshaler) return ((integerargumentmarshaler) am).intvalue; else return 0; } } las otras variantes de argumentmarshaler simplemente repiten este patrón en matrices double y string y sólo complicarían el capítulo. puede consultarlas como ejercicio. otro fragmento que puede resultar complicado es la definición de las constantes de código de error, incluidas en la clase argsexception (véase el listado 14-7). listado 14-7 argsexception.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = null; private errorcode errorcode = ok; public argsexception() {} public argsexception(string message) { super(message); } public argsexception(errorcode errorcode) { this.errorcode = errorcode; } public argsexception(errorcode errorcode, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; } public argsexception(errorcode errorcode, char errorargumentid, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; this.errorargumentid = errorargumentid; } public char geterrorargumentid() { return errorargumentid; } public void seterrorargumentid(char errorargumentid) { this.errorargumentid = errorargumentid; 261} public string geterrorparameter() { return errorparameter; } public void seterrorparameter(string errorparameter) { this.errorparameter = errorparameter; } public errorcode geterrorcode() { return errorcode; } public void seterrorcode(errorcode errorcode) { this.errorcode = errorcode; } public string errormessage() { switch (errorcode) { case ok: return “tilt: should not get here.”; case unexpected_argument: return string.format(“argument -%c unexpected.”, errorargumentid); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c.”, errorargumentid); case invalid_argument_name: return string.format(“‘%c’ is not a valid argument name.”, errorargumentid); case invalid_argument_format: return string.format(“‘%s’ is not a valid argument format.”, errorparameter); } return “”; } public enum errorcode { ok, invalid_argument_format, unexpected_argument, invalid_argument_name, missing_string, missing_integer, invalid_integer, missing_double, invalid_double } } 262es sorprendente la cantidad de código necesario para detallar este sencillo concepto. uno de los motivos es el uso de un lenguaje especialmente profuso. java, al ser un lenguaje de tipos estáticos, requiere muchas palabras para satisfacer el sistema de tipos. en lenguajes como ruby, python o smalltalk, este programa es mucho más reducido [92] . vuelva a leer el código. fíjese especialmente en los nombres de los elementos, el tamaño de las funciones y el formato. si tiene experiencia como programador, partes del estilo o la estructura no le convencerán, pero espero que, desde un punto de vista global, considere que el programa está bien escrito y tiene una estructura limpia. por ejemplo, debería ser evidente cómo añadir un nuevo tipo de argumento, como una fecha o un número complejo, y que dicha inclusión apenas requeriría código. en definitiva, bastaría con una nueva variante de argumentmarshaler , una nueva función getxxx y una nueva instrucción case en la función parseschemaelement . también habría un nuevo código argsexception.errorcode y un nuevo mensaje de error. cómo se ha realizado no diseñé este programa de principio a fin en su forma actual y, sobre todo, no espero que pueda crear programas limpios y elegantes a la primera. si algo hemos aprendido en las dos últimas décadas es que la programación es un arte más que una ciencia. para escribir código limpio, primero debe crear código imperfecto y después limpiarlo. no debería sorprenderle. ya lo aprendimos en el colegio cuando los profesores (normalmente en vano) nos obligaban a crear borradores de nuestras redacciones. el proceso, nos decían, era escribir un primer borrador, después otro, y después otros muchos hasta lograr una versión definitiva. para escribir redacciones limpias, el refinamiento debía ser continuado. muchos programadores noveles (como sucede con los alumnos) no siguen este consejo. creen que el objetivo principal es que el programa funcione. una vez que lo consiguen, pasan a la siguiente tarea, y conservan el estado funcional del programa, sea cual sea. los programadores 263experimentados saben que esto es un suicidio profesional. args: el primer borrador el listado 14-8 muestra una versión inicial de la clase args . funciona, pero es un desastre. listado 14-8 args.java (primer borrador) import java.text.parseexception; import java.util.*; public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private map<character, string> stringargs = new hashmap<character, string>(); private map<character, integer> intargs = new hashmap<character, integer>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema. string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { 264} return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)); parsebooleanschemaelement(elementid); else if (isstringschemaelement(elementtail)) parsestringschemaelement(elementid); else if (isintegerschemaelement(elementtail)) { parseintegerschemaelement(elementid); } else { throw new parseexception( string.format(“argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, false); } private void parseintegerschemaelement(char elementid) { intargs.put(elementid, 0); } private void parsestringschemaelement(char elementid) { stringargs.put(elementid, “”); } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } 265private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private boolean isintegerschemaelement(string elementtail) { return elementtail.equals(“#”); } private boolean parsearguments() throws argsexception { for (currentargument = 0; currentargument < args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = errorcode.unexpected_argument; valid = false; } } private boolean setargument(char argchar) throws argsexception { if (isbooleanarg(argchar)) setbooleanarg(argchar, true); else if (isstringarg(argchar)) setstringarg(argchar); else if (isintarg(argchar)) setintarg(argchar); else return false; return true; } private boolean isintarg(char argchar) { return intargs.containskey(argchar); } 266private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.put(argchar, new integer(parameter)); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch (numberformatexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.put(argchar, args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } private boolean isstringarg(char argchar) { return stringargs.containskey(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isbooleanarg(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return "-[" + schema + “]”; else return “”; } 267public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument - %c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“arguments(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } private boolean falseifnull(boolean b) { return b != null && b; } private int zeroifnull(integer i) { return i == null ? 0 : i; } private string blankifnull(string s) { return s = null ? “” : s; } public string getstring(char arg) { return blankifnull(stringargs.get(arg)); } public int getint(char arg) { return zeroifnull(intargs.get(arg)); } public boolean getboolean(char arg) { return falseifnull(booleanargs.get(arg)); } public boolean has(char arg) ( 268return argsfound.contains(arg); } public boolean isvalid() { return valid; } private class argsexception extends exception { } } espero que su reacción inicial ante tal cantidad de código es alegrarse por no haberlo conservado tal cual. si ha sido su reacción, recuerde que será la que tengan otros que lean un borrador de su código. en realidad, primer borrador es lo mejor que se puede decir sobre este código. evidentemente es un trabajo en progreso. la cantidad de variables de instancia es apabullante. cadenas extrañas como « tilt », hashset y treeset , y los bloques try-catch-catch aumentan el desastre. no era mi intención crear este desastre. en realidad, intentaba mantener cierta organización, como demuestra la elección de nombres de funciones y variables, y la estructura del programa. pero es evidente que el problema se me fue de las manos. el desastre aumentó gradualmente. las versiones anteriores no fueron tan malas. por ejemplo, el listado 14-9 muestra una versión inicial en la que sólo funcionaban los argumentos booleanos. listado 14-9 args.java (sólo argumentos booleanos) package com.objectmentor.utilities.getopts; import java.util.*; public class args { private string schema; private string[] args; private boolean valid; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private int numberofarguments = 0; public args(string schema, string[] args) { this.schema = schema; this.args = args; 269valid = parse(); } public boolean isvalid() { return valid; } private boolean parse() { if (schema.length() == 0 && args.length == 0) return true; parseschema(); parsearguments(); return unexpectedarguments.size() == 0; } private boolean parseschema() { for (string element : schema.split(“,”)) { parseschemaelement(element); } return true; } private void parseschemaelement(string element) { if (element.length() == 1) { parsebooleanschemaelement(element); } } private void parsebooleanschemaelement(string element) { char c = element.charat(0); if (character.isletter(c)) { booleanargs.put(c, false); } } private boolean parsearguments() { for (string arg : args) parseargument(arg); return true; } private void parseargument(string arg) { if (arg.startswith(“-”)) parseelement(arg); } private void parseelements(string arg) { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) { if (isboolean(argchar)) { numberofarguments++; setbooleanarg(argchar, true); 270} else unexpectedarguments.add(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return numberofarguments; } public string usage() { if (schema.length() > 0) return “-[”+schema+“]”; else return “”; } public string errormessage() { if (unexpectedarguments.size() > 0) { return unexpectedargumentmessage(); } else return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return booleanargs.get(arg); } } aunque hay motivos para quejarse del código, no es tan malo. es compacto y sencillo, y fácil de entender. sin embargo, en este código se aprecia la semilla del desastre posterior y resulta evidente porqué. la versión posterior sólo tiene dos tipos de argumentos más que ésta: string e integer . la inclusión de sólo dos tipos más tiene un tremendo impacto negativo en el código. lo convierte de algo que sería razonablemente 271mantenible en algo que seguramente esté plagado de errores. añadí los dos tipos de argumento de forma incremental. primero, el argumento string , que genera lo siguiente: listado 14-10 args.java (booleano y string) package com.objectmentor.utilities.getopts; import java.text.parseexception; import java.util.*; public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private map<character, string> stringargs = new hashmap<character, string>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargument = ‘\0’; enum errorcode { ok, missing_string } private errorcode errorcode = errorcode.ok; public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); parsearguments(); return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; 272} private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) parsebooleanschemaelement(elementid); else if (isstringschemaelement(elementtail)) parsestringschemaelement(elementid); } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private void parsestringschemaelement(char elementid) { stringargs.put(elementid, “”); } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, false); } private boolean parsearguments() { for (currentargument = 0; currentargument < args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } 273private void parseelement(char argchar) { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); valid = false; } } private boolean setargument(char argchar) { boolean set = true; if (isboolean(argchar)) setbooleanarg(argchar, true); else if (isstring(argchar)) setstringarg (argchar, “”); else set = false; return set; } private void setstringarg(char argchar, string s) { currentargument++; try { stringargs.put(argchar, args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargument = argchar; errorcode = errorcode.missing_string; } } private boolean isstring(char argchar) { return stringargs.containskey(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return “-[” + schema + “]”; else return “”; } 274public string errormessage() throws exception { if (unexpectedarguments.size() > 0) { return unexpectedargumentmessage(); } else switch (errorcode) { case missing_string: return string.format (“could not find string parameter for -%c.”, errorargument); case ok: throw new exception(“tilt: should not get here.”); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return falseifnull(booleanargs.get(arg)); } private boolean falseifnull(boolean b) { return b == null ? false : b; } public string getstring(char arg) { return blankifnull(stringargs.get(arg)); } private string blankifnull(string s) { return s == null ? “” : s; } public boolean has(char arg) { return argsfound.contains(arg); } public boolean isvalid() { return valid; } } comprobará que empieza a desbocarse. no es terrible pero el desastre se está gestando. basta con incluir el tipo de argumento integer para que resulte fatídico. 275entonces me detuve todavía tenía que añadir otros dos tipos de argumentos y sabía que empeorarían las cosas. si los forzaba, seguramente funcionarían pero provocaría un desastre demasiado complicado de arreglar. si la estructura del código tenía que poder mantenerse, era el momento de corregirla. por ello dejé de añadir elementos y comencé la refactorización. tras añadir los argumentos string e integer , sabía que cada uno necesitaría nuevo código en tres puntos principales. en primer lugar, cada tipo de argumento necesita una forma de analizar su elemento de esquema para poder seleccionar el hashmap de ese tipo. tras ello, sería necesario analizar cada tipo de argumento en las cadenas de línea de comandos y convertirlos en su tipo correcto. por último, cada tipo de argumento necesitaría un método getxxx para poder devolverlo al invocador como su tipo correcto. muchos tipos diferentes y todos con métodos similares, lo que en realidad era una clase. y de este modo nació el concepto de argumentmarshaler . sobre el incrementalismo una de las mejores formas de acabar con un programa es realizar cambios masivos con la intención de mejorarlo. algunos programas nunca se recuperan de estas mejoras. el problema es lo complicado que resulta conseguir que el programa funcione de la misma forma que antes de la mejora. para evitarlo, recurro a la disciplina tdd ( test-driven development o desarrollo guiado por pruebas). una de las doctrinas centrales de este enfoque es mantener la ejecución del sistema en todo momento. es decir, con tdd no puedo realizar cambios que afecten al funcionamiento del sistema. todos los cambios deben mantenerlo como antes de los cambios. para lograrlo, necesito una serie de pruebas automatizadas que ejecutar rápidamente y que verifiquen que el comportamiento del sistema no ha variado. para la clase args , creé una serie de pruebas de unidad y aceptación. las pruebas de unidad se crearon en java y se administraron con junit. las 276pruebas de aceptación se crearon como páginas wiki en fitnesse. podría haber ejecutado estas pruebas en cualquier momento y, si eran satisfactorias, sabría que el sistema funcionaba de la forma especificada. así pues, comencé a realizar pequeños cambios. cada uno desplazaba la estructura del sistema hacia el concepto argumentmarshaler , y cada cambio mantenía el funcionamiento del sistema. el primer cambio realizado fue añadir el esqueleto de argumentmarshaller al final del desastre anterior (véase el listado 14-11). listado 14-11 argumentmarshaller añadido a args.java private class argumentmarshaler { private boolean booleanvalue = false; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } private class booleanargumentmarshaler extends argumentmarshaler { } private class stringargumentmarshaler extends argumentmarshaler { } private class integerargumentmarshaler extends argumentmarshaler { } } evidentemente, esto no afectaría a nada, por lo que realicé la modificación más sencilla posible que afectara a la mínima cantidad de código. cambié hashmap para que los argumentos boolean aceptaran argumentmarshaler . private map<character, argumentmarshaler > booleanargs = new hashmap<character, argumentmarshaler >(); esto afectaba a varias instrucciones que corregí rápidamente. … private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, new booleanargumentmarshaler ()); } … 277private void setbooleanarg(char argchar, boolean value) { booleanargs. get (argchar). setboolean (value); } … public boolean getboolean(char arg) { return falseifnull (booleanargs.get(arg). getboolean() ); } estos cambios se aplican a las zonas que mencionamos antes: parse , set y get para el tipo de argumento. desafortunadamente, aunque sean cambios menores, algunas de las pruebas comenzaron a fallar. si se fija atentamente en getboolean , comprobará que se puede invocar con y pero no existe un argumento y , por lo que booleanargs.get(‘y’) devolverá null y la función generará nullpointerexception . la función falseifnull se usa como protección ante este hecho pero el cambio aplicado hace que la función sea irrelevante. el incrementalismo exigía que esto funcionara antes de realizar otros cambios. la solución no era demasiado complicada; bastaba con cambiar la comprobación de null . ya no era necesario comprobar null en boolean, sino en argumentmarshaller . primero, eliminé la invocación de falseifnull en la función getboolean . ya no servía de nada, por lo que eliminé directamente la función. las pruebas seguían fallando igual, lo que suponía que no había nuevos errores. public boolean getboolean(char arg) { return booleanargs.get(arg).getboolean(); } tras ello, dividí la función en dos líneas y añadí argumentmarshaller a una variable propia: argumentmarshaller . no me preocupaba el extenso nombre de la variable; era redundante y estorbaba a la función, por lo que lo reduje a am [n5]. public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am .getboolean(); } y tras ello añadí la lógica de detección de null . public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); 278return am != null && am.getboolean(); } argumentos de cadena la inclusión de los argumentos string fue similar a la de los argumentos boolean . tuve que cambiar hashmap y conseguir que funcionaran parse , set y get . no deberían producirse sorpresas posteriores a excepción de que la implementación completa se incluía en la clase argumentmarshaller en lugar de distribuirla en variantes. private map<character, argumentmarshaler > stringargs = new hashmap<character, argumentmarshaler >(); … private void parsestringschemaelement(char elementid) { stringargs.put(elementid, new stringargumentmarshaler()); } … private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs. get (argchar). setstring (args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring (char arg) { args.argumentmarshaler am = stringargs.get(arg); return am == null ? “” : am.getstring(); } … private class argumentmarshaler { private boolean booleanvalue = false; private string stringvalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { 279stringvalue = s; } public string getstring() { return stringvalue == null ? “” : stringvalue; } } de nuevo, estos cambios se realizaron individualmente para conservar las pruebas, aunque fallaran. si una prueba fallaba, me aseguraba de que fuera correcta antes de continuar con el siguiente cambio. ya debería reconocer mi intención. tras incluir el comportamiento de señalización en la clase base argumentmarshaler , comencé a transferirlo a las variantes, para de esta forma mantener el funcionamiento mientras cambiaba gradualmente la forma del programa. el siguiente paso consistía en transferir la funcionalidad del argumento int a argumentmarshaler . de nuevo, no hubo sorpresas. private map<character, argumentmarshaler > intargs = new hashmap<character, argumentmarshaler >(); … private void parseintegerschemaelement(char elementid) { intargs.put(elementid, new integerargumentmarshaler() ); } … private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs. get (argchar). setinteger (integer.parseint(parameter)); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch (numberformatexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } … public int getint(char arg) { args.argumentmarshaler am = intargs.get(arg); return am == null ? 0 : am.getinteger(); } 280… private class argumentmarshaler { private boolean booleanvalue = false; private string stringvalue; private int integervalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { stringvalue = s; } public string getstring() { return stringvalue == null ? “” : stringvalue; } public void setinteger(int i) { integervalue = i; } public int getinteger() { return integervalue; } } tras transferir la señalización a argumentmarshaler , comencé a transferir la funcionalidad a las variantes. el primer paso fue pasar la función setboolean a booleanargumentmarshaller y garantizar su correcta invocación. para ello creé un método set abstracto. private abstract class argumentmarshaler { protected boolean booleanvalue = false; private string stringvalue; private int integervalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { stringvalue = s; } public string getstring() { 281return stringvalue == null ? “” : stringvalue; } public void set integer(int i) { integervalue = i; } public int getinteger() { return integervalue; } public abstract void set(string s); } tras ello, implementé el método set en booleanargumentmarshaller . private class booleanargumentmarshaler extends argumentmarshaler { public void set(string s) { booleanvalue = true; } } y por último cambié la invocación de setboolean por la de set . private void setbooleanarg(char argchar, boolean value) { booleanargs.get(argchar). set(“true”) ; } las pruebas seguían siendo satisfactorias. como este cambio hacía que set se implementara en booleanargumentmarshaler , eliminé el método setboolean de la clase base argumentmarshaler . la función abstracta set acepta un argumento string pero la implementación de booleanargumentmarshaler no lo usa. he incluido el argumento porque sabía que stringargumentmarshaler e integerargumentmarshaler lo utilizarían. tras ello, el objetivo era implementar el método get en booleanargumentmarshaler . la implementación de funciones get siempre es escabrosa ya que el tipo devuelto tiene que ser object y en este caso debe convertirse a boolean . public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am != null && (boolean) am. get (); } para compilarlo, añadí la función get a argumentmarshaler . private abstract class argumentmarshaler { … 282public object get() { return null; } } se compila y las pruebas fallan. para que vuelvan a funcionar, basta con convertir get en abstracto e implementarlo en booleanargumentmarshaler . private abstract class argumentmarshaler { protected boolean booleanvalue = false; … public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { public void set (string s) { booleanvalue = true; } public object get() { return booleanvalue; } } de nuevo, las pruebas son satisfactorias. ahora tanto get como set se implementan en booleanargumentmarshaler . esto me permite eliminar la antigua función getboolean de argumentmarshaler , cambiar la variable protegida booleanvalue a booleanargumentmarshaler y convertirla en privada. repetí el mismo patrón de cambios con las cadenas. implementé set y get , eliminé las funciones sin usar y desplacé las variables. private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.get(argchar). set (args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring(char arg) { args.argumentmarshaler am = stringargs.get(arg); return am == null ? “” : (string) am. get (); } 283… private abstract class argumentmarshaler { private int integervalue; public void setinteger(int i) { integervalue = i; } public int getinteger() { return integervalue; } public abstract void set(string s); public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(string s) { booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { public void set(string s){ } public object get() { return null; } } } por último, repetí el proceso con los enteros. resulta más complicado ya que los enteros deben analizarse y la operación de análisis puede generar una 284excepción, pero el resultado es más indicado ya que el concepto de numberformatexception se oculta totalmente en integerargumentmarshaler . private boolean isintarg(char argchar) { return intargs.containskey(argchar); } private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.get(argchar). set (parameter); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( argsexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e ; } } … private void setbooleanarg(char argchar) { try { booleanargs.get(argchar).set(“true”); } catch (argsexception e) { } } … public int getint(char arg) { args.argumentmarshaler am = intargs.get(arg); return am == null ? 0 : (integer) am. get (); } … private abstract class argumentmarshaler { public abstract void set(string s) throws argsexception; public abstract object get(); } … private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception s) { throw new argsexception(); } 285} public object get() { return intvalue; } } evidentemente, las pruebas seguían funcionando. tras ello, me deshice de las distintas asignaciones de la parte superior del algoritmo, lo que hace que el sistema sea mucho más genérico. sin embargo, no las puede eliminar ya que afectaría a la integridad del sistema. en su lugar, añadí un nuevo map para argumentmarshaler y, tras ello, cambié uno a uno los métodos para que usaran la nueva asignación en lugar de las originales. public class args { … private map<character, argumentmarshaler> booleanargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … private void parsebooleanschemaelement(char elementid) { argumentmarshaler m = new booleanargumentmarshaler(); booleanargs.put(elementid, m); marshalers.put(elementid, m); } private void parseintegerschemaelement(char elementid) { argumentmarshaler m = new integerargumentmarshaler(); intargs.put(elementid, m); marshalers.put(elementid, m); } private void parsestringschemaelement(char elementid) { argumentmarshaler m = new stringargumentmarshaler(); stringargs.put(elementid, m); marshalers.put(elementid, m); } las pruebas seguían funcionando. tras ello, cambié isbooleanarg de esto: private boolean isbooleanarg(char argchar) { return booleanargs.containskey(argchar); } a este otro: 286private boolean isbooleanarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof booleanargumentmarshaler; } las pruebas funcionaban, por lo que apliqué el mismo cambio en isintarg e isstringarg . private boolean isintarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof integerargumentmarshaler; } private boolean isstringarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof stringargumentmarshaler; } las pruebas eran correctas, por lo que eliminé las invocaciones duplicadas de marshalers.get : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (isbooleanarg( m )) setbooleanarg(argchar); else if (isstringarg( m )) setstringarg(argchar); else if (isintarg( m )) setintarg(argchar); else return false; return true; } private boolean isintarg ( argumentmarshaler m ) { return m instanceof integerargumentmarshaler; } private boolean isstringarg ( argumentmarshaler m ) { return m instanceof stringargumentmarshaler; } private boolean isbooleanarg ( argumentmarshaler m ) { return m instanceof booleanargumentmarshaler; } los tres argumentos isxxxarg ya no tenían sentido, de modo que los reubiqué: private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if ( m instanceof booleanargumentmarshaler ) setbooleanarg(argchar); 287else if ( m instanceof stringargumentmarshaler ) setstringarg(argchar); else if ( m instanceof integerargumentmarshaler ) setintarg(argchar); else return false; return true; } tras ello, empecé a usar la asignación marshalers en las funciones set , dividiendo el uso de las otras tres asignaciones. comencé por los elementos boolean . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m instanceof booleanargumentmarshaler) setbooleanarg( m ); else if (m instanceof stringargumentmarshaler) setstringarg(argchar); else if (m instanceof integerargumentmarshaler) setintarg(argchar); else return false; return true; } … private void setbooleanarg( argumentmarshaler m ) { try { m .set(“true”); // era: booleanargs.get(argchar).set(“true”); } catch (argsexception e) { } } las pruebas seguían siendo correctas de modo que repetí la operación con las cadenas y los enteros. de esta manera se puede integrar parte del desagradable código de gestión de excepciones en la función setargument . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg( m ); else if (m instanceof integerargumentmarshaler) setintarg( m ); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; 288throw e; } return true; } private void setintarg( argumentmarshaler m ) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; m .set(parameter); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg( argumentmarshaler m ) throws argsexception { currentargument++; try { m .set(args[currentargument]); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } ya podía eliminar las tres asignaciones antiguas. primero, debía cambiar la función getboolean de: public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am != null && (boolean) am.get(); } a: public boolean getboolean(char arg) { args.argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } este último cambio puede parecer sorprendente. ¿por qué de repente decidí enfrentarme a classcastexception ? por tener una serie de pruebas de 289unidad y otra serie independiente de pruebas de aceptación creadas en fitnesse. las pruebas de fitnesse garantizan que si se invoca getboolean en un argumento no booleano, se obtiene false . no sucede lo mismo con las pruebas de unidad. hasta el momento, sólo había ejecutado las pruebas de unidad [93] . este último cambio me permitió extraer otro uso de la asignación boolean: private void parsebooleanschemaelement(char elementid) { argumentmarshaler m = new booleanargumentmarshaler(); booleanargs.put(elementid, m); marshalers.put(elementid, m); } y ahora ya podemos eliminar la asignación boolean. public class args { … private map<character, argumentmarshaler> booleanargs = new hashmap<character, argmentmarshaler>(); private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … tras ello, cambié los argumentos string e integer de la misma forma y limpié los valores boolean . private void parsebooleanschemaelement(char elementid) { marshalers.put(elementid, new booleanargumentmarshaler() ); } private void parseintegerschemaelement(char elementid) { marshalers.put(elementid, new integerargumentmarshaler() ); } private void parsestringschemaelement(char elementid) { marshalers.put(elementid, new stringargumentmarshaler() ); } … public string getstring(char arg) { args.argumentmarshaler am = marshalers .get(arg); try { return am null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } 290public int getint(char arg) { args.argumentmarshaler am = marshalers .get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } … public class args { … private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … seguidamente, dispuse en línea los tres métodos parse ya que no servían para mucho: private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else if (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentmarshaler()); else if (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( “argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } es el momento de ver la estructura completa. el listado 14-12 muestra la clase args actual. listado 14-12 args.java (tras la primera refactorización) package com.objectmentor.utilities.getopts; import java.text.parseexception; import java.util.*; public class args { private string schema; 291private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { } return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else if (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentwarshaler()); else if (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( 292“argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private boolean isintegerschemaelement(string elementtail) { return elementtail.equals(“#”); } private boolean parsearguments() throws argsexception { for (currentargument=0; currentargument<args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = errorcode.unexpected_argument; valid = false; } } private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); try { 293if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } private void setintarg(argumentmarshaler m) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; m.set(parameter); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg(argumentmarshaler m) throws argsexception { currentargument++; try { m.set (args[currentargument]); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } private void setbooleanarg(argumentmarshaler m) { try { m.set(“true”); } catch (argsexception e) { } } public int cardinality() { return argsfound.size(); } public string usage() { 294if (schema.length() > 0) return = “-[” + schema + “]”; else return “”; } public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for {char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { args.argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } public string getstring(char arg) { args.argumentmarshaler am = marshalers.get (arg); try { return am == null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } 295public int getint(char arg) { args.argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } public boolean has(char arg) { return argsfound.contains(arg); } public boolean isvalid() { return valid; } private class argsexception extends exception { } private abstract class argumentmarshaler { public abstract void set(string s) throws argsexception; public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(string s) { booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); 296} catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } } tras todo este esfuerzo, es un tanto decepcionante. la estructura ha mejorado pero todavía hay demasiadas variables en la parte superior; se mantiene un terrible caso de tipos en setargument ; y todas las funciones set . sin mencionar el procesamiento de errores. todavía nos queda mucho trabajo por hacer. mi intención es eliminar el caso de tipos de setargument [g23] y que sólo incluya una invocación a argumentmarshaler.set . para ello, debo desplazar setintarg , setstringarg y setbooleanarg a las correspondientes variantes de argumentmarshaler . pero hay un problema. si se fija atentamente en setintarg , comprobará que usa dos variables de instancia: args y currentarg . para desplazar setintarg hasta booleanargumentmarshaler , tengo que pasar args y currentargs como argumentos de función. muy desagradable [f1]. resultaría más indicado pasar un argumento y no dos. afortunadamente, la solución es sencilla. podemos convertir la matriz args en list y pasar iterator a las funciones set . para el siguiente cambio necesité diez pasos, y superar todas las pruebas tras cada uno. pero sólo mostraremos el resultado. debería determinar la mayoría de estos pequeños pasos. public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private iterator<string> currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private list<string> argslist; 297private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument } public args(string schema. string[] args) throws parseexception { this.schema = schema; argslist = arrays.aslist(args); valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && argslist.size() == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { } return valid; } … private boolean parsearguments() throws argsexception { for (currentargument = argslist.iterator(); currentargument. hasnext() ;) { string arg = currentargument. next() ; parseargument(arg); } return true; } … private void setintarg(argumentmarshaler m) throws argsexception { string parameter = null; try { parameter = currentargument. next() ; m.set(parameter); } catch ( nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg(argumentmarshaler m) throws argsexception { try { m.set (currentargument. next() ); } catch ( nosuchelementexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } 298son pequeños cambios que conservan el funcionamiento de las pruebas. ahora podemos empezar a desplazar las funciones set a las correspondientes variantes. primero, debemos realizar el siguiente cambio en setargument : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } es un cambio importante ya que queremos eliminar totalmente la cadena if-else . por tanto, debemos excluir la condición de error. ya podemos empezar a desplazar las funciones set . la función setbooleanarg es trivial, de modo que la prepararemos en primer lugar. el objetivo es cambiar la función setbooleanarg para redirigirla a booleanargumentmarshaler . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m, currentargument ); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } 299return true; } --- private void setbooleanarg (argumentmarshaler m, iterator<string> currentargument) throws argsexception { try { m.set(“true”); catch (argsexception e) { } } ¿no acabamos de incluir el procesamiento de excepciones? añadir elementos para después excluirlos es habitual en los procesos de refactorización. los pasos reducidos y la necesidad de que las pruebas sigan siendo correctas implican que los elementos cambien de posición. la refactorización es como resolver el cubo de rubik. se necesitan muchos pasos pequeños para lograr un objetivo mayor. cada paso habilita el siguiente. se preguntará por qué pasamos iterator si setbooleanarg no lo necesita. pues porque setintarg y setstringarg sí. y como el objetivo es implementar las tres funciones a través de un método abstracto en argumentmarshaller , es necesario pasarlo a setbooleanarg . ahora setbooleanarg no sirve de nada. si hubiera una función set en argumentmarshaler , podríamos invocarla directamente. es el momento de crear dicha función. el primer paso consiste en añadir el nuevo método abstracto a argumentmarshaler . private abstract class argumentmarshaler { public abstract void set(iterator<string> currentargument) throws argsexception; public abstract void set (string s) throws argsexception; public abstract object get(); } evidentemente, esto afecta a todas las variantes, de modo que implementamos el nuevo método en cada una. private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(iterator<string> currentargument) throws argsexception { booleanvalue = true; } public void set(string s) { 300booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { } public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { } public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } y ahora ya podemos eliminar setbooleanarg : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) m.set (currentargument); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); 301} catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } las pruebas siguen siendo satisfactorias y la función set se implementa en boolean argumentmarshaler . podemos repetir la operación con las cadenas y los enteros. private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) m.set(currentargument); else if (m instanceof stringargumentmarshaler) m.set(currentargument); else if (m instanceof integerargumentmarshaler) m.set(currentargument); } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } --- private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } public void set(string s){ } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { 302private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); set(parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } y el golpe de gracia: se elimina el caso de tipos. private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { m.set(currentargument); return true; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } } ya podemos deshacernos de las funciones de integerargumentmarshaler y limpiar el resto. private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0 public void set (iterator<string> currentargument) throws argsexception { string parameter = null; try { 303parameter = currentargument.next(); intvalue = integer.parseint (parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( numberformatexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } public object get() { return intvalue; } } también podemos convertir argumentmarshaler en una interfaz. private interface argumentmarshaler { void set (iterator<string> currentargument) throws argsexception; object get(); } veamos ahora lo sencillo que resulta añadir un nuevo tipo de argumento a la estructura. apenas necesitaremos cambios y los que apliquemos tendrán que ser aislados. en primer lugar, añadimos un nuevo caso de prueba para comprobar que el argumento double funciona correctamente: public void testsimpledoublepresent() throws exception { args args = new args(“x##”, new string[] {“-x”,“42.3”}); asserttrue(args.isvalid()); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42.3, args.getdouble(‘x’), .001); } limpiamos el código de análisis de esquemas y añadimos la detección ## para el tipo de argumento double . private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (elementtail. length() == 0 ) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail. equals(“*”) ) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail. equals(“#”) ) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); 304else throw new parseexception(string.format( “argument: %c has invalid format: %s.”, elementid, elementtail), 0); } seguidamente, creamos la clase doubleargumentmarshaler . private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_double; throw new argsexception(); } catch (numberformatexception e) { errorparameter = parameter; errorcode = errorcode.invalid_double; throw new argsexception(); } } public object get() { return doublevalue; } } esto nos obliga a añadir un nuevo código de error ( errorcode ). private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } y necesitamos una función getdouble . public double getdouble(char arg) { args.argumentmarshaler am = marshalers.get(arg); try { return am = null ? 0 : (double) am.get(); } catch (exception e) { return 0.0; } } y todas las pruebas son correctas. ha sido sencillo. a continuación comprobamos que el procesamiento de errores funciona correctamente. el siguiente caso de prueba comprueba que se declare un error si se proporciona 305una cadena que no se puede analizar a un argumento ##. public void testinvaliddouble() throws exception { args args = new args(“x##”, new string[] {“-x”, “forty two”}); assertfalse(args.isvalid()); assertequals(0, args.cardinality()); assertfalse(args.has(‘x’)); assertequals(0, args.getint(‘x’)); assertequals(“argument -x expects a double but was ‘forty two’.”, args.errormessage()); } --- public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c”, errorargumentid); } return “”; } y las pruebas son satisfactorias. la siguiente prueba garantiza que se detecte correctamente la ausencia de un argumento double . public void testmissingdouble() throws exception { args args = new args(“x##”, new string[]{"-x"}); assertfalse (args.isvalid()); assertequals(0, args.cardinality()); assertfalse(args.has(‘x’)); assertequals(0.0, args.getdouble(‘x’), 0.01); assertequals(“could not find double parameter for -x.”, args.errormessage()); } es correcto. la incluimos para que el ejemplo resulte más completo. el código de excepciones no es atractivo y no pertenece realmente a la 306clase args . también generamos parseexception , que no nos pertenece. por ello, combinamos todas las excepciones en una única clase argsexception y la incluimos en su propio módulo. public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; public argsexception() {} public argsexception(string message) { super(message); } public enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } } … public class args { … private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private argsexception .errorcode errorcode = argsexception .errorcode.ok; private list<string> argslist; public args(string schema, string[] args) throws argsexception { this.schema = schema; argslist = arrays.aslist(args); valid = parse(); } private boolean parse() throws argsexception { if (schema.length() == 0 && argslist.size() == 0) return true; parseschema(); try { parsearguments(); } catch ( argsexception e) { } return valid; } private boolean parseschema() throws argsexception { … } private void parseschemaelement(string element) throws argsexception { … else throw new argsexception ( string.format(“argument: %c has invalid format: %s.”, elementid, elementtail)); } 307private void validateschemaelementid(char elementid) throws argsexception { if (!character.isletter(elementid)) { throw new argsexception ( “bad character:” + elementid + “in args format: ” + schema); } } … private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = argsexception .errorcode.unexpected_argument; valid = false; } } … private class stringargumentmarshaler implements argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { errorcode = argsexception .errorcode.missing_string; throw new argsexception(); } } public object get() { return stringvalue; } } private class integerargumentmarshaler implements argumentmarshaler { private int intvalue = 0; public void set (iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); intvalue = integer.parseint(parameter); } catch (nosuchelementexception e) { errorcode = argsexception.errorcode.missing_integer; throw new argsexception (); } catch (numberformatexception e) { errorparameter = parameter; errorcode = argsexception .errorcode.invalid_integer; throw new argsexception (); 308} } public object get() { return intvalue; } } private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception e) { errorcode = argsexception .errorcode.missing_double; throw new argsexception(); } catch (numberformatexception e) { errorparameter = parameter; errorcode = argsexception .errorcode.invalid_double; throw new argsexception); } } public object get() { return doublevalue; } } } muy bien. ahora, args solamente genera argsexception . al desplazar argsexception a un módulo propio, podemos añadir a dicho módulo gran parte del código de error y extraerlo del módulo args . es una posición natural y evidente para incluir todo el código y nos permitirá limpiar posteriormente el módulo args . ya hemos separado el código de excepciones y de error del módulo args (véanse los listados del 14-13 al 14-16). para ello realizamos una serie de 30 pasos mínimos y las pruebas fueron satisfactorias entre todos ellos. listado 14-13 argstest.java. package com.objectmentor.utilities.args; import junit.framework.testcase; 309public class argstest extends testcase { public void testcreatewithnoschemaorarguments() throws exception { args args = new args(“”, new string[0]); assertequals(0, args.cardinality()); } public void testwithnoschemabutwithoneargument() throws exception { try { new args(“”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.unexpected_argument, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testwithnoschemabutwithmultiplearguments() throws exception { try { new args(“”, new string[]{“-x”, “-y”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.unexpected_argument, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testnonletterschema() throws exception { try { new args(“*”, new string[]{}); fail(“args constructor should have thrown exception”); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_argument_name, e.geterrorcode()); assertequals(‘*’, e.geterrorargumentid()); } } public void testinvalidargumentformat() throws exception { try { new args(“f~”, new string[]{}); fail(“args constructor should have throws exception”); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_format, e.geterrorcode()); assertequals(‘f’, e.geterrorargumentid()); } } public void testsimplebooleanpresent() throws exception { args args = new args(“x”, new string []{“-x”}); assertequals(1, args.cardinality()); assertequals(true, args.getboolean(‘x’)); 310} public void testsimplestringpresent() throws exception { args args = new args(“x*”, new string[]{“-x”, “param”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(“param”, args.getstring(‘x’)); } public void testmissingstringargument() throws exception { try { new args(“x*”, new string[]{"-x"}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_string, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testspacesinformat() throws exception { args args = new args(“x, y”, new string[]{“-xy”}); assertequals(2, args.cardinality()); asserttrue(args.has(‘x’)); asserttrue(args.has(‘y’)); } public void testsimpleintpresent() throws exception { args args = new args(“x#”, new string[]{“-x”, “42”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42, args.getint(‘x’)); } public void testinvalidinteger() throws exception { try { new args(“x#”, new string[] {“-x”, “forty two”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_integer, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); assertequals(“forty two”, e.geterrorparameter()); } } public void testmissinginteger() throws exception { try { new args(“x#”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_integer, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } 311public void testsimpledoublepresent() throws exception { args args = new args(“x##”, new string[](“-x”, “42.3”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42.3, args.getdouble(‘x’), .001); } public void testinvaliddouble() throws exception { try { new args(“x##”, new string []{“-x”, “forty two”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_double, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); assertequals(“forty two”, e.geterrorparameter()); } } public void testmissingdouble() throws exception { try { new args(“x##”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_double, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } } listado 14-14 argsexceptiontest.java. public class argsexceptiontest extends testcase { public void testunexpectedmessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.unexpected_argument, ‘x’, null); assertequals(“argument -x unexpected.”, e.errormessage()); } public void testmissingstringmessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_string, ‘x’, null); assertequals(“could not find string parameter for –x.”, e.errormessage()); } public void testinvalidintegermessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.invalid_integer, 312‘x’, “forty two”); assertequals(“argument –x expects an integer but was ‘forty two’.”, e.errormessage()); } public void testmissingintegermessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_integer, ‘x’, null); assertequals(“could not find integer parameter for -x.”, e.errormessage()); } public void testinvaliddoublemessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.invalid_double, ‘x’, “forty two”); assertequals(“argument -x expects a double but was ‘forty two’.”, e.errormessage()); } public void testmissingdoublemessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_double, ‘x’, null); assertequals(“could not find double parameter for -x.”, e.errormessage()); } } listado 14-15 argsexception.java. public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; public argsexception() {} public argsexception(string message) {super(message);} public argsexception(errorcode errorcode) { this.errorcode = errorcode; } public argsexception(errorcode errorcode, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; } public argsexception(errorcode errorcode, char errorargumentid, string errorparameter) { this.errorcode = errorcode; 313this.errorparameter = errorparameter; this.errorargumentid = errorargumentid; } public char geterrorargumentid() { return errorargumentid; } public void seterrorargumentid(char errorargumentid) { this.errorargumentid = errorargumentid; } public string geterrorparameter() { return errorparameter; } public void seterrorparameter(string errorparameter) { this.errorparameter = errorparameter; } public errorcode geterrorcode() { return errorcode; } public void seterrorcode(errorcode errorcode) { this.errorcode = errorcode; } public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return string.format(“argument -%c unexpected.”, errorargumentid); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c.”, errorargumentid); } return “”; } public enum errorcode { ok, invalid_format, unexpected_argument, invalid_argument_name, 314missing_string, missing_integer, invalid_integer, missing_double, invalid_double} } listado 14-16 args.java. public class args { private string schema; private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private iterator<string> currentargument; private list<string> argslist; public args(string schema, string[] args) throws argsexception { this.schema = schema; argslist = arrays.aslist(args); parse(); } private void parse() throws argsexception { parseschema(); parsearguments(); } private boolean parseschema() throws argsexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { parseschemaelement(element.trim()); } } return true; } private void parseschemaelement(string element) throws argsexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (elementtail.length() == 0) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail.equals(“*”)) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail.equals(“#”)) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); else throw new argsexception(argsexception.errorcode.invalid_format, elementid, elementtail); } 315private void validateschemaelementid(char elementid) throws argsexception { if (!character.isletter(elementid)) { throw new argsexception(argsexception.errorcode.invalid_argument_name, elementid, null); } } private void parsearguments() throws argsexception { for (currentargument = argslist.iterator(); currentargument.hasnext();) { string arg = currentargument.next(); parseargument(arg); } } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { throw new argsexception(argsexception.errorcode.unexpected_argument, argchar, null); } } private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { m.set(currentargument); return true; } catch (argsexception e) { e.seterrorargumentid(argchar); throw e; } } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return "-[" + schema + “]”; 316else return “”; } public boolean getboolean(char arg) { argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } public string getstring(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } public int getint(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } public double getdouble(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (double) am.get(); } catch (exception e) { return 0.0; } } public boolean has(char arg) { return argsfound.contains(arg); } } la mayoría de los cambios realizados en la clase args han sido eliminaciones. gran parte del código se extrajo de args y se añadió a argsexception . perfecto. también cambiamos todos los elementos argumentmarshaller a sus propios archivos. mejor todavía. 317el diseño de software correcto se basa gran parte en las particiones, en crear zonas adecuadas para incluir distintos tipos de código. esta separación hace que el código sea más fácil de entender y mantener. especialmente interesante es el método errormessage de argsexception . incumple claramente el srp al incluir el formato de mensajes de error en args . args debe centrarse en el procesamiento de argumentos, no en el formato de los mensajes de error. sin embargo, ¿realmente tiene sentido incluir el código de formato de mensajes de error en argsexception ? francamente es un compromiso. los usuarios que no deseen los mensajes de error proporcionados por argsexception tendrán que crear los suyos propios, pero la utilidad de mensajes de error ya preparados es evidente. ya debería haberse dado cuenta de la distancia recorrida con respecto a la solución mostrada al inicio del capítulo. las transformaciones finales puede examinarlas por su cuenta. conclusión no basta con que el código funcione. el código que funciona suele ser incorrecto. los programadores que se conforman con código funcional no se comportan de forma profesional. puede que teman que no tienen tiempo para mejorar la estructura y el diseño del código, pero discrepo. no hay nada que afecte más negativamente a un proyecto de desarrollo que el código incorrecto. los plazos incorrectos se pueden rehacer y los requisitos equivocados se pueden volver a definir. la dinámica incorrecta de un equipo se puede reparar pero el código incorrecto se corrompe y se convierte en una carga que arrastra al equipo completo. he visto equipos dominados por el desastre que han generado y que han dominado su destino. evidentemente, el código incorrecto se puede limpiar pero resulta muy costoso. cuando el código se corrompe los módulos se insinúan unos a otros y generan multitud de dependencias ocultas y entrelazadas. la localización y división de dependencias antiguas es una tarea larga y complicada. por otra parte, resulta relativamente sencillo mantener código limpio. si comete un error en un módulo, es más fácil limpiarlo directamente. mejor todavía, si 318cometió un error hace cinco minutos, es muy fácil limpiarlo ahora. por tanto, la solución consiste en mantener el código limpio y sencillo siempre que se pueda y no dejar que llegue a corromperse. 31915 aspectos internos de junit 320junit es una de las estructuras de java más conocidas. de concepción sencilla, definición precisa y documentación elegante. ¿y su código? en este capítulo analizaremos un ejemplo extraído de la estructura junit. la estructura junit junit ha tenido muchos autores, comenzando por kent beck y eric gamma en un vuelo a atlanta. kent quería aprender java y eric quería saber más sobre la estructura de pruebas smalltalk de kent. “¿hay algo más natural que 321dos fanáticos enciendan sus portátiles y empiecen a escribir código?” [94] tras tres horas de trabajo de altura, habían creado los fundamentos de junit. el módulo que analizaremos es un inteligente fragmento de código que permite identificar errores de comparación de cadenas. el nombre del módulo es comparisoncompactor . dadas dos cadenas diferentes, como abcde y abxde , muestra la diferencia entre ambas generando una cadena como <… b[x]d…> . podríamos explicarlo más, pero los casos de prueba son mejores. fíjese en el listado 15-1 para comprender los requisitos de este módulo. analice la estructura de las pruebas. ¿podrían ser más simples o más evidentes? listado 15-1 comparisoncompactortest.java. package junit.tests.framework; import junit.framework.comparisoncompactor; import junit.framework.testcase; public class comparisoncompactortest extends testcase { public void testmessage() { string failure= new comparisoncompactor(0, “b”, “c”).compact(“a”); asserttrue(“a expected:<[b]> but was:<[c]>”.equals(failure)); } public void teststartsame() { string failure= new comparisoncompactor(1, “ba”, “bc”).compact(null); assertequals(“expected:<b[a]> but was:<b[c]>”, failure); } public void testendsame() { string failure= new comparisoncompactor(1, “ab”, “cb”).compact(null); assertequals(“expected:<[a]b> but was:<[c]b>”, failure); } public void testsame() { string failure= new comparisoncompactor(1, “ab”, “ab”).compact(null); assertequals(“expected:<ab> but was:<ab>”, failure); } public void testnocontextstartandendsame() { string failure= new comparisoncompactor(0, “abc”, “adc”).compact(null); assertequals(“expected:<…[b]…> but was:<…[d]…>”, failure); } 322public void teststartandendcontext() { string failure= new comparisoncompactor(1, “abc”, “adc”).compact(null); assertequals(“expected:<a[b]c> but was:<a[d]c>”, failure); } public void teststartandendcontextwithellipses() { string failure= new comparisoncompactor(1, “abcde”, “abfde”).compact(null); assertequals(“expected:<…b[c]d…> but was:<…b[f]d…>”, failure); } public void testcomparisonerrorstartsamecomplete() { string failure= new comparisoncompactor(2, “ab”, “abc”).compact(null); assertequals(“expected:<ab[]> but was:<ab[c]>”, failure); } public void testcomparisonerrorendsamecomplete() { string failure= new comparisoncompactor(0, “bc”, “abc”).compact(null); assertequals(“expected:<[]…> but was:<[a]…>”, failure); } public void testcomparisonerrorendsamecompletecontext() { string failure= new comparisoncompactor(2, “bc”, “abc”).compact(null); assertequals(“expected:<[]bc> but was:<[a]bc>”, failure); } public void testcomparisonerroroverlapingmatches() { string failure= new comparisoncompactor(0, “abc”, “abbc”).compact(null); assertequals(“expected:<…[]…> but was:<…[b]…>”, failure); } public void testcomparisonerroroverlapingmatchescontext() { string failure= new comparisoncompactor(2, “abc”, “abbc”).compact(null); assertequals(“expected:<ab[]c> but was:<ab[b]c>”, failure); } public void testcomparisonerroroverlapingmatches2() { string failure= new comparisoncompactor(0, “abcdde”, “abcde”).compact(null); assertequals(“expected:<…[d]…> but was:<…[]…>”, failure); } public void testcomparisonerroroverlapingmatches2context() { string failure= new comparisoncompactor(2, “abcdde”, “abcde”).compact(null); assertequals(“expected:<…cd[d]e> but was:<…cd[]e>”, failure); } public void testcomparisonerrorwithactualnull() { string failure= new comparisoncompactor(0, “a”, null).compact(null); assertequals(“expected:<a> but was:<null>”, failure); } public void testcomparisonerrorwithactualnullcontext() { string failure= new comparisoncompactor(2, “a”, null).compact(null); 323assertequals(“expected:<a> but was:<null>”, failure); } public void testcomparisonerrorwithexpectednull() { string failure= new comparisoncompactor(0, null, “a”).compact(null); assertequals(“expected:<null> but was:<a>”, failure); } public void testcomparisonerrorwithexpectednullcontext() { string failure= new comparisoncompactor(2, null, “a”).compact(null); assertequals(“expected:<null> but was:<a>”, failure); } public void testbug609972() { string failure= new comparisoncompactor(10, “s&p500”, “0”).compact(null); assertequals(“expected:<[s&p50]0> but was:<[]0>”, failure); } } realicé un análisis de alcance de código en comparisoncompactor con estas pruebas. el código se cubre en un 100 por 100. cada línea, cada instrucción if y cada bucle for se ejecuta con las pruebas. de este modo sé que el código funciona y sus autores me merecen el mayor de los respetos. el código comparisoncompactor se reproduce en el listado 15-2. examínelo. creo que lo encontrará bien distribuido, razonablemente expresivo y estructuralmente sencillo. cuando termine, lo diseccionaremos. listado 15-2 comparisoncompactor.java (original). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int fcontextlength; private string fexpected; private string factual; private int fprefix; private int fsuffix; public comparisoncompactor(int contextlength, string expected, string actual) { fcontextlength = contextlength; fexpected = expected; 324factual = actual; } public string compact(string message) { if (fexpected == null || factual == null || arestringsequal()) return assert.format(message, fexpected, factual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(fexpected); string actual = compactstring(factual); return assert.format(message, expected, actual); } private string compactstring(string source) { string result = delta_start + source.substring(fprefix, source.length() - fsuffix + 1) + delta_end; if (fprefix > 0) result = computecommonprefix() + result; if (fsuffix > 0) result = result + computecommonsuffix(); return result; } private void findcommonprefix() { fprefix = 0; int end = math.min(fexpected.length(), factual.length()); for (; fprefix < end; fprefix++) { if (fexpected.charat(fprefix) != factual.charat(fprefix)) break; } } private void findcommonsuffix() { int expectedsuffix = fexpected.length() - 1; int actualsuffix = factual.length() - 1; for (; actualsuffix >= fprefix && expectedsuffix >= fprefix; actualsuffix--, expectedsuffix--) { if (fexpected.charat(expectedsuffix) != factual.charat(actualsuffix)) break; } fsuffix = fexpected.length() - expectedsuffix; } private string computecommonprefix() { return (fprefix > fcontextlength ? ellipsis : “”) + fexpected.substring(math.max(0, fprefix - fcontextlength), fprefix); } private string computecommonsuffix() { int end = math.min(fexpected.length() - fsuffix + 1 + fcontextlength, fexpected.length()); 325return fexpected.substring(fexpected.length() - fsuffix + 1, end) + (fexpected.length() - fsuffix + 1 < fexpected.length() - fcontextlength ? ellipsis : “”); } private boolean arestringsequal() { return fexpected.equals(factual); } } puede que tenga varias quejas sobre el módulo. incluye expresiones extensas y extraños elementos +1 . pero en general, está bastante bien. después de todo, podría haber sido como el listado 15-3. listado 15-3 comparisoncompator.java (defactorizado) package junit.framework; public class comparisoncompactor { private int ctxt; private string s1; private string s2; private int pfx; private int sfx; public comparisoncompactor(int ctxt, string s1, string s2) { this.ctxt = ctxt; this.s1 = s1; this.s2 = s2; } public string compact(string msg) { if (s1 == null || s2 == null || s1.equals(s2)) return assert.format(msg, s1, s2); pfx = 0; for (; pfx < math.min(s1.length(), s2.length()); pfx++) { if (s1.charat(pfx) != s2.charat(pfx)) break; } int sfx1 = s1.length() - 1; int sfx2 = s2.length() - 1; for (; sfx2 >= pfx && sfx1 >= pfx; sfx2--, sfx1--) { if (s1.charat(sfx1) != s2.charat(sfx2)) break; } sfx = s1.length() - sfx1; string cmp1 = compactstring(s1); string cmp2 = compactstring(s2); return assert.format(msg, cmp1, cmp2); 326} private string compactstring(string s) { string result = “[” + s.substring(pfx, s.length() - sfx + 1) + “]”; if (pfx > 0) result = (pfx > ctxt ? “…” : “”) + s1.substring(math.max(0, pfx - ctxt), pfx) + result; if (sfx > 0) { int end = math.min(s1.length() - sfx + 1 + ctxt, s1.length()); result = result + (s1.substring(s1.length() - sfx + 1, end) + (s1.length() - sfx + 1 < s1.length() - ctxt ? “…” : “”)); } return result; } } aunque los autores hicieron un buen trabajo con este módulo, la regla del boy scout [95] muestra que podrían haberlo dejado más limpio de lo que se encontró. ¿cómo podemos mejorar el código original del listado 15-2? lo primero que no necesitamos es el prefijo f de las variables miembro [n6]. los entornos actuales hacen que este tipo de código de ámbito sea redundante, por lo que eliminaremos todas las f . private int contextlength; private string expected; private string actual; private int prefix; private int suffix; tras ello, tenemos una condicional sin encapsular al inicio de la función compact [g28]. public string compact(string message) { if (expected == null || actual == null || arestringsequal()) return assert.format(message, expected, actual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } es necesario encapsular esta condicional para que nuestra intención sea más clara. por tanto, extraemos un método que la explique. public string compact(string message) { if ( shouldnotcompact() ) return assert.format(message, expected, actual); 327findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } private boolean shouldnotcompact() { return expected == null || actual == null || arestringsequal(); } en la función compact , this.expected y this.actual no son demasiado relevantes. sucede al cambiar el nombre de fexpected por expected . ¿por qué esta función tiene variables con los mismos nombres que las variables miembro? ¿no representan cosas diferentes?[n4]. los nombres deben ser exclusivos. string compactexpected = compactstring( expected ); string compactactual = compactstring( actual ); los negativos son más difíciles de entender que los positivos [g29]. por ello, invertimos esa instrucción if para cambiar el sentido de la condicional. public string compact(string message) { if ( canbecompacted() ) { findcommonprefix(); findcommonsuffix(); string compactexpected = compactstring(expected); string compactactual = compactstring(actual); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private boolean canbecompacted () { return expected != null && actual != null && !arestringsequal(); } el nombre de la función es extraño [n7]. aunque compacta las cadenas, puede que lo haga si canbecompacted devuelve false . al asignar el nombre compact a esta función se oculta el efecto secundario de la comprobación de errores. además, la función devuelve un mensaje con formato, no sólo las cadenas compactadas. por tanto, el nombre de la función debería ser formatcompactedcomparison . de esta forma, se lee mejor junto al argumento de la función: 328public string formatcompactedcomparison(string message) { el cuerpo de la instrucción if es donde se realiza la verdadera compactación de las cadenas. debemos extraerlo como método con el nombre compactexpectedandactual . sin embargo, queremos que la función formatcompactedcomparison realice todo el formato. la función compact … sólo debe realizar la compactación [g30], de modo que la dividimos de esta forma: … private string compactexpected; private string compactactual; … public string formatcompactedcomparison(string message) { if (canbecompacted()) { compactexpectedandactual(); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private void compactexpectedandactual () { findcommonprefix(); findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } para ello, hemos tenido que ascender compactexpected y compactactual a variables miembro. no me gusta la forma en que las dos últimas líneas de la nueva función devuelven variables pero las dos primeras no lo hacen. no utilizan convenciones coherentes [g11]. debemos cambiar findcommonprefix y findcommonsuffix para que devuelvan los valores de prefijo y sufijo. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonprefix() { int prefix index = 0; int end = math.min(expected.length(), actual.length()); for (; prefix index < end; prefix index ++) { 329if (expected.charat(prefix index ) != actual.charat(prefix index )) break; } return prefixindex; } private int findcommonsuffix() { int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefix index && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix--) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } también debemos cambiar los nombres de las variables miembro para que sean más preciosas [n1], ya que en el fondo son índices. al examinar findcommonsuffix vemos una conexión temporal oculta [g31]; depende de que prefixindex se calcule por findcommonprefix . si estas dos funcione se invocan de forma desordenada, la sesión de depuración posterior sería complicada. por ello, para mostrar esta combinación temporal, haremos que findcommonsuffix acepte prefixindex como argumento. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix( prefixindex ); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonsuffix( int prefixindex ) { int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefixindex && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix--) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } no me convence del todo. el hecho de pasar prefixindex como argumento es un tanto arbitrario [g32]. permite establecer el orden pero no explica la necesidad del mismo. otro programador podría deshacer esta operación ya que no se indica en ningún momento para qué sirve el parámetro. adoptemos un enfoque diferente. 330private void compactexpectedandactual() { findcommonprefixandsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private void findcommonprefixandsuffix () { findcommonprefix(); int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefixindex && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix-- ) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } suffixindex = expected.length() - expectedsuffix; } private void findcommonprefix() { prefixindex = 0; int end = math.min(expected.length(), actual.length()); for (; prefixindex < end; prefixindex++) if (expected.charat(prefixindex) != actual.charat(prefixindex)) break; } devolvemos findcommonprefix y findcommonsuffix a su posición original, cambiamos el nombre de findcommonsuffix por findcommonprefixandsuffix y hacemos que invoque findcommonprefix antes de hacer nada más. de ese modo se establece la naturaleza temporal de ambas funciones de forma más evidente que antes. además, se muestra el mínimo atractivo de findcommonprefixandsuffix , que limpiaremos a continuación: private void findcommonprefixandsuffix() { findcommonprefix(); int suffixlength = 1; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } suffixindex = suffixlength; } private char charfromend(string s, int i) { return s.charat(s.length()-i);} private boolean suffixoverlapsprefix(int suffixlength) { 331return actual.length() - suffixlength < prefixlength || expected.length() - suffixlength < prefixlength; } mucho mejor. muestra que suffixindex es en realidad la longitud del sufijo y que su nombre no es correcto. lo mismo sucede con prefixindex , aunque en ese caso índice y longitud son sinónimos. incluso así, es más coherente usar length . el problema es que la variable suffixindex no es de base cero, sino de base 1 y no es una verdadera longitud. éste es el motivo de la abundancia de +1 en computecommonsuffix [g33]. lo corregimos. en el listado 15-4 puede ver el resultado. listado 15-4 comparisoncompactor.java (versión intermedia). public class comparisoncompactor { … private int suffixlength ; … private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = 0; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } } private char charfromend(string s, int i) { return s.charat(s.length() - i - 1 ); } private boolean suffixoverlapsprefix(int suffixlength) { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } … private string compactstring(string source) { string result = delta_start + source.substring(prefixlength, source.length() - suffixlength ) + delta_end; if (prefixlength > 0) result = computecommonprefix() + result; if ( suffixlength > 0) 332result = result + computecommonsuffix(); return result; } … private string computecommonsuffix() { int end = math.min(expected.length() - suffixlength + contextlength, expected.length() ); return expected.substring(expected.length() - suffixlength , end) + (expected.length() - suffixlength < expected.length() - contextlength ? ellipsis : “”); } cambiamos +1 en computecommonsuffix por un -1 en charfromend, donde tiene sentido, y dos operadores <= en suffixoverlapsprefix , totalmente correctos. de este modo podemos cambiar el nombre de suffixindex por suffixlength , lo que mejora considerablemente la legibilidad del código. pero hay un problema. al comenzar a eliminar los +1 , me fijé en la siguiente línea de compactstring : if (suffixlength > 0) búsquela en el listado 15-4. como ahora suffixlength es una unidad menos que antes, debemos cambiar el operador > por >= . pero eso no tiene sentido. ahora sí. significa que no tenía sentido antes y que seguramente fuera un error. bueno, no del todo. tras un análisis detallado, vemos que ahora la instrucción if impide que se añada un sufijo de longitud cero. antes de realizar el cambio, la instrucción if no funcionaba ya que suffixindex nunca podía ser menos de uno. esto cuestiona ambas instrucciones if en compactstring . parece como si se pudieran eliminar. por ello, las comentamos y ejecutamos las pruebas. satisfactorias. reestructuremos compactstring para eliminar las instrucciones if sobrantes y simplificar la función [g9]. private string compactstring(string source) { return computecommonprefix() + delta_start + source.substring(prefixlength, source.length() - suffixlength) + 333delta_end + computecommonsuffix(); } mucho mejor. ahora vemos que la función compactstring simplemente combina los fragmentos. probablemente lo podríamos limpiar más, en pequeñas operaciones, pero en lugar de desarrollar el resto de los cambios, mostraremos el resultado final en el listado 15-5. listado 15-5 comparisoncompactor.java (versión definitiva). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int contextlength; private string expected; private string actual; private int prefixlength; private int suffixlength; public comparisoncompactor( int contextlength, string expected, string actual ) { this.contextlength = contextlength; this.expected = expected; this.actual = actual; } public string formatcompactedcomparison(string message) { string compactexpected = expected; string compactactual = actual; if (shouldbecompacted()) { findcommonprefixandsuffix(); compactexpected = compact(expected); compactactual = compact(actual); } return assert.format(message, compactexpected, compactactual); } private boolean shouldbecompacted() { return !shouldnotbecompacted(); } private boolean shouldnotbecompacted() { return expected == null || 334actual == null || expected.equals(actual); } private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = 0; for (; !suffixoverlapsprefix(); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength) ) break; } } private char charfromend(string s, int i) { return s.charat(s.length() - i - 1); } private boolean suffixoverlapsprefix() { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } private void findcommonprefix() { prefixlength = 0; int end = math.min(expected.length(), actual.length()); for (; prefixlength < end; prefixlength++) if (expected.charat(prefixlength) != actual.charat(prefixlength)) break; } private string compact(string s) { return new stringbuilder() .append(startingellipsis()) .append(startingcontext()) .append(delta_start) .append(delta(s)) .append(delta_end) .append(endingcontext()) .append(endingellipsis()) .tostring(); } private string startingellipsis() { return prefixlength > contextlength ? ellipsis : “”; } private string startingcontext() { int contextstart = math.max(0, prefixlength - contextlength); int contextend = prefixlength; return expected.substring(contextstart, contextend); } private string delta(string s) { 335int deltastart = prefixlength; int deltaend = s.length() - suffixlength; return s.substring(deltastart, deltaend); } private string endingcontext() { int contextstart = expected.length() - suffixlength; int contextend = math.min(contextstart + contextlength, expected.length()); return expected.substring(contextstart, contextend); } private string endingellipsis() { return (suffixlength > contextlength ? ellipsis : “”); } } bastante atractivo. el módulo se separa en un grupo de funciones de análisis y otro grupo de funciones de síntesis. se ordenan topológicamente para que la definición de cada función aparezca donde realmente se usa. primero se muestran las funciones de análisis y después las de síntesis. si se fija atentamente, verá que he invertido algunas de las decisiones adoptadas inicialmente. por ejemplo, he añadido algunos métodos extraídos a formatcompactedcomparison y he modificado el sentido de la expresión shouldnotbecompacted . es algo habitual. a menudo, un cambio de refactorización lleva a otro que a su vez lleva a deshacer el primero. la refactorización es un proceso iterativo de ensayo y error, e inevitablemente converge en algo que consideramos digno de un profesional. conclusión hemos cumplido la regla del boy scout. hemos dejado este módulo más limpio de como lo encontramos. no es que no estuviera limpio originalmente, ya que el trabajo de sus autores es excelente, pero cualquier módulo se puede mejorar y es nuestra responsabilidad dejar el código más limpio de lo que lo encontramos. 33616 refactorización de serialdate si visita http://www.jfree.org/jcommon/index.php , encontrará la biblioteca jcommon. en su interior incluye el paquete org.jfree.date y, dentro de éste, la clase serialdate . vamos a analizar esta clase. el autor de serialdate es david gilbert. david es un programador experimentado y competente. como veremos, muestra un elevado grado de profesionalidad y disciplina en su código. en lo que a éste respecta, se puede 337considerar de calidad. y voy a despedazarlo. no es un acto de malicia, ni tampoco me creo mejor que david y con el derecho de juzgar su código. de hecho, si leyera algún código que he creado, seguramente tendría que objetar muchos aspectos del mismo. no es un acto de arrogancia. lo que voy a hacer no es más que una revisión profesional, algo con lo que todos deberíamos sentirnos cómodos y algo que deberíamos agradecer si alguien lo hace. a través de las críticas es como podemos aprender, como hacen médicos, pilotos o abogados. y nosotros, como programadores, también tenemos que aprender a hacerlo. otra cosa más sobre david gilbert: es más que un buen programador. david ha tenido el valor y la buena voluntad de ofrecer este código al público gratuitamente, para que cualquiera pueda usarlo y examinarlo. ¡bien hecho! serialdate (véase el listado b-1) es una clase que representa una fecha en java. ¿para qué se necesita una clase que represente una fecha si java ya cuenta con java.util.date y java.util.calendar , entre otras? el autor creó esta clase como respuesta a un problema que yo también he padecido. el comentario de su javadoc inicial (línea 67) lo explica. podríamos cuestionar su intención, pero yo también he sufrido este problema y se agradece una clase sobre fechas en lugar de horas. primero, conseguir que funcione hay varias pruebas de unidad en la clase serialdatetests (véase el listado b-2). todas son satisfactorias. desafortunadamente, un rápido examen demuestra que no comprueban todos los aspectos [t1]. por ejemplo, al realizar una búsqueda de usos en el método monthcodetoquarter (línea 334) se indica que no se usa [f4]. por lo tanto, las pruebas de unidad no lo comprueban. por ello, recurrí a clover para ver el alcance de las pruebas de unidad. clover indicó que las pruebas sólo ejecutan 91 de las 185 instrucciones ejecutables de serialdate (aproximadamente el 50 por 100) [t2]. el mapa de alcance muestra grandes fragmentos de código sin ejecutar desperdigados por la clase. mi objetivo era comprender la clase y refactorizarla, algo que no podía 338lograr sin una cobertura mayor de las pruebas. por ello diseñé mi propia suite de pruebas de unidad independientes (véase el listado b-4). si se fija en las pruebas, comprobará que muchas están comentadas, ya que no se superaron. representan un comportamiento que considero debería incluirse en serialdate . por tanto, al refactorizar serialdate , intentaré que estas pruebas funcionen. incluso con algunas de las pruebas comentadas, el informe de clover indica que ahora ejecutan 170 (el 92 por ciento) de las 185 instrucciones ejecutables. un gran resultado que creo que puedo mejorar. las primeras pruebas comentadas (líneas 23-63) son un tanto pretenciosas. el programa no fue diseñado para superar estas pruebas, pero el comportamiento me parecía evidente [g2]. desconozco por qué se ha creado el método testweekdaycodetostring pero ya que está ahí, parece obvio que no debe distinguir entre mayúsculas y minúsculas. el diseño de las pruebas fue sencillo [t3] y más todavía que fueran satisfactorias; simplemente cambié las líneas 259 y 263 para usar equalsignorecase . comenté las pruebas de las líneas 32 y 45 ya que no estaba seguro de si las abreviaturas tues y thurs se admitían o no. las pruebas de las líneas 153 y 154 no se superaron, aunque deberían haberlo hecho [g2]. podemos corregirlas, junto a las pruebas de las líneas 163 a la 213, si realizamos los siguientes cambios en la función stringtomonthcode . 457 if ((result < 1) || (result > 12)) { result = -1; 458 for (int i = 0; i < monthnames.length; i++) { 459 if (s.equalsignorecase(shortmonthnames[i])) { 460 result = i + 1; 461 break; 462 } 463 if (s.equalsignorecase(monthnames[i])) { 464 result = i + 1; 465 break; 466 } 467 } 468 } la prueba comentada de la línea 318 descubre un error en el método getfollowingdayofweek (línea 672). el 25 de diciembre de 2004 fue sábado y el siguiente sábado fue el 1 de enero de 2005. sin embargo, al ejecutar la 339prueba, vemos que getfollowingdayofweek devuelve el 25 de diciembre como siguiente sábado después del 25 de diciembre, un error evidente [g3], [t1]. vemos el problema en la línea 685. es un error de condición de límite típico [t5]. debería ser lo siguiente: 685 if (basedow >= targetweekday) { conviene destacar que esta función sufrió una reparación anterior. el historial de cambios (línea 43) muestra que se corrigieron los errores en getpreviousdayofweek , getfollowingdayofweek y getnearestdayofweek [t6]. la prueba de unidad testgetnearestdayofweek (línea 329), que prueba el método getnearestdayofweek (línea 705), inicialmente no era tan extensa y completa. añadí multitud de casos de prueba ya que los iniciales no se superaban [t6]. puede ver el patrón de fallos si se fija en los casos de prueba comentados. el patrón es revelador [t7]. muestra que el algoritmo falla si el día más próximo es de una fecha futura. evidentemente se trata de algún tipo de error de condición de límite [t5]. el patrón de alcance de las pruebas generado por clover también es interesante [t8]. la línea 719 nunca se ejecuta, lo que significa que la instrucción if de la línea 718 siempre es false , pero si nos fijamos en el código, indica que debe ser true . la variable adjust siempre es negativa y no puede ser mayor o igual a 4, por lo que el algoritmo es incorrecto. a continuación se muestra el algoritmo correcto: int delta = targetdow - base.getdayofweek(); int positivedelta = delta + 7; int adjust = positivedelta % 7; if (adjust > 3) adjust -= 7; return serialdate.adddays (adjust, base); por último, las pruebas de la líneas 417 y 429 se pueden superar si se genera illegalargumentexception en lugar de devolver una cadena de error desde weekinmonthtostring y relativetostring . con estos cambios, todas las pruebas de unidad se superan y creo que ahora serialdate funciona. llega el momento de hacer que sea correcta. 340hacer que sea correcta describiremos serialdate de arriba a abajo para mejorarla en nuestro recorrido. aunque no lo veamos en este análisis, ejecutaré todas las pruebas de unidad de jcommon , incluida mi prueba de unidad mejorada para serialdate , con todos los cambios efectuados. por ello, tenga la seguridad de que todos los cambios que vea funcionan para jcommon . en la línea 1 vemos abundantes comentarios sobre información de licencia, derechos de autor, autores e historial de cambios. asumo que hay ciertos aspectos legales que mostrar, por lo que los derechos de autor y las licencias deben conservarse. por otra parte, el historial de cambios es una rémora de la década de 1960. ahora tenemos herramientas de control de código fuente que se encargan de ello. hay que eliminar este historial [c1]. la lista de importación que comienza en la línea 61 se puede reducir por medio de java.text.* y java.util.* . [j1] no me convence el formato html del javadoc (línea 67). un archivo fuente con más de un lenguaje me parece un problema. este comentario tiene cuatro lenguajes: java, español, javadoc y html [g1]. con tantos lenguajes se hace difícil mantener la coherencia. por ejemplo, la ubicación de las líneas 71 y 72 se pierde al generar el javadoc y además, ¿quién quiere ver <ul> y <li> en el código fuente? una estrategia más acertada consiste en rodear el comentario con <pre> para que el formato del código fuente se conserve en el javadoc [96] . la línea 86 es la declaración de la clase. ¿por qué se le asigna el nombre serialdate ? ¿qué sentido tiene la palabra serial ? ¿es porque la clase se deriva de serializable ? parece improbable. basta de adivinanzas. sé por qué (o al menos eso creo) se usa la palabra serial . la clave se encuentra en las constantes serial_lower_bound y serial_upper_bound de las líneas 98 y 101. y una clave todavía mejor es el comentario de la línea 830. el nombre de la clase es serialdate ya que se implementa con un número de serie, que parece ser el número de días desde el 30 de diciembre de 1899. 341pero esto supone un problema. por un lado, el término «número de serie» no es realmente correcto. puede ser un detalle menor pero la representación es más un desplazamiento relativo que un número de serie. el término «número de serie» tiene que ver más con marcadores de identificación de productos que con fechas. por ello, no lo considero especialmente descriptivo [n1]. un término más descriptivo sería «ordinal». el segundo problema es más significativo. el nombre serialdate implica una implementación. esta clase es abstracta. no es necesario que implique nada sobre la implementación; de hecho, es aconsejable ocultarla. por ello, creo que el nombre se encuentra en un nivel de abstracción incorrecto [n2]. en mi opinión, el nombre de esta clase debería ser simplemente date . desafortunadamente, hay demasiadas clases con el nombre date en la biblioteca de java, de modo que no es el más adecuado. como esta clase trabaja con días y no horas, podríamos usar day , pero ya se usa en otros muchos puntos. al final, opté por daydate como mejor opción. a partir de ahora, usaremos daydate . recuerde que los listados que va a leer siguen usando serialdate . entiendo porque daydate se hereda de comparable y serializable . ¿pero de monthconstants ? la clase monthconstants (véase el listado b-3) es una serie de constantes finales estáticas que definen los meses. heredar de clases con constantes es un viejo truco que los programadores de java usan para evitar expresiones como monthconstants.january , pero es una mala idea [j2]. monthconstants debería ser una enumeración. public abstract class daydate implements comparable, serializable { public static enum month { january(1), february(2), march(3), april(4), may(5), june(6), july(7), august(8), september(9), october(10), november(11), december(12); 342month(int index) { this.index = index; } public static month make(int monthindex) { for (month m : month.values()) { if (m.index == monthindex) return m; } throw new illegalargumentexception(“invalid month index ” + monthindex); } public final int index; } al cambiar monthconstants por esta enumeración se modifica la clase daydate y todos sus usuarios. tardé una hora en realizar todos los cambios. sin embargo, las funciones que antes aceptaban un valor int para el mes, ahora aceptan un enumerador month . esto significa que podemos deshacernos del método isvalidmonthcode (línea 326) y de la comprobación de errores del código de los meses como en monthcodetoquarter (línea 356) [g5]. tras ello, en la línea 91, tenemos serialversionuid . esta variable se usa para controlar el señalizador. si la cambiamos, con lo que todos los elementos daydate escritos con una versión antigua del software serán ilegibles y se generará invalidclassexception . si no declara la variable serialversionuid , el compilador genera una automáticamente y será diferente cada vez que modifique el módulo. ya sé que todos los documentos recomiendan el control manual de esta variable, pero creo que el control automático de la señalización es más seguro [g4]. después de todo, prefiero depurar una invalidclassexception que el extraño comportamiento que se produciría si me olvido de cambiar serialversionuid . por ello, eliminaré la variable, al menos por ahora [97] . creo que el comentario de la línea 93 es redundante. los comentarios redundantes sólo sirven para acumular mentiras y desinformación [c2]. por ello los eliminaré. los comentarios de las líneas 97 y 100 hablan sobre números de serie, que ya hemos mencionado antes [c1]. las variables que describen son la primera y última fecha posible que daydate puede describir. podríamos hacer que fuera más claro [n1]. 343public static final int earliest_date_ordinal = 2; // 1/1/1900 public static final int latest_date_ordinal = 2958465; // 12/31/9999 desconozco por qué earliest_date_ordinal es 2 en lugar de 0. el comentario de la línea 829 sugiere que tiene que ver con la forma de representar fechas en microsoft excel. hay información mucho más completa en una variante de daydate : spreadsheetdate (véase el listado b-5). el comentario de la línea 71 describe este problema. el problema parece relacionado con la implementación de spreadsheetdate y no con daydate . mi conclusión es que earliest_date_ordinal y latest_date_ordinal no pertenecen a daydate y deberían cambiarse a spreadsheetdate [g6]. de hecho, una búsqueda en el código demuestra que estas variables sólo se usan en spreadsheetdate . ni en daydate , ni en otras clases de la estructura jcommon. por lo tanto, las cambio por spreadsheetdate . las siguientes variables, minimum_year_supported y maximum_year_supported (líneas 104 y 107), constituyen un dilema. parece evidente que si daydate es una clase abstracta que no dice nada sobre implementación, no debería informarnos de un año mínimo o máximo. de nuevo, siento la necesidad de cambiar las variables a spreadsheetdate [g6]. pero una búsqueda rápida de los usuarios de estas variables muestra que otra clase las utiliza: relativedayofweekrule (véase el listado b-6), vemos dicho uso en las líneas 177 y 178, en la función getdate , donde se usan para comprobar que el argumento de getdate sea un año válido. el dilema es que un usuario de una clase abstracta necesita información sobre su implementación. tendremos que proporcionar esta información sin contaminar daydate . por lo general, obtendríamos la información de implementación de una instancia de una variante. sin embargo, la función getdate no recibe una instancia de daydate , aunque sí la devuelve, lo que significa que debe crearla en alguna parte. la solución está en las líneas 187-205. la instancia daydate se crea por medio de una de estas tres funciones: getpreviousdayofweek , getnearestdayofweek o getfollowingdayofweek . si nos fijamos en el 344listado daydate , vemos que estas funciones (líneas 638-724) devuelven una fecha creada por adddays (línea 571), que invoca createinstance (línea 808), que crea spreadsheetdate [g7]. no es recomendable que las clases base conozcan sus variantes. para corregirlo, debemos usar el patrón de factoría abstracta [98] y crear daydatefactory . esta factoría creará las instancias de daydate que necesitamos y también responderá a preguntas sobre la implementación, como las fechas máxima y mínima. public abstract class daydatefactory { private static daydatefactory factory = new spreadsheetdatefactory(); public static void set instance(daydatefactory factory) { daydatefactory.factory = factory; } protected abstract daydate _makedate(int ordinal); protected abstract daydate _makedate(int day, daydate.month month, int year); protected abstract daydate _makedate(int day, int month, int year); protected abstract daydate _makedate(java.util.date date); protected abstract int _getminimumyear(); protected abstract int _getmaximumyear(); public static daydate makedate(int ordinal) { return factory._makedate(ordinal); } public static daydate makedate(int day, daydate.month month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(int day, int month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(java.util.date date) { return factory._makedate(date); } public static int getminimumyear() { return factory._getminimumyear(); } public static int getmaximumyear() { return factory._getmaximumyear(); } } esta clase de factoría sustituye los métodos createinstance por métodos 345makedate , lo que mejora ligeramente los nombres [n1]. de forma predeterminada es spreadsheetdatefactory pero se puede cambiar por otra factoría. los métodos estáticos delegados en métodos abstractos usan una combinación de los patrones de instancia única [99] , decorador [100] y factoría abstracta que considero muy útil. spreadsheetdatefactory tiene este aspecto: public class spreadsheetdatefactory extends daydatefactory { public daydate _makedate(int ordinal) { return new spreadsheetdate(ordinal); } public daydate _makedate(int day, daydate.month month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(int day, int month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(date date) { final gregoriancalendar calendar = new gregoriancalendar(); calendar.settime(date); return new spreadsheetdate( calendar.get(calendar.date), daydate.month.make(calendar.get(calendar.month) + 1), calendar.get(calendar.year)); } protected int _getminimumyear() { return spreadsheetdate.minimum_year_supported; } protected int _getmaximumyear() { return spreadsheetdate.maximum_year_supported; } } como puede apreciar, hemos enviado las variables minimum_year_supported y maximum_year_supported a spreadsheetdate , donde pertenecen [g6]. el siguiente problema de daydate son las constantes de días, comenzando en la línea 109. deberían ser otra enumeración [j3]. ya hemos visto este patrón, de modo que no lo repetiremos. se incluye en los listados definitivos. seguidamente, vemos una serie de tablas que comienzan en last_day_of_month (línea 140). el primer problema con estas tablas es que 346los comentarios que las describen son redundantes [c3]. basta con sus nombres, de modo que eliminamos los comentarios. no hay motivos para que la tabla no sea privada [g8], ya que existe una función estática lastdayofmonth que proporciona los mismos datos. la siguiente tabla, aggregate_days_to_end_of_month , es más misteriosa, ya que no se usa en ninguna parte de la estructura jcommon [g9], de modo que la elimino. lo mismo sucede con leap_year_aggregate_days_to_end_of_month . la siguiente tabla, aggregate_days_to_end_of_preceding_month , sólo se usa en spreadsheetdate (líneas 434 y 473), lo que me hace dudar si transferirla a spreadsheetdate . la razón de no cambiarla es que la tabla no es específica de ninguna implementación concreta [g6]. por otra parte, sólo existe la implementación spreadsheetdate , de modo que la tabla debe acercarse a donde se vaya a usar [g10], para zanjar la duda y ser coherentes [g11], deberíamos privatizar la tabla y mostrarla a través de una función como juliandateoflastdayofmonth . pero nadie parece que la necesita. es más, la tabla se puede cambiar a daydate si una nueva implementación de daydate la necesita. así que la cambiamos. lo mismo sucede con leap_year_aggregate_days_to_end_of_month . tras ello, vemos tres grupos de constantes que se pueden convertir en enumeraciones (líneas 162-205). la primera selecciona una semana de un mes. la transformo en la enumeración weekinmonth . public enum weekinmonth { first(1), second(2), third(3), fourth(4), last(0); public final int index; weekinmonth(int index) { this.index = index; } } el segundo grupo de constantes (líneas 177-187) es más complicado. las constantes include_none, include_first, include_second e include_both se usan para describir si las fechas finales de un intervalo deben incluirse en el mismo. matemáticamente, se describe como intervalo 347abierto, intervalo a medio abrir e intervalo cerrado. creo que resulta más claro con la nomenclatura matemática [n3], de modo que lo cambio por la enumeración dateinterval con los enumeradores closed, closed_left, closed_right y open . el tercer grupo de constantes (líneas 18-205) describen si la búsqueda de un día concreto de la semana devuelve la última instancia, la siguiente o la más próxima. decidir un nombre adecuado es complicado. al final, opté por weekdayrange con los enumeradores last, next y nearest . puede que no esté de acuerdo con los nombres elegidos. para mí tienen sentido. lo importante es que ahora son más fáciles de cambiar [j3]. ya no se pasan como enteros, sino como símbolos. puedo usar la función de cambio de nombre de mi ide para cambiar los nombres o los tipos sin preocuparme de haberme olvidado de un -1 o un 2 en alguna parte del código o de que la declaración de un argumento int no estén bien descrita. el campo de descripción de la línea 208 no parece que se use en ninguna parte. lo elimino junto a sus elementos de acceso y mutación [g9]. también elimino el constructor predeterminado de la línea 213 [g12]. el compilador se encargará de generarlo. podemos ignorar el método isvalidweekdaycode (líneas 216-238) ya que lo eliminamos al crear la enumeración day . llegamos al método stringtoweekdaycode (líneas 242-270). los javadoc que no suponen demasiado para la firma del método sobran [c3], [g12]. el único valor de este javadoc es la descripción del valor devuelto -1 . sin embargo, como cambiamos a la enumeración day , el comentario es en realidad incorrecto [c2]. ahora el método genera illegalargumentexception . por ello, eliminamos el javadoc. también elimino las palabras clave final de argumentos y declaraciones de variables, ya que no parecen servir de mucho [g12]. la eliminación de final no goza de gran aceptación. por ejemplo, robert simmons [101] recomienda «… diseminar final por la totalidad del código». no estoy de acuerdo. creo que existen casos para usar final , por ejemplo como constante ocasional, pero en general, esta palabra clave apenas añade valor y suele ser 348un estorbo. puede que lo piense porque el tipo de errores que puede capturar final ya se capturan en las pruebas de unidad que he creado. las instrucciones if duplicadas [g5] del bucle for (líneas 259 y 263) son irrelevantes, de modo que las conecté en una única instrucción if con el operador || . también usé la enumeración day para dirigir el bucle for y realicé otros cambios estéticos. este método no pertenece realmente a daydate . en realidad es la función de análisis de day . por lo tanto, lo cambié a la enumeración day , lo que hizo que aumentara considerablemente de tamaño. como el concepto de day no depende de daydate , extraje la enumeración day de la clase daydate a un archivo propio [g13]. también cambié la siguiente función, weekdaycodetostring (líneas 272-286) a la enumeración day y le asigné el nombre tostring . public enum day { monday(calendar.monday), tuesday(calendar.tuesday), wednesday(calendar.wednesday), thursday(calendar.thursday), friday(calendar.friday), saturday(calendar.saturday), sunday(calendar.sunday); public final int index; private static dateformatsymbols datesymbols = new dateformatsymbols(); day(int day) { index = day; } public static day make(int index) throws illegalargumentexception { for (day d : day.values()) if (d.index == index) return d; throw new illegalargumentexception( string.format(“illegal day index: %d.”, index)); } public static day parse(string s) throws illegalargumentexception { string[] shortweekdaynames = datesymbols.getshortweekdays(); string[] weekdaynames = datesymbols.getweekdays(); s = s.trim(); for (day day : day.values()) { 349if (s.equalsignorecase(shortweekdaynames[day.index]) || s.equalsignorecase(weekdaynames[day.index])) { return day; } } throw new illegalargumentexception( string.format(“%s is not a valid weekday string”, s)); } public string tostring() { return datesymbols.getweekdays()[index]; } } hay dos funciones getmonths (líneas 288-316). la primera invoca la segunda. la segunda solamente se invoca desde la primera. por ello, las he combinado en una y las he simplificado considerablemente [g9], [g12], [f4]. por último, he cambiado el nombre por otro más descriptivo [n1]. public static string[] getmonthnames() { return dateformatsymbols.getmonths(); } la función isvalidmonthcode (líneas 326-346) es ahora irrelevante gracias a la enumeración month , de modo que la elimino [g9]. la función monthcodetoquarter (líneas 356-375) parece sufrir envidia de las características [102] [g14] y seguramente pertenezca a la enumeración month como método quarter , motivo por el que la sustituyo. public int quarter() { return 1 + (index-1)/3; } de este modo, la enumeración month tiene tamaño suficiente como para estar en una clase propia. la extraigo de daydate para mantener la coherencia con la enumeración day [g11], [g13]. los dos siguientes métodos tienen el nombre monthcodetostring (líneas 377-426). vemos de nuevo que uno invoca al otro con un indicador. no es recomendable pasar un indicador como argumento de una función, en especial si dicho indicador sólo selecciona el formato del resultado [g15]. por tanto, cambio de nombre, simplifico y reestructuro estas funciones y las incluyo en la enumeración month [n1], [n3], [c3], [g14]. public string tostring() { return dateformatsymbols.getmonths()[index - 1]; 350} public string toshortstring() { return dateformatsymbols.getshortmonths()[index – 1]; } el siguiente método es stringtomonthcode (líneas 428-472). lo cambio de nombre, lo paso a la enumeración month y lo simplifico [n1], [n3], [c3], [g14], [g12]. public static month parse(string s) { s = s.trim(); for (month m : month.values()) if (m.matches(s)) return m; try { return make(integer.parseint(s)); } catch (numberformatexception e) {} throw new illegalargumentexception(“invalid month ” + s); } private boolean matches(string a) { return s.equalsignorecase(tostring()) || s.equalsignorecase(toshortstring()); } el método isleapyear (líneas 495-517) se puede modificar para que sea más expresivo [g16]. public static boolean isleapyear(int year) { boolean fourth = year % 4 == 0; boolean hundredth = year % 100 == 0; boolean fourhundredth = year % 400 == 0; return fourth && (!hundredth || fourhundredth); } la siguiente función, leapyearcount (líneas 519-536) no pertenece realmente a daydate . nadie la invoca, excepto los dos métodos de spreadsheetdate , de modo que la desplazo hacia abajo [g6]. la función lastdayofmonth (líneas 538-560) usa la matriz last_day_of_month , que en realidad pertenece a la enumeración month [g17], por lo que la cambio de ubicación. también simplifico la función y aumento su expresividad [g16]. public static int lastdayofmonth(month month, int year) { if (month == month.february && isleapyear(year)) return month.lastday() + 1; else 351return month.lastday(); } ahora empieza a ponerse interesante. la siguiente función es adddays (líneas 562-576). en primer lugar, como opera en las variables de daydate , no debería ser estática [g18]. la cambio por un método de instancia. por otra parte, invoca la función toserial , cuyo nombre deberíamos cambiar por toordinal [n1]. por último, el método se puede simplificar. public daydate adddays(int days) { return daydatefactory.makedate(toordinal() + days); } lo mismo sucede con addmonths (líneas 578-602). debería ser un método de instancia [g18]. el algoritmo es un tanto complicado, de modo que recurro a la explicación de variables temporales [103] [g19] para que sea más transparente. también cambio el nombre del método getyyy por getyear [n1]. public daydate addmonths(int months) { int thismonthasordinal = 12 * getyear() + getmonth().index - 1; int resultmonthasordinal = thismonthasordinal + months; int resultyear = resultmonthasordinal / 12; month resultmonth = month.make(resultmonthasordinal % 12 + 1); int lastdayofresultmonth = lastdayofmonth(resultmonth, resultyear); int resultday = math.min(getdayofmonth(), lastdayofresultmonth); return daydatefactory.makedate(resultday, resultmonth, resultyear); } la función addyears (líneas 604-626) es similar al resto. public daydate plusyears(int years) { int resultyear = getyear() + years; int lastdayofmonthinresultyear = lastdayofmonth(getmonth(), resultyear); int resultday = math.min(getdayofmonth(), lastdayofmonthinresultyear); return daydatefactory.makedate(resultday, getmonth(), resultyear); } hay algo que me preocupa sobre el cambio de estos métodos de estáticos a métodos de instancia. ¿la expresión date.adddays(5) aclara que el objeto date no cambia y que se devuelve una nueva instancia de daydate o se supone, equivocadamente, que se añaden cinco días al objeto date ? pensará que no es un gran problema, pero un fragmento de código como el siguiente puede ser muy engañoso [g20]. daydate date = datefactory.makedate(5, month.december, 1952); date.adddays(7); // desplazar la fecha una semana 352un lector de este código podría aceptar que adddays cambia el objeto date , de modo que necesitamos un nombre que acabe con la ambigüedad [n4]: plusdays y plusmonths . creo que la intención del método se captura correctamente por medio de daydate date = olddate.plusdays(5); mientras que el siguiente no transmite con fluidez al lector que el objeto date ha cambiado: date.plusdays(5); los algoritmos son cada vez más interesantes. getpreviousdayofweek (líneas 628-660) funciona pero es complicado. tras meditar en lo que sucedía [g21], pude simplificarlo y aplicar la explicación de variables temporales [g19] para aclarar su significado. también lo cambié de método estático a método de instancia [g18] y me deshice del método de instancia duplicado [g5] (líneas 997-1008). public daydate getpreviousdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index = getdayofweek().index; if (offsettotarget >= 0) offsettotarget - 7; return plusdays(offsettotarget); } sucede exactamente lo mismo con getfollowingdayofweek (líneas 662-693). public daydate getfollowingdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index - getdayofweek().index; if (offsettotarget <= 0) offsettotarget += 7; return plusdays(offsettotarget); } la siguiente función es getnearestdayofweek (líneas 695-726), que corregimos en un apartado anterior. pero esos cambios no son coherentes con el patrón actual de las dos últimas funciones [g11]. por ello, recurro a la explicación de variables temporales [g19] para aclarar el algoritmo. public daydate getnearestdayofweek(final day targetday) { int offsettothisweekstarget = targetday.index - getdayofweek().index; int offsettofuturetarget = (offsettothisweekstarget + 7) % 7; int offsettoprevioustarget = offsettofuturetarget - 7; if (offsettofuturetarget > 3) 353return plusdays(offsettoprevioustarget); else return plusdays(offsettofuturetarget); } el método getendofcurrentmonth (líneas 728-740) es un tanto extraño ya que es un método de instancia que envidia [g14] a su propia clase aceptado un argumento daydate . lo convierto en un verdadero método de instancia y clarifico algunos de los nombres. public daydate getendofmonth() { month month = getmonth(); int year = getyear(); int lastday = lastdayofmonth(month, year); return daydatefactory.makedate(lastday, month, year); } la refactorización de weekinmonthtostring (líneas 742-761) resultó ser muy interesante. mediante las herramientas de refactorización de mi ide, primero cambié el método a la enumeración weekinmonth creada antes y después cambié el nombre por tostring . tras ello, lo convertí en método de instancia. todas las pruebas fueron correctas (¿adivina hacia dónde nos dirigimos?). seguidamente, eliminé el método. fallaron cinco afirmaciones (líneas 411-415 del listado b-4). cambié estas líneas para usar los nombres de los enumeradores ( first , second , etc.). las pruebas fueron correctas. ¿ve por qué? ¿puede ver también por qué son necesarios estos pasos? la herramienta de refactorización se encargó de que los invocadores anteriores de weekinmonthtostring invocaran ahora tostring en el enumerador weekinmonth ya que todos los enumeradores implementan tostring para devolver sus nombres… desafortunadamente, me pasé de listo. a pesar de la elegancia de la cadena de refactorización, comprobé que los únicos usuarios de esta función eran las pruebas que acababa de modificar, de modo que las eliminé. así pues, tras determinar que sólo las pruebas invocaban relativetostring (líneas 765-781), eliminé directamente la función y sus pruebas. hemos llegado a los métodos abstractos de esta clase abstracta. y el primero es toserial (líneas 838-844). en un apartado anterior cambié el nombre por toordinal . al verlo en este contexto, decidí que el cambio de 354nombre debería ser por getordinalday . el siguiente método abstracto es todate (líneas 838-844). convierte daydate en java.util.date . ¿por qué es abstracto? si analizamos su implementación en spreadsheetdate (líneas 198-207 del listado b-5), vemos que no depende de la implementación de esa clase [g6]. por tanto, lo desplazo hacia arriba. los métodos getyyyy , getmonth y getdayofmonth son evidentemente abstractos. sin embargo, getdayofweek debería ascender desde spreadsheetdate ya que no depende de nada de lo que encontremos en daydate [g6]. ¿o sí? si se fija atentamente (línea 247 del listado b-5), verá que el algoritmo depende implícitamente del origen del día ordinal (es decir, el día de la semana del día 0). por ello, aunque esta función carezca de dependencias físicas que no se puedan cambiar a daydate , cuenta con una dependencia lógica. este tipo de dependencias lógicas me molestan [g22]. si algo lógico depende de la implementación, también debería haber algo físico. además, me parece que el propio algoritmo podría ser genérico y que debería depender en menor medida de la implementación [g6]. por tanto, creé un método abstracto en daydate con el nombre getdayofweekforordinalzero y lo implementé en spreadsheetdate para devolver day.saturday . tras ello, envié el método getdayofweek a daydate y lo cambié para que invocara getordinalday y getdayofweekforordinalzero . public day getdayofweek() { day startingday = getdayofweekforordinalzero(); int startingoffset = startingday.index - day.sunday.index; return day.make((getordinalday() + startingoffset) % 7 + 1); } fíjese en el comentario de las líneas 895-899. ¿necesitamos realmente esta repetición? como de costumbre, eliminé este comentario junto a los demás. el siguiente método es compare (líneas 902-913). de nuevo, es incorrectamente abstracto [g6], por lo que cambio la implementación a daydate . además, el nombre no es descriptivo [n1]. en realidad, este método devuelve la diferencia en días desde el argumento, por lo que cambié el nombre por dayssince . tampoco existían pruebas para este método, de 355modo que las creé. las seis siguientes funciones (líneas 915-980) son métodos abstractos que deben implementarse en daydate , por lo que las extraje de spreadsheetdate . la última función, isinrange (líneas 982-995), también debe extraerse y refactorizarse. la instrucción switch no es agradable [g23] y se puede modificar si enviamos los casos a la enumeración dateinterval . public enum dateinterval { open { public boolean isin(int d, int left, int right) { return d > left && d < right; } }, closed_left { public boolean isin(int d, int left, int right) { return d >= left && d < right; } }, closed_right { public boolean isin(int d, int left, int right) { return d > left && d <= right; } }, closed { public boolean isin(int d, int left, int right) { return d >= left && d <= right; } }; public abstract boolean isin(int d, int left, int right); } public boolean isinrange(daydate d1, daydate d2, dateinterval interval) { int left = math.min(d1.getordinalday(), d2.getordinalday()); int right = math.max(d1.getordinalday(), d2.getordinalday()); return interval.isin(getordinalday(), left, right); } con esto llegamos al final de daydate . realizaremos una nueva pasada por la clase completa para comprobar cómo fluye. primero, el comentario inicial está desfasado, de modo que lo reduzco y lo mejoro [c2]. tras ello, desplazo las enumeraciones restantes a sus propios archivos [g12]. seguidamente, desplazo la variable estática ( dateformatsymbols ) y tres métodos estáticos ( getmonthnames , isleapyear , lastdayofmonth ) a una nueva clase con el nombre dateutil [g6]. 356cambio los métodos abstractos a una posición superior, donde pertenecen [g24]. cambio month.make por month.fromint [n1] y repito la operación con las demás enumeraciones. también creo un método de acceso toint() para todas las enumeraciones y convierto en privado el campo index . se produce una interesante duplicación [g5] en plusyears y plusmonths que conseguí eliminar extrayendo un nuevo método con el nombre correctlastdayofmonth , lo que aclaraba el significado de los tres métodos. me deshice del número mágico 1 [g25] y lo sustituí por month.january.toint() o day.sunday.toint() , según el caso. me detuve en limpiar los algoritmos de spreadsheetdate . el resultado final se puede comprobar en los listados b.7 a b.16. el alcance del código en daydate se ha reducido al 84.9 por 100, no porque se pruebe una cantidad menor de funcionalidad, sino porque la clase se ha reducido tanto que las líneas sin alcance tienen un peso mayor. ahora, en daydate las pruebas se aplican a 45 de las 53 instrucciones ejecutables. las líneas sin alcance son tan triviales que no merece la pena probarlas. conclusión otra vez hemos aplicado la regla del boy scout. hemos entregado el código más limpio de lo que lo recibimos. nos ha llevado tiempo, pero ha merecido la pena. el alcance de las pruebas ha aumentado, hemos corregido algunos errores y hemos aclarado y reducido el tamaño del código. la próxima persona que lo lea seguramente lo encontrará más fácil de leer. y probablemente esa persona sea capaz de limpiarlo algo más de lo que hemos hecho nosotros. bibliografía [gof] : design patterns: elements of reusable object oriented 357software , gamma et al., addison-wesley, 1996. [simmons04] : hardcore java , robert simmons, jr., o’reilly, 2004. [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. [beck97] : smalltalk best practice patterns , kent beck, prentice hall, 1997. 35817 síntomas y heurística en su magnífico libro refactoring [104] , martin fowler identifica diversos síntomas de código ( smells ). la lista que mostramos a continuación incluye muchos de los síntomas de martin y otros propios. también contiene otras perlas y heurística que suelo emplear en mi trabajo. 359para compilar esta lista he examinado diversos programas y los he refactorizado. al aplicar un cambio, me preguntaba el por qué y anotaba el motivo. el resultado es una extensa lista de aspectos que no me «huelen» bien cuando leo código. la lista se debe leer de arriba a abajo, y también se puede usar como referencia. comentarios c1: información inapropiada no es apropiado que un comentario contenga información que se pueda almacenar en otro tipo de sistema como un sistema de control de código fuente, de seguimiento de problemas o de mantenimiento de registros. los historiales de cambios, por ejemplo, abarrotan los archivos de código con abundante texto sin interés alguno. por lo general, metadatos como autores, fechas de modificación, números spr y similares no deben aparecer en los comentarios. los comentarios deben reservarse para notas técnicas sobre el código y el diseño. c2: comentario obsoleto un comentario anticuado, irrelevante e incorrecto es obsoleto. los comentarios envejecen rápidamente. es recomendable no escribir un comentario que vaya a quedar obsoleto. si detecta un comentario obsoleto, conviene actualizarlo o eliminarlo lo antes posible. los comentarios obsoletos tienden a alejarse del código que describían. se convierten en islas de irrelevancia y desorientación en el código. c3: comentario redundante un comentario es redundante si describe algo que ya se define correctamente 360por sí mismo. por ejemplo: i++; // incrementar i otro ejemplo es un javadoc que no dice más (o incluso menos) que la firma de una función: /** * @param sellrequest * @return * @throws managedcomponentexception */ public sellresponse beginsellitem(sellrequest sellrequest) throws managedcomponentexception los comentarios deben comunicar lo que el código no pueda expresar por sí mismo. c4: comentario mal escrito un comentario que merezca la pena escribir merece la pena ser leído. si piensa escribir un comentario, asegúrese de que es el mejor que puede crear. elija las palabras con atención. use gramática y puntuación correctas. no divague. no afirme lo evidente. sea breve. c5: código comentado me molesta ver grandes fragmentos de código comentado. ¿quién sabe qué antigüedad tienen? ¿quién sabe si tiene sentido o no? pero nadie lo borra porque piensa que alguien más lo necesita. ese código se estanca y se corrompe, y cada día que pasa es menos relevante. invoca funciones que ya no existen. usa variables cuyos nombres han cambiado. se rige por convenciones obsoletas. contamina los módulos en los que aparece y distrae a los usuarios que lo leen. el código comentado es una aberración. cuando vea código comentado, elimínelo. no se preocupe, el sistema de control de código fuente lo recordará. si alguien lo necesita, puede consultar una versión anterior. no sufra el código comentado para sobrevivir. 361entorno e1: la generación requiere más de un paso la generación de un proyecto debería ser una operación sencilla. no debería tener que comprobar demasiados elementos del control de código fuente. no debería necesitar una secuencia de antiguos comandos ni secuencias de comandos dependientes del contexto para generar cada elemento. no debería tener que buscar los distintos archivos jar, xml y similares necesarios para el sistema. debería finalizar el sistema con un sencillo comando y después ejecutar otro igual de sencillo para generarlo. svn get mysystem cd mysystem ant all e2: las pruebas requieren más de un paso debería poder ejecutar todas las pruebas de unidad con un solo comando. en el mejor de los casos, debería poder ejecutarlas pulsando un botón de su ide. en el peor, debería poder ejecutar un único comando en una línea de comandos. la capacidad de ejecutar todas las pruebas es tan importante que debe ser algo rápido, sencillo y obvio. funciones f1: demasiados argumentos las funciones deben tener un número reducido de argumentos. lo mejor es que no tengan, seguido de uno, dos y tres argumentos. más de tres ya es cuestionable y debería evitarse (véase el capítulo 3). 362f2: argumentos de salida los argumentos de salida son ilógicos. el lector espera que los argumentos sean entradas, no salidas. si su función tiene que cambiar el estado de algo, haga que cambie el estado del objeto en el que se invoca (véase el capítulo 3). f3: argumentos de indicador los argumentos booleanos declaran abiertamente que la función hace más de una cosa. resultan confusos y deben eliminarse (véase el capítulo 3). f4: función muerta los métodos que nunca se invocan deben descartarse. la presencia de código muerto es innecesaria. no tema eliminar la función. su sistema de control de código fuente la recordará. general g1: varios lenguajes en un archivo de código los modernos entornos de programación actuales permiten incluir varios lenguajes diferentes en el mismo archivo de código. por ejemplo, un archivo de java puede contener fragmentos de xml, html, yaml, javadoc, javascript, y similares. además de html, un archivo jsp podría incluir java, sintaxis de biblioteca de etiquetas, comentarios en español, javadoc, xml, javascript, etc. resulta confuso en el mejor de los casos y un desastre en el peor. lo ideal sería que el archivo de código incluyera un solo lenguaje pero, en realidad, seguramente tendremos que usar más de uno. debemos intentar minimizar la cantidad y el alcance de los lenguajes adicionales en nuestros 363archivos de código. g2: comportamiento evidente no implementado de acuerdo al principio de la mínima sorpresa [105] , una función o clase debe implementar los comportamientos que otro programador esperaría. por ejemplo, imagine una función que traduce el nombre de un día en una enumeración que represente dicho día. day day = daydate.stringtoday(string dayname); esperaríamos que la cadena « monday » se tradujera en day.monday. también esperaríamos la traducción de las abreviaturas habituales y que la función ignorara mayúsculas y minúsculas. cuando un comportamiento obvio no se implementa, los lectores y usuarios del código ya no dependen de su intuición sobre los nombres de las funciones. pierden su confianza en el autor original y se ven obligados a leer los detalles del código. g3: comportamiento incorrecto en los límites parece evidente afirmar que el código debe comportarse de forma correcta. el problema es que no nos damos cuenta de lo complicado que es dicho comportamiento correcto. los programadores suelen crear funciones que esperan que funcionen y confían en su intuición más que en comprobar que el código funciona en todos los casos de límites. no existe sustituto para la meticulosidad. las condiciones de límite, los casos extremos, las excepciones, representan algo que puede confundir a un algoritmo elegante e intuitivo. no dependa de su intuición . busque todas las condiciones de límite y cree pruebas para cada una. g4: medidas de seguridad canceladas chernobyl se derritió porque el director de la central ignoró todos y cada uno de los mecanismos de seguridad. impedían que se realizara un experimento. 364el resultado fue que el experimento no salió bien y el mundo fue testigo de la primera gran catástrofe nuclear para la población. anular las medidas de seguridad es un riesgo. puede que sea necesario ejercer el control manual sobre serialversionuid pero siempre es arriesgado. la desactivación de determinadas advertencias del compilador (o de todas) puede ayudarle a conseguir la generación, pero corre el riesgo de sufrir interminables sesiones de depuración. desactivar las pruebas que fallan y convencerse de que conseguirá que después sean satisfactorias es tan erróneo como pensar que sus tarjetas de crédito son dinero gratuito. g5: duplicación una de las reglas más importantes del libro y que debe tomarse muy en serio. la práctica totalidad de los autores que escriben sobre diseño de software mencionan esta regla. dave thomas y andy hunt la denominaron principio dry [106] ( don't repeat yourself , no repetirse). kent beck la convirtió en uno de los principios fundamentales de la programación extreme y la denominó «una sola vez». ron jeffries sitúa esta regla en segunda posición, por debajo de la consecución satisfactoria de todas las pruebas. siempre que vea duplicados en el código, indican una oportunidad de abstracción fallida. la duplicación podría convertirse en una subrutina o en otra clase. al incluir la duplicación en una abstracción, aumenta el vocabulario del lenguaje del diseño. otros programadores pueden usar sus creaciones abstractas. el código se vuelve más rápido y menos proclive a errores ya que ha aumentado el nivel de abstracción. el caso más evidente de duplicación es la presencia de fragmentos de código idéntico que parecen pegados repetidamente por el programador, sin sentido. conviene reemplazarlos por métodos simples. una forma más sutil es la cadena switch/case o if/else que aparece repetidamente en diversos módulos y que siempre prueba las mismas condiciones. conviene reemplazar estas cadenas por polimorfismo. y más sutiles todavía son los módulos con algoritmos similares pero que no comparten las mismas líneas de código. sigue siendo duplicación y debe 365corregirse por medio del patrón de método de plantilla [107] o estrategia [108] . en realidad, la mayoría de patrones de diseño aparecidos en los últimos 15 años son formas de eliminar la duplicación. las formas normales de codd también son una estrategia para eliminar la duplicación en esquemas de base de datos. incluso la programación orientada a objetos es una estrategia para organizar módulos y eliminar la duplicación. no debería sorprenderle, ya que se trata de programación estructurada. creo que el objetivo es evidente: localice los elementos duplicados y elimínelos siempre que pueda. g6: código en un nivel de abstracción incorrecto es importante crear abstracciones que separen conceptos generales de nivel superior de conceptos detallados de nivel inferior. para ello, en ocasiones creamos clases abstractas que contengan los conceptos de nivel superior y variantes los de nivel inferior. si lo hacemos, debemos asegurarnos de que la separación sea completa. todos los conceptos de nivel inferior deben estar en las variantes y los de nivel superior en la clase base. por ejemplo, constantes, variables o funciones de utilidad que solamente pertenezcan a la implementación detallada no deben aparecer en la clase base. la clase base no debe saber nada al respecto de estos elementos. esta regla también se aplica a archivos fuente, componentes y módulos. el diseño correcto de software requiere la separación de conceptos en distintos niveles y su inclusión en contenedores diferentes. en ocasiones, dichos contenedores son clases base o variantes, y en otros casos son archivos fuente, módulos o componentes. independientemente del caso, la separación debe ser completa. no queremos que conceptos de nivel inferior y superior se mezclen. fíjese en este código: public interface stack { object pop() throws emptyexception; void push(object o) throws fullexception; double percentfull(); class emptyexception extends exception {} class fullexception extends exception {} } la función percentfull se encuentra en el nivel de abstracción 366equivocado. aunque hay implementaciones de stack en las que el concepto de amplitud es razonable, otras no pueden conocer su nivel de amplitud. por tanto, la función debería incluirse en una interfaz derivada como boundedstack . pensará que la implementación podría devolver cero si la pila no tuviera límites. el problema es que no existen pilas totalmente sin límites. no se puede evitar outofmemoryexception mediante la comprobación de stack.percentfull() < 50.0. la implementación de esta función para que devuelva 0 sería una mentira. la moraleja es que no puede mentir o escapar de una abstracción mal ubicada. el aislamiento de abstracciones es una de las operaciones más complicadas para los desarrolladores de software y no se puede corregir cuando se realiza de forma incorrecta. g7: clases base que dependen de sus variantes el motivo más habitual para dividir conceptos en clases base y derivadas es para que los conceptos de nivel superior de la clase base sean independientes de los de nivel inferior de las derivadas. por ello, cuando vemos clases base que mencionan los nombres de sus variantes, se intuye un problema. por lo general, las clases base no deben saber nada sobre su derivadas. evidentemente, hay excepciones. en ocasiones, el número de variantes es fijo y la clase base tiene código que elegir entre las variantes. es muy habitual en implementaciones de equipos con estado finito. sin embargo, en ese caso las variantes y la clase base están íntimamente unidas y siempre se implementan en el mismo archivo jar. en el caso general, deben implementarse en archivos independientes. al implementar variantes y clases base en archivos diferentes y garantizar que los archivos de la clase base desconocen el contenido de los archivos de las variantes podemos implementar nuestros sistemas en componentes discretos e independientes. al modificar dichos componentes, se pueden volver a implementar sin necesidad de implementar de nuevo los componentes base. de este modo se reduce significativamente el impacto del 367cambio y se facilita el mantenimiento de los sistemas. g8: exceso de información los módulos bien definidos tienen interfaces reducidas que nos permiten hacer mucho con poco. los módulos definidos de forma incorrecta tienen interfaces más amplias que nos obligan a usar distintos gestos para realizar operaciones sencillas. una interfaz bien definida no ofrece demasiadas funciones y las conexiones son reducidas. una interfaz definida de forma incorrecta ofrece multitud de funciones que invocar y, por tanto, las conexiones son elevadas. los buenos programadores de software aprenden a limitar la parte de sus clases y módulos que muestran en sus interfaces. cuantos menos métodos tenga una clase, mejor. cuantas menos variables conozca una función, mejor. cuantas menos variables de instancia tenga una clase, mejor. oculte sus datos. oculte sus funciones de utilidad. oculte sus constantes y elementos temporales. no cree clases con multitud de métodos y variables de instancia. no cree multitud de variables y funciones protegidas para sus subclases. concéntrese en crear interfaces concisas y de tamaño reducido. limite la información para reducir las conexiones. g9: código muerto el código muerto es el que no se ejecuta. se encuentra en el cuerpo de una instrucción if que comprueba una condición que no sucede. se encuentra en el bloque catch de una instrucción try que carece de throws . se encuentra en pequeños métodos de utilidad que nunca se invocan o en condiciones switch/case inexistentes. el problema del código muerto es que con el tiempo empieza a oler. cuanto más antiguo es, más profundo el hedor que despide. se debe a que el código muerto no se actualiza al cambiar los diseños. sigue compilándose pero no se rige por nuevas convenciones o reglas. se creó en un momento en el que el sistema era diferente . debe tener un entierro digno. bórrelo del 368sistema. g10: separación vertical variables y funciones deben definirse cerca de donde se utilicen. las variables locales deben declararse por encima de su primer uso y deben tener un reducido ámbito vertical. no deben declararse a cientos de líneas de distancia de su uso. las funciones privadas deben definirse justo debajo de su primer uso. pertenecen al ámbito de la clase completa pero conviene limitar la distancia vertical entre las invocaciones y las definiciones. para localizar una función privada debe bastar con buscar debajo de su primer uso. g11: incoherencia si hace algo de una forma concreta, aplique la misma técnica a operaciones similares. esto entronca con el principio de mínima sorpresa. preste atención a las convenciones que elija y, una vez elegidas, asegúrese de mantenerlas. si en una función concreta usa la variable response para almacenar httpservletresponse , use el mismo nombre de variable en las demás funciones que usen objetos httpservletresponse . si asigna el nombre processverificationrequest a un método, use un nombre similar, como processdeletionrequest , para los métodos que procesen otros tipos de solicitudes. este tipo de coherencia, si se aplica repetidamente, facilita la lectura y modificación del código. g12: desorden ¿para qué sirve un constructor predeterminado sin implementación? únicamente desordena el código y lo inunda de elementos sin sentido. variables sin usar, funciones que nunca se invocan, comentarios que no añaden información, etc. todos estos elementos sobran y deben eliminarse. 369mantenga limpios sus archivos, bien organizados y sin elementos sobrantes. g13: conexiones artificiales los elementos que no dependen unos de otros no deben conectarse de forma artificial. por ejemplo, las enumeraciones generales no deben incluirse en clases más específicas ya que esto obliga a la aplicación a saber más sobre dichas clases. lo mismo sucede con funciones static de propósito general declaradas en clases específicas. por lo general, una conexión artificial es la que se establece entre dos módulos sin un propósito directo. es el resultado de incluir una variable, constante o función en una ubicación temporalmente útil pero inadecuada. es un síntoma de falta de atención. piense en dónde debe declarar sus funciones, constantes y variables. no las deje en el punto más cómodo. g14: envidia de las características uno de los síntomas de martin fowler [109] . los métodos de una clase deben interesarse por las variables y funciones de la clase a la que pertenecen, no por las variables y funciones de otras clases. cuando un método usa elementos de acceso y mutación de otro objeto para manipular los datos de éste, envidia el ámbito de la clase de dicho objeto. desea formar parte de la otra clase para tener acceso directo a las variables que manipula. por ejemplo: public class hourlypaycalculator { public money calculateweeklypay(hourlyemployee e) { int tenthrate = e.gettenthrate().getpennies(); int tenthsworked = e.gettenthsworked(); int straighttime = math.min(400, tenthsworked); int overtime = math.max(0, tenthsworked - straighttime); int straightpay = straighttime * tenthrate; int overtimepay = (int)math.round(overtime*tenthrate*1.5); return new money(straightpay + overtimepay); } } el método calculateweeklypay se acerca al objeto hourlyemployee para 370obtener los datos sobre los que opera. el método calculateweeklypay envidia el ámbito de hourlyemployee . su deseo es formar parte de hourlyemployee . es recomendable suprimir la envidia de características ya que muestra los detalles internos de una clase a otra. sin embargo, en ocasiones es un mal necesario. fíjese en lo siguiente: public class hourlyemployeereport { private hourlyemployee employee; public hourlyemployeereport(hourlyemployee e) { this.employee = e; } string reporthours() { return string.format( “name: %s\thours:%d.%1d\n”, employee.getname(), employee.gettenthsworked()/10, employee.gettenthsworked()%10); } } evidentemente, el método reporthours envidia la clase hourlyemployee . por otra parte, no queremos que hourlyemployee tenga que conocer el formato del informe. al incluir la cadena de formato en la clase hourlyemployee incumpliríamos varios de los principios del diseño orientado a objetos [110] . conectaría hourlyemployee al formato del informe y lo mostraría en los cambios de dicho formato. g15: argumentos de selector no hay nada más abominable que un argumento false aislado al final de la invocación de una función. ¿qué significa? ¿qué cambiaría si fuera true ? no sólo el propósito de un argumento de selector es difícil de recordar, sino que cada argumento de selector combina varias funciones en una. los argumentos de selector son una forma indolente de evitar dividir una función de gran tamaño en otras menores. fíjese en lo siguiente: public int calculateweeklypay(boolean overtime) { int tenthrate = gettenthrate(); int tenthsworked = gettenthsworked(); 371int straighttime = math.min(400, tenthsworked); int overtime = math.max(0, tenthsworked - straighttime); int straightpay = straighttime * tenthrate; double overtimerate = overtime ? 1.5 : 1.0 * tenthrate; int overtimepay = (int)math.round(overtime*overtimerate); return straightpay + overtimepay; } esta función se invoca con true si las horas extras se pagan como hora y media, y con false si se pagan como una hora normal. ya es bastante malo tener que recordar lo que significa calculateweeklypay(false) cada vez que aparezca. pero lo peor de esta función es que el autor ha perdido la oportunidad de crear lo siguiente: public int straightpay() { return gettenthsworked() * gettenthrate(); } public int overtimepay() { int overtimetenths = math.max(0, gettenthsworked() - 400); int overtimepay = overtimebonus(overtimetenths); return straightpay() + overtimepay; } private int overtimebonus(int overtimetenths) { double bonus = 0.5 * gettenthrate() * overtimetenths; return (int) math.round(bonus); } evidentemente, los selectores no deben ser boolean . pueden ser enumeraciones, enteros u otro tipo de argumento que se use para seleccionar el comportamiento de la función. es más recomendable tener varias funciones que pasar código a una función para seleccionar el comportamiento. g16: intención desconocida queremos que el código sea lo más expresivo posible. expresiones extensas, notación húngara y números mágicos distorsionan la intención del autor. por ejemplo, veamos la función overtimepay cómo podría haber aparecido: public int m_otcalc() { return ithswkd * ithsrte + (int) math.round(0.5 * ithsrte * math.max(0/ ithswkd - 400) ); } 372aunque parezca reducida y densa, también es prácticamente impenetrable. es recomendable dedicar tiempo a lograr que la intención de nuestro código sea aparente para nuestros lectores. g17: responsabilidad desubicada una de las principales decisiones de un programador de software es dónde ubicar el código. por ejemplo, dónde incluir la constante pi . ¿en la clase math ? ¿pertenece a la clase trigonometry ? ¿o a la clase circle ? el principio de mínima sorpresa vuelve a aparecer. el código debe ubicarse donde el lector espera encontrarlo. la constante pi debe incluirse junto a la declaración de las funciones trigonométricas. la constante overtime_rate debe declararse en la clase hourlypaycalculator . en ocasiones presumimos de dónde añadimos una determinada funcionalidad. incluimos una función porque nos resulta cómodo pero no porque sea intuitivo para el lector. por ejemplo, puede que tengamos que imprimir un informe con el total de horas que ha trabajado un empleado. podríamos sumar las horas en el código que imprime el informe o intentar mantener un total en el código que acepte horarios de trabajo. una forma de tomar esta decisión consiste en analizar el nombre de las funciones. imagine que el módulo del informe tiene la función gettotalhours . imagine también que el módulo que acepta horarios de trabajo tiene la función savetimecard . ¿cuál de las dos, por nombre, implica que calcula el total? la respuesta es evidente. existen motivos de rendimiento para calcular el total como horarios de trabajo y no como informe impreso. es correcto, pero el nombre de las funciones debería reflejarlo. por ejemplo, debería haber una función computerunningtotalofhours en el módulo de horarios. g18: elementos estáticos incorrectos math.max (double a, double b) es un método estático correcto. no opera 373en una única instancia; de hecho, sería un error tener que usar new math().max(a,b) o incluso a.max(b) . todos los datos que usa max provienen de sus dos argumentos, no de un objeto. además, es prácticamente imposible que queramos que math.max sea polimórfico. sin embargo, en ocasiones creamos funciones estáticas que no deben serlo. fíjese en este ejemplo: hourlypaycalculator.calculatepay(employee, overtimerate). de nuevo, parece una función estática razonable. no opera en un objeto concreto y recibe todos los datos de sus argumentos. sin embargo, existe la posibilidad de que queramos que sea polimórfica. puede que queramos implementar distintos algoritmos para calcular el precio de la hora, como por ejemplo. overtimehourlypaycalculator y straighttimehourlypaycalculator . en este caso, la función no debe ser estática. debería ser una función miembro no estática de employee . por lo general, debe decantarse por métodos no estáticos. en caso de duda, convierta la función en no estática. si realmente quiere que una función sea estática, asegúrese de que nunca querrá que sea polimórfica. g19: usar variables explicativas kent beck escribió sobre este tema en su magnífico libro smalltalk best practice patterns [111] y, más recientemente en implementation patterns [112] . una de las técnicas más completas para que un programa sea legible consiste en dividir los cálculos en valores intermedios almacenados en variables con nombres descriptivos. fíjese en este ejemplo de fitnesse: matcher match = headerpattern.matcher(line); if(match.find()) { string key = match.group(1); string value = match.group(2); headers.put(key.tolowercase(), value); } el simple uso de variables explicativas ilustra con claridad que el primer grupo comparado es la clave y el segundo es el valor . es complicado excederse en esta técnica. por lo general, es mejor tener más variables explicativas que menos. es sorprendente que un módulo opaco 374se vuelva más transparente con tan sólo dividir los cálculos en valores intermedios con los nombres adecuados. g20: los nombres de función deben indicar lo que hacen fíjese en este código: date newdate = date.add(5); ¿intuye que se añaden cinco días a la fecha o son semanas u horas? ¿la instancia date cambia y la función simplemente devuelve un nuevo objeto date sin cambiar el antiguo? por la invocación no podemos saber qué hace la función . si la función añade cinco días a la fecha y después la cambia, el nombre debería ser adddaysto o increasebydays . si, por otra parte, la función devuelve una nueva fecha con cinco días más pero no cambia la instancia date , el nombre debería ser dayslater o dayssince . si tiene que fijarse en la implementación (o documentación) de la función para saber qué hace, tendrá que elegir un nombre más apropiado o modificar la funcionalidad para que se pueda incluir en funciones con nombres más acertados. g21: comprender el algoritmo se crea gran cantidad de código extraño porque los autores no se esfuerzan en comprender el algoritmo. consiguen que algo funcione combinando instrucciones if e indicadores sin pararse a pensar en qué sucede realmente. la programación es una tarea de exploración. creemos que conocemos el algoritmo adecuado para algo pero después lo modificamos y variamos hasta conseguir que funcione . ¿cómo sabemos que funciona ? porque supera los casos de prueba que pensamos. no es un enfoque equivocado. de hecho, suele ser la única forma de conseguir que una función haga lo que pensamos que debe hacer. sin 375embargo, no basta con conseguir que funcione . antes de creer que hemos terminado con una función, asegúrese de entender su funcionamiento. no basta con que supere todas las pruebas. tiene que estar seguro [113] de que la solución es la correcta. por lo general, la forma óptima de saberlo consiste en refactorizar la función en algo tan limpio y expresivo que su funcionamiento sea evidente . g22: convertir dependencias lógicas en físicas si un módulo depende de otro, dicha dependencia debe ser física, no sólo lógica. el módulo dependiente no debe asumir aspectos (es decir, dependencias lógicas) sobre el módulo del que depende. por el contrario, debe solicitar de forma explícita al módulo toda la información de la que depende. por ejemplo, imagine que tiene que crear una función que imprima un informe de las horas trabajadas por cada empleado. la clase hourlyreporter recopila los datos y los pasa a hourlyreportformatter para imprimirlos (véase el listado 17-1). listado 17-1 hourlyreporter.java. public class hourlyreporter { private hourlyreportformatter formatter; private list<lineitem> page; private final int page_size = 55; public hourlyreporter(hourlyreportformatter formatter) { this.formatter = formatter; page = new arraylist<lineitem>(); } public void generatereport(list<hourlyemployee> employees) { for (hourlyemployee e : employees) { addlineitemtopage(e); if (page.size() == page_size) printandclearitemlist(); } if (page.size() > 0) printandclearitemlist(); 376} private void printandclearitemlist() { formatter.format(page); page.clear(); } private void addlineitemtopage(hourlyemployee e) { lineitem item = new lineitem(); item.name = e.getname(); item.hours = e.gettenthsworked() / 10; item.tenths = e.gettenthsworked() % 10; page.add(item); } public class lineitem { public string name; public int hours; public int tenths; } } este código tiene una dependencia lógica que no se ha convertido en física. ¿la detecta? es la constante page_size . ¿para qué necesita hourlyreporter saber el tamaño de la página? el tamaño de la página debe ser responsabilidad de hourlyreportformatter . la declaración de page_size en hourlyreporter representa una responsabilidad desubicada [g17] que hace que hourlyreporter asuma que conoce el tamaño que debe tener la página. esta presunción es una dependencia lógica. hourlyreporter depende de que hourlyreportformatter pueda procesar tamaños de página de hasta 55. si alguna implementación de hourlyreportformatter no puede asumir esos tamaños, se producirá un error. podemos convertir en física esta dependencia si creamos un nuevo método en hourlyreportformatter con el nombre getmaxpagesize() . tras ello, hourlyreporter invoca esta función en lugar de usar la constante page_size . g23: polimorfismo antes que if/else o switch/case puede parecer una sugerencia extraña dado el tema descrito en el capítulo 6. en este capítulo, afirmo que las instrucciones switch son adecuadas en partes del sistema en las que se añadan más funciones nuevas que tipos nuevos. 377por un lado, la mayoría usamos instrucciones switch por ser una solución de fuerza bruta evidente, no por ser la solución perfecta. por tanto, esta heurística nos recuerda que debemos considerar el uso de polimorfismo antes de usar switch . por otra parte, los casos en que las funciones son más volátiles que los tipos son escasos. por tanto, toda instrucción switch es sospechosa. suelo aplicar la siguiente regla de una instrucción switch : no puede haber más de una instrucción  switch  por cada tipo de selección. los casos de esa instrucción  switch  deben crear objetos polimórficos que ocupen el lugar de otras instrucciones  switch  similares en el resto del sistema . g24: seguir las convenciones estándar todos los equipos deben seguir un estándar de diseño de código basado en normas comunes de la industria. este estándar debe especificar aspectos como dónde declarar variables de instancia, cómo asignar nombres a clases, métodos y variables, dónde añadir llaves, etc. el equipo no debe necesitar un documento que describa estas convenciones ya que su código proporciona los ejemplos. todos los miembros del equipo deben seguir estas convenciones, lo que significa que no importa dónde añada cada uno las llaves mientras todos estén de acuerdo en dónde añadirlas. si desea saber qué convenciones aplico, puede verlas en el código refactorizado de los listados b.7 a b.14 del apéndice b. g25: sustituir números mágicos por constantes con nombre es probablemente una de las reglas más antiguas del desarrollo de software . recuerdo haberla leído a finales de la década de 1960 en manuales de cobol, fortran y pl/1. por lo general, no es recomendable incluir números sin procesar en el código; debe ocultarlos tras constantes con 378nombres correctos. por ejemplo, el número 86 400 debe ocultarse tras la constante seconds_per_day . si va a imprimir 55 líneas por página, la constante 55 debe ocultarse tras la constante lines_per_page . algunas constantes son tan fáciles de reconocer que no siempre necesitan una constante con nombre tras la que ocultarse mientras se usen junto a código explicativo. por ejemplo: double mileswalked = feetwalked/5280.0; int dailypay = hourlyrate * 8; double circumference = radius * math.pi * 2; ¿necesitamos realmente las constantes feet_per_mile, work_hours_per_day y two en los ejemplos anteriores? el último caso es absurdo. existen ciertas fórmulas en las que las constantes se escriben mejor como números sin procesar. puede cuestionar el caso de work_hours_per_day ya que las leyes o las convenciones pueden cambiar. por otra parte, esa fórmula se lee perfectamente si se incluye el 8 por lo que no es necesario añadir 17 más. en el caso de feet_per_mile , el número 5280 es una constante tan conocida y exclusiva que los lectores la reconocerán aunque se muestre de forma independiente en una página sin contexto alguno. constantes como 3.141592653589793 también son conocidas y reconocibles. sin embargo, la probabilidad de errores es alta y no conviene mostrarlas tal cual. siempre que alguien ve 3.1415927535890793, sabe que es π, y no se molestan en examinarlo (¿ha visto el error de un dígito?). tampoco queremos que la gente use 3.14, 3.14159, 3.142, y similares. por lo tanto, es una suerte contar con math.pi . el término número mágico no sólo se aplica a números, sino a todo símbolo que tenga un valor que no sea descriptivo por sí mismo. por ejemplo: assertequals(7777, employee.find(“john doe”).employeenumber()); en esta afirmación hay dos números mágicos. el primero es obviamente 7777, aunque no significa que no sea obvio. el segundo es « john doe » y su cometido tampoco está claro. “john doe” es el nombre del empleado #7777 en una conocida base de datos de pruebas creada por nuestro equipo. todo el mundo sabe que al 379conectarse a la base de datos, ya cuenta con varios empleados con sus valores y atributos. además, « john doe » representa el único empleado por horas de la base de datos. por tanto, la prueba debería ser la siguiente: assertequals( hourly_employee_id, employee.find(hourly_employee_name).employeenumber()); g26: precisión esperar que la primera coincidencia de una consulta sea la única es una ingenuidad. el uso de números de coma flotante para representar divisas es casi un delito. evitar bloqueos y/o la administración de transacciones por creer que las actualizaciones concurrentes no son posibles es pura indolencia. declarar una variable como arraylist cuando se necesita list es un exceso de restricciones. crear todas las variables como protected de forma predeterminada es falta de restricciones. al adoptar una decisión en el código, debe hacerlo de forma precisa. debe saber por qué la adopta y cómo afrontará las excepciones. no sea indolente sobre la precisión de sus decisiones. si decide invocar una función que pueda devolver null , asegúrese de comprobar null . si consulta el que considera el único registro de una base de datos, asegúrese de que el código comprueba que no haya otros. si tiene que trabajar con divisas, use enteros [114] y aplique el redondeo correcto. si existe la posibilidad de una actualización concurrente, asegúrese de implementar algún tipo de mecanismo de bloqueo. en el código, la ambigüedad y las imprecisiones son el resultado de desacuerdos o de indolencia. en cualquier caso, elimínelas. g27: estructura sobre convención aplique las decisiones de diseño con estructura y no convenciones. las convenciones de nomenclatura son correctas pero resultan inferiores a estructuras que refuerzan la compatibilidad. por ejemplo, los casos switch con enumeraciones de nombres correctos son inferiores a clases base con 380métodos abstractos. no estamos obligados a implementar siempre la instrucción switch/case de la misma forma, pero las clases base hacen que las clases concretas implementen métodos abstractos. g28: encapsular condicionales la lógica booleana es difícil de entender sin necesidad de verla en el contexto de una instrucción if o while . extraiga funciones que expliquen el cometido de la condicional. por ejemplo: if (shouldbedeleted(timer)) es preferible a if (timer.hasexpired() && !timer.isrecurrent()) g29: evitar condicionales negativas las condicionales negativas son más difíciles de entender que las positivas. por ello, siempre que sea posible, debe expresar las condiciones como positivas. por ejemplo: if (buffer.shouldcompact()) es preferible a if (!buffer.shouldnotcompact()) g30: las funciones sólo deben hacer una cosa es tentador crear funciones con varias secciones que realicen una serie de operaciones. este tipo de funciones hacen más de una cosa y deben convertirse en funciones de menor tamaño, cada una para una cosa . por ejemplo: public void pay() { for (employee e : employees) { if (e.ispayday()) { money pay = e .calculatepay(); e.deliverpay(pay); } } 381} este fragmento de código realiza tres operaciones. itera por todos los empleados, comprueba si cada uno debe recibir su paga y después paga al empleado. se podría reescribir de esta forma: public void pay() { for (employee e : employees) payifnecessary(e); } private void payifnecessary(employee e) { if (e.ispayday()) calculateanddeliverpay(e); } private void calculateanddeliverpay(employee e) { money pay = e.calculatepay(); e.deliverpay(pay); } cada una de estas funciones hace una sola cosa (véase el capítulo 3). g31: conexiones temporales ocultas las conexiones temporales suelen ser necesarias pero no debe ocultar la conexión. estructure los argumentos de sus funciones de modo que el orden de invocación sea evidente. fíjese en lo siguiente: public class moogdiver { gradient gradient; list<spline> splines; public void dive(string reason) { saturategradient(); reticulatesplines(); diveformoog(reason); } … } el orden de las tres funciones es importante. debe saturar el degradado antes de poder entrelazar las tiras, para después continuar. desafortunadamente, el código no aplica esta conexión temporal. otro programador podría invocar reticulatesplines antes de saturategradient , lo que generaría unsaturatedgradientexception . una solución más acertada sería: 382public class moogdiver { gradient gradient; list<spline> splines; public void dive(string reason) { gradient gradient = saturategradient(); list<spline> splines = reticulatesplines(gradient); diveformoog(splines, reason); } … } de este modo se muestra la conexión temporal generando una especie de embudo. cada función genera un resultado que la siguiente necesita de modo que no se pueden invocar en otro orden. puede argumentar que esto aumenta la complejidad de las funciones y tiene razón, pero ese incremento de complejidad sintáctica muestra la verdadera complejidad temporal de la situación. observará que he mantenido las variables de instancia. imagino que son necesarias para los métodos privados de las clases. incluso así, conservo los argumentos para que la conexión temporal sea explícita. g32: evitar la arbitrariedad argumente la estructura de su código y asegúrese de que la estructura del código comunica dicho argumento. si la estructura parece arbitraria, otros se verán con derecho a modificarla. si la estructura parece coherente en la totalidad del sistema, otros la usarán y conservarán la convención. por ejemplo, recientemente repasaba cambios realizados en fitnesse y descubrí lo siguiente: public class aliaslinkwidget extends parentwidget { public static class variableexpandingwidgetroot { … … } el problema es que variableexpandingwidgetroot no debía estar en el ámbito de aliaslinkwidget . es más, otras clases sin relación usaban aliaslinkwidget.variableexpandingwidgetroot y no tenían por qué saber 383nada de aliaslinkwidget . puede que el programador añadiera variableexpandingwidgetroot a aliaswidget por comodidad o que realmente pensara que debía formar parte del ámbito de aliaswidget . independientemente del motivo, el resultado será arbitrario. las clases públicas que no son utilidades de otra clase no deben incluirse en el ámbito de otra clase. la convención es convertirlas en públicas en el nivel superior de su paquete. g33: encapsular condiciones de límite las condiciones de límite son difíciles de controlar. aísle su procesamiento y no permita que se transfieran al resto del código. no necesitamos legiones de +1 y -1 por todas partes. fíjese en este ejemplo de fit: if (level + 1 < tags.length) { parts = new parse(body, tags, level + 1, offset + endtag); body = null; } level+1 aparece dos veces. es una condición de límite que debe encapsularse en una variable con un nombre como nextlevel . int nextlevel = level + 1; if(nextlevel < tags.length) { parts = new parse(body, tags, nextlevel, offset + endtag); body = null; } g34: las funciones sólo deben descender un nivel de abstracción las instrucciones de una función deben crearse en el mismo nivel de abstracción, un nivel por debajo de la operación descrita por el nombre de la función. puede que sea la heurística más difícil de interpretar y aplicar. aunque la idea es simple, como humanos nos cuesta mezclar niveles de abstracción. fíjese en el siguiente código de fitnesse: public string render() throws exception { 384stringbuffer html = new stringbuffer(“<hr”); if(size > 0) html.append(“ size=\“”).append(size + 1).append(“\””); html.append(“>”); return html.tostring(); } si lo analiza, verá lo que sucede. esta función crea la etiqueta html que traza una regla horizontal por la página. la altura de la regla se especifica en la variable size . fíjese otra vez en el código. este método mezcla al menos dos niveles de abstracción. el primero es la noción de que una regla horizontal tiene un tamaño. el segundo es la sintaxis de la propia etiqueta hr . el código proviene del módulo hrulewidget de fitnesse. este módulo detecta una fila de cuatro o más guiones y la convierte en la correspondiente etiqueta hr . cuantos más guiones haya, mayor será el tamaño. a continuación le muestro la refactorización del código. he cambiado el nombre del campo size para reflejar su verdadero cometido. contenía el número de guiones adicionales. public string render() throws exception { htmltag hr = new htmltag(“hr”); if (extradashes > 0) hr.addattribute(“size”, hrsize(extradashes)); return hr.html(); } private string hrsize(int height) { int hrsize = height + 1; return string.format(“%d”, hrsize); } este cambio separa correctamente los dos niveles de abstracción. la función render simplemente crea una etiqueta hr sin tener que saber nada sobre su sintaxis html. el módulo htmltag se encarga de los problemas sintácticos. de hecho, al realizar este cambio detecté un sutil error. el código original no incluía la barra final en la etiqueta hr , como haría el estándar xhtml (es decir, generaba <hr> en lugar de <hr/> ). el módulo htmltag se había modificado hace tiempo para ajustarlo a xhtml. 385la separación de niveles de abstracción es una de las tareas más importantes de la refactorización, y también una de las más complejas. por ejemplo, fíjese en el siguiente código. fue mi primer intento de separar los niveles de abstracción del método hrulewidget.render . public string render() throws exception { htmltag hr = new htmltag(“hr”); if (size > 0) { hr.addattribute (“size”, “”+(size+1)); } return hr.html(); } mi objetivo, en esta fase, es crear la separación necesaria y conseguir superar las pruebas. el objetivo lo alcancé fácilmente pero el resultado fue una función con niveles de abstracción mezclados. en este caso, fueron obra de la etiqueta hr y de la interpretación y el formato de la variable size. esto indica que al dividir una función en líneas de abstracción, suelen aparecer nuevas líneas de abstracción ocultas por la estructura anterior. g35: mantener los datos configurables en los niveles superiores si tiene una constante como un valor predeterminado o de configuración que se conoce y se espera en un nivel superior de abstracción, no debe sepultarla en una función de nivel inferior. muéstrela como argumento para esa función de nivel inferior invocado desde la función de nivel superior. fíjese en este ejemplo de fitnesse: public static void main(string[] args) throws exception { arguments arguments = parsecommandline(args); … } public class arguments { public static final string default_path = “.”; public static final string default_root = “fitnesseroot”; public static final int default_port = 80; public static final int default_version_days = 14; … } 386los argumentos de línea de comandos se analizan en la primera línea ejecutable de fitnesse. los valores predeterminados de dichos argumentos se especifican al inicio de la clase argument . no tiene que buscar instrucciones como la siguiente en los niveles inferiores del sistema: if (arguments.port == 0) // usar 80 de forma predeterminada las constantes de configuración se encuentran en un nivel superior y son fáciles de cambiar. se pasan al resto de la aplicación. los niveles inferiores de la aplicación no poseen los valores de estas constantes. g36: evitar desplazamientos transitivos por lo general, no es recomendable que un módulo sepa demasiado sobre sus colaboradores. en concreto, si a colabora con b y b con c, no queremos que los módulos que usan a sepan nada sobre c (por ejemplo, o queremos a.getb().getc().dosomething(); ). es lo que en ocasiones se denomina ley de demeter. los programadores pragmáticos lo denominan crear código silencioso [115] . en cualquier caso, se trata de garantizar que los módulos sólo tienen conocimiento de sus colaboradores inmediatos y no del mapa de navegación completo del sistema. si varios módulos usan alguna variante de la instrucción a.getb().getc() , sería complicado cambiar el diseño y la arquitectura para intercalar q entre b y c. tendría que localizar todas las instancias de a.getb().getc() y convertirlas a a.getb().getq().getc() . es la forma en que las arquitecturas se vuelven rígidas. demasiados módulos saben demasiado sobre la arquitectura. por el contrario, queremos que nuestros colaboradores intermedios ofrezcan todos los servicios que necesitamos. no debemos deambular por el gráfico de objetos del sistema en busca del método que necesitamos invocar. bastaría con poder usar: mycollaborator.dosomething(). java 387j1: evitar extensas listas de importación mediante el uso de comodines si usa dos o más clases de un paquete, importe el paquete completo con import package.*; las listas extensas de importaciones intimidan al lector. no queremos colapsar la parte superior de los módulos con 80 líneas de importaciones, sino que sean una instrucción concisa de los paquetes con los que colaboramos. las importaciones específicas son dependencias rígidas, mientras que las importaciones de comodín no. si importa una clase concreta, esa clase debe existir, pero si importa un paquete con un comodín, no es necesario que existan clases concretas. la instrucción de importación simplemente añade el paquete a la ruta de búsqueda al localizar los nombres. por tanto, no se genera una verdadera dependencia en estas importaciones y permiten aligerar las conexiones de nuestros módulos. en ocasiones, la lista extensa de importaciones puede resultar útil. por ejemplo, si tiene que trabajar con código de legado y desea saber para qué clases crear elementos ficticios, puede examinar la lista de importaciones concretas para determinar los verdaderos nombres cualificados de todas esas clases y después añadirlos. no obstante, este uso de las importaciones concretas no es habitual. es más, muchos ide modernos le permiten convertir las importaciones con comodines en una lista de importaciones concretas con un solo comando. por tanto, incluso en el caso anterior, es recomendable usar comodines. las importaciones de comodín pueden probar conflictos de nombres y ambigüedades. dos clases con el mismo nombre pero en paquetes diferentes tienen que importarse de forma concreta o al menos cualificarse de forma específica cuando se usen. puede resultar molesto pero no es habitual que el uso de importaciones de comodín sea más indicado que el de importaciones concretas. j2: no heredar constantes lo he visto muchas veces y siempre me molesta. un programador añade 388constantes a una interfaz y después accede a las mismas heredando dicha interfaz. fíjese en el siguiente código: public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } ¿de dónde salen las constantes tenths_per_week y overtime_rate ? puede que provengan de la clase employee ; comprobémoslo: public abstract class employee implements payrollconstants { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } no, de ahí no. ¿entonces de dónde? fíjese atentamente en la clase employee . implementa payrollconstants . public interface payrollconstants { public static final int tenths_per_week = 400; public static final double overtime_rate = 1.5; } es horrible. las constantes se ocultan en la parte superior de la jerarquía de herencia. no use la herencia para burlar las reglas de ámbito del lenguaje. use una importación estática: import static payrollconstants.*; public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } 389j3: constantes frente a enumeraciones ahora que se han añadido enumeraciones al lenguaje (java 5), ¡úselas! no recurra al viejo truco de public static final int . el significado de int se puede perder. el de enum no, ya que pertenece a una enumeración con nombre. es más, analice atentamente la sintaxis de las enumeraciones . pueden tener métodos y campos, lo que las convierte en potentes herramientas que ofrecen mayor expresividad y flexibilidad que los int . fíjese en esta variante del código: public class hourlyemployee extends employee { private int tenthsworked; hourlypaygrade grade; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( grade.rate() * (tenthsworked + overtime_rate * overtime) ); } … } public enum hourlypaygrade { apprentice { public double rate() { return 1.0; } }, leutenant_journeyman ( public double rate() { return 1.2; } }, journeyman { public double rate() { return 1.5; } }, master { public double rate() { return 2.0; } }; public abstract double rate(); 390} nombres n1: elegir nombres descriptivos no sea demasiado rápido a la hora de elegir un nombre. asegúrese de que sea descriptivo. recuerde que los significados suelen variar cuando el código evoluciona, de modo que debe revisar frecuentemente la corrección de los nombres elegidos. no es una recomendación de sensaciones. en software , los nombres constituyen el 90 por 100 de su legibilidad. dedique tiempo a seleccionarlos con atención y mantenga su relevancia. los nombres son demasiado importantes como para tratarlos mal. fíjese en el siguiente código. ¿para qué sirve? si le muestro el mismo código con nombres bien elegidos, tendrá sentido, pero con este formato no es más que una masa de símbolos y números mágicos. public int x() { int q = 0; int z = 0; for (int kk = 0; kk < 10; kk++) { if (l[z] == 10) { q += 10 + (l[z + 1] + l[z + 2]); z += 1; } else if (l[z] + l[z + 1] == 10) { q += 10 + l[z + 2]; z += 2; } else { q += l[z] + l[z + 1]; z += 2; } } return q; } a continuación, el código como debería haberse escrito. este fragmento es en realidad menos completo que el anterior, pero detectará inmediatamente 391lo que intenta hacer y es probable que pudiera crear las funciones que faltan en función de ese significado que intuye. los números mágicos ya no lo son y la estructura del algoritmo es descriptiva y atractiva: public int score() { int score = 0; int frame = 0; for (int framenumber = 0; framenumber < 10; framenumber++) { if (isstrike(frame)) { score += 10 + nexttwoballsforstrike(frame); frame += 1; } else if (isspare(frame)) { score += 10 + nextballforspare(frame); frame += 2; } else { score += twoballsinframe(frame); frame += 2; } } return score; } los nombres bien elegidos inundan la estructura del código con descripciones. dicha inundación define las expectativas del lector sobre el cometido de otras funciones del módulo. puede inferir la implementación de isstrike() si se fija en el código anterior. cuando lea el método isstrike , será prácticamente lo que esperaba [116] . private boolean isstrike(int frame) { return rolls[frame] = 10; } n2: elegir nombres en el nivel correcto de abstracción no elija nombres que comuniquen implementación; seleccione nombres que reflejen el nivel de abstracción de la clase o la función con la que trabaje. es complicado. de nuevo, nos cuesta mezclar niveles de abstracción. siempre que realice una pasada por su código, es probable que encuentre una variable con nombre en un nivel demasiado bajo. cambie esos nombres cuando los vea. para que el código sea legible se necesita una mejora continua. fíjese en la siguiente interfaz modem : public interface modem { 392boolean dial(string phonenumber); boolean disconnect(); boolean send(char c); char recv(); string getconnectedphonenumber(); } inicialmente parece correcta. las funciones parecen las adecuadas. de hecho lo son para muchas aplicaciones, pero piense ahora en una aplicación en la que algunos módems no se conecten mediante marcación telefónica, sino mediante cables (como los usados para conexiones domésticas a internet). puede que algunos se conecten enviando un número de puerto a un concentrador a través de una conexión usb. es evidente que la noción de números de teléfono se encuentra en un nivel de abstracción equivocado. una estrategia de nomenclatura más adecuada para este caso sería la siguiente: public interface modem { boolean connect(string connectionlocator); boolean disconnect(); boolean send(char c); char recv(); string getconnectedlocator(); } ahora los nombres no se limitan a números de teléfono. se pueden usar para números de teléfono o para otros tipos de estrategia de conexión. n3: usar nomenclatura estándar siempre que sea posible los nombres son más fáciles de entender si se basan en una convención o un uso existente. por ejemplo, si emplea el patrón decorator , debería usar la palabra decorator en los nombres de las clases. por ejemplo, autohangupmodemdecorator podría ser el nombre de una clase que permite a un módem colgar automáticamente al final de una sesión. los patrones son un tipo de estándar. en java, por ejemplo, las funciones que convierten objetos en representaciones de cadena suelen tener el nombre tostring . es mejor seguir estas convenciones que inventar otras propias. los equipos suelen inventar su propio sistema estándar de nombres para un proyecto concreto. eric evans lo denomina lenguaje omnipresente del 393proyecto [117] . su código debe usar los términos de este lenguaje. en definitiva, cuantos más nombres con significado especial y relevante para su proyecto utilice, más fácil será para los lectores saber de qué trata el código. n4: nombres inequívocos seleccione nombres que ilustren de forma inequívoca el funcionamiento de funciones y variables. fíjese en este ejemplo de fitnesse: private string dorename() throws exception { if (refactorreferences) renamereferences(); renamepage(); pathtorename.removenamefromend(); pathtorename.addnametoend(newname); return pathparser.render(pathtorename); } el nombre de esta función no indica qué hace, al menos en términos amplios y sin concretar. además, se refuerza por la presencia de la función renamepage dentro de la función dorename . ¿qué indican los nombres sobre la diferencia entre ambas funciones? nada. un nombre más acertado para la función sería renamepageandoptionallyallreferences . puede parecerle extenso, y lo es, pero sólo se invoca desde un punto del módulo, de modo que su valor descriptivo supera su longitud. n5: usar nombres extensos para ámbitos extensos la longitud de un nombre debe estar relacionada con la de su ámbito. puede usar nombres de variables breves para ámbitos diminutos pero en ámbitos mayores debe emplear nombres extensos. los nombres de variables como i y j son correctos si su ámbito tiene cinco líneas de longitud. fíjese en el siguiente fragmento del conocido juego de los bolos: private void rollmany(int n, int pins) { for (int i=0; i<n; i++) 394g.roll(pins); } es totalmente claro y se complicaría si la variable i se cambiara por algo como rollcount . por otra parte, las variables y funciones con nombres breves pierden su significado en las grandes distancias. por tanto, cuanto mayor sea el ámbito del nombre, más extenso y preciso tendrá que ser el nombre. n6: evitar codificaciones los nombres no deben codificarse con información de tipos o ámbitos. prefijos como m_ o f no sirven de nada en los entornos actuales. además, codificaciones de proyecto y/o subsistema como vis_ (para un sistema de imágenes visuales) distraen la atención y son redundantes. los entornos actuales proporcionan toda esa información sin tener que modificar los nombres. aleje sus nombres de la contaminación húngara. n7: los nombres deben describir efectos secundarios los nombres deben describir todo lo que haga una función, variable o clase. no oculte efectos secundarios con un nombre. no utilice un simple verbo para describir una función que realiza algo más que una simple acción. fíjese en este código de testng: public objectoutputstream getoos() throws ioexception { if (m_oos == null) { m_oos = new objectoutputstream(m_socket.getoutputstream()); } return m_oos; } esta función hace algo más que obtener oos ; lo crea si todavía no se ha creado. por lo tanto, un nombre más acertado sería createorreturnoos . pruebas (test) 395t1: pruebas insuficientes ¿cuántas pruebas debe incluir una suite de pruebas? desafortunadamente, muchos programadores dirían que las que parezcan suficientes. una suite de pruebas debe probar todo lo que pueda fallar. las pruebas son insuficientes mientras haya condiciones que no se hayan examinado o cálculos que no se hayan validado. t2: usar una herramienta de cobertura las herramientas de cobertura indican vacíos en su estrategia de pruebas. facilitan la detección de módulos, clases y funciones insuficientemente probadas. muchos ide le ofrecen un indicador visual y marcan en verde las líneas cubiertas y en rojo las no cubiertas. de este modo es más rápido y sencillo detectar instrucciones if o catch cuyos cuerpos no se han comprobado. t3: no ignorar pruebas triviales son fáciles de redactar y su valor documental es mayor que el coste de crearlas. t4: una prueba ignorada es una pregunta sobre una ambigüedad en ocasiones dudamos de un detalle de comportamiento porque los requisitos no son claros. podemos expresar nuestra duda sobre los requisitos en forma de prueba comentada o como prueba anotada con @ignore . la decisión depende de si la ambigüedad es sobre algo que se compila o no. t5: probar condiciones de límite 396preste especial atención a las pruebas de condiciones de límite. solemos acertar con la parte central de un algoritmo pero malinterpretar los límites. t6: probar de forma exhaustiva junto a los errores los errores suelen congregarse. si detecta un error en una función, es recomendable probarla de forma exhaustiva. seguramente no sea el único error. t7: los patrones de fallo son reveladores en ocasiones diagnosticamos un problema detectando patrones de fallo en los casos de prueba. es otro argumento para crear casos de prueba lo más completos posibles. los casos de prueba completos, si se ordenan de forma razonable, revelan patrones. como ejemplo, imagine que ha detectado que todas las pruebas con un entero mayor de cinco caracteres fallan. o que fallan todas las pruebas que pasan un número negativo al segundo argumento de una función. en ocasiones, con ver el patrón de rojos y verdes de un informe de pruebas basta para hacer saltar la chispa y llegar a una solución. en el capítulo 16 encontrará un interesante ejemplo en el caso de serialdate . t8: los patrones de cobertura de pruebas pueden ser reveladores el análisis del código que se ejecuta o no en las pruebas superadas suele indicar porqué fallan las pruebas no superadas. t9: las pruebas deben ser rápidas una prueba lenta no se ejecuta. cuando las cosas se ponen feas, las pruebas lentas se eliminan de la suite . por lo tanto, intente que sus pruebas sean 397rápidas. conclusión esta lista de heurística y síntomas no se podría considerar completa. de hecho, dudo de que alguna vez exista alguna. pero puede que ese no sea el objetivo, ya que lo que implica esta lista es un sistema de valores. el sistema de valores ha sido el objetivo y la base de este libro. el código limpio no se crea siguiendo una serie de reglas. no se convertirá en un maestro del software aprendiendo una lista de heurísticas. la profesionalidad y la maestría provienen de los valores que impulsan las disciplinas. bibliografía [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. [beck97] : smalltalk best practice patterns , kent beck, prentice hall, 1997. [beck07] : implementation patterns , kent beck, addison-wesley, 2008. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. [ddd] : domain driven design , eric evans, addison-wesley, 2003. 398apéndice a concurrencia ii por brett l. schuchert este apéndice complementa y amplía el capítulo 13 sobre concurrencia. se ha escrito como una serie de temas independientes que puede leer en el orden que desee. algunas secciones están duplicadas para facilitar dicha lectura. ejemplo cliente/servidor imagine una sencilla aplicación cliente/servidor. un servidor espera a que un cliente se conecte. un cliente se conecta y envía una solicitud. el servidor a continuación le mostramos una versión simplificada de una aplicación de servidor. el código completo de este ejemplo se recoge en el listado a-3. serversocket serversocket = new serversocket(8009); while (keepprocessing) { try { socket socket = serversocket.accept(); process(socket); } catch (exception e) { handle(e); } 399} esta sencilla aplicación espera una conexión, procesa un mensaje entrante y vuelve a esperar a la siguiente solicitud cliente. el código cliente para conectarse al servidor es el siguiente: private void connectsendreceive(int i) { try { socket socket = new socket (“localhost”, port); messageutils.sendmessage(socket, integer.tostring(i)); messageutils.getmessage(socket); socket.close(); } catch (exception e) { e.printstacktrace(); } } ¿cómo se comporta esta combinación de cliente y servidor? ¿cómo podemos describir formalmente ese rendimiento? la siguiente prueba afirma que el rendimiento es aceptable: @test(timeout = 10000) public void shouldruninunder10seconds() throws exception { thread[] threads = createthreads(); startallthreadsw(threads); waitforallthreadstofinish(threads); } se omite la configuración para que el ejemplo sea sencillo (véase “ clienttest.java ” más adelante). esta prueba afirma que debe completarse en 10 000 milisegundos. es un ejemplo clásico de validación del rendimiento de un sistema. este sistema debe completar una serie de solicitudes cliente en 10 segundos. mientras el servidor pueda procesar cada solicitud cliente a tiempo, la prueba será satisfactoria. ¿qué sucede si la prueba falla? aparte de desarrollar algún tipo de bucle de consulta de eventos, no hay mucho que hacer en un único proceso para aumentar la velocidad de este código. ¿se solucionaría el problema con varios procesos? puede, pero necesitamos saber cómo se consume el tiempo. hay dos posibilidades: e/s: con un socket, conectándose a la base de datos, esperando al intercambio de memoria virtual, etc. procesador: cálculos numéricos, procesamiento de expresiones 400regulares, recolección de elementos sin usar, etc. los sistemas suelen tener uno de cada, pero para una operación concreta suele haber uno dominante. si el código se vincula al procesador, mayor cantidad de hardware de procesamiento puede mejorar el rendimiento y hacer que se supere la prueba, pero no hay tantos ciclos de cpu disponibles, de modo que añadir procesos a un problema vinculado al procesador no hará que aumente la velocidad. por otra parte, si el proceso está vinculado a e/s, la concurrencia puede aumentar la eficacia. cuando una parte del sistema espera a e/s, otra puede usar ese tiempo de espera para procesar algo distinto, maximizando el uso eficaz de la cpu disponible. añadir subprocesos imagine que la prueba de rendimiento falla. ¿cómo podemos mejorar la producción para que la prueba de rendimiento sea satisfactoria? si el método process del servidor está vinculado a la e/s, existe una forma de conseguir que el servidor use subprocesos (basta con cambiar processmessage): void process (final socket socket) { if (socket == null) return; runnable clienthandler = new runnable() { public void run() { try { string message = messageutils.getmessage(socket); messageutils.sendmessage(socket, “processed: ” + message); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } }; thread clientconnection = new thread(clienthandler); clientconnection.start(); } asuma que este cambio hace que la prueba se supere [118] ; el código es completo, ¿correcto? 401observaciones del servidor el servidor actualizado completa satisfactoriamente la prueba en algo más de un segundo. desafortunadamente, la solución genera ciertos problemas. ¿cuántos subprocesos podría crear nuestro servidor? el código no define límites de modo que podríamos alcanzar el impuesto por la máquina virtual de java (mvj), suficiente en muchos sistemas sencillos. ¿pero y si el sistema tiene que asumir multitud de usuarios de una red pública? si se conectan demasiados usuarios al mismo tiempo, el sistema podría colapsarse. pero dejemos temporalmente este problema de comportamiento. la solución mostrada tiene problemas de limpieza y estructura. ¿cuántas responsabilidades tiene el código del servidor? administración de conexiones. procesamiento de clientes. política de subprocesos. política de cierre del servidor. desafortunadamente, todas estas responsabilidades se encuentran en la función process . además, el código cruza varios niveles diferentes de abstracción. por tanto, a pesar de la reducida función process , es necesario dividirlo. existen varios motivos para cambiar el servidor; por tanto, incumple el principio de responsabilidad única. para mantener la limpieza de un sistema concurrente, la administración de subprocesos debe limitarse a una serie de puntos controlados. es más, el código que gestione los subprocesos únicamente debe encargarse de la gestión de subprocesos. ¿por qué? si no existe otro motivo, el control de problemas de concurrencia ya es lo suficientemente complicado como para generar simultáneamente otros problemas no relacionados con la concurrencia. si creamos una lista independiente para cada una de las responsabilidades anteriores, incluyendo la administración de subprocesos, al cambiar la estrategia de administración de subprocesos, el cambio tiene un menor impacto sobre el código y no contamina a otras responsabilidades. de este 402modo también es más sencillo probar las demás responsabilidades sin necesidad de preocuparse de los subprocesos. veamos la versión actualizada que se encarga de ello: public void run() { while (keepprocessing) { try { clientconnection clientconnection = connectionmanager.awaitclient(); clientrequestprocessor requestprocessor = new clientrequestprocessor(clientconnection); clientscheduler.schedule(requestprocessor); } catch (exception e) { e.printstacktrace(); } } connectionmanager.shutdown(); } ahora centra en el mismo punto todos los aspectos relacionados con los subprocesos: clientscheduler . si hay problemas de concurrencia, bastará con examinar un punto concreto: public interface clientscheduler { void schedule(clientrequestprocessor requestprocessor); } la política actual es fácil de implementar: public class threadperrequestscheduler implements clientscheduler { public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; thread thread = new thread(runnable); thread.start(); } } tras aislar la administración de subprocesos, resulta más sencillo cambiar el control de los mismos. por ejemplo, para cambiar a la estructura executor de java 5 es necesario crear una nueva clase y conectarla (véase el listado a-1). listado a-1 403executorclientscheduler.java. import java.util.concurrent.executor; import java.util.concurrent.executors; public class executorclientscheduler implements clientscheduler { executor executor; public executorclientscheduler(int availablethreads) { executor = executors.newfixedthreadpool(availablethreads); } public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; executor.execute(runnable); } } conclusión en este ejemplo concreto, la presencia de la concurrencia ilustra una forma de mejorar la producción de un sistema y otra de validar dicha producción a través de una estructura de pruebas. al centrar el código de concurrencia en un número reducido de clases, aplicamos el principio de responsabilidad única. en el caso de la programación concurrente, resulta especialmente importante debido a su complejidad. posibles rutas de ejecución repase el método incrementvalue , un método de java de una línea sin bucles ni ramificaciones: public class idgenerator { int lastidused; public int incrementvalue() { return ++lastidused; } } ignore el desbordamiento de enteros e imagine que solamente un 404subproceso accede a una instancia de idgenerator . en este caso existe una sola ruta de ejecución y un único resultado garantizado: el valor devuelto es igual al valor de lastidused , y ambos son una unidad mayores que antes de invocar el método. ¿qué sucede si usamos dos subprocesos y no cambiamos el método? ¿cuáles son los posibles resultados si cada subproceso invoca incrementvalue una vez? ¿cuántas rutas de ejecución posibles hay? primero, los resultados (imagine que el valor inicial de lastidused es 93): el primer subproceso obtiene el valor 94, el segundo el valor 95 y lastidused es 95. el primer subproceso obtiene el valor 95, el segundo el valor 94 y lastidused es 95. el primer subproceso obtiene el valor 94, el segundo el valor 94 y lastidused es 94. el resultado final, aunque sorprendente, es posible. para ver los distintos resultados, debemos comprender las diferentes rutas de ejecución posibles y cómo las ejecuta la mvj. número de rutas para calcular el número de rutas de ejecución posibles, comenzaremos con el código de bytes generado. la única línea de java ( return ++lastidused; ) se convierte en ocho instrucciones de código de bytes . los dos subprocesos pueden intercambiar la ejecución de estas ocho instrucciones del mismo modo que mezclamos las cartas de una baraja [119] . incluso con sólo ocho cartas en cada mano, el número de posibles resultados es sorprendente. para este sencillo caso de n instrucciones en una secuencia, sin bucles ni condicionales y t subprocesos, el número total de posibles rutas de ejecución es igual a: 405(nt)! n! t calcular las órdenes posibles extraído de un correo electrónico de uncle bob a brett: con n pasos y t subprocesos hay t * n pasos totales. antes de cada paso hay un conmutador de contexto que elige entre los subprocesos. por tanto, cada ruta se representa como una cadena de dígitos que denota los cambios de contexto. dados los pasos a y b y los subprocesos 1 y 2, las seis rutas posibles son 1122, 1212, 1221, 2112, 2121 y 2211. o, en términos de pasos, a1b1a2b2, a1a2b1b2, a1a2b2b1, a2a1b1b2, a2a1b2b1 y a2b2a1b1. para tres subprocesos, la secuencia sería 112233, 112323, 113223, 113232, 112233, 121233, 121323, 121332, 123132, 123123… una característica de estas cadenas es que siempre debe haber n instancias de cada t . por tanto, la cadena 111111 no es válida ya que tiene seis instancias de 1 y ninguna de 2 y 3. por tanto, necesitamos las permutaciones de n 1, n 2… y n  t . en realidad son las permutaciones de n * t tomando cada vez n * t , que es (n * t)! , pero sin los duplicados. por tanto, el truco consiste en contar los duplicados y restarlos de (n * t)! . dados dos pasos y dos subprocesos, ¿cuántos duplicados hay? cada cadena de cuatro dígitos tiene dos 1 y dos 2. estos pares se pueden intercambiar sin modificar el sentido de la cadena. podríamos intercambiar los 1 o los 2, o ninguno. por tanto hay cuatro isomorfas por cada cadena, lo que significa que hay tres duplicados, de modo que tres de las cuatro opciones son duplicados; por otra parte, una de las cuatro permutaciones no son duplicados. 4! * .25 = 6. este razonamiento parece funcionar. ¿cuántos duplicados hay? si n = 2 y t = 2, podría intercambiar los 1, los 2, o ambos. en el caso de n = 2 y t = 3, podría intercambiar los 1, los 2, los 3, 1 y 2, 1 y 3, o 2 y 3. el intercambio son las permutaciones de n . imagine que hay p permutaciones de n . el número de formas diferentes de organizar dichas permutaciones es p**t . por tanto el número de isomorfas posibles es n!**t . y el número de rutas es ( t*n )!/( n!**t ). de nuevo, en nuestro caso t = 2, n = 2 obtenemos 6 (24/4). para n = 2 y t = 3 obtenemos 720/8 = 90. para n = 3 y t = 3 obtenemos 9!/6^3 = 1680. en nuestro sencillo caso de una sola línea de código java, que equivale a ocho líneas de código de bytes y a dos subprocesos, el número total de posibles rutas de ejecución es 12 870. si el tipo de lastidused es long , cada lectura y escritura se convierte en dos operaciones y no una, y el número de posibilidades asciende a 2 704 156. ¿qué sucede si realizamos un cambio en este método? 406public synchronized void incrementvalue() { ++lastidused; } el número de posibles rutas de ejecución es dos para dos subprocesos y n! para el caso general. un examen más profundo ¿qué piensa del sorprendente resultado de dos subprocesos que invoquen el método una vez (antes de añadir synchronized ) y obtengan el mismo resultado numérico? ¿cómo es posible? vayamos por partes. ¿qué es una operación atómica? podemos definir una operación atómica como toda operación ininterrumpible. por ejemplo, en el siguiente código, la línea 5, donde se asigna 0 a lastid , es atómica ya que de acuerdo al modelo de memoria de java, la asignación a un valor de 32 bits es ininterrumpible. 01: public class example { 02: int lastid; 03: 04: public void resetid() { 05: value = 0; 06: } 07: 08: public int getnextid() { 09: ++value; 10: } 11: } ¿qué sucede si cambiamos el tipo de lastid de int a long ? ¿sigue siendo atómica la línea 5? no de acuerdo a la especificación de la mvj. podría ser atómica en un procesador concreto, pero según la especificación de la mvj, la asignación a un valor de 64 bits requiere dos asignaciones de 32 bits. esto significa que entre la primera y la segunda podría irrumpir otro subproceso y cambiar uno de los valores. ¿y qué sucede con el operador de preincremento, ++ , de la línea 9? este operador se puede interrumpir, de modo que no es atómico. para entenderlo, repasemos el código de bytes de ambos métodos. antes de continuar, hay tres definiciones importantes: 407marco: la invocación de un método requiere un marco, el cual incluye la dirección de devolución, los parámetros pasados al método y las variables locales definidas en el mismo. es una técnica estándar empleada para definir una pila de invocaciones, que se usa en muchos lenguajes modernos para permitir la invocación de funciones y métodos básicos, además de invocaciones recursivas. variable local: las variables definidas en el ámbito del método. todos los métodos no estáticos tienen al menos una variable, this , que representa el objeto actual, el objeto que ha recibido el último mensaje (en el subproceso actual) que ha propiciado la invocación del método. pila de operandos: muchas instrucciones de la mvj aceptan parámetros. la pila de operandos es donde se incluyen dichos parámetros. la pila es una estructura de datos lifo ( last-in, first-out o último en entrar, primero en salir) estándar. veamos el código de bytes generado para resetid(). nemónico descripción pila de operandos posterior aload 0 cargar la variable 0 a en la pila de operandos. ¿qué es la variable 0 a ? es this. , el objeto actual. al invocar el método, el receptor del mensaje, una instancia de example , se envía a la matriz de variables locales del marco creado para la invocación de métodos. siempre es la primera variable que se añade a todos los métodos de instancia. this iconst_0 incluir el valor constante 0 en la pila de operandos. this, 0 putfield lastid almacenar el valor superior de la pila (0) en el valor de campo del objeto denominado por la referencia de objeto una posición alejada de la parte superior de la pila, this . <vacío> 408estas tres instrucciones son atómicas ya que a pesar de que el subproceso que las ejecuta podría verse interrumpido por cualquiera de ellas, la información para la instrucción putfield (el valor constante 0 de la parte superior de la pila y la referencia a éste una posición inferior, junto con el valor del campo) no se ve alterada por ningún otro subproceso. por tanto, al producirse la asignación, sabemos que el valor 0 se almacena en el valor del campo. la operación es atómica. todos los operandos procesan información local del método, de modo que no hay interferencias entre subprocesos. si estas instrucciones se ejecutan en diez subprocesos, hay 4.38679733629e+24 ordenaciones posibles. sin embargo, sólo hay un resultado posible, de modo que las distintas ordenaciones son irrelevantes. y además, se garantiza el mismo resultado para valores long en este caso. ¿por qué? los diez subprocesos asignan un valor constante. aunque se entremezclen, el resultado final será el mismo. habrá problemas con la operación ++ en el método getnextid . imagine que lastid contiene 42 al inicio de este método. veamos el código de bytes de este nuevo método: nemónico descripción pila de operandos posterior aload 0 cargar this en la pila de operandos. this dup copiar la parte superior de la pila. ahora tenemos dos copias de this en la pila de operandos. this, this getfield lastid recuperar el valor del campo lastid del objeto al que se apunta en la parte superior de la pila ( this ) y volver a almacenar el valor en la pila. this, 42 iconst_1 desplazar la constante entera 1 en la pila. this, 42, 1 iadd suma entera de los dos valores superiores de la pila de operandos y volver a almacenar el resultado en la pila. this, 43 dup_x1 duplicar el valor 43 y añadirlo delante de this . 43, this, 43 putfield almacenar el valor superior de la pila de operandos, 43 409value 43, en el valor de campo del objeto actual, representado por el siguiente valor superior de la pila de operandos, this . ireturn devolver el valor superior (y único) de la pila de operandos. <vacío> imagine que el primer subproceso completa las tres primeras instrucciones, hasta getfield incluida y después se interrumpe. aparece un segundo subproceso y ejecuta el método completo, incrementando lastid en uno; devuelve 43. tras ello, el primer subproceso retoma desde donde se detuvo; 42 sigue en la pila de operandos por ser el valor de lastid cuando ejecutó getfield . suma uno para obtener 43 y almacena el resultado. el valor 43 también se devuelve al primer subproceso. como resultado, uno de los incrementos se pierde ya que el primer subproceso interfiere con el segundo después de que éste haya interrumpido al primero. al convertir el método getnextid() en synchronized se corrige este problema. conclusión no se necesita un conocimiento extenso del código de bytes para entender cómo unos subprocesos interrumpen a otros. si consigue entender este ejemplo, demostrará la posibilidad de varios subprocesos entrelazados, un conocimiento suficiente. dicho esto, lo que este sencillo ejemplo revela es la necesidad de entender el modelo de memoria para saber qué se permite y qué no. equivocadamente se piensa que el operador ++ (pre o postincremento) es atómico, y evidentemente no lo es. esto significa que tiene que saber: dónde están los objetos y valores compartidos. el código que provoca problemas de lectura/actualización concurrente. cómo evitar que se produzcan dichos problemas. 410conocer su biblioteca la estructura executor como mostramos en executorclientscheduler.java , la estructura executor de java 5 permite la ejecución sofisticada por medio de agrupaciones de subprocesos. es una clase del paquete java.util.concurrent . si va a crear subprocesos y no usa una agrupación de subprocesos o utiliza una creada a mano, considere el uso de executor. hace que el código sea más limpio, más fácil de entender y de menor tamaño. la estructura executor agrupa subprocesos, los cambia automáticamente de tamaño y los vuelve a crear si es necesario. también admite futuros , una construcción de programación concurrente habitual. la estructura executor funciona con clases que implementan runnable y también con clases que implementan la interfaz callable . callable se parece a runnable , pero puede devolver un resultado, una necesidad habitual en soluciones de múltiples subprocesos. un futuro resulta muy útil cuando el código tiene que ejecutar varias operaciones independientes y esperar a que terminen: public string processrequest(string message) throws exception { callable<string> makeexternalcall = new callable<string>() { public string call() throws exception { string result = “”; // realizar solicitud externa return result; } }; future<string> result = executorservice.submit(makeexternalcall); string partialresult = dosomelocalprocessing(); return result.get() + partialresult; } en este ejemplo, el método comienza a ejecutar el objeto makeexternalcall , prosigue con otro procesamiento y la última línea invoca result.get(), que se bloquea hasta que el futuro termina. 411soluciones no bloqueantes la mv java 5 aprovecha el diseño de los procesadores modernos que admiten actualizaciones fiables y no bloqueantes. imagine una clase que usa sincronización (y por tanto bloqueo) para proporcionar la actualización compatible con subprocesos de un valor: public class objectwithvalue { private int value; public void synchronized incrementvalue() { ++value; } public int getvalue() { return value; } } java 5 dispone de varias clases nuevas para este tipo de situaciones, como por ejemplo atomicboolean , atomicinteger y atomicreference . podemos modificar el código anterior para usar un enfoque no bloqueante: public class objectwithvalue { private atomicinteger value = new atomicinteger(0); public void incrementvalue() { value.incrementandget(); } public int getvalue() { return value.get(); } } aunque use un objeto en lugar de una primitiva y envíe mensajes como incrementandget() en lugar de ++ , el rendimiento de esta clase supera en la mayoría de los casos al de la versión anterior. en algunos casos será ligeramente más rápido pero los casos en los que es más lento son prácticamente inexistentes. ¿cómo es posible? los procesadores modernos disponen de una operación denominada cas (compare and swap, comparar e intercambiar). es una operación similar al bloqueo optimista de una base de datos, mientras que la versión sincronizada es similar al bloqueo pesimista. la palabra clave synchronized siempre adquiere un bloqueo, incluso cuando un segundo subproceso no intenta actualizar el mismo valor. aunque el rendimiento de los bloqueos intrínsecos ha mejorado con respecto a versiones anteriores, sigue siendo muy costoso. la versión no bloqueante asume inicialmente que varios subprocesos no 412modifican el mismo valor con la suficiente periodicidad como para generar un problema. por el contrario, detecta de forma eficaz si se produce dicha situación y la reintenta hasta que la actualización es satisfactoria. esta detección suele ser menos costosa que la adquisición de un bloqueo, incluso en situaciones de contención moderada o alta. ¿cómo lo hace la mv? la operación cas es atómica. por tanto, la operación cas tiene este aspecto: int variablebeingset; void simulatenonblockingset (int newvalue) { int currentvalue; do { currentvalue = variablebeingset } while(currentvalue != compareandswap(currentvalue, newvalue)); } int synchronized compareandswap(int currentvalue, int newvalue) { if(variablebeingset == currentvalue) { variablebeingset = newvalue; return currentvalue; } return variablebeingset; } cuando un método intenta actualizar una variable compartida, la operación cas comprueba que la variable establecida sigue teniendo el último valor conocido. en caso afirmativo, se cambia la variable. en caso contrario, la variable no se establece ya que otro subproceso ha conseguido acceder. el método que realiza el intento (mediante la operación cas) ve que el cambio no se ha realizado y lo intenta de nuevo. clases incompatibles con subprocesos existen clases que no son compatibles con subprocesos, como las siguientes: simpledateformat . conexiones de base de datos. contenedores de java.util . 413servlet. algunas clases de colección tienen métodos concretos compatibles con subprocesos. sin embargo, cualquier operación que invoque más de un método no lo es. por ejemplo, si no quiere reemplazar algo en hashtable porque ya existe, podría crear el siguiente código: if(!hashtable.containskey(somekey)) { hashtable.put(somekey, new somevalue()); } cada uno de los métodos es compatible con subprocesos. sin embargo, otro subproceso podría añadir un valor entre las invocaciones de containskey y put . existen varias formas de solucionar este problema: bloquear primero hashtable y comprobar que los demás usuarios de hashtable hagan lo mismo; bloqueo basado en clientes: synchronized(map) { if(!map.containskey(key)) map.put(key,value); } envolver hashtable en su propio objeto y usar dos api distintas; bloqueo basado en servidores con un adaptador: public class wrappedhashtable<k, v> { private map<k, v> map = new hashtable<k, v>(); public synchronized void putifabsent(k key, v value) { if (map.containskey(key)) map.put(key, value); } } usar colecciones compatibles con subprocesos: concurrenthashmap<integer, string> map = new concurrenthashmap<integer, string>(); map.putifabsent(key, value); las colecciones de java.util.concurrent incluyen operaciones como putifabsent() para acomodar este tipo de operaciones. 414las dependencias entre métodos pueden afectar al código concurrente el siguiente ejemplo es una forma de añadir dependencias entre métodos: public class integeriterator implements iterator<integer> private integer nextvalue = 0; public synchronized boolean hasnext() { return nextvalue < 100000; } public synchronized integer next() { if (nextvalue == 100000) throw new iteratorpastendexception(); return nextvalue++; } public synchronized integer getnextvalue() { return nextvalue; } } veamos otro código que usa integeriterator : integeriterator iterator = new integeriterator(); while(iterator.hasnext()) { int nextvalue = iterator.next(); // hacer algo con nextvalue } si un subproceso ejecuta este código no habrá problemas. ¿qué sucede si dos subprocesos intentan compartir una misma instancia de integeriterator para procesar el valor que reciba cada uno pero cada elemento de la lista sólo se procesa una vez? en la mayoría de los casos, no hay consecuencias negativas; los subprocesos comparten la lista, procesan los elementos devueltos por el iterador y se detienen cuando éste termina. sin embargo, existe la posibilidad de que al final de la iteración los dos subprocesos interfieran entre ellos y provoquen que uno supere el final del iterador y se genere una excepción. el problema es el siguiente: el subproceso 1 pregunta hasnext() , que devuelve true . el subproceso 1 se evita y el subproceso 2 realiza la misma pregunta, que sigue siendo true . tras ello, el subproceso 2 invoca next() , que devuelve un valor, como era de esperar, pero como efecto secundario 415hace que hasnext() devuelva false . se vuelve a iniciar el subproceso 1, pensando que hasnext() sigue siendo true , y después invoca next() . aunque los métodos concretos están sincronizados, el cliente usa dos métodos. es un problema real y un ejemplo que puede surgir en código concurrente. en este caso concreto, el problema es especialmente sutil ya que la única ocasión en la que produce un fallo es durante la iteración final del iterador. si los subprocesos se dividen de forma correcta, puede que uno supere el final del iterador. es el tipo de error que surge en un sistema que lleva tiempo en producción, y es difícil de detectar. tiene tres opciones: tolerar el fallo. solucionar el problema cambiando el cliente: bloqueo basado en el cliente. solucionar el problema cambiando el servidor, lo que también provoca que cambie el cliente: bloqueo basado en el servidor. tolerar el fallo en ocasiones, los sistemas se configuran para que un fallo no produzca daños. por ejemplo, el cliente anterior podía capturar la excepción y limpiarla, aunque sería un tanto torpe. es como limpiar fugas de memoria reiniciando a medianoche. bloqueo basado en el cliente para que integeriterator funcione correctamente con varios subprocesos, cambie el cliente (y los demás) como se indica a continuación: integeriterator iterator = new integeriterator(); while (true) { int nextvalue; synchronized (iterator) { if (!iterator.hasnext()) break; nextvalue = iterator.next(); 416} dosometingwith(nextvalue); } cada cliente añade un bloqueo a través de la palabra clave synchronized . esta duplicación incumple el principio dry, pero puede ser necesaria si el código usa agrupaciones de terceros no compatibles con subprocesos. la estrategia es arriesgada ya que todos los programadores que usen el servidor deben acordarse de bloquearlo antes de usarlo y de desbloquearlo cuando terminen. hace muchos años, trabajé en un sistema que usaba el bloqueo basado en el cliente en un recurso compartido. el recurso se usaba en cientos de puntos distintos del código. un pobre programador se olvidó de bloquear el recurso en uno de esos puntos. era un sistema de varios terminales con software de contabilidad para el sindicato de transportistas. local 705. el ordenador se encontraba en una sala de temperatura controlada de un piso elevado, a unas 50 millas al norte de la sede de local 705. en la sede, decenas de trabajadores introducían datos en las terminales, conectadas al ordenador mediante líneas telefónicas dedicadas y módem semidúplex de 600bps (esto fue hace mucho , mucho tiempo). una vez al día, una de las terminales se bloqueaba, sin razón aparente. el bloqueo no tenía preferencia alguna por una terminal o una hora concreta. es como si alguien echara a suertes la terminal que bloquear y la hora del bloqueo. en ocasiones, se bloqueaba más de una terminal. en ocasiones, podían pasar varios días sin bloqueos. inicialmente, se optó por reiniciar como solución, pero era complicado coordinar los reinicios. tenemos que avisar a la sede y esperar a que todos terminaran lo que estuvieran haciendo en todas las terminales. tras ello, se apagaba el sistema y se reiniciaba. si alguien estaba haciendo algo importante para lo que necesitaba una o dos horas, la terminal bloqueada tenía que seguir bloqueada. tras varias semanas de depuración, descubrimos que la causa era un contador de búfer circular desincronizado con su puntero. este búfer controlaba la salida a la terminal. el valor del puntero indicaba que el búfer estaba vacío pero el contador mostraba que estaba lleno. como estaba vacío, no había nada que mostrar; pero como también estaba lleno, no se podía añadir nada al búfer que mostrar en la pantalla. 417sabíamos qué era lo que bloqueaba las terminales pero no qué provocaba la desincronización del búfer circular, por lo que añadimos un truco para resolver el problema. se podían leer los conmutadores del panel frontal en el ordenador (esto fue hace mucho, mucho, mucho tiempo). diseñamos una función de trampa que detectaba si uno de los conmutadores se había generado y después buscábamos un búfer circular que estuviera tanto lleno como vacío. si lo encontrábamos, lo variábamos. ¡ voilá ! la terminal bloqueada volvía a funcionar. de este modo no era necesario reiniciar el sistema si una terminal se bloqueaba. la sede nos llamaba y nos decía que había un bloqueo, nos acercábamos hasta la sala de ordenadores y pulsábamos un conmutador. en ocasiones ellos trabajan los fines de semana pero nosotros no. por ello, añadimos una función al programador que comprobaba los búfer circulares una vez por minuto y restablecía los que estuvieran tanto llenos como vacíos. de este modo se descongestionaban las pantallas antes de que la dirección llegara al teléfono. necesitamos varias semanas de análisis de código de lenguaje de ensamblado antes de localizar al culpable. habíamos calculado que la frecuencia de los bloqueos se debía a un uso desprotegido del búfer circular, así que sólo era necesario determinar el uso fallido. desafortunadamente, esto fue hace mucho tiempo y no disponíamos de herramientas de búsqueda, referencias cruzadas ni de otras técnicas automáticas de ayuda. teníamos que escudriñar los listados. en aquel frío invierno de 1971 en chicago aprendí que los bloqueos basados en el cliente son verdaderamente terribles. bloqueo basado en el servidor la duplicación se puede eliminar si modificamos integeriterator de esta forma: public class integeriteratorserverlocked { private integer nextvalue = 0; public synchronized integer getnextornull() { if (nextvalue < 100000) return nextvalue++; else return null; 418} } y también cambia el código cliente: while (true) { integer nextvalue = iterator.getnextornull(); if (next == null) break; // hacer algo con nextvalue } en este caso, en realidad cambiamos la api de la clase para que sea compatible con el subproceso [120] . el cliente debe realizar una comprobación de null en lugar de comprobar hasnext() . por lo general, el bloqueo basado en el servidor es preferible por estos motivos: reduce el código repetido: el bloqueo basado en el servidor hace que el cliente bloquee correctamente el servidor. al incluir el código de bloqueo en el servidor, se libera a los clientes para usar el objeto y no tener que preocuparse de crear código de bloqueo adicional. permite un mejor rendimiento: puede intercambiar un servidor compatible con subprocesos por otro incompatible en caso de desarrollo de un solo subproceso, lo que evita la sobrecarga. reduce las posibilidades de error: sólo se necesita un programador que se olvide del bloqueo. aplica una única política: la política se aplica solamente al servidor, no a todos los clientes. reduce el ámbito de las variables compartidas: el cliente las desconoce y tampoco sabe cómo se bloquean. todo se oculta en el servidor. cuando se produce un fallo, su origen se busca en menos puntos. ¿y si no es el propietario del código de servidor? usar un adaptador para cambiar la api y añadir bloqueo public class threadsafeintegeriterator { private integeriterator iterator = new integeriterator(); public synchronized integer getnextornull() { 419if(iterator.hasnext()) return iterator.next(); return null; } } mejor todavía, usar colecciones compatibles con subprocesos con interfaces ampliadas. aumentar la producción imagine que desea leer el contenido de una serie de páginas de una lista de url en la red. al leer cada página, la analizamos para acumular estadísticas. después de leer todas, imprimimos un informe de resumen. la siguiente clase devuelve el contenido de una página, dada una url. public class pagereader { //… public string getpagefor(string url) { httpmethod method = new getmethod(url); try { httpclient.executemethod(method); string response = method.getresponsebodyasstring(); return response; } catch (exception e) { handle(e); } finally { method.releaseconnection(); } } } la siguiente clase es el iterador que proporciona el contenido de las páginas en función de un iterador de url: public class pageiterator { private pagereader reader; private urliterator urls; public pageiterator(pagereader reader, urliterator urls) { this.urls = urls; this.reader = reader; } public synchronized string getnextpageornull() { if (urls.hasnext()) getpagefor(urls.next()); 420else return null; } public string getpagefor(string url) { return reader.getpagefor(ur1); } } se puede compartir una instancia de pageiterator entre varios subprocesos distintos, cada uno con su propia instancia de pagereader para leer las páginas que obtiene del iterador. hemos reducido el tamaño del bloque synchronized . simplemente contiene la sección crítica de pageiterator . siempre conviene sincronizar lo menos posible. cálculo de producción de un solo subproceso vayamos con los cálculos. imagine lo siguiente, de acuerdo al argumento anterior: tiempo de e/s para recuperar una página (de media): 1 segundo. tiempo de procesamiento para analizar la página (de media): .5 segundos. e/s requiere 0 por 100 de la cpu mientras que el procesamiento requiere 100 por 100. si se procesan n páginas en un mismo subproceso, el tiempo de ejecución total es de 1.5 segundos * n . en la figura a.1 puede ver una instantánea de 13 páginas, aproximadamente 19.5 segundos. figura a.1. un único subproceso 421cálculo de producción con varios subprocesos si se pueden recuperar páginas en cualquier orden y procesarlas de forma independiente, entonces es posible usar varios subprocesos para aumentar la producción. ¿qué sucede si usamos tres subprocesos? ¿cuántas páginas podemos obtener en el mismo tiempo? como se aprecia en la figura a.2, la solución con varios procesos permite que el análisis de las páginas vinculado al proceso se solape con la lectura de las mismas, vinculada a e/s. en un mundo ideal, significaría que el procesador se utiliza totalmente. cada lectura de página por segundo se solapa con dos análisis. por tanto, podemos procesar dos páginas por segundo, lo que triplica la producción de la solución con un solo proceso. figura a.2. tres subprocesos concurrentes. bloqueo mutuo imagine una aplicación web con dos agrupaciones de recursos compartidos de tamaño finito: una agrupación de conexiones de base de datos para tareas locales de almacenamiento de procesos. 422una agrupación de conexiones mq a un repositorio principal. imagine que hay dos operaciones en la aplicación: crear y actualizar: crear: adquirir una conexión al repositorio principal y la base de datos. comunicarse con el repositorio principal y después almacenar el trabajo local en la base de datos de procesos. actualizar: adquirir una conexión a la base de datos y después al repositorio principal. leer el trabajo de la base de datos y enviarlo al repositorio principal. ¿qué sucede con los usuarios que superan el tamaño de la agrupación? imagine que el tamaño de cada agrupación es 10 . 10 usuarios intentan usar crear, de modo que se adquieren diez conexiones de base de datos y cada subproceso se interrumpe después de esta adquisición pero antes de adquirir una conexión al repositorio principal. 10 usuarios intentan usar actualizar, de modo que se adquieren las diez conexiones al repositorio principal y cada subproceso se interrumpe después de adquirir el repositorio principal pero antes de adquirir una conexión a la base de datos. ahora los 10 subprocesos crear deben esperar a adquirir una conexión al repositorio principal pero los 10 subprocesos actualizar deben esperar a adquirir una conexión a la base de datos. bloqueo mutuo. el sistema no se recupera nunca. puede parecerle una situación improbable pero ¿quién desea un sistema que se colapsa cada semana? ¿quién quiere depurar un sistema con síntomas tan difíciles de reproducir? es el tipo de problema que tarda semanas en resolverse. una solución habitual consiste en añadir instrucciones de depuración para determinar qué sucede. evidentemente, estas instrucciones cambian tanto el código que el bloqueo mutuo se genera en otras situaciones y tarda meses en 423volver a producirse [121] . para solucionar realmente el problema del bloqueo absoluto, debemos entender sus causas. para que se produzca, deben darse cuatro condiciones: exclusión mutua. bloqueo y espera. no expropiación. espera circular. exclusión mutua la exclusión mutua se produce cuando varios subprocesos deben usar los mismos recursos y dichos recursos no se pueden usar en varios subprocesos al mismo tiempo. son de número limitado. un ejemplo típico de este tipo de recurso es una conexión de base de datos, un archivo abierto para escritura, un bloqueo de registro o un semáforo. bloqueo y espera cuando un subproceso adquiere un recurso, no lo libera hasta adquirir los demás recursos que necesita y terminar su trabajo. no expropiación un subproceso no puede adueñarse de los recursos de otro. cuando un subproceso obtiene un recurso, la única forma de que otro lo consiga es que el primero lo libere. espera circular 424también se denomina abrazo mortal. imagine dos subprocesos, t1 y t2, y dos recursos, r1 y r2. t1 tiene r1, t2 tiene r2. t1 también necesita r2 y t2 también necesita r1. es similar al diagrama de la figura a.3: figura a.3. estas cuatro condiciones deben cumplirse para que se produzca un bloqueo mutuo. si se incumple alguna de ellas, no se producirá. evitar la exclusión mutua una estrategia para evitar el bloqueo mutuo es impedir la condición de exclusión mutua, por medio de lo siguiente: usar recursos que permitan un uso simultáneo, como por ejemplo, atomicinteger . incrementar el número de recursos para que sea igual o mayor que el número de subprocesos implicados. comprobar que todos los recursos están libres antes de adquirir ninguno. desafortunadamente, la mayoría de recursos son limitados y no permiten un uso simultáneo, y es habitual que la identidad del segundo recurso se base en los resultados de operar sobre el primero, pero no se desanime, todavía 425quedan tres condiciones. evitar bloqueo y espera también puede eliminar el bloqueo mutuo si rechaza la espera. compruebe cada uno de los recursos antes de obtenerlos y libere todos los recursos y comience de nuevo si detecta uno que esté ocupado. este enfoque genera algunos problemas: inanición: un subproceso no consigue adquirir los recursos que necesita (puede que tenga una combinación exclusiva de recursos que casi nunca esté disponible). bloqueo activo: varios subprocesos pueden actuar al unísono, adquirir un recurso y liberarlo, de forma repetida. es especialmente probable en algoritmos de programación de cpu simples (como dispositivos incrustados o algoritmos de equilibrio de subprocesos escritos a mano). en ambos casos, se puede reducir la producción. el primero reduce la utilización de la cpu, mientras que el segundo genera una elevada utilización de la cpu sin sentido. aunque esta estrategia parezca ineficaz, es mejor que nada. como ventaja, siempre se puede implementar si todo lo demás falla. evitar la expropiación otra estrategia para evitar el bloqueo mutuo consiste en permitir que todos los subprocesos se apropien de los recursos de otros. suele realizarse a través de un sencillo mecanismo de solicitudes. cuando un subproceso descubre que hay un recurso ocupado, le solicita al propietario que lo libere. si el propietario también espera a otro recurso, lo libera y comienza de nuevo. es similar al enfoque anterior, pero, como ventaja, un subproceso puede esperar a un recurso, lo que reduce el número de reinicios. sin embargo, la gestión de todas estas solicitudes puede resultar complicada. 426evitar la espera circular es el enfoque más habitual para impedir el bloqueo mutuo. en la mayoría de sistemas, basta con una sencilla convención acordada entre ambas partes. en el ejemplo anterior del subproceso 1 que quiere tanto el recurso 1 como el 2, y el subproceso 2 que desea tanto el recurso 2 como el 1, al forzar a ambos subprocesos a que asignen los recursos en el mismo orden se imposibilita la espera circular. en general, si todos los subprocesos pueden acordar un orden global de los recursos y si todos asignan los recursos en ese orden, el bloqueo mutuo es imposible. pero como todas las estrategias, también se pueden producir problemas: el orden de adquisición puede no corresponderse al orden de uso; por tanto, un recurso adquirido al inicio puede que no se use hasta el final. esto puede bloquear recursos más tiempo de lo estrictamente necesario. en ocasiones no se puede imponer un orden de adquisición de recursos. si el id del segundo recurso proviene de una operación realizada en el primero, ese orden no es factible. por tanto, existen varias formas de evitar el bloqueo mutuo. algunas provocan inanición, mientras que otras usan la cpu en exceso y reducen la capacidad de respuesta. ¡ tanstaafl ! [122] el aislamiento de la parte relacionada con subprocesos de su solución para permitir ajustes y experimentación es una forma de aprender a determinar las estrategias óptimas. probar código con múltiples subprocesos ¿cómo se puede crear una prueba que demuestre que el siguiente código no es correcto? 01: public class classwiththreadingproblem { 02: int nextid; 03: 42704: public int takenextid() { 05: return nextid++; 06: } 07: } veamos la descripción de una prueba que lo demuestre: recordar el valor actual de nextid . crear dos subprocesos y que cada uno invoque takenextid() una vez. comprobar que el valor de nextid es dos más que el inicial. ejecutar hasta demostrar que nextid sólo se ha incrementado en uno y no en dos. en el listado a-2 se reproduce la prueba: listado a-2 classwiththreadingproblemtest.java. 01: package example; 02: 03: import static org.junit.assert.fail; 04: 05: import org.junit.test; 06: 07: public class classwiththreadingproblemtest { 08: @test 09: public void twothreadsshouldfaileventually() throws exception { 10: final classwiththreadingproblem classwiththreadingproblem = new classwiththreadingproblem(); 11: 12: runnable runnable = new runnable() { 13: public void run() { 14: classwiththreadingproblem.takenextid(); 15: } 16: }; 17: 18: for (int i = 0; i < 50000; ++i) { 19: int startingid = classwiththreadingproblem.lastid; 20: int expectedresult = 2 + startingid; 21: 22: thread t1 = new thread(runnable); 42823: thread t2 = new thread(runnable); 24: t1.start(); 25: t2.start(); 26: t1.join(); 27: t2.join(); 28: 29: int endingid = classwiththreadingproblem.lastid; 30: 31: if (endingid != expectedresult) 32: return; 33: } 34: 35: fail(“should have exposed a threading issue but it did not.”); 36: } 37: } línea descripción 10 crear una sola instancia de classwiththreadingproblem . debemos usar la palabra clave final ya que se usa después en una clase interna anónima. 12-16 crear una clase interna anónima que use la instancia de classwiththreadingproblem . 18 ejecutar este código hasta demostrar que falla, pero no tanto como para que la prueba tarde demasiado. es un acto de equilibrio; no queremos esperar demasiado para demostrar el fallo. elegir la cantidad de ejecuciones es complicado, aunque como veremos después, esta cifra se puede reducir considerablemente. 19 recordar el valor inicial, la prueba intenta demostrar que el código de classwiththreadingproblem es incorrecto. si se supera la prueba, lo habrá demostrado. si la prueba falla, habrá sido incapaz de demostrarlo. 20 esperamos que el valor final sea dos más que el actual. 22-23 crear dos subprocesos que usen el objeto creado en las líneas 12-16. de este modo contamos con dos posibles subprocesos que intentan usar nuestra instancia de classwiththreadingproblem y ambos interfieren entre sí. 24-25 hacer que los dos subprocesos se puedan ejecutar. 42926-27 esperar a que terminen los dos subprocesos antes de comprobar los resultados. 29 registrar el valor final. 31-32 ¿es diferente endingid a lo que esperábamos? en caso afirmativo, se finaliza la prueba; hemos demostrado que el código es incorrecto. en caso negativo, volver a intentarlo. 35 si hemos llegado hasta aquí, la prueba no ha podido demostrar que el código de producción era incorrecto en una cantidad de tiempo razonable; el código ha fallado. o no es incorrecto o no hemos realizado suficientes iteraciones para que se produzca la condición de fallo. esta prueba establece las condiciones de un problema de actualización concurrente. sin embargo, el problema es tan infrecuente que la mayoría de las veces la prueba no lo detecta. en realidad, para detectar el problema debemos establecer el número de iteraciones en más de un millón. incluso con esa cantidad, en diez ejecuciones de un bucle de 1 000 000, el problema sólo apareció una vez, lo que significa que debemos aumentar las iteraciones para obtener fallos fiables. ¿cuánto estamos dispuestos a esperar? aunque ajustáramos la prueba para obtener fallos fiables en un equipo, seguramente tendríamos que ajustarla con otros valores para ilustrar el fallo en otro equipo, sistema operativo o versión de la mvj. y es un problema sencillo . si no podemos demostrarlo, ¿qué pasará cuando detectemos problemas realmente complejos? ¿qué enfoques debemos adoptar para demostrar este sencillo fallo? y, sobre todo, ¿cómo podemos crear pruebas que demuestren fallos en un código más complejo? ¿cómo podremos saber si el código tiene fallos cuando ni siquiera sabemos dónde buscar? veamos algunas sugerencias: pruebas monte carlo: crear pruebas flexibles que se puedan ajustar. después, ejecutarlas repetidamente, por ejemplo, en un servidor de prueba, y cambiar los valores de ajuste aleatoriamente. si las pruebas 430fallan, el código es incorrecto. diseñe las pruebas en las fases iniciales para que un servidor de integración continua las ejecute lo antes posible. registre las condiciones de fallo de las pruebas. ejecutar la prueba en todas las plataformas de desarrollo: de forma repetida y continuada. cuanto más tiempo se ejecuten las pruebas sin fallos, más probable es que el código de producción sea correcto o las pruebas no sean adecuadas para revelar los problemas. ejecutar las pruebas en un equipo con distintas cargas: si puede simular cargas similares a las del entorno de producción, hágalo. sin embargo, aunque realice todos estos pasos, no es probable que detecte problemas de subprocesos en el código. los problemas más complicados son los que sólo se producen una vez cada mil millones de oportunidades. son el azote de los sistemas complejos. herramientas para probar código basado en subprocesos ibm ha creado la herramienta contest [123] . lo que hace es instrumentar las clases para aumentar las probabilidades de que falle el código sin subprocesos. no tenemos relación directa con ibm ni con el equipo que ha desarrollado contest. un colega nos la descubrió. tras varios minutos de usarla, notamos una gran mejoría en la detección de errores. a continuación, le indicamos cómo usar contest: crear pruebas y código de producción, asegurándonos que haya pruebas diseñadas específicamente para simular varios usuarios con diferentes cargas, como mencionamos antes. instrumentar el código de pruebas y producción con contest. ejecutar las pruebas. 431al instrumentar el código con contest, la tasa de éxito pasó de un fallo por cada millón de iteraciones a un fallo en 30 iteraciones. los valores de bucle de las distintas ejecuciones de la prueba tras la instrumentación son los siguientes: 13, 23, 0, 54, 16, 14, 6, 69, 107, 49, 2. evidentemente, las clases instrumentadas fallaban antes y con mayor fiabilidad. conclusión en este capítulo hemos realizado un breve recorrido por el vasto y complejo territorio de la programación concurrente. apenas hemos mostrado la superficie. nos hemos centrado en disciplinas para mantener la limpieza del código concurrente, pero hay mucho más que aprender si tiene pensado diseñar sistemas concurrentes. le recomendamos que empiece por el libro de doug lea concurrent programming in java: design principles and patterns [124] . en este capítulo hemos presentado la actualización concurrente y las disciplinas de sincronización y bloqueo para evitarla. hemos visto cómo los subprocesos pueden mejorar la producción de un sistema vinculado a e/s y las técnicas limpias para lograr dichas mejoras. hemos descrito el bloqueo mutuo y las disciplinas para evitarlo de forma limpia. por último, hemos analizado estrategias para mostrar problemas de concurrencia mediante la instrumentación del código. ejemplos de código completos cliente/servidor sin subprocesos listado a-3 server.java package com.objectmentor.clientserver.nonthreaded; 432import java.io.ioexception; import java.net.serversocket; import java.net.socket; import java.net.socketexception; import common.messageutils; public class server implements runnable { serversocket serversocket; volatile boolean keepprocessing = true; public server(int port, int millisecondstimeout) throws ioexception { serversocket = new serversocket(port); serversocket.setsotimeout(millisecondstimeout); } public void run() { system.out.printf(“server starting\n”); while (keepprocessing) { try { system.out.printf(“accepting client\n”); socket socket = serversocket.accept(); system.out.printf(“got client\n”); process(socket); } catch (exception e) { handle(e); } } } private void handle(exception e) { if (!(e instanceof socketexception)) { e.printstacktrace(); } } public void stopprocessing() { keepprocessing = false; closeignoringexception(serversocket); } void process(socket socket) { if (socket == null) return; try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); 433closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } private void closeignoringexception(socket socket) { if (socket != null) try { socket.close(); } catch (ioexception ignore) { } } private void closeignoringexception(serversocket serversocket) { if (serversocket != null) try { serversocket.close(); } catch (ioexception ignore) { } } } listado a-4 clienttest.java. package com.objectmentor.clientserver.nonthreaded; import java.io.ioexception; import java.net.serversocket; import java.net.socket; import java.net.socketexception; import common.messageutils; public class server implements runnable { serversocket serversocket; volatile boolean keepprocessing = true; public server(int port, int millisecondstimeout) throws ioexception { serversocket = new serversocket(port); serversocket.setsotimeout(millisecondstimeout); } public void run() { system.out.printf(“server starting\n”); while (keepprocessing) { try { system.out.printf(“accepting client\n”); socket socket = serversocket.accept(); system.out.printf(“got client\n”); process(socket); } catch (exception e) { 434handle(e); } } } private void handle(exception e) { if (!(e instanceof socketexception)) { e.printstacktrace(); } } public void stopprocessing() { keepprocessing = false; closeignoringexception(serversocket); } void process(socket socket) { if (socket == null) return; try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } private void closeignoringexception(socket socket) { if (socket != null) try { socket.close(); } catch (ioexception ignore) { } } private void closeignoringexception(serversocket serversocket) { if (serversocket != null) try { serversocket.close(); } catch (ioexception ignore) { } } } listado a-5 435messageutils.java. package common; import java.io.ioexception; import java.io.inputstream; import java.io.objectinputstream; import java.io.objectoutputstream; import java.io.outputstream; import java.net.socket; public class messageutils { public static void sendmessage(socket socket, string message) throws ioexception { outputstream stream = socket.getoutputstream(); objectoutputstream oos = new objectoutputstream(stream); oos.writeutf(message); oos.flush(); } public static string getmessage(socket socket) throws ioexception { inputstream stream = socket.getinputstream(); objectinputstream ois = new objectinputstream(stream); return ois.readutf(); } } cliente/servidor con subprocesos para cambiar el servidor para que use subprocesos basta con cambiar el mensaje process (las nuevas líneas se muestran en negrita para destacarlas): void process(final socket socket) { if (socket == null) return; runnable clienthandler = new runnable() { public void run() { try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } 436}; thread clientconnection = new thread(clienthandler); clientconnection.start(); } 437apéndice b org.jfree.date.serialdate listado b-1 serialdate.java 1 /*============================================================== 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 *============================================================== 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia 17 * pública general gnu si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110- 1301, 22 * ee.uu. 23 * 43824 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ------------------ 28 * serialdate.java 29 * ------------------ 30 * (c) copyright 2001-2005, de object refinery limited. 31 * 32 * autor original: david gilbert (para object refinery limited); 33 * colaborador(es): -; 34 * 35 * $id: serialdate.java,v 1.7 2005/11/03 09:25:17 mungady exp $ 36 * 37 * cambios (11-oct-2001) 38 * -------------------------------------- 39 * 11-oct-2001: reorganización de la clase y cambio a un nuevo paquete 40 * com.jrefinery.date (dg); 41 * 05-nov-2001: se añade un método getdescription() y se elimina la clase 42 * notabledate (dg); 43 * 12-nov-2001: ibd requiere el método setdescription(), una vez eliminada la clase 44 * notabledate (dg); se cambian getpreviousdayofweek(), 45 * getfollowingdayofweek() y getnearestdayofweek() para corregir 46 * errores (dg); 47 * 05-dic-2001: error corregido en la clase spreadsheetdate (dg); 48 * 29-may-2002: se transfieren las constantes de mes a una interfaz independiente 49 * (monthconstants) (dg); 50 * 27-ago-2002: error corregido en el método addmonths(), gracias a nálevka petr (dg); 51 * 03-oct-2002: errores indicados por checkstyle (dg) corregidos; 52 * 13-mar-2003: implementación de serializable (dg); 53 * 29-may-2003: error corregido en el método addmonths (dg); 54 * 04-sep-2003: implementación de comparable. actualización de los javadoc isinrange (dg); 55 * 05-ene-2005: error corregido en el método addyears() (1096282) (dg); 56 * 57 */ 58 59 package org.jfree.date; 60 61 import java.io.serializable; 62 import java.text.dateformatsymbols; 63 import java.text.simpledateformat; 64 import java.util.calendar; 65 import java.util.gregoriancalendar; 43966 67 /** 68 * clase abstracta que define nuestros requisitos para manipular fechas, 68 * sin limitación a una determinada implementación. 70 * <p> 71 * requisito 1: coincidir al menos con el procesamiento de fechas en excel; 72 * requisito 2: la clase es inmutable; 73 * <p> 74 * ¿por qué no usar java.util.date? lo haremos, cuando tenga sentido. en ocasiones, 75 * java.util.date puede ser demasiado precisa; representa un instante en el tiempo, 76 * con una precisión de 1/1000 de segundo (y la fecha depende de la 77 * zona horaria). en ocasiones sólo querremos representar un día concreto (como el 21 78 * de enero de 2015) sin preocuparnos de la hora del día, la 79 * zona horaria u otros aspectos. para eso hemos definido daydate. 80 * <p> 81 * puede invocar getinstance() para obtener una subclase concreta de serialdate, 82 * sin preocuparse de su implementación exacta 83 * 84 * @author david gilbert 85 */ 86 public abstract class serialdate implements comparable, 87 serializable, 88 monthconstants { 89 90 /** para serialización. */ 91 private static final long serialversionuid = -293716040467423637l; 92 93 /** símbolos de formato de fecha. */ 94 public static final dateformatsymbols 95 date_format_symbols = new simpledateformat().getdateformatsymbols(); 96 97 /** número de serie para el 1 de enero de 1900. */ 98 public static final int serial_lower_bound = 2; 99 100 /** número de serie para el 31 de diciembre de 9999. */ 101 public static final int serial_upper_bound = 2958465; 102 103 /** valor de año más bajo admitido por este formato de fecha. */ 104 public static final int minimum_year_supported = 1900; 105 106 /** valor de año más alto admitido por este formato de fecha. */ 440107 public static final int maximum_year_supported = 9999; 108 109 /** constante útil para lunes; equivale a java.util.calendar.monday. */ 110 public static final int monday = calendar.monday; 111 112 /** 113 * constante útil para martes; equivale a java.util.calendar.tuesday. 114 * / 115 public static final int tuesday = calendar.tuesday; 116 117 /** 118 * constante útil para miércoles; equivale a 119 * java.util.calendar.wednesday. 120 */ 121 public static final int wednesday = calendar.wednesday; 122 123 /** 124 * constante útil para jueves; equivale a java.util.calendar.thursday. 125 */ 126 public static final int thursday = calendar.thursday; 127 128 /** constante útil para viernes; equivale a java.util.calendar.friday. */ 129 public static final int friday = calendar.friday; 130 131 /** 132 * constante útil para sábado; equivale a java.util.calendar.saturday. 133 */ 134 public static final int saturday = calendar.saturday; 135 136 /** constante útil para domingo; equivale a java.util.calendar.sunday. */ 137 public static final int sunday = calendar.sunday; 138 139 /** número de días de cada mes en años no bisiestos. */ 140 static final int[] last_day_of_month = 141 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 142 143 /** número de días en un año (no bisiesto) hasta el final de cada mes. */ 144 static final int[] aggregate_days_to_end_of_month = 145 {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 146 147 /** número de días en un año hasta el final del mes anterior. */ 148 static final int[] aggregate_days_to_end_of_preceding_month = 441149 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 150 151 /** número de días en un año bisiesto hasta el final de cada mes. */ 152 static final int[] leap_year_aggregate_days_to_end_of_month = 153 {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 154 155 /** 156 * número de días en un año bisiesto hasta el final del mes anterior. 157 */ 158 static final int[] 159 leap_year_aggregate_days_to_end_of_preceding_month = 160 {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 161 162 /** una constante útil para hacer referencia a la primera semana del mes. */ 163 public static final int first_week_in_month = 1; 164 165 /** una constante útil para hacer referencia a la segunda semana del mes. */ 166 public static final int second_week_in_month = 2; 167 168 /** una constante útil para hacer referencia a la tercera semana del mes. */ 169 public static final int third_week_in_month = 3; 170 171 /** una constante útil para hacer referencia a la cuarta semana del mes. */ 172 public static final int fourth_week_in_month = 4; 173 174 /** una constante útil para hacer referencia a la última semana del mes. */ 175 public static final int last_week_in_month = 0; 176 177 /** constante de intervalo. */ 178 public static final int include_none = 0; 179 180 /** constante de intervalo. */ 181 public static final int include_first = 1; 182 183 /** constante de intervalo. */ 184 public static final int include_second = 2; 185 186 /** constante de intervalo. */ 187 public static final int include_both = 3; 188 189 /** 442190 * constante útil para especificar un día de la semana con respecto a una fecha 191 * fija. 192 */ 193 public static final int preceding = -1; 194 195 /** 196 * constante útil para especificar un día de la semana con respecto a una fecha 197 * fija. 198 */ 199 public static final int nearest = 0; 200 201 /** 202 * constante útil para especificar un día de la semana con respecto a una fecha 203 * fija. 204 */ 205 public static final int following = 1; 206 207 /** una descripción para la fecha. */ 208 private string description; 209 210 /** 211 * constructor predeterminado. 212 */ 213 protected serialdate() { 214 } 215 216 /** 217 * devuelve <code>true</code> si el código entero proporcionado representa un 218 * día de la semana válido y <code>false</code> en caso contrario. 219 * 220 * @param code el código del que se comprueba la validez. 221 * 222 * @return <code>true</code> si el código entero proporcionado representa un 223 * día de la semana válido y <code>false</code> en caso contrario. 224 */ 225 public static boolean isvalidweekdaycode(final int code) { 227 switch(code) { 228 case sunday: 229 case monday: 230 case tuesday: 231 case wednesday: 443232 case thursday: 233 case friday: 234 case saturday: 235 return true; 236 default: 237 return false; 238 } 239 240 } 241 242 /** 243 * convierte la cadena proporcionada en un día de la semana. 244 * 245 * @param s una cadena que representa el día de la semana. 246 * 247 * @return <code>-1</code> si la cadena no se puede convertir o el día de 248 * la semana en caso contrario. 249 */ 250 public static int stringtoweekdaycode(string s) { 251 252 final string[] shortweekdaynames 253 = date_format_symbols.getshortweekdays(); 254 final string[] weekdaynames = date_format_symbols.getweekdays(); 255 256 int result = -1; 257 s = s.trim(); 258 for (int i = 0; i < weekdaynames.length; i++) { 259 if (s.equals(shortweekdaynames[i])) { 260 result = i; 261 break; 262 } 263 if (s.equals(weekdaynames[i])) { 264 result = i; 265 break; 266 } 267 } 268 return result; 269 270 } 271 272 /** 273 * devuelve una representación en cadena del día de la semana proporcionado. 274 * <p> 275 * necesitamos un enfoque mejor. 444276 * 277 * @param weekday el día de la semana. 278 * 279 * @return una cadena que representa el día de la semana proporcionado. 280 */ 281 public static string weekdaycodetostring(final int weekday) { 282 283 final string[] weekdays = date_format_symbols.getweekdays(); 284 return weekdays[weekday]; 285 286 } 287 288 /** 289 * devuelve una matriz de nombres de mes. 290 * 291 * @return una matriz de nombres de mes. 292 */ 293 public static string[] getmonths() { 294 295 return getmonths(false); 296 297 } 298 299 /** 300 * devuelve una matriz de nombres de mes. 301 * 302 * @param shortened un indicador para indicar que deben devolverse los nombres 303 * de mes en formato reducido. 304 * 305 * @return una matriz de nombres de mes. 306 */ 307 public static string[] getmonths(final boolean shortened) { 308 309 if (shortened) { 310 return date_format_symbols.getshortmonths(); 311 } 312 else { 313 return date_format_symbols.getmonths(); 314 } 315 316 } 317 318 /** 319 * devuelve true si el código entero proporcionado representa un mes 445válido. 320 * 321 * @param code el código del que se comprueba la validez. 322 * 323 * return <code>true</code> si el código entero proporcionado representa un 324 * mes válido. 325 */ 326 public static boolean isvalidmonthcode(final int code) { 327 328 switch(code) { 329 case january: 330 case february: 331 case march: 332 case april: 333 case may: 334 case june: 335 case july: 336 case august: 337 case september: 338 case october: 339 case november: 340 case december: 341 return true; 342 default: 343 return false; 344 } 345 346 } 347 348 /** 349 * devuelve el trimestre del mes especificado. 350 * 351 * @param code el código del mes (1-12). 352 * 353 * @return el trimestre al que pertenece el mes. 354 * @throws java.lang.illegalargumentexception 355 */ 356 public static int monthcodetoquarter(final int code) { 357 358 switch(code) { 359 case january: 360 case february: 361 case march: return 1; 362 case april: 446363 case may: 364 case june: return 2; 365 case july: 366 case august: 367 case september: return 3; 368 case october: 369 case november: 370 case december: return 4; 371 default: throw new illegalargumentexception( 372 “serialdate.monthcodetoquarter: invalid month code.”); 373 } 374 375 } 376 377 /** 378 * devuelve una cadena que representa el mes proporcionado. 379 * <p> 380 * la cadena devuelta es la forma extensa del nombre del mes obtenido de la 381 * configuración regional. 382 * 383 * @param month el mes. 384 * 385 * @return una cadena que representa el mes proporcionado 386 */ 387 public static string monthcodetostring(final int month) { 388 389 return monthcodetostring(month, false); 390 391 } 392 393 /** 394 * devuelve una cadena que representa el mes proporcionado. 395 * <p> 396 * la cadena devuelta es la forma extensa o reducida del nombre del mes 397 * obtenido de la configuración regional. 398 * 399 * @param month el mes. 400 * @param shortened si <code>true</code> devuelve la abreviatura del 401 * mes. 402 * 403 * @return una cadena que representa el mes proporcionado. 404 * @throws java.lang.illegalargumentexception 405 */ 406 public static string monthcodetostring(final int month, 447407 final boolean shortened) { 408 409 // comprobar argumentos… 410 if (!isvalidmonthcode(month)) { 411 throw new illegalargumentexception( 412 “serialdate.monthcodetostring: month outside valid range.”); 413 } 414 415 final string[] months; 416 417 if (shortened) { 418 months = date_format_symbols.getshortmonths(); 419 } 420 else { 421 months = date_format_symbols.getmonths(); 422 } 423 424 return months[month - 1]; 425 426 } 427 428 /** 429 * convierte una cadena en el código del mes. 430 * <p> 431 * este método devuelve una de las constantes january, february, …, 432 * december correspondientes a la cadena. si la cadena no se 433 * reconoce, este método devuelve -1. 434 * 435 * @param s la cadena que analizar. 436 * 437 * @return <code>-1</code> si la cadena no se puede analizar, o el mes del 438 * año en caso contrario. 439 */ 440 public static int stringtomonthcode(string s) { 441 442 final string[] shortmonthnames = date_format_symbols.getshortmonths(); 443 final string[] monthnames = date_format_symbols.getmonths(); 444 445 int result = -1; 446 s = s.trim(); 447 448 // primero intentar analizar la cadena como entero (1-12)… 449 try { 450 result = integer.parseint(s); 448451 } 452 catch (numberformatexception e) { 453 // suprimir 454 } 455 456 // buscar por los nombres de los meses… 457 if ((result < 1) || (result > 12)) { 458 for (int i = 0; i < monthnames.length; i++) { 459 if (s.equals(shortmonthnames[i])) { 460 result = i + 1; 461 break; 462 } 463 if (s.equals(monthnames[i])) { 464 result = i + 1; 465 break; 466 } 467 } 468 } 469 470 return result; 471 472 } 473 474 /** 475 * devuelve true si el código entero proporcionado representa una semana 476 * del mes válida y false en caso contrario 477 * 478 * @param code el código del que se comprueba la validez. 479 * @return <code>true</code> si el código entero proporcionado representa una 480 * semana del mes válida. 481 */ 482 public static boolean isvalidweekinmonthcode(final int code) { 483 484 switch(code) { 485 case first_week_in_month: 486 case second_week_in_month: 487 case third_week_in_month: 488 case fourth_week_in_month: 489 case last_week_in_month: return true; 490 default: return false; 491 } 492 493 } 449494 495 /** 496 * determina si el año especificado es bisiesto o no. 497 * 498 * @param yyyy el año (entre 1900 y 9999). 499 * 500 * @return <code>true</code> si el año especificado es bisiesto. 501 */ 502 public static boolean isleapyear(final int yyyy) { 503 504 if ((yyyy % 4) != 0) { 505 return false; 506 } 507 else if ((yyyy % 400) == 0) { 508 return true; 509 } 510 else if ((yyyy % 100) == 0) { 511 return false; 512 } 513 else { 514 return true; 515 } 516 517 } 518 519 /** 520 * devuelve el número de años bisiestos desde 1900 hasta el año especificado 521 * inclusive. 522 * <p> 523 * 1900 no es un año bisiesto. 524 * 525 * @param yyyy el año (entre 1900 y 9999). 526 * 527 * @return el número de años bisiestos desde 1900 hasta el año especificado. 528 */ 529 public static int leapyearcount(final int yyyy) { 530 531 final int leap4 = (yyyy - 1896) / 4; 532 final int leap100 = (yyyy - 1800) / 100; 533 final int leap400 = (yyyy - 1600) / 400; 534 return leap4 - leap100 + leap400; 535 536 } 537 450538 /** 539 * devuelve el número del último día del mes, teniendo en cuenta los 540 * años bisiestos. 541 * 542 * @param month el mes. 543 * @param yyyy el año (entre 1900 y 9999). 544 * 545 * @return el número del último día del mes. 546 */ 547 public static int lastdayofmonth(final int month, final int yyyy) { 548 549 final int result = last_day_of_month[month]; 550 if (month != february) { 551 return result; 552 } 553 else if (isleapyear(yyyy)) { 554 return result + 1; 555 } 556 else { 557 return result; 558 } 559 560 } 561 562 /** 563 * crea una nueva fecha añadiendo el número especificado de días a la fecha 564 * base. 565 * 566 * @param days el número de días que añadir (puede ser negativo). 567 * @param base la fecha base. 568 * 569 * @return una nueva fecha. 570 */ 571 public static serialdate adddays(final int days, final serialdate base) { 572 573 final int serialdaynumber = base.toserial() + days; 574 return serialdate.createinstance(serialdaynumber); 575 576 } 577 578 /** 579 * crea una nueva fecha añadiendo el número especificado de meses a la fecha 580 * base. 451581 * <p> 582 * si la fecha base es próxima al final del mes, el día del resultado 583 * se puede ajustar ligeramente: 31 mayo + 1 mes = 30 junio. 584 * 585 * @param months el número de meses que añadir (puede ser negativo). 586 * @param base la fecha base. 587 * 588 * @return una nueva fecha. 589 */ 590 public static serialdate addmonths(final int months, 591 final serialdate base) { 592 593 final int yy = (12 * base.getyyyy() + base.getmonth() + months - 1) 594 / 12; 595 final int mm = (12 * base.getyyyy() + base.getmonth() + months – 1) 596 % 12 + 1; 597 final int dd = math.min( 598 base.getdayofmonth(), serialdate.lastdayofmonth(mm, yy) 599 ); 600 return serialdate.createinstance(dd, mm, yy); 601 602 } 603 604 /** 605 * crea una nueva fecha añadiendo el número especificado de años a la fecha 606 * base. 607 * 608 * @param years el número de años que añadir (puede ser negativo). 609 * @param base la fecha base. 610 * 611 * @return una nueva fecha. 612 */ 613 public static serialdate addyears(final int years, final serialdate base) { 614 615 final int basey = base.getyyyy(); 616 final int basem = base.getmonth(); 617 final int based = base.getdayofmonth(); 618 619 final int targety = basey + years; 620 final int targetd = math.min( 621 based, serialdate.lastdayofmonth(basem, targety) 622 ); 623 624 return serialdate.createinstance(targetd, basem, targety); 452625 626 } 627 628 /** 629 * devuelve la última fecha correspondiente al día de la semana especificado y 630 * anterior a la fecha base. 631 * 632 * @param targetweekday un código para el día de la semana de destino. 633 * @param base la fecha base. 634 * 635 * @return la última fecha correspondiente al día de la semana especificado y 636 * anterior a la fecha base. 637 */ 638 public static serialdate getpreviousdayofweek(final int targetweekday, 639 final serialdate base) { 640 641 // comprobar argumentos… 642 if (!serialdate.isvalidweekdaycode(targetweekday)) { 643 throw new illegalargumentexception( 644 “invalid day-of-the-week code.” 645 ); 646 } 647 648 // buscar la fecha… 649 final int adjust; 650 final int basedow = base.getdayofweek(); 651 if (basedow > targetweekday) { 652 adjust = math.min(0, targetweekday - basedow); 653 } 654 else { 655 adjust = -7 + math.max(0, targetweekday - basedow); 656 } 657 658 return serialdate.adddays(adjust, base); 659 660 } 661 662 /** 663 * devuelve la primera fecha que coincide con el día de la semana especificado 664 * y posterior a la fecha base. 665 * 666 * @param targetweekday un código para el día de la semana de destino. 453667 * @param base la fecha base. 668 * 669 * @return la primera fecha que coincide con el día de la semana especificado 670 * y posterior a la fecha base. 671 */ 672 public static serialdate getfollowingdayofweek(final int targetweekday, 673 final serialdate base) { 674 675 // comprobar argumentos… 676 if (!serialdate.isvalidweekdaycode(targetweekday)) { 677 throw new illegalargumentexception( 678 “invalid day-of-the-week code.” 679 ); 680 } 681 682 // buscar la fecha… 683 final int adjust; 684 final int basedow = base.getdayofweek(); 685 if (basedow > targetweekday) { 686 adjust = 7 + math.min(0, targetweekday - basedow); 687 } 688 else { 689 adjust = math.max(0, targetweekday - basedow); 690 } 691 692 return serialdate.adddays(adjust, base); 693 } 694 695 /** 696 * devuelve la fecha que coincide con el día de la semana especificado y más 697 * próxima a la fecha base. 698 * 699 * @param targetdow un código para el día de la semana de destino. 700 * @param base la fecha base. 701 * 702 * @return la fecha que coincide con el día de la semana especificado y más 703 * próxima a la fecha base. 704 */ 705 public static serialdate getnearestdayofweek(final int targetdow, 706 final serialdate base) { 707 708 // comprobar argumentos… 454709 if (!serialdate.isvalidweekdaycode(targetdow)) { 710 throw new illegalargumentexception( 711 “invalid day-of-the-week code.” 712 ); 713 } 714 715 // buscar la fecha… 716 final int basedow = base.getdayofweek(); 717 int adjust = -math.abs(targetdow - basedow); 718 if (adjust >= 4) { 719 adjust = 7 - adjust; 720 } 721 if (adjust <= -4) { 722 adjust = 7 + adjust; 723 } 724 return serialdate.adddays(adjust, base); 725 726 } 727 728 /** 729 * avanzar la fecha hasta el último día del mes. 730 * 731 * @param base la fecha base. 732 * 733 * @return una nueva fecha de serie. 734 */ 735 public serialdate getendofcurrentmonth(final serialdate base) { 736 final int last = serialdate.lastdayofmonth( 737 base.getmonth(), base.getyyyy() 738 ); 739 return serialdate.createinstance(last, base.getmonth(), base.getyyyy()); 740 } 741 742 /** 743 * devuelve una cadena correspondiente al código de la semana del mes. 744 * <p> 745 * necesitamos un enfoque mejor. 746 * 747 * @param count un código entero que representa la semana del mes. 748 * 749 * @return una cadena correspondiente al código de la semana del mes. 750 */ 751 public static string weekinmonthtostring(final int count) { 752 455753 switch (count) { 754 case serialdate.first_week_in_month : return “first”; 755 case serialdate.second_week_in_month : return “second”; 756 case serialdate.third_week_in_month : return “third”; 757 case serialdate.fourth_week_in_month : return “fourth”; 758 case serialdate.last_week_in_month : return “last”; 759 default : 760 return “serialdate.weekinmonthtostring(): invalid code.”; 761 } 762 763 } 764 765 /** 766 * devuelve una cadena que representa el valor ‘relativo’ proporcionado. 767 * <p> 768 * necesitamos un enfoque mejor. 769 * 770 * @param relative una constante que representa el valor ‘relativo’. 771 * 772 * @return una cadena que representa el valor ‘relativo’ proporcionado. 773 */ 774 public static string relativetostring(final int relative) { 775 776 switch (relative) { 777 case serialdate.preceding : return “preceding”; 778 case serialdate.nearest : return “nearest”; 779 case serialdate.following : return “following”; 780 default : return “error : relative to string”; 781 } 782 783 } 784 785 /** 786 * método de factoría que devuelve una instancia de una subclase concreta de 787 * {@link serialdate}. 788 * 789 * @param day el día (1-31). 790 * @param month el mes (1-12). 791 * @param yyyy el año (entre 1900 y 9999). 792 * 793 * @return una instancia de {@link serialdate} 794 */ 795 public static serialdate createinstance(final int day, final int 456month, 796 final int yyyy) { 797 return new spreadsheetdate(day, month, yyyy); 798 } 799 800 /** 801 * método de factoría que devuelve una instancia de una subclase concreta de 802 * {@link serialdate}. 803 * 804 * @param serial numero de serie del día (1 de enero de 1900 = 2). 805 * 806 * @return una instancia de serialdate. 807 */ 808 public static serialdate createinstance(final int serial) { 809 return new spreadsheetdate(serial); 810 } 811 812 /** 813 * método de factoría que devuelve una instancia de una subclase de serialdate. 814 * 815 * @param date un objeto de fecha de java. 816 * 817 * @return una instancia de serialdate. 818 */ 818 public static serialdate createinstance(final java.util.date date) { 820 821 final gregoriancalendar calendar = new gregoriancalendar(); 822 calendar.settime(date); 823 return new spreadsheetdate(calendar.get(calendar.date), 824 calendar.get(calendar.month) + 1, 825 calendar.get(calendar.year)); 826 827 } 828 829 /** 830 * devuelve el número de serie de la fecha, siendo el 1 de enero de 1900 = 2 (se 831 * corresponde, casi totalmente, al sistema de numeración empleado en microsoft 832 * excel para windows y lotus 1-2-3). 833 * 834 * @return el número de serie de la fecha. 835 */ 836 public abstract int toserial(); 457837 838 /** 839 * devuelve java.util.date. como java.util.date tiene mayor precisión que 840 * serialdate, debemos definir una convención para “la hora del día”. 841 * 842 * @return this como <code>java.util.date</code>. 843 */ 844 public abstract java.util.date todate(); 845 846 /** 847 * devuelve una descripción de la fecha. 848 * 849 * @return una descripción de la fecha. 850 */ 851 public string getdescription() { 852 return this.description; 853 } 854 855 /** 856 * establece la descripción de la fecha. 857 * 858 * @param description la nueva descripción de la fecha. 859 */ 860 public void setdescription(final string description) { 861 this.description = description; 862 } 863 864 /** 865 * convierte la fecha en una cadena. 866 * 867 * @return una representación en cadena de la fecha. 868 */ 869 public string tostring() { 870 return getdayofmonth() + “-” + serialdate.monthcodetostring(getmonth()) 871 + “-” + getyyyy(); 872 } 873 874 /** 875 * devuelve el año (con un intervalo válido de 1900 a 9999). 876 * 877 * @return el año. 878 */ 879 public abstract int getyyyy(); 880 458881 /** 882 * devuelve el mes (enero = 1, febrero = 2, marzo = 3). 883 * 884 * @return el mes del año. 885 */ 886 public abstract int getmonth(); 887 888 /** 889 * devuelve el día del mes. 890 * 891 * @return el día del mes. 892 */ 893 public abstract int getdayofmonth(); 894 895 /** 896 * devuelve el día de la semana. 897 * 898 * @return el día de la semana. 899 */ 900 public abstract int getdayofweek(); 901 902 /** 903 * devuelve la diferencia (en días) entre esta fecha y la 904 * ‘otra’ fecha especificada. 905 * <p> 906 * el resultado es positivo si esta fecha es posterior a la ‘otra’ y 907 * negativo si es anterior. 908 * 909 * @param other la fecha con la que se compara. 910 * 911 * @return la diferencia entre esta fecha y la otra. 912 */ 913 public abstract int compare(serialdate other); 914 915 /** 916 * devuelve true si esta serialdate representa la misma fecha que la 917 * serialdate especificada. 918 * 919 * @param other la fecha con la que se compara. 920 * 921 * @return <code>true</code> si esta serialdate representa la misma fecha que 922 * la serialdate especificada. 923 */ 924 public abstract boolean ison(serialdate other); 459925 926 /** 927 * devuelve true si esta serialdate representa una fecha anterior en 928 * comparación a la serialdate especificada. 929 * 930 * @param other la fecha con la que se compara. 931 * 932 * @return <code>true</code> si esta serialdate representa una fecha anterior 933 * en comparación a la serialdate especificada. 934 */ 935 public abstract boolean isbefore(serialdate other); 936 937 /** 938 * devuelve true si esta serialdate representa la misma fecha que la 939 * serialdate especificada. 940 * 941 * @param other la fecha con la que se compara. 942 * 943 * @return <code>true</code> si esta serialdate representa la misma fecha 944 * que la serialdate especificada. 945 */ 946 public abstract boolean isonorbefore(serialdate other); 947 948 /** 949 * devuelve true si esta serialdate representa la misma fecha que la 950 * serialdate especificada. 951 * 952 * @param other la fecha con la que se compara. 953 * 954 * @return <code>true</code> si esta serialdate representa la misma fecha 955 * que la serialdate especificada. 956 */ 957 public abstract boolean isafter(serialdate other); 958 959 /** 960 * devuelve true si esta serialdate representa la misma fecha que la 961 * serialdate especificada. 962 * 963 * @param other la fecha con la que se compara. 964 * 965 * @return <code>true</code> si esta serialdate representa la misma fecha 966 * que la serialdate especificada. 460967 */ 968 public abstract boolean isonorafter(serialdate other); 969 970 /** 971 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 972 * rango especificado (inclusive). el orden de fecha de d1 y d2 no es 973 * importante. 974 * 975 * @param d1 fecha límite del rango. 976 * @param d2 la otra fecha límite del rango. 977 * 978 * @return un valor booleano. 979 */ 980 public abstract boolean isinrange(serialdate d1, serialdate d2); 981 982 /** 983 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 984 * rango especificado (el invocador especifica si los puntos finales se 985 * incluyen o no). el orden de fecha de d1 y d2 no es importante. 986 * 987 * @param d1 fecha límite del rango. 988 * @param d2 la otra fecha límite del rango. 989 * @param include un código que controla si las fechas inicial y final 990 * se incluyen o no en el rango. 991 * 992 * @return un valor booleano. 993 */ 994 public abstract boolean isinrange(serialdate d1, serialdate d2, 995 int include); 996 997 /** 998 * devuelve la última fecha que coincide con el día de la semana especificado y 999 * que es anterior a esta fecha. 1000 * 1001 * @param targetdow un código para el día de la semana de destino. 1002 * 1003 * @return la última fecha que coincide con el día de la semana especificado y 1004 * que es anterior a esta fecha. 1005 */ 1006 public serialdate getpreviousdayofweek(final int targetdow) { 1007 return getpreviousdayofweek(targetdow, this); 1008 } 1009 4611010 /** 1011 * devuelve la primera fecha que coincide con el día de la semana especificado 1012 * y que es posterior a esta fecha. 1013 * 1014 * @param targetdow un código para el día de la semana de destino. 1015 * 1016 * @return la primera fecha que coincide con el día de la semana especificado 1017 * que es posterior a esta fecha. 1018 */ 1019 public serialdate getfollowingdayofweek(final int targetdow) { 1020 return getfollowingdayofweek(targetdow, this); 1021 } 1022 1023 /** 1024 * devuelve la fecha más próxima que coincide con el día de la semana especificado. 1025 * 1026 * @param targetdow un código para el día de la semana de destino. 1027 * 1028 * @return la fecha más próxima que coincide con el día de la semana especificado. 1029 */ 1030 public serialdate getnearestdayofweek(final int targetdow) { 1031 return getnearestdayofweek(targetdow, this); 1032 } 1033 1034 } listado b-2 serialdatetest.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del projecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 46212 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ------------------------- 28 * serialdatetests.java 29 * ------------------------- 30 * (c) copyright 2001-2005, por object refinery limited. 31 32 * autor original: david gilbert (por object refinery limited); 33 * colaborador(es): -; 34 35 * $id: serialdatetests.java,v 1.6 2005/11/16 15:58:40 taqua exp $ 36 37 * cambios 38 * ----------- 39 * 15-nov-2001: version 1 (dg); 40 * 25-jun-2002: se elimina la importación innecesaria (dg); 41 * 24-oct-2002: errores indicados checkstyle corregidos (dg); 42 * 13-mar-2003: se añade prueba de serialización (dg); 43 * 05-jan-2005: se añade prueba para el informe de errores 1096282 (dg); 44 * 45 */ 46 47 package org.jfree.date.junit; 48 49 import java.io.bytearrayinputstream; 50 import java.io.bytearrayoutputstream; 51 import java.io.objectinput; 52 import java.io.objectinputstream; 53 import java.io.objectoutput; 54 import java.io.objectoutputstream; 55 46356 import junit.framework.test; 57 import junit.framework.testcase; 58 import junit.framework.testsuite; 59 60 import org.jfree.date.monthconstants; 61 import org.jfree.date.serialdate; 62 63 /** 64 * pruebas junit para la clase {@link serialdate}. 65 */ 66 public class serialdatetests extends testcase { 67 68 /** fecha que representa 9 de noviembre. 69 private serialdate nov9y2001; 70 71 /** 72 * crea un nuevo caso de prueba. 73 * 74 * @param name el nombre. 75 */ 76 public serialdatetests(final string name) { 77 super(name); 78 } 79 80 /** 81 * devuelve una suite de pruebas para el ejecutor de pruebas junit. 82 * 83 * @return la suite de pruebas. 84 */ 85 public static test suite() { 86 return new testsuite(serialdatetests.class); 87 } 88 89 /** 90 * problema. 91 */ 92 protected void setup() { 93 this.nov9y2001 = serialdate.createinstance(9, monthconstants.november, 2001); 94 } 95 96 /** 97 * 9 nov 2001 más dos meses debe ser 9 ene 2002. 98 */ 99 public void testaddmonthsto9nov2001() { 464100 final serialdate jan9y2002 = serialdate.addmonths(2, this.nov9y2001); 101 final serialdate answer = serialdate.createinstance(9, 1, 2002); 102 assertequals(answer, jan9y2002); 103 } 104 105 /** 106 * caso de prueba de un error, ya corregido. 107 */ 108 public void testaddmonthsto5oct2003() { 109 final serialdate d1 = serialdate.createinstance(5, monthconstants.october, 2003); 110 final serialdate d2 = serialdate.addmonths(2, d1); 111 assertequals(d2, serialdate.createinstance(5, monthconstants.december, 2003)); 112 } 113 114 /** 115 * caso de prueba de un error, ya corregido. 116 */ 117 public void testaddmonthsto1jan2003() { 118 final serialdate d1 = serialdate.createinstance(1, monthconstants.january, 2003); 119 final serialdate d2 = serialdate.addmonths(0, d1); 120 assertequals(d2, d1); 121 } 122 123 /** 124 * el lunes anterior al viernes 9 de noviembre de 2001 debe ser el 5 de noviembre. 125 */ 126 public void testmondayprecedingfriday9nov2001() { 127 serialdate mondaybefore = serialdate.getpreviousdayofweek( 128 serialdate.monday, this.nov9y2001 129 ); 130 assertequals(5, mondaybefore.getdayofmonth()); 131 } 132 133 /** 134 * el lunes posterior al viernes 9 de noviembre de 2001 debe ser el 12 de noviembre. 135 */ 136 public void testmondayfollowingfriday9nov2001() { 137 serialdate mondayafter = serialdate.getfollowingdayofweek( 138 serialdate.monday, this.nov9y2001 139 ); 465140 assertequals(12, mondayafter.getdayofmonth()); 141 } 142 143 /** 144 * el lunes más próximo al viernes 9 de noviembre de 2001 debe ser el 12 de noviembre. 145 */ 146 public void testmondaynearestfriday9nov2001() { 147 serialdate mondaynearest = serialdate.getnearestdayofweek( 148 serialdate.monday, this.nov9y2001 149 ); 150 assertequals(12, mondaynearest.getdayofmonth()); 151 } 152 153 /** 154 * el lunes más próximo al 22 de enero de 1970 cae en el 19. 155 */ 156 public void testmondaynearest22jan1970() { 157 serialdate jan22y1970 = serialdate.createinstance(22, monthconstants.january, 1970); 158 serialdate mondaynearest = serialdate.getnearestdayofweek(serialdate.monday, jan22y1970); 159 assertequals(19, mondaynearest.getdayofmonth()); 160 } 161 162 /** 163 * el problema es que la conversión de días en cadenas devuelva el resultado 164 * correcto. en realidad este resultado depende de la configuración regional. 165 */ 166 public void testweekdaycodetostring() { 167 168 final string test = serialdate.weekdaycodetostring(serialdate.saturday); 169 assertequals(“saturday”, test); 170 171 } 172 173 /** 174 * probar la conversión de una cadena en día de la semana. esta prueba falla si 175 * la configuración regional predeterminada no usa nombres de días en inglés 176 */ 177 public void teststringtoweekday() { 178 466179 int weekday = serialdate.stringtoweekdaycode(“wednesday”); 180 assertequals(serialdate.wednesday, weekday); 181 182 weekday = serialdate.stringtoweekdaycode(“ wednesday ”); 183 assertequals(serialdate.wednesday, weekday); 184 185 weekday = serialdate.stringtoweekdaycode(“wed”); 186 assertequals(serialdate.wednesday, weekday); 187 188 } 189 190 /** 191 * probar la conversión de una cadena en mes. esta prueba falla si la 192 * configuración regional predeterminada no usa nombres de días en inglés 193 */ 194 public void teststringtomonthcode() { 195 196 int m = serialdate.stringtomonthcode(“january”); 197 assertequals(monthconstants.january, m); 198 199 m = serialdate.stringtomonthcode(“ january ”); 200 assertequals(monthconstants.january, m); 201 202 m = serialdate.stringtomonthcode(“jan”); 203 assertequals(monthconstants.january, m); 204 205 } 206 207 /** 208 * probar la conversión de un código de mes en cadena. 209 */ 210 public void testmonthcodetostringcode() { 211 212 final string test = serialdate.monthcodetostring(monthconstants.december); 213 assertequals(“december”, test); 214 215 } 216 217 /** 218 * 1900 no es un año bisiesto. 219 */ 220 public void testisnotleapyear1900() { 221 asserttrue(!serialdate.isleapyear(1900)); 222 } 467223 224 /** 225 * 2000 es un año bisiesto. 226 */ 227 public void testisleapyear2000() { 228 asserttrue(serialdate.isleapyear(2000)); 229 } 230 231 /** 232 * el número de años bisiestos desde 1900 y hasta 1899 incluido es 0. 233 */ 234 public void testleapyearcount1899() { 235 assertequals(serialdate.leapyearcount(1899), 0); 236 } 237 238 /** 239 * el número de años bisiestos desde 1900 y hasta 1903 incluido es 0. 240 */ 241 public void testleapyearcount1903() { 242 assertequals(serialdate.leapyearcount(1903), 0); 243 } 244 245 /** 246 * el número de años bisiestos desde 1900 y hasta 1904 incluido es 1. 247 */ 248 public void testleapyearcount1904() { 249 assertequals(serialdate.leapyearcount(1904), 1); 250 } 251 252 /** 253 * el número de años bisiestos desde 1900 y hasta 1999 incluido es 24. 254 */ 255 public void testleapyearcount1999() { 256 assertequals(serialdate.leapyearcount(1999), 24); 257 } 258 259 /** 260 * el número de años bisiestos desde 1900 y hasta 2000 incluido es 25. 261 */ 262 public void testleapyearcount2000() { 263 assertequals(serialdate.leapyearcount(2000), 25); 264 } 265 266 /** 267 * serializar una instancia, restaurarla y comprobar la igualdad. 468268 */ 269 public void testserialization() { 270 271 serialdate d1 = serialdate.createinstance(15, 4, 2000); 272 serialdate d2 = null; 273 274 try { 275 bytearrayoutputstream buffer = new bytearrayoutputstream(); 276 objectoutput out = new objectoutputstream(buffer); 277 out.writeobject(d1); 278 out.close(); 279 280 objectinput in = new objectinputstream( new bytearrayinputstream(buffer.tobytearray())); 281 d2 = (serialdate) in.readobject(); 282 in.close(); 283 } 284 catch (exception e) { 285 system.out.println(e.tostring()); 286 } 287 assertequals(d1, d2); 288 289 } 290 291 /** 292 * prueba para el informe de error 1096282 (ya corregido). 293 */ 294 public void test1096282() { 295 serialdate d = serialdate.createinstance(29, 2, 2004); 296 d = serialdate.addyears(1, d); 297 serialdate expected = serialdate.createinstance(28, 2, 2005); 298 asserttrue(d.ison(expected)); 299 } 300 301 /** 302 * diversas pruebas para el método addmonths(). 303 */ 304 public void testaddmonths() { 305 serialdate d1 = serialdate.createinstance(31, 5, 2004); 307 serialdate d2 = serialdate.addmonths(1, d1); 308 assertequals(30, d2.getdayofmonth()); 309 assertequals(6, d2.getmonth()); 310 assertequals(2004, d2.getyyyy()); 311 312 serialdate d3 = serialdate.addmonths(2, d1); 469313 assertequals(31, d3.getdayofmonth()); 314 assertequals(7, d3.getmonth()); 315 assertequals(2004, d3.getyyyy()); 316 317 serialdate d4 = serialdate.addmonths(1, serialdate.addmonths(1, d1)); 318 assertequals(30, d4.getdayofmonth()); 319 assertequals(7, d4.getmonth()); 320 assertequals(2004, d4.getyyyy()); 321 } 322 } listado b-3 monthconstants.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ---------------------- 28 * monthconstants.java 47029 * ---------------------- 30 * (c) copyright 2002, 2003, de object refinery limited. 31 * 32 * autor original: david gilbert (para object refinery limited); 33 * colaborador(es): -; 34 * 35 * $id: monthconstants.java,v 1.4 2005/11/16 15:58:40 taqua exp $ 36 * 37 * cambios 38 * ---------- 39 * 29-may-2002 : version 1 (code moved from serialdate class) (dg); 40 * 41 */ 42 43 package org.jfree.date; 44 45 /** 46 * constantes útiles para los meses. no son equivalentes a las 47 * constantes definidas por java.util.calendar (donde january=0 y december=11). 48 * <p> 49 * se usa en las clases serialdate y regulartimeperiod. 50 * 51 * @author david gilbert 52 */ 53 public interface monthconstants { 54 55 /** constante para enero. */ 56 public static final int january = 1; 57 58 /** constante para febrero. */ 59 public static final int february = 2; 60 61 /** constante para marzo. */ 62 public static final int march = 3; 63 64 /** constante para abril. */ 65 public static final int april = 4; 66 67 /** constante para mayo. */ 68 public static final int may = 5; 69 70 /** constante para junio. */ 71 public static final int june = 6; 72 47173 /** constante para julio. */ 74 public static final int july = 7; 75 76 /** constante para agosto. */ 77 public static final int august = 8; 78 79 /** constante para septiembre. */ 80 public static final int september = 9; 81 82 /** constante para octubre. */ 83 public static final int october = 10; 84 85 /** constante para noviembre. */ 86 public static final int november = 11; 87 88 /** constante para diciembre. */ 89 public static final int december = 12; 90 91 } listado b-4 bobsserialdatetest.java 1 package org.jfree.date.junit; 2 3 import junit.framework.testcase; 4 import org.jfree.date.*; 5 import static org.jfree.date.serialdate.*; 6 7 import java.util.*; 8 9 public class bobsserialdatetest extends testcase { 10 11 public void testisvalidweekdaycode() throws exception { 12 for (int day = 1; day <= 7; day++) 13 asserttrue(isvalidweekdaycode(day)); 14 assertfalse(isvalidweekdaycode(0)); 15 assertfalse(isvalidweekdaycode(8)); 16 } 17 18 public void teststringtoweekdaycode() throws exception { 19 20 assertequals(-1, stringtoweekdaycode(“hello”)); 21 assertequals(monday, stringtoweekdaycode(“monday”)); 47222 assertequals(monday, stringtoweekdaycode(“mon”)); 23 //todo assertequals(monday,stringtoweekdaycode(“monday”)); 24 // assertequals(monday,stringtoweekdaycode(“monday”)); 25 // assertequals(monday, stringtoweekdaycode(“mon”)); 26 27 assertequals(tuesday, stringtoweekdaycode(“tuesday”)); 28 assertequals(tuesday, stringtoweekdaycode(“tue”)); 29 // assertequals(tuesday,stringtoweekdaycode(“tuesday”)); 30 // assertequals(tuesday,stringtoweekdaycode(“tuesday”)); 31 // assertequals(tuesday, stringtoweekdaycode(“tue”)); 32 // assertequals(tuesday, stringtoweekdaycode(“tues”)); 33 34 assertequals(wednesday, stringtoweekdaycode (“wednesday”)); 35 assertequals(wednesday, stringtoweekdaycode(“wed”)); 36 // assertequals(wednesday,stringtoweekdaycode(“wednesday”)); 37 // assertequals(wednesday,stringtoweekdaycode(“wednesday”)); 38 // assertequals(wednesday, stringtoweekdaycode(“wed”)); 39 40 assertequals(thursday, stringtoweekdaycode(“thursday”)); 41 assertequals(thursday, stringtoweekdaycode(“thu”)); 42 // assertequals(thursday,stringtoweekdaycode(“thursday”)); 43 // assertequals(thursday,stringtoweekdaycode(“thursday”)); 44 // assertequals(thursday, stringtoweekdaycode(“thu”)); 45 // assertequals(thursday, stringtoweekdaycode(“thurs”)); 46 47 assertequals(friday, stringtoweekdaycode(“friday”)); 48 assertequals(friday, stringtoweekdaycode(“fri”)); 49 // assertequals(friday,stringtoweekdaycode(“friday”)); 50 // assertequals(friday,stringtoweekdaycode(“friday”)); 51 // assertequals(friday, stringtoweekdaycode(“fri”)); 52 53 assertequals(saturday, stringtoweekdaycode(“saturday”)); 54 assertequals(saturday, stringtoweekdaycode(“sat”)); 55 // assertequals(saturday,stringtoweekdaycode(“saturday”)); 56 // assertequals(saturday,stringtoweekdaycode(“saturday”)); 57 // assertequals(saturday, stringtoweekdaycode(“sat”)); 58 59 assertequals(sunday, stringtoweekdaycode(“sunday”)); 60 assertequals(sunday, stringtoweekdaycode(“sun”)); 61 // assertequals(sunday,stringtoweekdaycode(“sunday”)); 62 // assertequals(sunday,stringtoweekdaycode(“sunday”)); 63 // assertequals(sunday, stringtoweekdaycode(“sun”)); 64 } 65 66 public void testweekdaycodetostring() throws exception { 47367 assertequals(“sunday”, weekdaycodetostring(sunday)); 68 assertequals(“monday”, weekdaycodetostring(monday)); 69 assertequals(“tuesday”, weekdaycodetostring(tuesday)); 70 assertequals(“wednesday”, weekdaycodetostring(wednesday)); 71 assertequals(“thursday”, weekdaycodetostring(thursday)); 72 assertequals(“friday”, weekdaycodetostring(friday)); 73 assertequals(“saturday”, weekdaycodetostring(saturday)); 74 } 75 76 public void testisvalidmonthcode() throws exception { 77 for (int i = 1; i <= 12; i++) 78 asserttrue(isvalidmonthcode(i)); 79 assertfalse(isvalidmonthcode(0)); 80 assertfalse(isvalidmonthcode(13)); 81 } 82 83 public void testmonthtoquarter() throws exception { 84 assertequals(1, monthcodetoquarter(january)); 85 assertequals(1, monthcodetoquarter(february)); 86 assertequals(1, monthcodetoquarter(march)); 87 assertequals(2, monthcodetoquarter(april)); 88 assertequals(2, monthcodetoquarter(may)); 89 assertequals(2, monthcodetoquarter(june)); 90 assertequals(3, monthcodetoquarter(july)); 91 assertequals(3, monthcodetoquarter(august)); 92 assertequals(3, monthcodetoquarter(september)); 93 assertequals(4, monthcodetoquarter(october)); 94 assertequals(4, monthcodetoquarter(november)); 95 assertequals(4, monthcodetoquarter(december)); 96 97 try { 98 monthcodetoquarter(-1); 99 fail(“invalid month code should throw exception”); 100 } catch (illegalargumentexception e) { 101 } 102 } 103 104 public void testmonthcodetostring() throws exception { 105 assertequals(“january”, monthcodetostring(january)); 106 assertequals(“february”, monthcodetostring(february)); 107 assertequals(“march”, monthcodetostring(march)); 108 assertequals(“april”, monthcodetostring(april)); 109 assertequals(“may”, monthcodetostring(may)); 110 assertequals(“june”, monthcodetostring(june)); 111 assertequals(“july”, monthcodetostring(july)); 474112 assertequals(“august”, monthcodetostring(august)); 113 assertequals(“september”, monthcodetostring(september)); 114 assertequals(“october”, monthcodetostring(october)); 115 assertequals(“november”, monthcodetostring(november)); 116 assertequals(“december”, monthcodetostring(december)); 117 118 assertequals(“jan”, monthcodetostring(january, true)); 119 assertequals(“feb”, monthcodetostring(february, true)); 120 assertequals(“mar”, monthcodetostring(march, true)); 121 assertequals(“apr”, monthcodetostring(april, true)); 122 assertequals(“may”, monthcodetostring(may, true)); 123 assertequals(“jun”, monthcodetostring(june, true)); 124 assertequals(“jul”, monthcodetostring(july, true)); 125 assertequals(“aug”, monthcodetostring(august, true)); 126 assertequals(“sep”, monthcodetostring(september, true)); 127 assertequals(“oct”, monthcodetostring(october, true)); 128 assertequals(“nov”, monthcodetostring(november, true)); 129 assertequals(“dec”, monthcodetostring(december, true)); 130 131 try { 132 monthcodetostring(-1); 133 fail(“invalid month code should throw exception”); 134 } catch (illegalargumentexception e) { 135 } 136 137 } 138 139 public void teststringtomonthcode() throws exception { 140 assertequals(january,stringtomonthcode(“1”)); 141 assertequals(february,stringtomonthcode(“2”)); 142 assertequals(march,stringtomonthcode(“3”)); 143 assertequals(april,stringtomonthcode(“4”)); 144 assertequals(may,stringtomonthcode(“5”)); 145 assertequals(june,stringtomonthcode(“6”)); 146 assertequals(july,stringtomonthcode(“7”)); 147 assertequals(august,stringtomonthcode(“8”)); 148 assertequals(september,stringtomonthcode(“9”)); 149 assertequals(october,stringtomonthcode(“10”)); 150 assertequals(november, stringtomonthcode(“11”)); 151 assertequals(december,stringtomonthcode(“12”)); 152 153 //todo assertequals(-1, stringtomonthcode(“0”)); 154 // assertequals(-1, stringtomonthcode(“13”)); 155 156 assertequals(-1,stringtomonthcode(“hello”)); 475157 158 for (int m = 1; m <= 12; m++) { 159 assertequals(m, stringtomonthcode(monthcodetostring(m, false))); 160 assertequals(m, stringtomonthcode(monthcodetostring(m, true))); 161 } 162 163 // assertequals(1,stringtomonthcode(“jan”)); 164 // assertequals(2,stringtomonthcode(“feb”)); 165 // assertequals(3,stringtomonthcode(“mar”)); 166 // assertequals(4,stringtomonthcode(“apr”)); 167 // assertequals(5,stringtomonthcode(“may”)); 168 // assertequals(6,stringtomonthcode(“jun”)); 169 // assertequals(7,stringtomonthcode(“jul”)); 170 // assertequals(8,stringtomonthcode(“aug”)); 171 // assertequals(9,stringtomonthcode(“sep”)); 172 // assertequals(10,stringtomonthcode(“oct”)); 173 // assertequals(11,stringtomonthcode(“nov”)); 174 // assertequals(12,stringtomonthcode(“dec”)); 175 176 // assertequals(1,stringtomonthcode(“jan”)); 177 // assertequals(2,stringtomonthcode(“feb”)); 178 // assertequals(3,stringtomonthcode(“mar”)); 179 // assertequals(4,stringtomonthcode(“apr”)); 180 // assertequals(5,stringtomonthcode(“may”)); 181 // assertequals(6,stringtomonthcode(“jun”)); 182 // assertequals(7,stringtomonthcode(“jul”)); 183 // assertequals(8,stringtomonthcode(“aug”)); 184 // assertequals(9,stringtomonthcode(“sep”)); 185 // assertequals(10,stringtomonthcode(“oct”)); 186 // assertequals(11,stringtomonthcode(“nov”)); 187 // assertequals(12,stringtomonthcode(“dec”)); 188 189 // assertequals(1,stringtomonthcode(“january”)); 190 // assertequals(2,stringtomonthcode(“february”)); 191 // assertequals(3,stringtomonthcode(“march”)); 192 // assertequals(4,stringtomonthcode(“april”)); 193 // assertequals(5,stringtomonthcode(“may”)); 194 // assertequals(6,stringtomonthcode(“june”)); 195 // assertequals(7,stringtomonthcode(“july”)); 196 // assertequals(8,stringtomonthcode(“august”)); 197 // assertequals(9,stringtomonthcode(“september”)); 198 // assertequals(10,stringtomonthcode(“october”)); 199 // assertequals(11,stringtomonthcode(“november”)); 200 // assertequals(12,stringtomonthcode(“december”)); 201 476202 // assertequals(1,stringtomonthcode(“january”)); 203 // assertequals(2,stringtomonthcode(“february”)); 204 // assertequals(3,stringtomonthcode(“mar”)); 205 // assertequals(4,stringtomonthcode(“april”)); 206 // assertequals(5,stringtomonthcode(“may”)); 207 // assertequals(6,stringtomonthcode(“june”)); 208 // assertequals(7,stringtomonthcode(“july”)); 209 // assertequals(8,stringtomonthcode(“august”)); 210 // assertequals(9,stringtomonthcode(“september”)); 211 // assertequals(10,stringtomonthcode(“october”)); 212 // assertequals(11,stringtomonthcode(“november”)); 213 // assertequals(12,stringtomonthcode(“december”)); 214 } 215 216 public void testisvalidweekinmonthcode() throws exception { 217 for (int w = 0; w <= 4; w++) { 218 asserttrue(isvalidweekinmonthcode(w)); 219 } 220 assertfalse(isvalidweekinmonthcode(5)); 221 } 222 223 public void testisleapyear() throws exception { 224 assertfalse(isleapyear(1900)); 225 assertfalse(isleapyear(1901)); 226 assertfalse(isleapyear(1902)); 227 assertfalse(isleapyear(1903)); 228 asserttrue(isleapyear(1904)); 229 asserttrue(isleapyear(1908)); 230 assertfalse(isleapyear(1955)); 231 asserttrue(isleapyear(1964)); 232 asserttrue(isleapyear(1980)); 233 asserttrue(isleapyear(2000)); 234 assertfalse(isleapyear(2001)); 235 assertfalse(isleapyear(2100)); 236 } 237 238 public void testleapyearcount() throws exception { 239 assertequals(0, leapyearcount(1900)); 240 assertequals(0, leapyearcount(1901)); 241 assertequals(0, leapyearcount(1902)); 242 assertequals(0, leapyearcount(1903)); 243 assertequals(1, leapyearcount(1904)); 244 assertequals(1, leapyearcount(1905)); 245 assertequals(1, leapyearcount(1906)); 246 assertequals(1, leapyearcount(1907)); 477247 assertequals(2, leapyearcount(1908)); 248 assertequals(24, leapyearcount(1999)); 249 assertequals(25, leapyearcount(2001)); 250 assertequals(49, leapyearcount(2101)); 251 assertequals(73, leapyearcount(2201)); 252 assertequals(97, leapyearcount(2301)); 253 assertequals(122, leapyearcount(2401)); 254 } 255 256 public void testlastdayofmonth() throws exception { 257 assertequals(31, lastdayofmonth(january, 1901)); 258 assertequals(28, lastdayofmonth(february, 1901)); 259 assertequals(31, lastdayofmonth(march, 1901)); 260 assertequals(30, lastdayofmonth(april, 1901)); 261 assertequals(31, lastdayofmonth(may, 1901)); 262 assertequals(30, lastdayofmonth(june, 1901)); 263 assertequals(31, lastdayofmonth(july, 1901)); 264 assertequals(31, lastdayofmonth(august, 1901)); 265 assertequals(30, lastdayofmonth(september, 1901)); 266 assertequals(31, lastdayofmonth(october, 1901)); 267 assertequals(30, lastdayofmonth(november, 1901)); 268 assertequals(31, lastdayofmonth(december, 1901)); 269 assertequals(29, lastdayofmonth(february, 1904)); 270 } 271 272 public void testadddays() throws exception { 273 serialdate newyears = d(1, january, 1900); 274 assertequals(d(2, january, 1900), adddays(1, newyears)); 275 assertequals(d(1, february, 1900), adddays(31, newyears)); 276 assertequals(d(1, january, 1901), adddays(365, newyears)); 277 assertequals(d(31, december, 1904), adddays(5 * 365, newyears)); 278 } 279 280 private static spreadsheetdate d(int day, int month, int year) { return new spreadsheetdate(day, month, year); } 281 282 public void testaddmonths() throws exception { 283 assertequals(d(1, february, 1900), addmonths(1, d(1, january, 1900))); 284 assertequals(d(28, february, 1900), addmonths(1, d(31, january, 1900))); 285 assertequals(d(28, february, 1900), addmonths(1, d(30, january, 1900))); 286 assertequals(d(28, february, 1900), addmonths(1, d(29, january, 1900))); 287 assertequals(d(28, february, 1900), addmonths(1, d(28, january, 4781900))); 288 assertequals(d(27, february, 1900), addmonths(1, d(27, january, 1900))); 289 290 assertequals(d(30, june, 1900), addmonths(5, d(31, january, 1900))); 291 assertequals(d(30, june, 1901), addmonths(17, d(31, january, 1900))); 292 293 assertequals(d(29, february, 1904), addmonths(49, d(31, january, 1900))); 294 295 } 296 297 public void testaddyears() throws exception { 298 assertequals(d(1, january, 1901), addyears(1, d(1, january, 1900))); 299 assertequals(d(28, february, 1905), addyears(1, d(29, february, 1904))); 300 assertequals(d(28, february, 1905), addyears(1, d(28, february, 1904))); 301 assertequals(d(28, february, 1904), addyears(1, d(28, february, 1903))); 302 } 303 304 public void testgetpreviousdayofweek() throws exception { 305 assertequals(d(24, february, 2006), getpreviousdayofweek(friday, d(1, march, 2006))); 306 assertequals(d(22, february, 2006), getpreviousdayofweek(wednesday, d(1, march, 2006))); 307 assertequals(d(29, february, 2004), getpreviousdayofweek(sunday, d(3, march, 2004))); 308 assertequals(d(29, december, 2004), getpreviousdayofweek(wednesday, d(5, january, 2005))); 309 310 try { 311 getpreviousdayofweek(-1, d(1, january, 2006)); 312 fail(“invalid day of week code should throw exception”); 313 } catch (illegalargumentexception e) { 314 } 315 } 316 317 public void testgetfollowingdayofweek() throws exception { 318 // assertequals(d(1, january, 2005),getfollowingdayofweek(saturday, d(25, december, 2004))); 319 assertequals(d(1, january, 2005), getfollowingdayofweek(saturday, d(26, december, 2004))); 320 assertequals(d(3, march, 2004), getfollowingdayofweek(wednesday, d(28, february, 2004))); 321 479322 try { 323 getfollowingdayofweek(-1, d(1, january, 2006)); 324 fail(“invalid day of week code should throw exception”); 325 } catch (illegalargumentexception e) { 326 } 327 } 328 329 public void testgetnearestdayofweek() throws exception { 330 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(16, april, 2006))); 331 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(17, april, 2006))); 332 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(18, april, 2006))); 333 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(19, april, 2006))); 334 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(20, april, 2006))); 335 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(21, april, 2006))); 336 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(22, april, 2006))); 337 338 //todo assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(16, april, 2006))); 339 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(17, april, 2006))); 340 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(18, april, 2006))); 341 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(19, april, 2006))); 342 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(20, april, 2006))); 343 assertequals(d(24, april, 2006), getnearestdayofweek(monday, d(21, april, 2006))); 344 assertequals(d(24, april, 2006), getnearestdayofweek(monday, d(22, april, 2006))); 345 346 // assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(16, april, 2006))); 347 // assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(17, april, 2006))); 348 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(18, april, 2006))); 349 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(19, april, 2006))); 350 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(20, april, 2006))); 351 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(21, 480april, 2006))); 352 assertequals(d(25, april, 2006), getnearestdayofweek(tuesday, d(22, april, 2006))); 353 354 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(16, april, 2006))); 355 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(17, april, 2006))); 356 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(18, april, 2006))); 357 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(19, april, 2006))); 358 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(20, april, 2006))); 359 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(21, april, 2006))); 360 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(22, april, 2006))); 361 362 // assertequals(d(13, april, 2006), getnearestdayofweek(thursday, d(16, april, 2006))); 363 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(17, april, 2006))); 364 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(18, april, 2006))); 365 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(19, april, 2006))); 366 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(20, april, 2006))); 367 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(21, april, 2006))); 368 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(22, april, 2006))); 369 370 // assertequals(d(14, april, 2006), getnearestdayofweek(friday, d(16, april, 2006))); 371 // assertequals(d(14, april, 2006), getnearestdayofweek(friday, d(17, april, 2006))); 372 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(18, april, 2006))); 373 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(19, april, 2006))); 374 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(20, april, 2006))); 375 assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(21, april, 2006))); 376 assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(22, april, 2006))); 377 378 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(16, 481april, 2006))); 379 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(17, april, 2006))); 380 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(18, april, 2006))); 381 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(19, april, 2006))); 382 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(20, april, 2006))); 383 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(21, april, 2006))); 384 assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(22, april, 2006))); 385 386 try { 387 getnearestdayofweek(-1, d(1, january, 2006)); 388 fail(“invalid day of week code should throw exception”); 389 } catch (illegalargumentexception e) { 390 } 391 } 392 393 public void testendofcurrentmonth() throws exception { 394 serialdate d = serialdate.createinstance(2); 395 assertequals(d(31, january, 2006), d.getendofcurrentmonth(d(1, january, 2006))); 396 assertequals(d(28, february, 2006), d.getendofcurrentmonth(d(1, february, 2006))); 397 assertequals(d(31, march, 2006), d.getendofcurrentmonth(d(1, march, 2006))); 398 assertequals(d(30, april, 2006), d.getendofcurrentmonth(d(1, april, 2006))); 399 assertequals(d(31, may, 2006), d.getendofcurrentmonth(d(1, may, 2006))); 400 assertequals(d(30, june, 2006), d.getendofcurrentmonth(d(1, june, 2006))); 401 assertequals(d(31, july, 2006), d.getendofcurrentmonth(d(1, july, 2006))); 402 assertequals(d(31, august, 2006), d.getendofcurrentmonth(d(1, august, 2006))); 403 assertequals(d(30, september, 2006), d.getendofcurrentmonth(d(1, september, 2006))); 404 assertequals(d(31, october, 2006), d.getendofcurrentmonth(d(1, october, 2006))); 405 assertequals(d(30, november, 2006), d.getendofcurrentmonth(d(1, november, 2006))); 406 assertequals(d(31, december, 2006), d.getendofcurrentmonth(d(1, december, 2006))); 407 assertequals(d(29, february, 2008), d.getendofcurrentmonth(d(1, february, 2008))); 482408 } 409 410 public void testweekinmonthtostring() throws exception { 411 assertequals(“first”,weekinmonthtostring(first_week_in_month)); 412 assertequals(“second”,weekinmonthtostring(second_week_in_month)); 413 assertequals(“third”,weekinmonthtostring(third_week_in_month)); 414 assertequals(“fourth”,weekinmonthtostring(fourth_week_in_month)); 415 assertequals(“last”,weekinmonthtostring(last_week_in_month)); 416 417 //todo try { 418 // weekinmonthtostring(-1); 419 // fail(“invalid week code should throw exception”); 420 // } catch (illegalargumentexception e) { 421 // } 422 } 423 424 public void testrelativetostring() throws exception { 425 assertequals(“preceding”,relativetostring(preceding)); 426 assertequals(“nearest”,relativetostring(nearest)); 427 assertequals(“following”,relativetostring(following)); 428 429 //todo try { 430 // relativetostring(-1000); 431 // fail(“invalid relative code should throw exception”); 432 // } catch (illegalargumentexception e) { 433 // } 434 } 435 436 public void testcreateinstancefromddmmyyyy() throws exception { 437 serialdate date = createinstance(1, january, 1900); 438 assertequals(1,date.getdayofmonth()); 439 assertequals(january,date.getmonth()); 440 assertequals(1900,date.getyyyy()); 441 assertequals(2,date.toserial()); 442 } 443 444 public void testcreateinstancefromserial() throws exception { 445 assertequals(d(1, january, 1900),createinstance(2)); 446 assertequals(d(1, january, 1901), createinstance(367)); 447 } 448 449 public void testcreateinstancefromjavadate() throws exception { 450 assertequals(d(1, january, 1900), createinstance(new gregoriancalendar(1900,0,1).gettime())); 451 assertequals(d(1, january, 2006), 483createinstance(new gregoriancalendar(2006,0,1).gettime())); 452 } 453 454 public static void main(string[] args) { 455 junit.textui.testrunner.run(bobsserialdatetest.class); 456 } 457 } 484listado b-5 spreadsheetdate.java. 1 /* ============================================================= 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * -------------------------- 28 * spreadsheetdate.java 29 * -------------------------- 30 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 31 * 32 * autor original: david gilbert (por object refinery limited); 33 * colaboradores(s): -; 34 * 35 * $id: speadsheetdate.java,v 1.8 2005/11/03 09:25:39 mungady exp $ 36 * 37 * cambios 38 * ---------- 39 * 11-oct-2001 : version 1 (dg); 48540 * 05-nov-2001 : se añaden los métodos getdescription() y setdescription() (dg); 41 * 12-nov-2001 : se cambia el nombre exceldate.java por spreadsheetdate.java (dg); 42 * se corrige un error a la hora de calcular el día, mes y año a 43 * partir del número de serie (dg); 44 * 24-jan-2002 : se corrige un error a la hora de calcular el número de serie a 45 * partir del día, mes y año. gracias a trevor kills por el informe (dg); 46 * 29-may-2002 : se añade el método equals(object) (sourceforge id 558850) (dg); 47 * 03-oct-2002 : se corrigen los errores detectados por checkstyle (dg); 48 * 13-mar-2003 : implementación de serializable (dg); 49 * 04-sep-2003 : métodos isinrange() completados (dg); 50 * 05-sep-2003 : implementación de comparable (dg); 51 * 21-oct-2003 : se añade el método hashcode() (dg); 52 * 53 /* 54 55 package org.jfree.date; 56 57 import java.util.calendar; 58 import java.util.date; 59 /** 60 61 * representa una con un entero, de forma similar a la 62 * implementación en microsoft excel. el intervalo de fechas admitido es 63 * 1-ene-1900 a 31-dic-9999. 64 * <p> 65 * recuerde que excel tiene un error que reconoce el año 66 * 1900 como bisiesto cuando en realidad no lo es. encontrará más 67 * información en el sitio web de microsoft, en el artículo q181370: 68 * <p> 69 * http://support.microsoft.com/support/kb/articles/q181/3/70.asp 70 * <p> 71 * excel usa como convención que el 1-ene-1900 = 1. esta clase usa la 72 * convención de que 1-ene-1900 = 2. 73 * como resultado, el número de día de esta clase será diferente al de 74 * excel para enero y febrero de 1900… pero excel añade un día 75 * más (29-feb-1900 que en realidad no existe) y a partir de ahí 76 * los números de los días coinciden. 77 * 78 * @author david gilbert 79 */ 80 public class spreadsheetdate extends serialdate { 81 48682 /** para serialización. */ 83 private static final long serialversionuid = -2039586705374454461l; 84 85 /** 86 * el número de día (1-ene-1900 = 2, 2-ene-1900 = 3…, 31-dic-9999 = 87 * 2958465). 88 */ 89 private int serial; 90 91 /** el día del mes (de 1 a 28, 29, 30 o 31 en función del mes). */ 92 private int day; 93 94 /** el mes del año (de 1 a 12). */ 95 private int month; 96 97 /** el año (de 1900 a 9999). */ 98 private int year; 99 100 /** una descripción opcional para la fecha. */ 101 private string description; 102 103 /** 104 * crear una nueva instancia de la fecha. 105 * 106 * @param day el día (entre 1 y 28/29/30/31). 107 * @param month el mes (entre 1 y 12). 108 * @param year el año (entre 1900 y 9999). 109 */ 110 public spreadsheetdate(final int day, final int month, final int year) { 111 112 if ((year >= 1900) && (year <= 9999)) { 113 this.year = year; 114 } 115 else { 116 throw new illegalargumentexception( 117 “the ‘year’ argument must be in range 1900 to 9999.” 118 ); 119 } 120 121 if ((month >= monthconstants.january) 122 && (month <= monthconstants.december)) { 123 this.month = month; 124 } 125 else { 487126 throw new illegalargumentexception( 127 “the ‘month’ argument must be in the range 1 to 12.” 128 ); 129 } 130 131 if ((day >= 1) && (day <= serialdate.lastdayofmonth(month, year))) { 132 this.day = day; 133 } 134 else { 135 throw new illegalargumentexception(“invalid ‘day’ argument.”); 136 } 137 138 // es necesario sincronizar el número de serie con el día-mes-año… 139 this.serial = calcserial(day, month, year); 140 141 this.description = null; 142 143 } 144 145 /** 146 * constructor estándar: crear un nuevo objeto de fecha que representa el 147 * número de día especificado (que debe estar comprendido entre 2 y 2958465). 148 * 149 * @param serial número de serie para el día (entre 2 y 2958465). 150 */ 151 public spreadsheetdate(final int serial) { 152 153 if ((serial >= serial_lower_bound) && (serial <= serial_upper_bound)) { 154 this.serial = serial; 155 } 156 else { 157 throw new illegalargumentexception( 158 “spreadsheetdate: serial must be in range 2 to 2958465.”); 159 } 160 161 // el día-mes-año debe estar sincronizado con el número de serie… 162 calcdaymonthyear(); 163 164 } 165 166 /** 167 * devuelve la descripción adjuntada a la fecha. no es 168 * obligatorio que la fecha tenga una descripción, pero resulta útil 488169 * en algunas aplicaciones. 170 * 171 * @return la descripción adjuntada a la fecha. 172 */ 173 public string getdescription() { 174 return this.description; 175 } 176 177 /** 178 * establece la descripción de la fecha. 179 * 180 * @param description la descripción de esta fecha (<code>null</code> 181 * se permite) 182 */ 183 public void setdescription(final string description) { 184 this.description = description; 185 } 186 187 /** 188 * devuelve el número de serie de la fecha, siendo el 1 de enero 1900 = 2 189 * (se corresponde, casi totalmente, al sistema de numeración empleado en 190 * microsoft excel para windows y lotus 1-2-3). 191 * 192 * @return el número de serie de la fecha. 193 */ 194 public int toserial() { 195 return this.serial; 196 } 197 198 /** 199 * devuelve una <code>java.util.date</code> equivalente a esta fecha. 200 * 201 * @return la fecha. 202 */ 203 public date todate() { 204 final calendar calendar = calendar.getinstance(); 205 calendar.set(getyyyy(), getmonth() - 1, getdayofmonth(), 0, 0, 0); 206 return calendar.gettime(); 207 } 208 209 /** 210 * devuelve el año (con un intervalo válido de 1900 a 9999). 211 * 212 * @return el año. 489213 */ 214 public int getyyyy() { 215 return this.year; 216 } 217 218 /** 219 * devuelve el mes (enero = 1, febrero = 2, marzo = 3). 220 * 221 * @return el mes del año. 222 */ 223 public int getmonth() { 224 return this.month; 225 } 226 227 /** 228 * devuelve el día del mes. 229 * 230 * @return el día del mes. 231 */ 232 public int getdayofmonth() { 233 return this.day; 234 } 235 236 /** 237 * devuelve un código que representa el día de la semana. 238 * <p> 239 * los códigos se definen en la clase {@link serialdate} como: 240 * <code>sunday</code>, <code>monday</code>, <code>tuesday</code>, 241 * <code>wednesday</code>, <code>thursday</code>, <code>friday</code>, y 242 * <code>saturday</code>. 243 * 244 * @return un código que representa el día de la semana. 245 */ 246 public int getdayofweek() { 247 return (this.serial + 6) % 7 + 1; 248 } 249 250 /** 251 * prueba la igualdad de esta fecha con un objeto arbitrario. 252 * <p> 253 * este método sólo devuelve true si el objeto es una instancia de la 254 * clase base {@link serialdate} y representa el mismo día que 255 * {@link spreadsheetdate}. 256 * 490257 * @param object el objeto que comparar (se permite <code>null</code>). 258 * 259 * @return un valor booleano. 260 */ 261 public boolean equals(final object object) { 262 263 if (object instanceof serialdate) { 264 final serialdate s = (serialdate) object; 265 return (s.toserial() == this.toserial()); 266 } 267 else { 268 return false; 269 } 270 271 } 272 273 /** 274 * devuelve un código hash para la instancia de este objeto. 275 * 276 * @return un código hash. 277 */ 278 public int hashcode() { 279 return toserial(); 280 } 281 282 /** 283 * devuelve la diferencia (en días) entre esta fecha y la 284 * ‘otra’ fecha especificada. 285 * 286 * @param other la fecha con la que se compara. 287 * 288 * @return la diferencia (en días) entre esta fecha y la 289 * otra’ fecha especificada. 290 */ 291 public int compare(final serialdate other) { 292 return this.serial – other.toserial(); 293 } 294 295 /** 296 * implementa el método necesario para la interfaz comparable. 297 * 298 * @param other el otro objeto (normalmente otro serialdate). 299 * 300 * @return un entero negativo, cero o un entero positivo si este objeto 301 * es menor que, igual o mayor que el objeto especificado. 491302 */ 303 public int compareto(final object other) { 304 return compare((serialdate) other); 305 } 306 307 /** 308 * devuelve true si esta serialdate representa la misma fecha que la 309 * serialdate especificada. 310 * 311 * @param other la fecha con la que se compara. 312 * 313 * @return <code>true</code> si esta serialdate representa la misma fecha que 314 * la otra serialdate especificada. 315 */ 316 public boolean ison(final serialdate other) { 317 return (this.serial == other.toserial()); 318 } 319 320 /** 321 * devuelve true si esta serialdate representa una fecha anterior a 322 * la serialdate especificada. 323 * 324 * @param other la fecha con la que se compara. 325 * 326 * @return <code>true</code> si esta serialdate representa una fecha anterior a 327 * la serialdate especificada. 328 */ 329 public boolean isbefore(final serialdate other) { 330 return (this.serial < other.toserial()); 331 } 332 333 /** 334 * devuelve true si esta serialdate representa la misma fecha que la 335 * serialdate especificada. 336 * 337 * @param other la fecha con la que se compara. 338 * 339 * @return <code>true</code> si esta serialdate representa la misma fecha 340 * que la serialdate especificada. 341 */ 342 public boolean isonorbefore(final serialdate other) { 343 return (this.serial <= other.toserial()); 344 } 492345 346 /** 347 * devuelve true si esta serialdate representa la misma fecha que la 348 * serialdate especificada. 349 * 350 * @param other la fecha con la que se compara. 351 * 352 * @return <code>true</code> si esta serialdate representa la misma fecha 353 * que la serialdate especificada. 354 */ 355 public boolean isafter(final serialdate other) { 356 return (this.serial > other.toserial()); 357 } 358 359 /** 360 * devuelve true si esta serialdate representa la misma fecha que la 361 * serialdate especificada. 362 * 363 * @param other la fecha con la que se compara. 364 * 365 * @return <code>true</code> si esta serialdate representa la misma fecha 366 * que la serialdate especificada. 367 */ 368 public boolean isonorafter(final serialdate other) { 369 return (this.serial >= other.toserial()); 370 } 371 372 /** 373 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 374 * intervalo especificado (inclusive). el orden de fecha de d1 y d2 no es 375 * importante. 376 * 377 * @param d1 una fecha límite para el rango. 378 * @param d2 la otra fecha límite para el rango. 379 * 380 * @return un valor booleano. 381 */ 382 public boolean isinrange(final serialdate d1, final serialdate d2) { 383 return isinrange(d1, d2, serialdate.include_both); 384 } 385 386 /** 387 * devuelve true si esta serialdate se encuentra en el intervalo 493especificado 388 * (el invocador especifica si los puntos finales se incluyen o no). el orden 389 * de d1 y d2 no es importante. 390 * 391 * @param d1 una fecha límite para el rango. 392 * @param d2 la otra fecha límite para el rango. 393 * @param include un código que controla si la fecha inicial y final 394 * se incluyen en el intervalo. 395 * 396 * @return <code>true</code> si esta serialdate se encuentra en el intervalo 397 * especificado. 398 */ 399 public boolean isinrange(final serialdate d1, final serialdate d2, 400 final int include) { 401 final int s1 = d1.toserial(); 402 final int s2 = d2.toserial(); 403 final int start = math.min(s1, s2); 404 final int end = math.max(s1, s2); 405 406 final int s = toserial(); 407 if (include == serialdate.include_both) { 408 return (s >= start && s <= end); 409 } 410 else if (include == serialdate.include_first) { 411 return (s >= start && s < end); 412 } 413 else if (include == serialdate.include_second) { 414 return (s > start && s <= end); 415 } 416 else { 417 return (s > start && s < end); 418 } 419 } 420 421 /** 422 * calcular el número de serie a partir del día, mes y año. 423 * <p> 424 * 1-ene-1900 = 2. 425 * 426 * @param d el día. 427 * @param m el mes. 428 * @param y el año. 429 * 430 * @return el número de serie a partir del día, mes y año. 494431 */ 432 private int calcserial(final int d, final int m, final int y) { 433 final int yy = ((y - 1900) * 365) + serialdate.leapyearcount(y - 1); 434 int mm = serialdate.aggregate_days_to_end_of_preceding_month[m]; 435 if (m > monthconstants.february) { 436 if (serialdate.isleapyear(y)) { 437 mm = mm + 1; 438 } 439 } 440 final int dd = d; 441 return yy + mm + dd + 1; 442 } 443 444 /** 445 * calcular el día, mes y año a partir del número de serie. 446 */ 447 private void calcdaymonthyear() { 448 449 // obtener el año a partir del número de serie de la fecha 450 final int days = this.serial - serial_lower_bound; 451 // sobrevalorado ya que ignoramos los días bisiestos 452 final int overestimatedyyyy = 1900 + (days / 365); 453 final int leaps = serialdate.leapyearcount(overestimatedyyyy); 454 final int nonleapdays = days - leaps; 455 // subestimado ya que sobrevaloramos los años 456 int underestimatedyyyy = 1900 + (nonleapdays / 365); 457 458 if (underestimatedyyyy == overestimatedyyyy) { 459 this.year = underestimatedyyyy; 460 } 461 else { 462 int ss1 = calcserial(1, 1, underestimatedyyyy); 463 while (ss1 <= this.serial) { 464 underestimatedyyyy = underestimatedyyyy + 1; 465 ss1 = calcserial(1, 1, underestimatedyyyy); 466 } 467 this.year = underestimatedyyyy - 1; 468 } 469 470 final int ss2 = calcserial(1, 1, this.year); 471 472 int[] daystoendofprecedingmonth 473 = aggregate_days_to_end_of_preceding_month; 474 475 if (isleapyear(this.year)) { 495476 daystoendofprecedingmonth 477 = leap_year_aggregate_days_to_end_of_preceding_month; 478 } 479 480 // get the month from the serial date 481 int mm = 1; 482 int sss = ss2 + daystoendofprecedingmonth[mm] - 1; 483 while (sss < this.serial) { 484 mm = mm + 1; 485 sss = ss2 + daystoendofprecedingmonth[mm] - 1; 486 } 487 this.month = mm - 1; 488 489 // el resto es d(+1); 490 this.day = this.serial - ss2 491 - daystoendofprecedingmonth[this.month] + 1; 492 493 } 494 495 } listado b-6 relativedayofweekrule.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 49619 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * -------------------------- 28 * relativedayofweekrule.java 29 * -------------------------- 30 * (c) copyright 2000-2003, de object refinery limited y colaboradores. 31 * 32 * autor original: david gilbert (por object refinery limited); 33 * colaboradores(s): -; 34 * 35 * $id: relativedayofweekrule.java,v 1.6 2005/11/16 15:58:40 taqua exp $ 36 * 37 * cambios (26-oct-2001) 38 * -------------------------- 39 * 26-oct-2001 : se cambió el paquete por com.jrefinery.date.*; 40 * 03-oct-2002 : se corrigen los errores detectados por checkstyle (dg); 41 * 42 */ 43 44 package org.jfree.date; 45 46 /** 47 * una regla de fechas anuales que devuelve una fecha por cada año en función de 48 * (a) una regla de referencia; (b) un día de la semana y (c) un parámetro de 49 * selección (serialdate.preceding, serialdate.nearest, serialdate.following). 50 * <p> 51 * por ejemplo, el viernes santo se puede especificado ‘el viernes anterior al 52 * domingo de resurrección. 53 * 54 * @author david gilbert 55 */ 56 public class relativedayofweekrule extends annualdaterule { 57 58 /** una referencia a la regla de fechas anuales sobre la que se basa esta regla. */ 59 private annualdaterule subrule; 49760 61 /** 62 * el día de la semana (serialdate.monday, serialdate.tuesday, etc). 63 */ 64 private int dayofweek; 65 66 /** indica que día de la semana (preceding, nearest o following). */ 67 private int relative; 68 69 /** 70 * constructor predeterminado: genera una regla para el lunes siguiente al 1 de enero. 71 */ 72 public relativedayofweekrule() { 73 this(new dayandmonthrule(), serialdate.monday, serialdate.following); 74 } 75 76 /** 77 * constructor estándar: genera una regla en función de la subregla proporcionada. 78 * 79 * @param subrule la regla que determina la fecha de referencia. 80 * @param dayofweek el día de la semana relativo a la fecha de referencia. 81 * @param relative indica “qué” día de la semana (anterior, más próximo 82 * o posterior). 83 */ 84 public relativedayofweekrule(final annualdaterule subrule, 85 final int dayofweek, final int relative) { 86 this.subrule = subrule; 87 this.dayofweek = dayofweek; 88 this.relative = relative; 89 } 90 91 /** 92 * devuelve la subregla (también denominada regla de referencia). 93 * 94 * @return la regla de fechas anuales que determina la fecha de referencia para 95 * esta regla. 96 */ 97 public annualdaterule getsubrule() { 98 return this.subrule; 99 } 100 498101 /** 102 * establece la subregla. 103 * 104 * @param subrule la regla de fechas anuales que determina la fecha de 105 * referencia para esta regla. 106 */ 107 public void setsubrule(final annualdaterule subrule) { 108 this.subrule = subrule; 109 } 110 111 /** 112 * devuelve el día de la semana de esta regla. 113 * 114 * @return el día de la semana de esta regla. 115 */ 116 public int getdayofweek() { 117 return this.dayofweek; 118 } 119 120 /** 121 * establece el día de la semana de esta regla. 122 * 123 * @param dayofweek el día de la semana de (serialdate.monday, 124 * serialdate.tuesday, etc.). 125 */ 126 public void setdayofweek(final int dayofweek) { 127 this.dayofweek = dayofweek; 128 } 129 130 /** 131 * devuelve el atributo ‘relativo’ que determina “qué” 132 * día de la semana nos interesa (serialdate.preceding, 133 * serialdate.nearest o serialdate.following). 134 * 135 * @return el atributo ‘relativo’. 136 */ 137 public int getrelative() { 138 return this.relative; 139 } 140 141 /** 142 * establece el atributo ‘relativo’ (serialdate.preceding, serialdate.nearest, 143 * serialdate.following). 144 * 499145 * @param relative determina “qué” día de la semana se selecciona con esta 146 * regla. 147 */ 148 public void setrelative(final int relative) { 149 this.relative = relative; 150 } 151 152 /** 153 * crea un clon de esta regla. 154 * 155 * @return un clon de esta regla. 156 * 157 * @throws clonenotsupportedexception nunca debe producirse. 158 */ 159 public object clone() throws clonenotsupportedexception { 160 final relativedayofweekrule duplicate 161 = (relativedayofweekrule) super.clone(); 162 duplicate.subrule = (annualdaterule) duplicate.getsubrule().clone(); 163 return duplicate; 164 } 165 166 /** 167 * devuelve la fecha generada por esta regla, para el año especificado. 168 * 169 * @param year el año (1900 &lt;= year &lt;= 9999). 170 * 171 * @return la fecha generada por esta regla para un año concreto (posiblemente 172 * <code>null</code>). 173 */ 174 public serialdate getdate(final int year) { 175 176 // comprobar argumento… 177 if ((year < serialdate.minimum_year_supported) 178 || (year > serialdate.maximum_year_supported)) { 179 throw new illegalargumentexception( 180 “relativedayofweekrule.getdate(): year outside valid range.”); 181 } 182 183 // calcular la fecha… 184 serialdate result = null; 185 final serialdate base = this.subrule.getdate(year); 186 187 if (base != null) { 188 switch (this.relative) { 500189 case(serialdate.preceding): 190 result = serialdate.getpreviousdayofweek(this.dayofweek, 191 base); 192 break; 193 case(serialdate.nearest): 194 result = serialdate.getnearestdayofweek(this.dayofweek, 195 base); 196 break; 197 case(serialdate.following): 198 result = serialdate.getfollowingdayofweek(this.dayofweek, 199 base); 200 break; 201 default: 202 break; 203 } 204 } 205 return result; 206 207 } 208 209 } listado b-7 daydate.java (final) 1 /* ============================================================= 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. … 36 */ 37 package org.jfree.date; 38 39 import java.io.serializable; 40 import java.util.*; 41 42 /** 43 * una clase abstracta que representa fechas inmutables con una precisión de 44 * un día. la implementación asigna cada fecha a un entero que 45 * representa un número ordinal de días de un origen fijo. 46 * 47 * ¿por qué no usar java.útil.date? lo haremos, cuando tenga sentido. en ocasiones, 50148 * java.util.date puede ser demasiado precisa; representa un instante en el tiempo, 49 * con una precisión de 1/1000 de segundo (y la fecha depende de la 50 * zona horaria). en ocasiones solo querremos representar un día concreto (como el 21 51 * de enero de 2015) sin preocuparnos de la hora del día, la 52 * zona horaria u otros aspectos. para eso hemos definido serialdate. 53 * 54 * usar daydatefactory.makedate para crear una instancia. 55 * 56 * @author david gilbert 57 * @author robert c. martin realizó gran parte de la refactorización. 58 */ 59 60 public abstract class daydate implements comparable, serializable { 61 public abstract int getordinalday(); 62 public abstract int getyear(); 63 public abstract month getmonth(); 64 public abstract int getdayofmonth(); 65 66 protected abstract day getdayofweekforordinalzero(); 67 68 public daydate plusdays(int days) { 69 return daydatefactory.makedate(getordinalday() + days); 70 } 71 72 public daydate plusmonths(int months) { 73 int thismonthasordinal = getmonth().toint() - month.january.toint(); 74 int thismonthandyearasordinal = 12 * getyear() + thismonthasordinal; 75 int resultmonthandyearasordinal = thismonthandyearasordinal + months; 76 int resultyear = resultmonthandyearasordinal / 12; 77 int resultmonthasordinal = resultmonthandyearasordinal % 12 + month.january.toint(); 78 month resultmonth = month.fromint(resultmonthasordinal); 79 int resultday = correctlastdayofmonth(getdayofmonth(), resultmonth, resultyear); 80 return daydatefactory.makedate(resultday, resultmonth, resultyear); 81 } 82 83 public daydate plusyears(int years) { 84 int resultyear = getyear() + years; 85 int resultday = correctlastdayofmonth(getdayofmonth(), getmonth(), resultyear); 86 return daydatefactory.makedate(resultday, getmonth(), resultyear); 87 } 50288 89 private int correctlastdayofmonth(int day, month month, int year) { 90 int lastdayofmonth = dateutil.lastdayofmonth(month, year); 91 if (day > lastdayofmonth) 92 day = lastdayofmonth; 93 return day; 94 } 95 96 public daydate getpreviousdayofweek(day targetdayofweek) { 97 int offsettotarget = targetdayofweek.toint() - getdayofweek().toint(); 98 if (offsettotarget >= 0) 99 offsettotarget -= 7; 100 return plusdays(offsettotarget); 101 } 102 103 public daydate getfollowingdayofweek(day targetdayofweek) { 104 int offsettotarget = targetdayofweek.toint() - getdayofweek().toint(); 105 if (offsettotarget <= 0) 106 offsettotarget += 7; 107 return plusdays(offsettotarget); 108 } 109 110 public daydate getnearestdayofweek(day targetdayofweek) { 111 int offsettothisweekstarget = targetdayofweek.toint() - getdayofweek().toint(); 112 int offsettofuturetarget = (offsettothisweekstarget + 7) % 7; 113 int offsettoprevioustarget = offsettofuturetarget - 7; 114 115 if (offsettofuturetarget > 3) 116 return plusdays(offsettoprevioustarget); 117 else 118 return plusdays(offsettofuturetarget); 119 } 120 121 public daydate getendofmonth() { 122 month month = getmonth(); 123 int year = getyear(); 124 int lastday = dateutil.lastdayofmonth(month, year); 125 return daydatefactory.makedate(lastday, month, year); 126 } 127 128 public date todate() { 129 final calendar calendar = calendar.getinstance(); 130 int ordinalmonth = getmonth().toint() - month.january.toint(); 503131 calendar.set(getyear(), ordinalmonth, getdayofmonth(), 0, 0, 0); 132 return calendar.gettime(); 133 } 134 135 public string tostring() { 136 return string.format(“%02d-%s-%d”, getdayofmonth(), getmonth(), getyear()); 137 } 138 139 public day getdayofweek() { 140 day startingday = getdayofweekforordinalzero(); 141 int startingoffset = startingday.toint() - day.sunday.toint(); 142 int ordinalofdayofweek = (getordinalday() + startingoffset) % 7; 143 return day.fromint(ordinalofdayofweek + day.sunday.toint()); 144 } 145 146 public int dayssince(daydate date) { 147 return getordinalday() - date.getordinalday(); 148 } 149 150 public boolean ison(daydate other) { 151 return getordinalday() == other.getordinalday(); 152 } 153 154 public boolean isbefore(daydate other) { 155 return getordinalday() < other.getordinalday(); 156 } 157 158 public boolean isonorbefore(daydate other) { 159 return getordinalday() <= other.getordinalday(); 160 } 161 162 public boolean isafter(daydate other) { 163 return getordinalday() > other.getordinalday(); 164 } 165 166 public boolean isonorafter(daydate other) { 167 return getordinalday() >= other.getordinalday(); 168 } 169 170 public boolean isinrange(daydate d1, daydate d2) { 171 return isinrange(d1, d2, dateinterval.closed); 172 } 173 174 public boolean isinrange(daydate d1, daydate d2, dateinterval interval) { 504175 int left = math.min(d1.getordinalday(), d2.getordinalday()); 176 int right = math.max(d1.getordinalday(), d2.getordinalday()); 177 return interval.isin(getordinalday(), left, right); 178 } 179 } listado b-8 month.java (final) 1 package org.jfree.date; 2 3 import java.text.dateformatsymbols; 4 5 public enum month { 6 january(1), february(2), march(3), 7 april(4), may(5), june(6), 8 july(7), august(8), september(9), 9 october(10),november(11),december(12); 10 private static dateformatsymbols dateformatsymbols = new dateformatsymbols(); 11 private static final int[] last_day_of_month = 12 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 13 14 private int index; 15 16 month(int index) { 17 this.index = index; 18 } 19 20 public static month fromint(int monthindex) { 21 for (month m : month.values()) { 22 if (m.index == monthindex) 23 return m; 24 } 25 throw new illegalargumentexception(“invalid month index ” + monthindex); 26 } 27 28 public int lastday() { 29 return last_day_of_month[index]; 30 } 31 32 public int quarter() { 33 return 1 + (index - 1) / 3; 50534 } 35 36 public string tostring() { 37 return dateformatsymbols.getmonths()[index - 1]; 38 } 39 40 public string toshortstring() { 41 return dateformatsymbols.getshortmonths()[index - 1]; 42 } 43 44 public static month parse(string s) { 45 s = s.trim(); 46 for (month m : month.values()) 47 if (m.matches(s)) 48 return m; 49 50 try { 51 return fromint(integer.parseint(s)); 52 } 53 catch (numberformatexception e) {} 54 throw new illegalargumentexception(“invalid month ” + s); 55 } 56 57 private boolean matches(string s) { 58 return s.equalsignorecase(tostring()) || 59 s.equalsignorecase(toshortstring()); 60 } 61 62 public int toint() { 63 return index; 64 } 65 } listado b-9 day.java (final) 1 package org.jfree.date; 2 3 import java.util.calendar; 4 import java.text.dateformatsymbols; 5 6 public enum day { 7 monday(calendar.monday), 8 tuesday(calendar.tuesday), 5069 wednesday(calendar.wednesday), 10 thursday(calendar.thursday), 11 friday(calendar.friday), 12 saturday(calendar.saturday), 13 sunday(calendar.sunday); 14 15 private final int index; 16 private static dateformatsymbols datesymbols = new dateformatsymbols(); 17 18 day(int day) { 19 index = day; 20 } 21 22 public static day fromint(int index) throws illegalargumentexception { 23 for (day d : day.values()) 24 if (d.index == index) 25 return d; 26 throw new illegalargumentexception( 27 string.format(“illegal day index: %d.”, index)); 28 } 29 30 public static day parse(string s) throws illegalargumentexception { 31 string[] shortweekdaynames = 32 datesymbols.getshortweekdays(); 33 string[] weekdaynames = 34 datesymbols.getweekdays(); 35 36 s = s.trim(); 37 for (day day : day.values()) { 38 if (s.equalsignorecase(shortweekdaynames[day.index]) || 39 s.equalsignorecase(weekdaynames[day.index])) { 40 return day; 41 } 42 } 43 throw new illegalargumentexception( 44 string.format(“%s is not a valid weekday string”, s)); 45 } 46 47 public string tostring() { 48 return datesymbols.getweekdays()[index]; 49 } 50 51 public int toint() { 52 return index; 53 } 50754 } listado b-10 dateinterval.java (final) 1 package org.jfree.date; 2 3 public enum dateinterval { 4 open { 5 public boolean isin(int d, int left, int right) { 6 return d > left && d < right; 7 } 8 }, 9 closed_left { 10 public boolean isin(int d, int left, int right) { 11 return d >= left && d < right; 12 } 13 }, 14 closed_right { 15 public boolean isin(int d, int left, int right) { 16 return d > left && d <= right; 17 } 18 }, 19 closed { 20 public boolean isin(int d, int left, int right) { 21 return d >= left && d <= right; 22 } 23 }; 24 25 public abstract boolean isin(int d, int left, int right); 26 } listado b-11 weekinmonth.java (final) 1 package org.jfree.date; 2 3 public enum weekinmonth { 4 first(1), second(2), third(3), fourth(4), last(0); 5 private final int index; 6 7 weekinmonth(int index) { 8 this.index = index; 5089 } 10 11 public int toint() { 12 return index; 13 } 14 } listado b-12 weekdayrange.java (final) 1 package org.jfree.date; 2 3 public enum weekdayrange { 4 last, nearest, next 5 } listado b-13 dateutil.java (final) 1 package org.jfree.date; 2 3 import java.text.dateformatsymbols; 4 5 public class dateutil { 6 private static dateformatsymbols dateformatsymbols = new dateformatsymbols(); 7 8 public static string[] getmonthnames() { 9 return dateformatsymbols.getmonths(); 10 } 11 12 public static boolean isleapyear(int year) { 13 boolean fourth = year % 4 == 0; 14 boolean hundredth = year % 100 == 0; 15 boolean fourhundredth = year % 400 == 0; 16 return fourth && (!hundredth || fourhundredth); 17 } 18 19 public static int lastdayofmonth(month month, int year) { 20 if (month == month.february && isleapyear(year)) 21 return month.lastday() + 1; 22 else 23 return month.lastday(); 50924 } 25 26 public static int leapyearcount(int year) { 27 int leap4 = (year - 1896) / 4; 28 int leap100 = (year - 1800) / 100; 29 int leap400 = (year - 1600) / 400; 30 return leap4 - leap100 + leap400; 31 } 32 } listado b-14 daydatefactory.java (final) 1 package org.jfree.date; 2 3 public abstract class daydatefactory { 4 private static daydatefactory factory = new spreadsheetdatefactory(); 5 public static void setinstance(daydatefactory factory) { 6 daydatefactory.factory = factory; 7 } 8 9 protected abstract daydate _makedate(int ordinal); 10 protected abstract daydate _makedate(int day, month month, int year); 11 protected abstract daydate _makedate(int day, int month, int year); 12 protected abstract daydate _makedate(java.util.date date); 13 protected abstract int _getminimumyear(); 14 protected abstract int _getmaximumyear(); 15 16 public static daydate makedate(int ordinal) { 17 return factory._makedate(ordinal); 18 } 19 20 public static daydate makedate(int day, month month, int year) { 21 return factory._makedate(day, month, year); 22 } 23 24 public static daydate makedate(int day, int month, int year) { 25 return factory._makedate(day, month, year); 26 } 27 28 public static daydate makedate(java.util.date date) { 29 return factory._makedate(date); 30 } 51031 32 public static int getminimumyear() { 33 return factory._getminimumyear(); 34 } 35 36 public static int getmaximumyear() { 37 return factory._getmaximumyear(); 38 } 39 } listado b-15 spreadsheetdatefactory.java (final) 1 package org.jfree.date; 2 3 import java.util.*; 4 5 public class spreadsheetdatefactory extends daydatefactory { 6 public daydate _makedate(int ordinal) { 7 return new spreadsheetdate(ordinal); 8 } 9 10 public daydate _makedate(int day, month month, int year) { 11 return new spreadsheetdate(day, month, year); 12 } 13 14 public daydate _makedate(int day, int month, int year) { 15 return new spreadsheetdate(day, month, year); 16 } 17 18 public daydate _makedate(date date) { 19 final gregoriancalendar calendar = new gregoriancalendar(); 20 calendar.settime(date); 21 return new spreadsheetdate( 22 calendar.get(calendar.date), 23 month.fromint(calendar.get(calendar.month) + 1), 24 calendar.get(calendar.year)); 25 } 26 27 protected int _getminimumyear() { 28 return spreadsheetdate.minimum_year_supported; 29 } 30 31 protected int _getmaximumyear() { 51132 return spreadsheetdate.maximum_year_supported; 33 } 34 } listado b-16 spreadsheetdate.java (final) 1 /* ============================================================== 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================== 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * … 52 * 53 */ 54 55 package org.jfree.date; 56 57 import static org.jfree.date.month.february; 58 59 import java.util.*; 60 61 /** 62 * representa una fecha con un entero, de forma similar a la 63 * implementación en microsoft excel. el intervalo de fechas admitido es 64 * del 1-ene-1900 al 31-dic-9999. 65 * <p/> 66 * recuerde que excel tiene un error que reconoce el año 67 * 1900 como bisiesto cuando en realidad no lo es. encontrará más 68 * información en el sitio de microsoft, en el artículo q181370: 69 * <p/> 70 * http://support.microsoft.com/support/kb/articles/q181/3/70.asp 71 * <p/> 72 * excel usa como convención que el 1-ene-1900 = 1. esta clase usa la 73 * convención de que el 1-ene-1900 = 2. 74 * como resultado, el número de día de esta clase será diferente al de 75 * excel para enero y febrero de 1900… pero excel añade un día 76 * más (29-feb-1900 que en realidad no existe) y a partir de ahí 77 * los números de los días coinciden. 78 * 79 * @author david gilbert 80 */ 81 public class spreadsheetdate extends daydate { 51282 public static final int earliest_date_ordinal = 2; // 1/1/1900 83 public static final int latest_date_ordinal = 2958465; // 12/31/9999 84 public static final int minimum_year_supported = 1900; 85 public static final int maximum_year_supported = 9999; 86 static final int[] aggregate_days_to_end_of_preceding_month = 87 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 88 static final int[] leap_year_aggregate_days_to_end_of_preceding_month = 89 {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 90 91 private int ordinalday; 92 private int day; 93 private month month; 94 private int year; 95 96 public spreadsheetdate(int day, month month, int year) { 97 if (year < minimum_year_supported || year > maximum_year_supported) 98 throw new illegalargumentexception( 99 “the ‘year’ argument must be in range ” + 100 minimum_year_supported + “ to ” + maximum_year_supported + “.”); 101 if (day < 1 || day > dateutil.lastdayofmonth(month, year)) 102 throw new illegalargumentexception(“invalid ‘day’ argument.”); 103 104 this.year = year; 105 this.month = month; 106 this.day = day; 107 ordinalday = calcordinal(day, month, year); 108 } 109 110 public spreadsheetdate(int day, int month, int year) { 111 this(day, month.fromint(month), year); 112 } 113 114 public spreadsheetdate(int serial) { 115 if (serial < earliest_date_ordinal || serial > latest_date_ordinal) 116 throw new illegalargumentexception( 117 “spreadsheetdate: serial must be in range 2 to 2958465.”); 118 119 ordinalday = serial; 120 calcdaymonthyear(); 121 } 122 123 public int getordinalday() { 124 return ordinalday; 125 } 513126 127 public int getyear() { 128 return year; 129 } 130 131 public month getmonth() { 132 return month; 133 } 134 135 public int getdayofmonth() { 136 return day; 137 } 138 139 protected day getdayofweekforordinalzero() {return day.saturday;} 140 141 public boolean equals(object object) { 142 if (!(object instanceof daydate)) 143 return false; 144 145 daydate date = (daydate) object; 146 return date.getordinalday() == getordinalday(); 147 } 148 149 public int hashcode() { 150 return getordinalday(); 151 } 152 153 public int compareto(object other) { 154 return dayssince((daydate) other); 155 } 156 157 private int calcordinal(int day, month month, int year) { 158 int leapdaysforyear = dateutil.leapyearcount(year - 1); 159 int daysuptoyear = (year - minimum_year_supported) * 365 + leapdaysforyear; 160 int daysuptomonth = aggregate_days_to_end_of_preceding_month[month.toint()]; 161 if (dateutil.isleapyear(year) && month.toint() > february.toint()) 162 daysuptomonth++; 163 int daysinmonth = day - 1; 164 return daysuptoyear + daysuptomonth + daysinmonth + earliest_date_ordinal; 165 } 166 167 private void calcdaymonthyear() { 168 int days = ordinalday - earliest_date_ordinal; 514169 int overestimatedyear = minimum_year_supported + days / 365; 170 int nonleapdays = days - dateutil.leapyearcount(overestimatedyear); 171 int underestimatedyear = minimum_year_supported + nonleapdays / 365; 172 173 year = huntforyearcontaining(ordinalday, underestimatedyear); 174 int firstordinalofyear = firstordinalofyear(year); 175 month = huntformonthcontaining(ordinalday, firstordinalofyear); 176 day = ordinalday - firstordinalofyear - daysbeforethismonth(month.toint()); 177 } 178 179 private month huntformonthcontaining(int anordinal, int firstordinalofyear) { 180 int daysintothisyear = anordinal - firstordinalofyear; 181 int amonth = 1; 182 while (daysbeforethismonth(amonth) < daysintothisyear) 183 amonth++; 184 185 return month.fromint(amonth - 1); 186 } 187 188 private int daysbeforethismonth(int amonth) { 189 if (dateutil.isleapyear(year)) 190 return leap_year_aggregate_days_to_end_of_preceding_month[amonth] - 1; 191 else 192 return aggregate_days_to_end_of_preceding_month[amonth] - 1; 193 } 194 195 private int huntforyearcontaining(int anordinalday, int startingyear) { 196 int ayear = startingyear; 197 while (firstordinalofyear(ayear) <= anordinalday) 198 ayear++; 199 200 return ayear - 1; 201 } 202 203 private int firstordinalofyear(int year) { 204 return calcordinal(1, month.january, year); 205 } 206 207 public static daydate createinstance(date date) { 208 gregoriancalendar calendar = new gregoriancalendar(); 209 calendar.settime(date); 210 return new spreadsheetdate(calendar.get(calendar.date), 515211 month.fromint(calendar.get(calendar.month) + 1), 212 calendar.get(calendar.year)); 213 214 } 215 } 516epílogo en 2005, mientras asistía a la conferencia agile en denver (ee.uu.), elisabeth hedrickson [125] me dio una pulsera verde parecida a la que lance armstrong popularizó hace unos años. en ésta se leía test obsessed (obsesionado por las pruebas). me la puse y la lucí con orgullo. desde que aprendí el tdd de kent beck en 1999, sin duda el desarrollo controlado por pruebas me ha obsesionado. pero sucedió algo extraño. no me podía quitar la pulsera. no porque se hubiera quedado físicamente pegada, sino porque estaba moralmente pegada. la pulsera resumía mi ética profesional. era un indicador visible de mi compromiso por crear el mejor código posible. si me la hubiera quitado habría traicionado a esa ética y a ese compromiso. y todavía la llevo en la muñeca. cuando escribo código, la veo ahí. es un recordatorio constante de la promesa que me hice de escribir código limpio. 517robert cecil “uncle bob” martin (palo alto california, estados unidos, 1952). es un prestigioso desarrollador de software desde 1970 y consultor internacional desde 1990. es fundador y presidente de object mentor, inc., un equipo de experimentados consultores que ayudan a clientes de todo el mundo en diferentes campos de la programación como c++, java, c#, ruby, programación orientada a objetos (poo), patrones de diseño, uml, metodologías ágiles y programación extreme. 518notas 519[1] [beck07]. << 520[2] cuando ignaz semmelweis recomendó en 1847 que los médicos se lavaran las manos, su propuesta fue rechazada aludiendo que los doctores estaban demasiado ocupados para hacerlo entre paciente y paciente. << 521[3] http://www.pragmaticprogrammer.com/booksellers/2004-12.html. << 522[4] [knuth92]. << 523[5] es una adaptación del mensaje de despedida de robert stephenson smyth baden-powell a los scouts: «intentad dejar este mundo un poco mejor de como os lo encontrasteis…». << 524[6] como veremos más adelante, aunque un contenedor sea una lista , no conviene codificar el tipo de contenedor en el nombre. << 525[7] imagine que se crea una variable con el nombre klass sólo porque el nombre class se ha usado en otro elemento. << 526[8] uncle bob solía hacerlo en c++ pero ha abandonado esta práctica ya que no es necesario en los ide modernos. << 527[9] http://java.sun.com/products/javabeans/docs/spec.html. << 528[10] una herramienta de pruebas de código abierto (www.fitnese.org). << 529[11] una herramienta de código abierto para probar unidades para java ( www.junit.org ). << 530[12] le pregunté a kent si todavía conservaba una copia, pero no la encontró. busqué en mis viejos ordenadores, pero nada. solamente se conserva el recuerdo de aquél programa. << 531[13] el lenguaje logo usaba la palabra clave to al igual que ruby y python usaban def . por tanto, todas las funciones comenzaban por to , lo que tenía un efecto interesante en cómo se diseñaban. << 532[14] [kp78], p. 37. << 533[15] y, por supuesto, se incluyen cadenas if/else. << 534[16] a. http://en.wikipedia.org/wiki/single_responsibility_principle b. http://www.objectmentor.com/resources/articles/srp.pdf << 535[17] a. http://en.wikipedia.org/wiki/open/closed_principle b. http://www.objectmentor.com/resources/articles/ocp.pdf << 536[18] [gof]. << 537[19] terminé la refactorización de un módulo que usaba la forma dinámica. conseguí convertir el módulo outputstream en un campo de la clase y las invocaciones de writefield a formato monódico. el resultado fue mucho más limpio. << 538[20] existen algunos que creen que pueden evitar volver a compilar e implementar, y nos hemos encargado de ellos. << 539[21] ejemplo de principio abierto/cerrado (ocp) [ppp02]. << 540[22] el principio dry. [prag]. << 541[23] [sp72]. << 542[24] [kp78], p. 144. << 543[25] la tendencia actual de los ide de comprobar la ortografía de los comentarios será un bálsamo para los que tenemos que leer gran cantidad de código. << 544[26] el cuadro muestra sigma/2 por encima y debajo de la media. asumo que la distribución de la longitud de archivos no es normal, por lo que la desviación estándar no es matemáticamente precisa. pero aquí el objetivo no es la precisión, sino la sensación. << 545[27] es lo contrario a lo que sucede en lenguajes como pascal, c y c++ que obligan a definir, o al menos a declarar, las funciones antes de usarlas. << 546[28] ¿a quien voy a engañar? sigo siendo programador de lenguajes de ensamblado. en este caso, el hábito sí hace al monje. << 547[29] siempre existe una solución conocida por los diseñadores orientados a objetos con experiencia: visitor o entrega dual, por ejemplo. pero son técnicas costosas y suelen devolver la estructura de un programa por procedimientos. << 548[30] http://es.wikipedia.org/wiki/ley_de_demeter. << 549[31] de la estructura apache. << 550[32] en ocasiones se denomina feature envy (envidia de las características), de [refactoring]. << 551[33] [martin]. << 552[34] [becktdd], pp. 136-137. << 553[35] véase el patrón del adaptador en [gof]. << 554[36] más información al respecto en [welc]. << 555[37]  professionalism and test-driven development , robert c. martin, object mentor, ieee software, mayo/junio 2007 (vol. 24, no. 3) pp. 32-36 http://doi.ieeecomputersociety.org/10.1109/ms.2007.85 << 556[38] http://fitnesse.org/fitnesse.acceptancetestpatterns. << 557[39] véase el apartado sobre asignaciones mentales del capítulo 2. << 558[40] véase la entrada de dave astel: http://www.artima.com/weblogs/viewpost.jsp?thread=35578 << 559[41] [rspec]. << 560[42] [gof]. << 561[43] ¡cíñase al código! << 562[44] materiales de formación de object mentor. << 563[45] [rdd]. << 564[46] encontrará más información sobre este principio en [ppp]. << 565[47] [knuth92]. << 566[48] [ppp]. << 567[49] [ppp]. << 568[50] [mezzaros07]. << 569[51] [gof]. << 570[52] véase, por ejemplo, [fowler]. << 571[53] véase [spring], también existe una estructura spring.net. << 572[54] no olvide que la creación de instancias/evaluación tardía es sólo una optimización, puede que prematura. << 573[55] sistema de administración de base de datos. << 574[56] consulte [aosd] si necesita información general sobre aspectos y [aspectj] y [colyer] para información concreta de aspectj. << 575[57] no se necesita la modificación manual del código fuente de destino. << 576[58] véase [cglib], [asm] y [javassist]. << 577[59] si necesita ejemplos más detallados de la api proxy y ejemplos de uso, consulte [goetz]. << 578[60] aop se suele confundir con técnicas empleadas para implementarlo, como la intercepción y envoltorio de métodos a través de proxies . el verdadero valor de un sistema aop es la capacidad para especificar comportamientos del sistema de forma concisa y modular. << 579[61] véase [spring] y [jboss]. java puro significa sin aspectj. << 580[62] adaptado de www.theserverside.com/tt/articles/article.tss? l=introtospring25. << 581[63] [gof]. << 582[64] el ejemplo se puede simplificar mediante mecanismos que usen convenciones y anotaciones de java 5 para reducir la cantidad necesaria de lógica de conexión explícita. << 583[65] adaptado de http://www.onjava.com/pub/a/onjava/2006/05/17/standardizing-with-ejb3- java-persistence-api.html. << 584[66] véase [aspectj] y [colyer]. << 585[67] no confundir con la práctica de diseño anticipado. bduf es la práctica de diseñar todo por adelantado antes de implementar nada. << 586[68] existe una cantidad significativa de exploración iterativa y detalles de análisis, incluso una vez iniciada la construcción. << 587[69] el término fue empleado por primera vez por [kolence]. << 588[70] el trabajo de [alexander] ha sido una gran influencia para la comunidad de software . << 589[71] véase, por ejemplo, [dsl]. [jmock] es un buen ejemplo de api de java que crea un dsl. << 590[72] [xpe]. << 591[73] [gof]. << 592[74] correspondencia privada. << 593[75] rayos cósmicos, repeticiones, etc. << 594[76] véase el apéndice a. << 595[77] véase el apéndice a. << 596[78] [ppp]. << 597[79] véase el apéndice a. << 598[80] [prag]. << 599[81] [lea99]. << 600[82] http://en.wikipedia.org/wiki/producer-consumer. << 601[83] http://en.wikipedia.org/wiki/readers-writers_problem. << 602[84] http://es.wikipedia.org/wiki/problema_de_la_cena_de_los_filósofos. << 603[85] véase el apéndice a. << 604[86] una sección crítica es cualquier sección de código que debe protegerse de usos simultáneos por parte del programa para que sea correcta. << 605[87] véase el apéndice a. << 606[88] véase el apéndice a. << 607[89] ¿sabía que el modelo de procesos de java no garantiza el procesamiento preventivo? los so modernos sí lo hacen, de modo que lo obtiene de forma gratuita. no obstante, la mvj no lo garantiza. << 608[90] no es estrictamente el caso. como la mvj no garantiza los procesos preventivos, un determinado algoritmo puede que siempre funcione en un so que no prevea los procesos. lo contrario también es posible, pero por distintos motivos. << 609[91] https://www.ibm.com/developerworks/community/groups/service/html/communityview? lang=es&communityuuid=18d10b14-e2c8-4780-bace-9af1fc463cc0. << 610[92] hace poco modifiqué este módulo para ruby. tenía una séptima parte del tamaño original y una mejor estructura. << 611[93] para evitar este tipo de sorpresas, añadí una nueva prueba de unidad que invocaba todas las pruebas de fitnesse. << 612[94]  junit pocket guide , kent beck, o’reilly. 2004. p. 43. << 613[95] véase el capítulo 1. << 614[96] una solución mejor sería que el javadoc presentara todos los comentarios con formato previo, para que tengan el mismo aspecto en el código y en el documento. << 615[97] algunos revisores de este texto no comparten esta decisión. sostienen que en una estructura de código abierto es más recomendable ejercer control manual sobre el id de serie para que los cambios mínimos del software no invaliden las fechas señalizadas antiguas. me parece justo. sin embargo, al menos el fallo, aunque sea inconveniente, tiene un motivo evidente. por otra parte, si el autor de la clase se olvida de actualizar el id, el modo de fallo será indefinido y puede que silencioso. creo que la moraleja es que no debe esperar a deserializar entre versiones. << 616[98] [gof]. << 617[99] ibid. << 618[100] ibid. << 619[101] [simmons04], p. 73. << 620[102] [refactoring]. << 621[103] [beck97]. << 622[104] [refactoring]. << 623[105] http://es.wikipedia.org/wiki/principio_de_la_mínima_sorpresa << 624[106] [prag]. << 625[107] [gof]. << 626[108] [gof]. << 627[109] [refactoring]. << 628[110] en concreto, el principio de responsabilidad única, el principio abierto/cerrado y el principio de cierre común. véase [ppp]. << 629[111] [beck97], p. 108. << 630[112] [beck07]. << 631[113] es distinto saber cómo funciona el código y saber si el algoritmo se encargará de realizar la tarea para la que se necesita. es habitual desconocer si un algoritmo es el adecuado. desconocer lo que hace el código es indolencia. << 632[114] o mejor todavía, una clase money que use enteros. << 633[115] [prag]. p. 138. << 634[116] véase la cita de ward cunningham del capítulo 1. << 635[117] [ddd]. << 636[118] puede comprobar personalmente el código antes y después, y revisar las versiones con y sin subprocesos, que veremos en un apartado posterior. << 637[119] es una comparación simplificada, pero para los objetivos de este ejercicio es un modelo válido. << 638[120] de hecho, la interfaz iterator es incompatible con subprocesos por naturaleza. no se diseñó para usar varios subprocesos, de modo que no debería sorprenderle. << 639[121] por ejemplo, alguien añade un resultado de depuración y el problema desaparece. el código de depuración corrige el problema, pero permanece en el sistema. << 640[122] siglas de there ain’t no such thing as a free lunch (todo tiene un precio). << 641[123] http://www.haifa.ibm.com/projects/verification/contest/index.html << 642[124] véase [lea99] p. 191. << 643[125] http://www.qualitytree.com/ << 644cada año, se invierten innumerables horas y se pierden numerosos recursos debido a código mal escrito, ralentizando el desarrollo, disminuyendo la productividad, generando graves fallos e incluso pudiendo acabar con la organización o empresa. el reconocido experto de software robert c. martin, junto con sus colegas de object mentor, nos presentan sus óptimas técnicas y metodologías ágiles para limpiar el código sobre la marcha y crearlo de forma correcta, de este modo mejorará como programador. esta obra se divide en tres partes. la primera describe los principios, patrones y prácticas para crear código limpio. la segunda incluye varios casos de estudio cuya complejidad va aumentando. cada ejemplo es un ejercicio de limpieza y transformación de código con problemas. la tercera parte del libro contiene una lista de heurística y síntomas de código erróneo (smells) confeccionada al crear los casos prácticos. el resultado es una base de conocimientos que describe cómo pensamos cuando creamos, leemos y limpiamos código. imprescindible para cualquier desarrollador, ingeniero de software, director de proyectos, jefe de equipo o analista de sistemas interesado en crear código de mejor calidad. ¡el libro que todo programador debe leer! 2robert cecil martin código limpio manual de estilo para el desarrollo ágil de software epub r1.1 xcuidi 21.03.2018 3título original: clean code: a handbook of agile software craftsmanship robert cecil martin, 2009 traducción: josé luis gómez celador ilustraciones: jeniffer kohnke & angela brooks editor digital: xcuidi colaborador: mario j. c. (pdf-español) epub base r1.2 este libro se ha maquetado siguiendo los estándares de calidad de www.epublibre.org. la página, y sus editores, no obtienen ningún tipo de beneficio económico por ello. si ha llegado a tu poder desde otra web debes saber que seguramente sus propietarios sí obtengan ingresos publicitarios mediante archivos como este 4para ann marie: el verdadero amor de mi vida. 5agradecimientos me gustaría dar las gracias a mis dos artistas, jeniffer kohnke y angela brooks. jennifer es la encargada de las impresionantes ilustraciones del inicio de cada capítulo y también de los retratos de kent beck, ward cunningham, bjarne stroustrup, ron jeffries, grady booch, dave thomas, michael feathers y el mío propio. angela se encarga de las ilustraciones internas de los capítulos. ha realizado muchos dibujos para mí en los últimos años, incluidos muchos de los del libro agile software development: principles, patterns, and practices . también es mi primogénita. un agradecimiento especial a los revisores bob bogetti, george bullock, jeffrey overbey y especialmente matt heusser. han sido increíbles. han sido inmisericordes. han sido minuciosos. me han forzado al máximo para realizar las mejoras necesarias. gracias a mi editor, chris guzikowski, por su apoyo, aliento y amistad. gracias a todo el personal de la editorial, incluida raina chrobak, que se encargó de que fuera honesto y cumpliera los plazos. gracias a micah martin y a todos los de 8th light (www.8thlight.com) por sus críticas y su apoyo. gracias a todos los object mentor, pasados, presentes y futuros, incluidos bob koss, michael feathers, michael hill, erik meade, jeff langr, pascal roy, david farber, brett schuchert, dean wampler, tim ottinger, dave thomas, james grenning, brian button, ron jeffries, lowell lindstrom, angelique martin, cindy sprague, libby ottinger, joleen craig, janice 6brown, susan rosso y el resto. gracias jim newkirk, mi amigo y socio, que me ha enseñado más de lo que cree. mi agradecimiento a kent beck, martin fowler, ward cunningham, bjarne stroustrup, grady booch y todos mis mentores, compatriotas y colegas. gracias a john vlissides por estar ahí cuando lo necesitaba. gracias a todos los de zebra por permitirme despotricar sobre la extensión que debe tener una función. y, por último, darle las gracias por leer estos agradecimientos. 7prólogo una de nuestras golosinas preferidas en dinamarca es ga-jol , con un fuerte sabor a regaliz, que constituye un complemento perfecto para nuestro húmedo y frío clima. parte del encanto de ga-jol para los daneses es la frase que suele incluir en el envoltorio. esta mañana compré un paquete de dos y me encontré con este antiguo dicho danés: ærlighed i små ting er ikke nogen lille ting. «la honestidad por las cosas pequeñas no es algo menor». perfecto para que lo que pensaba escribir. las cosas pequeñas importan. este libro trata sobre humildes preocupaciones cuyo valor dista mucho de ser menor. 8dios está en los detalles , afirmó el arquitecto ludwig mies van der rohe. esta cita recuerda argumentos contemporáneos sobre el papel de la arquitectura en el desarrollo de software , en especial en el universo ágil. bob y yo hemos tenido esta conversación muchas veces. y sí, mies van der rohe se fijaba en la utilidad y la forma atemporal de la construcción que subyace a las grandes creaciones arquitectónicas. por otra parte, seleccionaba personalmente los pomos de todas las puertas de todas las casas que diseñaba. ¿por qué? porque las cosas pequeñas importan. en nuestro interminable debate sobre tdd, bob y yo coincidimos en que la arquitectura del software desempeña una importante labor en el desarrollo, aunque tenemos diferentes visiones de lo que esto significa. estas diferencias carecen de importancia, ya que podemos aceptar que los profesionales responsables dedican parte de su tiempo a planificar un proyecto antes de comenzarlo. las nociones de diseño controlado únicamente por pruebas y el código, propias de finales de la década de 1990, ya no son válidas. y la atención al detalle es un pilar fundamental de los profesionales, casi como cualquier visión. por un lado, la práctica en los detalles otorga dominio a los profesionales, y aumenta su confianza para la práctica a mayor escala. por otra parte, el más mínimo fallo de construcción, una puerta que no cierre bien o un baldosín mal colocado, acaba con el encanto del todo. de eso se trata el código limpio. pero la arquitectura es sólo una metáfora del desarrollo de software y en concreto de la parte del software que ofrece el producto inicial, de la misma forma que un arquitecto entrega un edificio inmaculado. hoy en día, el objetivo es comercializar rápidamente los productos. queremos que las fábricas produzcan software a pleno rendimiento. se trata de fábricas humanas, programadores que piensan, que sienten y que trabajan para crear un producto. la metáfora de la manufacturación es incluso más evidente en este pensamiento. los aspectos productivos de las fábricas de automóviles japonesas fueron una gran inspiración para serum. pero incluso en la industria automovilística, gran parte del trabajo no radica en la fabricación sino en el mantenimiento, o más bien en cómo evitarlo. en el software , el 80 por 100 o más de lo que hacemos se denomina cuantitativamente mantenimiento, el acto de reparar. en lugar de optar por la 9típica costumbre occidental de crear software de calidad, debemos pensar como reparadores o mecánicos. ¿qué piensan los directores japoneses de todo esto? en 1951, un enfoque de calidad denominado tpm ( total productive maintenance o mantenimiento productivo total) apareció en escena. se centraba en el mantenimiento y no en la producción. uno de los pilares de tpm es el conjunto de principios denominados 5s, una serie de disciplinas. estos principios 5s son en realidad la base lean, otro conocido término en la escena occidental, y cada vez más presente en el mundo del software . estos principios no son opcionales. como indica uncle bob, la práctica del software correcto requiere disciplina. no siempre se trata de hacer, de producir a la velocidad óptima. la filosofía 5s incluye estos conceptos: seiri u organización : es fundamental saber dónde están las cosas, mediante enfoques como el uso de nombres correctos. ¿cree que los nombres de los identificadores no son relevantes? lea los siguientes capítulos. seiton o sistematización : existe un antiguo dicho norteamericano: un sitio para cada cosa y cada cosa en su sitio. un fragmento de código debe estar donde esperamos encontrarlo; en caso contrario, refactorice hasta conseguirlo. seiso o limpieza : mantenga limpio el lugar de trabajo. ¿qué dicen los autores sobre inundar el código de comentarios y líneas que capturan historias o deseos futuros? elimínelos. seiketsu o estandarización : el grupo decide cómo mantener limpio el lugar de trabajo. ¿cree que este libro habla sobre tener un estilo de código coherente y una serie de prácticas dentro del grupo? ¿de dónde provienen esos estándares? siga leyendo. shutsuke o disciplina : significa ser disciplinado en la aplicación de las prácticas y reflejarlas en el trabajo y aceptar los cambios. si acepta el reto, ha leído bien, el reto, de leer y llevar a la práctica este libro, podrá comprender y apreciar el último punto. aquí nos acercamos a la 10raíz de la profesionalidad responsable de una profesión que debería preocuparse del ciclo vital de un producto. al igual que mantenemos coches y otras máquinas, el mantenimiento divisible, esperar a que surjan los errores, es la excepción. por el contrario, ascendemos un nivel: inspeccionamos diariamente las máquinas y arreglamos los componentes gastados antes de que se rompan, o cambiamos el aceite cada varios miles de kilómetros para evitar problemas. en el código, debemos refactorizar sin compasión. puede ascender otro nivel más, como hizo el movimiento tpm hace 50 años: crear máquinas que se pueden mantener mejor. crear código legible es tan importante como crear código ejecutable. la práctica definitiva, que apareció en los círculos tpm en 1960, es la que se centra en introducir nuevas máquinas o sustituir las antiguas. como fred brooks nos advirtió, deberíamos rehacer el software cada siete años para eliminar los problemas latentes. tendríamos que actualizar este plazo por semanas, días e incluso horas en lugar de años. ahí es donde se encuentra el detalle. el detalle tiene un gran poder, y es un enfoque vital humilde y profundo, como es de esperar de cualquier enfoque de origen japonés. pero no es sólo la visión oriental de la vida; también lo encontramos en el pueblo norteamericano. la cita seiton anterior proviene de la pluma de un ministro de ohio que, literalmente, consideraba la limpieza como un remedio para todas las formas del mal. ¿y seiso ? la limpieza es la pureza . aunque una casa sea bella, el mobiliario inadecuado acaba con su encanto. ¿y la opinión de shutsuke al respecto? el que confíe en lo pequeño confiará en lo superior . ¿y la predisposición a refactorizar en el momento adecuado, reforzando nuestra posición para las posteriores grandes decisiones, en lugar de dejarlo pasar? una puntada a tiempo ahorra ciento. al que madruga, dios le ayuda. no dejes para mañana lo que puedas hacer hoy (éste era el sentido original de la frase «en el momento adecuado» de lean hasta que cayó en manos de consultores de software ). ¿y sobre calibrar la importancia de los pequeños esfuerzos individuales en un todo mayor? de pequeñas semillas crecen grandes árboles . ¿y la integración de sencillas tareas preventivas en la vida diaria? más vale prevenir que curar . el código limpio honra las raíces de la sabiduría popular, de antes o de ahora, y se puede aplicar con atención al detalle. 11incluso en la literatura arquitectónica encontramos ejemplos de estos detalles. piense en los pomos de mies van der rohe. eso es seiri . es la atención a todos los nombres de variables. debe bautizar a una variable con el mismo cuidado como si fuera su primogénito. y como todo sabemos, este cuidado no acaba nunca. el arquitecto christopher alexander, padre de patrones y lenguajes de patrones, considera todo acto de diseño como un pequeño acto local de reparación, y considera la maestría de la estructura como competencia única del arquitecto; las formas mayores se ceden a los patrones y su aplicación a los habitantes. el diseño es interminable no sólo al añadir una nueva habitación a una casa, sino al prestar atención a la pintura, a cambiar las alfombras o a instalar un nuevo fregadero en la cocina. otras artes muestran sentimientos análogos. en nuestra búsqueda por la importancia de los detalles, nos topamos con el autor francés del siglo xix gustav flaubert. el poeta francés paul valery afirma que un poema no se acaba nunca y que tiene que retocarse continuamente, y que dejar de trabajar en el poema es señal de abandono. tal preocupación por el detalle es común en todas las empresas de excelencia. puede que esto no sea nada nuevo, pero al leer este libro sentirá la necesidad de adoptar disciplinas rechazadas en su momento por apatía o por un deseo de espontaneidad o una simple respuesta al cambio. desafortunadamente, no solemos considerar estas preocupaciones la clave del arte de la programación. renunciamos pronto a nuestro código, no porque lo hayamos completado, sino porque nuestro sistema de valores se centra en el futuro más que en la sustancia de nuestros productos. esto tiene un precio final: hierba mala nunca muere . la investigación, ni en el mundo industrial ni en el académico, se reduce a mantener limpio el código. cuando trabajaba en la organización bell labs software production research (sin duda de producción) comprobamos que un estilo de sangrado coherente era uno de los mayores indicadores estadísticamente significativos de una baja densidad de errores. queremos que una arquitectura, un lenguaje de programación u otra noción superior sea el motivo de la calidad; como seres cuya supuesta profesionalidad se debe al dominio de herramientas y métodos de diseño, nos sentimos insultados por el valor que los programadores añaden con tan sólo aplicar un estilo de sangrado coherente. 12para citar mi propio libro de hace 17 años, dicho estilo distingue la excelencia de la simple competencia. la visión japonesa comprende el verdadero valor del trabajador cotidiano y, en especial, de los sistemas de desarrollo que dependen de las sencillas acciones diarias de tales trabajadores. la calidad es el resultado de un millón de acciones cuidadosas, no de un método magnífico caído del cielo. que dichas acciones sean simples no significa que sean simplistas, y mucho menos que sean sencillas. son la base de la grandeza y, cada vez más, de cualquier empresa humana. ignorarlas no es humano en absoluto. evidentemente, todavía defiendo el pensamiento global, en especial el valor de los enfoques arquitectónicos cimentados en el conocimiento de los dominios y la capacidad de uso del software . este libro no versa sobre esto, al menos no de forma evidente. este libro transmite un mensaje más sutil cuya profundidad no debe menospreciarse. coincide con la visión de gente como peter sommerlad, kevlin henney y giovanni asproni, cuyos mantras son «el código es el diseño» y «código simple». aunque debemos recordar que la interfaz es el programa y que sus estructuras dicen mucho sobre la propia estructura del programa, es fundamental adoptar de forma continuada la humilde posición de que el diseño vive en el código. y aunque los cambios y la metáfora de la fábrica supongan costes, los cambios de diseño suponen valor. debemos considerar al código como la articulación de los esfuerzos de diseño, visto como un proceso, no como algo estático. es en el código donde se desarrollan los conceptos arquitectónicos de conexión y cohesión. si escucha a larry constantine describir la conexión y la cohesión, lo hace en términos del código, no desde conceptos abstractos propios de uml. en su ensayo abstraction descant , richard gabriel afirma que la abstracción es el mal. el código es el remedio al mal y el código limpio puede que sea divino. volviendo a mi caja de ga-jol , considero importante recordar que la sabiduría danesa nos recomienda no sólo prestar atención a las pequeñas cosas, sino también ser honestos con ellas. esto significa ser honesto con el código, con nuestros colegas sobre el estado del código y, en especial, con nosotros mismos. ¿hemos hecho todo lo posible para dejar las cosas mejor que como las encontramos? ¿hemos refactorizado el código antes de terminarlo? no se trata de preocupaciones periféricas, sino que se encuentran 13en la base misma de los valores agile. en serum se recomienda que la refactorización sea parte del concepto de terminado. ni la arquitectura ni el código limpio insisten en la perfección, sino en la honestidad y en hacerlo lo mejor posible. errar es humano; perdonar es divino . en serum, todo lo hacemos de forma visible. aireamos los trapos sucios. somos honestos sobre el estado de nuestro código ya que nunca es perfecto. nos hemos hecho más humanos, más merecedores de lo divino y estamos más próximos a la grandeza de los detalles. en nuestra profesión, necesitamos desesperadamente toda la ayuda posible. si un suelo seco reduce el riesgo de resbalones y las herramientas bien organizadas aumentan la productividad, es nuestra meta. y en cuanto al libro, es la mejor aplicación pragmática de los principios lean de software que he visto nunca en formato impreso. no esperaba menos de este grupo de individuos que durante años se han esforzado no sólo por mejorar sino en ofrecer sus conocimientos a la industria mediante obras como la que ahora tiene entre manos. hace que el mundo sea un poco mejor que antes de que uncle bob me enviara el manuscrito. y tras completar este ejercicio, me dispongo a limpiar mi escritorio. james o. coplien mørdrup, dinamarca 14introducción reproducido con permiso de thom holwerda. http://www.osnews.com/story/19266/wtfs_m. © 2008 focus shift. ¿qué puerta representa su código? ¿qué puerta representa a su equipo o a su 15empresa? ¿por qué estamos en esa habitación? ¿es una sencilla revisión del código o hemos detectado un sinfín de problemas terribles? ¿depuramos presas del pánico el código que pensábamos que funcionaba? ¿los clientes huyen despavoridos y los directores nos pisan los talones? ¿cómo asegurarnos de que abrimos la puerta correcta cuando las cosas se ponen feas? la respuesta: la maestría . la maestría se consigue de dos formas: conocimientos y trabajo. debe adquirir el conocimiento de los principios, patrones, prácticas y heurística propios de un maestro, y dominar dichos conocimientos a través de la práctica. puedo enseñarle la teoría de montar en bicicleta. de hecho, los conceptos matemáticos clásicos son muy sencillos. gravedad, fricción, velocidad angular, centro de masa, etc., se pueden demostrar en menos de una página repleta de ecuaciones. con esas fórmulas, puedo demostrar que montar en bicicleta es práctico y proporcionarle los conocimientos necesarios para conseguirlo. pero la primera vez que se monte en una bici se caerá al suelo. el diseño de código no es diferente. podríamos enumerar todos los principios del código limpio y confiar en que se encargue del resto (es decir, dejar que se cayera de la bici) pero entonces la pregunta sería qué clase de profesores somos y qué clase de alumno sería. no. así no funciona este libro. aprender a crear código limpio es complicado . requiere algo más que conocer principios y patrones. tiene que sudar. debe practicarlo y fallar. debe ver cómo otros practican y fallan. debe observar cómo se caen y recuperan el paso. debe ver cómo agonizan en cada decisión y el precio que pagan por tomar decisiones equivocadas. para leer este libro, prepárese a trabajar duro. no es un libro que se pueda leer en un avión y terminarlo antes de aterrizar. este libro le hará trabajar, y mucho. ¿y qué tipo de trabajo? tendrá que leer código, en abundancia. y se le pedirá que piense en qué acierta el código y en qué falla. se le pedirá que siga nuestras descripciones mientras despedazamos módulos y los volvemos a ensamblar. para ello necesitará tiempo y esfuerzo, pero creemos que merece la pena. hemos dividido el libro en tres partes. los primeros capítulos describen 16los principios, patrones y prácticas para crear código limpio. incluyen abundante código y resultan difíciles de leer. sirven como preparación a la segunda parte. si abandona tras leer la primera sección, que tenga buena suerte. la segunda parte del libro es la más difícil. incluye varios casos de estudio cuya complejidad va aumentando. cada ejemplo es un ejercicio de limpieza de código, transformar código con problemas para que tenga menos problemas. el detalle de esta parte es abundante . tendrá que alternar entre el texto y los listados de código. tendrá que analizar y entender el código, y comprender el razonamiento de cada cambio realizado. piense en que esta parte le llevará varios días . la tercera parte del libro es un único capítulo que contiene una lista de heurística y síntomas de código erróneo ( smells ) confeccionada al crear los casos prácticos. al analizar y limpiar el código de los ejemplos, documentamos el motivo de todas nuestras acciones como heurística o síntoma. intentamos comprender nuestras reacciones al código que leíamos y modificábamos, y nos esforzamos por capturar las sensaciones que tuvimos y las decisiones que adoptamos. el resultado es una base de conocimientos que describe cómo pensamos cuando creamos, leemos y limpiamos código. esta base de conocimientos no le servirá de mucho si no lee atentamente los casos de la segunda parte del libro. en esos capítulos hemos anotado con precisión todos los cambios realizados con referencias a la heurística. estas referencias se muestran entre corchetes, como [h22]. de este modo puede ver el contexto en el que se ha aplicado y creado dicha heurística. no importa tanto el propio valor de las heurísticas sino la relación entre ellas y las decisiones adoptadas al limpiar el código en los ejemplos . si lee la primera y la tercera parte y se salta los casos prácticos, habrá leído otro libro distinto sobre cómo crear código correcto, pero si dedica tiempo a analizar los casos, sigue todos y cada uno de los pasos, cada una de las decisiones, si se pone en nuestro lugar y se obliga a pensar tal y como lo hicimos nosotros, entonces comprenderá mucho mejor todos los principios, patrones, prácticas y heurística. ya no será un conocimiento superficial. se convertirá en algo profundo. lo integrará de la misma forma que una bicicleta se convierte en una extensión propia una vez dominada la forma de 17montar. 18sobre la imagen de cubierta la imagen de la portada es m104: la galaxia del sombrero. m104 se encuentra en virgo, a unos 30 millones de años luz, y su núcleo es un súper agujero negro que pesa aproximadamente mil millones de masas solares. ¿la imagen le recuerda la explosión de la luna praxis de klingon? recuerdo la escena de star trek vi en la que se mostraba un anillo de restos flotando tras la explosión. tras esa escena, el anillo se ha convertido en un elemento habitual de las explosiones de ciencia ficción. incluso se añadió a la explosión de alderaan en ediciones posteriores de la primera película de la guerra de las galaxias. ¿qué provocó la formación de este anillo alrededor de m104? ¿por qué tiene un centro de tales dimensiones y un núcleo tan brillante y diminuto? parece como si el agujero negro central hubiera provocado un orificio de 30 000 años luz en el centro de la galaxia. la desgracia caería sobre las civilizaciones que se encontraran en el camino de este desastre cósmico. los súper agujeros negros desayunan estrellas y convierten parte de su masa en energía. e=mc 2 puede bastar, pero cuando m es una masa estelar hay que tener cuidado. ¿cuántas estrellas habrá engullido este monstruo antes de saciar su apetito? el tamaño del vacío central podría ser una pista. la imagen de m104 de la portada es una combinación de la famosa fotografía del hubble (imagen superior) y la reciente imagen de infrarrojos del observatorio orbital spitzer (inferior). esta última muestra claramente la forma de anillo de la galaxia. a la luz, sólo vemos el borde frontal de la silueta del anillo. 19imagen de portada: © spitzet space telescope. la masa central oculta el resto. pero en la imagen de infrarrojos, las partículas calientes del anillo brillan a través de la masa central. las dos imágenes combinadas nos ofrecen una vista desconocida hasta ahora e implican que hace tiempo era un auténtico infierno activo. 201 código limpio está leyendo este libro por dos motivos. por un lado, es programador. por otro, quiere ser mejor programador. perfecto. necesitamos mejores 21programadores. este libro trata sobre programación correcta. está repleto de código. lo analizaremos desde todas las direcciones. desde arriba, desde abajo y desde dentro. cuando terminemos, sabremos mucho sobre código y, en especial sabremos distinguir entre código correcto e incorrecto. sabremos cómo escribir código correcto y cómo transformar código incorrecto en código correcto. hágase el código se podría afirmar que un libro sobre código es algo obsoleto, que el código ya no es el problema y que deberíamos centrarnos en modelos y requisitos. hay quienes sugieren que el final del código está próximo. que los programadores ya no serán necesarios porque los empresarios generarán programas a partir de especificaciones. no es cierto. el código nunca desaparecerá, ya que representa los detalles de los requisitos. en algún nivel, dichos detalles no se pueden ignorar ni abstraer; deben especificarse, y para especificar requisitos de forma que un equipo pueda ejecutarlos se necesita la programación. dicha especificación es el código. espero que el nivel de abstracción de nuestros lenguajes siga aumentando. también espero que aumente el número de lenguajes específicos de dominios. será algo positivo, pero no eliminará el código. de hecho, todas las especificaciones creadas en estos lenguajes de nivel superior y específicos de los dominios serán código, y tendrá que ser riguroso, preciso, formal y detallado para que un equipo pueda entenderlo y ejecutarlo. el que piense que el código va a desaparecer es como el matemático que espera que un día las matemáticas no sean formales. esperan descubrir una forma de crear máquinas que hagan lo que queramos en lugar de lo que digamos. esas máquinas tendrían que entendernos de tal forma que puedan traducir necesidades ambiguas en programas perfectamente ejecutados que satisfagan dichas necesidades a la perfección. esto nunca sucederá. ni siquiera los humanos, con toda su intuición y 22creatividad, han sido capaces de crear sistemas satisfactorios a partir de las sensaciones de sus clientes. en realidad, si la disciplina de la especificación de requisitos nos ha enseñado algo es que los requisitos bien especificados son tan formales como el código y que pueden actuar como pruebas ejecutables de dicho código. recuerde que el código es básicamente el lenguaje en el que expresamos los requisitos en última instancia. podemos crear lenguajes que se asemejen a dichos requisitos. podemos crear herramientas que nos permitan analizar y combinar dichos requisitos en estructuras formales, pero nunca eliminaremos la precisión necesaria; por ello, siempre habrá código. código incorrecto recientemente leí el prólogo del libro implementation pattern [1] de kent beck, donde afirmaba que «…este libro se basa en una frágil premisa: que el código correcto es relevante…». ¿una frágil premisa? en absoluto. considero que es una de las más robustas, admitidas e importantes de nuestro sector (y creo que kent lo sabe). sabemos que el código correcto es relevante porque durante mucho tiempo hemos tenido que sufrir su ausencia. sé de una empresa que, a finales de la década de 1980, creó una magnífica aplicación, muy popular y que muchos profesionales compraron y utilizaron. pero los ciclos de publicación empezaron a distanciarse. no se corrigieron los errores entre una versión y la siguiente. crecieron los tiempos de carga y aumentaron los fallos. todavía recuerdo el día en que apagué el producto y nunca más lo volví a usar. poco después, la empresa desapareció. 23dos décadas después conocí a uno de los empleados de la empresa y le pregunté sobre lo que había pasado. la respuesta confirmó mis temores. habían comercializado el producto antes de tiempo con graves fallos en el código. al añadir nuevas funciones, el código empeoró hasta que ya no pudieron controlarlo. el código incorrecto fue el motivo del fin de la empresa . ¿en alguna ocasión el código incorrecto le ha supuesto un obstáculo? si es programador seguramente sí. de hecho, tenemos una palabra que lo describe: sortear . tenemos que sortear el código incorrecto. nos arrastramos por una maraña de zarzas y trampas ocultas. intentamos buscar el camino, una pista de lo que está pasando, pero lo único que vemos es más y más código sin sentido. sin duda el código incorrecto le ha supuesto un obstáculo. entonces, ¿por qué lo escribió? ¿tenía prisa? ¿plazos de entrega? seguramente. puede que pensara que no tenía tiempo para hacer un buen trabajo; que su jefe se enfadaría si necesitaba tiempo para limpiar su código. o puede que estuviera cansado de trabajar en ese programa y quisiera acabar cuanto antes. o que viera el trabajo pendiente y tuviera que acabar con un módulo para pasar al siguiente. a todos nos ha pasado. todos hemos visto el lío en el que estábamos y hemos optado por dejarlo para otro día. todos hemos sentido el alivio de ver cómo un programa incorrecto funcionaba y hemos decidido que un mal programa que funciona es mejor que nada. todos hemos dicho que lo solucionaríamos después. evidentemente, por aquel entonces, no conocíamos la ley de leblanc: después es igual a nunca . el coste total de un desastre si es programador desde hace dos o tres años, probablemente haya sufrido los desastres cometidos por otros en el código. si tiene más experiencia, lo habrá sufrido en mayor medida. el grado de sufrimiento puede ser significativo. en un periodo de un año o dos, los equipos que avancen rápidamente al inicio de 24un proyecto pueden acabar a paso de tortuga. cada cambio en el código afecta a dos o tres partes del mismo. ningún cambio es trivial. para ampliar o modificar el sistema es necesario comprender todos los detalles, efectos y consecuencias, para de ese modo poder añadir nuevos detalles, efectos y consecuencias. con el tiempo, el desastre aumenta de tal modo que no se puede remediar. es imposible. al aumentar este desastre, la productividad del equipo disminuye y acaba por desaparecer. al reducirse la productividad, el director hace lo único que puede: ampliar la plantilla del proyecto con la esperanza de aumentar la productividad. pero esa nueva plantilla no conoce el diseño del sistema. no conocen la diferencia entre un cambio adecuado al objetivo de diseño y otro que lo destroce. por tanto, todos se encuentran sometidos a una gran presión para aumentar la productividad. por ello, cometen más errores, aumenta el desastre y la productividad se acerca a cero cada vez más (véase la figura 1.1). figura 1.1. productividad frente a tiempo. el gran cambio de diseño en última instancia, el equipo se rebela. informan al director que no pueden seguir trabajando con ese código. exigen un cambio de diseño. la dirección no requiere invertir en un cambio de diseño del proyecto, pero no puede ignorar el bajo nivel de productividad. 25acaba por ceder a las exigencias de los programadores y autoriza el gran cambio de diseño. se selecciona un nuevo equipo. todos quieren formar parte del nuevo equipo por ser un lienzo en blanco. pueden empezar de cero y crear algo realmente bello, pero sólo los mejores serán elegidos para el nuevo equipo. los demás deben continuar con el mantenimiento del sistema actual. ahora los dos equipos compiten. el nuevo debe crear un sistema que haga lo que el antiguo no puede. además, deben asumir los cambios que continuamente se aplican al sistema antiguo. la dirección no sustituirá el sistema antiguo hasta que el nuevo sea capaz de hacer todo lo que hace el antiguo. esta competición puede durar mucho tiempo. conozco casos de casi 10 años. y cuando acaba, los miembros originales del equipo nuevo han desaparecido y los miembros actuales exigen un cambio de diseño del nuevo sistema porque es un desastre. si ha experimentado alguna fase de esta historia, ya sabrá que dedicar tiempo a que el código sea correcto no sólo es rentable, es una cuestión de supervivencia profesional. actitud ¿alguna vez ha tenido que superar un desastre tan grave que ha tardado semanas en lo que normalmente hubiera tardado horas? ¿ha visto un cambio que debería haberse realizado en una línea, aplicado en cientos de módulos distintos? son síntomas demasiado habituales. ¿por qué sucede en el código? ¿por qué el código de calidad se transforma tan rápidamente en código incorrecto? hay muchas explicaciones. nos quejamos de que los requisitos cambian de forma que comprometen el diseño original, de que los plazos de entrega son demasiado exigentes para hacer las cosas bien. culpamos a directores incompetentes, a usuarios intolerantes y a comerciales sin sentido. pero la culpa, querido dilbert, es nuestra. no somos profesionales. puede que resulte duro escucharlo. ¿cómo es posible que seamos responsables de tales desastres? ¿qué pasa con los requisitos? ¿y los plazos de entrega? ¿y los directores incompetentes y los comerciales sin sentido? 26¿no es también culpa suya? no. los directores y los comerciales nos exigen la información que necesitan para realizar sus promesas y compromisos, e incluso cuando no recurren a nosotros, no debemos tener miedo a decirles lo que pensamos. los usuarios acuden a nosotros para validar la forma de encajar los requisitos en el sistema. los directores de proyectos acuden a nosotros para determinar los objetivos. somos cómplices en la programación del proyecto y compartimos gran parte de la responsabilidad de los fallos, en especial si tienen que ver con código incorrecto. seguramente piense que, si no hace lo que su jefe le dice, le despedirán. es improbable. muchos jefes sólo quieren la verdad, aunque lo disimulen. muchos quieren código correcto, aunque estén obsesionados con los objetivos. pueden defender apasionadamente los objetivos y los requisitos, pero es su trabajo. el nuestro es defender el código con la misma intensidad. para resumir, imagine que es médico y un paciente le exige que no se lave las manos antes de una operación porque se pierde demasiado tiempo [2] . en este caso, el paciente es el jefe, pero el médico debe negarse a lo que pide. ¿por qué? porque el médico sabe más que el paciente sobre los riesgos de infecciones. no sería profesional (incluso sería ilegal) que el médico cediera a las exigencias del paciente. tampoco sería profesional que los programadores cedieran a la voluntad de los jefes que no entienden los riesgos de un posible desastre. el enigma los programadores se enfrentan a un enigma de valores básicos. los que tienen años de experiencia saben que un desastre ralentiza su trabajo, y aun así todos los programadores sienten la presión de cometer errores para poder cumplir los plazos de entrega. en definitiva, no toman el tiempo necesario para avanzar. los verdaderos profesionales saben que la segunda parte del enigma no es cierta. no se cumple un plazo de entrega cometiendo un error. de hecho, el error nos ralentiza de forma inmediata y hace que no lleguemos al plazo de entrega. la única forma de cumplirlo, la única forma de avanzar, es intentar 27que el código siempre sea limpio. ¿el arte del código limpio? imagine que cree que el código incorrecto es un obstáculo significativo. imagine que acepta que la única forma de avanzar es mantener el código limpio. entonces se preguntará cómo crear código limpio. no tiene sentido intentar crearlo si no sabe lo que es. la mala noticia es que crear código limpio es como pintar un cuadro. muchos sabemos si un cuadro se ha pintado bien o no, pero poder reconocer la calidad de una obra no significa que sepamos pintar. por ello, reconocer código limpio no significa que sepamos cómo crearlo. para crearlo se requiere el uso disciplinado de miles de técnicas aplicadas mediante un detallado sentido de la «corrección». este sentido del código es la clave. algunos nacen con este sentido. otros han de luchar para conseguirlo. no sólo permite distinguir entre código correcto e incorrecto, sino que también muestra la estrategia para aplicar nuestra disciplina y transformar código incorrecto en código correcto. un programador sin este sentido puede reconocer el desastre cometido en un módulo, pero no saber cómo solucionarlo. un programador con este sentido verá las posibles opciones y elegirá la variante óptima para definir una secuencia de cambios. en definitiva, un programador que cree código limpio es un artista que puede transformar un lienzo en blanco en un sistema de código elegante. concepto de código limpio existen tantas definiciones como programadores. por ello, he consultado la opinión de conocidos y experimentados programadores. bjarne stroustrup, inventor de c++ y autor de the c++ programming language 28me gusta que mi código sea elegante y eficaz. la lógica debe ser directa para evitar errores ocultos, las dependencias deben ser mínimas para facilitar el mantenimiento, el procesamiento de errores completo y sujeto a una estrategia articulada, y el rendimiento debe ser óptimo para que los usuarios no tiendan a estropear el código con optimizaciones sin sentido. el código limpio hace bien una cosa. bjarne usa la palabra «elegante». menuda palabra. según el diccionario, «elegante» significa « dotado de gracia, nobleza y sencillez ». aparentemente bjarne piensa que el código limpio es un placer a la hora de leerlo. su lectura debe hacernos sonreír, como una caja de música o un coche bien diseñado. bjarne también menciona la eficacia, en dos ocasiones . no debería sorprendemos viniendo del inventor de c++; pero considero que hay algo más que el mero deseo de velocidad. los ciclos malgastados no son elegantes, no son un placer. y fíjese en la palabra empleada por bjarne para describir la consecuencia de esta falta de elegancia. usa tiendan . una gran verdad. el código incorrecto tiende a aumentar el desastre. cuando otros cambian código incorrecto, tienden a empeorarlo. dave thomas y andy hunt lo expresan de forma diferente. usan la metáfora de las ventanas rotas [3] . un edificio con ventanas rotas parece abandonado. y hace que otros lo abandonen. dejan que se rompan otras ventanas. e incluso las rompen a propósito. la fachada se ensucia con pintadas y se acumula la basura. una ventana rota inicia el proceso de la decadencia. bjarne también menciona que el procesamiento de errores debe ser completo, lo que se relaciona con la disciplina de prestar atención a los detalles. el procesamiento de errores abreviado es una forma de ignorar los detalles. otras son las fugas de memoria, las condiciones de carrera o el uso 29incoherente de los nombres. en definitiva, el código limpio muestra gran atención al detalle. bjarne termina afirmando que el código limpio hace una cosa bien . no es accidental que existan tantos principios de diseño de software que se puedan reducir a esta sencilla máxima. muchos escritores han tratado de comunicar este pensamiento. el código incorrecto intenta hacer demasiadas cosas y su cometido es ambiguo y enrevesado. el código limpio es concreto . cada función, cada clase y cada módulo muestran una única actitud que se mantiene invariable y no se contamina por los detalles circundantes. grady booch, autor de object oriented analysis and design with applications el código limpio es simple y directo. el código limpio se lee como un texto bien escrito. el código limpio no oculta la intención del diseñador, sino que muestra nítidas abstracciones y líneas directas de control. grady mantiene las mismas ideas que bjarne, pero adopta una perspectiva de legibilidad . me gusta especialmente que el código limpio se pueda leer como un texto bien escrito. piense en un buen libro. recordará que las palabras desaparecen y se sustituyen por imágenes, como ver una película. mejor todavía. es ver los caracteres, escuchar los sonidos, experimentar las sensaciones. leer código limpio nunca será como leer el señor de los anillos . pero esta metáfora literaria no es incorrecta. como una buena novela, el código limpio debe mostrar de forma clara el suspense del problema que hay que resolver. debe llevar ese suspense hasta un punto álgido para después demostrar al lector que los problemas y el suspense se han solucionado de forma evidente. 30la frase «nítida abstracción» de grady es un oxímoron fascinante. nítido es casi un sinónimo de concreto, con un potente mensaje. el código debe ser específico y no especulativo. sólo debe incluir lo necesario. nuestros lectores deben percibir que hemos tomado decisiones. «big» dave thomas, fundador de oti, el padrino de la estrategia eclipse el código limpio se puede leer y mejorar por parte de un programador que no sea su autor original. tiene pruebas de unidad y de aceptación. tiene nombres con sentido. ofrece una y no varias formas de hacer algo. sus dependencias son mínimas, se definen de forma explícita y ofrece una api clara y mínima. el código debe ser culto en función del lenguaje, ya que no toda la información necesaria se puede expresar de forma clara en el código. big dave comparte el deseo de grady de la legibilidad, pero con una importante variante. dave afirma que el código limpio facilita las labores de mejora de otros . puede parecer evidente pero no debemos excedernos. después de todo, existe una diferencia entre el código fácil de leer y el código fácil de cambiar. dave vincula la limpieza a las pruebas. hace 10 años esto hubiera provocado cierta controversia. pero la disciplina del desarrollo controlado por pruebas ha tenido un gran impacto en nuestro sector y se ha convertido en uno de sus pilares. dave tiene razón. el código, sin pruebas, no es limpio. independientemente de su elegancia, legibilidad y accesibilidad, si no tiene pruebas, no será limpio. dave usa dos veces la palabra mínimo . valora el código de tamaño 31reducido, una opinión habitual en la literatura de software desde su concepción. cuanto más pequeño, mejor. también afirma que el código debe ser culto , una referencia indirecta a la programación de knuth [4] y que en definitiva indica que el código debe redactarse de una forma legible para los humanos. michael feathers, autor de working effectively with legacy code podría enumerar todas las cualidades del código limpio, pero hay una principal que engloba a todas ellas. el código limpio siempre parece que ha sido escrito por alguien a quien le importa. no hay nada evidente que hacer para mejorarlo. el autor del código pensó en todos los aspectos posibles y si intentamos imaginar alguna mejora, volvemos al punto de partida y sólo nos queda disfrutar del código que alguien a quien le importa realmente nos ha proporcionado. una palabra; dar importancia. es el verdadero tema de este libro, que incluso podría usar el subtítulo « cómo dar importancia al código ». michael ha acertado de pleno. el código limpio es aquél al que se le ha dado importancia. alguien ha dedicado su tiempo para que sea sencillo y ha prestado atención a los detalles. se ha preocupado. ron jeffries, autor de extreme programming installed y extreme programming adventures in c# 32ron comenzó su carrera como programador con fortran en strategic air command y ha escrito código para la práctica totalidad de lenguajes y equipos. merece la pena fijarse en sus palabras: en los últimos años, comencé y prácticamente terminé con las reglas de código simple de beck. en orden de prioridad, el código simple: ejecuta todas las pruebas. no contiene duplicados. expresa todos los conceptos de diseño del sistema. minimiza el número de entidades como clases, métodos, funciones y similares. de todos ellos, me quedo con la duplicación. cuando algo se repite una y otra vez, es una señal de que tenemos una idea que no acabamos de representar correctamente en el código. intento determinar cuál es y, después, expresar esa idea con mayor claridad. para mí, la expresividad debe incluir nombres con sentido y estoy dispuesto a cambiar los nombres de las cosas varias veces. con las modernas herramientas de creación de código como eclipse, el cambio de nombres es muy sencillo, por lo que no me supone problema alguno. la expresividad va más allá de los nombres. también me fijo si un objeto o un método hacen más de una cosa. si se trata de un objeto, probablemente tenga que dividirse en dos o más. si se trata de un método, siempre recurro a la refactorización de extracción de métodos para generar un método que exprese con mayor claridad su cometido y varios métodos secundarios que expliquen cómo lo hace. la duplicación y la expresividad son dos factores que permiten mejorar considerablemente código que no sea limpio. sin embargo, 33existe otra cosa que también hago conscientemente, aunque sea más difícil de explicar. tras años en este trabajo, creo que todos los programas están formados de elementos muy similares. un ejemplo es la búsqueda de elementos en una colección. independientemente de que sea una base de datos de registros de empleados o un mapa de claves y valores, o una matriz de elementos, por lo general tenemos que buscar un elemento concreto de esa colección. cuando esto sucede, suelo incluir esa implementación concreta en un método o una clase más abstractos. de ese modo disfruto de una serie de interesantes ventajas. puedo implementar la funcionalidad con algo sencillo, como un mapa hash, por ejemplo, pero como ahora todas las referencias a la búsqueda se ocultan en mi pequeña abstracción, puedo modificar la implementación siempre que desee. puedo avanzar rápidamente al tiempo que conservo la posibilidad de realizar cambios posteriores. además, la abstracción de la colección suele captar mi atención en lo que realmente sucede e impide que implemente comportamientos de colecciones arbitrarias si lo que realmente necesito es una forma sencilla de localizar un elemento. reducir los duplicados, maximizar la expresividad y diseñar sencillas abstracciones en las fases iniciales. para mí, es lo que hace que el código sea limpio. en estos breves párrafos, ron resume el contenido de este libro. nada de duplicados, un objetivo, expresividad y pequeñas abstracciones. todo está ahí. ward cunningham, inventor de wiki, fit, y uno de los inventores de la programación extreme. uno de los impulsores de los patrones de diseño. una de las mentes tras smalltalk y la programación orientada a objetos. el padrino de todos a los que les importa el código. 34sabemos que estamos trabajando con código limpio cuando cada rutina que leemos resulta ser lo que esperábamos. se puede denominar código atractivo cuando el código hace que parezca que el lenguaje se ha creado para el problema en cuestión. este tipo de afirmaciones son características de ward. las leemos, asentimos y pasamos a la siguiente. es tan razonable y evidente que apenas parece profundo. incluso podemos pensar que es lo que esperábamos. pero preste atención. «… resulta ser lo que esperábamos». ¿cuándo fue la última vez que vio un módulo que fuera más o menos lo que esperaba? ¿lo habitual no es ver módulos complicados y enrevesados? ¿no es esta falta de concreción lo habitual? ¿no está acostumbrado a intentar extraer el razonamiento de un sistema para llegar al módulo que está leyendo? ¿cuándo fue la última vez que leyó un código y asintió como seguramente haya hecho al leer la afirmación de ward? ward espera que al leer código limpio no le sorprenda. de hecho, ni siquiera tendrá que esforzarse. lo leerá y será prácticamente lo que esperaba. será evidente, sencillo y atractivo. cada módulo prepara el camino del siguiente. cada uno indica cómo se escribirá el siguiente. los programas limpios están tan bien escritos que ni siquiera se dará cuenta. el diseñador consigue simplificarlo todo enormemente, como sucede con todos los diseños excepcionales. ¿y la noción de atractivo de ward? todos hemos criticado que nuestros lenguajes no se hayan diseñado para nuestros problemas. pero la afirmación de ward hace que ahora la responsabilidad sea nuestra. afirma que el código atractivo hace que el lenguaje parezca creado para el problema . por tanto, somos responsables de que el lenguaje parezca sencillo. no es el lenguaje el que hace que los programas parezcan sencillos, sino el programador que consigue que el lenguaje lo parezca. 35escuelas de pensamiento ¿y yo (uncle bob)? ¿qué es para mí el código limpio? en este libro le contaremos, con todo detalle, lo que yo y mis colegas pensamos del código limpio. le contaremos lo que pensamos que hace que un nombre de variable, una función o una clase sean limpias. presentaremos estas opiniones de forma absoluta, sin disculparnos. en este punto de nuestra carrera, ya son absolutas. son nuestra escuela de pensamiento del código limpio. los especialistas de las artes marciales no se ponen de acuerdo sobre cuál es la mejor de todas, ni siquiera sobre cuál es la mejor técnica de un arte marcial. es habitual que los maestros de las artes marciales creen sus propias escuelas de pensamiento y los alumnos aprendan de ellos. de esta forma nació gracie jiu jitsu , creada e impartida por la familia gracie en brasil; hakkoryu jiu jitsu , fundada e impartida por okuyama ryuho en tokio o jeet kune do , fundada e impartida por bruce lee en estados unidos. los alumnos de estas disciplinas se sumergen en las enseñanzas del fundador. se dedican a aprender lo que su maestro les enseña y suelen excluir las enseñanzas de otros maestros. después, cuando han mejorado su arte, pueden convertirse en alumnos de otro maestro diferente para ampliar sus conocimientos y su experiencia. algunos seguirán mejorando sus habilidades, descubriendo nuevas técnicas y fundando sus propias escuelas. ninguna de estas escuelas tiene la razón absoluta pero dentro de cada una actuamos como si las enseñanzas y las técnicas fueran correctas. después de todo, existe una forma correcta de practicar hakkoryu jiu jitsu o jeet kune do, pero esta corrección dentro de una escuela determinada no anula las enseñanzas de otra diferente. 36imagine que este libro es una descripción de la escuela de mentores del código limpio . las técnicas y enseñanzas impartidas son la forma en la que practicamos nuestro arte. podemos afirmar que, si sigue nuestras enseñanzas, disfrutará de lo que hemos disfrutado nosotros, y aprenderá a crear código limpio y profesional. pero no cometa el error de pensar que somos los únicos que tenemos razón. existen otras escuelas y otros maestros tan profesionales como nosotros, y su labor es aprender de ellos también. de hecho, muchas de las recomendaciones del libro son controvertidas, seguramente no esté de acuerdo con muchas de ellas y puede que rechace algunas de forma definitiva. es correcto. no somos la autoridad final. pero, por otra parte, las recomendaciones del libro son algo en lo que hemos pensado mucho. las hemos aprendido tras décadas de experiencia y ensayo y error. por lo tanto, esté o no de acuerdo, sería una lástima que no apreciara, y respetara, nuestro punto de vista. somos autores el campo @author de un javadoc indica quiénes somos. somos autores. y los autores tienen lectores. de hecho, los autores son responsables de comunicarse correctamente con sus lectores. la próxima vez que escriba una línea de código, recuerde que es un autor y que escribe para que sus lectores juzguen su esfuerzo. seguramente se pregunte qué cantidad de código se lee realmente y si la mayor parte del esfuerzo no se concentra en crearlo. ¿alguna vez ha reproducido una sesión de edición? en las décadas de 1980 y 1990 teníamos editores como emacs que controlaban cada pulsación de tecla. se podía trabajar durante una hora y después reproducir la sesión de edición completa como una película a alta velocidad. cuando lo hice, los resultados fueron fascinantes. la mayor parte de la reproducción eran desplazamientos entre módulos. bob accede al módulo. se desplaza hasta la función que tiene que cambiar. 37se detiene y piensa en las posibles opciones. oh, vuelve al inicio del módulo para comprobar la inicialización de una variable. ahora vuelve a bajar y comienza a escribir. vaya, borra lo que había escrito. vuelve a escribirlo. lo vuelve a borrar. escribe algo diferente pero también lo borra. se desplaza a otra función que invoca la función que está modificando para comprobar cómo se invoca. vuelve a subir y escribe el mismo código que acaba de borrar. se detiene. vuelve a borrar el código. abre otra ventana y examina las subclases. ¿se ha reemplazado esa función? … se hace una idea. en realidad, la proporción entre tiempo dedicado a leer frente a tiempo dedicado a escribir es de más de 10:1. constantemente tenemos que leer código antiguo como parte del esfuerzo de crear código nuevo. al ser una proporción tan elevada, queremos que la lectura del código sea sencilla, aunque eso complique su creación. evidentemente, no se puede escribir código sin leerlo, de modo que si es más fácil de leer será más fácil de escribir . es una lógica sin escapatoria. no se puede escribir código si no se puede leer el código circundante. el código que intente escribir hoy será fácil o difícil de escribir en función de lo fácil o difícil de leer que sea el código circundante. si quiere avanzar rápidamente, terminar cuanto antes y que su código sea fácil de escribir, haga que sea fácil de leer. la regla del boy scout 38no basta con escribir código correctamente. el código debe limpiarse con el tiempo. todos hemos visto que el código se corrompe con el tiempo, de modo que debemos adoptar un papel activo para evitarlo. los boy scouts norteamericanos tienen una sencilla regla que podemos aplicar a nuestra profesión: dejar el campamento más limpio de lo que se ha encontrado [5] . si todos entregamos el código más limpio de lo que lo hemos recibido, no se corromperá. no hace falta que la limpieza sea masiva. cambie el nombre de una variable, divida una función demasiado extensa, elimine elementos duplicados, simplifique una instrucción if compuesta. ¿se imagina trabajar en un proyecto en el que el código mejorara con el tiempo? ¿cree que hay otras opciones que puedan considerarse profesionales? de hecho, ¿la mejora continuada no es una parte intrínseca de la profesionalidad? precuela y principios en muchos aspectos, este libro es una «precuela» de otro que escribí en 2002 titulado agile software development: principles, patterns, and practices (ppp). el libro ppp trata sobre los principios del diseño orientado a objetos y muchas de las técnicas empleadas por desarrolladores profesionales. si no ha leído ppp, comprobará que continúa la historia contada en este libro. si lo ha leído, encontrará muchas de las sensaciones de ese libro reproducidas en éste a nivel del código. en este libro encontrará referencias esporádicas a distintos principios de diseño como srp ( single responsibility principle o principio de responsabilidad única), ocp ( open closed principle o principio abierto/cerrado) y dip ( dependency inversion principle o principio de inversión de dependencias) entre otros. todos estos principios se describen detalladamente en ppp. 39conclusión los libros sobre arte no le prometen que se convertirá en artista. solamente pueden mostrarle herramientas, técnicas y procesos de pensamiento que otros artistas hayan utilizado. del mismo modo, este libro no puede prometer que se convierta en un buen programador, que tenga sentido del código. sólo puede mostrarle los procesos de pensamiento de buenos programadores y los trucos, técnicas y herramientas que emplean. al igual que un libro sobre arte, este libro está repleto de detalles. encontrará mucho código. verá código correcto y código incorrecto. verá código incorrecto transformado en código correcto. verá listas de heurística, disciplinas y técnicas. verá un ejemplo tras otro. y después de todo, será responsabilidad suya. ¿recuerda el chiste sobre el violinista que se pierde camino de un concierto? se cruza con un anciano y le pregunta cómo llegar al teatro real. el anciano mira al violinista y al violín que lleva bajo el brazo y le responde: «practique joven, practique». bibliografía [beck07] : implementation patterns , kent beck, addison-wesley, 2007. [knuth92] : literate programming , donald e. knuth, center for the study of language and information, leland stanford junior university, 1992. 402 nombres con sentido por tim ottinger introducción en el software , los nombres son omnipresentes. aparecen en variables, 41funciones, argumentos, clases y paquetes. asignamos nombres a archivos y a directorios, a archivos jar, war y ear. usamos nombres constantemente. por ello, debemos hacerlo bien. a continuación, veremos algunas reglas básicas para crear nombres correctos. usar nombres que revelen las intenciones es fácil afirmar que los nombres deben revelar nuestras intenciones. lo que queremos recalcar es la importancia de hacerlo. elegir nombres correctos lleva tiempo, pero también ahorra trabajo. por ello, preste atención a los nombres y cámbielos cuando encuentre otros mejores. todo el que lea su código se lo agradecerá. el nombre de una variable, función o clase debe responder una serie de cuestiones básicas. debe indicar por qué existe, qué hace y cómo se usa. si un nombre requiere un comentario, significa que no revela su cometido. int d; // tiempo transcurrido en días el nombre d no revela nada. no evoca una sensación de tiempo transcurrido, ni de días. debe elegir un nombre que especifique lo que se mide y la unidad de dicha medida: int elapsedtimeindays; int dayssincecreation; int dayssincemodification; int fileageindays; la elección de nombres que revelen intenciones facilita considerablemente la comprensión y la modificación del código. ¿para qué sirve el siguiente código? public list<int[]> getthem() { list<int[]> list1 = new arraylist<int[]>(); for (int[] x : thelist) if (x[0] == 4) list1.add(x); return list1; } ¿por qué es complicado saber la función de este código? no hay expresiones complejas. los espacios y el sangrado son razonables. sólo hay tres variables y dos constantes. ni siquiera contiene clases complejas o 42métodos polimórficos, sólo una lista de matrices (o eso parece). el problema no es la simplicidad del código sino su carácter implícito : el grado en el que el contexto no es explícito en el propio código. implícitamente, el código requiere que sepamos las respuestas a las siguientes preguntas: ¿qué contiene thelist ? ¿qué significado tiene el subíndice cero de un elemento de thelist ? ¿qué importancia tiene el valor 4 ? ¿cómo se usa la lista devuelta? las respuestas a estas preguntas no se encuentran en el código, pero se podrían haber incluido. imagine que trabaja en un juego de buscar minas. el tablero es una lista de celdas llamada thelist . cambiemos el nombre por gameboard . cada celda del teclado se representa por medio de una matriz. el subíndice cero es la ubicación de un valor de estado que, cuando es 4 , significa que se ha detectado. al asignar nombres a estos conceptos mejoramos considerablemente el código: public list<int[]> getflaggedcells() { list<int[]> flaggedcells = new arraylist<int[]>(); for (int[] cell : gameboard) if (cell[status_value] == flagged) flaggedcells.add(cell); return flaggedcells; } la simplicidad del código no ha cambiado. sigue teniendo los mismos operadores y constantes y el mismo número de niveles anidados, pero ahora es mucho más explícito. podemos crear una sencilla clase para celdas en lugar de usar una matriz de elementos int . puede incluir una función que revele el objetivo (con el nombre isflagged ) para ocultar los números. el resultado es una nueva versión de la función: public list<cell> getflaggedcells() { list<cell> flaggedcells = new arraylist<cell>(); for (cell cell : gameboard) if (cell.isflagged()) flaggedcells.add(cell); 43return flaggedcells; } con estos sencillos cambios de nombre, es fácil saber qué sucede. es la ventaja de seleccionar nombres adecuados. evitar la desinformación los programadores deben evitar dejar pistas falsas que dificulten el significado del código. debemos evitar palabras cuyo significado se aleje del que pretendemos. por ejemplo, hp , aix y sco son nombres de variables pobres ya que son los nombres de plataformas o variantes de unix. aunque se trate del código de una hipotenusa y hp parezca la abreviatura correcta, puede no serlo. no haga referencia a un grupo de cuentas como accountlist a menos que realmente sea una lista ( list ). la palabra lista tiene un significado concreto para los programadores. si el contenedor de las cuentas no es realmente una lista, puede provocar falsas conclusiones [6] . por tanto, resulta más adecuado usar accountgroup , bunchofaccounts o simplemente accounts . evite usar nombres con variaciones mínimas. ¿cuánto se tarda en apreciar la sutil diferencia entre xyzcontrollerforefficienthandlingofstrings y xyzcontrollerforefficientstorageofstrings en un módulo? ambas palabras tienen una forma similar. la ortografía similar de conceptos parecidos es información; el uso de ortografía incoherente es desinformación. en los entornos modernos de java, el código se completa de forma automática. escribimos varios caracteres de un nombre y pulsamos varias teclas para obtener una lista de posibles opciones de un nombre. es muy útil si los nombres de elementos similares se ordenan alfabéticamente de forma conjunta y si las diferencias son muy evidentes, ya que es probable que el programador elija un objeto por nombre sin fijarse en los comentarios o la lista de métodos proporcionados por una clase. 44un ejemplo de nombre desinformativo sería el uso de la l minúscula o la o mayúscula como nombres de variables, sobre todo combinados. el problema, evidentemente, es que se parecen a las constantes 1 y 0 respectivamente: int a = l; if ( o == l ) a = o1; else l = 01; el lector puede pensar que es una invención, pero hemos visto código con abundancia de estos elementos. en un caso, el autor del código, sugirió usar una fuente distinta para que las diferencias fueran más evidentes, una solución que se hubiera transmitido a todos los futuros programadores como tradición oral o en un documento escrito. el problema se resolvió con carácter definitivo y sin necesidad de crear nuevos productos, con tan sólo cambiar los nombres. realizar distinciones con sentido los programadores se crean un problema al crear código únicamente dirigido a un compilador o intérprete. por ejemplo, como se puede usar el mismo nombre para hacer referencia a dos elementos distintos en el mismo ámbito, puede verse tentado a cambiar un nombre de forma arbitraria. en ocasiones se hace escribiéndolo incorrectamente, lo que provoca que los errores ortográficos impidan la compilación [7] . no basta con añadir series de números o palabras adicionales, aunque eso satisfaga al compilador. si los nombres tienen que ser distintos, también deben tener un significado diferente. los nombres de series numéricas ( a1 , a2 … an ) son lo contrario a los nombres intencionados. no desinforman, simplemente no ofrecen información; son una pista sobre la intención del autor. fíjese en lo siguiente: 45public static void copychars(char a1[], char a2[]) { for (int i = 0; i < a1.length; i++) { a2[i] = a1[i]; } } esta función se lee mejor cuando se usa source y destination como nombres de argumentos. las palabras adicionales son otra distinción sin sentido. imagine que tiene la clase product. si tiene otra clase con el nombre productinfo o productdata , habrá creado nombres distintos, pero con el mismo significado. info y data son palabras adicionales, como a , an y the . no es incorrecto usar prefijos como a y the mientras la distinción tenga sentido. imagine que usa a para variables locales y for para argumentos de funciones [8] . el problema aparece cuando decide invocar la variable thezork porque ya tiene otra variable con el nombre zork . las palabras adicionales son redundantes. la palabra variable no debe incluirse nunca en el nombre de una variable. la palabra table no debe incluirse nunca en el nombre de una tabla. ¿es mejor namestring que name ? ¿podría ser name un número de coma flotante? en caso afirmativo, incumple la regla anterior sobre desinformación. imagine que encuentra una clase con el nombre customer y otra con el nombre customerobject . ¿cuál sería la distinción? ¿cuál representa mejor el historial de pagos de un cliente? existe una aplicación que lo ilustra. hemos cambiado los nombres para proteger al culpable. veamos el error exacto: getactiveaccount(); getactiveaccounts(); getactiveaccountinfo(); ¿cómo saben los programadores de este proyecto qué función deben invocar? en ausencia de convenciones concretas, la variable moneyamount no se distingue de money , customerinfo no se distingue de customer , accountdata no se distingue de account y themessage no se distingue de message . debe diferenciar los nombres de forma que el lector aprecie las diferencias. 46usar nombres que se puedan pronunciar a los humanos se nos dan bien las palabras. gran parte de nuestro cerebro se dedica al concepto de palabras. y, por definición, las palabras son pronunciables. sería una pena malgastar esa parte de nuestro cerebro dedicada al lenguaje hablado. por tanto, cree nombres pronunciables. si no lo puede pronunciar, no podrá explicarlo sin parecer tonto. es un factor importante, ya que la programación es una actividad social. conozco una empresa que usa genymdhms (fecha de generación, año, mes, día, hora, minuto y segundo) y lo pronuncian tal cual. yo tengo la costumbre de pronunciar todo tal y como lo veo escrito, de forma que muchos analistas y diseñadores acabaron por llamarme algo como «genimedemes». era un chiste y nos parecía divertido, pero en realidad estábamos tolerando el uso de nombres pobres. teníamos que explicar las variables a los nuevos programadores y cuando las pronunciaban, usaban palabras inventadas en lugar de nombres correctos. compare: class dtarcrd102 { private date genymdhms; private date modymdhms; private final string pszqint = “102”; /*… */ }; con: class customer { private date generationtimestamp; private date modificationtimestamp; private final string recordid = “102”; /*… */ }; ahora se puede mantener una conversación inteligente: «eh, mikey, fíjate en este registro. la marca de tiempo de generación es para mañana. ¿cómo es posible?» usar nombres que se puedan buscar 47los nombres de una letra y las constantes numéricas tienen un problema: no son fáciles de localizar en el texto. se puede detectar max_classes_per_student , pero el número 7 resulta más complicado. las búsquedas pueden devolver el dígito como parte de nombres de archivo, otras definiciones de constantes o expresiones en las que se use con otra intención. mucho peor si la constante es un número extenso y alguien ha intercambiado los dígitos, lo que genera un error inmediato y no aparece en la búsqueda. del mismo modo, el nombre e es una opción muy pobre para variables que el programador tenga que buscar. es la letra más usada en inglés y aparece en la práctica totalidad de los textos de un programa. a este respecto, los nombres extensos superan a los breves y cualquier nombre que se pueda buscar supera a una constante en el código. personalmente prefiero nombres de una letra que sólo se puedan usar como variables locales dentro de métodos breves. la longitud de un nombre debe corresponderse al tamaño de su ámbito [n5]. si una variable o constante se usa en varios puntos del código, debe asignarle un nombre que se pueda buscar. compare: for (int j=0; j<34; j++) { s += (t[j]*4)/5; } con: int realdaysperidealday = 4; const int work_days_per_week = 5; int sum = 0; for (int j = 0; j < number_of_tasks; j++) { int realtaskdays = taskestimate[j] * realdaysperidealday; int realtaskweeks = (realdays / work_days_per_week); sum += realtaskweeks; } en este ejemplo, sum no es un nombre especialmente útil, pero al menos se puede buscar. se usa una función más extensa, pero comprobará que resulta mucho más fácil buscar work_days_per_week que todas las instancias de 5 y filtrar la lista a los casos con el significado adecuado. evitar codificaciones 48ya tenemos suficientes codificaciones como para tener que añadir otras nuevas. al codificar información de tipos o ámbitos en un nombre se dificulta la descodificación. no parece razonable que todos los nuevos empleados tengan que aprender otro lenguaje de codificación además del código con el que van a trabajar. es una carga mental innecesaria a la hora de intentar solucionar un problema. los nombres codificados resultan impronunciables y suelen escribirse de forma incorrecta. notación húngara antiguamente, cuando trabajábamos con lenguajes en los que la longitud de los nombres era un reto, incumplíamos esta regla a nuestro pesar. fortran forzaba las codificaciones convirtiendo la primera letra de un tipo en código. en sus primeras versiones, basic sólo se permitía una letra y un dígito. la notación húngara (hn) lo llevó a un nuevo nivel. hn se consideraba muy importante en el api c de windows, donde todo era un control entero, un puntero long , un puntero void o una de varias implementaciones de string (con diferentes usos y atributos). por aquel entonces, el compilador no comprobaba los tipos, de modo que los programadores tenían que recordarlos. en los lenguajes modernos disponemos de sistemas de tipos más completos y los compiladores recuerdan los tipos y los aplican. es más, existe una tendencia a usar clases y funciones más breves para que los usuarios aprecien la declaración de las variables que usan. los programadores de java no tienen que codificar tipos. los objetos son de tipos fuertes y los entornos de edición han avanzado tanto que detectan un error de tipo antes de ejecutar la compilación. por ello, en la actualidad hn y otras formas de codificación de tipos no son más que un impedimento. hacen que sea más complicado cambiar el nombre o el tipo de una variable o clase. dificultan la legibilidad del código y pueden hacer que el sistema de codificación confunda al lector: phonenumber phonestring; // el nombre no cambia cuando cambia el tipo 49prefijos de miembros tampoco es necesario añadir m_ como prefijo a los nombres de variables. las clases y funciones tienen el tamaño necesario para no tener que hacerlo, y debe usar un entorno de edición que resalte o coloree los miembros para distinguirlos. public class part { private string m_dsc; // la descripción textual void setname(string name) { m_dsc = name; } } public class part { string description; void setdescription(string description) { this.description = description; } } además, los usuarios aprenden rápidamente a ignorar el prefijo (o sufijo) y fijarse en la parte con sentido del nombre. cuanto más código leemos, menos nos fijamos en los prefijos. en última instancia, los prefijos son un indicio de código antiguo. interfaces e implementaciones existe un caso especial para usar codificaciones. imagine por ejemplo que crea una factoría abstracta para crear formas. esta factoría será una interfaz y se implementará por medio de una clase concreta. ¿qué nombres debe asignar? ¿ ishapefactory y shapefactory ? prefiero las interfaces sin adornos. la i inicial, tan habitual en los archivos de legado actuales es, en el mejor de los casos, una distracción, y en el peor, un exceso de información. no quiero que mis usuarios sepan que se trata de una interfaz, solamente que se trata de shapefactory . si tengo que codificar la interfaz o la implementación, opto por ésta última. es mejor usar shapefactoryimp o incluso cshapefactory , que codificar la interfaz. 50evitar asignaciones mentales los lectores no tienen que traducir mentalmente sus nombres en otros que ya conocen. este problema suele aparecer al elegir entre no usar términos de dominio de problemas o de soluciones. es un problema de los nombres de variables de una sola letra. un contador de bucles se podría bautizar como i , j o k (pero nunca l ) si su ámbito es muy reducido y no hay conflictos con otros nombres, ya que los nombres de una letra son tradicionales en contadores de bucles. sin embargo, en otros contextos, un nombre de una letra es una opción muy pobre: es como un marcador de posición que el lector debe asignar mentalmente a un concepto real. no hay peor motivo para usar el nombre c que a y b ya estén seleccionados. por lo general, los programadores son gente inteligente. a la gente inteligente le gusta presumir de sus habilidades mentales. si puede recordar que r es la versión en minúscula de una url sin el host y el sistema, debe ser muy listo. una diferencia entre un programador inteligente y un programador profesional es que este último sabe que la claridad es lo que importa . los profesionales usan sus poderes para hacer el bien y crean código que otros puedan entender. nombres de clases las clases y los objetos deben tener nombres o frases de nombre como customer , wikipage , account y addressparser . evite palabras como manager , processor , data , o info en el nombre de una clase. el nombre de una clase no debe ser un verbo. nombres de métodos 51los métodos deben tener nombres de verbo como postpayment , deletepage o save . los métodos de acceso, de modificación y los predicados deben tener como nombre su valor y usar como prefijo get , set e is de acuerdo al estándar de javabean [9] . string name = employee.getname(); customer.setname(“mike”); if (paycheck.isposted())… al sobrecargar constructores, use métodos de factoría estáticos con nombres que describan los argumentos. por ejemplo: complex fulcrumpoint = complex.fromrealnumber(23.0); es mejor que: complex fulcrumpoint = new complex(23.0); refuerce su uso convirtiendo en privados sus constructores correspondientes. no se exceda con el atractivo si los nombres son demasiado inteligentes, sólo los recordarán los que compartan el sentido del humor de su autor, y sólo mientras se acuerden del chiste. ¿sabrán qué significa la función holyhandgrenade ? sin duda es atractiva, pero en este caso puede que deleteitems fuera más indicado. opte por la claridad antes que por el entretenimiento. en el código, el atractivo suele aparecer como formas coloquiales o jergas. por ejemplo, no use whack() en lugar de kill() . no recurra a bromas culturales como eatmyshorts() si quiere decir abort() . diga lo que piense. piense lo que diga. una palabra por concepto elija una palabra por cada concepto abstracto y manténgala. por ejemplo, 52resulta confuso usar fetch , retrieve y get como métodos equivalentes de clases distintas. ¿cómo va a recordar qué método se corresponde a cada clase? desafortunadamente, tendrá que recordar qué empresa, grupo o individuo ha creado la biblioteca o clase en cuestión para recordar qué término se ha empleado. en caso contrario, perderá mucho tiempo buscando en encabezados y fragmentos de código. los entornos de edición modernos como eclipse e intellij ofrecen pistas sensibles al contexto, como la lista de métodos que puede invocar en un determinado objeto. pero esta lista no suele incluir los comentarios de nombres de funciones y listas de parámetros. tendrá suerte si muestra los nombres de parámetros de las declaraciones de funciones. los nombres de funciones deben ser independientes y coherentes para que pueda elegir el método correcto sin necesidad de búsquedas adicionales. del mismo modo, resulta confuso tener un controlador, un administrador y un control en la misma base de código. ¿cuál es la diferencia entre devicemanager y protocolcontroller ? ¿por qué no son los dos controladores o administradores? ¿son controladores? el nombre hace que espere que dos objetos tengan un tipo diferente y clases diferentes. un léxico coherente es una gran ventaja para los programadores que tengan que usar su código. no haga juegos de palabras evite usar la misma palabra con dos fines distintos. suele hacerse en juegos de palabras. si aplica la regla de una palabra por conceptos, acabará con muchas clases que por ejemplo tengan un método add . mientras las listas de parámetros y los valores devueltos de los distintos métodos add sean semánticamente equivalentes, no hay problema. sin embargo, alguien puede decidir usar la palabra add por motivos de coherencia, aunque no sea en el mismo sentido. imagine que hay varias clases en las que add crea un nuevo valor sumando o concatenando dos valores existentes. imagine ahora que crea una nueva clase con un método 53que añada su parámetro a una colección. ¿este método debe tener el método add ? parece coherente ya que hay otros muchos métodos add , pero en este caso hay una diferencia semántica, de modo que debemos usar un nombre como insert o append . llamar add al nuevo método sería un juego de palabras. nuestro objetivo, como autores, es facilitar la comprensión del código. queremos que el código sea algo rápido, no un estudio exhaustivo. queremos usar un modelo en el que el autor sea el responsable de transmitir el significado, no un modelo académico que exija investigar el significado mostrado. usar nombres de dominios de soluciones recuerde que los lectores de su código serán programadores. por ello, use términos informáticos, algoritmos, nombres de patrones, términos matemáticos y demás. no conviene extraer todos los nombres del dominio de problemas ya que no queremos que nuestros colegas tengan que preguntar el significado de cada nombre en especial cuando ya conocen el concepto bajo otro nombre diferente. el nombre accountvisitor tiene mucho significado para un programador familiarizado con el patrón visitor . ¿qué programador no sabe lo que es jobqueue ? hay cientos de cosas técnicas que los programadores tienen que hacer y elegir nombres técnicos para dichas cosas suele ser lo más adecuado. usar nombres de dominios de problemas cuando no exista un término de programación para lo que esté haciendo, use el nombre del dominio de problemas. al menos el programador que mantenga su código podrá preguntar el significado a un experto en dominios. separar los conceptos de dominio de soluciones y de problemas es parte del trabajo de un buen programador y diseñador. el código que tenga más relación con los conceptos del dominio de problemas tendrá nombres 54extraídos de dicho dominio. añadir contexto con sentido algunos nombres tienen significado por sí mismos, pero la mayoría no. por ello, debe incluirlos en un contexto, en clases, funciones y espacios de nombres con nombres adecuados. cuando todo lo demás falle, pueden usarse prefijos como último recurso. imagine que tiene las variables firstname , lastname , street , housenumber , city , state y z ipcode . si las combina, es evidente que forman una dirección. pero si la variable state se usa de forma aislada en un método, ¿sabría que forma parte de una dirección? puede añadir contexto por medio de prefijos: addrfirstname , addrlastname , addrstate , etc. al menos los lectores comprenderán que estas variables forman parte de una estructura mayor. evidentemente, es mejor crear la clase address . de ese modo, incluso el compilador sabrá que las variables pertenecen a un concepto más amplio. fíjese en el método del listado 2-1. ¿las variables necesitan un contexto con más sentido? el nombre de la función sólo ofrece parte del contexto, el resto se obtiene del algoritmo. tras leer la función, verá que las tres variables number , verb y pluralmodifier forman parte del mensaje guess statistics . desafortunadamente, es necesario inferir el contexto. al leer el método, el significado de las variables no es evidente. listado 2-1 variables en un contexto ambiguo. private void printguessstatistics(char candidate, int count) { string number; string verb; string pluralmodifier; if (count == 0) { number = “no”; verb = “are”; pluralmodifier = “s”; } else if (count == 1) { number = “1”; 55verb = “is”; pluralmodifier = “”; } else { number = integer.tostring(count); verb = “are”; pluralmodifier = “s”; } string guessmessage = string.format( “there %s %s %s%s”, verb, number, candidate, pluralmodifier ); print(guessmessage); } la función es demasiado extensa y las variables aparecen por todas partes. para dividir la función en fragmentos más reducidos necesitamos crear una clase guessstatisticsmessage y convertir a las tres variables en campos de la misma. de este modo contamos con un contexto más obvio para las tres variables. forman parte sin duda de guessstatisticsmessage . la mejora del contexto también permite que el algoritmo sea más limpio y se divida en funciones más reducidas (véase el listado 2-2). listado 2-2 variables con un contexto. public class guessstatisticsmessage ( private string number; private string verb; private string pluralmodifier; public string make(char candidate, int count) { createpluraldependentmessageparts(count); return string.format( “there %s %s %s%s, verb, number, candidate, pluralmodifier); } private void createpluraldependentmessageparts(int count) { if (count == 0) { therearenoletters(); } else if (cout == 1) { thereisoneletter(); } else { therearemanyletters(count); } } private void therearemanyletters(int count) { number = “1”; 56verb = “is”; pluralmodifier = “”; } private void thereisoneletter() { number = “1”; verb = “is”; pluralmodifier = “”; } private void therearenoletters() { number = “no”; verb = “are”; pluralmodifier = “s”; } } no añadir contextos innecesarios en la aplicación imaginaria gas station deluxe, no es aconsejable usar el prefijo gsd en todas las clases. es trabajar contra las herramientas proporcionadas. introduzca g y pulse la tecla de finalización para acceder a una lista interminable de todas las clases del sistema. ¿es lo correcto? ¿por qué dificultar la ayuda del ide? del mismo modo, imagine que ha creado la clase mailingaddress en un módulo de contabilidad de gsd , con el nombre gsdaccountaddress . después, necesita una dirección de correo para la aplicación de contacto con el cliente. ¿usará gsdaccountaddress ? ¿le parece el nombre correcto? 10 de los 17 caracteres son redundantes o irrelevantes. los nombres breves suelen ser más adecuados que los extensos, siempre que sean claros. no añada más contexto del necesario a un nombre. los nombres accountaddress y customeraddress son perfectos para instancias de la clase address pero no sirven como nombres de clase. address sirve como nombre de clase. para distinguir entre direcciones mac, direcciones de puertos y direcciones web, podría usar postaladdress , mac y uri . los nombres resultantes son más precisos, el objetivo de cualquier nombre. 57conclusión lo más complicado a la hora de elegir un buen nombre es que requiere habilidad descriptiva y acervo cultural. es un problema de formación más que técnico, empresarial o administrativo. como resultado, mucha gente del sector no aprende a hacerlo bien. la gente teme que al cambiar los nombres otros programadores se quejen. nosotros no compartimos ese temor y agradecemos los cambios de nombre (siempre que sean a mejor). en muchos casos no memorizamos los nombres de clases y métodos. usamos herramientas modernas para estos detalles y así poder centrarnos en si el código se lee como frases o párrafos, o al menos como tablas y estructuras de datos (una frase no siempre es la mejor forma de mostrar datos). seguramente acabará sorprendiendo a alguien cuando cambie los nombres, como puede suceder con cualquier otra mejora del código. no deje que le detenga. aplique estas reglas y compruebe si mejora o no la legibilidad de su código. si es el encargado de mantener código de terceros, use herramientas para solucionar estos problemas. obtendrá recompensas a corto y largo plazo. 583 funciones 59en los inicios de la programación, creábamos sistemas a partir de rutinas y subrutinas. después, en la época de fortran y pl/1, creábamos nuestros sistemas con programas, subprogramas y funciones. en la actualidad, sólo las funciones han sobrevivido. son la primera línea organizativa en cualquier programa. en este capítulo veremos cómo crearlas. fíjese en el código del listado 3-1. es complicado encontrar una función extensa en fitnesse [10] , pero acabé encontrando ésta. no sólo es extensa, sino que también contiene código duplicado, muchas cadenas y tipos de datos extraños, además de api poco habituales y nada evidentes. intente 60comprenderlo en los próximos tres minutos. listado 3-1 htmlutil.java (fitnesse 20070619). public static string testablehtml { pagedata pagedata, boolean includesuitesetup } throws exception { wikipage wikipage = pagedata.getwikipage(); stringbuffer buffer = new stringbuffer(); if (pagedata.hasattribute(“test”)) { if (includesuitesetup) { wikipage suitesetup = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_setup_name, wikipage ); if (suitesetup != null) { wikipagepath pagepath = suitesetup.getpagecrawler().getfullpath (suitesetup); string pagepathname = pathparser.render(pagepath); buffer.append(“!include -setup .”) .append(pagepathname) .append(“\n”); } } wikipage setup = pagecrawlerimpl.getinheritedpage(“setup”, wikipage); if (setup != null) { wikipagepath setuppath = wikipage.getpagecrawler().getfullpath(setup); string setuppathname = pathparser.render(setuppath); buffer.append(“!include -setup .”) .append(setuppathname) .append(“\n”); } } buffer.append(pagedata.getcontent()); if (pagedata.hasattribute(“test”)) { wikipage teardown = pagecrawlerimpl.getinheritedpage(“teardown”, wikipage); if (teardown != null) { wikipagepath teardownpath = wikipage.getpagecrawler().getfullpath(teardown); string teardownpathname = pathparser.render(teardownpath); buffer.append(“\n”) .append(“!include -teardown .”) .append(teardownpathname) .append(“\n”); } if (includesuitesetup) { 61wikipage suiteteardown = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_teardown_name, wikipage ); if (suiteteardown != null) { wikipagepath pagepath = suiteteardown.getpagecrawler().getfullpath (suiteteardown); string pagepathname = pathparser.render(pagepath); buffer.append(“!include -teardown .”) .append(pagepathname) .append(“\n”); } } } pagedata.setcontent(buffer.tostring()); return pagedata.gethtml(); } ¿tras tres minutos entiende la función? seguramente no. pasan demasiadas cosas y hay demasiados niveles de abstracción diferentes. hay cadenas extrañas e invocaciones de funciones mezcladas en instrucciones if doblemente anidadas controladas por indicadores. sin embargo, con sencillas extracciones de código, algún cambio de nombres y cierta reestructuración, pude capturar la intención de la función en las nueve líneas del listado 3-2. compruebe si ahora la entiende. listado 3-2 htmlutil.java (refactorización). public static string renderpagewithsetupsandteardowns( pagedata pagedata, boolean issuite ) throws exception { boolean istestpage = pagedata.hasattribute(“test”); if (istestpage) { wikipage testpage = pagedata.getwikipage(); stringbuffer newpagecontent = new stringbuffer(); includesetuppages (testpage, newpagecontent, issuite); newpagecontent.append(pagedata.getcontent()); includeteardownpages(testpage, newpagecontent, issuite); pagedata.setcontent(newpagecontent.tostring()); } return pagedata.gethtml(); } a menos que sea un alumno de fitnesse, seguramente no entienda los 62detalles. entenderá que la función se encarga de añadir páginas de configuración y detalles en una página de prueba, que después muestra en html. si está familiarizado con junit [11] , verá que esta función pertenece a algún tipo de estructura de pruebas basada en la web y, evidentemente, es correcto. resulta sencillo adivinar esta información del listado 3-2 pero no del listado 3-1. ¿qué tiene la función del listado 3-2 para que resulte sencilla de leer y entender? ¿qué hay que hacer para que una función transmita su intención? ¿qué atributos podemos asignar a nuestras funciones para que el lector pueda intuir el tipo de programa al que pertenecen? tamaño reducido la primera regla de las funciones es que deben ser de tamaño reducido. la segunda es que deben ser todavía más reducidas . no es una afirmación que pueda justificar. no puedo mostrar referencias a estudios que demuestren que las funciones muy reducidas sean mejores. lo que sí puedo afirmar es que durante casi cuatro décadas he creado funciones de diferentes tamaños. he creado monstruos de casi 3000 líneas y otras muchas funciones de entre 100 y 300 líneas. también he creado funciones de 20 a 30 líneas de longitud. esta experiencia me ha demostrado, mediante ensayo y error, que las funciones deben ser muy reducidas. en la década de 1980 se decía que una función no debía superar el tamaño de una pantalla. por aquel entonces, las pantallas vt100 tenían 24 líneas por 80 columnas, y nuestros editores usaban 4 líneas para tareas administrativas. en la actualidad, con una fuente mínima y un monitor de gran tamaño, se pueden encajar 150 caracteres por línea y 100 líneas o más en una pantalla. las líneas no deben tener 150 caracteres. las funciones no deben tener 100 líneas de longitud. las funciones deben tener una longitud aproximada de 20 líneas. ¿qué tamaño mínimo debe tener una función? en 1999 visité a kent beck en su casa de oregon. nos sentamos y comenzamos a programar. me enseñó un atractivo programa de java/swing que había llamado sparkle . generaba un efecto visual en pantalla, similar a la varita mágica del hada de 63cenicienta. al mover el ratón, salían estrellitas del cursor, y descendían a la parte inferior de la pantalla en un campo gravitatorio simulado. cuando kent me enseñó el código, me sorprendió la brevedad de las funciones. estaba acostumbrado a ver programas de swing con funciones que ocupaban kilómetros de espacio vertical. en este programa, las funciones tenían dos, tres o cuatro líneas de longitud. todas eran obvias. todas contaban una historia y cada una llevaba a la siguiente en un orden atractivo. ¡así de breves deberían ser todas las funciones! [12] ¿qué tamaño mínimo deben tener sus funciones? deberían ser más breves que las del listado 3-2. de hecho, el listado 3-2 debería reducirse como el listado 3-3. listado 3-3 htmlutil.java (nueva refactorización). public static string renderpagewithsetupsandteardowns( pagedata pagedata, boolean issuite) throws exception { if (istestpage(pagedata)) includesetupandteardownpages(pagedata, issuite); return pagedata.gethtml(); } bloques y sangrado esto implica que los bloques en instrucciones if , else , while y similares deben tener una línea de longitud que, seguramente, sea la invocación de una función. de esta forma, no sólo se reduce el tamaño de la función, sino que también se añade valor documental ya que la función invocada desde el bloque puede tener un nombre descriptivo. también implica que las funciones no deben tener un tamaño excesivo que albergue estructuras anidadas. por tanto, el nivel de sangrado de una función no debe ser mayor de uno o dos. evidentemente, de esta forma las funciones son más fáciles de leer y entender. hacer una cosa 64es evidente que el listado 3-1 hace más de una cosa. crea búferes, obtiene páginas, busca páginas heredadas, añade cadenas antiguas y genera html. el listado 3-1 está muy ocupado realizando varias tareas. por su parte, el listado 3-3 sólo hace una cosa: incluye configuraciones y detalles en páginas de prueba. el siguiente consejo lleva vigente, de una u otra forma, durante más de 30 años: las funciones sólo deben hacer una cosa. deben hacerlo bien y debe ser lo único que hagan. el problema de esta afirmación es saber qué es una cosa. ¿el listado 3-3 hace una cosa? se podría pensar que hace tres: 1 . determinar si la página es una página de prueba. 2 . en caso afirmativo, incluir configuraciones y detalles. 3 . representar la página en html. ¿cuál será de las tres? ¿la función hace una o tres cosas? los tres pasos de la función se encuentran un nivel de abstracción por debajo del nombre de la función. podemos describir la función como un breve párrafo to (para) [13] : para renderpagewithsetupsandteardowns , comprobamos si la página es de prueba y, en caso afirmativo, incluimos las configuraciones y los detalles. en ambos casos, la representamos en html. si una función sólo realiza los pasos situados un nivel por debajo del nombre de la función, entonces hace una cosa. en definitiva, creamos funciones para descomponer conceptos más amplios (es decir, el nombre de 65la función) en un conjunto de pasos en el siguiente nivel de abstracción. es evidente que el listado 3-1 contiene pasos en distintos niveles de abstracción, por lo que es obvio que hace más de una cosa. incluso el listado 3-2 tiene tres niveles de abstracción, como ha demostrado la capacidad de reducirlo, pero sería complicado reducir con sentido el listado 3-3. podríamos extraer la instrucción if en la función includesetupsandteardownsiftestpage , pero sólo reduciríamos el código sin cambiar el nivel de abstracción. por ello, otra forma de saber que una función hace más de una cosa es extraer otra función de la misma con un nombre que no sea una reducción de su implementación [g34]. secciones en funciones fíjese en el listado 4-7. verá que la función generateprimes se divide en secciones como declaraciones, inicializaciones y filtros. es un síntoma evidente de que hace más de una cosa. las funciones que hacen una sola cosa no se pueden dividir en secciones. un nivel de abstracción por función para que las funciones realicen «una cosa», asegúrese de que las instrucciones de la función se encuentran en el mismo nivel de abstracción. el listado 3-1 incumple esta regla. incluye conceptos a un elevado nivel de abstracción, como gethtml(); otros se encuentran en un nivel intermedio, como stringpagepathname = pathparser.render(pagepath) y hay otros en un nivel especialmente bajo, como .append(“\n”). la mezcla de niveles de abstracción en una función siempre resulta confusa. los lectores no sabrán si una determinada expresión es un concepto esencial o un detalle. peor todavía, si se mezclan detalles con conceptos esenciales, aumentarán los detalles dentro de la función. 66leer código de arriba a abajo: la regla descendente el objetivo es que el código se lea como un texto de arriba a abajo [14] . queremos que tras todas las funciones aparezcan las del siguiente nivel de abstracción para poder leer el programa, descendiendo un nivel de abstracción por vez mientras leemos la lista de funciones. es lo que denomino la regla descendente. para decirlo de otra forma, queremos leer el programa como si fuera un conjunto de párrafos to , en el que cada uno describe el nivel actual de abstracción y hace referencia a los párrafos to posteriores en el siguiente nivel. para incluir configuraciones y detalles, incluimos configuraciones, después del contenido de la página de prueba, y por último los detalles. para incluir las configuraciones, incluimos la configuración de suite si se trata de una suite , y después la configuración convencional. para incluir la configuración de suite ; buscamos la jerarquía principal de la página suitesetup y añadimos una instrucción include con la ruta de dicha página. para buscar la jerarquía principal… a los programadores les resulta complicado aprender esta regla y crear funciones en un único nivel de abstracción, pero es un truco importante. es la clave para reducir la longitud de las funciones y garantizar que sólo hagan una cosa. al conseguir que el código se lea de arriba a abajo, se mantiene la coherencia de los niveles de abstracción. fíjese en el listado 3-7 del final del capítulo. muestra la función testablehtml modificada de acuerdo a estos principios. cada función presenta a la siguiente y se mantiene en un nivel de abstracción coherente. instrucciones switch 67es complicado usar una instrucción switch de tamaño reducido [15] . aunque sólo tenga dos casos, es mayor de lo que un bloque o función debería ser. también es complicado crear una instrucción switch que haga una sola cosa. por su naturaleza, las instrucciones switch siempre hacen n cosas. desafortunadamente, no siempre podemos evitar las instrucciones switch pero podemos asegurarnos de incluirlas en una clase de nivel inferior y de no repetirlas. para ello, evidentemente, recurrimos al polimorfismo. fíjese en el listado 3-4. muestra una de las operaciones que pueden depender del tipo de empleado. listado 3-4 payroll.java. public money calculatepay(employee e) throws invalidemployeetype ( switch (e.type) { case commissioned: return calculatecommissionedpay(e); case hourly: return calculatehourlypay(e); case salaried: return calculatesalariedpay(e); default: throw new invalidemployeetype(e.type); } } esta función tiene varios problemas. por un lado, es de gran tamaño y cuando se añadan nuevos tipos de empleado, aumentará más. por otra parte, hace más de una cosa. también incumple el principio de responsabilidad única ( single responsibility principie o srp) [16] ya que hay más de un motivo para cambiarla. además, incumple el principio de abierto/cerrado ( open closed principle u ocp) [17] , ya que debe cambiar cuando se añadan nuevos tipos, pero posiblemente el peor de los problemas es que hay un número ilimitado de funciones que tienen la misma estructura. por ejemplo, podríamos tener: ispayday(employee e, date date), o 68deliverpay(employee e, date date), o muchas otras, todas con la misma estructura. la solución al problema (véase el listado 3-5) consiste en ocultar la instrucción switch en una factoría abstracta [18] e impedir que nadie la vea. la factoría usa la instrucción switch para crear las instancias adecuadas de los derivados de employee y las distintas funciones, como calculatepay , ispayday y deliverpay , se entregarán de forma polimórfica a través de la interfaz employee . listado 3-5 employee y factory. public abstract class employee { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } public interface employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype; } public class employeefactoryimpl implements employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype { switch (r.type) { case commissioned: return new commissionedemployee(r); case hourly: return new hourlyemployee(r); case salaried: return new salariedemployee(r); default: throw new invalidemployeetype(r.type); } } } mi regla general para las instrucciones switch es que se pueden tolerar si sólo aparecen una vez, se usan para crear objetos polimórficos y se ocultan tras una relación de herencia para que el resto del sistema no las pueda ver [g23]. evidentemente, cada caso es diferente y en ocasiones se puede 69incumplir una o varias partes de esta regla. usar nombres descriptivos en el listado 3-7, hemos cambiado el nombre de la función de ejemplo de testablehtml a setupteardownincluder.render . es un nombre más apropiado ya que describe mejor el cometido de la función. también hemos asignado a los métodos privados un nombre descriptivo como istestable o includesetupandteardownpages . no hay que olvidar el valor de los nombres correctos. recuerde el principio de ward: «sabemos que trabajamos con código limpio cuando cada rutina es más o menos lo que esperábamos». para alcanzar este principio, gran parte del esfuerzo se basa en seleccionar nombres adecuados para pequeñas funciones que hacen una cosa. cuanto más reducida y concreta sea una función, más sencillo será elegir un nombre descriptivo. no tema los nombres extensos. un nombre descriptivo extenso es mucho mejor que uno breve pero enigmático. use una convención de nombres que permita leer varias palabras en los nombres de las funciones y use esas palabras para asignar a la función un nombre que describa su cometido. no tema dedicar tiempo a elegir un buen nombre. de hecho, debería probar con varios nombres y leer el código con todos ellos. los ide modernos como eclipse o intellij facilitan el cambio de nombres. use uno de estos ide y experimente con diferentes nombres hasta que encuentre uno que sea lo bastante descriptivo. la elección de nombres descriptivos clarifica el diseño de los módulos y le permite mejorarlos. no es extraño que la búsqueda de nombres adecuados genere una reestructuración favorable del código. sea coherente con los nombres. use las mismas frases, sustantivos y verbos en los nombres de función que elija para los módulos. pruebe, por ejemplo, con includesetupandteardownpages , includesetuppages , includesuitesetuppage e includesetuppage . la estructura similar de estos nombres permite que la secuencia cuente una historia. en realidad, si ve la secuencia anterior, seguramente se pregunte qué ha pasado con 70includeteardownpages , includesuiteteardownpage e includeteardownpage . argumentos de funciones el número ideal de argumentos para una función es cero. después uno (monádico) y dos (diádico). siempre que sea posible, evite la presencia de tres argumentos (triádico). más de tres argumentos (poliádico) requiere una justificación especial y no es muy habitual. los argumentos son complejos ya que requieren un gran poder conceptual. por ello suelo evitarlos en los ejemplos. fíjese en stringbuffer . podríamos haberlo pasado como argumento en lugar de como variable de instancia, pero los lectores habrían tenido que interpretarlo cada vez que lo vieran. al leer la historia que cuenta el módulo, includesetuppage() es más sencillo de interpretar que includesetuppageinto(newpagecontent) . el argumento se encuentra en un nivel de abstracción diferente que el nombre de la función y nos obliga a conocer un detalle ( stringbuffer ) que no es especialmente importante en ese momento. los argumentos son todavía más complicados desde un punto de vista de pruebas. imagine la dificultad de crear todos los casos de prueba para garantizar el funcionamiento de las distintas combinaciones de argumentos. si no hay argumentos, todo es más sencillo. si hay uno, no es demasiado difícil. con dos argumentos el problema es más complejo. con más de dos argumentos, probar cada combinación de valores adecuados es todo un reto. los argumentos de salida son más difíciles de entender que los de entrada. al leer una función, estamos acostumbrados al concepto de información añadida 71a la función a través de argumentos y extraída a través de un valor devuelto. no esperamos que la información se devuelva a través de los argumentos. por ello, los argumentos de salida suelen obligamos a realizar una comprobación doble. un argumento de salida es la mejor opción, después de la ausencia de argumentos. setupteardownincluder.render(pagedata) se entiende bien. evidentemente, vamos a representar los datos en el objeto pagedata . formas monádicas habituales hay dos motivos principales para pasar un solo argumento a una función. puede que realice una pregunta sobre el argumento, como en boolean fileexists(“myfile”), o que procese el argumento, lo transforme en otra cosa y lo devuelva. por ejemplo, inputstream fileopen(“myfile”) transforma un nombre de archivo string en un valor devuelto inputstream . los usuarios esperan estos dos usos cuando ven una función. debe elegir nombres que realicen la distinción con claridad y usar siempre ambas formas en un contexto coherente (consulte el apartado sobre separación de consultas de comandos). una forma menos habitual pero muy útil para un argumento es un evento. en esta forma, hay argumento de entrada pero no de salida. el programa debe interpretar la invocación de la función como evento y usar el argumento para alterar el estado del sistema, por ejemplo, void passwordattemptfailedntimes(int attempts) . use esta forma con precaución. debe ser claro para el lector que se trata de un evento. elija nombres y contextos con atención. intente evitar funciones monádicas que no tengan estas formas, por ejemplo, void includesetuppageinto(stringbuffer pagetext) . el uso de un argumento de salida en lugar de un valor devuelto para realizar transformaciones resulta confuso. si una función va a transformar su argumento de entrada, la transformación debe aparecer como valor devuelto. sin duda stringbuffertransform(stringbuffer in) es mejor que void 72transform(stringbuffer out) , aunque la implementación del primer caso devuelva solamente el argumento de entrada. al menos se ajusta a la forma de la transformación. argumentos de indicador los argumentos de indicador son horribles. pasar un valor booleano a una función es una práctica totalmente desaconsejable. complica inmediatamente la firma del método e indica que la función hace más de una cosa. hace algo si el indicador es true y otra cosa diferente si es false . en el listado 3-7 no se puede evitar, porque los invocadores ya pasan el indicador y el objetivo era limitar el ámbito a la función y después, pero la invocación de render (true) es confusa para el lector. si se desplaza el ratón sobre la invocación vemos que render (boolean issuite) puede ayudar, pero no demasiado. tendremos que dividir la función en dos: renderforsuite() y renderforsingletest() . funciones diádicas una función con dos argumentos es más difícil de entender que una función monádica. por ejemplo writefield(name) es más fácil de entender que writefield (outputstream, name) [19] . aunque en ambos casos el significado es evidente, la primera se capta mejor visualmente. la segunda requiere una breve pausa hasta que ignoramos el segundo parámetro, lo que en última instancia genera problemas ya que no debemos ignorar esa parte del código. las partes que ignoramos son las que esconden los errores. pero en ocasiones se necesitan dos argumentos. por ejemplo. point p = new point(0,0); es totalmente razonable. los puntos cartesianos suelen adoptar dos argumentos. de hecho, sería muy sorprendente ver point(0) . sin embargo, en este caso ambos argumentos son componentes ordenados de un mismo valor, mientras que outputstream y name carecen de una cohesión o un orden natural. 73incluso funciones diádicas evidentes como assertequals(expected, actual) resultan problemáticas. ¿cuántas veces ha incluido el valor real en su posición esperada? los dos argumentos carecen de un orden natural. el orden real y esperado es una convención que se adquiere gracias a la práctica. las combinaciones diádicas no son el mal en persona y tendrá que usarlas. sin embargo, recuerde que tienen un precio y que debe aprovechar los mecanismos disponibles para convertirlas en unitarias. por ejemplo, puede hacer que el método writefield sea un miembro de outputstream para poder usar outputstream.writefield(name) , o podría convertir outputstream en una variable miembro de la clase actual para no tener que pasarla. incluso podría extraer una nueva clase como fieldwriter que usara outputstream en su constructor y tuviera un método write . triadas las funciones que aceptan tres argumentos son sin duda mucho más difíciles de entender que las de dos. los problemas a la hora de ordenar, ignorar o detenerse en los argumentos se duplican. piense atentamente antes de crear una triada. por ejemplo, fíjese en la sobrecarga de assertequals que acepta tres argumentos: assertequals(message, expected, actual) . ¿cuántas veces lee el mensaje y piensa que es lo esperado? he visto esta triada en concreto muchas veces. de hecho, siempre que la veo, tengo que repasarla antes de ignorar el mensaje. por otra parte, hay otra triada que no es tan negativa: assertequals(1.0, amount, .001) . aunque también exija doble atención, merece la pena. conviene recordar siempre que la igualdad de los valores de coma flotante es algo relativo. objeto de argumento cuando una función parece necesitar dos o más argumentos, es probable que 74alguno de ellos se incluya en una clase propia. fíjese en la diferencia entre las dos siguientes declaraciones: circle makecircle (double x, double y, double radius); circle makecircle(point center, double radius); la reducción del número de argumentos mediante la creación de objetos puede parecer una trampa pero no lo es. cuando se pasan grupos de variables de forma conjunta, como x e y en el ejemplo anterior, es probable que formen parte de un concepto que se merece un nombre propio. listas de argumentos en ocasiones tendremos que pasar un número variable de argumentos a una función. fíjese en el método string.format : string.format (“%s worked %.2f hours.”, name, hours); si los argumentos variables se procesan de la misma forma, como en el ejemplo anterior, serán equivalentes a un único argumento de tipo list . por tanto, string.format es en realidad diádico. de hecho, la siguiente declaración de string.format es claramente diádica. public string format(string format, object… args) así pues, se aplican las mismas reglas. las funciones que aceptan argumentos variables pueden ser monádicas, diádicas o incluso triádicas, pero sería un error asignar más argumentos. void monad(integer… args); void dyad(string name, integer… args); void triad(string name, int count, integer… args); verbos y palabras clave la selección de nombres correctos para una función mejora la explicación de su cometido, así como el orden y el cometido de los argumentos. en formato monádico, la función y el argumento deben formar un par de verbo y sustantivo. por ejemplo, write(name) resulta muy evocador. sea lo que sea name , sin duda se escribe (write) . 75un nombre más acertado podría ser writefield(name) , que nos dice que name es un campo (field) . éste es un ejemplo de palabra clave como nombre de función. con este formato codificamos los nombres de los argumentos en el nombre de la función. por ejemplo, assertequals se podría haber escrito como assertexpectedequalsactual(expected, actual) , lo que mitiga el problema de tener que recordar el orden de los argumentos. sin efectos secundarios los efectos secundarios son mentiras. su función promete hacer una cosa, pero también hace otras cosas ocultas. en ocasiones realiza cambios inesperados en las variables de su propia clase. en ocasiones las convierte en las variables pasadas a la función o a elementos globales del sistema. en cualquier caso, se comete un engaño que suele provocar extrañas combinaciones temporales y dependencias de orden. fíjese en la función del listado 3-6, aparentemente inofensiva. usa un algoritmo estándar para comparar username con password . devuelve true si coinciden y false si hay algún problema, pero también hay un efecto secundario. ¿lo detecta? listado 3-6 uservalidator.java. public class uservalidator { private cryptographer cryptographer; public boolean checkpassword(string username, string password) { user user = usergateway.findbyname(username); if (user != user.null) { string codedphrase = user.getphraseencodedbypassword(); string phrase = cryptographer.decrypt(codedphrase, password); if (“valid password”.equals(phrase)){ session.initialize(); return true; } } return false; } 76} el efecto secundario es la invocación de session.initialize() . la función checkpassword , por su nombre, afirma comprobar la contraseña. el nombre no implica que inicialice la sesión. por tanto, un invocador que se crea lo que dice el nombre de la función se arriesga a borrar los datos de sesión actuales cuando decida comprobar la validez del usuario. este efecto secundario genera una combinación temporal. es decir, sólo se puede invocar checkpassword en determinados momentos (cuando se pueda inicializar la sesión). si no se invoca en orden, se pueden perder los datos de la sesión. las combinaciones temporales son confusas, en especial cuando se ocultan como efecto secundario. si tiene que realizar una combinación temporal, hágalo de forma clara en el nombre de la función. en este caso, podríamos cambiar el nombre de la función por checkpasswordandinitializesession , pero incumpliría la norma de hacer una sola cosa. argumentos de salida los argumentos suelen interpretarse como entradas de una función. si lleva varios años programando, estoy seguro de que habrá visto un argumento que en vez de ser de entrada era de salida. por ejemplo; appendfooter(s); ¿está función añade s al final de algo? ¿o añade el final de algo a s ? ¿ s es una entrada o una salida? lo sabemos al ver la firma de la función: public void appendfooter(stringbuffer report) esto lo aclara todo, pero para ello hay que comprobar la declaración de la función. todo lo que le obligue a comprobar la firma de la función es un esfuerzo doble. es una pausa cognitiva y debe evitarse. antes de la programación orientada a objetos, era necesario tener argumentos de salida. sin embargo, gran parte de su necesidad desaparece en los lenguajes orientados a objetos, pensados para actuar como argumento de salida. es decir, sería más indicado invocar appendfooter como report.appendfooter();. por lo general, los argumentos de salida deben evitarse. si su función 77tiene que cambiar el estado de un elemento, haga que cambie el estado de su objeto contenedor. separación de consultas de comando las funciones deben hacer algo o responder a algo, pero no ambas cosas. su función debe cambiar el estado de un objeto o devolver información sobre el mismo, pero ambas operaciones causan confusión. fíjese en la siguiente función: public boolean set(string attribute, string value); esta función establece el valor de un atributo y devuelve true en caso de éxito o false si el atributo no existe. esto provoca la presencia de una extraña instrucción como la siguiente: if (set(“username”, “unclebob”))… imagínelo desde el punto de vista del lector. ¿qué significa? ¿pregunta si el atributo « username » se ha establecido antes en « unclebob », o si el atributo «username» se ha establecido correctamente en « unclebob »? es complicado saberlo por la invocación ya que no es evidente si set es un verbo o un adjetivo. el autor pretendía que set fuera un verbo, pero el contexto de la instrucción if parece un adjetivo. la instrucción se lee como «si el atributo username se ha establecido previamente en unclebob », no como «establecer el atributo username en unclebob y si funciona, entonces…». podríamos solucionarlo si cambiamos el nombre de la función set por setandcheckifexists , pero no mejoraría la legibilidad de la instrucción if . la verdadera solución es separar el comando de la consulta para evitar la ambigüedad. if (attributeexists(“username”)) { setattribute(“username”, “unclebob”); … } 78mejor excepciones que devolver códigos de error devolver códigos de error de funciones de comando es un sutil incumplimiento de la separación de comandos de consulta. hace que los comandos usados asciendan a expresiones en los predicados de las instrucciones if . if (deletepage(page) == e_ok) no padece la confusión entre verbo y adjetivo, pero genera estructuras anidadas. al devolver un código de error se crea un problema: el invocador debe procesar el error de forma inmediata. if (deletepage(page) == e_ok) { if (registry.deletereference(page.name) == e_ok) { if (configkeys.deletekey(page.name.makekey()) == e_ok) { logger.log(“page deleted”); } else { logger.log(“configkey not deleted”); } } else { logger.log(“deletereference from registry failed”); } } else { logger.log(“delete failed”); return e_error; } por otra parte, si usa excepciones en lugar de códigos de error, el código de procesamiento del error se puede separar del código de ruta y se puede simplificar: try { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } catch (exception e) { logger.log(e.getmessage()); } extraer bloques try/catch los bloques try/catch no son atractivos por naturaleza. confunden la estructura del código y mezclan el procesamiento de errores con el normal. 79por ello, conviene extraer el cuerpo de los bloques try y catch en funciones individuales. public void delete(page page) { try { deletepageandallreferences(page); } catch (exception e) { logerror(e); } } private void deletepageandallreferences(page page) throws exception { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } private void logerror(exception e) { logger.log(e.getmessage()); } en este caso, la función delete es de procesamiento de errores. es fácil de entender e ignorar. la función deletepageandallreferences es para los procesos de borrar una página. el procesamiento de errores se puede ignorar. de este modo, la separación facilita la comprensión y la modificación del código. el procesamiento de errores es una cosa las funciones sólo deben hacer una cosa y el procesamiento de errores es un ejemplo. por tanto, una función que procese errores no debe hacer nada más. esto implica (como en el ejemplo anterior) que, si una función incluye la palabra clave try , debe ser la primera de la función y que no debe haber nada más después de los bloques catch/finally . el imán de dependencias error.java la devolución de códigos de error suele implicar que existe una clase o enumeración en la que se definen los códigos de error. public enum error { 80ok, invalid, no_such, locked, out_of_resources, waiting_for_event; } clases como ésta son un imán para las dependencias ; otras muchas clases deben importarlas y usarlas. por ello, cuando cambia la enumeración error , es necesario volver a compilar e implementar dichas clases [20] . esto añade presión a la clase error . los programadores no quieren añadir nuevos errores porque tendrán que volver a generar e implementarlo todo. por ello, reutilizan códigos de error antiguos en lugar de añadir otros nuevos. al usar excepciones en lugar de códigos de error, las nuevas excepciones son derivaciones de la clase de la excepción. se pueden añadir sin necesidad de volver a compilar o implementar [21] . no repetirse [22] fíjese de nuevo en el listado 3-1; verá que hay un algoritmo que se repite cuatro veces, en los casos setup , suitesetup , teardown y suiteteardown . no es fácil detectar esta repetición ya que las cuatro instancias se mezclan con otro código, pero la duplicación es un problema ya que aumenta el tamaño del código y requerirá una modificación cuádruple si alguna vez cambia el algoritmo. también se cuadriplica el riesgo de errores. esta duplicación se remedia gracias al método include del listado 3-7. vuelva a leer el código y fíjese en cómo se ha mejorado la legibilidad del código reduciendo la duplicación. la duplicación puede ser la raíz de todos los problemas del software . existen numerosos principios y prácticas para controlarla o eliminarla. imagine que todas las formas normales de la base de datos de codd sirvieran 81para eliminar la duplicación de datos. imagine también cómo la programación orientada a objetos concentra el código en clases base que en otros casos serian redundantes. la programación estructurada, la programación orientada a aspecto y la orientada a componentes son, en parte, estrategias para eliminar duplicados. parece que, desde la aparición de las subrutinas, las innovaciones en desarrollo de software han sido un intento continuado por eliminar la duplicación de nuestro código fuente. programación estructurada algunos programadores siguen las reglas de programación estructurada de edsger dijkstra [23] . dijkstra afirma que todas las funciones y todos los bloques de una función deben tener una entrada y una salida. estas reglas implican que sólo debe haber una instrucción return en una función, que no debe haber instrucciones break o continue en un bucle y nunca, bajo ningún concepto, debe haber instrucciones goto . aunque apreciemos los objetivos y disciplinas de la programación estructurada, no sirven de mucho cuando las funciones son de reducido tamaño. su verdadero beneficio se aprecia en funciones de gran tamaño. por tanto, si sus funciones son de tamaño reducido, una instrucción return , break o continue no hará daño alguno y en ocasiones puede resultar más expresiva que la regla de una entrada y una salida. por otra parte, goto sólo tiene sentido en funciones de gran tamaño y debe evitarse. cómo crear este tipo de funciones la creación de software es como cualquier otro proceso creativo. al escribir un informe o un artículo, primero se estructuran las ideas y después el mensaje hasta que se lea bien. el primer borrador puede estar desorganizado, de modo que lo retoca y mejora hasta que se lea de la forma adecuada. cuando creo funciones, suelen ser extensas y complicadas, con abundancia de sangrados y bucles anidados. con extensas listas de 82argumentos, nombres arbitrarios y código duplicado, pero también cuento con una serie de pruebas de unidad que abarcan todas y cada una de las líneas de código. por tanto, retoco el código, divido las funciones, cambio los nombres y elimino los duplicados. reduzco los métodos y los reordeno. en ocasiones, elimino clases enteras, mientras mantengo las pruebas. al final, consigo funciones que cumplen las reglas detalladas en este capítulo. no las escribo al comenzar y dudo que nadie pueda hacerlo. conclusión todo sistema se crea a partir de un lenguaje específico del dominio diseñado por los programadores para describir dicho sistema. las funciones son los verbos del lenguaje y las clases los sustantivos. no es volver a la noción de que los sustantivos y verbos de un documento de requisitos son las clases y funciones de un sistema. es una verdad mucho más antigua. el arte de la programación es, y ha sido siempre, el arte del diseño del lenguaje. los programadores experimentados piensan en los sistemas como en historias que contar, no como en programas que escribir. recurren a las prestaciones del lenguaje de programación seleccionado para crear un lenguaje expresivo mejor y más completo que poder usar para contar esa historia. parte de ese lenguaje es la jerarquía de funciones que describen las acciones que se pueden realizar en el sistema. dichas acciones se crean para usar el lenguaje de dominio concreto que definen para contar su pequeña parte de la historia. en este capítulo hemos visto la mecánica de la creación de funciones correctas. si aplica estas reglas, sus funciones serán breves, con nombres correctos, y bien organizadas, pero no olvide que su verdadero objetivo es contar la historia del sistema y que las funciones que escriba deben encajar en un lenguaje claro y preciso que le sirva para contar esa historia. setupteardownincluder 83listado 3-7 setupteardownincluder.java. package fitnesse.html; import fitnesse.responders.run.suiteresponder; import fitnesse.wiki.*; public class setupteardownincluder { private pagedata pagedata; private boolean issuite; private wikipage testpage; private stringbuffer newpagecontent; private pagecrawler pagecrawler; public static string render(pagedata pagedata) throws exception { return render(pagedata, false); } public static string render(pagedata pagedata, boolean issuite) throws exception { return new setupteardownincluder(pagedata).render(issuite); } private setupteardownincluder(pagedata pagedata) { this.pagedata = pagedata; testpage = pagedata.getwikipage(); pagecrawler = testpage.getpagecrawler(); newpagecontent = new stringbuffer(); } private string render(boolean issuite) throws exception { this.issuite = issuite; if (istestpage()) includesetupandteardownpages(); return pagedata.gethtml(); } private boolean istestpage() throws exception { return pagedata.hasattribute(“test”); } private void includesetupandteardownpages() throws exception { includesetuppages(); includepagecontent(); includeteardownpages(); updatepagecontent(); } private void includesetuppages() throws exception { if (issuite) includesuitesetuppage(); includesetuppage(); } 84private void includesuitesetuppage() throws exception { include(suiteresponder.suite_setup_name, “-setup”); } private void includesetuppage() throws exception { include(“setup”, “-setup”); } private void includepagecontent() throws exception { newpagecontent.append(pagedata.getcontent()); } private void includeteardownpages() throws exception { includeteardownpage(); if (issuite) includesuiteteardownpage(); } private void includeteardownpage() throws exception { include(“teardown”, “-teardown”); } private void includesuiteteardownpage() throws exception { include(suiteresponder.suite_teardown_name, “-teardown”); } private void updatepagecontent() throws exception { pagedata.setcontent(newpagecontent.tostring()); } private void include(string pagename, string arg) throws exception ( wikipage inheritedpage = findinheritedpage(pagename); if (inheritedpage != null) { string pagepathname = getpathnameforpage(inheritedpage); buildincludedirective(pagepathname, arg); } } private wikipage findinheritedpage(string pagename) throws exception { return pagecrawlerimpl.getinheritedpage(pagename, testpage); } private string getpathnameforpage(wikipage page) throws exception { wikipagepath pagepath = pagecrawler.getfullpath(page); return pathparser.render(pagepath); } private void buildincludedirective(string pagepathname, string arg) { newpagecontent .append(“\n!include ”) .append(arg) .append(“ .”) .append(pagepathname) .append(“\n”); } 85} bibliografía [kp78] : kernighan and plaugher, the elements of programming style , 2d. ed., mcgraw-hill, 1978. [ppp02] : robert c. martin, agile software development: principles, patterns, and practices, prentice hall, 2002. [gof] : design patterns: elements of reusable object oriented software, gamma et al., addison wesley, 1996. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. [sp72] : structured programming , o. j. dahl, e. w. dijkstra, c. a. r. hoare, academic press, london, 1972. 864 comentarios «no comente el código incorrecto, reescríbalo». brian w. kernighan y p. j. plaugher [24] no hay nada más útil que un comentario bien colocado. no hay nada que colapse más un módulo que comentarios dogmáticos innecesarios. no hay nada más dañino que un comentario antiguo que propague mentiras y desinformación. los comentarios no son como la lista de schindler. no son pura bondad. de hecho, en el mejor de los casos, son un mal necesario. si los lenguajes de 87programación fueran más expresivos o si pudiéramos dominarlos para expresar nuestras intenciones, no necesitaríamos demasiados comentarios, puede que incluso ninguno. el uso correcto de los comentarios permite compensar nuestra incapacidad para expresarnos en el código. he usado la palabra incapacidad, a propósito. los comentarios siempre son fallos. debemos usarlos porque no siempre sabemos cómo expresarnos sin ellos pero su uso no es motivo de celebración. cuando tenga que escribir un comentario, piense si no existe otra forma de expresarse en el código. siempre que se exprese en el código, debe felicitarse. siempre que escriba un comentario, debe hacer un gesto de desaprobación y sentir su incapacidad para expresarse. ¿por qué estoy en contra de los comentarios? porque mienten. no siempre y no siempre intencionadamente, pero lo hacen. cuando más antiguo es un comentario y más se aleja del código que describe, mayor es la probabilidad de que sea equivocado. el motivo es sencillo. los programadores no los pueden mantener. el código cambia y evoluciona. los fragmentos cambian de lugar, se bifurcan, se reproducen y se vuelven a combinar para crear quimeras. desafortunadamente, los comentarios no siempre siguen el ritmo, no siempre pueden hacerlo y suelen separarse del código que describen y se convierten en huérfanos sin precisión alguna. por ejemplo, fíjese en lo que sucede con este comentario y la línea que pretendía describir: mockrequest request; private final string http_date_regexp = “[smtwf][a-z]{2}\\,\\s[0-9]{2}\\s[jfmasond][a-z]{2}\\s” + “[0-9]{4}\\s[0-9]{2}\\:[0-9]{2}\\:[0-9]{2}\\sgmt”; private response response; private fitnessecontext context; private fileresponder responder; private locale savelocale; // ejemplo: «tue, 02 apr 2003 22:18:49 gmt» seguramente se añadieron después otras variables de instancia entre la constante http_date_regexp y su comentario explicativo. se podría afirmar que los programadores deben ser lo bastante disciplinados como para mantener los comentarios actualizados, relevantes y precisos. de acuerdo, debería, pero esa energía debería invertirse en crear 88código claro y expresivo que no necesite comentario alguno. los comentarios imprecisos son mucho peor que la ausencia de comentarios. suelen confundir al usuario. generan expectativas que nunca se cumplen. definen reglas que no deben seguirse en absoluto. la verdad sólo se encuentra en un punto: el código. sólo el código puede contar lo que hace. es la única fuente de información precisa. por tanto, aunque los comentarios sean necesarios en ocasiones, dedicaremos nuestra energía a minimizarlos. los comentarios no compensan el código incorrecto una de las principales motivaciones para crear comentarios es el código incorrecto. creamos un módulo y sabemos que es confuso y está desorganizado. sabemos que es un desastre y entonces decidimos comentarlo. error. mejor límpielo. el código claro y expresivo sin apenas comentarios es muy superior al código enrevesado y complejo con multitud de comentarios. en lugar de perder tiempo escribiendo comentarios que expliquen el desastre cometido, dedíquelo a solucionarlo. explicarse en el código en ocasiones, el código es un pobre vehículo de expresión. desafortunadamente, muchos programadores lo entienden como que el código no es un buen medio de expresión. esto es falso. ¿qué prefiere ver? esto: // comprobar si el empleado tiene derecho a todos los beneficios if ((employee.flags & hourly_flag) && (employee.age > 65)) o esto otro: if (employee.iseligibleforfullbenefits()) apenas se tardan unos segundos en explicar nuestras intenciones en el código. en muchos casos, basta con crear una función que diga lo mismo que 89el comentario que pensaba escribir. comentarios de calidad algunos comentarios son necesarios o beneficiosos. veremos algunos de los que considero válidos. no obstante, recuerde que el único comentario realmente bueno es el que no tiene que escribir. comentarios legales en ocasiones, nuestros estándares corporativos de creación de código nos obligan a crear determinados comentarios por motivos legales. por ejemplo, los comentarios de derechos de autor son necesarios y deben incluirse al inicio de cada archivo. el siguiente encabezado de comentario se incluye de forma estándar al inicio de todos los archivos fuente de fitnesse. nuestro ide evita que este comentario parezca sobrante replegándolo de forma automática. // copyright (c) 2003,2004,2005 de object mentor, inc. todos los derechos reservados. // publicado bajo las condiciones de la licencia pública general gnu versión 2 o posterior. este tipo de comentarios no deben ser contratos ni tomos legales. siempre que sea posible, haga referencia a una licencia estándar o a otro documento externo en lugar de incluir todos los términos y condiciones en el comentario. comentarios informativos en ocasiones es útil proporcionar información básica con un comentario. por ejemplo, el siguiente comentario explica el valor devuelto por un método abstracto: // devuelve una instancia del elemento responder probado. protected abstract responder responderinstance(); estos comentarios pueden ser útiles, pero es mejor usar el nombre de la función para transmitir la información siempre que sea posible. por ejemplo, 90en este caso el comentario sería redundante si cambiamos el nombre de la función por responderbeingtested. veamos un ejemplo mejor: // el formato coincide con kk:mm:ss eee, mmm dd, yyyy pattern timematcher = pattern.compile( “\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*”); en este caso, el comentario nos indica que la expresión regular debe coincidir con una fecha y una hora con el formato aplicado por la función simpledateformat.format con la cadena de formato especificada. hubiera resultado mejor y más claro si el código se hubiera cambiado a una clase especial que convirtiera los formatos de fechas y horas. de ese modo el comentario habría sido superfluo. explicar la intención en ocasiones, un comentario es algo más que información útil sobre la implementación y proporciona la intención de una decisión. en el siguiente caso, vemos una interesante decisión documentada por un comentario. al comparar dos objetos, el autor decidió ordenar los objetos de su clase por encima de los objetos de otra. public int compareto(object o) { if (o instanceof wikipagepath) { wikipagepath p = (wikipagepath) o; string compressedname = stringutil.join(names, “”); string compressedargumentname = stringutil.join(p.names, “”); return compressedname.compareto(compressedargumentname); } return 1; // somos mayores porque somos el tipo correcto. } veamos otro ejemplo mejor. puede que no esté de acuerdo con la solución del programador, pero al menos sabe lo que intentaba hacer. public void testconcurrentaddwidgets() throws exception { widgetbuilder widgetbuilder = new widgetbuilder(new class[](boldwidget.class)); string text = “‘‘‘bold text’’’”; parentwidget parent = new boldwidget(new mockwidgetroot(), “‘‘‘bold text’’’”); atomicboolean failflag = new atomicboolean(); failflag.set(false); 91//nuestro mejor intento de obtener una condición de carrera //creando un gran número de procesos. for (int i = 0; i < 25000; i++) { widgetbuilderthread widgetbuiiderthread = new widgetbuilderthread(widgetbuilder, text, parent, failflag); thread thread = new thread(widgetbuilderthread); thread.start(); } assertequals(false, failflag.get()); } clarificación en ocasiones, basta con traducir el significado de un argumento o valor devuelto en algo más legible. por lo general, conviene buscar la forma de que el argumento o el valor devuelto sean claros por sí mismos; pero cuando forma parte de una biblioteca estándar o de código que no se puede alterar, un comentario aclarativo puede ser muy útil. public void testcompareto() throws exception { wikipagepath a = pathparser.parse(“pagea”); wikipagepath ab = pathparser.parse(“pagea.pageb”); wikipagepath b = pathparser.parse(“pageb”); wikipagepath aa = pathparser.parse(“pagea.pagea”); wikipagepath bb = pathparser.parse(“pageb.pageb”); wikipagepath ba = pathparser.parse(“pageb.pagea”); asserttrue(a.compareto(a) == 0); // a == a asserttrue(a.compareto(b) != 0); // a != b asserttrue(ab.compareto(ab) == 0); // ab == ab asserttrue(a.compareto(b) == -1); // a < b asserttrue(aa.compareto(ab) == -1); // aa < ab asserttrue(ba.compareto(bb) == -1); // ba < bb asserttrue(b.compareto(a) == 1); // b > a asserttrue(ab.compareto (aa) == 1); // ab > aa asserttrue(bb.compareto(ba) == 1); // bb > ba } pero también existe el riesgo de que un comentario aclarativo sea incorrecto. en el ejemplo anterior, compruebe lo difícil que resulta comprobar si los comentarios son correctos. esto explica por qué la clarificación es necesaria y también arriesgada. por ello, antes de escribir estos comentarios, asegúrese de que no hay una solución mejor y también de que sean precisos. 92advertir de las consecuencias en ocasiones es muy útil advertir a otros programadores de determinadas consecuencias. por ejemplo, el siguiente comentario explica por qué un determinado caso de prueba está desactivado: // no ejecutar a menos // que le sobre tiempo. public void _testwithreallybigfile() { writelinestofile(10000000); response.setbody(testfile); response.readytosend(this); string responsestring = output.tostring(); assertsubstring(“content-length: 1000000000”, responsestring); asserttrue(bytessent > 1000000000); } en la actualidad, evidentemente, desactivaríamos la prueba por medio del atributo @ignore con la correspondiente cadena explicativa: @ignore(“takes too long to run”) , pero antes de la aparición de junit 4, era habitual añadir un guion bajo delante del nombre del método. el comentario realizaba su cometido. veamos otro ejemplo: public static simpledateformat makestandardhttpdateformat() { //simpledataformat no es compatible con procesos, //por lo que debe crear cada instancia de forma independiente. simpledateformat df = new simpledateformat(“eee, dd mmm yyyy hh:mm:ss z”); df.settimezone (timezone.gettimezone (“gmt”)); return df; } seguramente conozca soluciones mejores para este problema. estoy de acuerdo, pero el comentario es perfectamente razonable. evita que un programador use un inicializador estático por motivos de eficacia. comentarios todo en ocasiones conviene usar notas con forma de comentarios //todo . en el 93siguiente caso, el comentario todo explica por qué la función tiene una implementación incorrecta y cuál debe ser su futuro. // todo-mdm no son necesarios // esperamos que desaparezca en el modelo definitivo protected versioninfo makeversion() throws exception { return null; } todo son tareas que el programador piensa que debería haber hecho pero que no es así. pueden ser un recordatorio para eliminar una función obsoleta o una petición para resolver un problema. pueden ser una solicitud para buscar un nombre más adecuado o para realizar un cambio que dependa de un evento planeado. sea lo que sea, no es excusa para mantener código incorrecto en el sistema. en la actualidad, muchos ide cuentan con funciones especiales para localizar comentarios todo , por lo que seguramente no se pierda. sin embargo, no colapse el código con estos comentarios. examínelos y elimine todos los que pueda. amplificación se puede usar un comentario para amplificar la importancia de algo que, en caso contrario, parecería irrelevante. string listitemcontent = match.group(3).trim(); // el recorte es importante. elimina los espacios iniciales // que harían que el elemento se reconociera como // otra lista. new listitemwidget(this, listitemcontent, this.level + 1); return buildlist(text.substring(match.end())); javadoc en api públicas no hay nada más útil y satisfactorio que una api pública bien descrita. los javadoc de la biblioteca estándar de java son un ejemplo. sería muy complicado crear programas de java sin ellos. si usa una api pública, debe crear javadoc de calidad para la misma, pero recuerde el siguiente consejo a lo largo del capítulo: los javadoc pueden ser 94tan ambiguos, amplios y descorteses como cualquier otro tipo de documento. comentarios incorrectos muchos comentarios pertenecen a esta categoría. suelen ser excusas de código pobre o justificaciones de decisiones insuficientes, algo así como si el programador se hablara a sí mismo. balbucear añadir un comentario sin razón o porque el proceso lo requiere es un error. si decide escribir un comentario, tómese el tiempo necesario para asegurarse de que sea el mejor que puede redactar. el siguiente ejemplo es de fitnesse, donde un comentario sin duda sería de utilidad, pero el autor tenía prisa o no prestó demasiada atención. su balbuceo generó un enigma: public void loadproperties() { try { string propertiespath = propertieslocation + “/” + properties_file; fileinputstream propertiesstream = new fileinputstream(propertiespath); loadedproperties.load(propertiesstream); } catch(ioexception e) { // si no hay archivos de propiedades significan que cargan las predeterminadas } } ¿qué significa el comentario del bloque catch ? seguro que algo para el autor, pero el significado no está claro. aparentemente, si se genera ioexception , significa que no hay archivo de propiedades y, en ese caso, se cargan los valores predeterminados. ¿pero quién carga los valores predeterminados? ¿se cargan antes de la invocación de loadproperties.load o loadproperties.load captura la excepción, carga los valores predeterminados y después nos pasa la excepción para que la ignoremos? ¿o será que loadproperties.load carga todos los valores 95predeterminados antes de intentar abrir el archivo? ¿intentaba el autor consolarse por dejar el bloque catch vacío? ésta es la posibilidad más temida, ¿se estaba diciendo que volviera más tarde para crear el código para cargar los valores predeterminados? nuestro único recurso es examinar el código en otras partes del sistema para determinar qué sucede. cualquier comentario que le obligue a buscar su significado en otro módulo ha fallado en su intento de comunicación y no merece los bits que consume. comentarios redundantes el listado 4-1 muestra una sencilla función con un comentario de encabezado totalmente redundante. seguramente se tarde más en leer que el propio código. listado 4-1 waitforclose. // método de utilidad devuelto cuando this.closed es true. genera una excepción // si se alcanza el tiempo de espera. public synchronized void waitforclose(final long timeoutmillis) throws exception { if (!closed) { wait(timeoutmillis); if(!closed) throw new exception (“mockresponsesender could not be closed”); } } ¿para qué sirve este comentario? no es más informativo que el código. no lo justifica ni transmite la intención ni la lógica. no es más fácil de leer que el código. de hecho, es menos preciso y obliga al lector a aceptar la falta de precisión en lugar de a entenderlo. es como un vendedor de coches de segunda menos que le asegura que no hace falta revisar el motor. fíjese ahora en la legión de javadoc inútiles y redundantes del listado 4- 2, obtenido de tomcat. estos comentarios únicamente ensucian y oscurecen el código. no tienen ninguna función documental. para empeorar las cosas, 96sólo le mostramos algunos. el módulo tiene muchos más. listado 4-2 containerbase.java (tomcat). public abstract class containerbase implements container, lifecycle, pipeline, mbeanregistration, serializable { /** * retardo del procesador para este componente. */ protected int backgroundprocessordelay = -1; /** * compatibilidad con eventos de ciclo vital de este componente. */ protected lifecyclesupport lifecycle = new lifecyclesupport(this); /** * escuchadores de eventos de contenedor de este contenedor. */ protected arraylist listeners = new arraylist(); /** * implementación loader a la que se asocia este contenedor. */ protected loader loader = null; /** * implementación logger a la que se asocia este contenedor. */ protected log logger = null; /** * nombre de registrador asociado. */ protected string logname = null; /** * implementación manager a la que se asocia este contenedor. */ protected manager manager = null; /** * clúster al que se asocia este contenedor. */ protected cluster cluster = null; /** * nombre legible de este contenedor. 97*/ protected string name = null; /** * contenedor principal de este contenedor. */ protected container parent = null; /** * cargador de clase principal que configurar al instalar un elemento * loader. */ protected classloader parentclassloader = null; /** * objeto pipeline al que se asocia este contenedor. */ protected pipeline pipeline = new standardpipeline(this); /** * objeto realm al que se asocia este contenedor. */ protected realm realm = null; /** * objeto dircontext de recursos al que se asocia este contenedor. */ protected dircontext resources = null; comentarios confusos en ocasiones, a pesar de las buenas intenciones, un programador realiza una afirmación en sus comentarios que no es del todo precisa. fíjese otra vez en el comentario redundante y confuso del listado 4-1. ¿sabe por qué es confuso? el método no devuelve nada cuando this.closed se convierte en true . devuelve algo si this.closed es true ; en caso contrario, espera y genera una excepción si this.closed no es true . este sutil fragmento, oculto en un comentario más difícil de leer que el cuerpo del código, puede hacer que otro programador invoque la función con la esperanza de que devuelva algo cuando this.closed sea true . ese pobre programador se encontrará en una sesión de depuración intentando determinar por qué el código se ejecuta tan lentamente. 98comentarios obligatorios es una locura tener una regla que afirme que todas las funciones deben tener un javadoc o que todas las variables deben tener un comentario. este tipo de comentarios ensucian el código y generan confusión y desorganización. por ejemplo, los javadoc obligatorios para todas las funciones crean abominaciones como el listado 4-3. no sirven de nada, complican el código y constituyen posibles engaños y desorientaciones. listado 4-3 /** * * @param title el título del cd * @param author el autor del cd * @param tracks el número de pistas del cd * @param durationinminutes la duración del cd en minutos */ public void addcd(string title, string author, int tracks, int durationinminutes) { cd cd = new cd(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = duration; cdlist.add(cd); } comentarios periódicos en ocasiones, se añade un comentario al inicio de un módulo cada vez que se edita. estos comentarios acumulan una especie de registro de todos los cambios realizados. he visto módulos con decenas de páginas con estas entradas. * cambios (11-oct-2001) * ----------------------------- * 11-oct- 2001 : reorganización de la clase y cambio a un nuevo paquete * com.jrefinery.date (dg); * 05-nov- 2001 : se añade un método getdescription() y se elimina la clase notabledate (dg); 99* 12-nov- 2001 : ibd requiere el método setdescription(), una vez eliminada la clase notabledate * (dg); se cambian getpreviousdayofweek(), getfollowingdayofweek() * y getnearestdayofweek() para corregir errores (dg); * 05-dic- 2001 : error corregido en la clase spreadsheetdate (dg); * 29-may- 2002 : se transfieren todas las constantes de mes a una interfaz * independiente (monthconstants) (dg); * 27-ago- 2002 : error corregido en el método addmonths(), gracias a nálevka petr (dg); * 03-oct- 2002 : errores indicados por checkstyle (dg) corregidos; * 13-mar- 2003 : implementación de serializable (dg); * 29-may- 2003 : error corregido en el método addmonths (dg); * 04-sep- 2003 : implementación de comparable. actualización de los javadoc isinrange (dg); * 05-ene- 2005 : error corregido en el método addyears() (1096202) (dg); hace tiempo hubo una buena razón para crear y mantener estas entradas de registro al inicio de cada módulo. carecíamos de sistemas de control de código fuente que se encargaran de ello, pero en la actualidad, estas entradas son elementos sobrantes que complican los módulos. debe eliminarlas totalmente. comentarios sobrantes en ocasiones vemos comentarios que simplemente sobran. restan importancia a lo evidente y no ofrecen información nueva. /** * constructor predeterminado. */ protected annualdaterule() { } ¿en serio? ¿y este otro?: /** día del mes. */ private int dayofmonth; y aquí el parangón de la redundancia: /** * devuelve el día del mes. 100* * @return el día del mes. */ public int getdayofmonth() { return dayofmonth; } estos comentarios son tan inservibles que aprendemos a ignorarlos. al leer el código, la vista los salta. con el tiempo, los comentarios empiezan a mentir cuando cambia el código que les rodea. el primer comentario del listado 4-4 parece correcto [25] . explica por qué se ignora el bloque catch , pero el segundo comentario sobra. parece que el programador estaba tan frustrado con crear bloques try/catch en la función que necesitaba explotar. listado 4-4 startsending. private void startsending() { try { dosending(); } catch(socketexception e) { // normal, alguien ha detenido la solicitud. } catch(exception e) { try { response.add(errorresponder.makeexceptionstring(e)); response.closeall(); } catch(exception e1) { //¡un respiro! } } } en lugar de explotar en un comentario sin sentido, el programador debería haber sabido que su frustración se podría aliviar mejorando la estructura del código. tendría que haber centrado su energía en extraer el último bloque try/catch en una función independiente, como muestra el 101listado 4-5. listado 4-5 startsending (refactorizado). private void startsending() { try { dosending(); } catch(socketexception e) { // normal. alguien ha detenido la solicitud. } catch(exception e) { addexceptionandcloseresponse(e); } } private void addexceptionandcloseresponse(exception e) { try { response.add(errorresponder.makeexceptionstring(e)); response.closeall(); } catch(exception e1) { } } cambie la tentación de crear elementos sobrantes por la determinación de limpiar su código. mejorará como programador y será más fácil. comentarios sobrantes espeluznantes los javadoc también pueden ser innecesarios. ¿para qué sirven los siguientes javadoc (de una conocida biblioteca) de código abierto? la respuesta: para nada. son comentarios redundantes creados en un intento equivocado de redactar documentación. /** el nombre. */ private string name; /** la versión. */ 102private string version; /** el licencename. */ private string licencename; /** la versión. */ private string info; vuelva a leer los comentarios. ¿detecta el error de corta y pega? si los autores no prestan atención al escribir sus comentarios (o al pegarlos), ¿por qué se espera que sean de utilidad para los lectores? no usar comentarios si se puede usar una función o una variable fíjese en el siguiente código: // ¿el módulo de la lista global <mod> depende del // subsistema del que formamos parte? if (smodule.getdependsubsystems().contains(subsysmod.getsubsystem())) se podría cambiar sin el comentario de esta forma: arraylist moduledependees = smodule.getdependsubsystems(); string oursubsystem = subsysmod.getsubsystem(); if (moduledependees.contains(oursubsystem)) el autor del código original seguramente escribió primero el comentario (improbable) y después el código para ajustarlo al comentario. sin embargo, el autor tendría que haber refactorizado el código, como hice yo, para poder eliminar el comentario. marcadores de posición en ocasiones los programadores marcan una determinada posición en un archivo. por ejemplo, recientemente encontré esto en un programa: // acciones ////////////////////////////////// son escasas las ocasiones en las que tiene sentido agrupar funciones bajo esta estructura. por lo general, debe eliminarse, sobre todo la molesta hilera de barras al final. piénselo de esta forma. estas estructuras son atractivas si no las usa demasiado. por ello, úselas esporádicamente y sólo cuando el beneficio sea 103significativo. si las usa en exceso, acabarán por ser ignoradas. comentarios de llave de cierre en ocasiones, los programadores incluyen comentarios especiales en llaves de cierre, como en el listado 4-6. aunque pueda tener sentido en funciones extensas con estructuras anidadas, únicamente estorba a las funciones encapsuladas y de pequeño tamaño que nos gustan. por ello, si siente el deseo de marcar sus llaves de cierre, pruebe a reducir el tamaño de sus funciones. listado 4-6 wc.java. public class wc { public static void main(string[] args) { bufferedreader in = new bufferedreader(new inputstreamreader(system.in)); string line; int linecount = 0; int charcount = 0; int wordcount = 0; try { while ((line = in.readline()) != null) { linecount++; charcount += line.length(); string words[] = line.split(“\\w”); wordcount += words.length; } //while system.out.println(“wordcount = ” + wordcount); system.out.println(“linecount = ” + linecount); system.out.println(“charcount = ” + charcount); } // try catch (ioexception e) { system.err.println(“error: ” + e.getmessage()); } //catch } //main } asignaciones y menciones /* añadido por rick */ los sistemas de control de código fuente recuerdan a la perfección quién ha añadido qué y cuándo. no es necesario plagar el código con pequeñas 104menciones. puede pensar que estos comentarios son útiles y que ayudan a otros a hablar sobre el código, pero en realidad sobreviven durante años y cada vez son menos precisos y relevantes. el sistema de control de código fuente es el punto idóneo para este tipo de información. código comentado no hay nada más odioso que el código comentado. ¡no lo haga! inputstreamresponse response = new inputstreamresponse(); response.setbody(formatter.getresultstream(), formatter.getbytecount()); // inputstream resultsstream = formatter.getresultstream(); // streamreader reader = new streamreader(resultsstream); // response.setcontent(reader.read(formatter.getbytecount())); los lectores que vean código comentado no tendrán el valor de borrarlo. pensarán que está ahí por algo y que es demasiado importante para borrarlo. por ello, el código comentado se acumula como los sedimentos en una botella de vino malo. fíjese en este fragmento de apache commons: this.bytepos = writebytes(pngidbytes, 0); //hdrpos = bytepos; writeheader(); writeresolution(); //datapos = bytepos; if (writeimagedata()) { writeend(); this.pngbytes = resizebytearray(this.pngbytes, this.maxpos); } else { this.pngbytes = null; } return this.pngbytes; ¿por qué hay dos líneas comentadas? ¿son importantes? ¿se han conservado como recordatorio de un cambio inminente o es algo que alguien comentó hace años y no se ha preocupado de limpiar? hubo una época, en la década de 1960, en la que el código comentado pudo ser útil, pero hace tiempo que contamos con buenos sistemas de control de código fuente, sistemas que recuerdan el código por nosotros. ya no tenemos que comentarlo. elimínelo. no lo perderá. se lo aseguro. 105comentarios html el html en comentarios de código fuente es una aberración, como puede apreciar en el siguiente fragmento. dificulta la lectura de los comentarios donde debería ser más fácil; el editor o ide. si los comentarios se van a extraer con una herramienta (como javadoc) para mostrarlos en una página web, debe ser responsabilidad de dicha herramienta y no del programador el adornar los comentarios con el correspondiente html. /** * tarea para ejecutar pruebas de aceptación. * esta tarea ejecuta pruebas de aceptación y publica los resultados. * <p/> * <pre> * uso: * &lt;taskdef name=&quot;execute-fitnesse-tests&quot; * classname=&quot;fitnesse.ant.executefitnesseteststask&quot; * classpathref=&quot;classpath&quot; /&gt; * or * &lt;taskdef classpathref=&quot;classpath&quot; * resource=&quot;tasks.properties&quot; /&gt; * <p/> * &lt;execute-fitnesse-tests * suitepage=&quot;fitnesse.suiteacceptancetests&quot; * fitnesseport=&quot;8082&quot; * resultsdir=&quot;$(results.dir)&quot; * resultshtmlpage=&quot;fit-results.html&quot; * classpathref=&quot;classpath&quot; /&gt; * </pre> */ información no local si tiene que escribir un comentario, asegúrese de que describa el código que le rodea. no ofrezca información global del sistema en el contexto de un comentario local. fíjese en el siguiente comentario javadoc. aparte de su terrible redundancia, también ofrece información sobre el puerto predeterminado y la función no tiene control alguno sobre el puerto predeterminado. el comentario no describe la función sino otra parte distinta 106del sistema. evidentemente, no hay garantías de que el comentario cambie cuando lo haga el código que contiene el valor predeterminado. /** * puerto para ejecutar fitnesse. el predeterminado es <b>8082</b>. * * @param fitnesseport */ public void setfitnesseport(int fitnesseport) { this.fitnesseport = fitnesseport; } demasiada información no incluya en sus comentarios interesantes reflexiones históricas ni irrelevantes descripciones de detalles. el siguiente comentario se ha extraído de un módulo diseñado para probar que una función puede codificar y descodificar base64. aparte del número rfc, el lector de este código no necesita la información obsoleta que contiene el comentario. /* rfc 2045 - extensiones multipropósito de correo de internet (mime) primera parte: formato del cuerpo de los mensajes de internet sección 6.8. codificación de transferencia de contenidos base64 el proceso de codificación representa grupos de 24 bits de la entrada como cadenas de salida de 4 caracteres codificados. procediendo de izquierda a derecha, se forma un grupo de 24 bits de entrada concatenando 3 grupos de 8 bits de entrada. estos 24 bits se tratan como 4 grupos concatenados de 6 bits, cada uno de los cuales se traduce en un solo dígito del alfabeto base64. cuando se codifica un flujo de bits mediante la codificación base64, el flujo de bits se debe considerar ordenado con el bit más significativo primero. esto es, el primer bit del flujo será el bit de orden más alto en el primer byte de 8 bits, y el octavo bit será el de orden más bajo en el primer byte de 8 bits, y así sucesivamente. */ conexiones no evidentes la conexión entre un comentario y el código que describe debe ser evidente. si se ha preocupado de escribir un comentario, lo mínimo es que el lector que lo vea entienda a qué se refiere. fíjese en este comentario obtenido de apache commons: 107/* * comienza con una matriz de tamaño suficiente para albergar todos los pixeles * (más bytes de filtro), y 200 bytes adicionales para la información de encabezado */ this.pngbytes = new byte[((this.width + 1) * this.height * 3) + 200]; ¿qué es un byte de filtro? ¿está relacionado con +1 ? ¿o con *3 ? ¿con ambos? ¿es un pixel un byte ? ¿por qué 200? la función de un comentario es explicar código que no se explica por sí mismo. es una lástima que un comentario requiera su propia explicación. encabezados de función las funciones breves apenas requieren explicación. un nombre bien elegido para una función que hace una cosa suele ser mejor que un encabezado de comentario. javadocs en código no público a pesar de la utilidad de los javadoc para las api públicas, no sirven para código no dirigido a consumo público. la generación de páginas javadoc para clases y funciones de un sistema no suele ser útil y la formalidad adicional de los comentarios javadoc no es más que una distracción. ejemplo escribí el módulo del listado 4-7 para la primera versión de xp immersion . debía ser un ejemplo de estilo incorrecto de creación de código y comentarios. después, kent beck refactorizó este código en algo mucho más atractivo delante de varios alumnos. posteriormente, adapté el ejemplo para mi libro agile software development, principles, patterns, and practices y para el primero de mis artículos craftsman publicados en la revista software development . lo que me fascina de este módulo es que hubo un tiempo en que muchos 108lo hubiéramos considerado bien documentado. ahora vemos que es un auténtico desastre. a ver cuántos problemas detecta en los comentarios. listado 4-7 generateprimes.java. /** * esta clase genera números primos hasta la cantidad máxima especificada por el * usuario. el algoritmo usado es la criba de eratóstenes. * <p> * eratóstenes de cirene, 276 a. c., cirene, libia - * 194 a. c., alejandría. el primer hombre en calcular la * circunferencia de la tierra. también trabajó con calendarios * con años bisiestos y fue responsable de la biblioteca de alejandría. * <p> * el algoritmo es muy simple. dada una matriz de enteros * empezando por el 2, se tachan todos los múltiplos de 2. se busca el siguiente * entero sin tachar y se tachan todos sus múltiplos. * repetir hasta superar la raíz cuadrada del valor * máximo. * * ©author alphonse * ©version 13 feb 2002 atp */ import java.util.*; public class generateprimes { /** * @param maxvalue es el límite de generación. */ public static int[] generateprimes(int maxvalue) { if (maxvalue >= 2) //el único caso válido { // declaraciones int s = maxvalue + 1; // tamaño de la matriz boolean[] f = new boolean[s]; int i; // inicializar la matriz en true. for (i = 0; i < s; i++) f[i] = true; // eliminar los números no primos conocidos f[0] = f[1] = false; // cribar int j; 109for (i = 2; i < math.sqrt(s) + 1; i++) { if (f[i]) // si no está tachado, tachar sus múltiplos. { for (j = 2 * i; j < s; j += i) f[j] = false; // el múltiplo no es primo } } // ¿cuántos primos hay? int count = 0; for (i = 0; i < s; i++) { if (f[i]) count++; // contador. } int[] primes = new int[count]; // enviar primos al resultado for (i = 0, j = 0; i < s; i++) { if (f[i]) // si es primo primes[j++] = i; } return primes; // devolver los primos } else // maxvalue < 2 return new int[0]; // devolver matriz null si la entrada no es correcta. } } en el listado 4-8 puede ver una versión refactorizada del mismo módulo. se ha limitado considerablemente el uso de comentarios. hay sólo dos en todo el módulo y ambos claramente descriptivos. listado 4-8 primegenerator.java (refactorizado). /** * esta clase genera números primos hasta la cantidad máxima especificada por el * usuario. el algoritmo usado es la criba de eratóstenes. dada una matriz de enteros * empezando por el 2: buscar el primer entero sin tachar y tachar todos sus * múltiplos. repetir hasta que no haya más múltiplos en la matriz. */ public class primegenerator { 110private static boolean[] crossedout; private static int[] result; public static int[] generateprimes(int maxvalue) { if (maxvalue < 2) return new int[0]; else { uncrossintegersupto(maxvalue); crossoutmultiples(); putuncrossedintegersintoresult(); return result; } } private static void uncrossintegersupto(int maxvalue) { crossedout = new boolean[maxvalue + 1]; for (int i = 2; i < crossedout.length; i++) crossedout[i] = false; } private static void crossoutmultiples() { int limit = determineiterationlimit(); for (int i = 2; i <= limit; i++) if (notcrossed(i)) crossoutmultiplesof(i); } private static int determineiterationlimit() { // cada múltiplo en la matriz tiene un factor primordial que // es menor o igual que la raíz del tamaño de la matriz, // entonces no tenemos que tachar múltiplos de números // más grande que esa raíz. double iterationlimit = math.sqrt(crossedout.length); return (int) iterationlimit; } private static void crossoutmultiplesof (int i) { for (int multiple = 2 * i; multiple < crossedout.length; multiple += i) crossedout[multiple] = true; } private static boolean notcrossed(int i) { return crossedout[i] == false; } private static void putuncrossedintegersintoresult() 111{ result = new int[numberofuncrossedintegers()]; for (int j = 0, i = 2; i < crossedout.length; i++) if (notcrossed(i)) result[j++] = i; } private static int numberofuncrossedintegers() { int count = 0; for (int i = 2; i < crossedout.length; i++) if (notcrossed(i)) count++; return count; } } se podría decir que el primer comentario es redundante ya que es muy similar a la función generateprimes , pero creo que muestra mejor el algoritmo al lector, motivo por el que lo he mantenido. el segundo argumento es sin duda necesario. explica la lógica del uso de la raíz cuadrada como límite del bucle. no encontré otro nombre de variable más sencillo ni otra estructura de código que lo aclarara más. por otra parte, el uso de la raíz cuadrada podría resultar presuntuoso. ¿realmente se ahorra tanto tiempo limitando la iteración a la raíz cuadrada? ¿el cálculo de la raíz cuadrada llevaría más tiempo del que se ahorra? conviene analizarlo. el uso de la raíz cuadrada como límite de iteración satisface al viejo hacker de c y de lenguajes de ensamblado de mi interior, pero no estoy convencido de que merezca el tiempo y el esfuerzo que los demás puedan dedicar a entenderlo. bibliografía [kp78] : kernighan and plaugher, the elements of programming style , 2d. ed., mcgraw-hill, 1978. 1125 formato cuando los usuarios miran entre bastidores, queremos que queden 113impresionados por el atractivo, la coherencia y la atención al detalle que perciben. queremos que el orden les sorprenda, que abran los ojos con asombro cuando se desplacen por los módulos. queremos que aprecien que se trata de un trabajo de profesionales. si ven una masa amorfa de código que parece escrito por un grupo de marineros borrachos, es probable que piensen que sucederá lo mismo en otros aspectos del proyecto. debe preocuparse por el formato de su código. debe elegir una serie de reglas sencillas que controlen el formato del código y después aplicarlas de forma coherente. si trabaja en equipo, debe acordar una serie de reglas que todos los miembros deben cumplir. también es muy útil usar una herramienta automatizada que se encargue de aplicar las reglas. la función del formato en primer lugar, debe ser claro. el formato de código es importante, demasiado importante como para ignorarlo y también demasiado importante como para tratarlo de forma religiosa. el formato del código se basa en la comunicación y la comunicación debe ser el principal pilar de un desarrollador profesional. puede que piense que conseguir que algo funcione es la principal preocupación de un programador profesional. espero que este libro le haga cambiar de idea. la funcionalidad que cree hoy es muy probable que cambie en la siguiente versión, pero la legibilidad de su código afectará profundamente a todos los cambios que realice. el estilo del código y su legibilidad establecen los precedentes que afectan a la capacidad de mantenimiento y ampliación mucho después de que el código cambie. su estilo y su disciplina sobrevivirán, aunque el código no lo haga. veamos qué aspectos del formato nos permiten comunicarnos mejor. formato vertical comencemos por el tamaño vertical. ¿qué tamaño debe tener un archivo 114fuente? en java, el tamaño de los archivos está relacionado con el tamaño de las clases, como veremos más adelante. por el momento, nos detendremos en el tamaño de los archivos. ¿qué tamaño tienen la mayoría de archivos fuente de java? existe una amplia gama de tamaños e importantes diferencias de estilo, como se aprecia en la figura 5.1. figura 5.1. escala log de distribuciones de longitud de archivos (altura del cuadro = sigma). se describen siete proyectos: junit, fitnesse, testng, time and money, jdepend, ant y tomcat. las líneas que cruzan los cuadros muestran la longitud máxima y mínima de cada proyecto. el cuadro muestra aproximadamente un tercio (una desviación estándar [26] ) de los archivos. la parte central del cuadro es la media. por tanto, el tamaño de archivo medio del proyecto fitnesse es de 65 líneas y un tercio de los archivos ocupan entre 40 y 100+ líneas. el mayor archivo de fitnesse tiene unas 400 líneas y el de menor tamaño, 6. es una escala de registro, de modo que la pequeña diferencia de posición vertical supone una gran diferencia en tamaño absoluto. junit, fitnesse y time and money tienen archivos relativamente pequeños. ninguno supera las 500 líneas y la mayoría tienen menos de 200. tomcat y ant, por su parte, tienen archivos con varios miles de líneas de 115longitud y más de la mitad superan las 200. ¿qué significa todo esto? aparentemente se pueden crear sistemas (fitnesse se aproxima a las 50 000 líneas) a partir de archivos de unas 200 líneas de longitud, con un límite máximo de 500. aunque no debería ser una regla, es un intervalo aconsejable. los archivos de pequeño tamaño se entienden mejor que los grandes. la metáfora del periódico piense en un artículo de periódico bien escrito. en la parte superior espera un titular que indique de qué se trata la historia y le permita determinar si quiere leerlo o no. el primer párrafo ofrece una sinopsis de la historia, oculta los detalles y muestra conceptos generales. al avanzar la lectura, aumentan los detalles junto con todas las fechas, nombres, citas y otros elementos. un archivo de código debe ser como un artículo de periódico. el nombre debe ser sencillo pero claro. por sí mismo, debe bastar para indicarnos si estamos o no en el módulo correcto. los elementos superiores del archivo deben proporcionar conceptos y algoritmos de nivel superior. los detalles deben aumentar según avanzamos, hasta que en la parte final encontremos las funciones de nivel inferior del archivo. un periódico se compone de varios artículos, algunos muy reducidos y otros de gran tamaño. no hay muchos que ocupen toda la página con texto, para que el periódico sea manejable. si el periódico fuera un único y extenso texto con una aglomeración desorganizada de hechos, fechas y nombres, no lo leeríamos. apertura vertical entre conceptos la práctica totalidad del código se lee de izquierda a derecha y de arriba a abajo. cada línea representa una expresión o una cláusula, y cada grupo de líneas representa un pensamiento completo. estos pensamientos deben separarse mediante líneas en blanco. fíjese en el listado 5-1. hay líneas en blanco que separan la declaración 116del paquete, las importaciones y las funciones. es una regla muy sencilla con un profundo efecto en el diseño visual del código. cada línea en blanco es una pista visual que identifica un nuevo concepto independiente. al avanzar por el listado, la vista se fija en la primera línea que aparece tras una línea en blanco. listado 5-1 boldwidget.java package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = “‘‘‘.+?’’’”; private static final pattern pattern = pattern.compile (“‘‘‘(.+?)’’’”, pattern.multiline + pattern.dotall ); public boldwidget(parentwidget parent, string text) throws exception { super(parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group(1)); } public string render() throws exception { stringbuffer html = new stringbuffer(“<b>”); html.append(childhtml()).append (“</b>”); return html.tostring(); } } si eliminamos las líneas en blanco, como en el listado 5-2, se oscurece la legibilidad del código. listado 5-2 boldwidget.java package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = “‘‘‘.+?’’’”; private static final pattern pattern = pattern.compile(“‘‘‘(.+?)’’’”, pattern.multiline + pattern.dotall); public boldwidget(parentwidget parent, string text) throws exception { 117super(parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group(1));} public string render() throws exception { stringbuffer html = new stringbuffer(“<b>”); html.append(childhtml()).append(“</b>”); return html.tostring(); } } este efecto aumenta todavía más si no centramos la vista. en el primer ejemplo, los distintos grupos de líneas saltan a la vista, mientras que en el segundo es una mezcla amorfa. la diferencia entre ambos listados es una ligera apertura vertical. densidad vertical si la apertura separa los conceptos, la densidad vertical implica asociaciones. por tanto, las líneas de código con una relación directa deben aparecer verticalmente densas. fíjese en cómo los comentarios sin sentido del listado 5-3 anulan la asociación entre las dos variables de instancia. listado 5-3 public class reporterconfig { /** * nombre de clase del escuchador */ private string m_classname; /** * propiedades del escuchador */ private list<property> m_properties = new arraylist<property>(); public void addproperty(property property) { m_properties.add(property); } el listado 5-4 es mucho más fácil de leer. lo apreciamos a simple vista o al menos yo lo hago. al mirarlo, veo que es una clase con dos variables y un método, sin tener que mover la cabeza ni la vista. el listado anterior nos 118obliga a forzar la vista y a mover la cabeza para alcanzar el mismo nivel de comprensión. listado 5-4 public class reporterconfig { private string m_classname; private list<property> m_properties = new arraylist<property>(); public void addproperty(property property) { m_properties.add(property); } distancia vertical ¿alguna vez ha tenido que recorrer una clase, saltando de una función a otra, desplazándose por el código para intentar adivinar la relación y el funcionamiento de las funciones, y acabar totalmente confundido? ¿alguna vez ha escudriñado la cadena de herencia buscando la definición de una variable o función? resulta frustrante porque intenta comprender lo que hace el sistema, pero pierde el tiempo y su energía mental en intentar localizar y recordar sus elementos. los conceptos relacionados entre sí deben mantenerse juntos verticalmente [g10]. esta regla no funciona con conceptos de archivos independientes. por lo tanto, no debe separar conceptos relacionados en archivos independientes a menos que tenga un motivo de peso. de hecho, es uno de los motivos por los que se debe evitar el uso de variables protegidas. para los conceptos relacionados que pertenecen al mismo archivo, su separación vertical debe medir su importancia con respecto a la legibilidad del otro. debe evitar que el lector deambule entre archivos y clases. declaraciones de variables las variables deben declararse de la forma más aproximada a su uso. como las funciones son muy breves, las variables locales deben aparecer en la parte superior de cada función, como en este ejemplo de junit4.3.1. 119private static void readpreferences() { inputstream is = null; try { is = new fileinputstream(getpreferencesfile()); setpreferences(new properties(getpreferences())); getpreferences().load(is); } catch (ioexception e) { try { if (is != null) is.close(); } catch (ioexception e1) { } } } las variables de control de bucles deben declararse en la instrucción del bucle, como en esta pequeña función del mismo código fuente: public int counttestcases() { int count= 0; for ( test each : tests) count += each.counttestcases(); return count; } en casos excepcionales, una variable puede declararse en la parte superior de un bloque o antes de un bucle en una función extensa. puede ver este tipo de variable en la siguiente función de testng. … for (xmltest test: m_suite.gettests()) { testrunner tr = m_runnerfactory.newtestrunner(this, test); tr.addlistener(m_textreporter); m_testrunners.add(tr); invoker = tr.getinvoker(); for (itestngmethod m : tr.getbeforesuitemethods()) { beforesuitemethods.put(m.getmethod(), m); } for (itestngmethod m : tr.getaftersuitemethods()) { aftersuitemethods.put(m.getmethod(), m); } } … variables de instancia las variables de instancia, por su parte, deben declararse en la parte superior de la clase. esto no debe aumentar la distancia vertical de las variables, ya 120que en una clase bien diseñada se usan en muchos sino en todos sus métodos. existen discrepancias sobre la ubicación de las variables de instancia. en c++ suele aplicarse la denominada regla de las tijeras, que sitúa todas las variables de instancia en la parte inferior. en java, sin embargo, es habitual ubicarlas en la parte superior de la clase. no veo motivos para no hacerlo. lo importante es declarar las variables de instancia en un punto conocido para que todo el mundo sepa dónde buscarlas. fíjese en el extraño caso de la clase testsuite de junit 4.3.1. he atenuado considerablemente esta clase para ilustrar este concepto. si se fija en la mitad del listado, verá dos variables de instancia declaradas. resultaría complicado ocultarlas en un punto mejor. cualquiera que lea este código tendría que toparse con las declaraciones por casualidad (como me pasó a mí). public class testsuite implements test { static public test createtest(class<? extends testcase> theclass, string name) { … } public static constructor<? extends testcase> gettestconstructor(class<? extends testcase> theclass) throws nosuchmethodexception { … } public static test warning(final string message) { … } private static string exceptiontostring(throwable t) { … } private string fname; private vector<test> ftests = new vector<test>(10); public testsuite() { } public testsuite(final class<? extends testcase> theclass) { … } public testsuite(class<? extends testcase> theclass, string name) { … } 121… … … … } funciones dependientes si una función invoca otra, deben estar verticalmente próximas, y la función de invocación debe estar por encima de la invocada siempre que sea posible. de este modo el programa fluye con normalidad. si la convención se sigue de forma fiable, los lectores sabrán que las definiciones de función aparecen después de su uso. fíjese en el fragmento de fitnesse del listado 5-5. la función superior invoca las situadas por debajo que, a su vez, invocan a las siguientes. esto facilita la detección de las funciones invocadas y mejora considerablemente la legibilidad del módulo completo. listado 5-5 wikipageresponder.java. public class wikipageresponder implements secureresponder { protected wikipage page; protected pagedata pagedata; protected string pagetitle; protected request request; protected pagecrawler crawler; public response makeresponse(fitnessecontext context, request request) throws exception { string pagename = getpagenameordefault(request, “frontpage”); loadpage(pagename, context); if (page == null) return notfoundresponse(context, request); else return makepageresponse(context); } private string getpagenameordefault(request request, string defaultpagename) { string pagename = request.getresource(); if (stringutil.isblank(pagename)) pagename = defaultpagename; return pagename; } protected void loadpage(string resource, fitnessecontext context) throws exception { wikipagepath path = pathparser.parse(resource); 122crawler = context.root.getpagecrawler(); crawler.setdeadendstrategy(new virtualenabledpagecrawler()); page = crawler.getpage(context.root, path); if (page != null) pagedata = page.getdata(); } private response notfoundresponse(fitnessecontext context, request request) throws exception { return new notfoundresponder().makeresponse(context, request); } private simpleresponse makepageresponse(fitnessecontext context) throws exception { pagetitle = pathparser.render(crawler.getfullpath(page)); string html = makehtml(context); simpleresponse response = new simpleresponse(); response.setmaxage(0); response.setcontent(html); return response; } … además, este fragmento es un buen ejemplo de ubicación de constantes en un nivel correcto [g35]. la constante frontpage se podría haber ocultado en la función getpagenameordefault , pero eso habría ocultado una constante conocida y esperada en una función de nivel inferior de forma incorrecta. es mejor pasar la constante desde un punto en el que tiene sentido a la posición en la que realmente se usa. afinidad conceptual determinados conceptos de código deben estar próximos a otros. tienen una afinidad conceptual concreta. cuanto mayor sea esta afinidad, menor distancia vertical debe existir entre ellos. como hemos visto, esta afinidad se puede basar en una dependencia directa, como cuando una función invoca a otra, o cuando usa una variable. pero hay otras causas de afinidad. puede generarse porque un grupo de funciones realice una operación similar. fíjese en este fragmento de código de junit 4.3.1: public class assert { static public void asserttrue(string message, boolean condition) { 123if (!condition) fail(message); } static public void asserttrue(boolean condition) { asserttrue (null, condition); } static public void assertfalse(string message, boolean condition) { asserttrue(message, !condition); } static public void assertfalse(boolean condition) { assertfalse(null, condition); } … estas funciones tienen una elevada afinidad conceptual ya que comparten un sistema de nombres común y realizan variantes de la misma tarea básica. el hecho de que se invoquen unas a otras es secundario. aunque no lo hicieran, deberían seguir estando próximas entre ellas. orden vertical por lo general, las dependencias de invocaciones de funciones deben apuntar hacia abajo. es decir, la función invocada debe situarse por debajo de la que realice la invocación [27] . esto genera un agradable flujo en el código fuente, de los niveles superiores a los inferiores. como sucede en los artículos del periódico, esperamos que los conceptos más importantes aparezcan antes y que se expresen con la menor cantidad de detalles sobrantes. esperamos que los detalles de nivel inferior sean los últimos. de este modo, podemos ojear los archivos de código y captar el mensaje en las primeras funciones sin necesidad de sumergirnos en los detalles. el listado 5-5 se organiza de esta forma. puede que otros ejemplos mejores sean los listados 15-5 y 3-7. formato horizontal 124¿qué ancho debe tener una línea? para responderlo, fíjese en la anchura de las líneas de un programa convencional. de nuevo, examinamos siete proyectos diferentes. en la figura 5.2 puede ver la distribución de longitud de todos ellos. la regularidad es impresionante, en especial en tomo a los 45 caracteres. de hecho, los tamaños entre 20 y 60 representan un uno por cien del número total de líneas. ¡eso es un 40 por 100! puede que otro 30 por 100 sea menos de 10 caracteres de ancho. recuerde que es una escala de registro, de modo que la apariencia lineal es muy significativa. es evidente que los programadores prefieren líneas menos anchas. figura 5.2. distribución de anchura de líneas en java. esto sugiere que debemos intentar reducir las líneas de código. el antiguo límite hollerith de 80 es un tanto arbitrario y no me opongo a líneas que tienen 100 o incluso 120, pero no más. como norma, no debe tener que desplazarse hacia la derecha. los monitores modernos son más anchos y los programadores noveles pueden reducir la fuente para encajar hasta 200 caracteres en la pantalla. no lo haga. mi límite personal es de 120. apertura y densidad horizontal 125usamos el espacio en blanco horizontal para asociar elementos directamente relacionados y separar otros con una relación menos estrecha. fíjese en la siguiente función: private void measureline(string line) { linecount++; int linesize = line.length(); totalchars += linesize; linewidthhistogram.addline(linesize, linecount); recordwidestline(linesize); } hemos rodeado los operadores de asignación con espacios en blanco para destacarlos. las instrucciones de asignación tienen dos elementos principales: el lado izquierdo y el derecho. los espacios acentúan esta separación. por otra parte, no hemos incluido espacios entre los nombres de las funciones y el paréntesis de apertura, ya que la función y sus argumentos están estrechamente relacionados. su separación los desconectaría. separo los argumentos en los paréntesis de invocación de la función para acentuar la coma e indicar que los argumentos son independientes. el espacio en blanco también se usa para acentuar la precedencia de los operadores: public class quadratic { public static double root1(double a, double b, double c) { double determinant = determinant(a, b, c); return (-b + math.sqrt(determinant)) / (2*a); } public static double root2(int a, int b, int c) { double determinant = determinant(a, b, c); return (-b - math.sqrt(determinant)) / (2*a); } private static double determinant(double a, double b, double c) { return b*b - 4*a*c; } } fíjese en lo bien que se leen las ecuaciones. los factores carecen de espacios en blanco ya que tienen una mayor precedencia. los términos se separan mediante espacios en blanco ya que la suma y la resta son de precedencia inferior. desafortunadamente, muchas herramientas de formato de código ignoran la precedencia de los operadores e imponen un espaciado uniforme. por ello, separaciones sutiles como las anteriores suelen perderse tras modificar el 126formato del código. alineación horizontal cuando era programador de lenguajes de ensamblado [28] , usaba la alineación horizontal para acentuar determinadas estructuras. cuando comencé a programar en c, c++ y java, seguía intentando alinear los nombres de variables en un conjunto de declaraciones o todos los valores en un grupo de instrucciones de asignación. el aspecto de mi código era el siguiente: public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long requestprogress; private long requestparsingdeadline; private boolean haserror; public fitnesseexpediter( socket s, fitnessecontext context) throws exception { this.context = context; socket = s; input = s.getinputstream(); output = s.getoutputstream(); requestparsingtimelimit = 10000; } sin embargo, este tipo de alineación no es útil. parece enfatizar los elementos incorrectos y aleja la vista de la verdadera intención. por ejemplo, en la lista anterior de declaraciones, nos vemos tentados a leer la lista de nombres de variables sin fijarnos en sus tipos. del mismo modo, en la lista de instrucciones de asignación, nos fijamos en los valores sin ver el operador. para empeorarlo todo, las herramientas automáticas de formato suelen eliminar este tipo de alineación. por tanto, al final, ya no lo uso. ahora prefiero declaraciones y asignaciones sin alinear, como se muestra a 127continuación, ya que resaltan una deficiencia importante. si tengo listas extensas que deben alinearse, el problema es la longitud de las listas, no la falta de alineación. la longitud de la siguiente lista de declaraciones de fitnesseexpediter sugiere que esta clase debe dividirse. public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long request progress; private long requestparsingdeadline; private boolean haserror; public fitnesseexpediter(socket s, fitnessecontext context) throws exception { this.context = context; socket = s; input = s.getinputstream(); output = s.getoutputstream(); requestparsingtimelimit = 10000; } sangrado un archivo de código es una jerarquía más que un contorno. incluye información que pertenece a la totalidad del archivo, a sus clases individuales, a los métodos de las clases, a los bloques de los métodos y a los bloques de los bloques. cada nivel de esta jerarquía es un ámbito en el que se pueden declarar nombres y en el que se interpretan declaraciones e instrucciones ejecutables. para que esta jerarquía de ámbitos sea visible, sangramos las líneas de código fuente de acuerdo a su posición en la jerarquía. las instrucciones al nivel del archivo, como las declaraciones de clases, no se sangran. los métodos de una clase se sangran un nivel a la derecha de la clase. las implementaciones de dichos métodos se implementan un nivel a la derecha de la declaración de los métodos. las implementaciones de bloques se 128implementan un nivel a la derecha de su bloque contenedor y así sucesivamente. los programadores dependen de este sistema de sangrado. alinean visualmente las líneas a la izquierda para ver el ámbito al que pertenece. de este modo pueden acceder rápidamente a los ámbitos, como por ejemplo a implementaciones de instrucciones if o while , que no son relevantes para la situación actual. buscan en la izquierda nuevas declaraciones de métodos, variables e incluso clases. sin el sangrado, los programas serian prácticamente ilegibles. fíjese en los siguientes programas, sintáctica y semánticamente idénticos: public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket s) { serve(s, 10000); } public void serve(socket s, long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(s, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch(exception e) { e.printstacktrace(); } } } public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket s) { serve (s, 10000); } public void serve(socket s, long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(s, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch (exception e) { e.printstacktrace(); } } } a la vista puede incluso apreciar la estructura del archivo sangrado. detectamos inmediatamente las variables, constructores y métodos de acceso. en cuestión de segundos vemos que es una especie de interfaz de conexión, 129con un tiempo de espera. la versión sin sangrar, por su parte, es prácticamente impenetrable. romper el sangrado en ocasiones tenemos la tentación de romper la regla de sangrado con instrucciones if breves, bucles while breves o funciones breves. siempre que he sucumbido a esta tentación, he acabado por volver a aplicar el sangrado. por ello, evito replegar ámbitos a una línea, como en este ejemplo: public class commentwidget extends textwidget { public static final string regexp = “^#[^\r\n]*(?:(?:\r\n)|\n|\r)?”; public commentwidget(parentwidget parent, string text){super (parent, text);} public string render() throws exception { return “”; } } prefiero desplegar y sangrar los ámbitos: public class commentwidget extends textwidget { public static final string regexp = “^#[^\r\n]*(?:(?:\r\n)|\n|\r)?”; public commentwidget(parentwidget parent, string text) { super(parent, text); } public string render() throws exception { return “”; } } ámbitos ficticios en ocasiones, el cuerpo de una instrucción while o for es ficticio, como se muestra a continuación. no me gustan estas estructuras y prefiero evitarlas. en caso de no poder hacerlo, me aseguro de sangrar el cuerpo ficticio y de incluirlo entre paréntesis. no sabría decir cuántas veces me ha engañado un punto y coma situado al final de un bucle while en la misma línea. a menos que lo haga visible y lo sangre en una línea propia, es difícil de ver. while (dis.read(buf, 0, readbuffersize) != -1) ; 130reglas de equipo todo programador tiene sus reglas de formato preferidas, pero si forma parte de un equipo, el equipo manda. un equipo de programadores debe acordar un único estilo de formato y todos los integrantes del equipo deben aplicarlo. el objetivo es que el software tenga un estilo coherente. no queremos que parezca escrito por individuos enfrentados. cuando comencé el proyecto fitnesse en 2002, me reuní con el equipo para definir un estilo de código. tardamos 10 minutos. decidimos dónde añadir las llaves, qué tamaño de sangrado utilizar, los nombres de clases, variables y métodos, y demás. tras ello, codificamos las reglas en el ide y las cumplimos desde entonces. no son las reglas que prefiero, son las que el equipo decidió. y como miembro de ese equipo, las apliqué cuando creamos el código del proyecto fitnesse. recuerde que un buen sistema de software se compone de una serie de documentos que se leen fácilmente. deben tener un estilo coherente y dinámico. el lector debe confiar en que los formatos que ve en nuestro archivo de código significarán lo mismo para otros. lo último que queremos es aumentar la complejidad del código creando una mezcla de estilos diferentes. reglas de formato de uncle bob las reglas que uso personalmente son sencillas y se ilustran en el código del listado 5-6. considérelo un ejemplo de documento estándar de código óptimo. listado 5-6 131codeanalyzer.java. public class codeanalyzer implements javafileanalysis { private int linecount; private int maxlinewidth; private int widestlinenumber; private linewidthhistogram linewidthhistogram; private int totalchars; public codeanalyzer() { linewidthhistogram = new linewidthhistogram(); } public static list<file> findjavafiles(file parentdirectory) { list<file> files = new arraylist<file>(); findjavafiles(parentdirectory, files); return files; } private static void findjavafiles(file parentdirectory, list<file> files) { for (file file : parentdirectory.listfiles()) { if (file.getname().endswith(“.java”)) files.add(file); else if (file.isdirectory()) findjavafiles(file, files); } } public void analyzefile(file javafile) throws exception { bufferedreader br = new bufferedreader(new filereader(javafile)); string line; while ((line = br.readline()) != null) measureline(line); } private void measureline(string line) { linecount++; int linesize = line.length(); totalchars += linesize; linewidthhistogram.addline(linesize, linecount); recordwidestline(linesize); } private void recordwidestline(int linesize) { if (linesize > maxlinewidth) { maxlinewidth = linesize; widestlinenumber = linecount; } } public int getlinecount() { return linecount; } 132public int getmaxlinewidth() { return maxlinewidth; } public int getwidestlinenumber() { return widestlinenumber; } public linewidthhistogram getlinewidthhistogram() { return linewidthhistogram; } public double getmeanlinewidth() { return (double)totalchars/linecount; } public int getmedianlinewidth() { integer[] sortedwidths = getsortedwidths(); int cumulativelinecount = 0; for (int width : sortedwidths) { cumulativelinecount += linecountforwidth(width); if (cumulativelinecount > linecount/2) return width; } throw new error (“cannot get here”); } private int linecountforwidth(int width) { return linewidthhistogram.getlinesforwidth(width).size(); } private integer[] getsortedwidths() { set<integer> widths = linewidthhistogram.getwidths(); integer[] sortedwidths = (widths.toarray(new integer[0])); arrays.sort(sortedwidths); return sortedwidths; } } 1336 objetos y estructuras de datos 134hay una razón para que las variables sean privadas. no queremos que nadie más dependa de ellas. queremos poder cambiar su tipo o implementación cuando deseemos. entonces, ¿por qué tantos programadores añaden automáticamente métodos de establecimiento y recuperación que muestran sus variables privadas como si fueran públicas? abstracción de datos fíjese en la diferencia entre los listados 6-1 y 6-2. ambos representan los datos de un punto cartesiano, pero uno muestra su implementación y otro la oculta totalmente. listado 6-1 punto concreto. public class point { public double x; public double y; } listado 6-2 punto abstracto. public interface point { double getx(); double gety(); void setcartesian(double x, double y); double getr(); double gettheta(); void set polar(double r, double theta); } lo mejor del listado 6-2 es que no hay forma de saber si la implementación está en coordenadas rectangulares o polares. ¡puede que en ninguna! y aun así la interfaz representa sin lugar a dudas una estructura de datos. pero representa algo más que una estructura de datos. los métodos refuerzan una política de acceso. puede leer las coordenadas de forma 135independiente, pero debe establecerlas de forma conjunta como operación atómica. el listado 6-1, por su parte, se implementa claramente en coordenadas rectangulares y nos obliga a manipularlas de forma independiente, lo que muestra la implementación. de hecho, la mostraría igualmente, aunque las variables fueran privadas y usáramos métodos variables de establecimiento y recuperación. para ocultar la implementación no basta con añadir una capa de funciones entre las variables. se basa en la abstracción. una clase no fuerza sus variables a través de métodos de establecimiento y recuperación. por el contrario, muestra interfaces abstractas que permiten a sus usuarios manipular la esencia de los datos sin necesidad de conocer su implementación. fíjese en los listados 6-3 y 6-4. el primero usa términos concretos para indicar el nivel de combustible de un vehículo mientras que el segundo lo hace con la abstracción del porcentaje. en el caso concreto, podemos estar seguros de que se trata de métodos de acceso de variables. en el caso abstracto, desconocemos la forma de los datos. listado 6-3 vehículo concreto. public interface vehicle { double getfueltankcapacityingallons(); double getgallonsofgasoline(); } listado 6-4 vehículo abstracto. public interface vehicle { double getpercentfuelremaining(); } en ambos casos, la segunda opción es preferible. no queremos mostrar los detalles de los datos, sino expresarlos en términos abstractos. esto no se consigue simplemente mediante interfaces o métodos de establecimiento y recuperación. hay que meditar seriamente la forma óptima de representar los datos que contiene un objeto. la peor opción es añadir métodos de 136establecimiento y recuperación a ciegas. antisimetría de datos y objetos estos dos ejemplos ilustran la diferencia entre objetos y estructuras de datos. los objetos ocultan sus datos tras abstracciones y muestran funciones que operan en dichos datos. la estructura de datos muestra sus datos y carece de funciones con significado. vuelva a leerlos. fíjese en la naturaleza complementaria de las dos definiciones. son virtualmente opuestas. puede parecer una diferencia menor, pero tiene importantes implicaciones. fíjese en el ejemplo del listado 6-5. la clase geometry opera en las tres clases de formas, que son sencillas estructuras de datos sin comportamiento. todo el comportamiento se encuentra en la clase geometry. listado 6-5 forma mediante procedimientos. public class square { public point topleft; public double side; } public class rectangle { public point topleft; public double height; public double width; } public class circle { public point center; public double radius; } public class geometry { public final double pi = 3.141592653589793; public double area(object shape) throws nosuchshapeexception { if (shape instanceof square) { square s = (square)shape; return s.side * s.side; } else if (shape instanceof rectangle) { 137rectangle r = (rectangle)shape; return r.height * r.width; } else if (shape instanceof circle) { circle c = (circle)shape; return pi * c.radius * c.radius; } throw new nosuchshapeexception(); } } los programadores orientados a objetos se quejarán de que es un ejemplo de procedimiento, y tienen razón. imagine qué pasaría si añadimos la función perimeter() a geometry . ¡las clases de formas no se verían afectadas! ¡y las demás clases que dependieran de las formas tampoco! por otra parte, si añado una nueva forma, tendría que cambiar todas las funciones de geometry . vuélvalo a leer. comprobará que las dos condiciones son diametralmente opuestas. fíjese ahora en la solución orientada a objetos del listado 6-6. aquí, el método area() es polimórfico. no se necesita una clase geometry . por tanto, si añado una nueva forma, ninguna de las funciones existentes se ven afectadas, pero si añado otra función, habrá que cambiar todas las formas [29] . listado 6-6 formas polimórficas. public class square implements shape { private point topleft; private double side; public double area() { return side*side; } public class rectangle implements shape { private point topleft; private double height; private double width; public double area() { return height * width; } } public class circle implements shape { private point center; 138private double radius; public final double pi = 3.141592653589793; public double area() { return pi * radius * radius; } } de nuevo, vemos la naturaleza complementaria de estas dos definiciones; totalmente contrarias. esto ilustra la dicotomía fundamental entre objetos y estructuras de datos: el código por procedimientos (el que usa estructuras de datos) facilita la inclusión de nuevas funciones sin modificar las estructuras de datos existentes. el código orientado a objetos, por su parte, facilita la inclusión de nuevas clases sin cambiar las funciones existentes. el complemento también es cierto: el código por procedimientos dificulta la inclusión de nuevas estructuras de datos ya que es necesario cambiar todas las funciones. el código orientado a objetos dificulta la inclusión de nuevas funciones ya que es necesario cambiar todas las clases. por tanto, lo que es difícil para la programación orientada a objetos es fácil para los procedimientos, y viceversa. en cualquier sistema complejo habrá ocasiones en las que queramos añadir nuevos tipos de datos en lugar de nuevas funciones. en dichos casos, los objetos y la programación orientada a objetos es lo más adecuado. por otra parte, en ocasiones tendremos que añadir nuevas funciones en lugar de tipos de datos, para lo que resulta más adecuado usar código por procedimientos y estructuras de datos. los programadores experimentados saben que la idea de que todo es un objeto es un mito. en ocasiones solamente queremos sencillas estructuras de datos con procedimientos que operen en las mismas. 139la ley de demeter existe una conocida heurística denominada ley de demeter [30] que afirma que un módulo no debe conocer los entresijos de los objetos que manipula. como vimos en el apartado anterior, los objetos ocultan sus datos y muestran operaciones, lo que significa que un objeto no debe mostrar su estructura interna a través de métodos de acceso ya que, si lo hace, mostraría, no ocultaría, su estructura interna. en concreto, la ley de demeter afirma que un método de una clase c sólo debe invocar los métodos de: c . un objeto creado por f . un objeto pasado como argumento a f . un objeto en una variable de instancia de c . el método no debe invocar métodos de objetos devueltos por ninguna de las funciones permitidas. es decir, no hable con desconocidos, sólo con amigos. el siguiente código [31] parece incumplir la ley de demeter (entre otras cosas) ya que invoca la función getscratchdir() en el valor devuelto de getoptions() y después invoca getabsolutepath() en el valor devuelto de getscratchdir() . final string outputdir = ctxt.getoptions().getscratchdir().getabsolutepath(); choque de trenes ese tipo de código suele denominarse choque de trenes ya que se asemeja a un grupo de vagones de tren. estas cadenas de invocaciones suelen considerarse un estilo descuidado y deben evitarse [g36]. conviene dividirlas de esta forma: options opts = ctxt.getoptions(); file scratchdir = opts.getscratchdir(); 140final string outputdir = scratchdir.getabsolutepath(); ¿incumplen estos dos fragmentos de código la ley de demeter? sin duda el módulo contenedor sabe que el objeto ctxt contiene opciones, que contienen un directorio scratch , que tiene una ruta absoluta. la función sabe demasiado. la función que realiza la invocación sabe cómo desplazarse por numerosos objetos diferentes. si incumple o no la ley de demeter depende de si ctxt , options y scratchdir son objetos o estructuras de datos. si son objetos, debería ocultarse su estructura interna, no mostrarse, y conocer sus detalles internos sería un claro incumplimiento de la ley de demeter. por otra parte, si ctxt , options y scratchdir son simples estructuras de datos, mostrarán su estructura interna con naturalidad y la ley de demeter no se aplica. el uso de funciones de acceso complica el problema. si el código se hubiera escrito de esta otra forma, probablemente no nos preocuparíamos de si se incumple la ley de demeter o no. final string outputdir = ctxt.options.scratchdir.absolutepath; el problema sería menos confuso si las estructuras de datos tuvieran variables públicas y no funciones, y los objetos tuvieran variables privadas y funciones públicas. sin embargo, existen estructuras y estándares (como los bean ) que exigen que incluso una sencilla estructura de datos tenga elementos de acceso y mutación. híbridos esta confusión genera ocasionalmente desafortunadas estructuras híbridas mitad objeto y mitad estructura de datos. tienen funciones que realizan tareas significativas y también variables públicas o método públicos de acceso y mutación que hacen que las variables privadas sean públicas, y tientan a otras funciones externas a usar dichas variables de la misma forma que un programa por procedimientos usaría una estructura de datos [32] . estos 141híbridos dificultan la inclusión de nuevas funciones y también de nuevas estructuras de datos. son lo peor de ambos mundos. evítelos. indican un diseño descuidado cuyos autores dudan, o peor todavía, desconocen, si necesitan protegerse de funciones o tipos. ocultar la estructura ¿qué pasaría si ctxt , options y scratchdir fueran objetos con un comportamiento real? como los objetos deben ocultar su estructura interna, no podríamos desplazarnos por los mismos. entonces, ¿cómo obtendríamos la ruta absoluta del directorio scratch ? ctxt.getabsolutepathofscratchdirectoryoption(); o ctxt.getscratchdirectoryoption().getabsolutepath() la primera opción provocaría una explosión de métodos en el objeto ctxt . la segunda asume que getscratchdirectoryoption() devuelve una estructura de datos, no un objeto. ninguna de las opciones parece correcta. si ctxt es un objeto, deberíamos indicarle que hiciera algo, no preguntar sobre sus detalles internos. entonces, ¿para qué queremos la ruta absoluta del directorio scratch ? ¿cómo vamos a usarla? fíjese en este código del mismo módulo (muchas líneas después): string outfile = outputdir + “/” + classname.replace(‘.’, ‘/’) + “.class”; fileoutputstream fout = new fileoutputstream(outfile); bufferedoutputstream bos = new bufferedoutputstream(fout); la mezcla de distintos niveles de detalle [g34][g6] es preocupante. puntos, guiones, extensiones de archivo y objetos file no deben mezclarse de esta forma, junto al código contenedor. si lo ignoramos, vemos que la intención de obtener la ruta absoluta del directorio scratch es crear un archivo de borrador de un nombre concreto. ¿y si le dijéramos al objeto ctxt que hiciera esto? bufferedoutputstream bos = ctxt.createscratchfilestream(classfilename); parece algo razonable para un objeto. permite a ctxt ocultar sus detalles internos e impide que la función actual incumpla la ley de demeter y se 142desplace por objetos que no debería conocer. objetos de transferencia de datos la quintaesencia de una estructura de datos es una clase con variables públicas y sin funciones. en ocasiones se denomina objeto de transferencia de datos ( data transfer object u otd). los otd son estructuras muy útiles, en especial para comunicarse con bases de datos o analizar mensajes de conexiones, etc. suelen ser los primeros de una serie de fases de traducción que convierten datos sin procesar en objetos en el código de la aplicación. más común es la forma de bean mostrada en el listado 6-7. los bean tienen variables privadas manipuladas por métodos de establecimiento y recuperación. la cuasi-encapsulación de bean hace que algunos puristas de la programación orientada a objetos se sientan mejor pero no ofrece ningún otro beneficio. listado 6-7 address.java public class address { private string street; private string streetextra; private string city; private string state; private string zip; public address(string street, string streetextra, string city, string state, string zip) { this.street = street; this.streetextra = streetextra; this.city = city; this.state = state; this.zip = zip; } public string getstreet() { return street; } public string getstreetextra() { return streetextra; } 143public string getcity() { return city; } public string getstate() { return getstate; } public string getzip() { return zip; } } registro activo los registros activos son una forma especial de otd. son estructuras de datos con variables públicas (o de acceso por bean) pero suelen tener métodos de navegación como save y find . por lo general, estos registros activos son traducciones directas de tablas de base de datos u otros orígenes de datos. desafortunadamente, muchos programadores intentan procesar estas estructuras de datos como si fueran objetos y les añaden métodos de reglas empresariales. es algo extraño ya que crea un híbrido entre una estructura de datos y un objeto. la solución, evidentemente, consiste en considerar al registro activo una estructura de datos y crear objetos independientes que contengan las reglas empresariales y que oculten sus datos internos (que probablemente sean instancias del propio registro activo). conclusión los objetos muestran comportamiento y ocultan datos. esto facilita la inclusión de nuevos tipos de objetos sin necesidad de cambiar los comportamientos existentes. también dificulta la inclusión de nuevos comportamientos en objetos existentes. las estructuras de datos muestran datos y carecen de comportamiento significativo. esto facilita la inclusión de nuevos comportamientos en las estructuras de datos existentes, pero dificulta la inclusión de nuevas estructuras de datos en funciones existentes. 144en un sistema, en ocasiones necesitaremos la flexibilidad de añadir nuevos tipos de datos, por lo que preferimos objetos para esa parte del sistema. en otros casos, querremos añadir nuevos comportamientos, para lo que preferimos tipos de datos y procedimientos en esa parte del sistema. los buenos programadores de software entienden estos problemas sin prejuicios y eligen el enfoque más adecuado para cada tarea concreta. bibliografía [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. 1457 procesar errores por michael feathers le parecerá extraño encontrar una sección de control de errores en un libro sobre código limpio. el control de errores es algo que todos tenemos que hacer al programar. las entradas pueden ser incorrectas y los dispositivos pueden fallar, y cuando lo hacen, los programadores somos responsables de comprobar que el código hace lo que debe hacer. no obstante, la conexión con el código limpio debe ser evidente. muchas bases de código están totalmente dominadas por el control de errores. cuando digo que están dominadas, no quiero decir que únicamente realicen control de 146código, sino que es prácticamente imposible ver lo que el código hace debido a todo ese control de errores. el control de errores es importante, pero si oscurece la lógica, es incorrecto . en este capítulo detallaremos diversas técnicas y consideraciones que puede usar para crear código limpio y robusto, código que procese los errores con elegancia y estilo. usar excepciones en lugar de códigos devueltos en el pasado, muchos lenguajes carecían de excepciones. las técnicas para procesar e informar de errores eran limitadas. se definía un indicador de error o se devolvía un código de error que el invocador podía comprobar. el código del listado 7-1 ilustra estos enfoques. listado 7-1 devicecontroller.java. public class devicecontroller { … public void sendshutdown() { devicehandle handle = gethandle(dev1); // comprobar el estado del dispositivo if (handle != devicehandle.invalid) { // guardar el estado del dispositivo en el campo de registro retrievedevicerecord(handle); // si no está suspendido, cerrarlo if { record.getstatus() != device_suspended) { pausedevice(handle); cleardeviceworkqueue(handle); closedevice(handle); } else { logger.log(“device suspended. unable to shut down”); } } else { logger.log(“invalid handle for: ” + dev1.tostring()); } } … } el problema de estos enfoques es que confunden al invocador. el invocador debe comprobar inmediatamente los errores después de la 147invocación. desafortunadamente, es algo que se suele olvidar. por ello, es más recomendable generar una excepción al detectar un error. el código de invocación es más limpio. su lógica no se oscurece por el control de errores. el listado 7-2 muestra el código tras generar una excepción en los métodos que pueden detectar errores. listado 7-2 devicecontroller.java (con excepciones). public class devicecontroller { … public void sendshutdown() { try { trytoshutdown(); } catch (deviceshutdownerror e) { logger.log(e); } } private void trytoshutdown() throws deviceshutdownerror { devicehandle handle = gethandle(dev1); devicerecord record = retrievedevicerecord(handle); pausedevice(handle); cleardeviceworkqueue(handle); closedevice(handle); } private devicehandle gethandle(deviceid id) { … throw new deviceshutdownerror(“invalid handle for: ” - id.tostring()); … } … } comprobará que es mucho más limpio. no es cuestión de estética. el código es mejor porque se solventan dos preocupaciones: el algoritmo para apagar el dispositivo y el control de errores ahora se encuentran separados. puede ver cada uno de ellos y entenderlos de forma independiente. crear primero la instrucción try-catch-finally 148uno de los aspectos más interesantes de las excepciones es que definen un ámbito en el programa. al ejecutar código en la parte try de una instrucción try-catch-finally , indicamos que la ejecución se puede cancelar en cualquier momento y después retomar en catch . los bloques try son como las transacciones, catch debe salir del programa en un estado coherente, independientemente de lo que suceda en try . por este motivo, es aconsejable iniciar con una instrucción try-catch- finally el código que genere excepciones. de este modo define lo que debe esperar el usuario del código, independientemente de que se produzca un error en el código ejecutado en la cláusula try . veamos un ejemplo. imagine que tiene que crear un código que acceda a un archivo y lea objetos serializados. comenzamos con una prueba de unidad que muestra que obtendremos una excepción cuando el archivo no exista: @test(expected = storageexception.class) public void retrievesectionshouldthrowoninvalidfilename() { sectionstore.retrievesection(“invalid - file”); } la prueba nos lleva a crear lo siguiente: public list<recordedgrip> retrievesection(string sectionname) { // se devuelve un resultado ficticio hasta tener una implementación real return new arraylist<recordedgrip>(); } nuestra prueba falla ya que no genera una excepción. tras ello, cambiamos la implementación para que intente acceder a un archivo no válido. esta operación genera una excepción: public list<recordedgrip> retrievesection (string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname) } catch (exception e) { throw new storageexception(“retrieval error”, e); } return new arraylist<recordedgrip>(); } ahora la prueba es correcta ya que capturamos la excepción y ya podemos refactorizar. podemos reducir el tipo de la excepción capturada para que coincida con el tipo generado desde el constructor fileinputstream: 149filenotfoundexception : public list<recordedgrip> retrievesection(string sectionname) { try { fileinputstream stream = new fileinputstream(sectionname); stream.close(); } catch (filenotfoundexception e) { throw new storageexception(“retrieval error”, e); } return new arraylist<recordedgrip>(); } ahora que hemos definido el ámbito con una estructura try-catch , podemos usar tdd para diseñar el resto de la lógica necesaria. dicha lógica se añade entre la creación de fileinputstream y el cierre, y podemos pretender que no pasa nada incorrecto. intente crear pruebas que fuercen las excepciones, para después añadir al controlador un comportamiento que satisfaga dichas pruebas. de este modo primero creará el ámbito de transacción del bloque try y podrá mantener la naturaleza de transacción del ámbito. usar excepciones sin comprobar el debate ha terminado. durante años, los programadores de java han debatido las ventajas y los problemas de las excepciones comprobadas. cuando aparecieron en la primera versión de java, parecían una gran idea. la firma de todos los métodos enumeraría todas las excepciones que se podían pasar a su invocador. es más, estas excepciones formaban parte del tipo del método. el código no se compilaría si la firma no coincidía con lo que el código iba a hacer. en aquel momento, pensábamos que las excepciones comprobadas eran una gran idea y sí, ofrecían ciertas ventajas. sin embargo, ahora es evidente que no se necesitan para crear software robusto. c# carece de excepciones comprobadas y, a pesar de los intentos, c++ tampoco, como sucede en python o ruby. y en todos estos lenguajes se puede crear software robusto. por ello, debemos decidir si las excepciones comprobadas valen su precio. ¿qué precio? el precio de las excepciones comprobadas es un 150incumplimiento del principio abierto/cerrado [33] . si genera una excepción comprobada desde un método de su código y la cláusula catch se encuentra tres niveles por debajo, debe declarar dicha excepción en la firma de todos los métodos comprendidos entre su posición y catch . esto significa que un cambio en un nivel inferior del software puede forzar cambios de firma en muchos niveles superiores. será necesario volver a generar e implementar los módulos cambiados, aunque no cambien los elementos a los que hacen referencia. piense en la jerarquía de invocación de un sistema. las funciones de la parte superior invocan a las funciones situadas debajo, que invocan a otras funciones inferiores y así sucesivamente. imagine que una de las funciones de nivel inferior se modifica de forma que debe generar una excepción. si la excepción se comprueba, la firma de la función tendrá que añadir una cláusula throws . pero esto significa que todas las funciones que invoquen nuestra función modificada también tendrán que cambiarse para capturar la nueva excepción o para añadir la correspondiente cláusula throws en su firma. y así indefinidamente. el resultado final es una cascada de cambios que pasan desde los niveles inferiores del software hasta los superiores. la encapsulación se rompe ya que todas las funciones en la ruta de throw deben conocer detalles de la excepción de nivel inferior. como el cometido de las excepciones es permitimos procesar errores a distancia, es una lástima que las excepciones comprobadas rompan la encapsulación de esta forma. las excepciones comprobadas pueden ser útiles si tiene que crear una biblioteca crítica: tendrá que capturarlas. pero en el desarrollo de aplicaciones generales, los costes de dependencia superan las ventajas. ofrecer contexto junto a las excepciones las excepciones que genere deben proporcionar el contexto adecuado para determinar el origen y la ubicación de un error. en java, puede obtener un rastreo de pila de cualquier excepción; sin embargo, no le indicará el cometido de la función fallida. redacte mensajes de error informativos y páselos junto a sus 151excepciones. mencione la operación fallida y el tipo de fallo. si guarda registros en su aplicación, incluya información suficiente para poder registrar el error en la cláusula catch . definir clases de excepción de acuerdo a las necesidades del invocador existen varias formas de clasificar los errores. podemos hacerlo por origen (¿provienen de uno u otro componente?) o por tipo (¿son fallos del dispositivo, de la red o errores de programación?). sin embargo, al definir clases de excepción en una aplicación, debemos preocuparnos principalmente en cómo se capturan . veamos un pobre ejemplo de clasificación de excepciones. es una instrucción try-catch-finally de la invocación de una biblioteca de terceros. abarca todas las excepciones que las invocaciones pueden generar: acmeport port = new acmeport(12); try { port.open(); } catch (deviceresponseexception e) { reportporterror(e); logger.log{“device response exception”, e); } catch (atm1212unlockedexception e) { reportporterror(e); logger.log(“unlock exception”, e); } catch (gmxerror e) { reportporterror(e); logger.log(“device response exception”); } finally { … } esta instrucción contiene elementos duplicados, algo que no debería sorprendernos. en muchos casos de control de excepciones, el trabajo que realizamos es relativamente estándar independientemente de la causa real. debemos registrar un error y asegurarnos de poder continuar. en este caso, como sabemos que el trabajo es el mismo independientemente de la excepción, podemos simplificar el código si incluimos la api invocada y nos aseguramos de que devuelve un tipo de 152excepción común: localport port = new localport(12); try { port.open(); } catch (portdevicefailure e) { reporterror(e); logger.log(e.getmessage(), e); } finally { … } nuestra clase localport es un simple envoltorio que captura y traduce excepciones generadas por la clase acmeport : public class localport { private acmeport innerport; public localport(int portnumber) { innerport = new acmeport(portnumber); } public void open() { try { innerport.open(); } catch (deviceresponseexception e) { throw new portdevicefailure(e); } catch (atm1212unlockedexception e) { throw new portdevicefailure(e); } catch (gmxerror e) { throw new portdevicefailure(e); } } … } los envoltorios como el definido para acmeport pueden ser muy útiles. de hecho, es recomendable envolver api de terceros. al hacerlo, se minimizan las dependencias: puede cambiar a otra biblioteca diferente sin apenas problemas y el envoltorio también facilita imitar invocaciones de terceros cuando se prueba el código. una última ventaja es que no estamos limitados a las decisiones de diseño de api de un determinado fabricante. puede definir una api que le resulte cómoda. en el ejemplo anterior, definimos un único tipo de excepción para el fallo de puertos y podemos escribir un código mucho más limpio. a menudo, una única clase de excepción es suficiente para una zona concreta del código. la información enviada con la excepción puede distinguir los errores. use clases diferentes 153sólo para capturar una excepción y permitir el paso de otra distinta. definir el flujo normal si sigue los consejos de apartados anteriores, realizará una importante separación entre la lógica empresarial y el control de errores. la mayoría de su código parecerá un algoritmo limpio y sin adornos. sin embargo, el proceso desplaza la detección de errores hacia los bordes del programa. debe envolver api externas para poder generar sus propias excepciones y definir un controlador por encima del código para poder procesar cálculos cancelados. en muchos casos es el enfoque más acertado, pero en ocasiones conviene no cancelar. veamos un ejemplo, un código extraño que suma gastos en una aplicación de facturación: try { mealexpenses expenses = expensereportdao.getmeals(employee.getid()); m_total += expenses.gettotal(); } catch(mealexpensesnotfound e) { m_total += getmealperdiem(); } en esta empresa, si las comidas son gastos, pasan a formar parte del total. si no lo son, los trabajadores reciben una cantidad diaria para la comida. la excepción entorpece la lógica. sería más adecuado no tener que procesar el caso especial y el código sería mucho más sencillo: mealexpenses expenses = expensereportdao.getmeals(employee.getid()); m_total += expenses.gettotal(); ¿de verdad que el código puede ser tan simple? pues sí. podemos cambiar expensereportdao para que siempre devuelva un objeto mealexpense . si no hay gastos de comida, devuelve un objeto mealexpense que devuelve la dieta diaria como total: public class perdiemmealexpenses implements mealexpenses { public int gettotal() { // devolver la dieta diaria predeterminada 154} } es lo que se denomina patrón de caso especial [fowler]. se crea una clase o se configura un objeto que procese un caso especial. al hacerlo, el código cliente no tiene que procesar comportamientos excepcionales. dichos comportamientos se encapsulan en un objeto de caso especial. no devolver null creo que toda descripción del control de errores debe mencionar los elementos proclives a errores. el primero es devolver null. he perdido la cuenta de la cantidad de aplicaciones en que las que línea sí y línea también se comprueba null: public void registeritem(item item) { if (item != null) { itemregistry registry = peristentstore.getitemregistry(); if (registry != null) { item existing = registry.getitem(item.getid()); if (existing.getbillingperiod().hasretailowner()) { existing.register(item); } } } } si trabaja en una base de código como ésta, puede que no le parezca tan mala, pero lo es. al devolver null , básicamente nos creamos trabajo y generamos problemas para los invocadores. basta con que falte una comprobación de null para que la aplicación pierda el control. ¿se ha fijado en que no hay una comprobación de null en la segunda línea de la instrucción if anidada? ¿qué sucedería en tiempo de ejecución si persistentstore fuera null ? se generaría nullpointerexception en tiempo de ejecución y se capturaría nullpointerexception en el nivel superior o no. en ambos casos es incorrecto. ¿qué debería hace como respuesta a la generación de nullpointerexception desde el interior de su aplicación? se puede afirmar que el problema de este código es la ausencia de una comprobación de null pero en realidad el problema es su exceso. si 155siente la tentación de devolver null desde un método, pruebe a generar una excepción o a devolver un objeto de caso especial. si invoca un método que devuelva null desde una api de terceros, envuélvalo en un método que genere una excepción o devuelva un objeto de caso especial. en muchos casos, los objetos de caso especial son un remedio sencillo. imagine que tiene el siguiente código: list<employee> employees = getemployees(); if (employees != null) { for(employee e : employees) { totalpay += e.getpay(); } } ahora, getemployees puede devolver null , ¿pero es necesario? si cambiamos getemployee para que devuelva una lista vacía, podremos limpiar el código: list<employee> employees = getemployees(); for(employee e : employees) { totalpay += e.getpay(); } afortunadamente, java dispone de collections.emptylist() y devuelve una lista inmutable predefinida que podemos usar para este cometido: public list<employee> getemployees() { if (… there are no employees …) return collections.emptylist(); } si usa este tipo de código, minimizará la presencia de nullpointerexception y su código será más limpio. no pasar null devolver null desde métodos es incorrecto, pero es peor pasar null a métodos. a menos que trabaje con una api que espere que pase null , debe evitarlo siempre que sea posible. veamos otro ejemplo, un sencillo método que calcula una métrica para dos puntos: public class metricscalculator 156{ public double xprojection(point p1, point p2) { return (p2.x – p1.x) * 1.5; } … } ¿qué sucede cuando alguien pasa null como argumento? calculator.xprojection(null, new point (12, 13)); se genera nullpointerexception , evidentemente. ¿cómo solucionarlo? podríamos crear un nuevo tipo de excepción y generarla: public class metricscalculator { public double xprojection(point p1, point p2) { if (p1==null || p2==null) { throw invalidargumentexception( “invalid argument for metricscalculator.xprojection”); } return (p2.x – p1.x) * 1.5; } } } ¿mejor? puede que sea mejor que una excepción de puntero nulo, pero recuerde que debe definir un controlador para invalidargumentexception . ¿qué debe hacer el controlador? ¿hay alguna forma correcta de hacerlo? existe otra alternativa, usar un grupo de afirmaciones: public class metricscalculator ( public double xprojection{point p1, point p2) { assert p1 != null : “p1 should not be null”; assert p2 != null : “p2 should not be null”; return (p2.x - pl.x) * 1.5; } } es documentación correcta pero no soluciona el problema. si alguien pasa null , seguirá produciéndose un error de tiempo de ejecución. en la mayoría de lenguajes de programación no hay una forma correcta de procesar un null pasado por accidente. como éste es el caso, el enfoque racional es impedir que se pase null de forma predeterminada. si lo hace, puede diseñar código sabiendo que null en una lista de argumentos indica un problema y los errores serán menores. 157conclusión el código limpio es legible pero también debe ser robusto. no son objetivos opuestos. podemos crear código limpio y robusto si consideramos el control de errores una preocupación diferente, algo que vemos de forma independiente desde nuestra lógica principal. si somos capaces de lograrlo, razonaremos de forma independiente y podemos aumentar la capacidad de mantenimiento de nuestro código. bibliografía [martin] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. 1588 límites por james grenning no es habitual que controlemos todo el software de nuestros sistemas. en ocasiones, adquirimos paquetes de terceros o usamos código abierto. en otros casos, dependemos de equipos de nuestra propia empresa para producir 159componentes o subsistemas que utilizamos. de algún modo debemos integrar este código externo con el nuestro. en este capítulo veremos prácticas y técnicas para definir con claridad los límites de nuestro software . utilizar código de terceros existe una tensión natural entre el proveedor de una interfaz y el usuario de la misma. los proveedores de paquetes y estructuras de terceros abogan por una capacidad de aplicación global para poder trabajar en diversos entornos y atraer a un público más amplio. los usuarios, por su parte, desean una interfaz centrada en sus necesidades concretas. esta tensión puede provocar problemas en los límites de nuestros sistemas. analicemos java.util.map como ejemplo. como puede apreciar en la siguiente lista. map tiene una amplia interfaz con numerosas prestaciones. esta potencia y flexibilidad es muy útil, pero también puede ser un problema. por ejemplo, nuestra aplicación puede generar un map y compartirlo. nuestra intención puede que sea que ninguno de los receptores del mapa borre sus elementos. pero en la parte superior de la lista encontramos el método clear() . cualquier usuario del mapa puede borrarlo. o puede que nuestra convención de diseño determine que sólo se puedan almacenar objetos concretos en el mapa, pero map no limita de forma fiable los tipos de objetos que admite. cualquier usuario puede añadir elementos de cualquier tipo a cualquier mapa. clear() void - map containskey (object key) boolean - map containsvalue (object value) boolean - map entryset() set - map equals(object o) boolean - map get(object key) object - map getclass() class<? extends object> - object hashcode() int - map isempty() boolean - map keyset() set - map notify() void - object 160notifyall() void - object put(object key, object value) object - map putall(map t) void - map remove(object key) object - map size() int - map tostring() string - object values() collection - map wait() void - object wait(long timeout) void - object wait(long timeout, int nanos) void - object figura 8.1. los métodos de map si nuestra aplicación necesita un mapa de sensor , comprobará que los sensores se definen de esta forma: map sensors = new hashmap(); tras ello, cuando otra parte del código necesite acceder a sensor, vemos este código: sensor s = (sensor)sensors.get(sensorid); no lo vemos una sola vez, sino repetidamente a lo largo del código. el cliente de este código es responsable de obtener un objeto de map y convertirlo al tipo correcto. funciona, pero no es código limpio. además, este código no cuenta su historia como debería. la legibilidad del código se podría mejorar mediante el uso de genéricos, como se indica a continuación: map<sensor> sensors = new hashmap<sensor>(); … sensor s = sensors.get(sensorid); sin embargo, esto no soluciona el problema de que map<sensor> ofrezca más prestaciones de las que necesitamos o deseamos. al pasar una instancia de map<sensor> en el sistema, significa que habrá muchos puntos que corregir si la interfaz de map cambia. seguramente piense que son cambios improbables, pero recuerde que se han producido al añadir compatibilidad con genéricos en java 5. sin duda hemos visto sistemas que impiden el uso de genéricos debido a la gran cantidad de cambios necesarios para compensar el uso liberal de map . una forma más limpia de usar map sería la siguiente. a ningún usuario 161sensor le importa si se usan genéricos o no. esa opción se ha convertido (y siempre debería serlo) en un detalle de implementación. public class sensors { private map sensors = new hashmap(); public sensor getbyid(string id) { return (sensor) sensors.get(id); } //corte } la interfaz en el límite (map) está oculta. ha conseguido evolucionar sin apenas impacto en el resto de la aplicación. el uso de genéricos ya no es un problema ya que la conversión y la administración de tipos se procesa dentro de la clase sensors . esta interfaz también se ha ajustado y limitado a las necesidades de la aplicación. genera código más fácil de entender y con menor probabilidad de errores. la clase sensors puede aplicar las reglas empresariales y de diseño. no sugerimos que se encapsulen de esta forma todos los usos de map, sino que no se pase map (ni otras interfaces en el límite) por el sistema. si usa una interfaz de límite como map , manténgala dentro de la clase o la familia de clases en la que se use. evite devolverla o aceptarla como argumento de api públicas. explorar y aprender límites el código de terceros nos permite obtener mayor funcionalidad en menos tiempo. ¿por dónde empezamos cuando queremos utilizar un paquete de terceros? nuestra labor no es probar el código, pero sí crear pruebas para el código de terceros que utilicemos. imagine que no es evidente cómo usar una biblioteca de terceros. podríamos perder uno o varios días en leer la documentación y decidir cómo usarla. tras ello, podríamos escribir el código para usar el código de terceros y comprobar si se comporta de la forma esperada. no deberíamos sorprendernos por tener que realizar extensas sesiones de depuración intentando localizar errores en nuestro código o en el suyo. 162aprender el código de terceros es complicado, y también integrarlo. hacer ambas cosas al mismo tiempo es el doble de complicado. necesitamos un enfoque diferente. en lugar de experimentar y probar el nuevo material en nuestro código de producción, podríamos crear pruebas que analicen nuestro entendimiento del código de terceros. jim newkirk las denomina pruebas de aprendizaje [34] . en las pruebas de aprendizaje, invocamos la api de terceros como supuestamente la usaríamos en nuestra aplicación. básicamente realizamos experimentos controlados para comprobar si la entendemos. las pruebas se centran en lo que queremos obtener de la api. aprender log4j imagine que desea usar el paquete de apache log4j en lugar de su propio dispositivo de registro personalizado. lo descarga y abre la página inicial de la documentación. sin una lectura exhaustiva, crea el primer caso de prueba con la esperanza de que escriba hello en la consola. @test public void testlogcreate() { logger logger = logger.getlogger(“mylogger”); logger.info(“hello”); } al ejecutarlo, el registrador genera un error que nos indica que necesitamos algo denominado appender . tras investigar, descubrimos que existe un elemento consoleappender . creamos consoleappender y comprobamos si hemos conseguido revelar los secretos del registro en la consola. @test public void testlogaddappender() { logger logger = logger.getlogger (“mylogger”); consoleappender appender = new consoleappender(); logger.addappender(appender); logger.info(“hello”); } en esta ocasión descubrimos que appender carece de flujo de salida, algo extraño, ya que parece lógico que lo tuviera. tras recurrir a google, 163probamos lo siguiente: @test public void testlogaddappender() { logger logger = logger.getlogger(“mylogger”); logger.removeallappenders(); logger.addappender(new consoleappender( new patternlayout(“%p %t %m%n”), consoleappender.system_out)); logger.info(“hello”); } funciona; en la consola aparece un mensaje con la palabra hello . resulta extraño tener que indicarle a consoleappender que escriba en la consola. al eliminar el argumento consoleappender.systemout , vemos que hello sigue impreso. pero al eliminar patternlayout , de nuevo vemos la queja de la falta de un flujo de salida. es un comportamiento muy extraño. si nos fijamos en la documentación, vemos que el constructor consoleappender predeterminado no está configurado, lo que no parece demasiado obvio ni útil. parece más bien un error o una incoherencia de log4j . tras nuevas búsquedas en google, investigaciones y pruebas, conseguimos el listado 8-1. hemos descubierto cómo funciona log4j y hemos codificado esos conocimientos en un grupo de sencillas pruebas de unidad. listado 8-1 logtest.java. public class logtest ( private logger logger; @before public void initialize() { logger = logger.getlogger(“logger”); logger.removeallappenders(); logger.getrootlogger().removeallappenders(); } @test public void basiclogger() { basicconfigurator.configure(); logger.info(“basiclogger”); } 164@test public void addappenderwithstream() { logger.addappender(new consoleappender( new patternlayout (“%p %t %m%n”), consoleappender.system_out)); logger.info(“addappenderwithstream”); } @test public void addappenderwithoutstream() { logger.addappender(new consoleappender( new patternlayout(“%p %t %m%n”))); logger.info(“addappenderwithoutstream”); } } ahora sabemos cómo inicializar un sencillo registrador de consola y encapsular ese conocimiento en nuestra propia clase de registro para que el resto de la aplicación se aísle de la interfaz de límite log4j . las pruebas de aprendizaje son algo más que gratuitas las pruebas de aprendizaje no cuestan nada. de todas formas, hemos tenido que aprender la api y crear las pruebas fue una forma sencilla y aislada de adquirir esos conocimientos. las pruebas de aprendizaje fueron experimentos precisos que permitieron aumentar nuestros conocimientos. las pruebas no sólo son gratuitas, sino también rentables. cuando aparezcan nuevas versiones del paquete de terceros, ejecutamos las pruebas de aprendizaje para comprobar si hay diferencias de comportamiento. las pruebas de aprendizaje demuestran que los paquetes de terceros que usamos funcionan de la forma esperada. una vez integrados, no hay garantía de que el código de terceros sea compatible con nuestras necesidades. los autores originales se verán presionados para cambiar el código y ajustarlo a sus propias necesidades. corregirán errores y añadirán nuevas funciones. en cada versión surgirán nuevos riesgos. si el paquete de terceros cambia de una forma incompatible con nuestras pruebas, lo sabremos al instante. independientemente de que necesite los conocimientos proporcionados por las pruebas de aprendizaje, un límite claro debe estar respaldado por un conjunto de pruebas que ejerciten la interfaz de la misma forma que hace el 165código de producción. sin estas pruebas de límites para facilitar la transición, podríamos conservar la versión antigua más tiempo del necesario. usar código que todavía no existe existe otro tipo de límite, que separa lo conocido de lo desconocido. en ocasiones, nuestro conocimiento del código parece desvanecerse. lo que hay al otro lado del límite es desconocido (al menos por el momento). en ocasiones, decidimos no mirar más allá del límite. hace años formé parte de un equipo de desarrollo de software para un sistema de comunicación por radio. había un subsistema, el transmisor, que apenas conocíamos y cuya interfaz todavía no se había diseñado. como no queríamos quedarnos parados, comenzamos a trabajar alejándonos de la parte desconocida del código. sabíamos perfectamente dónde acababa nuestro mundo y comenzaba el nuevo. mientras avanzábamos, en ocasiones nos topábamos con este límite. aunque la ignorancia ocultaba nuestra visión más allá del límite, sabíamos cómo queríamos que fuera la interfaz. queríamos decirle al transmisor algo como lo siguiente: ajustar el transmisor en la frecuencia proporcionada y emitir una representación analógica de los datos que provienen de este flujo. no sabíamos cómo hacerlo ya que todavía no se había diseñado la api. por ello decidimos determinar después los detalles. para no quedarnos bloqueados, definimos nuestra propia interfaz. le dimos un nombre sencillo, transmitter . le asignamos el método transmit que aceptaba una frecuencia y un flujo de datos. es la interfaz que deseábamos haber tenido. lo mejor de escribir la interfaz que deseábamos haber tenido era que la controlábamos. esto hace que el código cliente sea más legible y se ciña a los objetivos previstos. en la figura 8.1 se aprecia que aislamos las clases 166communicationscontroller de la api del transmisor (que no controlábamos y estaba por definir). al usar nuestra propia interfaz específica de la aplicación, el código de communicationscontroller era limpio y expresivo. una vez definida la api del transmisor, creamos transmitteradapter para reducir las distancias. el adaptador [35] encapsulaba la interacción con la api y ofrecía un único punto en el que evolucionaba. figura 8.1. predicción del transmisor este diseño también nos ofrece un sello [36] en el código para realizar pruebas. con un elemento faketransmitter , podemos probar las clases communicationscontroller . también podemos crear pruebas de límite una vez diseñada la api transmitter para asegurarnos de que la utilizamos correctamente. límites limpios en los límites suceden cosas interesantes. los cambios es una de ellas. los diseños de código correctos acomodan los cambios sin necesidad de grandes modificaciones. cuando usamos código que no controlamos, hay que prestar especial atención a proteger nuestra inversión y asegurarnos de que los cambios futuros no son demasiado costosos. el código en los límites requiere una separación evidente y pruebas que definan expectativas. debemos evitar que el código conozca los detalles de terceros. es más aconsejable depender de algo que controlemos que de algo que no controlemos, y menos todavía si nos controla. los límites de terceros se gestionan gracias a la presencia de 167puntos mínimos en el código que hagan referencia a los mismos. podemos envolverlos como hicimos con map o usar un adaptador para convertir nuestra interfaz perfecta en la interfaz proporcionada. en cualquier caso, el código se lee mejor, promueve el uso coherente e interno en el límite y hay menos puntos de mantenimiento cuando cambie el código de terceros. bibliografía [becktdd] : test driven development , kent beck, addison-wesley, 2003. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison wesley, 19%. [welc] : working effectively with legacy code , addison-wesley, 2004. 1689 pruebas de unidad nuestra profesión ha evolucionado mucho en los últimos 10 años. en 1997 nadie había oído hablar del desarrollo guiado por pruebas (dgp). para la mayoría, las pruebas de unidad eran pequeños fragmentos de código 169desechable que creábamos para asegurarnos de que nuestros programas funcionaban. escribíamos clases y métodos, y después código ad hoc para probarlos, lo que implicaba algún tipo de programa controlador que nos permitiera interactuar manualmente con el programa que habíamos escrito. recuerdo crear un programa de c++ para un sistema incrustado de tiempo real a mediados de la década de 1990. el programa era un sencillo temporizador con la siguiente firma: void timer::schedulecommand(command* thecommand, int milliseconds) la idea era sencilla; el método execute de command se ejecutaba en un nuevo subproceso tras el número especificado de milisegundos. el problema era cómo probarlo. confeccioné un sencillo programa controlador que escuchaba al teclado. cada vez que se introducía un carácter, se programaba un comando que escribía el mismo carácter cinco segundos después. introduje una rítmica melodía en el teclado y esperé a que se reprodujera en pantalla cinco segundos después: «i… want-a-girl… just… like-the-girl-who-marr… ied… dear… old… dad.» incluso tarareé la melodía mientras pulsaba la tecla, y la volví a cantar cuando aparecieron los puntos en la pantalla. ésa fue mi prueba. cuando vi que funcionaba y se lo mostré a mis compañeros, me deshice del código de prueba. como he afirmado, nuestra profesión ha evolucionado mucho. ahora crearía una prueba que garantizara el funcionamiento de hasta el más mínimo detalle del código. aislaría el código del sistema operativo en lugar de invocar las funciones estándar de temporización. las imitaría para tener control total sobre el tiempo. programaría comandos que definieran indicadores booleanos y avanzaría el tiempo, para observar los indicadores y asegurarme de que pasaran de false a true al cambiar el tiempo al valor correcto. cuando superara una serie de pruebas, comprobaría que fueran adecuadas para todo el que tuviera que trabajar con el código. me aseguraría de comprobar las pruebas y el código en el mismo paquete. sí, hemos 170avanzado mucho, pero nos queda mucho por avanzar. los movimientos agile y tdd han animado a muchos programadores a crear pruebas de unidad automatizadas y cada vez son más. pero en esta alocada carrera por añadir pruebas a nuestra disciplina, muchos programadores han pasado por alto dos de los aspectos más sutiles e importantes de diseñar pruebas de calidad. las tres leyes del dgp todos sabemos que el dgp nos pide que primero creemos las pruebas de unidad, antes que el código de producción. pero esa norma es sólo la punta del iceberg. tenga en cuenta las tres siguientes leyes [37] : primera ley : no debe crear código de producción hasta que haya creado una prueba de unidad que falle. segunda ley : no debe crear más de una prueba de unidad que baste como fallida, y no compilar se considera un fallo. tercera ley : no debe crear más código de producción que el necesario para superar la prueba de fallo actual. estas tres leyes generan un ciclo de unos 30 segundos de duración. las pruebas y el código de producción se crean de forma conjunta, las pruebas unos segundos antes que el código. si trabajamos de esta forma, crearemos decenas de pruebas al día, cientos al mes y miles al año. si trabajamos de esta forma, las pruebas abarcarán todos los aspectos de nuestro código de producción. el tamaño de dichas pruebas, que puede ser similar al del código de producción, puede suponer un problema de administración. realizar pruebas limpias hace unos años me pidieron que dirigiera un equipo que había decidido explícitamente que su código de prueba no debía mantenerse con los mismos estándares de calidad que su código de producción. podían incumplir las 171reglas en sus pruebas de unidad. la premisa era «rápido y directo». no era necesario que las variables tuvieran nombres adecuados, ni que las funciones de prueba fueran breves y descriptivas. no era necesario que el código de prueba estuviera bien diseñado. bastaba con que funcionara y abarcara el código de producción. puede que algunos lectores empaticen con esta decisión. puede que en el pasado creara el tipo de pruebas que cree para la clase timer . supone un gran paso crear ese tipo de pruebas desechables a diseñar una suite de pruebas de unidad automatizadas. por ello, como el equipo que dirigía, puede decidir que pruebas incorrectas sea mejor que no tener pruebas. pero el equipo no se daba cuenta que tener pruebas incorrectas era igual o peor que no tener prueba alguna. el problema es que las pruebas deben cambiar de acuerdo a la evolución del código. cuanto menos limpias sean, más difícil es cambiarlas. cuando más enrevesado sea el código de prueba, más probabilidades de que dedique más tiempo a añadir nuevas pruebas a la suite que el empleado en crear el nuevo código de producción. al modificar el código de producción, las pruebas antiguas comienzan a fallar y el desastre impide que las pruebas se superen, por lo que acaban por convertirse en un obstáculo interminable. entre versiones, aumentó el coste de mantener la suite de pruebas de mi equipo. acabó por convertirse en la principal queja entre los desarrolladores. cuando los directores preguntaron sobre este aumento, los desarrolladores culparon a las pruebas. al final, se vieron obligados a descartar la suite de pruebas completa. pero sin una suite de pruebas perdieron la posibilidad de garantizar el funcionamiento esperado de los cambios en el código. sin una suite de pruebas no podían asegurar que los cambios en una parte del sistema no afectaran a otras diferentes. los defectos aumentaron, lo que propició que temieran realizar cambios. dejaron de limpiar su código de producción por miedo a que los cambios fueran dañinos. el código de producción comenzó a corromperse. al final, se quedaron sin pruebas, con un código de producción enmarañado y defectuoso, clientes frustrados y la sensación de que su esfuerzo les había fallado. en cierto modo tenían razón. su esfuerzo les había fallado. pero fue su 172decisión de permitir que las pruebas fueran incorrectas lo que provocó el fallo. si hubieran empleado pruebas limpias, su esfuerzo no habría fallado. puedo afirmarlo con cierta seguridad porque he participado y dirigido muchos equipos que han tenido éxito gracias a pruebas de unidad limpias. la moraleja de la historia es sencilla: el código de prueba es tan importante como el de producción. no es un ciudadano de segunda. requiere concentración, diseño y cuidado. debe ser tan limpio como el código de producción. las pruebas propician posibilidades si sus pruebas no son limpias, las perderá. y sin ellas pierde lo mismo que hace que su código de producción sea flexible. sí, ha leído bien. las pruebas de unidad son las que hacen que el código sea flexible y se pueda mantener y reutilizar. la razón es sencilla. si tiene pruebas, no tendrá miedo a realizar cambios en el código. sin pruebas, cada cambio es un posible error. independientemente de la flexibilidad de su arquitectura, de la división del diseño, sin pruebas tendrá miedo a realizar cambios por la posibilidad de añadir errores no detectados. pero con las pruebas ese miedo desaparece. cuanto mayor sea el alcance de sus pruebas, menos miedo tendrá. podrá modificar el código con total impunidad, aunque su arquitectura no sea la mejor y el diseño sea mediocre. podrá mejorar la arquitectura y el diseño sin miedo alguno. por tanto, disponer de una suite automatizada de pruebas de unidad que cubran el código de producción es la clave para mantener limpio el diseño y la arquitectura. las pruebas proporcionan las posibilidades, ya que permiten el cambio. si sus pruebas no son limpias, la capacidad de modificar el código se verá limitada y perderá la posibilidad de mejorar la estructura de dicho código. cuanto menos limpias sean las pruebas, menos lo será el código. en última instancia perderá las pruebas y el código se corromperá. pruebas limpias 173¿qué hace que una prueba sea limpia? tres elementos: legibilidad, legibilidad y legibilidad. la legibilidad es sin duda más importante en las pruebas de unidad que en el código de producción. ¿qué hace que una prueba sea legible? lo mismo que en el código: claridad, simplicidad y densidad de expresión. en una prueba debe decir mucho con el menor número de expresiones posible. fíjese en el código de fitnesse del listado 9-1. estas tres pruebas son difíciles de entender y sin duda se pueden mejorar. por un lado, hay mucho código duplicado [g5] en las invocaciones repetidas a addpage y assertsubstring . sobre todo, este código se carga con detalles que interfieren con la expresividad de la prueba. listado 9-1 serializedpagerespondertest.java. public void testgetpagehieratchyasxml() throws exception { crawler.addpage(root, pathparser.parse(“pageone”)); crawler.addpage(root, pathparser.parse(“pageone.childone”)); crawler.addpage(root, pathparser.parse(“pagetwo”)); request.setresource(“root”); request.addinput(“type”, “pages”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“<name>pageone</name>”, xml); assertsubstring(“<name>pagetwo</name>”, xml); assertsubstring(“<name>childone</name>”, xml); } public void testgetpagehieratchyasxmldoesntcontainsymboliclinks() throws exception { wikipage pageone = crawler.addpage(root, pathparser.parse(“pageone”)); crawler.addpage(root, pathparser.parse(“pageone.childone”)); crawler.addpage(root, pathparser.parse(“pagetwo”)); pagedata data = pageone.getdata(); wikipageproperties properties = data.getproperties(); 174wikipageproperty symlinks = properties.set(symbolicpage.property_name); symlinks.set(“sympage”, “pagetwo”); pageone.commit(data); request.setresource(“root”); request.addinput(“type”, “pages”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“<name>pageone</name>”, xml); assertsubstring(“<name>pagetwo</name>”, xml); assertsubstring(“<name>childone</name>”, xml); assertnotsubstring(“sympage”, xml); } public void testgetdataashtml() throws exception { crawler.addpage(root, pathparser.parse(“testpageone”), “test page”); request.setresource(“testpageone”); request.addinput(“type”, “data”); responder responder = new serializedpageresponder(); simpleresponse response = (simpleresponse) responder.makeresponse( new fitnessecontext(root), request); string xml = response.getcontent(); assertequals(“text/xml”, response.getcontenttype()); assertsubstring(“test page”, xml); assertsubstring(“<test”, xml); } fíjese en las invocaciones de pathparser . transforman cadenas en instancias de pagepath usadas por las arañas. esta transformación es totalmente irrelevante para la prueba y únicamente complica su cometido. los detalles circundantes a la creación del respondedor y la obtención y conversión de la respuesta también sobran. también la forma de crear la url de solicitud a partir de un recurso y un argumento (contribuí a crear este código, por lo que tengo todo el derecho a criticarlo). al final, el código no se ha diseñado de forma legible. el lector se ve rodeado de miles de detalles que debe comprender antes de que las pruebas tengan sentido. fíjese ahora en las pruebas mejoradas del listado 9-2. hacen exactamente lo mismo, pero se han refactorizado de forma más clara y 175descriptiva. listado 9-2 serializedpagerespondertest.java (refactorizado) public void testgetpagehierarchyasxml() throws exception { makepages(“pageone”, “pageone.childone”, “pagetwo”); submitrequest(“root”, “type:pages”); assertresponseisxml(); assertresponsecontains( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); } public void testsymboliclinksarenotinxmlpagehierarchy() throws exception { wikipage page = makepage(“pageone”); makepages(“pageone.childone”, “pagetwo”); addlinkto(page, “pagetwo”, “sympage”); submitrequest(“root”, “type:pages”); assertresponseisxml(); assertresponsecontains( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); assertresponsedoesnotcontain(“sympage”); } public void testgetdataasxml() throws exception { makepagewithcontent(“testpageone”, “test page”); submitrequest(“testpageone”, “type:data”); assertresponseisxml(); assertresponsecontains(“test page”, “<test”); } el patrón generar-operar-comprobar [38] es evidente en la estructura de las pruebas. cada una se divide claramente en tres partes. la primera crea los datos de prueba, la segunda opera en dichos datos y la tercera comprueba que la operación devuelva los resultados esperados. comprobará que se ha eliminado gran parte de los detalles molestos. las pruebas son concisas y sólo usan los tipos de datos y funciones que realmente necesitan. todo el que lea estas pruebas sabrá rápidamente para qué sirven y no se perderá entre detalles irrelevantes. 176lenguaje de pruebas específico del dominio las pruebas del listado 9-2 ilustran la creación de un lenguaje específico del dominio para sus pruebas. en lugar de usar las api que los programadores emplean para manipular el sistema, creamos una serie de funciones y utilidades que usan dichas api y que facilitan la escritura y la lectura de las pruebas. estas funciones y utilidades se convierten en una api especializada usada por las pruebas. son un lenguaje de pruebas que los programadores usan personalmente para crear sus pruebas y para ayudar a los que después las lean. esta api de pruebas no se diseña con antelación, sino que evoluciona con la refactorización continuada del código de prueba. al igual que refactorizamos el listado 9-1 en el listado 9-2, los programadores disciplinados refactorizan su código de prueba en versiones más sucintas y expresivas. un estándar dual en un sentido, el equipo que mencionamos antes tenía razón. el código de la api de pruebas tiene un conjunto de estándares de ingeniería diferentes al código de producción. también tiene que ser sencillo, sucinto y expresivo, pero no tan eficaz como el código de producción. después de todo, se ejecuta en un entorno de prueba, no de producción, y cada entorno tiene sus propias necesidades. fíjese en la prueba del listado 9-3. la creé como parte de un prototipo de sistema de control medioambiental. sin entrar en detalles, se aprecia que esta prueba comprueba que la alarma de baja temperatura, el calentador y el fuelle estén activados cuando la temperatura sea demasiado fría. listado 9-3 environmentcontrollertest.java @test public void turnonlotempalarmatthreashold() throws exception { hw.settemp(way_too_cold); 177controller.tic(); asserttrue(hw.heaterstate()); asserttrue(hw.blowerstate()); assertfalse(hw.coolerstate()); assertfalse(hw.hitempalarm()); asserttrue(hw.lotempalarm()); } aquí hay muchos detalles. por ejemplo, ¿para qué sirve la función tic ? de hecho, la ignoraría mientras leemos esta prueba. intente centrarse en saber si está de acuerdo en que el estado final del sistema tiene que ver con que la temperatura sea demasiado baja. al leer la prueba, la vista tiene que cambiar entre el nombre del estado comprobado y el sentido del estado comprobado. vemos heaterstate y después la vista salta a asserttrue . vemos coolerstate y nos fijamos en assertfalse . resulta tedioso y dificulta la lectura de la prueba. he conseguido mejorar la legibilidad de la prueba transformándola en el listado 9-4. listado 9-4 environmentcontrollertest.java (refactorizado) @test public void turnonlotempalarmatthreshold() throws exception { waytoocold(); assertequals(“hbchl”, hw.getstate()); } evidentemente, he ocultado el detalle de la función tic creando una función waytoocold . pero lo importante es la extraña cadena de assertequals . las mayúsculas significan activado y las minúsculas desactivado, y las letras siempre aparece en este orden: {heater, blower, cooler, hi-temp-alarm, lo-temp-alarm} . aunque prácticamente sea un incumplimiento de las reglas de asignación mental [39] , en este caso parece apropiado. una vez que conocemos el significado, la vista pasa por la cadena y podemos interpretar los resultados. la lectura de la prueba es casi un placer. fíjese en el listado 9-5 y compruebe con qué facilidad entiende las pruebas. 178listado 9-5 environmentcontrollertest.java (una selección mayor). @test public void turnoncoolerandbloweriftoohot() throws exception { toohot(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonheaterandbloweriftoocold() throws exception { toocold(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonhitempalarmatthreshold() throws exception { waytoohot(); assertequals(“hbchl”, hw.getstate()); } @test public void turnonlotempalarmatthreshold() throws exception { waytoocold(); assertequals(“hbchl”, hw.getstate()); } la función getstate se reproduce en el listado 9-6. no es un código muy eficaz. para que lo sea, deberíamos haber usado stringbuffer . listado 9-6 mockcontrolhardware.java. public string getstate() { string state = “”; state += heater ? “h” : “h”; state += blower ? “b” : “b”; state += cooler ? “c” : “c”; state += hitempalarm ? “h” : “h”; state += lotempalarm ? “l” : “l”; return state; } stringbuffer es poco atractivo. incluso en código de producción, intento evitarlo si el coste es mínimo, como podría suceder en el listado 9-6. pero esta aplicación es claramente un sistema incrustado en tiempo real y es probable que los recursos del equipo y la memoria estén limitados. sin 179embargo, el entorno de pruebas es improbable que lo esté. es la naturaleza del estándar dual. hay cosas que nunca haría en un entorno de producción totalmente válidas para un entorno de prueba. suelen ser problemas de memoria o eficacia de la cpu, pero nunca problemas de limpieza. una afirmación por prueba existe una escuela de pensamiento [40] que afirma que todas las funciones de prueba de una prueba junit sólo deben tener una instrucción de afirmación. puede parecer una regla draconiana pero la ventaja se aprecia en el listado 9- 5. las pruebas llegan a una misma conclusión, que se entiende de forma rápida y sencilla. ¿pero qué sucede con el listado 9-2? no parece razonable afirmar que el resultado es xml y que contiene determinadas subcadenas. sin embargo, podemos dividir la prueba en dos, cada una con una afirmación concreta, como se muestra en el listado 9-7. listado 9-7 serializedpagerespondertest.java (una sola afirmación). public void testgetpagehierarchyasxml() throws exception { givenpages(“pageone”, “pageone.childone”, “pagetwo”); whenrequestisissued(“root”, “type:pages”); thenresponseshouldbexml(); } public void testgetpagehierarchyhasrighttags() throws exception { givenpages(“pageone”, “pageone.childone”, “pagetwo”); whenrequestisissued(“root”, “type:pages”); thenresponseshouldcontain( “<name>pageone</name>”, “<name>pagetwo</name>”, “<name>childone</name>” ); } he cambiado los nombres de las funciones para usar la convención dado- cuando-entonces [41] . de este modo las pruebas son más fáciles de leer. desafortunadamente, al dividir las pruebas se genera código duplicado. 180podemos eliminar los duplicados por medio del patrón método de plantilla [42] e incluir las partes dado/cuando en la clase base, y las partes entonces en derivaciones diferentes. o podríamos crear una clase de prueba independiente e incluir las partes dado y cuando en la función @before y las partes entonces en cada función @test . pero parece un mecanismo excesivo para un problema tan menor. al final, opto por las afirmaciones múltiples del listado 9-2. considero que la regla de una sola afirmación es una directriz adecuada [43] . siempre intento crear un lenguaje de pruebas específico del dominio que la complemente, como en el listado 9-5, pero no rechazo incluir más de una afirmación en una prueba. creo que lo mejor que podemos decir es que el número de afirmaciones de una prueba debe ser mínimo. un solo concepto por prueba puede que una regla más indicada sea probar un único concepto en cada función de prueba. no queremos extensas funciones que prueben una cosa diferente tras otra, como sucede en el listado 9-8. esta prueba debería dividirse en tres diferentes que probaran tres cosas distintas. al combinarlas en la misma función se obliga al lector a determinar por qué cada sección se ubica en ese punto y qué prueba dicha sección. listado 9-8 /** * varias pruebas para el método addmonths(). */ public void testaddmonths() { serialdate d1 = serialdate.createinstance(31, 5, 2004); serialdate d2 = serialdate.addmonths(1, d1); assertequals(30, d2.getdayofmonth()); assertequals(6, d2.getmonth()); assertequals(2004, d2.getyyyy()); serialdate d3 = serialdate.addmonths(2, d1); assertequals(31, d3.getdayofmonth()); assertequals(7, d3.getmonth()); assertequals(2004, d3.getyyyy()); 181serialdate d4 = serialdate.addmonths(1, serialdate.addmonths(1, d1)); assertequals(30, d4.getdayofmonth()); assertequals(7, d4.getmonth()); assertequals(2004, d4.getyyyy()); } las tres funciones deberían ser las siguientes: dado el último día de un mes con 31 días (como mayo): 1 . cuando se añade un mes, si el último día de ese mes es el 30 (como en junio), entonces la fecha debe ser el día 30 de ese mes, no el 31. 2 . cuando se añaden dos meses a esa fecha, si el último mes tiene 31 días, entonces la fecha debe ser el día 31. dado el último día de un mes con 30 días (como junio): 1 . cuando se añade, si el último día de ese mes tiene 31 días, entonces la fecha debe ser el 30, no el 31. expresado de esta forma, se aprecia que existe una regla general entre las distintas pruebas. al incrementar el mes, la fecha no puede ser mayor que su último día. esto implica que al incrementar el mes en el 28 de febrero debe generarse el 28 de marzo. falta esa prueba y convendría que la escribiéramos. así pues, no son las múltiples afirmaciones del listado 9-8 las causantes del problema, sino el hecho de que se prueba más de un concepto. probablemente la regla óptima sea minimizar el número de activos por concepto y probar un solo concepto por función de prueba. f.i.r.s.t. [44] las pruebas limpias siguen otras cinco reglas, cuyas iniciales forman las siglas first en inglés: rapidez ( fast ): las reglas deben ser rápidas y ejecutarse de forma rápida. si lo hacen lentamente, no las ejecutará con frecuencia. al no hacerlo, no detectará los problemas con la suficiente antelación como para solucionarlos. no se sentirá con libertad para limpiar el código, que acabará corrompiéndose. 182independencia ( independent ): las pruebas no deben depender entre ellas. una prueba no debe establecer condiciones para la siguiente. debe poder ejecutar cada prueba de forma independiente y en el orden que desee. si las pruebas dependen unas de otras, la primera que falle provocará una sucesión de fallos, dificultará el diagnóstico y ocultará efectos posteriores. repetición ( repeatable ): las pruebas deben poder repetirse en cualquier entorno. debe poder ejecutarlas en el entorno de producción, en el de calidad y en su portátil de camino a casa en un tren sin red. si no puede repetir las pruebas en cualquier entorno, siempre tendrá una excusa de su fallo. también verá que no puede ejecutar las pruebas si el entorno no está disponible. validación automática ( self-validating ): las pruebas deben tener un resultado booleano: o aciertan o fallan. no debe tener que leer un extenso archivo de registro para saber si una prueba ha acertado, ni comparar manualmente dos archivos de texto distintos para ello. si las pruebas no se validan automáticamente, el fallo puede ser subjetivo y la ejecución de las pruebas puede requerir una extensa evaluación manual. puntualidad ( timely ): las pruebas deben crearse en el momento preciso: antes del código de producción que hace que acierten. si crea las pruebas después del código de producción, puede que resulte difícil probarlo. puede decidir qué parte del código de producción sea demasiado difícil de probar. no diseñe código de producción que no se pueda probar. conclusión apenas hemos abordado la superficie de este tema. de hecho, se podría crear un libro entero sobre pruebas limpias. las pruebas son tan importantes para la salud de un proyecto como el código de producción. puede que incluso más, ya que conservan y mejoran la flexibilidad, capacidad de mantenimiento y reutilización del código de producción. por ello, intente que sean limpias. trabaje para que resulten expresivas y concisas. invente api de prueba que actúen como lenguaje específico del dominio que le ayude a crear las pruebas. si deja que las pruebas se corrompan, sucederá lo mismo con el código de 183producción. mantenga limpias las pruebas. bibliografía [rspec] : rspec: behavior driven development for ruby programmers , aslak hellesay, david chelimsky, pragmatic bookshelf, 2008. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 18410 clases con jeff langr hasta ahora nos hemos centrado en escribir bien líneas y bloques de código. nos hemos adentrado en la correcta composición de las funciones y en su interrelación. pero a pesar de la atención dedicada a la expresividad de las instrucciones y las funciones, no tendremos código limpio hasta que nos fijemos en los niveles superiores de su organización. hablemos sobre clases. 185organización de clases de acuerdo a la convención estándar de java, una clase debe comenzar con una lista de variables. las constantes estáticas públicas, si existen, deben aparecer primero. tras ello, las variables estáticas privadas y después las variables de instancia privadas. no suele ser necesario usar variables públicas. las funciones públicas deben seguir a la lista de variables. incluimos las utilidades públicas invocadas por una función pública tras la propia función pública. este sistema cumple la regla descendente y permite que el programa se lea como un artículo de periódico. encapsulación queremos que nuestras variables y funciones de utilidad sean privadas, pero no es imprescindible. en ocasiones podemos proteger una variable o función de utilidad para que sea accesible para una prueba. las reglas mandan. si una regla del mismo paquete tiene que invocar una función o acceder a una variable, hacemos que tenga ámbito protected o de paquete. sin embargo, primero veremos una forma de mantener la privacidad. la relajación de la encapsulación siempre es un último resorte. las clases deben ser de tamaño reducido la primera regla de las clases es que deben ser de tamaño reducido. la segunda regla es que deben ser todavía más reducidas. no, no vamos a repetir el mismo texto en el capítulo sobre las funciones, pero como sucede con las funciones, el tamaño reducido es lo principal a la hora de diseñar una clase. y la pregunta inmediata es qué nivel de reducción. con las funciones medimos el tamaño contando líneas físicas. con las clases usamos otra medida distinta: las responsabilidades [45] . el listado 10-1 muestra una clase, superdashboard , que muestra 70 186métodos públicos. muchos programadores estarán de acuerdo en que es un tamaño excesivo. algunos denominarían a superdashboard una clase dios. listado 10-1 demasiadas responsabilidades. public class superdashboard extends jframe implements metadatauser public string getcustomizerlanguagepath() public void setsystemconfigpath(string systemconfigpath) public string getsystemconfigdocument() public void setsystemconfigdocument(string systemconfigdocument) public boolean getgurustate() public boolean getnovicestate() public boolean getopensourcestate() public void showobject(metaobject object) public void showprogress(string s) public boolean ismetadatadirty() public void setismetadatadirty(boolean ismetadatadirty) public component getlastfocusedcomponent() public void setlastfocused(component lastfocused) public void setmouseselectstate(boolean ismouseselected) public boolean ismouseselected() public languagemanager getlanguagemanager() public project getproject() public project getfirstproject() public project getlastproject() public string getnewprojectname() public void setcomponentsizes(dimension dim) public string getcurrentdir() public void setcurrentdir(string newdir) public void updatestatus(int dotpos, int markpos) public class[] getdatabaseclasses() public metadatafeeder getmetadatafeeder() public void addproject(project project) public boolean setcurrentproject(project project) public boolean removeproject(project project) public metaprojectheader getprogrammetadata() public void resetdashboard() public project loadproject(string filename, string projectname) public void setcansavemetadata(boolean cansave) public metaobject getselectedobject() public void deselectobjects() public void setproject(project project) public void editoraction(string actionname, actionevent event) public void setmode(int mode) public filemanager getfilemanager() public void setfilemanager(filemanager filemanager) public configmanager getconfigmanager() public void setconfigmanager(configmanager configmanager) public classloader getclassloader() 187public void setclassloader(classloader classloader) public properties getprops() public string getuserhome() public string getbasedir() public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() public metaobject pasting( metaobject target, metaobject pasted, metaproject project) public void processmenuitems(metaobject metaobject) public void processmenuseparators(metaobject metaobject) public void processtabpages(metaobject metaobject) public void processplacement(metaobject object) public void processcreatelayout(metaobject object) public void updatedisplaylayer(metaobject object, int layerindex) public void propertyeditedrepaint(metaobject object) public void processdeleteobject(metaobject object) public boolean getattachedtodesigner() public void processprojectchangedstate(boolean hasprojectchanged) public void processobjectnamechanged(metaobject object) public void runproject() public void setallowdragging(boolean allowdragging) public boolean allowdragging() public boolean iscustomizing() public void settitle(string title) public idemenubar getidemenubar() public void showhelper(metaobject metaobject, string propertyname) //… y otros muchos métodos no públicos… } ¿y si superdashboard sólo incluyera los métodos mostrados en el listado 10-2? listado 10-2 ¿suficientemente reducido? public class superdashboard extends jframe implements metadatauser public component getlastfocusedcomponent() public void setlastfocused(component lastfocused) public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() } cinco métodos no es demasiado, ¿verdad? en este caso sí ya que a pesar del reducido número de métodos, superdashboard también tiene demasiadas responsabilidades. el nombre de una clase debe describir las responsabilidades que 188desempeña. de hecho, el nombre es la primera forma para determinar el tamaño de una clase. si no podemos derivar un nombre conciso para una clase, seguramente sea demasiado extenso. cuanto más ambiguo sea el nombre de la clase, más probabilidades hay de que tenga demasiadas responsabilidades. por ejemplo, los nombres de clase con palabras como processor , manager o super suelen indicar una desafortunada acumulación de responsabilidades. también debemos ser capaces de escribir una breve descripción de la clase en unas 25 palabras, sin usar las palabras « si », « o », « y » o « pero ». ¿cómo describiríamos superdashboard ?: superdashboard permite acceder al componente con el enfoque y nos permite controlar los números de versión y producto. el primer y indica que superdashboard tiene demasiadas responsabilidades. el principio de responsabilidad única el principio de responsabilidad única ( single responsibility principle , srp) [46] indica que una clase o módulo debe tener uno y sólo un motivo para cambiar. este principio nos indica la definición de responsabilidad y una directriz para el tamaño de la clase. las clases sólo deben tener una responsabilidad, un motivo para cambiar. la clase superdashboard aparentemente reducida del listado 10-2 tiene dos motivos para cambiar. primero, controla información de versión que supuestamente debe actualizarse cada vez que se comercialice el software . por otra parte, gestiona componentes de java swing (un derivado de jframe, la representación swing de una ventana de igu de nivel superior). sin duda, querremos cambiar el número de versión si cambiamos el código swing, pero lo contrario no es necesario: podríamos cambiar la información de versión en función de los cambios de otro código del sistema. la identificación de responsabilidades (los motivos del cambio) nos permite reconocer y mejorar las abstracciones en nuestro código. podemos extraer los tres métodos de superdashboard relacionados con la información de versiones en una clase independiente como version (véase el listado 10-3.) la clase version es una construcción 189que se puede reutilizar en otras aplicaciones. listado 10-3 una clase con una única responsabilidad. public class version { public int getmajorversionnumber() public int getminorversionnumber() public int getbuildnumber() } srp es uno de los conceptos más importantes del diseño orientado a objetos y también uno de los más sencillos de entender y cumplir, pero también es uno de los que más se abusa al diseñar clases. habitualmente nos encontramos clases que hacen demasiadas cosas. ¿por qué? crear software que funcione y crear software limpio son dos actividades diferentes. muchos tenemos un cerebro limitado, de modo que nos centramos en que el código funcione más que en su organización y limpieza. es algo totalmente válido. mantener objetivos separados es tan importante en nuestras actividades de programación como en nuestros programas. el problema es que muchos creemos que hemos terminado cuando el programa funciona. no cambiamos al otro objetivo de organización y limpieza. pasamos al siguiente problema en lugar de retroceder y dividir las clases en unidades independientes con una única responsabilidad. al mismo tiempo, muchos programadores temen que un elevado número de pequeñas clases con un único propósito dificulten la comprensión del conjunto. les preocupa que tengan que desplazarse entre las clases para determinar cómo funciona un aspecto concreto. sin embargo, un sistema con muchas clases reducidas no tiene más elementos móviles que un sistema con algunas clases enormes. en ambos hay que entender lo mismo. la pregunta es si quiere organizar sus herramientas en cajas con muchos pequeños cajones que contengan componentes bien definidos y etiquetados, o usar varios cajones grandes en los que mezcle todo. todos los sistemas tienen una gran lógica y complejidad. el objetivo principal para gestionar dicha complejidad es organizarla para que un programador sepa dónde buscar y comprenda la complejidad directamente afectada en cada momento concreto. por el contrario, un sistema con clases 190multipropósito de mayor tamaño nos obliga a buscar entre numerosos elementos que no siempre necesitamos conocer. para reformular los puntos anteriores, diremos que los sistemas deben estar formados por muchas claves reducidas, no por algunas de gran tamaño. cada clase reducida encapsula una única responsabilidad, tiene un solo motivo para cambiar y colabora con algunas otras para obtener los comportamientos deseados del sistema. cohesión las clases deben tener un número reducido de variables de instancia. los métodos de una clase deben manipular una o varias de dichas variables. por lo general, cuantas más variables manipule un método, más cohesión tendrá con su clase. una clase en la que cada variable se usa en cada método tiene una cohesión máxima. por lo general, no es recomendable ni posible crear este tipo de clases pero queremos que la cohesión de nuestras clases sea elevada. si lo logramos, significa que los métodos y variables de la clase dependen unos de otros y actúan como un todo lógico. fíjese en la implementación de stack en el listado 10-4. es una clase muy consistente. de los tres métodos, sólo size() no usa ambas variables. listado 10-4 stack.java, una clase consistente. public class stack { private int topofstack = 0; list<integer> elements = new linkedlist<integer>(); public int size() { return topofstack; } public void push(int element) { topofstack++; elements.add(element); } public int pop() throws poppedwhenempty { 191if (topofstack == 0) throw new poppedwhenempty(); int element = elements.get(--topofstack); elements.remove(topofstack); return element; } } la estrategia de reducir el tamaño de las funciones y de las listas de parámetros suele provocar la proliferación de variables de instancia usadas por un subconjunto de los métodos. si esto sucede, siempre existe al menos una clase que intenta huir de la clase de mayor tamaño. debe intentar separar las variables y métodos en dos o más clases para que las nuevas sean más consistentes. mantener resultados consistentes en muchas clases de tamaño reducido la división de grandes funciones en otras más pequeñas aumenta la proliferación de clases. imagine una gran función con numerosas variables declaradas. imagine que desea extraer una pequeña parte de esa función en otra independiente. sin embargo, el código que extrae usa cuatro de las variables declaradas en la función. ¿debe pasar las cuatro variables como argumentos a la nueva función? en absoluto. si ascendemos estas cuatro variables a variables de instancia de la clase, podremos extraer el código sin pasar las variables. resultaría más sencillo dividir la función en pequeños fragmentos. desafortunadamente, eso significaría que nuestras clases perderían cohesión ya que acumularían más y más variables de instancia que sólo existen para que otras funciones las compartan. pero un momento. si apenas existen funciones que compartan determinadas variables, ¿no son entonces una clase con derecho propio? por supuesto. cuando las clases pierdan cohesión, divídalas. por tanto, dividir una gran función en otras más reducidas también nos permite dividir varias clases más reducidas. de este modo mejora la organización del programa y su estructura resulta más transparente. como ejemplo, usaremos un ejemplo obtenido del libro de knuth literate 192programming [47] . el listado 10-5 muestra una traducción a java del programa printprimes de knuth. para hacerle justicia, no es el programa que creó sino el resultado generado por su herramienta web. lo usamos aquí por ser un magnífico punto de partida para dividir una función de gran tamaño en varias funciones y clases más reducidas. listado 10-5 printprimes.java package literateprimes; public class printprimes { public static void main(string[] args) { final int m = 1000; final int rr = 50; final int cc = 4; final int ww = 10; final int ordmax = 30; int p[] = new int[m + 1]; int pagenumber; int pageoffset; int rowoffset; int c; int j; int k; boolean jprime; int ord; int square; int n; int mult[] = new int[ordmax + 1]; j = 1; k = 1; p[1] = 2; ord = 2; square = 9; while (k < m) { do { j = j + 2; if (j == square) { ord = ord + 1; square = p[ord] * p[ord]; mult[ord - 1] = j; } n = 2; jprime = true; while (n < ord && jprime) { while (mult[n] < j) 193mult[n] = mult[n] + p[n] + p[n]; if (mult[n] == j) jprime = false; n = n + 1; } } while (!jprime); k = k + 1; p[k] = j; } { pagenumber = 1; pageoffset = 1; while (pageoffset <= m) { system.out.println(“the first ” + m + “ prime numbers --- page ” + pagenumber); system.out.println(“”); for (rowoffset = pageoffset; rowoffset < pageoffset + rr; rowoffset++) { for (c = 0; c < cc;c++) if (rowoffset + c * rr <= m) system.out.format(“%10d”, p[rowoffset + c * rr]); system.out.println(“”); } system.out.println(“\f”); pagenumber = pagenumber + 1; pageoffset = pageoffset + rr * cc; } } } } este programa, escrito como una sola función, es un desastre. el sangrado de su estructura es excesivo y hay demasiadas variables extrañas. como mínimo, la función debería dividirse en otras más pequeñas. los listados del 10-6 al 10-8 muestran la división del código del listado 10-5 en clases y funciones de menor tamaño, además de los nombres elegidos para dichas clases, funciones y variables. listado 10-6 primeprinter.java (refactorizado) package literateprimes; public class primeprinter ( public static void main(string[] args) { final int number_of_prime5 = 1000; int[] primes = primegenerator.generate(number_of_primes); final int rows_per_page = 50; 194final int columns_per_page = 4; rowcolumnpageprinter tableprinter = new rowcolumnpageprinter(rows_per_page, columns_per_page, “the first ” + number_of_primes + “ prime numbers”); tableprinter.print(primes); } } listado 10-7 rowcolumnpageprinter.java. package literateprimes; import java.io.printstream; public class rowcolumnpageprinter { private int rowsperpage; private int columnsperpage; private int numbersperpage; private string pageheader; private printstream printstream; public rowcolumnpageprinter(int rowsperpage, int columnsperpage, string pageheader) { this.rowsperpage = rowsperpage; this.columnsperpage = columnsperpage; this.pageheader = pageheader; numbersperpage = rowsperpage * columnsperpage; printstream = system.out; } public void print(int data[]) { int pagenumber = 1; for (int firstindexonpage = 0; firstindexonpage < data.length; firstindexonpage += numbersperpage) { int lastindexonpage = math.min(firstindexonpage + numbersperpage - 1, data.length - 1); printpageheader(pageheader, pagenumber); printpage(firstindexonpage, lastindexonpage, data); printstream.println(“\f”); pagenumber++; } } private void printpage (int firstindexonpage, int lastindexonpage, int[] data) { 195int firstindexoflastrowonpage = firstindexonpage + rowsperpage - 1; for (int firstindexinrow = firstindexonpage; firstindexinrow <= firstindexoflastrowonpage; firstindexinrow++) { printrow(firstindexinrow, lastindexonpage, data); printstream.println(“”); } } private void printrow(int firstindexinrow, int lastindexonpage, int[] data) { for (int column = 0; column < columnsperpage; column++) { int index = firstindexinrow + column * rowsperpage; if (index <= lastindexonpage) printstream.format(“%10d”, data[index]); } } private void printpageheader(string pageheader, int pagenumber) { printstream.println(pageheader + “ --- page ” + pagenumber); printstream.println(“”); } public void setoutput(printstream printstream) { this.printstream = printstream; } } listado 10-8 primegenerator.java package literateprimes; import java.util.arraylist; public class primegenerator { private static int[] primes; private static arraylist<integer> multiplesofprimefactors; protected static int[] generate(int n) { primes = new int[n]; multiplesofprimefactors = new arraylist<integer>(); set2asfirstprime(); checkoddnumbersforsubsequentprimes(); return primes; } private static void set2asfirtsprime() { primes[0] = 2; multiplesofprimefactors.add(2); 196} private static void checkoddnumbersforsubsequentprimes() { int primeindex = 1; for (int candidate = 3; primeindex < primes.length; candidate += 2) { if (isprime(candidate)) primes[primeindex++] = candidate; } } private static boolean isprime(int candidate) { if (isleastrelevantmultipleofnextlargerprimefactor(candidate)) { multiplesofprimefactors.add(candidate); return false; } return isnotmultipleofanypreviousprimefactor(candidate); } private static boolean isleastrelevantmultipleofnextlargerprimefactor(int candidate) { int nextlargerprimefactor = primes[multiplesofprimefactors.size()]; int leastrelevantmultiple = nextlargerprimefactor * nextlargerprimefactor; return candidate == leastrelevantmultiple; } private static boolean isnotmultipleofanypreviousprimefactor(int candidate) { for (int n = 1; n < multiplesofprimefactors.size(); n++) { if (ismultipleofnthprimefactor(candidate, n)) return false; } return true; } private static boolean ismultipleofnthprimefactor(int candidate, int n) { return candidate == smallestoddnthmultiplenotlessthancandidate(candidate, n); } private static int smallestoddnthmultiplenotlessthancandidate(int candidate, int n) { int multiple = multiplesofprimefactors.get(n); while (multiple < candidate) multiple += 2 * primes[n]; multiplesofprimefactors.set(n, multiple); return multiple; } } lo primero que apreciará es que ha aumentado la longitud del programa, 197de una a casi tres páginas. este aumento se debe a varios motivos. en primer lugar, el programa refactorizado usa nombres de variable más extensos y descriptivos. por otra parte, usa declaraciones de funciones y clases como comentarios del código. por último, usamos espacios en blanco y técnicas de formato para mantener la legibilidad. el programa se ha dividido en tres responsabilidades principales. la parte principal se incluye en la clase primeprinter , responsable de controlar el entorno de ejecución. cambia si se modifica el método de invocación. por ejemplo, si este programa se convierte en un servicio soa, es la clase que se verá afectada. rowcolumnpageprinter sabe cómo aplicar formato a una lista de números con una determinada cantidad de filas y columnas. si es necesario cambiar el formato del resultado, es la clase que se verá afectada. la clase primegenerator sabe cómo generar una lista de números primos. no se creará una instancia como objeto. la clase es sólo un ámbito útil en el que declarar y ocultar sus variables. esta clase cambia si se modifica el algoritmo para calcular números primos. no hemos reescrito el programa. no hemos empezado de cero y los hemos vuelto a diseñar. en realidad, si se fija atentamente en los dos programas, verá que usan los mismos algoritmos y mecanismos. el cambio se ha realizado creando una suite de pruebas que verifican el comportamiento preciso del primer programa. tras ello, se aplican numerosos cambios mínimos, de uno en uno. tras cada cambio, se ejecuta el programa para garantizar que el comportamiento no varía. paso a paso, el primer programa se limpia y se transforma en el segundo. organizar los cambios en muchos sistemas, el cambio es continuo. cada cambio supone un riesgo de que el resto del sistema no funcione de la forma esperada. en un sistema limpio organizamos las clases para reducir los riesgos de los cambios. la clase sql del listado 10-9 se usa para generar cadenas sql de forma correcta con los metadatos adecuados. es un trabajo continuo y, como tal, no 198admite funciones sql como instrucciones update . cuando la clase sql tenga que admitir una instrucción update , tendremos que abrirla para realizar modificaciones. el problema de abrir una clase es el riesgo que conlleva. cualquier modificación puede afectar a otro código de la clase. debe probarse concienzudamente. listado 10-9 clase que debemos abrir para realizar cambios. public class sql { public sql(string table, column[] columns) public string create() public string insert(object[] fields) public string selectall() public string findbykey(string keycolumn, string keyvalue) public string select(column column, string pattern) public string select(criteria criteria) public string preparedinsert() private string columnlist(column[] columns) private string valueslist(object[] fields, final column[] columns) private string selectwithcriteria(string criteria) private string placeholderlist(column[] columns) } la clase sql debe cambiar al añadir un nuevo tipo de instrucción. también debe cambiar cuando variemos los detalles de un tipo de instrucción concreto; por ejemplo, si tenemos que modificar la funcionalidad select para admitir selecciones secundarias. estos dos motivos de cambio significan que la clase sql incumple srp. podemos detectar este incumplimiento desde un punto de vista organizativo. el método outline de sql muestra que hay métodos privados, como selectwithcriteria , que parecen relacionarse únicamente con instrucciones select . el comportamiento de métodos privados aplicados a un pequeño subconjunto de una clase puede ser una heurística útil para detectar zonas que mejorar. sin embargo, la verdadera razón debe ser el cambio del sistema. si la clase sql se considera totalmente lógica, no debemos preocuparnos por separar las responsabilidades. si no necesitamos funcionalidad de actualización en el futuro, podemos olvidarnos de sql . pero si tenemos que 199abrir una clase, debemos corregir el diseño. ¿y si optamos por una solución como la del listado 10-10? los métodos públicos de interfaz definidos en sql en el listado 10-9 se refactorizan en sus propias variantes de la clase sql . los métodos privados, como valueslist , se mueven directamente a las posiciones necesarias. el comportamiento privado se reduce a un par de clases de utilidad: where y columnlist . listado 10-10 un grupo de clases cerradas. abstract public class sql { public sql(string table, column[] columns) abstract public string generate(); } public class createsql extends sql { public createsql(string table, column[] columns) @override public string generate() } public class selectsql extends sql { public selectsql(string table, column[] columns) @override public string generate() } public class insertsql extends sql { public selectsql(string table, column[] columns, object[] fields) @override public string generate() private string valueslist(object[] fields, final column[] columns) } public class selectwithcriteriasql extends sql { public selectwithcriteriasql( string table, column[] columns, criteria criteria) @override public string generate() } public class selectwithmatchsql extends sql { public selectwithmatchsql( string table, column[] columns, column column, string pattern) @override public string generate() } public class findbykeysql extends sql { public findbykeysql( string table, column[] columns, string keycolumn, string keyvalue) @override public string generate() } 200public class preparedinsertsql extends sql { public preparedinsertsql(string table, column[] columns) @override public string generate() private string placeholderlist(column[] columns) } public class where { public where(string criteria) public string generate() } public class columnlist { public columnlist(column[] columns) public string generate() } el código de cada clase se simplifica enormemente. el tiempo necesario para entender las clases se reduce al mínimo. el riesgo de que una función afecte a otra desaparece casi por completo. desde el punto de vista de las pruebas, resulta más sencillo probar la lógica de esta solución, ya que las clases se aíslan unas de otras. además, cuando llegue el momento de añadir las instrucciones update , no cambia ninguna de las clases existentes. añadimos la lógica para generar instrucciones update a una nueva subclase de sql , updatesql . este cambio no afecta a otro código del sistema. nuestra lógica sql reestructurada representa lo mejor de ambos mundos. cumple con srp y también con otro principio clave del diseño de clases orientadas a objetos, denominado principio abierto/cerrado [48] : las clases deben abrirse para su ampliación para cerrarse para su modificación. la nueva clase sql se abre a nuevas funcionalidades mediante la creación de subclases pero podemos realizar estos cambios y mantener cerradas las demás clases. basta con añadir nuestra clase updatesql . debemos estructurar nuestros sistemas para ensuciarlos lo menos posible cuando los actualicemos con nuevas funciones o cambios. en un sistema ideal, incorporamos nuevas funciones ampliándolo, no modificando el código existente. aislarnos de los cambios 201las necesidades cambiarán y también lo hará el código. en la programación orientada a objetos aprendemos que hay clases concretas que contienen detalles de implementación (el código) y clases abstractas que sólo representan conceptos. una clase cliente que dependa de detalles concretos está en peligro si dichos detalles cambian. podemos recurrir a interfaces y clases abstractas para aislar el impacto de dichos detalles. las dependencias de detalles de concretos crean retos para nuestro sistema. si tenemos que crear la clase portfolio y ésta depende de una api tokyostockexchange externa para obtener su valor, nuestros casos de prueba se verán afectados por la volatilidad de esta búsqueda. resulta complicado crear una prueba cuando se obtiene una respuesta diferente cada cinco minutos. en lugar de diseñar portfolio para que dependa directamente de tokyostockexchange , creamos una interfaz, stockexchange , que declara un único método: public interface stockexchange { money currentprice(string symbol); } diseñamos tokyostockexchange para implementar esta interfaz. también nos aseguramos de que el constructor de portfolio adopte como argumento una referencia a stockexchange: public portfolio { private stockexchange exchange; public portfolio(stockexchange exchange) { this.exchange = exchange; } //… } ahora la prueba puede crear una implementación de la interfaz stockexchange que emule tokyostockexchange . esta implementación de prueba fijará el valor actual del símbolo que usemos en la prueba. si nuestra prueba demuestra la adquisición de cinco acciones de microsoft para nuestra cartera de valores, diseñe el código de la implementación de prueba para que siempre devuelva 100 dólares por acción de microsoft. nuestra implementación de prueba de la interfaz stockexchange se reduce a una sencilla búsqueda de tabla. de este modo 202podemos crear una prueba que espere un valor de cartera total de 500 dólares: public class portfoliotest { private fixedstockexchangestub exchange; private portfolio portfolio; @before protected void setup() throws exception { exchange = new fixedstockexchangestub(); exchange.fix(“msft”, 100); portfolio = new portfolio(exchange); } @test public void givenfivemsfttotalshouldbe500() throws exception { portfolio.add(5, “msft”); assert.assertequals(500, portfolio.value()); } } si diseccionamos un sistema para poder probarlo de esta forma, resultará más flexible y se podrá reutilizar. la ausencia de conexiones significa que los elementos del sistema se aíslan entre ellos y de otros cambios. este aislamiento hace que comprendamos mejor los elementos del sistema. al minimizar las conexiones de esta forma, nuestras clases cumplen otro principio de diseño: dependency inversion principle (dip) o principio de inversión de dependencias [49] . básicamente afirma que nuestras clases deben depender de abstracciones, no de detalles concretos. en lugar de depender de los detalles de implementación de la clase tokyostockexchange , nuestra clase portfolio depende de la interfaz stockexchange , que representa el concepto abstracto de solicitar el precio actual de una acción. esta abstracción aísla todos los datos concretos de la obtención de dicho precio, incluyendo de dónde se obtiene. bibliografía [rdd] : object design: roles, responsibilities, and collaborations , rebecca wirfs-brock et al., addison-wesley, 2002. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. 203[knuth92] : literate programming , donald e. knuth, center for the study of language and information, leland stanford junior university, 1992. 20411 sistemas por el dr. kevin dean wampler 205«la complejidad es letal. acaba con los desarrolladores y dificulta la planificación, generación y pruebas de los productos». —ray ozzie, cto, microsoft corporation cómo construir una ciudad ¿podría encargarse de todos los detalles por su cuenta? seguramente no. incluso la gestión de una ciudad existente sería demasiado para una sola persona. y aun así, las ciudades funcionan (en la mayoría de los casos). funcionan porque tienen equipos que controlan partes concretas de la ciudad, el alcantarillado, la red eléctrica, el tráfico, la seguridad, las normativas 206urbanísticas, etc. algunos se encargan de aspectos generales y otros se centran en los detalles. las ciudades también funcionan porque disponen de evolucionados niveles de abstracción y modularidad que permiten a individuos y componentes trabajar de forma eficaz, sin necesidad de entender el trasfondo general. aunque los equipos de software se suelen organizar de esta forma, los sistemas en los que trabajan no suelen contar con la misma separación de aspectos y niveles de abstracción. en este capítulo veremos cómo mantener la limpieza en niveles superiores de abstracción, en el sistema. separar la construcción de un sistema de su uso en primer lugar, recuerde que la construcción es un proceso muy diferente al uso. mientras escribo estas líneas, a través de la ventana veo un nuevo hotel en construcción en chicago. hoy instalarán una gran grúa. todos los obreros llevan casco. dentro de un año habrán acabado el hotel. la grúa desaparecerá. el edificio estará terminado, con su reluciente fachada de cristal y su atractiva decoración. la gente que trabajará en él también será diferente. los sistemas de software deben separar el proceso de inicio, en el que se crean los objetos de la aplicación y se conectan las dependencias, de la lógica de ejecución que toma el testigo tras el inicio. el proceso de inicio es un aspecto que toda aplicación debe abordar. es el primero que veremos en este capítulo. la separación de aspectos es una de las técnicas de diseño más antiguas e importantes de nuestra profesión. desafortunadamente, muchas aplicaciones no lo hacen. el código del proceso de inicio se mezcla con la lógica de tiempo de ejecución. veamos un ejemplo típico: public service getservice() { if (service == null) service = new myserviceimpl (…); //¿lo bastante predeterminado para la 207mayoría de los casos? return service; } es la técnica de inicialización/evaluación tardía y tiene sus méritos. no incurrimos en la sobrecarga de la construcción a menos que usemos el objeto realmente, y como resultado el tiempo de inicio se puede acelerar. también evitamos que se devuelva null . sin embargo, ahora tenemos una dependencia en myserviceimpl y todo lo que su constructor requiere (que he omitido). no podemos compilar sin resolver estas dependencias, aunque nunca usemos un objeto de este tipo en tiempo de ejecución. las pruebas también pueden ser un problema. si myserviceimpl es un objeto pesado, tendremos que asegurarnos de asignar el correspondiente test double [50] u objeto simulado al campo de servicio antes de invocar este método en las pruebas de unidad. como la lógica de la construcción se mezcla con el procesamiento normal de tiempo de ejecución, debemos probar todas las rutas de ejecución (como la prueba null y su bloque). al contar con ambas responsabilidades, el método hace más de una cosa, por lo que se incumple el principio de responsabilidad única. lo peor de todo es que no sabemos si myserviceimpl es el objeto correcto en todos los casos. ¿por qué la clase con este método tiene que conocer el contexto global? ¿podemos saber realmente cuál es el objeto correcto que usar aquí? ¿es posible que un mismo tipo sea el correcto para todos los contextos posibles? un caso de inicialización tardía no es un problema serio. sin embargo, suele haber muchos casos de este tipo de configuración en las aplicaciones. por tanto, la estrategia de configuración global (si existe) se disemina por la aplicación, sin apenas modularidad y con una significativa duplicación. si somos diligentes sobre el diseño de sistemas robustos y bien formados, no debemos permitir fallos de modularidad. el proceso de inicio de la construcción y conexión de objetos no es una excepción. debemos modularizar este proceso y asegurarnos de contar con una estrategia global y coherente para resolver las dependencias principales. 208separar main una forma de separar la construcción del uso consiste en trasladar todos los aspectos de la construcción a main o a módulos invocados por main , y diseñar el resto del sistema suponiendo que todos los objetos se han creado y conectado correctamente (véase la figura 11.1). el flujo de control es fácil de seguir. la función main crea los objetos necesarios para el sistema, los pasa a la aplicación y ésta los utiliza. verá que las flechas de dependencia atraviesan la barrera entre main y la aplicación. todas van en la misma dirección, alejándose de main , lo que significa que la aplicación no tiene conocimiento de main ni del proceso de construcción. simplemente espera que todo se haya construido correctamente. figura 11.1. separación de la construcción en main() . factorías en ocasiones, la aplicación tendrá que ser responsable de la creación de un objeto. por ejemplo, en un sistema de procesamiento de pedidos, la aplicación debe crear las instancias lineitem que añadir a order . en este caso, podemos usar el patrón de factoría abstracta [51] para que la aplicación controle cuándo crear lineitem , pero mantener los detalles de dicha construcción separados del código de la aplicación (véase la figura 11.2). 209de nuevo vemos que todas las dependencias se desplazan desde main a la aplicación orderprocessing , lo que significa que la aplicación se desconecta de los detalles de creación de lineitem . esta capacidad se incluye en lineitemfactoryimplementation , en el extremo main de la línea. y sin embargo, la aplicación tiene control total sobre cuándo se crean las instancias lineitem e incluso puede proporcionar argumentos de constructor específicos de la aplicación. figura 11.2. separación de la construcción con una factoría. inyectar dependencias un potente mecanismo para separar la construcción del uso es la inyección de dependencias, la aplicación de inversión de control ( inversion of control o ioc) a la administración de dependencias [52] . la inversión de control pasa responsabilidades secundarias de un objeto a otros dedicados a ese cometido, por lo que admite el principio de responsabilidad única. en el contexto de la administración de dependencias, un objeto no debe ser responsable de instanciar dependencias, sino que debe delegar esta responsabilidad en otro mecanismo autorizado, de modo que se invierte el control. como la configuración es un aspecto global, este mecanismo autorizado suele ser la 210rutina main o un contenedor de propósito especial. las búsquedas jndi son una implementación parcial de la inyección de dependencias, en las que un objeto solicita a un servidor de directorios un servicio que coincida con un nombre concreto. myservice myservice = (myservice)(jndicontext.lookup(“nameofmyservice”)); el objeto invocador no controla el tipo de objeto devuelto (siempre que implemente la interfaz correcta, evidentemente), pero es el que resuelve la dependencia de forma activa. la verdadera inyección de dependencias va un paso más allá. la clase no hace nada directamente para resolver sus dependencias, es totalmente pasiva. por el contrario, ofrece métodos de establecimiento o argumentos de constructor (o ambos) que se usan para inyectar las dependencias. en el proceso de construcción, el contenedor de inyección de dependencias crea instancias de los objetos necesarios (normalmente bajo demanda) y usa los argumentos de constructor o métodos de establecimiento proporcionados para conectar las dependencias. los objetos dependientes empleados suelen especificarse a través de un archivo de configuración o mediante programación en un módulo de construcción de propósito especial. la estructura spring proporciona el contenedor de inyección de dependencias más conocido para java [53] . los objetos que se van a conectar se definen en un archivo de configuración xml y después se solicitan objetos concretos por nombre en código de java. veremos un ejemplo en breve. ¿y qué sucede con las virtudes de la inicialización tardía? en ocasiones es útil con la inyección de dependencias. por un lado, muchos contenedores de inyección de dependencias no crean un objeto hasta que es necesario. por otra parte, muchos de estos contenedores cuentan con mecanismos para invocar factorías o crear proxies que se pueden usar para evaluación tardía y optimizaciones similares [54] . evolucionar las ciudades nacen de pueblos, que nacen de asentamientos. inicialmente, los 211caminos son estrechos y prácticamente inexistentes, después se asfaltan y aumentan de tamaño. los pequeños edificios y solares vacíos se llenan de otros mayores que acaban convirtiéndose en rascacielos. al principio no hay servicios, electricidad, agua, alcantarillado o internet (¡vaya!). estos servicios se añaden cuando aumenta la densidad de población. este crecimiento no es fácil. cuántas veces mientras conduce por una carretera llena de baches y ve una señal de obras no se ha preguntado por qué no la hicieron más ancha desde un principio. no se podía haber hecho de otra forma. ¿quién puede justificar el gasto en una autopista de seis carriles que atraviese un pequeño pueblo como anticipación a un supuesto crecimiento? ¿quién querría una autopista así en su ciudad? conseguir sistemas perfectos a la primera es un mito. por el contrario, debemos implementar hoy, y refactorizar y ampliar mañana. es la esencia de la agilidad iterativa e incremental. el desarrollo controlado por pruebas, la refactorización y el código limpio que generan hace que funcione a nivel del código. ¿pero qué sucede en el nivel del sistema? ¿la arquitectura del sistema no requiere una planificación previa? sin duda no puede aumentar incrementalmente algo sencillo a algo complejo, ¿o sí? los sistemas de software son únicos si los comparamos con los sistemas físicos. sus arquitecturas pueden crecer incrementalmente, si mantenemos la correcta separación de los aspectos. la naturaleza efímera de los sistemas de software hace que sea posible, como veremos. primero nos centraremos en una arquitectura que no separa correctamente los aspectos. las arquitecturas ejb1 y ejb2 originales no separaban correctamente los aspectos y por tanto imponían barreras innecesarias al crecimiento orgánico. imagine un bean de entidad para una clase bank persistente. un bean de entidad es una representación en memoria de datos relacionales, es decir, una fila de una tabla. primero, debe definir una interfaz local (en proceso) o remota (mvj 212independiente), que los clientes usen. el listado 1-1 muestra una posible interfaz local: listado 11-1 una interfaz local ejb2 para el ejb bank. package com.example.banking; import java.util.collections; import javax.ejb.*; public interface banklocal extends java.ejb.ejblocalobject { string getstreetaddrl{} throws ejbexception; string getstreetaddr2{} throws ejbexception; string getcity() throws ejbexception; string getstate() throws ejbexception; string getzipcode() throws ejbexception; void setstreetaddr1(string street1) throws ejbexception; void setstreetaddr2(string street2) throws ejbexception; void setcity(string city) throws ejbexception; void setstate(string state) throws ejbexception; void setzipcode(string zip) throws ejbexception; collection getaccounts() throws ejbexception; void setaccounts(collection accounts) throws ejbexception; void addaccount(accountdto accountdto) throws ejbexception; } mostramos diversos atributos de la dirección de bank y una colección de cuentas del banco, cuyos datos se procesarán por un ejb account diferente. el listado 11-2 muestra la correspondiente clase de implementación del bean bank . listado 11-2 implementación del bean de entidad ejb2. package com.example.banking; import java.util.collections; import javax.ejb.*; public abstract class bank implements javax.ejb.entitybean { // lógica empresarial… public abstract string getstreeraddr1(); public abstract string getstreetaddr2(); public abstract string getcity(); public abstract string getstate(); public abstract string getzipcode(); public abstract void setstreetaddr1(string street1); 213public abstract void setstreetaddr2(string street2); public abstract void setcity(string city); public abstract void setstate(string state); public abstract void setzipcode(string zip); public abstract collection getaccounts(); public abstract void setaccounts(collection accounts); public void addaccount(accountpto accountdto) { initialcontext context = new initialcontext(); accounthomelocal accounthome = context.lookup(“accounthomelocal”); accountlocal account = accounthome.create(accountdto); collection accounts = getaccounts(); accounts.add(account); } // lógica del contenedor ejb public abstract void setid(integer id); public abstract integer getid(); public integer ejbcreate(integer id) {…} public void ejbpostcreate(integer id) {…} // el resto tendría que implementarse pero se deja vacío: public void setentitycontext(entitycontext ctxt) {} public void unsetentitycontext() {} public void ejbactivate() {} public void ejbpassivate() {} public void ejbload() {} public void ejbstore() {} public void ejbremove() {} } no mostramos la correspondiente interfaz localhome , básicamente una factoría usada para crear objetos, no los métodos de consulta bank que pueda añadir. por último, debemos crear uno o varios descriptores de implementación xml que especifiquen los detalles de asignación relacional de objetos en un almacén persistente, el comportamiento deseado de la transacción, limitaciones de seguridad y demás. la lógica empresarial está directamente conectada al contenedor de la aplicación ejb2. debe crear subclases de tipos de contenedor y proporcionar los métodos de ciclo vital necesarios para el contenedor. debido a esta conexión al contenedor pesado, las pruebas de unidad aisladas son complicadas. es necesario imitar el contenedor, algo difícil, o perder demasiado tiempo en la implementación de ejb y pruebas en un servidor real. la reutilización fuera de la arquitectura ejb2 es imposible, debido a esta estrecha conexión. por último, incluso la programación orientada a objetos se ve afectada. un bean no se puede heredar de otro. fíjese en la lógica para 214añadir una nueva cuenta. en bean ejb2 es habitual definir objetos de transferencia de datos ( data transfer objects o dto), estructuras sin comportamiento. esto suele generar tipos redundantes con los mismos datos y requiere código predefinido para copiar datos entre objetos. aspectos transversales la arquitectura ejb2 se acerca a la verdadera separación de aspectos en determinados aspectos. por ejemplo, los comportamientos transaccionales, de seguridad y comportamiento deseados se declaran en los descriptores de implementación, independientemente del código fuente. aspectos como la persistencia suelen cruzar los límites de objeto naturales de un dominio. por lo general intentará mantener todos sus objetos mediante la misma estrategia, por ejemplo con un determinado dbms [55] y no archivos planos, usando determinadas convenciones de nomenclatura para tablas y columnas, una semántica transaccional coherente, etc. en principio, puede razonar su estrategia de persistencia de una forma modular y encapsulada, pero en la práctica tendrá que distribuir el mismo código que implemente la estrategia de persistencia entre varios objetos. usamos el término transversales para este tipo de aspectos. de nuevo, la estructura de persistencia podría ser modular y la lógica de dominios, aislada, también. el problema es la intersección entre ambos dominios. de hecho, la forma en que la arquitectura ejb procesa persistencia, seguridad y transacciones es una programación orientada a aspectos ( aspect oriented programming o aop) [56] anticipada, un enfoque de carácter general para restaurar la modularidad en aspectos transversales. en aop, construcciones modulares denominadas aspectos especifican qué puntos del sistema deben modificar su comportamiento de forma coherente para admitir un determinado aspecto. esta especificación se realiza mediante un sucinto mecanismo de declaración o programación. si usamos la persistencia como ejemplo, podría declarar qué objetos y atributos (o patrones) deben conservarse y después delegar las tareas de persistencia a su estructura de persistencia. las modificaciones de 215comportamiento no son invasivas [57] para el código de destino. veamos tres aspectos o mecanismos similares en java. proxies de java los proxies de java son útiles en casos sencillos, como envolver invocaciones de métodos en objetos o clases concretas. sin embargo, los proxies dinámicos proporcionados en el jdk sólo funcionan con interfaces. para aplicarlos a clases, debe usar una biblioteca de manipulación de código de bytes , como cglib, asm o javassist [58] . el listado 11-3 muestra la estructura de un proxy jdk para ofrecer asistencia de persistencia a nuestra aplicación bank; únicamente abarca los métodos para obtener y establecer la lista de cuentas. listado 11-3 ejemplo de proxy del jdk. // bank.java (eliminando nombres de paquetes…) import java.utils.*; // la abstracción de un banco. public interface bank { collection<account> getaccounts(); void setaccounts(collection<accounts> accounts); } // bankimpl.java import java.utils.*; // “plain old java object” pojo que implementa la abstracción. public class bankimpl implements bank { private list<account> accounts; public collection<account> getaccounts() { return accounts; } public void setaccounts(collections<accounts> accounts) { this.accounts = new arraylist<accounts>(); for (account account: accounts) { this.accounts.add(account); } } } 216// bankproxyhandler.java import java.lang.reflect.*; import java.util.*; // «invocationhandler» necesario para la api de proxy. public class bankproxyhandler implements invocationhandler { private bank bank; public bankhandler (bank bank) { this.bank = bank; } // método definido en invocationhandler public object invoke(object proxy, method method, object[] args) throws throwable { string methodname = method.getname(); if (methodname.equals(“getaccounts”)) { bank.setaccounts(getaccountsfromdatabase()); return bank.getaccounts(); } else if (methodname.equals(“setaccounts”)) { bank.setaccounts((collection<account>) args[0]); setaccountstodatabase(bank.getaccounts()); return null; } else { … } } // muchos detalles: protected collection<account> getaccountsfromdatabase() {…} protected void setaccountstodatabase(collection<account> accounts) {…} } //en otra parte… bank bank = (bank) proxy.newproxyinstance( bank.class.getclassloader(), new class[] { bank.class }, new bankproxyhandler(new bankimpl())); definimos la interfaz bank , que envolvemos en el proxy y un pojo ( plain-old object u objeto sencillo de java), bankimpl , que implementa la lógica empresarial (encontrará más información sobre pojo en un apartado posterior). la api proxy requiere un objeto invocationhandler que invocar para implementar las invocaciones de métodos bank realizadas en el proxy. bankproxyhandler usa la api de reflexión de java para asignar las invocaciones de métodos genéricos a los métodos correspondientes de 217bankimpl , y así sucesivamente. el código es abundante y complejo, incluso para este sencillo caso [59] . el uso de una de las bibliotecas de manipulación de bytes es igualmente complicado. el volumen y la complejidad de este código son dos de los inconvenientes de los proxies . dificultan la creación de código limpio. además, los proxies no ofrecen un mecanismo para especificar puntos de ejecución globales del sistema, imprescindibles para una verdadera solución aop [60] . estructuras aop java puras afortunadamente, gran parte del código predefinido de proxy se puede procesar de forma automática mediante herramientas. los proxies se usan internamente en varias estructuras de java como spring aop y jboss aop, para implementar aspectos en java [61] . en spring, se crea la lógica empresarial en forma de pojo, específicos de su dominio. no dependen de estructuras empresariales (ni de otros dominios). por tanto, son conceptualmente más sencillos y más fáciles de probar. su relativa simplicidad garantiza que se implementen correctamente las correspondientes historias y el mantenimiento y evolución del código en historias futuras. la infraestructura necesaria de la aplicación, incluidos aspectos transversales como persistencia, transacciones, seguridad, almacenamiento en caché y recuperación ante fallos, se incorpora por medio de archivos de configuración declarativos o api. en muchos casos, se especifican aspectos de bibliotecas spring o jboss, en los que la estructura controla el uso de proxies de java o bibliotecas de código de bytes de forma transparente al usuario. estas declaraciones controlan el contenedor de inyección de dependencias, que crea instancias de los principales objetos y las conecta bajo demanda. el listado 11-4 muestra un fragmento tipo de un archivo de configuración de spring v2.5, app.xml [62] . 218listado 11-4 archivo de configuración de spring 2.x <beans> … <bean id=“appdatasource” class=“org.apache.commons.dbcp.basicdatasource” destroy-method=“close” p:driverclassname=“com.mysql.jdbc.driver” p:url=“jdbc:mysql://localhost:3306/mydb” p:username=“me”/> <bean id=“bankdataaccessobject” class=“com.example.banking.persistence.bankdataaccessobject” p:datasource-ref=“appdatasource”/> <bean id=“bank” class=“com.example.banking.model.bank” p:dataaccessobject-ref=“bankdataaccessobject”/> … </beans> cada bean es como una parte de una muñeca rusa anidada, con un objeto de domino de un proxy bank (envuelto) por un objeto de acceso a datos ( data accessor object , dao), que también se procesa a través de un proxy por medio de un origen de datos de controlador jdbc (véase la figura 11.3). figura 11.3. la “muñeca rusa” de elementos de decoración. el cliente cree que invoca getaccounts() en un objeto bank , pero en realidad se comunica con el objeto decorator [63] más externo de un grupo, un objeto que amplía el comportamiento básico del pojo bank . podríamos añadir otros objetos de decoración para transacciones, almacenamiento en caché y demás. en la aplicación, bastan unas líneas para solicitar al contenedor de id los objetos de nivel superior del sistema, como se especifica en el archivo xml. 219xmlbeanfactory bf = new xmlbeanfactory(new classpathresource(“app.xml”, getclass())); bank bank = (bank) bf.getbean(“bank”); como apenas se necesitan líneas de código java específico de spring, la aplicación se desconecta casi por completo de spring y desaparecen los problemas de conexión de sistemas como ejb2. aunque xml puede ser difícil de leer [64] , la directiva especificada en estos archivos de configuración es más sencilla que la complicada lógica de proxy y aspectos oculta a la vista y creada de forma automática. es una arquitectura tan atractiva que sistemas como spring modificaron totalmente el estándar ejb para la versión 3. ejb3 sigue el modelo de spring de aspectos transversales admitidos mediante declaraciones con archivos de configuración xml y/o anotaciones de java 5. el listado 11-5 muestra nuestro objeto bank reescrito en ejb3 [65] . listado 11-5 un ejb bank ejb3. package com.example.banking.model; import javax.persistence; import java.util.arraylist; import java.util.collection; @entity @table(name = “banks”) public class bank implements java.io.serializable { @id @generatedvalue(strategy=generationtype.auto) private int id; @embeddable // un objeto en línea en la fila db de bank public class address { protected string streetaddr1; protected string streetaddr2; protected string city; protected string state; protected string zipcode; } @embedded private address address; @onetomany (cascade = cascadetype.all, fetch = fetchtype.eager, mappedby=“bank”) private collection<account> accounts = new arraylist<account>(); 220public int getid() { return id; } public void setid(int id) { this.id = id; } public void addaccount(account account) { account.setbank(this); accounts.add(account); } public collection<account> getaccounts() { return accounts; } public void setaccounts(collection<account> accounts) { this.accounts = accounts; } } este código es mucho más limpio que el código ejb2 original. se conservan algunos detalles de entidades, en las anotaciones. sin embargo, como no hay información fuera de las anotaciones, el código es limpio y fácil de probar, mantener y demás. parte de la información de persistencia de las anotaciones se puede cambiar a descriptores de implementación xml si es necesario, dejando un pojo puro. si los detalles de asignación de persistencia no cambian con frecuencia, muchos equipos pueden optar por mantener las anotaciones pero con menos obstáculos que si usaran ejb2. aspectos de aspectj por último, la herramienta más completa de separación a través de aspectos es el lenguaje aspectj [66] , una extensión de java que ofrece compatibilidad de primer nivel para aspectos como construcciones de modularidad. los enfoques puros de java proporcionados por spring aop y jboss aop son suficientes en el 80-90 por 100 de los casos en los que los aspectos son útiles. sin embargo, aspectj ofrece un conjunto de herramientas avanzadas y completas para la separación de aspectos. el inconveniente de aspectj es la necesidad de adoptar nuevas herramientas y aprender nuevas construcciones 221del lenguaje. los problemas de adopción se han mitigado parcialmente gracias a la introducción de un formato de anotación de aspectj, en el que se usan anotaciones de java 5 para definir aspectos con código puro de java. además, la estructura spring dispone de funciones que facilitan la incorporación de aspectos basados en anotaciones en un equipo con experiencia limitada con aspectj. el análisis completo de aspectj supera los objetivos de este libro. si necesita más información al respecto, consulte [aspectj], [colyer] y [spring]. pruebas de unidad de la arquitectura del sistema la separación a través de enfoques similares a aspectos no se puede menospreciar. si puede crear la lógica de dominios de su aplicación mediante pojo, sin conexión con los aspectos arquitectónicos a nivel del código, entonces se podrá probar realmente la arquitectura. puede evolucionar de simple a sofisticado, de acuerdo a las necesidades, adoptando nuevas tecnologías bajo demanda. no es necesario realizar un buen diseño por adelantado (big design up front [67] , bduf). de hecho, bduf puede ser negativo ya que impide la adaptación al cambio, debido a la resistencia fisiológica a descartar esfuerzos previos y a la forma en que las decisiones arquitectónicas influyen en la concepción posterior del diseño. los arquitectos deben realizar bduf ya que no resulta factible aplicar cambios arquitectónicos radicales a una estructura física una vez avanzada la construcción [68] . aunque el software se rige por una física propia [69] , es económicamente factible realizar cambios radicales si la estructura del software separa sus aspectos de forma eficaz. esto significa que podemos iniciar un proyecto de software con una arquitectura simple pero bien desconectada, y ofrecer historias funcionales de forma rápida, para después aumentar la infraestructura. algunos de los principales sitios web del mundo han alcanzado una gran disponibilidad y rendimiento por medio de sofisticadas técnicas de almacenamiento en caché, seguridad, virtualización y demás, todo ello de forma eficaz y flexible ya que los diseños mínimamente conectados son adecuadamente simples en cada 222nivel de abstracción y ámbito. evidentemente, no quiere decir que acometamos los proyectos sin timón. debemos tener expectativas del ámbito general, objetivos y un programa, así como la estructura general del sistema resultante. sin embargo, debemos mantener la capacidad de cambiar de rumbo en respuesta a las circunstancias. la arquitectura ejb inicial es una de las api conocidas con un exceso de ingeniería y que compromete la separación de aspectos. incluso las api bien diseñadas pueden ser excesivas cuando no resultan necesarias. una api correcta debe desaparecer de la vista en la mayoría de los casos, para que el equipo dedique sus esfuerzos creativos a las historias implementadas. en caso contrario, las limitaciones arquitectónicas impedirán la entrega eficaz de un valor óptimo para el cliente. para recapitular: una arquitectura de sistema óptima se compone de dominios de aspectos modularizados, cada uno implementado con pojo. los distintos dominios se integran mediante aspectos o herramientas similares mínimamente invasivas. al igual que en el código, en esta arquitectura se pueden realizar pruebas. optimizar la toma de decisiones la modularidad y separación de aspectos permite la descentralización de la administración y la toma de decisiones. en un sistema suficientemente amplio, ya sea una ciudad o un proyecto de software , no debe haber una sola persona que adopte todas las decisiones. sabemos que conviene delegar las responsabilidades en las personas más cualificadas. solemos olvidar que también conviene posponer decisiones hasta el último momento. no es falta de responsabilidad; nos permite tomar decisiones con la mejor información posible. una decisión prematura siempre es subjetiva. si decidimos demasiado pronto, tendremos menos información del cliente, reflexión mental sobre el proyecto y experiencia con las opciones de implementación. 223la agilidad que proporciona un sistema pojo con aspectos modularizados nos permite adoptar decisiones óptimas a tiempo, basadas en los conocimientos más recientes. además, se reduce la complejidad de estas decisiones. usar estándares cuando añadan un valor demostrable la construcción de edificios es una maravilla para la vista debido al ritmo empleado (incluso en invierno) y los extraordinarios diseños posibles gracias a la tecnología actual. la construcción es un sector maduro con elementos, métodos y estándares optimizados que han evolucionado bajo presión durante siglos. muchos equipos usaron la arquitectura ejb2 por ser un estándar, aunque hubiera bastado con diseños más ligeros y sencillos. he visto equipos obsesionados con estándares de moda y que se olvidaron de implementar el valor para sus clientes. los estándares facilitan la reutilización de ideas y componentes, reclutan individuos con experiencia, encapsulan buenas ideas y conectan componentes. sin embargo, el proceso de creación de estándares puede tardar demasiado para el sector, y algunos pierden el contacto con las verdaderas necesidades de aquello para los que están dirigidos. los sistemas necesitan lenguajes específicos del dominio la construcción de edificios, como muchos dominios, ha desarrollado un rico lenguaje con vocabularios, frases y patrones [70] que comunican información esencial de forma clara y concisa. en el mundo del software , ha renacido el interés por crear lenguajes específicos del dominio ( domain-specific languages o dsl) [71] , pequeños lenguajes independientes de creación de secuencias de comandos o api de lenguajes estándar que permiten crear 224código que se lea de una forma estructurada, como lo escribiría un experto del dominio. un buen dsl minimiza el vacío de comunicación entre un concepto de dominio y el código que lo implementa, al igual que las prácticas ágiles optimizan la comunicación entre un equipo y los accionistas del proyecto. si tiene que implementar la lógica de dominios en el mismo lenguaje usado por un experto del dominio, hay menos riesgo de traducir incorrectamente el dominio en la implementación. los dsl, si se usan de forma eficaz, aumentan el nivel de abstracción por encima del código y los patrones de diseño. permiten al desarrollador revelar la intención del código en el nivel de abstracción adecuado. los lenguajes específicos del dominio permiten expresar como pojo todos los niveles de abstracción y todos los dominios de la aplicación, desde directivas de nivel superior a los detalles más mínimos. conclusión los sistemas también deben ser limpios. una arquitectura invasiva afecta a la lógica de dominios y a la agilidad. si la lógica de dominios se ve afectada, la calidad se resiente, ya que los errores se ocultan y las historias son más difíciles de implementar. si la agilidad se ve comprometida, la productividad sufre y las ventajas de tdd se pierden. en todos los niveles de abstracción, los objetivos deben ser claros. esto sólo sucede si crea pojo y usa mecanismos similares a aspectos para incorporar otros aspectos de implementación de forma no invasiva. independientemente de que diseñe sistemas o módulos individuales, no olvide usar los elementos más sencillos que funcionen. bibliografía [alexander] : christopher alexander, a timeless way of building , oxford university press, new york, 1979. 225[aosd] : puerto de desarrollo de software orientado a aspectos, http://aosd.net. [asm] : página de asm, http://asm.objectweb.org/. [aspectj] : http: //eclipse.org/aspectj. [cglib] : biblioteca de generación de código, http://cglib.sourceforge.net/. [colyer] : adrian colyer, andy clement, george hurley, mathew webster, eclipse aspectj , person education, inc., upper saddle river, nj, 2005. [dsl] : lenguaje de programación específico del dominio, http://es.wikipedia.org/wiki/lenguaje_espec%c3%adfico_del_dominio. [fowler] : inversión de contenedores de control y el patrón de inyección de dependencias (http://martinfowler.com/articles/injection.html). [goetz] : brian goetz, java theory and practice: decorating with dynamic proxies , http://www.ibm.com/developerworks/java/library/j- jtp08305.html. [javassist] : página de javassist, http://www.csg.is.titech.ac.jp/chiba/javassist/. [jboss] : página de jboss, http: //jboss.org. [jmock] : jmock: una biblioteca de objetos mock ligeros para java, http://jmock.org. [kolence] : kenneth w. kolence, software physics and computer performance measurements, proceedings of the acm annual conference-volume 2, boston, massachusetts, pp. 1024-1040,1972. [spring] : the spring framework , http://www.springframework.org. [mezzaros07] : xunit patterns , gerard mezzaros, addison-wesley, 2007. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 22612 emergencia con jeff langr limpieza a través de diseños emergentes 227imagine que existieran cuatro sencillas reglas para crear diseños de calidad. imagine que siguiéndolas accediera a la estructura y al diseño de su código y facilitara la aplicación de principios como srp y dip. imagine que estas cuatro reglas facilitaran la emergencia de diseños de calidad. muchos consideramos que las cuatro reglas de kent beck de diseño sencillo [72] son fundamentales para crear un software bien diseñado. según kent, un diseño es sencillo si cumple estas cuatro reglas: ejecuta todas las pruebas. no contiene duplicados. expresa la intención del programador. minimiza el número de clases y métodos. describiremos estas reglas en orden de importancia. primera regla del diseño sencillo: ejecutar todas las pruebas en primer lugar, un diseño debe generar un sistema que actúe de la forma prevista. un sistema puede tener un diseño perfecto sobre el papel pero si no existe una forma sencilla de comprobar que realmente funciona de la forma esperada, el esfuerzo sobre el papel es cuestionable. un sistema minuciosamente probado y que supera todas las pruebas en todo momento se denomina sistema testable. es una afirmación obvia, pero importante. los sistemas que no se pueden probar no se pueden verificar, y un sistema que no se puede verificar no debe implementarse. afortunadamente, crear sistemas testables hace que diseñemos clases de tamaño reducido y un solo cometido. resulta más sencillo probar clases que cumplen el srp. cuantas más pruebas diseñemos, más nos acercaremos a elementos más fáciles de probar. por lo tanto, hacer que nuestro sistema se pueda probar nos ayuda a crear mejores diseños. las conexiones rígidas dificultan la creación de pruebas. del mismo modo, cuantas más pruebas creemos, más usaremos principios como dip y 228herramientas con inyección de dependencias, interfaces y abstracción para minimizar dichas conexiones. nuestros diseños mejorarán todavía más. en especial, seguir una sencilla regla que afirme que debemos realizar pruebas y ejecutarlas continuamente afecta el cumplimiento por parte de nuestro sistema de los principales objetivos de la programación orientada a objetos de baja conexión y elevada cohesión. la creación de pruebas conduce a obtener mejores diseños. reglas 2 a 4 del diseño sencillo: refactorizar una vez creadas las pruebas, debemos mantener limpio el código y las clases. para ello, refactorizamos el código progresivamente. tras añadir unas líneas, nos detenemos y reflejamos el nuevo diseño. ¿ha empeorado? en caso afirmativo, lo limpiamos y ejecutamos las pruebas para comprobar que no hay elementos afectados. la presencia de las pruebas hace que perdamos el miedo a limpiar el código y que resulte dañado . en la fase de refactorización, podemos aplicar todos los aspectos del diseño de software correcto. podemos aumentar la cohesión, reducir las conexiones, separar las preocupaciones, modularizar aspectos del sistema, reducir el tamaño de funciones y clases, elegir nombres más adecuados, etc. aquí también aplicamos las tres últimas reglas del diseño correcto: eliminar duplicados, garantizar la capacidad de expresión y minimizar el número de clases y métodos. eliminar duplicados los duplicados son los mayores enemigos de un sistema bien diseñado. suponen un esfuerzo adicional, riesgos añadidos y una complejidad a mayores innecesaria. los duplicados se manifiestan de diversas formas. las líneas de código similar pueden modificarse para que parezcan refactorizadas, y hay otras formas de duplicación como la de implementación. por ejemplo, podríamos tener dos métodos en una clase de colección: 229int size() {} boolean isempty() {} podríamos tener implementaciones separadas para cada método. el método isempty podría controlar un valor booleano y size un contador, o podemos eliminar la duplicación y vincular isempty a la definición de size : boolean isempty() { return 0 == size(); } la creación de un sistema limpio requiere la eliminación de duplicados, aunque sean unas cuantas líneas de código. fíjese en el siguiente ejemplo: public void scaletoonedimension { float desireddimension, float imagedimension) { if (math.abs(desireddimension - imagedimension) < errorthreshold) return; float scalingfactor = desireddimension / imagedimension; scalingfactor = (float)(math.floor(scalingfactor * 100) * 0.01f); renderedop newimage = imageutilities.getscaledimage( image, scalingfactor, scalingfactor); image.dispose(); system.gc(); image = newimage; } public synchronized void rotate(int degrees) { renderedop newimage = imageutilities.getrotatedimage( image, degrees); image.dispose(); system.gc(); image = newimage; } para mantener limpio este sistema, debemos eliminar la pequeña cantidad de duplicación entre los métodos scaletoonedimension y rotate : public void scaletoonedimension ( float desireddimension, float imagedimension) { if (math.abs(desireddimension - imagedimension) < errorthreshold) return; float scalingfactor = desireddimension / imagedimension; scalingfactor = (float)(math.floor(scalingfactor * 100) * 0.01f); replaceimage(imageutilities.getscaledimage( image, scalingfactor, scalingfactor)); } public synchronized void rotate (int degrees) { replaceimage(imageutilities.getrotatedimage(image, degrees)); } private void replaceimage(renderedop newimage) ( 230image.dispose(); system.gc(); image = newimage; } al extraer a este reducido nivel, comenzamos a detectar incumplimientos de srp. por ello, podríamos cambiar un nuevo método extraído a otra clase. esto aumenta su visibilidad. otro miembro del equipo puede ver la necesidad de volver a extraer el nuevo método y usarlo en otro contexto diferente. esta reutilización mínima puede reducir considerablemente la complejidad del sistema. saber cómo lograrlo es fundamental para alcanzar la reutilización a gran escala. el patrón método de plantilla [73] es una técnica muy utilizada para eliminar duplicados de nivel superior. por ejemplo: public class vacationpolicy { public void accrueusdivisionvacation() { // código para calcular las vacaciones en función de las horas trabajadas //… // código para garantizar que las vacaciones cumplen los mínimos legales //… // código para aplicar vacation al registro payroll //… } public void accrueeudivisionvacation() { // código para calcular las vacaciones en función de las horas trabajadas //… // código para garantizar que las vacaciones cumplen los mínimos legales //… // código para aplicar vacation al registro payroll //… } } el código entre accrueusdivisionvacation y accrueeuropeandivisionvacation es prácticamente idéntico, a excepción del cálculo de mínimos legales. esa parte del algoritmo cambia en función del tipo de empleado. podemos eliminar la duplicación evidente si aplicamos el patrón de método de plantilla : abstract public class vacationpolicy { public void accruevacation() { calculatebasevacationhours(); alterforlegalminimums(); applytopayroll(); } 231private void calculatebasevacationhours() { /* … */ }; abstract protected void alterforlegalminimums(); private void applytopayroll(); { /* … */ }; } public class usvacationpolicy extends vacationpolicy { @override protected void alterforlegalminimums() { // lógica específica de ee.uu. } } public class euvacationpolicy extends vacationpolicy { @override protected void alterforlegalminimums() { // lógica específica de la ue. } } las subclases ocupan el vacío generado en el algoritmo accruevacation y solamente proporcionan los datos que no están duplicados. expresividad muchos tenemos experiencia con código enrevesado. muchos lo hemos creado. es fácil crear código que entendamos, ya que durante su creación nos centramos en comprender el problema que intentamos resolver. los encargados de mantener el código no lo comprenderán de la misma forma. el principal coste de un proyecto de software es su mantenimiento a largo plazo. para minimizar los posibles defectos al realizar cambios, es fundamental que comprendamos el funcionamiento del sistema. al aumentar la complejidad de los sistemas, el programador necesita más tiempo para entenderlo y aumentan las posibilidades de errores. por tanto, el código debe expresar con claridad la intención de su autor. cuando más claro sea el código, menos tiempo perderán otros en intentar comprenderlo. esto reduce los defectos y el coste de mantenimiento. puede expresarse si elige nombres adecuados. el objetivo es ver el nombre de una clase y función, y que sus responsabilidades no nos sorprendan. también puede expresarse si reduce el tamaño de funciones y clases. al hacerlo, resulta más sencillo asignarles nombres, crearlas y comprenderlas. 232otra forma de expresarse es usar una nomenclatura estándar. los patrones de diseño, por ejemplo, se basan en la comunicación y en la capacidad de expresión. al usar los nombres de patrones estándar, como command o visitor , en los nombres de las clases que implementan dichos patrones puede describir sucintamente su diseño a otros programadores. las pruebas de unidad bien escritas también son expresivas. uno de los principales objetivos de una prueba es servir de documentación mediante ejemplos. los que lean las pruebas deben entender con facilidad para qué sirve una clase. pero la forma más importante de ser expresivo es la práctica. a menudo, conseguimos que el código funcione y pasamos al siguiente problema sin detenernos en facilitar la lectura del código para otros. no olvide que seguramente sea el próximo que lea el código. por tanto, afronte su creación con orgullo. dedique tiempo a sus funciones y clases. seleccione nombres mejores, divida las funciones extensas en otras más reducidas y cuide su obra. el cuidado es un recurso precioso. clases y métodos mínimos incluso conceptos tan básicos como la eliminación de código duplicado, la expresividad del código y srp pueden exagerarse. en un esfuerzo por reducir el tamaño de clases y métodos, podemos crear demasiadas clases y métodos reducidos. esta regla también sugiere minimizar la cantidad de funciones y clases. una gran cantidad de clases y métodos suele indicar un dogmatismo sin sentido. imagine un estándar de código que insista en la creación de una interfaz para todas las clases, o a programadores que insisten en qué campos y comportamientos siempre deben separarse en clases de datos y clases de comportamiento. este dogma debe evitarse y cambiarse por un enfoque más pragmático. nuestro objetivo es reducir el tamaño general del sistema además del tamaño de clases y funciones, pero recuerde que esta regla es la de menor 233prioridad de las cuatro. por ello, aunque sea importante reducir la cantidad de clases y funciones, es más importante contar con pruebas, eliminar duplicados y expresarse correctamente. conclusión ¿existen prácticas sencillas que puedan reemplazar a la experiencia? por supuesto que no. sin embargo, las prácticas descritas en este capítulo y en el libro son una forma cristalizada de décadas de experiencia de muchos autores. la práctica del diseño correcto anima y permite a los programadores adoptar principios y patrones que en caso contrario tardarían años en aprender. bibliografía [xpe] : extreme programming explained: embrace change , kent beck, addison wesley, 1999. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. 23413 concurrencia por brett l. schuchert 235“los objetos son abstracciones de procesamiento. los subprocesos son abstracciones de programaciones”. —james o. coplien [74] la creación de programas concurrentes limpios es complicada, muy complicada. es mucho más sencillo crear código que se ejecute en un mismo proceso. también es fácil crear código de subprocesamiento múltiple que parezca correcto en la superficie pero que esté dañado a niveles más profundos. este código funciona correctamente hasta que el sistema se somete a determinadas presiones. en este capítulo analizaremos la necesidad de la programación concurrente y sus dificultades. tras ello, presentaremos diversas recomendaciones para superar dichas dificultades y crear código concurrente limpio. por último, finalizaremos con los problemas relacionados con la prueba de código concurrente. la concurrencia limpia es un tema complejo, merecedor de un libro propio. aquí, intentaremos ofrecer una visión general, que después ampliaremos en el apéndice a. si simplemente tiene curiosidad por el tema, le bastará con este capítulo. si necesita entender la concurrencia a un nivel más profundo, consulte también el apéndice. ¿por qué concurrencia? la concurrencia es una estrategia de desvinculación. nos permite desvincular lo que se hace de dónde se hace. en aplicación de un solo proceso, el qué y el cuándo están tan firmemente vinculados que el estado de la aplicación se puede determinar analizando la huella de la pila. un programador que depure este tipo de sistemas puede definir un punto de interrupción (o varios) y saber el estado de la aplicación en función del punto al que se llegue. la desvinculación del qué del dónde puede mejorar considerablemente el rendimiento y la estructura de una aplicación. desde un punto de vista estructural, la aplicación parece una serie de equipos colaboradores y no un gran bucle principal. esto puede hacer que el sistema sea más fácil de 236comprender y ofrece diversas formas de separar las preocupaciones. pongamos por caso el modelo servlet estándar de aplicaciones web. estos sistemas se ejecutan bajo un contenedor web o ejb que gestiona parcialmente la concurrencia. los servlet se ejecutan de forma asíncrona cuando se reciben solicitudes web. el programador de los servlet no tiene que gestionar todas las solicitudes entrantes. en principio, la ejecución de cada servlet vive en un mundo propio y se desvincula del resto. evidentemente, si fuera tan sencillo, no necesitaríamos este capítulo. de hecho, la desvinculación proporcionada por los contenedores web dista mucho de ser perfecta. los programadores de servlet deben asegurarse de que sus programas sean correctos. no obstante, las ventajas estructurales del modelo de servlet son significativas. pero la estructura no es el único motivo para adoptar la concurrencia. algunos sistemas tienen limitaciones de tiempo de respuesta y producción que requieren soluciones concurrentes manuales. imagine un dispositivo para añadir información, con un solo proceso, que obtiene datos de distintos sitios web y los combina en un resumen diario. al tener un solo proceso, accede por turnos a cada sitio web y siempre termina uno antes de comenzar el siguiente. su recorrido diario debe ejecutarse en menos de 24 horas. sin embargo, al añadir nuevos sitios web, el tiempo aumenta hasta necesitarse más de 24 horas para recopilar todos los datos. el único proceso implica una prolongada espera para completar la e/s. podríamos mejorar el rendimiento con ayuda de un algoritmo de subprocesamiento múltiple que visite más de un sitio web por vez. imagine un sistema que procesa un usuario por vez y sólo requiere un segundo por cada uno. su capacidad de respuesta es válida para un número reducido de usuarios pero si aumenta, también lo hace el tiempo de respuesta del sistema. ningún usuario querrá esperar a otros 150. podríamos mejorar el tiempo de respuesta de este sistema procesando varios usuarios a la vez. imagine un sistema que interprete grandes conjuntos de datos pero que sólo ofrezca una solución completa tras procesarlos todos. se podría procesar cada conjunto de datos en un equipo distinto, para poder procesarlos todos en paralelo. 237mitos e imprecisiones también existen motivos evidentes para adoptar la concurrencia aunque, como indicamos antes, sea complicada. si no presta la suficiente atención, pueden darse casos desagradables. veamos los mitos e imprecisiones más habituales: la concurrencia siempre mejora el rendimiento : en ocasiones lo hace pero sólo cuando se puede compartir tiempo entre varios procesos o procesadores. ninguna situación es trivial. el diseño no cambia al crear programas concurrentes : de hecho, el diseño de un algoritmo concurrente puede ser muy distinto al de un sistema de un solo proceso. la desvinculación entre el qué y el cuándo suele tener un efecto importante en la estructura del sistema. no es importante entender los problemas de concurrencia al trabajar con un contenedor web o ejb : en realidad, debe saber lo que hace su contenedor y protegerlo de problemas de actualizaciones concurrentes y bloqueo, como veremos después. veamos otros aspectos relacionados con la creación de software concurrente: la concurrencia genera cierta sobrecarga , tanto en rendimiento como en la creación de código adicional. la concurrencia correcta es compleja , incluso para problemas sencillos. los errores de concurrencia no se suelen repetir , de modo que se ignoran [75] en lugar de considerarse verdaderos problemas. la concurrencia suele acarrear un cambio fundamental de la estrategia de diseño . desafíos ¿qué hace que la programación concurrente sea tan complicada? fíjese en la 238siguiente clase: public class x { private int lastidused; public int getnextid() { return ++lastidused; } } imagine que creamos una instancia x , establecemos el campo lastidused en 42 y después compartimos la instancia entre dos procesos. imagine ahora que esos dos procesos invocan el método getnextid() ; hay tres resultados posibles: el primer proceso obtiene el valor 43, el segundo el valor 44 y lastidused es 44. el primer proceso obtiene el valor 44, el segundo el valor 43 y lastidused es 44. el primer proceso obtiene el valor 43, el segundo el valor 43 y lastidused es 43. el sorprendente tercer resultado [76] se produce cuando los dos procesos coinciden. se debe a que pueden adoptar varias rutas posibles en una línea de código de java y algunas generan resultados incorrectos. ¿cuántas rutas distintas existen? para responder, debemos entender lo que hace el compilador justo a tiempo con el código de bytes generado, y lo que el modelo de memoria de java considera atómico. una rápida respuesta, con el código de bytes generado, es que existen 12 870 rutas de ejecución diferentes [77] para los dos procesos ejecutados en el método getnextid . si el tipo de lastidused cambia de int a long , el número de rutas asciende a 2 704 156. evidentemente, muchas generan resultados válidos. el problema es que algunas no lo hacen . principios de defensa de la concurrencia a continuación le mostramos una serie de principios y técnicas para proteger 239a sus sistemas de los problemas del código concurrente. principio de responsabilidad única (srp) srp [78] establece que un método, clase o componente sólo debe tener un motivo para cambiar. el diseño de concurrencia es lo bastante complejo como para ser un motivo de cambio con derecho propio y, por tanto, debe separarse del resto del código. desafortunadamente, es habitual incrustar los detalles de la implementación de concurrencia directamente en otro código de producción. tenga en cuenta los siguientes aspectos: el código relacionado con la concurrencia tiene su propio ciclo de desarrollo , cambios y ajustes. el código relacionado con la concurrencia tiene sus propios desafíos , diferentes y más complicados, que los del código no relacionado con la concurrencia. el número de formas en las que el código incorrecto basado en la concurrencia puede fallar lo complica ya de por sí, sin la carga añadida del código de aplicación circundante. recomendación : separe el código de concurrencia del resto del código [79] . corolario: limitar el ámbito de los datos como hemos visto, dos procesos que modifican el mismo campo u objeto compartido pueden interferir entre ellos y provocar un comportamiento inesperado. una solución consiste en usar la palabra clave synchronized para proteger una sección importante del código que use el objeto compartido, aunque conviene limitar la cantidad de estas secciones. cuantos más puntos actualicen datos compartidos, es más probable que: 240se olvide de proteger uno o varios de esos puntos, y se dañe el código que modifica los datos compartidos. se duplique el esfuerzo necesario para garantizar la protección de todos los elementos (incumplimiento de dry [80] ). resulta complicado determinar el origen de los fallos, que por naturaleza son difíciles de detectar. recomendación : encapsule los datos y limite el acceso a los datos compartidos . corolario: usar copias de datos una forma de evitar datos compartidos es no compartirlos. en algunos casos se pueden copiar objetos y procesarlos como si fueran de sólo lectura. en otros, se pueden copiar objetos, recopilar los resultados de varios procesos en las copias y después combinar los resultados en un mismo proceso. si existe una forma sencilla de evitar los objetos compartidos, el código resultante tendrá menos problemas. puede que le preocupe el coste de la creación de objetos adicionales. merece la pena experimentar y comprobar si es un problema real. no obstante, si el uso de copias de objetos permite al código evitar la sincronización, las ventajas de evitar el bloque compensan la creación adicional y la sobrecarga de la recolección de elementos sin usar. corolario: los procesos deben ser independientes pruebe a crear el código de sus procesos de forma que cada uno sea independiente y no comparta datos con otros. cada uno procesa una solicitud cliente y todos los datos necesarios provienen de un origen sin compartir y se almacenan como variables locales. de este modo, los procesos se comportan como si fueran los únicos del mundo y no existieran requisitos de sincronización. por ejemplo, las subclases de httpservlet reciben toda su información como parámetros pasados en los métodos doget y dopost . esto hace que cada servlet actúe como si dispusiera de su propio equipo. mientras 241el código del servlet sólo use variables locales, es imposible que cause problemas de sincronización. evidentemente, muchas aplicaciones que usan servlet se topan con recursos compartidos como conexiones de base de datos. recomendación : intente dividir los datos en subconjuntos independientes que se puedan procesar en procesos independientes, posiblemente en distintos procesadores . conocer las bibliotecas java 5 ofrece muchas mejoras para el desarrollo concurrente con respecto a versiones anteriores. existen diversos aspectos que tener en cuenta a la hora de crear código de procesos en java 5: usar las colecciones compatibles con procesos proporcionadas. usar la estructura de ejecución de tareas no relacionadas. usar soluciones antibloqueo siempre que sea posible. varias clases de bibliotecas no son compatibles con procesos. colecciones compatibles con procesos en los albores de java, doug lea escribió el conocido libro [81]  concurrent programming in java . al mismo tiempo, desarrolló varias colecciones compatibles con procesos, que posteriormente pasaron a formar parte del jdk en el paquete java.util.concurrent . las colecciones de dicho paquete son compatibles con casos de procesos múltiples y tienen un rendimiento adecuado. de hecho, la implementación concurrenthashmap tiene mejor rendimiento que hashmap en la mayoría de los casos. también permite lecturas y escrituras simultáneas, y dispone de métodos que admiten operaciones de composición habituales que en caso contrario serian incompatibles con subprocesos. si java 5 es su entorno de desarrollo, comience con concurrenthashmap . 242existen otras clases añadidas para admitir diseño avanzado de concurrencia. veamos algunos ejemplos: reentrantlock bloqueo que se puede adquirir en un método y liberar en otro. semaphore una implementación del clásico semáforo, un bloqueo con un contador. countdownlatch bloqueo que espera un número de eventos antes de liberar todos los subprocesos retenidos. de este modo todos tienen la misma oportunidad de iniciarse al mismo tiempo. recomendación : revise las clases de las que disponga. en el caso de java, debe familiarizarse con java.util.concurrent, java.util.concurrent.atomic y java.util.concurrent.locks . conocer los modelos de ejecución existen diversas formas de dividir el comportamiento de una aplicación concurrente. para describirlos debe conocer ciertas definiciones básicas. recursos vinculados recursos de tamaño o número fijo usados en un entorno concurrente, como por ejemplo conexiones de base de datos y búfer de lectura/escritura de tamaño fijo. exclusión mutua sólo un proceso puede acceder a datos o a un recurso compartido por vez. inanición se impide que un proceso o grupo de procesos continúen demasiado tiempo o indefinidamente. por ejemplo, si permite primero la ejecución de los procesos más rápidos, los que se ejecutan durante más tiempo pueden perecer de inanición si los primeros no terminan nunca. bloqueo dos o más procesos esperan a que ambos terminen. cada proceso tiene un recurso y ninguno puede terminar hasta que obtenga el otro recurso. bloqueo procesos bloqueados, intentando realizar su labor pero 243activo estorbándose unos a otros. por motivos de resonancia, los procesos siguen intentando avanzar pero no pueden durante demasiado tiempo, o de forma indefinida. tras mostrar estas definiciones, ya podemos describir los distintos modelos de ejecución empleados en la programación concurrente. productor-consumidor [82] uno o varios procesos productores crean trabajo y lo añaden a un búfer o a una cola. uno o varios procesos consumidores adquieren dicho trabajo de la cola y lo completan. la cola entre productores y consumidores es un recurso vinculado, lo que significa que los productores deben esperar a que se libere espacio en la cola antes de escribir y los consumidores deben esperar hasta que haya algo que consumir en la cola. la coordinación entre productores y consumidores a través de la cola hace que unos emitan señales a otros. los productores escriben en la cola e indican que ya no está vacía. los consumidores leen de la cola e indican que ya no está llena. ambos esperan la notificación para poder continuar. lectores-escritores [83] cuando un recurso compartido actúa básicamente como fuente de información para lectores pero ocasionalmente se actualiza por parte de escritores, la producción es un problema. el énfasis de la producción puede provocar la inanición y la acumulación de información caducada. las actualizaciones pueden afectar a la producción. la coordinación de lectores para que no lean algo que un escritor está actualizando y viceversa es complicada. los escritores tienden a bloquear a los lectores durante periodos prolongados, lo que genera problemas de producción. el desafío consiste en equilibrar las necesidades de ambos para satisfacer un funcionamiento correcto, proporcionar una producción razonable y evitar la inanición. una sencilla estrategia hace que los escritores esperen hasta que deje de haber lectores antes de realizar una actualización. si hay lectores 244continuos, los escritores perecen de inanición. por otra parte, si hay escritores frecuentes y se les asigna prioridad, la producción se ve afectada. determinar el equilibrio y evitar problemas de actualización concurrente es el objetivo de este modelo. la cena de los filósofos [84] imagine varios filósofos sentados alrededor de una mesa redonda. a la izquierda de cada uno hay un tenedor. en el centro de la mesa, una gran fuente de espaguetis. los filósofos pasan el tiempo pensando a menos que tengan hambre. cuando tienen hambre, utilizan los tenedores situados a ambos lados para comer. no pueden comer a menos que tengan dos tenedores. si el filósofo situado a la derecha o izquierda de otros ya tiene uno de los tenedores que necesita, tendrá que esperar a que termine de comer y deje los tenedores. cuando un filósofo termina de comer, vuelve a colocar los tenedores en la mesa hasta que vuelve a tener hambre. cambie los filósofos por procesos y los tenedores por recursos y tendrá un problema habitual en muchas aplicaciones en las que los procesos compiten por recursos. a menos que se diseñen correctamente, los sistemas que compiten de esta forma experimentan problemas de bloqueo, bloqueo mutuo, producción y degradación de la eficacia. la mayoría de problemas de concurrencia que encontrará serán alguna variante de éstos. analice los algoritmos y cree soluciones propias para estar preparado cuando surjan problemas de concurrencia. recomendación : aprenda estos algoritmos básicos y comprenda sus soluciones . dependencias entre métodos sincronizados las dependencias entre métodos sincronizados generan sutiles errores en el código concurrente. java cuenta con synchronized , que protege métodos individuales. no obstante, si hay más de un método sincronizado en la misma clase compartida, puede que su sistema sea incorrecto [85] . 245recomendación : evite usar más de un método en un objeto compartido . en ocasiones tendrá que usar más de un método en un objeto compartido. en ese caso, hay tres formas de crear código correcto: bloqueo basado en clientes : el cliente debe bloquear al servidor antes de invocar el primer método y asegurarse de que el alcance del bloque incluye el código que invoque el último método. bloqueo basado en servidores : debe crear un método en el servidor que bloquee el servidor, invoque todos los métodos y después anule el bloqueo. el cliente debe invocar el nuevo método. servidor adaptado : cree un intermediario que realice el bloque. es un ejemplo de bloqueo basado en servidores en el que el servidor original no se puede modificar. reducir el tamaño de las secciones sincronizadas la palabra clave synchronized presenta un bloqueo. todas las secciones de código protegidas por el mismo bloque sólo tendrán un proceso que las ejecute en un momento dado. los bloqueos son costosos ya que generan retrasos y añaden sobrecarga. por ello, no conviene colapsar el código con instrucciones synchronized . por otra parte, las secciones críticas [86] deben protegerse, de modo que debemos diseñar nuestro código con el menor número posible de secciones críticas. algunos programadores intentan lograrlo ampliando el tamaño de sus secciones críticas. sin embargo, al ampliar la sincronización más allá de la sección crítica mínima aumentan los problemas y afecta negativamente al rendimiento [87] . recomendación : reduzca al máximo el tamaño de las secciones synchronized . crear código de cierre correcto es complicado 246crear un sistema activo y que se ejecute indefinidamente es distinto a crear algo que funcione de forma temporal y después se cierre correctamente. entre los problemas más habituales destacan los bloqueos [88] , con procesos que esperan una señal para continuar que nunca se produce. imagine, por ejemplo, un sistema con un proceso principal que genera varios procesos secundarios y que espera a que todos terminen antes de liberar sus recursos y cerrarse. ¿qué sucede si uno de los procesos secundarios está bloqueado? el principal esperará indefinidamente y el sistema nunca se cerrará. imagine ahora un sistema similar al que se le indica que se cierre. el proceso principal indica a todos los secundarios que abandonen sus tareas y terminen. pero imagine que dos procesos secundarios funcionan como par productor/consumidor y que el productor recibe una señal del principal y se cierra rápidamente. el consumidor espera un mensaje del productor y puede quedar bloqueado en un estado en el que no recibe la señal del principal, lo que también impide que éste finalice. son situaciones habituales. por tanto, si tiene que crear código concurrente con cierres correctos, tendrá que dedicar tiempo a que el cierre se produzca de forma correcta. recomendación : planifique con antelación el proceso de cierre y pruébelo hasta que funcione. le llevará más tiempo del que espera. repase los algoritmos existentes porque será complicado . probar código con procesos demostrar que el código es correcto no resulta práctico. las pruebas no garantizan su corrección. sin embargo, las pruebas adecuadas pueden minimizar los riesgos, en especial en aplicaciones de un solo proceso. cuando hay dos o más procesos que usan el mismo código y trabajan con datos compartidos, la situación se vuelve más compleja. recomendación : cree pruebas que puedan detectar problemas y ejecútelas periódicamente, con distintas configuraciones de programación y del sistema, y cargas. si las pruebas fallan, identifique el fallo. no lo ignore 247porque las pruebas superen una ejecución posterior . hay muchos factores que tener en cuenta. veamos algunas recomendaciones concretas: considere los fallos como posibles problemas de los procesos. consiga que primero funcione el código sin procesos. el código con procesos se debe poder conectar a otros elementos. el código con procesos debe ser modificable. ejecute con más procesos que procesadores. ejecute en diferentes plataformas. diseñe el código para probar y forzar fallos. considerar los fallos como posibles problemas de los procesos el código con procesos hace que fallen elementos que no deberían fallar. muchos desarrolladores desconocen cómo interactúan los procesos con otro tipo de código. los problemas del código con procesos pueden mostrar sus síntomas una vez cada mil o un millón de ejecuciones. los intentos por repetir los sistemas pueden resultar frustrantes, lo que suele provocar que los programadores consideren el fallo como algo aislado. es recomendable asumir que los fallos aislados no existen. cuanto más los ignore, mayor será la cantidad de código que se acumule sobre un enfoque defectuoso. recomendación : no ignore los fallos del sistema como algo aislado . conseguir que primero funcione el código sin procesos puede parecer evidente pero no está de más recordarlo. asegúrese de que el código funciona fuera de sus procesos. por lo general, esto significa crear algunos pojo que los procesos deban invocar. los pojo no son compatibles con los procesos y por tanto se pueden probar fuera de su entorno. conviene 248incluir en los pojo la mayor cantidad posible del sistema. recomendación : no intente identificar fallos de procesos y que no sean de procesos al mismo tiempo. asegúrese de que su código funciona fuera de los procesos . el código con procesos se debe poder conectar a otros elementos cree el código compatible con la concurrencia de forma que se pueda ejecutar en distintas configuraciones: un proceso, varios procesos y variarlo durante la ejecución. el código con procesos interactúa con algo que puede ser real o probado. ejecutar con pruebas dobles ejecutadas de forma rápida, lenta y variable. configurar pruebas que ejecutar en diferentes iteraciones. recomendación : el código con procesos debe poder conectar a otros elementos y ejecutar en distintas configuraciones . el código con procesos debe ser modificable la obtención del equilibrio adecuado de procesos suele requerir operaciones de ensayo y error. en las fases iniciales, compruebe el rendimiento del sistema bajo diferentes configuraciones. permita que se puedan modificar los distintos procesos y también durante la ejecución del sistema. también puede permitir la modificación automática en función de la producción y la utilización del sistema. ejecutar con más procesos que procesadores cuando el sistema cambia de tarea, se producen reacciones. para promover el intercambio de tareas, realice la ejecución con más procesos que procesadores o núcleos. cuanto mayor sea la frecuencia de intercambio de las 249tareas, más probabilidades existen de que el código carezca de una sección crítica o se produzcan bloqueos. ejecutar en diferentes plataformas en 2007 diseñamos un curso sobre programación concurrente, principalmente en os x. la clase se presentó con windows xp ejecutado en una mv. se crearon pruebas para ilustrar condiciones de fallo que fallaban con más frecuencia en os x que en xp. en todos los casos, el código probado era incorrecto. esto refuerza el hecho de que cada sistema operativo tiene una política de procesos diferente que afecta a la ejecución del código. el código con procesos múltiples se comporta de forma distinta en cada entorno [89] . debe ejecutar sus pruebas en todos los entornos de implementación posibles. recomendación : ejecute el código con procesos en todas las plataformas de destino con frecuencia y en las fases iniciales . diseñar el código para probar y forzar fallos es habitual que los fallos del código concurrente se oculten. las pruebas sencillas no suelen mostrarlos. en realidad, suelen ocultarse durante el procesamiento normal. pueden aparecer horas, días o semanas después. la razón de que los problemas de procesos sean infrecuentes, esporádicos y apenas se repitan es que sólo fallan algunas de las miles de rutas posibles que recorren una sección vulnerable. por tanto, la probabilidad de adoptar una ruta fallida es realmente baja, lo que dificulta la detección y la depuración. se preguntará cómo aumentar las posibilidades de capturar estos casos. puede diseñar el código y forzarle a que se ejecute en diferentes órdenes añadiendo métodos como object.wait() , object.sleep() , object.yield() y object.priority() . estos métodos afectan al orden de ejecución y, por tanto, aumentan las posibilidades de detectar un error. resulta más adecuado que el código 250incorrecto falle lo antes posible y con frecuencia. hay dos opciones de instrumentación de código: manual. automática. manual puede añadir invocaciones de wait() , sleep() , yield() y priority() manualmente a su código, en especial si tiene que probar un fragmento especialmente escabroso. veamos un ejemplo: public synchronized string nexturlornull() { if (hasnext()) { string url = urlgenerator.next(); thread.yield(); // se añade para pruebas. updatehasnext(); return url; } return null; } la invocación de yield() cambia la ruta de ejecución adoptada por el código y posiblemente hace que el código falla donde no lo hacía antes. si el código falla, no se debe a la invocación de yield() añadida [90] . se debe a que el código es incorrecto y hemos hecho que el fallo sea más evidente. este enfoque presenta varios problemas: tendrá que buscar manualmente los puntos adecuados donde hacerlo. ¿cómo sabe dónde incluir la invocación y qué tipo de invocación usar? la presencia de este código en un entorno de producción ralentiza innecesariamente el código. es un enfoque que puede o no detectar los fallos; de hecho, no las tiene todas consigo. lo que necesitamos es una forma de hacerlo durante la fase de pruebas, no de producción. también debemos poder mezclar configuraciones entre ejecuciones, lo que aumenta las probabilidades de detectar los errores. 251evidentemente, si dividimos el sistema pojo que no sepa nada los procesos en clases que controlen los procesos, resultará más sencillo ubicar los puntos en los que instrumentar el código. es más, podríamos crear diferentes pruebas que invoquen los pojo bajo distintos regímenes de invocaciones a sleep , yield y demás. automática puede usar herramientas como la estructura orientada a aspectos, cglib o asm para instrumentar su código mediante programación. por ejemplo, podría usar una clase con un único método: public class threadjigglepoint { public static void jiggle() { } } puede añadir invocaciones en distintos puntos del código: public synchronized string nexturlornull() { if(hasnext()) { threadjigglepoint.jiggle(); string url = urlgenerator.next(); threadjigglepoint.jiggle(); updatehasnext(); threadjigglepoint.jiggle(); return url; } return null; } tras ello, use un sencillo aspecto que seleccione aleatoriamente entre no hacer nada, pausar o generar un resultado. imagine que la clase threadjigglepoint tiene dos implementaciones. la primera implementa jiggle para no hacer nada y se usa en producción. la segunda genera un número aleatorio para elegir entre sleep , yield o nada. si ejecuta sus pruebas mil veces con jiggle de forma aleatoria, puede descubrir algunos fallos. si la prueba es satisfactoria, al menos puede felicitarse por haber actuado correctamente. aunque sea un tanto simple, puede resultar una opción razonable en lugar de recurrir a una herramienta más sofisticada. la herramienta contest [91] , desarrollada por ibm, tiene un funcionamiento 252similar pero es más sofisticada. el objetivo es que los procesos del código se ejecuten en distinto orden en momentos diferentes. la combinación de pruebas bien escritas y ejecuciones aleatorias puede aumentar considerablemente la capacidad de detectar errores. recomendación : use estas estrategias para detectar errores . conclusión es complicado conseguir código concurrente correcto. el código sencillo se puede complicar al añadir varios procesos y datos compartidos. si tiene que crear código concurrente, tendrá que hacerlo con rigor o se enfrentará a sutiles y esporádicos fallos. en primer lugar, siga el principio de responsabilidad única. divida su sistema en varios pojo que separen el código compatible con procesos del resto. asegúrese de probar únicamente el código compatible con procesos y nada más, por lo que este código debe ser de tamaño reducido y específico. conozca los orígenes de los problemas de concurrencia: varios procesos que operen en datos compartidos o usen una agrupación de recursos común. los casos de límites, como el cierre correcto o la conclusión de la iteración de un bucle, pueden ser especialmente espinosos. conozca su biblioteca y los algoritmos fundamentales. debe comprender cómo las funciones de la biblioteca permiten resolver problemas similares a los de los algoritmos fundamentales. aprenda a localizar regiones del código que se puedan bloquear y bloquéelas. no bloquee otras regiones que no lo necesiten. evite invocar una sección bloqueada desde otra. para ello debe saber si un elemento está compartido o no. reduzca la cantidad de objetos compartidos y su ámbito. cambie los diseños de los objetos con datos compartidos para acomodar clientes en lugar de obligar a los clientes a gestionar el estado compartido. los problemas se acumularán. los que no aparezcan inicialmente suelen considerarse esporádicos y suelen producirse en la fase de carga o de modo aparentemente aleatorio. por tanto, debe poder ejecutar su código con 253procesos en diferentes configuraciones y plataformas de forma repetida y continua. la capacidad de prueba, algo natural si aplica las tres leyes de tdd, implica cierto nivel de conectividad, lo que ofrece la compatibilidad necesaria para ejecutar código en distintas configuraciones. la probabilidad de detectar errores mejora si se toma el tiempo necesario para instrumentar su código. puede hacerlo manualmente o mediante tecnologías automatizadas. hágalo en las fases iniciales. es aconsejable ejecutar el código basado en procesos durante el mayor tiempo posible antes de pasarlo a producción. si adopta un enfoque limpio, aumentarán las probabilidades de hacerlo de forma correcta. bibliografía [lea99] : concurrent programming in java: design principles and patterns , 2d. ed., doug lea, prentice hall, 1999. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. 25414 refinamiento sucesivo caso práctico de un analizador de argumentos de línea de comandos este capítulo es un caso práctico de refinamiento sucesivo. veremos un 255módulo que comienza correctamente pero no mantiene dicha corrección. tras ello, veremos cómo se refactoriza y se limpia. muchos hemos tenido que analizar argumentos de línea de comando. si no disponemos de una utilidad para ello, recorremos la matriz de cadenas pasadas a la función principal. puede encontrar utilidades de calidad pero ninguna hace exactamente lo que necesitamos. por ello, decidí crear una propia, a la que he denominado args . args es muy fácil de usar. basta crearla con los argumentos de entrada y una cadena de formato, y después consultar a la instancia de args los valores de los argumentos. fíjese en el siguiente ejemplo: listado 14-1 uso de args public static void main(string[] args) { try { args arg = new args(“l,p#,d*”, args); boolean logging = arg.getboolean(‘l’); int port = arg.getint(‘p’); string directory = arg.getstring(‘d’); executeapplication(logging, port, directory); } catch (argsexception e) { system.out.printf(“argument error: %s\n”, e.errormessage()); } } comprobará lo sencillo que es. creamos una instancia de la clase args con dos parámetros. el primero es la cadena de formato o esquema: “l,p#,d*” . define tres argumentos de línea de comandos. el primero, -l , es un argumento booleano. el segundo, -p , es un argumento entero. el tercero, - d , es un argumento de cadena. el segundo parámetro del constructor args es la matriz de argumentos de línea de comandos pasada a main . si el constructor no genera argsexception , la línea de comandos entrante se ha analizado y se puede consultar la instancia args . se usan métodos como getboolean , getinteger y getstring para acceder a los valores de los argumentos por sus nombres. si hay un problema, ya sea en la cadena de formato o en los argumentos de línea de comandos, se genera argsexception . la descripción del error se 256puede recuperar del método errormessage de la excepción. implementación de args el listado 14-2 es la implementación de la clase args . examínela con atención. el estilo y la estructura se han trabajado concienzudamente y espero que los imite. listado 14-2 args.java package com.objectmentor.utilities.args; import static com.objectmentor.utilities.args.argsexception.errorcode.*; import java.util.*; public class args { private map<character, argumentmarshaler> marshalers; private set<character> argsfound; private listiterator<string> currentargument; public args(string schema, string[] args) throws argsexception { marshalers = new hashmap<character, argumentmarshaler>(); argsfound = new hashset<character>(); parseschema(schema); parseargumentstrings(arrays.aslist(args)); } private void parseschema(string schema) throws argsexception { for (string element : schema.split(“,”)) if (element.length() > 0) parseschemaelement(element.trim()); } private void parseschemaelement(string element) throws argsexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(element id); if (elementtail.length() == 0) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail.equals(“*”)) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail.equals(“#”)) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); 257else if (elementtail.equals(“[*]”)) marshalers.put(elementid, new stringarrayargumentmarshaler()); else throw new argsexception(invalid_argument_format, elementid, elementtail); } private void validateschemaelementid(char elementid) throws argsexception { if {!character.isletter(elementid)) throw new argsexception(invalid_argument_name, elementid, null); } private void parseargumentstrings(list<string> argslist) throws argsexception { for (currentargument = argslist.listiterator(); currentargument.hasnext();) { string argstring = currentargument.next(); if (argstring.startswith(“-”)) { parseargumentcharacters(argstring.substring(1)); } else { currentargument.previous(); break; } } } private void parseargumentcharacters(string argchars) throws argsexception { for (int i = 0; i < argchars.length(); i++) parseargumentcharacter(argchars.charat(i)); } private void parseargumentcharacter(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) { throw new argsexception (unexpected_argument, argchar, null); } else { argsfound.add(argchar); try { m.set(currentargument); } catch (argsexception e) { e.seterrorargumentid(argchar); throw e; } } } public boolean has(char arg) { return argsfound.contains(arg); } public int nextargument() { 258return currentargument.nextindex(); } public boolean getboolean(char arg) { return booleanargumentmarshaler.getvalue(marshalers.get(arg)); } public string getstring(char arg) { return stringargumentmarshaler.getvalue(marshalers.get(arg)); } public int getint(char arg) { return integerargumentmarshaler.getvalue (marshalers.get(arg)); } public double getdouble(char arg) { return doubleargumentmarshaler.getvalue(marshalers.get(arg)); } public string[] getstringarray(char arg) { return stringarrayargumentmarshaler.getvalue(marshalers.get(arg)); } } puede leer el código de arriba a abajo sin necesidad de saltar de un punto a otro ni buscar hacia adelante. lo que seguramente busque es la definición de argumentmarshaler , que hemos omitido intencionadamente. tras leer el código, comprenderá la interfaz argumentmarshaler y la función de sus variantes. veamos algunas de ellas (entre los listados 14-3 y 14-6). listado 14-3 argumentmarshaler.java public interface argumentmarshaler { void set(iterator<string> currentargument) throws argsexception; } listado 14-4 booleanargumentmarshaler.java public class booleanargumentmarshaler implements argumentmarshaler { private boolean booleanvalue = false; public void set (iterator<string> currentargument) throws argsexception { booleanvalue = true; } public static boolean getvalue(argumentmarshaler am) { 259if (am != null && am instanceof booleanargumentmarshaler) return ((booleanargumentmarshaler) am).booleanvalue; else return false; } } listado 14-5 stringargumentmarshaler.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class stringargumentmarshaler implements argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { throw new argsexception(missing_string); } } public static string getvalue(argumentmarshaler am) { if (am != null && am instanceof stringargumentmarshaler) return ((stringargumentmarshaler) am).stringvalue; else return “”; } } listado 14-6 integerargumentmarshaler.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class integerargumentmarshaler implements argumentmarshaler { private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); intvalue = integer.parseint(parameter); } catch (nosuchelementexception e) { throw new argsexception(missing_integer); } catch (numberformatexception e) { throw new argsexception(invalid_integer, parameter); } } 260public static int getvalue (argumentmarshaler am) { if (am != null && am instanceof integerargumentmarshaler) return ((integerargumentmarshaler) am).intvalue; else return 0; } } las otras variantes de argumentmarshaler simplemente repiten este patrón en matrices double y string y sólo complicarían el capítulo. puede consultarlas como ejercicio. otro fragmento que puede resultar complicado es la definición de las constantes de código de error, incluidas en la clase argsexception (véase el listado 14-7). listado 14-7 argsexception.java import static com.objectmentor.utilities.args.argsexception.errorcode.*; public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = null; private errorcode errorcode = ok; public argsexception() {} public argsexception(string message) { super(message); } public argsexception(errorcode errorcode) { this.errorcode = errorcode; } public argsexception(errorcode errorcode, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; } public argsexception(errorcode errorcode, char errorargumentid, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; this.errorargumentid = errorargumentid; } public char geterrorargumentid() { return errorargumentid; } public void seterrorargumentid(char errorargumentid) { this.errorargumentid = errorargumentid; 261} public string geterrorparameter() { return errorparameter; } public void seterrorparameter(string errorparameter) { this.errorparameter = errorparameter; } public errorcode geterrorcode() { return errorcode; } public void seterrorcode(errorcode errorcode) { this.errorcode = errorcode; } public string errormessage() { switch (errorcode) { case ok: return “tilt: should not get here.”; case unexpected_argument: return string.format(“argument -%c unexpected.”, errorargumentid); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c.”, errorargumentid); case invalid_argument_name: return string.format(“‘%c’ is not a valid argument name.”, errorargumentid); case invalid_argument_format: return string.format(“‘%s’ is not a valid argument format.”, errorparameter); } return “”; } public enum errorcode { ok, invalid_argument_format, unexpected_argument, invalid_argument_name, missing_string, missing_integer, invalid_integer, missing_double, invalid_double } } 262es sorprendente la cantidad de código necesario para detallar este sencillo concepto. uno de los motivos es el uso de un lenguaje especialmente profuso. java, al ser un lenguaje de tipos estáticos, requiere muchas palabras para satisfacer el sistema de tipos. en lenguajes como ruby, python o smalltalk, este programa es mucho más reducido [92] . vuelva a leer el código. fíjese especialmente en los nombres de los elementos, el tamaño de las funciones y el formato. si tiene experiencia como programador, partes del estilo o la estructura no le convencerán, pero espero que, desde un punto de vista global, considere que el programa está bien escrito y tiene una estructura limpia. por ejemplo, debería ser evidente cómo añadir un nuevo tipo de argumento, como una fecha o un número complejo, y que dicha inclusión apenas requeriría código. en definitiva, bastaría con una nueva variante de argumentmarshaler , una nueva función getxxx y una nueva instrucción case en la función parseschemaelement . también habría un nuevo código argsexception.errorcode y un nuevo mensaje de error. cómo se ha realizado no diseñé este programa de principio a fin en su forma actual y, sobre todo, no espero que pueda crear programas limpios y elegantes a la primera. si algo hemos aprendido en las dos últimas décadas es que la programación es un arte más que una ciencia. para escribir código limpio, primero debe crear código imperfecto y después limpiarlo. no debería sorprenderle. ya lo aprendimos en el colegio cuando los profesores (normalmente en vano) nos obligaban a crear borradores de nuestras redacciones. el proceso, nos decían, era escribir un primer borrador, después otro, y después otros muchos hasta lograr una versión definitiva. para escribir redacciones limpias, el refinamiento debía ser continuado. muchos programadores noveles (como sucede con los alumnos) no siguen este consejo. creen que el objetivo principal es que el programa funcione. una vez que lo consiguen, pasan a la siguiente tarea, y conservan el estado funcional del programa, sea cual sea. los programadores 263experimentados saben que esto es un suicidio profesional. args: el primer borrador el listado 14-8 muestra una versión inicial de la clase args . funciona, pero es un desastre. listado 14-8 args.java (primer borrador) import java.text.parseexception; import java.util.*; public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private map<character, string> stringargs = new hashmap<character, string>(); private map<character, integer> intargs = new hashmap<character, integer>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema. string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { 264} return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)); parsebooleanschemaelement(elementid); else if (isstringschemaelement(elementtail)) parsestringschemaelement(elementid); else if (isintegerschemaelement(elementtail)) { parseintegerschemaelement(elementid); } else { throw new parseexception( string.format(“argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, false); } private void parseintegerschemaelement(char elementid) { intargs.put(elementid, 0); } private void parsestringschemaelement(char elementid) { stringargs.put(elementid, “”); } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } 265private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private boolean isintegerschemaelement(string elementtail) { return elementtail.equals(“#”); } private boolean parsearguments() throws argsexception { for (currentargument = 0; currentargument < args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = errorcode.unexpected_argument; valid = false; } } private boolean setargument(char argchar) throws argsexception { if (isbooleanarg(argchar)) setbooleanarg(argchar, true); else if (isstringarg(argchar)) setstringarg(argchar); else if (isintarg(argchar)) setintarg(argchar); else return false; return true; } private boolean isintarg(char argchar) { return intargs.containskey(argchar); } 266private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.put(argchar, new integer(parameter)); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch (numberformatexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.put(argchar, args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } private boolean isstringarg(char argchar) { return stringargs.containskey(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isbooleanarg(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return "-[" + schema + “]”; else return “”; } 267public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument - %c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“arguments(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } private boolean falseifnull(boolean b) { return b != null && b; } private int zeroifnull(integer i) { return i == null ? 0 : i; } private string blankifnull(string s) { return s = null ? “” : s; } public string getstring(char arg) { return blankifnull(stringargs.get(arg)); } public int getint(char arg) { return zeroifnull(intargs.get(arg)); } public boolean getboolean(char arg) { return falseifnull(booleanargs.get(arg)); } public boolean has(char arg) ( 268return argsfound.contains(arg); } public boolean isvalid() { return valid; } private class argsexception extends exception { } } espero que su reacción inicial ante tal cantidad de código es alegrarse por no haberlo conservado tal cual. si ha sido su reacción, recuerde que será la que tengan otros que lean un borrador de su código. en realidad, primer borrador es lo mejor que se puede decir sobre este código. evidentemente es un trabajo en progreso. la cantidad de variables de instancia es apabullante. cadenas extrañas como « tilt », hashset y treeset , y los bloques try-catch-catch aumentan el desastre. no era mi intención crear este desastre. en realidad, intentaba mantener cierta organización, como demuestra la elección de nombres de funciones y variables, y la estructura del programa. pero es evidente que el problema se me fue de las manos. el desastre aumentó gradualmente. las versiones anteriores no fueron tan malas. por ejemplo, el listado 14-9 muestra una versión inicial en la que sólo funcionaban los argumentos booleanos. listado 14-9 args.java (sólo argumentos booleanos) package com.objectmentor.utilities.getopts; import java.util.*; public class args { private string schema; private string[] args; private boolean valid; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private int numberofarguments = 0; public args(string schema, string[] args) { this.schema = schema; this.args = args; 269valid = parse(); } public boolean isvalid() { return valid; } private boolean parse() { if (schema.length() == 0 && args.length == 0) return true; parseschema(); parsearguments(); return unexpectedarguments.size() == 0; } private boolean parseschema() { for (string element : schema.split(“,”)) { parseschemaelement(element); } return true; } private void parseschemaelement(string element) { if (element.length() == 1) { parsebooleanschemaelement(element); } } private void parsebooleanschemaelement(string element) { char c = element.charat(0); if (character.isletter(c)) { booleanargs.put(c, false); } } private boolean parsearguments() { for (string arg : args) parseargument(arg); return true; } private void parseargument(string arg) { if (arg.startswith(“-”)) parseelement(arg); } private void parseelements(string arg) { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) { if (isboolean(argchar)) { numberofarguments++; setbooleanarg(argchar, true); 270} else unexpectedarguments.add(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return numberofarguments; } public string usage() { if (schema.length() > 0) return “-[”+schema+“]”; else return “”; } public string errormessage() { if (unexpectedarguments.size() > 0) { return unexpectedargumentmessage(); } else return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return booleanargs.get(arg); } } aunque hay motivos para quejarse del código, no es tan malo. es compacto y sencillo, y fácil de entender. sin embargo, en este código se aprecia la semilla del desastre posterior y resulta evidente porqué. la versión posterior sólo tiene dos tipos de argumentos más que ésta: string e integer . la inclusión de sólo dos tipos más tiene un tremendo impacto negativo en el código. lo convierte de algo que sería razonablemente 271mantenible en algo que seguramente esté plagado de errores. añadí los dos tipos de argumento de forma incremental. primero, el argumento string , que genera lo siguiente: listado 14-10 args.java (booleano y string) package com.objectmentor.utilities.getopts; import java.text.parseexception; import java.util.*; public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, boolean> booleanargs = new hashmap<character, boolean>(); private map<character, string> stringargs = new hashmap<character, string>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargument = ‘\0’; enum errorcode { ok, missing_string } private errorcode errorcode = errorcode.ok; public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); parsearguments(); return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; 272} private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) parsebooleanschemaelement(elementid); else if (isstringschemaelement(elementtail)) parsestringschemaelement(elementid); } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private void parsestringschemaelement(char elementid) { stringargs.put(elementid, “”); } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, false); } private boolean parsearguments() { for (currentargument = 0; currentargument < args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } 273private void parseelement(char argchar) { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); valid = false; } } private boolean setargument(char argchar) { boolean set = true; if (isboolean(argchar)) setbooleanarg(argchar, true); else if (isstring(argchar)) setstringarg (argchar, “”); else set = false; return set; } private void setstringarg(char argchar, string s) { currentargument++; try { stringargs.put(argchar, args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargument = argchar; errorcode = errorcode.missing_string; } } private boolean isstring(char argchar) { return stringargs.containskey(argchar); } private void setbooleanarg(char argchar, boolean value) { booleanargs.put(argchar, value); } private boolean isboolean(char argchar) { return booleanargs.containskey(argchar); } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return “-[” + schema + “]”; else return “”; } 274public string errormessage() throws exception { if (unexpectedarguments.size() > 0) { return unexpectedargumentmessage(); } else switch (errorcode) { case missing_string: return string.format (“could not find string parameter for -%c.”, errorargument); case ok: throw new exception(“tilt: should not get here.”); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for (char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { return falseifnull(booleanargs.get(arg)); } private boolean falseifnull(boolean b) { return b == null ? false : b; } public string getstring(char arg) { return blankifnull(stringargs.get(arg)); } private string blankifnull(string s) { return s == null ? “” : s; } public boolean has(char arg) { return argsfound.contains(arg); } public boolean isvalid() { return valid; } } comprobará que empieza a desbocarse. no es terrible pero el desastre se está gestando. basta con incluir el tipo de argumento integer para que resulte fatídico. 275entonces me detuve todavía tenía que añadir otros dos tipos de argumentos y sabía que empeorarían las cosas. si los forzaba, seguramente funcionarían pero provocaría un desastre demasiado complicado de arreglar. si la estructura del código tenía que poder mantenerse, era el momento de corregirla. por ello dejé de añadir elementos y comencé la refactorización. tras añadir los argumentos string e integer , sabía que cada uno necesitaría nuevo código en tres puntos principales. en primer lugar, cada tipo de argumento necesita una forma de analizar su elemento de esquema para poder seleccionar el hashmap de ese tipo. tras ello, sería necesario analizar cada tipo de argumento en las cadenas de línea de comandos y convertirlos en su tipo correcto. por último, cada tipo de argumento necesitaría un método getxxx para poder devolverlo al invocador como su tipo correcto. muchos tipos diferentes y todos con métodos similares, lo que en realidad era una clase. y de este modo nació el concepto de argumentmarshaler . sobre el incrementalismo una de las mejores formas de acabar con un programa es realizar cambios masivos con la intención de mejorarlo. algunos programas nunca se recuperan de estas mejoras. el problema es lo complicado que resulta conseguir que el programa funcione de la misma forma que antes de la mejora. para evitarlo, recurro a la disciplina tdd ( test-driven development o desarrollo guiado por pruebas). una de las doctrinas centrales de este enfoque es mantener la ejecución del sistema en todo momento. es decir, con tdd no puedo realizar cambios que afecten al funcionamiento del sistema. todos los cambios deben mantenerlo como antes de los cambios. para lograrlo, necesito una serie de pruebas automatizadas que ejecutar rápidamente y que verifiquen que el comportamiento del sistema no ha variado. para la clase args , creé una serie de pruebas de unidad y aceptación. las pruebas de unidad se crearon en java y se administraron con junit. las 276pruebas de aceptación se crearon como páginas wiki en fitnesse. podría haber ejecutado estas pruebas en cualquier momento y, si eran satisfactorias, sabría que el sistema funcionaba de la forma especificada. así pues, comencé a realizar pequeños cambios. cada uno desplazaba la estructura del sistema hacia el concepto argumentmarshaler , y cada cambio mantenía el funcionamiento del sistema. el primer cambio realizado fue añadir el esqueleto de argumentmarshaller al final del desastre anterior (véase el listado 14-11). listado 14-11 argumentmarshaller añadido a args.java private class argumentmarshaler { private boolean booleanvalue = false; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } private class booleanargumentmarshaler extends argumentmarshaler { } private class stringargumentmarshaler extends argumentmarshaler { } private class integerargumentmarshaler extends argumentmarshaler { } } evidentemente, esto no afectaría a nada, por lo que realicé la modificación más sencilla posible que afectara a la mínima cantidad de código. cambié hashmap para que los argumentos boolean aceptaran argumentmarshaler . private map<character, argumentmarshaler > booleanargs = new hashmap<character, argumentmarshaler >(); esto afectaba a varias instrucciones que corregí rápidamente. … private void parsebooleanschemaelement(char elementid) { booleanargs.put(elementid, new booleanargumentmarshaler ()); } … 277private void setbooleanarg(char argchar, boolean value) { booleanargs. get (argchar). setboolean (value); } … public boolean getboolean(char arg) { return falseifnull (booleanargs.get(arg). getboolean() ); } estos cambios se aplican a las zonas que mencionamos antes: parse , set y get para el tipo de argumento. desafortunadamente, aunque sean cambios menores, algunas de las pruebas comenzaron a fallar. si se fija atentamente en getboolean , comprobará que se puede invocar con y pero no existe un argumento y , por lo que booleanargs.get(‘y’) devolverá null y la función generará nullpointerexception . la función falseifnull se usa como protección ante este hecho pero el cambio aplicado hace que la función sea irrelevante. el incrementalismo exigía que esto funcionara antes de realizar otros cambios. la solución no era demasiado complicada; bastaba con cambiar la comprobación de null . ya no era necesario comprobar null en boolean, sino en argumentmarshaller . primero, eliminé la invocación de falseifnull en la función getboolean . ya no servía de nada, por lo que eliminé directamente la función. las pruebas seguían fallando igual, lo que suponía que no había nuevos errores. public boolean getboolean(char arg) { return booleanargs.get(arg).getboolean(); } tras ello, dividí la función en dos líneas y añadí argumentmarshaller a una variable propia: argumentmarshaller . no me preocupaba el extenso nombre de la variable; era redundante y estorbaba a la función, por lo que lo reduje a am [n5]. public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am .getboolean(); } y tras ello añadí la lógica de detección de null . public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); 278return am != null && am.getboolean(); } argumentos de cadena la inclusión de los argumentos string fue similar a la de los argumentos boolean . tuve que cambiar hashmap y conseguir que funcionaran parse , set y get . no deberían producirse sorpresas posteriores a excepción de que la implementación completa se incluía en la clase argumentmarshaller en lugar de distribuirla en variantes. private map<character, argumentmarshaler > stringargs = new hashmap<character, argumentmarshaler >(); … private void parsestringschemaelement(char elementid) { stringargs.put(elementid, new stringargumentmarshaler()); } … private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs. get (argchar). setstring (args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring (char arg) { args.argumentmarshaler am = stringargs.get(arg); return am == null ? “” : am.getstring(); } … private class argumentmarshaler { private boolean booleanvalue = false; private string stringvalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { 279stringvalue = s; } public string getstring() { return stringvalue == null ? “” : stringvalue; } } de nuevo, estos cambios se realizaron individualmente para conservar las pruebas, aunque fallaran. si una prueba fallaba, me aseguraba de que fuera correcta antes de continuar con el siguiente cambio. ya debería reconocer mi intención. tras incluir el comportamiento de señalización en la clase base argumentmarshaler , comencé a transferirlo a las variantes, para de esta forma mantener el funcionamiento mientras cambiaba gradualmente la forma del programa. el siguiente paso consistía en transferir la funcionalidad del argumento int a argumentmarshaler . de nuevo, no hubo sorpresas. private map<character, argumentmarshaler > intargs = new hashmap<character, argumentmarshaler >(); … private void parseintegerschemaelement(char elementid) { intargs.put(elementid, new integerargumentmarshaler() ); } … private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs. get (argchar). setinteger (integer.parseint(parameter)); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch (numberformatexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } … public int getint(char arg) { args.argumentmarshaler am = intargs.get(arg); return am == null ? 0 : am.getinteger(); } 280… private class argumentmarshaler { private boolean booleanvalue = false; private string stringvalue; private int integervalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { stringvalue = s; } public string getstring() { return stringvalue == null ? “” : stringvalue; } public void setinteger(int i) { integervalue = i; } public int getinteger() { return integervalue; } } tras transferir la señalización a argumentmarshaler , comencé a transferir la funcionalidad a las variantes. el primer paso fue pasar la función setboolean a booleanargumentmarshaller y garantizar su correcta invocación. para ello creé un método set abstracto. private abstract class argumentmarshaler { protected boolean booleanvalue = false; private string stringvalue; private int integervalue; public void setboolean(boolean value) { booleanvalue = value; } public boolean getboolean() { return booleanvalue; } public void setstring(string s) { stringvalue = s; } public string getstring() { 281return stringvalue == null ? “” : stringvalue; } public void set integer(int i) { integervalue = i; } public int getinteger() { return integervalue; } public abstract void set(string s); } tras ello, implementé el método set en booleanargumentmarshaller . private class booleanargumentmarshaler extends argumentmarshaler { public void set(string s) { booleanvalue = true; } } y por último cambié la invocación de setboolean por la de set . private void setbooleanarg(char argchar, boolean value) { booleanargs.get(argchar). set(“true”) ; } las pruebas seguían siendo satisfactorias. como este cambio hacía que set se implementara en booleanargumentmarshaler , eliminé el método setboolean de la clase base argumentmarshaler . la función abstracta set acepta un argumento string pero la implementación de booleanargumentmarshaler no lo usa. he incluido el argumento porque sabía que stringargumentmarshaler e integerargumentmarshaler lo utilizarían. tras ello, el objetivo era implementar el método get en booleanargumentmarshaler . la implementación de funciones get siempre es escabrosa ya que el tipo devuelto tiene que ser object y en este caso debe convertirse a boolean . public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am != null && (boolean) am. get (); } para compilarlo, añadí la función get a argumentmarshaler . private abstract class argumentmarshaler { … 282public object get() { return null; } } se compila y las pruebas fallan. para que vuelvan a funcionar, basta con convertir get en abstracto e implementarlo en booleanargumentmarshaler . private abstract class argumentmarshaler { protected boolean booleanvalue = false; … public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { public void set (string s) { booleanvalue = true; } public object get() { return booleanvalue; } } de nuevo, las pruebas son satisfactorias. ahora tanto get como set se implementan en booleanargumentmarshaler . esto me permite eliminar la antigua función getboolean de argumentmarshaler , cambiar la variable protegida booleanvalue a booleanargumentmarshaler y convertirla en privada. repetí el mismo patrón de cambios con las cadenas. implementé set y get , eliminé las funciones sin usar y desplacé las variables. private void setstringarg(char argchar) throws argsexception { currentargument++; try { stringargs.get(argchar). set (args[currentargument]); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_string; throw new argsexception(); } } … public string getstring(char arg) { args.argumentmarshaler am = stringargs.get(arg); return am == null ? “” : (string) am. get (); } 283… private abstract class argumentmarshaler { private int integervalue; public void setinteger(int i) { integervalue = i; } public int getinteger() { return integervalue; } public abstract void set(string s); public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(string s) { booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { public void set(string s){ } public object get() { return null; } } } por último, repetí el proceso con los enteros. resulta más complicado ya que los enteros deben analizarse y la operación de análisis puede generar una 284excepción, pero el resultado es más indicado ya que el concepto de numberformatexception se oculta totalmente en integerargumentmarshaler . private boolean isintarg(char argchar) { return intargs.containskey(argchar); } private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.get(argchar). set (parameter); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( argsexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e ; } } … private void setbooleanarg(char argchar) { try { booleanargs.get(argchar).set(“true”); } catch (argsexception e) { } } … public int getint(char arg) { args.argumentmarshaler am = intargs.get(arg); return am == null ? 0 : (integer) am. get (); } … private abstract class argumentmarshaler { public abstract void set(string s) throws argsexception; public abstract object get(); } … private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception s) { throw new argsexception(); } 285} public object get() { return intvalue; } } evidentemente, las pruebas seguían funcionando. tras ello, me deshice de las distintas asignaciones de la parte superior del algoritmo, lo que hace que el sistema sea mucho más genérico. sin embargo, no las puede eliminar ya que afectaría a la integridad del sistema. en su lugar, añadí un nuevo map para argumentmarshaler y, tras ello, cambié uno a uno los métodos para que usaran la nueva asignación en lugar de las originales. public class args { … private map<character, argumentmarshaler> booleanargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … private void parsebooleanschemaelement(char elementid) { argumentmarshaler m = new booleanargumentmarshaler(); booleanargs.put(elementid, m); marshalers.put(elementid, m); } private void parseintegerschemaelement(char elementid) { argumentmarshaler m = new integerargumentmarshaler(); intargs.put(elementid, m); marshalers.put(elementid, m); } private void parsestringschemaelement(char elementid) { argumentmarshaler m = new stringargumentmarshaler(); stringargs.put(elementid, m); marshalers.put(elementid, m); } las pruebas seguían funcionando. tras ello, cambié isbooleanarg de esto: private boolean isbooleanarg(char argchar) { return booleanargs.containskey(argchar); } a este otro: 286private boolean isbooleanarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof booleanargumentmarshaler; } las pruebas funcionaban, por lo que apliqué el mismo cambio en isintarg e isstringarg . private boolean isintarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof integerargumentmarshaler; } private boolean isstringarg(char argchar) { argumentmarshaler m = marshalers.get(argchar); return m instanceof stringargumentmarshaler; } las pruebas eran correctas, por lo que eliminé las invocaciones duplicadas de marshalers.get : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (isbooleanarg( m )) setbooleanarg(argchar); else if (isstringarg( m )) setstringarg(argchar); else if (isintarg( m )) setintarg(argchar); else return false; return true; } private boolean isintarg ( argumentmarshaler m ) { return m instanceof integerargumentmarshaler; } private boolean isstringarg ( argumentmarshaler m ) { return m instanceof stringargumentmarshaler; } private boolean isbooleanarg ( argumentmarshaler m ) { return m instanceof booleanargumentmarshaler; } los tres argumentos isxxxarg ya no tenían sentido, de modo que los reubiqué: private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if ( m instanceof booleanargumentmarshaler ) setbooleanarg(argchar); 287else if ( m instanceof stringargumentmarshaler ) setstringarg(argchar); else if ( m instanceof integerargumentmarshaler ) setintarg(argchar); else return false; return true; } tras ello, empecé a usar la asignación marshalers en las funciones set , dividiendo el uso de las otras tres asignaciones. comencé por los elementos boolean . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m instanceof booleanargumentmarshaler) setbooleanarg( m ); else if (m instanceof stringargumentmarshaler) setstringarg(argchar); else if (m instanceof integerargumentmarshaler) setintarg(argchar); else return false; return true; } … private void setbooleanarg( argumentmarshaler m ) { try { m .set(“true”); // era: booleanargs.get(argchar).set(“true”); } catch (argsexception e) { } } las pruebas seguían siendo correctas de modo que repetí la operación con las cadenas y los enteros. de esta manera se puede integrar parte del desagradable código de gestión de excepciones en la función setargument . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg( m ); else if (m instanceof integerargumentmarshaler) setintarg( m ); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; 288throw e; } return true; } private void setintarg( argumentmarshaler m ) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; m .set(parameter); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg( argumentmarshaler m ) throws argsexception { currentargument++; try { m .set(args[currentargument]); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } ya podía eliminar las tres asignaciones antiguas. primero, debía cambiar la función getboolean de: public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am != null && (boolean) am.get(); } a: public boolean getboolean(char arg) { args.argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } este último cambio puede parecer sorprendente. ¿por qué de repente decidí enfrentarme a classcastexception ? por tener una serie de pruebas de 289unidad y otra serie independiente de pruebas de aceptación creadas en fitnesse. las pruebas de fitnesse garantizan que si se invoca getboolean en un argumento no booleano, se obtiene false . no sucede lo mismo con las pruebas de unidad. hasta el momento, sólo había ejecutado las pruebas de unidad [93] . este último cambio me permitió extraer otro uso de la asignación boolean: private void parsebooleanschemaelement(char elementid) { argumentmarshaler m = new booleanargumentmarshaler(); booleanargs.put(elementid, m); marshalers.put(elementid, m); } y ahora ya podemos eliminar la asignación boolean. public class args { … private map<character, argumentmarshaler> booleanargs = new hashmap<character, argmentmarshaler>(); private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … tras ello, cambié los argumentos string e integer de la misma forma y limpié los valores boolean . private void parsebooleanschemaelement(char elementid) { marshalers.put(elementid, new booleanargumentmarshaler() ); } private void parseintegerschemaelement(char elementid) { marshalers.put(elementid, new integerargumentmarshaler() ); } private void parsestringschemaelement(char elementid) { marshalers.put(elementid, new stringargumentmarshaler() ); } … public string getstring(char arg) { args.argumentmarshaler am = marshalers .get(arg); try { return am null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } 290public int getint(char arg) { args.argumentmarshaler am = marshalers .get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } … public class args { … private map<character, argumentmarshaler> stringargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> intargs = new hashmap<character, argumentmarshaler>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); … seguidamente, dispuse en línea los tres métodos parse ya que no servían para mucho: private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else if (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentmarshaler()); else if (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( “argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } es el momento de ver la estructura completa. el listado 14-12 muestra la clase args actual. listado 14-12 args.java (tras la primera refactorización) package com.objectmentor.utilities.getopts; import java.text.parseexception; import java.util.*; public class args { private string schema; 291private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { } return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else if (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentwarshaler()); else if (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( 292“argument: %c has invalid format: %s.”, elementid, elementtail), 0); } } private void validateschemaelementid(char elementid) throws parseexception { if (!character.isletter(elementid)) { throw new parseexception( “bad character:” + elementid + “in args format: ” + schema, 0); } } private boolean isstringschemaelement(string elementtail) { return elementtail.equals(“*”); } private boolean isbooleanschemaelement(string elementtail) { return elementtail.length() == 0; } private boolean isintegerschemaelement(string elementtail) { return elementtail.equals(“#”); } private boolean parsearguments() throws argsexception { for (currentargument=0; currentargument<args.length; currentargument++) { string arg = args[currentargument]; parseargument(arg); } return true; } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = errorcode.unexpected_argument; valid = false; } } private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); try { 293if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } private void setintarg(argumentmarshaler m) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; m.set(parameter); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg(argumentmarshaler m) throws argsexception { currentargument++; try { m.set (args[currentargument]); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } private void setbooleanarg(argumentmarshaler m) { try { m.set(“true”); } catch (argsexception e) { } } public int cardinality() { return argsfound.size(); } public string usage() { 294if (schema.length() > 0) return = “-[” + schema + “]”; else return “”; } public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); } return “”; } private string unexpectedargumentmessage() { stringbuffer message = new stringbuffer(“argument(s) -”); for {char c : unexpectedarguments) { message.append(c); } message.append(“ unexpected.”); return message.tostring(); } public boolean getboolean(char arg) { args.argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } public string getstring(char arg) { args.argumentmarshaler am = marshalers.get (arg); try { return am == null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } 295public int getint(char arg) { args.argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } public boolean has(char arg) { return argsfound.contains(arg); } public boolean isvalid() { return valid; } private class argsexception extends exception { } private abstract class argumentmarshaler { public abstract void set(string s) throws argsexception; public abstract object get(); } private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(string s) { booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); 296} catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } } tras todo este esfuerzo, es un tanto decepcionante. la estructura ha mejorado pero todavía hay demasiadas variables en la parte superior; se mantiene un terrible caso de tipos en setargument ; y todas las funciones set . sin mencionar el procesamiento de errores. todavía nos queda mucho trabajo por hacer. mi intención es eliminar el caso de tipos de setargument [g23] y que sólo incluya una invocación a argumentmarshaler.set . para ello, debo desplazar setintarg , setstringarg y setbooleanarg a las correspondientes variantes de argumentmarshaler . pero hay un problema. si se fija atentamente en setintarg , comprobará que usa dos variables de instancia: args y currentarg . para desplazar setintarg hasta booleanargumentmarshaler , tengo que pasar args y currentargs como argumentos de función. muy desagradable [f1]. resultaría más indicado pasar un argumento y no dos. afortunadamente, la solución es sencilla. podemos convertir la matriz args en list y pasar iterator a las funciones set . para el siguiente cambio necesité diez pasos, y superar todas las pruebas tras cada uno. pero sólo mostraremos el resultado. debería determinar la mayoría de estos pequeños pasos. public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private iterator<string> currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private list<string> argslist; 297private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument } public args(string schema. string[] args) throws parseexception { this.schema = schema; argslist = arrays.aslist(args); valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && argslist.size() == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { } return valid; } … private boolean parsearguments() throws argsexception { for (currentargument = argslist.iterator(); currentargument. hasnext() ;) { string arg = currentargument. next() ; parseargument(arg); } return true; } … private void setintarg(argumentmarshaler m) throws argsexception { string parameter = null; try { parameter = currentargument. next() ; m.set(parameter); } catch ( nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg(argumentmarshaler m) throws argsexception { try { m.set (currentargument. next() ); } catch ( nosuchelementexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } 298son pequeños cambios que conservan el funcionamiento de las pruebas. ahora podemos empezar a desplazar las funciones set a las correspondientes variantes. primero, debemos realizar el siguiente cambio en setargument : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); else return false; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } es un cambio importante ya que queremos eliminar totalmente la cadena if-else . por tanto, debemos excluir la condición de error. ya podemos empezar a desplazar las funciones set . la función setbooleanarg es trivial, de modo que la prepararemos en primer lugar. el objetivo es cambiar la función setbooleanarg para redirigirla a booleanargumentmarshaler . private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) setbooleanarg(m, currentargument ); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } 299return true; } --- private void setbooleanarg (argumentmarshaler m, iterator<string> currentargument) throws argsexception { try { m.set(“true”); catch (argsexception e) { } } ¿no acabamos de incluir el procesamiento de excepciones? añadir elementos para después excluirlos es habitual en los procesos de refactorización. los pasos reducidos y la necesidad de que las pruebas sigan siendo correctas implican que los elementos cambien de posición. la refactorización es como resolver el cubo de rubik. se necesitan muchos pasos pequeños para lograr un objetivo mayor. cada paso habilita el siguiente. se preguntará por qué pasamos iterator si setbooleanarg no lo necesita. pues porque setintarg y setstringarg sí. y como el objetivo es implementar las tres funciones a través de un método abstracto en argumentmarshaller , es necesario pasarlo a setbooleanarg . ahora setbooleanarg no sirve de nada. si hubiera una función set en argumentmarshaler , podríamos invocarla directamente. es el momento de crear dicha función. el primer paso consiste en añadir el nuevo método abstracto a argumentmarshaler . private abstract class argumentmarshaler { public abstract void set(iterator<string> currentargument) throws argsexception; public abstract void set (string s) throws argsexception; public abstract object get(); } evidentemente, esto afecta a todas las variantes, de modo que implementamos el nuevo método en cada una. private class booleanargumentmarshaler extends argumentmarshaler { private boolean booleanvalue = false; public void set(iterator<string> currentargument) throws argsexception { booleanvalue = true; } public void set(string s) { 300booleanvalue = true; } public object get() { return booleanvalue; } } private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { } public void set(string s) { stringvalue = s; } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { } public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } y ahora ya podemos eliminar setbooleanarg : private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) m.set (currentargument); else if (m instanceof stringargumentmarshaler) setstringarg(m); else if (m instanceof integerargumentmarshaler) setintarg(m); 301} catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } las pruebas siguen siendo satisfactorias y la función set se implementa en boolean argumentmarshaler . podemos repetir la operación con las cadenas y los enteros. private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { if (m instanceof booleanargumentmarshaler) m.set(currentargument); else if (m instanceof stringargumentmarshaler) m.set(currentargument); else if (m instanceof integerargumentmarshaler) m.set(currentargument); } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } return true; } --- private class stringargumentmarshaler extends argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } public void set(string s){ } public object get() { return stringvalue; } } private class integerargumentmarshaler extends argumentmarshaler { 302private int intvalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); set(parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } y el golpe de gracia: se elimina el caso de tipos. private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { m.set(currentargument); return true; } catch (argsexception e) { valid = false; errorargumentid = argchar; throw e; } } ya podemos deshacernos de las funciones de integerargumentmarshaler y limpiar el resto. private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0 public void set (iterator<string> currentargument) throws argsexception { string parameter = null; try { 303parameter = currentargument.next(); intvalue = integer.parseint (parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( numberformatexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw new argsexception(); } } public object get() { return intvalue; } } también podemos convertir argumentmarshaler en una interfaz. private interface argumentmarshaler { void set (iterator<string> currentargument) throws argsexception; object get(); } veamos ahora lo sencillo que resulta añadir un nuevo tipo de argumento a la estructura. apenas necesitaremos cambios y los que apliquemos tendrán que ser aislados. en primer lugar, añadimos un nuevo caso de prueba para comprobar que el argumento double funciona correctamente: public void testsimpledoublepresent() throws exception { args args = new args(“x##”, new string[] {“-x”,“42.3”}); asserttrue(args.isvalid()); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42.3, args.getdouble(‘x’), .001); } limpiamos el código de análisis de esquemas y añadimos la detección ## para el tipo de argumento double . private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (elementtail. length() == 0 ) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail. equals(“*”) ) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail. equals(“#”) ) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); 304else throw new parseexception(string.format( “argument: %c has invalid format: %s.”, elementid, elementtail), 0); } seguidamente, creamos la clase doubleargumentmarshaler . private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception e) { errorcode = errorcode.missing_double; throw new argsexception(); } catch (numberformatexception e) { errorparameter = parameter; errorcode = errorcode.invalid_double; throw new argsexception(); } } public object get() { return doublevalue; } } esto nos obliga a añadir un nuevo código de error ( errorcode ). private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } y necesitamos una función getdouble . public double getdouble(char arg) { args.argumentmarshaler am = marshalers.get(arg); try { return am = null ? 0 : (double) am.get(); } catch (exception e) { return 0.0; } } y todas las pruebas son correctas. ha sido sencillo. a continuación comprobamos que el procesamiento de errores funciona correctamente. el siguiente caso de prueba comprueba que se declare un error si se proporciona 305una cadena que no se puede analizar a un argumento ##. public void testinvaliddouble() throws exception { args args = new args(“x##”, new string[] {“-x”, “forty two”}); assertfalse(args.isvalid()); assertequals(0, args.cardinality()); assertfalse(args.has(‘x’)); assertequals(0, args.getint(‘x’)); assertequals(“argument -x expects a double but was ‘forty two’.”, args.errormessage()); } --- public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return unexpectedargumentmessage(); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c”, errorargumentid); } return “”; } y las pruebas son satisfactorias. la siguiente prueba garantiza que se detecte correctamente la ausencia de un argumento double . public void testmissingdouble() throws exception { args args = new args(“x##”, new string[]{"-x"}); assertfalse (args.isvalid()); assertequals(0, args.cardinality()); assertfalse(args.has(‘x’)); assertequals(0.0, args.getdouble(‘x’), 0.01); assertequals(“could not find double parameter for -x.”, args.errormessage()); } es correcto. la incluimos para que el ejemplo resulte más completo. el código de excepciones no es atractivo y no pertenece realmente a la 306clase args . también generamos parseexception , que no nos pertenece. por ello, combinamos todas las excepciones en una única clase argsexception y la incluimos en su propio módulo. public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; public argsexception() {} public argsexception(string message) { super(message); } public enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument, missing_double, invalid_double } } … public class args { … private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private argsexception .errorcode errorcode = argsexception .errorcode.ok; private list<string> argslist; public args(string schema, string[] args) throws argsexception { this.schema = schema; argslist = arrays.aslist(args); valid = parse(); } private boolean parse() throws argsexception { if (schema.length() == 0 && argslist.size() == 0) return true; parseschema(); try { parsearguments(); } catch ( argsexception e) { } return valid; } private boolean parseschema() throws argsexception { … } private void parseschemaelement(string element) throws argsexception { … else throw new argsexception ( string.format(“argument: %c has invalid format: %s.”, elementid, elementtail)); } 307private void validateschemaelementid(char elementid) throws argsexception { if (!character.isletter(elementid)) { throw new argsexception ( “bad character:” + elementid + “in args format: ” + schema); } } … private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { unexpectedarguments.add(argchar); errorcode = argsexception .errorcode.unexpected_argument; valid = false; } } … private class stringargumentmarshaler implements argumentmarshaler { private string stringvalue = “”; public void set(iterator<string> currentargument) throws argsexception { try { stringvalue = currentargument.next(); } catch (nosuchelementexception e) { errorcode = argsexception .errorcode.missing_string; throw new argsexception(); } } public object get() { return stringvalue; } } private class integerargumentmarshaler implements argumentmarshaler { private int intvalue = 0; public void set (iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); intvalue = integer.parseint(parameter); } catch (nosuchelementexception e) { errorcode = argsexception.errorcode.missing_integer; throw new argsexception (); } catch (numberformatexception e) { errorparameter = parameter; errorcode = argsexception .errorcode.invalid_integer; throw new argsexception (); 308} } public object get() { return intvalue; } } private class doubleargumentmarshaler implements argumentmarshaler { private double doublevalue = 0; public void set(iterator<string> currentargument) throws argsexception { string parameter = null; try { parameter = currentargument.next(); doublevalue = double.parsedouble(parameter); } catch (nosuchelementexception e) { errorcode = argsexception .errorcode.missing_double; throw new argsexception(); } catch (numberformatexception e) { errorparameter = parameter; errorcode = argsexception .errorcode.invalid_double; throw new argsexception); } } public object get() { return doublevalue; } } } muy bien. ahora, args solamente genera argsexception . al desplazar argsexception a un módulo propio, podemos añadir a dicho módulo gran parte del código de error y extraerlo del módulo args . es una posición natural y evidente para incluir todo el código y nos permitirá limpiar posteriormente el módulo args . ya hemos separado el código de excepciones y de error del módulo args (véanse los listados del 14-13 al 14-16). para ello realizamos una serie de 30 pasos mínimos y las pruebas fueron satisfactorias entre todos ellos. listado 14-13 argstest.java. package com.objectmentor.utilities.args; import junit.framework.testcase; 309public class argstest extends testcase { public void testcreatewithnoschemaorarguments() throws exception { args args = new args(“”, new string[0]); assertequals(0, args.cardinality()); } public void testwithnoschemabutwithoneargument() throws exception { try { new args(“”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.unexpected_argument, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testwithnoschemabutwithmultiplearguments() throws exception { try { new args(“”, new string[]{“-x”, “-y”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.unexpected_argument, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testnonletterschema() throws exception { try { new args(“*”, new string[]{}); fail(“args constructor should have thrown exception”); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_argument_name, e.geterrorcode()); assertequals(‘*’, e.geterrorargumentid()); } } public void testinvalidargumentformat() throws exception { try { new args(“f~”, new string[]{}); fail(“args constructor should have throws exception”); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_format, e.geterrorcode()); assertequals(‘f’, e.geterrorargumentid()); } } public void testsimplebooleanpresent() throws exception { args args = new args(“x”, new string []{“-x”}); assertequals(1, args.cardinality()); assertequals(true, args.getboolean(‘x’)); 310} public void testsimplestringpresent() throws exception { args args = new args(“x*”, new string[]{“-x”, “param”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(“param”, args.getstring(‘x’)); } public void testmissingstringargument() throws exception { try { new args(“x*”, new string[]{"-x"}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_string, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } public void testspacesinformat() throws exception { args args = new args(“x, y”, new string[]{“-xy”}); assertequals(2, args.cardinality()); asserttrue(args.has(‘x’)); asserttrue(args.has(‘y’)); } public void testsimpleintpresent() throws exception { args args = new args(“x#”, new string[]{“-x”, “42”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42, args.getint(‘x’)); } public void testinvalidinteger() throws exception { try { new args(“x#”, new string[] {“-x”, “forty two”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_integer, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); assertequals(“forty two”, e.geterrorparameter()); } } public void testmissinginteger() throws exception { try { new args(“x#”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_integer, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } 311public void testsimpledoublepresent() throws exception { args args = new args(“x##”, new string[](“-x”, “42.3”}); assertequals(1, args.cardinality()); asserttrue(args.has(‘x’)); assertequals(42.3, args.getdouble(‘x’), .001); } public void testinvaliddouble() throws exception { try { new args(“x##”, new string []{“-x”, “forty two”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.invalid_double, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); assertequals(“forty two”, e.geterrorparameter()); } } public void testmissingdouble() throws exception { try { new args(“x##”, new string[]{“-x”}); fail(); } catch (argsexception e) { assertequals(argsexception.errorcode.missing_double, e.geterrorcode()); assertequals(‘x’, e.geterrorargumentid()); } } } listado 14-14 argsexceptiontest.java. public class argsexceptiontest extends testcase { public void testunexpectedmessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.unexpected_argument, ‘x’, null); assertequals(“argument -x unexpected.”, e.errormessage()); } public void testmissingstringmessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_string, ‘x’, null); assertequals(“could not find string parameter for –x.”, e.errormessage()); } public void testinvalidintegermessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.invalid_integer, 312‘x’, “forty two”); assertequals(“argument –x expects an integer but was ‘forty two’.”, e.errormessage()); } public void testmissingintegermessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_integer, ‘x’, null); assertequals(“could not find integer parameter for -x.”, e.errormessage()); } public void testinvaliddoublemessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.invalid_double, ‘x’, “forty two”); assertequals(“argument -x expects a double but was ‘forty two’.”, e.errormessage()); } public void testmissingdoublemessage() throws exception { argsexception e = new argsexception(argsexception.errorcode.missing_double, ‘x’, null); assertequals(“could not find double parameter for -x.”, e.errormessage()); } } listado 14-15 argsexception.java. public class argsexception extends exception { private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; public argsexception() {} public argsexception(string message) {super(message);} public argsexception(errorcode errorcode) { this.errorcode = errorcode; } public argsexception(errorcode errorcode, string errorparameter) { this.errorcode = errorcode; this.errorparameter = errorparameter; } public argsexception(errorcode errorcode, char errorargumentid, string errorparameter) { this.errorcode = errorcode; 313this.errorparameter = errorparameter; this.errorargumentid = errorargumentid; } public char geterrorargumentid() { return errorargumentid; } public void seterrorargumentid(char errorargumentid) { this.errorargumentid = errorargumentid; } public string geterrorparameter() { return errorparameter; } public void seterrorparameter(string errorparameter) { this.errorparameter = errorparameter; } public errorcode geterrorcode() { return errorcode; } public void seterrorcode(errorcode errorcode) { this.errorcode = errorcode; } public string errormessage() throws exception { switch (errorcode) { case ok: throw new exception(“tilt: should not get here.”); case unexpected_argument: return string.format(“argument -%c unexpected.”, errorargumentid); case missing_string: return string.format(“could not find string parameter for -%c.”, errorargumentid); case invalid_integer: return string.format(“argument -%c expects an integer but was ‘%s’.”, errorargumentid, errorparameter); case missing_integer: return string.format(“could not find integer parameter for -%c.”, errorargumentid); case invalid_double: return string.format(“argument -%c expects a double but was ‘%s’.”, errorargumentid, errorparameter); case missing_double: return string.format(“could not find double parameter for -%c.”, errorargumentid); } return “”; } public enum errorcode { ok, invalid_format, unexpected_argument, invalid_argument_name, 314missing_string, missing_integer, invalid_integer, missing_double, invalid_double} } listado 14-16 args.java. public class args { private string schema; private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private iterator<string> currentargument; private list<string> argslist; public args(string schema, string[] args) throws argsexception { this.schema = schema; argslist = arrays.aslist(args); parse(); } private void parse() throws argsexception { parseschema(); parsearguments(); } private boolean parseschema() throws argsexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { parseschemaelement(element.trim()); } } return true; } private void parseschemaelement(string element) throws argsexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (elementtail.length() == 0) marshalers.put(elementid, new booleanargumentmarshaler()); else if (elementtail.equals(“*”)) marshalers.put(elementid, new stringargumentmarshaler()); else if (elementtail.equals(“#”)) marshalers.put(elementid, new integerargumentmarshaler()); else if (elementtail.equals(“##”)) marshalers.put(elementid, new doubleargumentmarshaler()); else throw new argsexception(argsexception.errorcode.invalid_format, elementid, elementtail); } 315private void validateschemaelementid(char elementid) throws argsexception { if (!character.isletter(elementid)) { throw new argsexception(argsexception.errorcode.invalid_argument_name, elementid, null); } } private void parsearguments() throws argsexception { for (currentargument = argslist.iterator(); currentargument.hasnext();) { string arg = currentargument.next(); parseargument(arg); } } private void parseargument(string arg) throws argsexception { if (arg.startswith(“-”)) parseelements(arg); } private void parseelements(string arg) throws argsexception { for (int i = 1; i < arg.length(); i++) parseelement(arg.charat(i)); } private void parseelement(char argchar) throws argsexception { if (setargument(argchar)) argsfound.add(argchar); else { throw new argsexception(argsexception.errorcode.unexpected_argument, argchar, null); } } private boolean setargument(char argchar) throws argsexception { argumentmarshaler m = marshalers.get(argchar); if (m == null) return false; try { m.set(currentargument); return true; } catch (argsexception e) { e.seterrorargumentid(argchar); throw e; } } public int cardinality() { return argsfound.size(); } public string usage() { if (schema.length() > 0) return "-[" + schema + “]”; 316else return “”; } public boolean getboolean(char arg) { argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } public string getstring(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? “” : (string) am.get(); } catch (classcastexception e) { return “”; } } public int getint(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (integer) am.get(); } catch (exception e) { return 0; } } public double getdouble(char arg) { argumentmarshaler am = marshalers.get(arg); try { return am == null ? 0 : (double) am.get(); } catch (exception e) { return 0.0; } } public boolean has(char arg) { return argsfound.contains(arg); } } la mayoría de los cambios realizados en la clase args han sido eliminaciones. gran parte del código se extrajo de args y se añadió a argsexception . perfecto. también cambiamos todos los elementos argumentmarshaller a sus propios archivos. mejor todavía. 317el diseño de software correcto se basa gran parte en las particiones, en crear zonas adecuadas para incluir distintos tipos de código. esta separación hace que el código sea más fácil de entender y mantener. especialmente interesante es el método errormessage de argsexception . incumple claramente el srp al incluir el formato de mensajes de error en args . args debe centrarse en el procesamiento de argumentos, no en el formato de los mensajes de error. sin embargo, ¿realmente tiene sentido incluir el código de formato de mensajes de error en argsexception ? francamente es un compromiso. los usuarios que no deseen los mensajes de error proporcionados por argsexception tendrán que crear los suyos propios, pero la utilidad de mensajes de error ya preparados es evidente. ya debería haberse dado cuenta de la distancia recorrida con respecto a la solución mostrada al inicio del capítulo. las transformaciones finales puede examinarlas por su cuenta. conclusión no basta con que el código funcione. el código que funciona suele ser incorrecto. los programadores que se conforman con código funcional no se comportan de forma profesional. puede que teman que no tienen tiempo para mejorar la estructura y el diseño del código, pero discrepo. no hay nada que afecte más negativamente a un proyecto de desarrollo que el código incorrecto. los plazos incorrectos se pueden rehacer y los requisitos equivocados se pueden volver a definir. la dinámica incorrecta de un equipo se puede reparar pero el código incorrecto se corrompe y se convierte en una carga que arrastra al equipo completo. he visto equipos dominados por el desastre que han generado y que han dominado su destino. evidentemente, el código incorrecto se puede limpiar pero resulta muy costoso. cuando el código se corrompe los módulos se insinúan unos a otros y generan multitud de dependencias ocultas y entrelazadas. la localización y división de dependencias antiguas es una tarea larga y complicada. por otra parte, resulta relativamente sencillo mantener código limpio. si comete un error en un módulo, es más fácil limpiarlo directamente. mejor todavía, si 318cometió un error hace cinco minutos, es muy fácil limpiarlo ahora. por tanto, la solución consiste en mantener el código limpio y sencillo siempre que se pueda y no dejar que llegue a corromperse. 31915 aspectos internos de junit 320junit es una de las estructuras de java más conocidas. de concepción sencilla, definición precisa y documentación elegante. ¿y su código? en este capítulo analizaremos un ejemplo extraído de la estructura junit. la estructura junit junit ha tenido muchos autores, comenzando por kent beck y eric gamma en un vuelo a atlanta. kent quería aprender java y eric quería saber más sobre la estructura de pruebas smalltalk de kent. “¿hay algo más natural que 321dos fanáticos enciendan sus portátiles y empiecen a escribir código?” [94] tras tres horas de trabajo de altura, habían creado los fundamentos de junit. el módulo que analizaremos es un inteligente fragmento de código que permite identificar errores de comparación de cadenas. el nombre del módulo es comparisoncompactor . dadas dos cadenas diferentes, como abcde y abxde , muestra la diferencia entre ambas generando una cadena como <… b[x]d…> . podríamos explicarlo más, pero los casos de prueba son mejores. fíjese en el listado 15-1 para comprender los requisitos de este módulo. analice la estructura de las pruebas. ¿podrían ser más simples o más evidentes? listado 15-1 comparisoncompactortest.java. package junit.tests.framework; import junit.framework.comparisoncompactor; import junit.framework.testcase; public class comparisoncompactortest extends testcase { public void testmessage() { string failure= new comparisoncompactor(0, “b”, “c”).compact(“a”); asserttrue(“a expected:<[b]> but was:<[c]>”.equals(failure)); } public void teststartsame() { string failure= new comparisoncompactor(1, “ba”, “bc”).compact(null); assertequals(“expected:<b[a]> but was:<b[c]>”, failure); } public void testendsame() { string failure= new comparisoncompactor(1, “ab”, “cb”).compact(null); assertequals(“expected:<[a]b> but was:<[c]b>”, failure); } public void testsame() { string failure= new comparisoncompactor(1, “ab”, “ab”).compact(null); assertequals(“expected:<ab> but was:<ab>”, failure); } public void testnocontextstartandendsame() { string failure= new comparisoncompactor(0, “abc”, “adc”).compact(null); assertequals(“expected:<…[b]…> but was:<…[d]…>”, failure); } 322public void teststartandendcontext() { string failure= new comparisoncompactor(1, “abc”, “adc”).compact(null); assertequals(“expected:<a[b]c> but was:<a[d]c>”, failure); } public void teststartandendcontextwithellipses() { string failure= new comparisoncompactor(1, “abcde”, “abfde”).compact(null); assertequals(“expected:<…b[c]d…> but was:<…b[f]d…>”, failure); } public void testcomparisonerrorstartsamecomplete() { string failure= new comparisoncompactor(2, “ab”, “abc”).compact(null); assertequals(“expected:<ab[]> but was:<ab[c]>”, failure); } public void testcomparisonerrorendsamecomplete() { string failure= new comparisoncompactor(0, “bc”, “abc”).compact(null); assertequals(“expected:<[]…> but was:<[a]…>”, failure); } public void testcomparisonerrorendsamecompletecontext() { string failure= new comparisoncompactor(2, “bc”, “abc”).compact(null); assertequals(“expected:<[]bc> but was:<[a]bc>”, failure); } public void testcomparisonerroroverlapingmatches() { string failure= new comparisoncompactor(0, “abc”, “abbc”).compact(null); assertequals(“expected:<…[]…> but was:<…[b]…>”, failure); } public void testcomparisonerroroverlapingmatchescontext() { string failure= new comparisoncompactor(2, “abc”, “abbc”).compact(null); assertequals(“expected:<ab[]c> but was:<ab[b]c>”, failure); } public void testcomparisonerroroverlapingmatches2() { string failure= new comparisoncompactor(0, “abcdde”, “abcde”).compact(null); assertequals(“expected:<…[d]…> but was:<…[]…>”, failure); } public void testcomparisonerroroverlapingmatches2context() { string failure= new comparisoncompactor(2, “abcdde”, “abcde”).compact(null); assertequals(“expected:<…cd[d]e> but was:<…cd[]e>”, failure); } public void testcomparisonerrorwithactualnull() { string failure= new comparisoncompactor(0, “a”, null).compact(null); assertequals(“expected:<a> but was:<null>”, failure); } public void testcomparisonerrorwithactualnullcontext() { string failure= new comparisoncompactor(2, “a”, null).compact(null); 323assertequals(“expected:<a> but was:<null>”, failure); } public void testcomparisonerrorwithexpectednull() { string failure= new comparisoncompactor(0, null, “a”).compact(null); assertequals(“expected:<null> but was:<a>”, failure); } public void testcomparisonerrorwithexpectednullcontext() { string failure= new comparisoncompactor(2, null, “a”).compact(null); assertequals(“expected:<null> but was:<a>”, failure); } public void testbug609972() { string failure= new comparisoncompactor(10, “s&p500”, “0”).compact(null); assertequals(“expected:<[s&p50]0> but was:<[]0>”, failure); } } realicé un análisis de alcance de código en comparisoncompactor con estas pruebas. el código se cubre en un 100 por 100. cada línea, cada instrucción if y cada bucle for se ejecuta con las pruebas. de este modo sé que el código funciona y sus autores me merecen el mayor de los respetos. el código comparisoncompactor se reproduce en el listado 15-2. examínelo. creo que lo encontrará bien distribuido, razonablemente expresivo y estructuralmente sencillo. cuando termine, lo diseccionaremos. listado 15-2 comparisoncompactor.java (original). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int fcontextlength; private string fexpected; private string factual; private int fprefix; private int fsuffix; public comparisoncompactor(int contextlength, string expected, string actual) { fcontextlength = contextlength; fexpected = expected; 324factual = actual; } public string compact(string message) { if (fexpected == null || factual == null || arestringsequal()) return assert.format(message, fexpected, factual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(fexpected); string actual = compactstring(factual); return assert.format(message, expected, actual); } private string compactstring(string source) { string result = delta_start + source.substring(fprefix, source.length() - fsuffix + 1) + delta_end; if (fprefix > 0) result = computecommonprefix() + result; if (fsuffix > 0) result = result + computecommonsuffix(); return result; } private void findcommonprefix() { fprefix = 0; int end = math.min(fexpected.length(), factual.length()); for (; fprefix < end; fprefix++) { if (fexpected.charat(fprefix) != factual.charat(fprefix)) break; } } private void findcommonsuffix() { int expectedsuffix = fexpected.length() - 1; int actualsuffix = factual.length() - 1; for (; actualsuffix >= fprefix && expectedsuffix >= fprefix; actualsuffix--, expectedsuffix--) { if (fexpected.charat(expectedsuffix) != factual.charat(actualsuffix)) break; } fsuffix = fexpected.length() - expectedsuffix; } private string computecommonprefix() { return (fprefix > fcontextlength ? ellipsis : “”) + fexpected.substring(math.max(0, fprefix - fcontextlength), fprefix); } private string computecommonsuffix() { int end = math.min(fexpected.length() - fsuffix + 1 + fcontextlength, fexpected.length()); 325return fexpected.substring(fexpected.length() - fsuffix + 1, end) + (fexpected.length() - fsuffix + 1 < fexpected.length() - fcontextlength ? ellipsis : “”); } private boolean arestringsequal() { return fexpected.equals(factual); } } puede que tenga varias quejas sobre el módulo. incluye expresiones extensas y extraños elementos +1 . pero en general, está bastante bien. después de todo, podría haber sido como el listado 15-3. listado 15-3 comparisoncompator.java (defactorizado) package junit.framework; public class comparisoncompactor { private int ctxt; private string s1; private string s2; private int pfx; private int sfx; public comparisoncompactor(int ctxt, string s1, string s2) { this.ctxt = ctxt; this.s1 = s1; this.s2 = s2; } public string compact(string msg) { if (s1 == null || s2 == null || s1.equals(s2)) return assert.format(msg, s1, s2); pfx = 0; for (; pfx < math.min(s1.length(), s2.length()); pfx++) { if (s1.charat(pfx) != s2.charat(pfx)) break; } int sfx1 = s1.length() - 1; int sfx2 = s2.length() - 1; for (; sfx2 >= pfx && sfx1 >= pfx; sfx2--, sfx1--) { if (s1.charat(sfx1) != s2.charat(sfx2)) break; } sfx = s1.length() - sfx1; string cmp1 = compactstring(s1); string cmp2 = compactstring(s2); return assert.format(msg, cmp1, cmp2); 326} private string compactstring(string s) { string result = “[” + s.substring(pfx, s.length() - sfx + 1) + “]”; if (pfx > 0) result = (pfx > ctxt ? “…” : “”) + s1.substring(math.max(0, pfx - ctxt), pfx) + result; if (sfx > 0) { int end = math.min(s1.length() - sfx + 1 + ctxt, s1.length()); result = result + (s1.substring(s1.length() - sfx + 1, end) + (s1.length() - sfx + 1 < s1.length() - ctxt ? “…” : “”)); } return result; } } aunque los autores hicieron un buen trabajo con este módulo, la regla del boy scout [95] muestra que podrían haberlo dejado más limpio de lo que se encontró. ¿cómo podemos mejorar el código original del listado 15-2? lo primero que no necesitamos es el prefijo f de las variables miembro [n6]. los entornos actuales hacen que este tipo de código de ámbito sea redundante, por lo que eliminaremos todas las f . private int contextlength; private string expected; private string actual; private int prefix; private int suffix; tras ello, tenemos una condicional sin encapsular al inicio de la función compact [g28]. public string compact(string message) { if (expected == null || actual == null || arestringsequal()) return assert.format(message, expected, actual); findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } es necesario encapsular esta condicional para que nuestra intención sea más clara. por tanto, extraemos un método que la explique. public string compact(string message) { if ( shouldnotcompact() ) return assert.format(message, expected, actual); 327findcommonprefix(); findcommonsuffix(); string expected = compactstring(this.expected); string actual = compactstring(this.actual); return assert.format(message, expected, actual); } private boolean shouldnotcompact() { return expected == null || actual == null || arestringsequal(); } en la función compact , this.expected y this.actual no son demasiado relevantes. sucede al cambiar el nombre de fexpected por expected . ¿por qué esta función tiene variables con los mismos nombres que las variables miembro? ¿no representan cosas diferentes?[n4]. los nombres deben ser exclusivos. string compactexpected = compactstring( expected ); string compactactual = compactstring( actual ); los negativos son más difíciles de entender que los positivos [g29]. por ello, invertimos esa instrucción if para cambiar el sentido de la condicional. public string compact(string message) { if ( canbecompacted() ) { findcommonprefix(); findcommonsuffix(); string compactexpected = compactstring(expected); string compactactual = compactstring(actual); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private boolean canbecompacted () { return expected != null && actual != null && !arestringsequal(); } el nombre de la función es extraño [n7]. aunque compacta las cadenas, puede que lo haga si canbecompacted devuelve false . al asignar el nombre compact a esta función se oculta el efecto secundario de la comprobación de errores. además, la función devuelve un mensaje con formato, no sólo las cadenas compactadas. por tanto, el nombre de la función debería ser formatcompactedcomparison . de esta forma, se lee mejor junto al argumento de la función: 328public string formatcompactedcomparison(string message) { el cuerpo de la instrucción if es donde se realiza la verdadera compactación de las cadenas. debemos extraerlo como método con el nombre compactexpectedandactual . sin embargo, queremos que la función formatcompactedcomparison realice todo el formato. la función compact … sólo debe realizar la compactación [g30], de modo que la dividimos de esta forma: … private string compactexpected; private string compactactual; … public string formatcompactedcomparison(string message) { if (canbecompacted()) { compactexpectedandactual(); return assert.format(message, compactexpected, compactactual); } else { return assert.format(message, expected, actual); } } private void compactexpectedandactual () { findcommonprefix(); findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } para ello, hemos tenido que ascender compactexpected y compactactual a variables miembro. no me gusta la forma en que las dos últimas líneas de la nueva función devuelven variables pero las dos primeras no lo hacen. no utilizan convenciones coherentes [g11]. debemos cambiar findcommonprefix y findcommonsuffix para que devuelvan los valores de prefijo y sufijo. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonprefix() { int prefix index = 0; int end = math.min(expected.length(), actual.length()); for (; prefix index < end; prefix index ++) { 329if (expected.charat(prefix index ) != actual.charat(prefix index )) break; } return prefixindex; } private int findcommonsuffix() { int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefix index && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix--) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } también debemos cambiar los nombres de las variables miembro para que sean más preciosas [n1], ya que en el fondo son índices. al examinar findcommonsuffix vemos una conexión temporal oculta [g31]; depende de que prefixindex se calcule por findcommonprefix . si estas dos funcione se invocan de forma desordenada, la sesión de depuración posterior sería complicada. por ello, para mostrar esta combinación temporal, haremos que findcommonsuffix acepte prefixindex como argumento. private void compactexpectedandactual() { prefixindex = findcommonprefix(); suffixindex = findcommonsuffix( prefixindex ); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private int findcommonsuffix( int prefixindex ) { int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefixindex && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix--) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } return expected.length() - expectedsuffix; } no me convence del todo. el hecho de pasar prefixindex como argumento es un tanto arbitrario [g32]. permite establecer el orden pero no explica la necesidad del mismo. otro programador podría deshacer esta operación ya que no se indica en ningún momento para qué sirve el parámetro. adoptemos un enfoque diferente. 330private void compactexpectedandactual() { findcommonprefixandsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private void findcommonprefixandsuffix () { findcommonprefix(); int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefixindex && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix-- ) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } suffixindex = expected.length() - expectedsuffix; } private void findcommonprefix() { prefixindex = 0; int end = math.min(expected.length(), actual.length()); for (; prefixindex < end; prefixindex++) if (expected.charat(prefixindex) != actual.charat(prefixindex)) break; } devolvemos findcommonprefix y findcommonsuffix a su posición original, cambiamos el nombre de findcommonsuffix por findcommonprefixandsuffix y hacemos que invoque findcommonprefix antes de hacer nada más. de ese modo se establece la naturaleza temporal de ambas funciones de forma más evidente que antes. además, se muestra el mínimo atractivo de findcommonprefixandsuffix , que limpiaremos a continuación: private void findcommonprefixandsuffix() { findcommonprefix(); int suffixlength = 1; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } suffixindex = suffixlength; } private char charfromend(string s, int i) { return s.charat(s.length()-i);} private boolean suffixoverlapsprefix(int suffixlength) { 331return actual.length() - suffixlength < prefixlength || expected.length() - suffixlength < prefixlength; } mucho mejor. muestra que suffixindex es en realidad la longitud del sufijo y que su nombre no es correcto. lo mismo sucede con prefixindex , aunque en ese caso índice y longitud son sinónimos. incluso así, es más coherente usar length . el problema es que la variable suffixindex no es de base cero, sino de base 1 y no es una verdadera longitud. éste es el motivo de la abundancia de +1 en computecommonsuffix [g33]. lo corregimos. en el listado 15-4 puede ver el resultado. listado 15-4 comparisoncompactor.java (versión intermedia). public class comparisoncompactor { … private int suffixlength ; … private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = 0; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } } private char charfromend(string s, int i) { return s.charat(s.length() - i - 1 ); } private boolean suffixoverlapsprefix(int suffixlength) { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } … private string compactstring(string source) { string result = delta_start + source.substring(prefixlength, source.length() - suffixlength ) + delta_end; if (prefixlength > 0) result = computecommonprefix() + result; if ( suffixlength > 0) 332result = result + computecommonsuffix(); return result; } … private string computecommonsuffix() { int end = math.min(expected.length() - suffixlength + contextlength, expected.length() ); return expected.substring(expected.length() - suffixlength , end) + (expected.length() - suffixlength < expected.length() - contextlength ? ellipsis : “”); } cambiamos +1 en computecommonsuffix por un -1 en charfromend, donde tiene sentido, y dos operadores <= en suffixoverlapsprefix , totalmente correctos. de este modo podemos cambiar el nombre de suffixindex por suffixlength , lo que mejora considerablemente la legibilidad del código. pero hay un problema. al comenzar a eliminar los +1 , me fijé en la siguiente línea de compactstring : if (suffixlength > 0) búsquela en el listado 15-4. como ahora suffixlength es una unidad menos que antes, debemos cambiar el operador > por >= . pero eso no tiene sentido. ahora sí. significa que no tenía sentido antes y que seguramente fuera un error. bueno, no del todo. tras un análisis detallado, vemos que ahora la instrucción if impide que se añada un sufijo de longitud cero. antes de realizar el cambio, la instrucción if no funcionaba ya que suffixindex nunca podía ser menos de uno. esto cuestiona ambas instrucciones if en compactstring . parece como si se pudieran eliminar. por ello, las comentamos y ejecutamos las pruebas. satisfactorias. reestructuremos compactstring para eliminar las instrucciones if sobrantes y simplificar la función [g9]. private string compactstring(string source) { return computecommonprefix() + delta_start + source.substring(prefixlength, source.length() - suffixlength) + 333delta_end + computecommonsuffix(); } mucho mejor. ahora vemos que la función compactstring simplemente combina los fragmentos. probablemente lo podríamos limpiar más, en pequeñas operaciones, pero en lugar de desarrollar el resto de los cambios, mostraremos el resultado final en el listado 15-5. listado 15-5 comparisoncompactor.java (versión definitiva). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int contextlength; private string expected; private string actual; private int prefixlength; private int suffixlength; public comparisoncompactor( int contextlength, string expected, string actual ) { this.contextlength = contextlength; this.expected = expected; this.actual = actual; } public string formatcompactedcomparison(string message) { string compactexpected = expected; string compactactual = actual; if (shouldbecompacted()) { findcommonprefixandsuffix(); compactexpected = compact(expected); compactactual = compact(actual); } return assert.format(message, compactexpected, compactactual); } private boolean shouldbecompacted() { return !shouldnotbecompacted(); } private boolean shouldnotbecompacted() { return expected == null || 334actual == null || expected.equals(actual); } private void findcommonprefixandsuffix() { findcommonprefix(); suffixlength = 0; for (; !suffixoverlapsprefix(); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength) ) break; } } private char charfromend(string s, int i) { return s.charat(s.length() - i - 1); } private boolean suffixoverlapsprefix() { return actual.length() - suffixlength <= prefixlength || expected.length() - suffixlength <= prefixlength; } private void findcommonprefix() { prefixlength = 0; int end = math.min(expected.length(), actual.length()); for (; prefixlength < end; prefixlength++) if (expected.charat(prefixlength) != actual.charat(prefixlength)) break; } private string compact(string s) { return new stringbuilder() .append(startingellipsis()) .append(startingcontext()) .append(delta_start) .append(delta(s)) .append(delta_end) .append(endingcontext()) .append(endingellipsis()) .tostring(); } private string startingellipsis() { return prefixlength > contextlength ? ellipsis : “”; } private string startingcontext() { int contextstart = math.max(0, prefixlength - contextlength); int contextend = prefixlength; return expected.substring(contextstart, contextend); } private string delta(string s) { 335int deltastart = prefixlength; int deltaend = s.length() - suffixlength; return s.substring(deltastart, deltaend); } private string endingcontext() { int contextstart = expected.length() - suffixlength; int contextend = math.min(contextstart + contextlength, expected.length()); return expected.substring(contextstart, contextend); } private string endingellipsis() { return (suffixlength > contextlength ? ellipsis : “”); } } bastante atractivo. el módulo se separa en un grupo de funciones de análisis y otro grupo de funciones de síntesis. se ordenan topológicamente para que la definición de cada función aparezca donde realmente se usa. primero se muestran las funciones de análisis y después las de síntesis. si se fija atentamente, verá que he invertido algunas de las decisiones adoptadas inicialmente. por ejemplo, he añadido algunos métodos extraídos a formatcompactedcomparison y he modificado el sentido de la expresión shouldnotbecompacted . es algo habitual. a menudo, un cambio de refactorización lleva a otro que a su vez lleva a deshacer el primero. la refactorización es un proceso iterativo de ensayo y error, e inevitablemente converge en algo que consideramos digno de un profesional. conclusión hemos cumplido la regla del boy scout. hemos dejado este módulo más limpio de como lo encontramos. no es que no estuviera limpio originalmente, ya que el trabajo de sus autores es excelente, pero cualquier módulo se puede mejorar y es nuestra responsabilidad dejar el código más limpio de lo que lo encontramos. 33616 refactorización de serialdate si visita http://www.jfree.org/jcommon/index.php , encontrará la biblioteca jcommon. en su interior incluye el paquete org.jfree.date y, dentro de éste, la clase serialdate . vamos a analizar esta clase. el autor de serialdate es david gilbert. david es un programador experimentado y competente. como veremos, muestra un elevado grado de profesionalidad y disciplina en su código. en lo que a éste respecta, se puede 337considerar de calidad. y voy a despedazarlo. no es un acto de malicia, ni tampoco me creo mejor que david y con el derecho de juzgar su código. de hecho, si leyera algún código que he creado, seguramente tendría que objetar muchos aspectos del mismo. no es un acto de arrogancia. lo que voy a hacer no es más que una revisión profesional, algo con lo que todos deberíamos sentirnos cómodos y algo que deberíamos agradecer si alguien lo hace. a través de las críticas es como podemos aprender, como hacen médicos, pilotos o abogados. y nosotros, como programadores, también tenemos que aprender a hacerlo. otra cosa más sobre david gilbert: es más que un buen programador. david ha tenido el valor y la buena voluntad de ofrecer este código al público gratuitamente, para que cualquiera pueda usarlo y examinarlo. ¡bien hecho! serialdate (véase el listado b-1) es una clase que representa una fecha en java. ¿para qué se necesita una clase que represente una fecha si java ya cuenta con java.util.date y java.util.calendar , entre otras? el autor creó esta clase como respuesta a un problema que yo también he padecido. el comentario de su javadoc inicial (línea 67) lo explica. podríamos cuestionar su intención, pero yo también he sufrido este problema y se agradece una clase sobre fechas en lugar de horas. primero, conseguir que funcione hay varias pruebas de unidad en la clase serialdatetests (véase el listado b-2). todas son satisfactorias. desafortunadamente, un rápido examen demuestra que no comprueban todos los aspectos [t1]. por ejemplo, al realizar una búsqueda de usos en el método monthcodetoquarter (línea 334) se indica que no se usa [f4]. por lo tanto, las pruebas de unidad no lo comprueban. por ello, recurrí a clover para ver el alcance de las pruebas de unidad. clover indicó que las pruebas sólo ejecutan 91 de las 185 instrucciones ejecutables de serialdate (aproximadamente el 50 por 100) [t2]. el mapa de alcance muestra grandes fragmentos de código sin ejecutar desperdigados por la clase. mi objetivo era comprender la clase y refactorizarla, algo que no podía 338lograr sin una cobertura mayor de las pruebas. por ello diseñé mi propia suite de pruebas de unidad independientes (véase el listado b-4). si se fija en las pruebas, comprobará que muchas están comentadas, ya que no se superaron. representan un comportamiento que considero debería incluirse en serialdate . por tanto, al refactorizar serialdate , intentaré que estas pruebas funcionen. incluso con algunas de las pruebas comentadas, el informe de clover indica que ahora ejecutan 170 (el 92 por ciento) de las 185 instrucciones ejecutables. un gran resultado que creo que puedo mejorar. las primeras pruebas comentadas (líneas 23-63) son un tanto pretenciosas. el programa no fue diseñado para superar estas pruebas, pero el comportamiento me parecía evidente [g2]. desconozco por qué se ha creado el método testweekdaycodetostring pero ya que está ahí, parece obvio que no debe distinguir entre mayúsculas y minúsculas. el diseño de las pruebas fue sencillo [t3] y más todavía que fueran satisfactorias; simplemente cambié las líneas 259 y 263 para usar equalsignorecase . comenté las pruebas de las líneas 32 y 45 ya que no estaba seguro de si las abreviaturas tues y thurs se admitían o no. las pruebas de las líneas 153 y 154 no se superaron, aunque deberían haberlo hecho [g2]. podemos corregirlas, junto a las pruebas de las líneas 163 a la 213, si realizamos los siguientes cambios en la función stringtomonthcode . 457 if ((result < 1) || (result > 12)) { result = -1; 458 for (int i = 0; i < monthnames.length; i++) { 459 if (s.equalsignorecase(shortmonthnames[i])) { 460 result = i + 1; 461 break; 462 } 463 if (s.equalsignorecase(monthnames[i])) { 464 result = i + 1; 465 break; 466 } 467 } 468 } la prueba comentada de la línea 318 descubre un error en el método getfollowingdayofweek (línea 672). el 25 de diciembre de 2004 fue sábado y el siguiente sábado fue el 1 de enero de 2005. sin embargo, al ejecutar la 339prueba, vemos que getfollowingdayofweek devuelve el 25 de diciembre como siguiente sábado después del 25 de diciembre, un error evidente [g3], [t1]. vemos el problema en la línea 685. es un error de condición de límite típico [t5]. debería ser lo siguiente: 685 if (basedow >= targetweekday) { conviene destacar que esta función sufrió una reparación anterior. el historial de cambios (línea 43) muestra que se corrigieron los errores en getpreviousdayofweek , getfollowingdayofweek y getnearestdayofweek [t6]. la prueba de unidad testgetnearestdayofweek (línea 329), que prueba el método getnearestdayofweek (línea 705), inicialmente no era tan extensa y completa. añadí multitud de casos de prueba ya que los iniciales no se superaban [t6]. puede ver el patrón de fallos si se fija en los casos de prueba comentados. el patrón es revelador [t7]. muestra que el algoritmo falla si el día más próximo es de una fecha futura. evidentemente se trata de algún tipo de error de condición de límite [t5]. el patrón de alcance de las pruebas generado por clover también es interesante [t8]. la línea 719 nunca se ejecuta, lo que significa que la instrucción if de la línea 718 siempre es false , pero si nos fijamos en el código, indica que debe ser true . la variable adjust siempre es negativa y no puede ser mayor o igual a 4, por lo que el algoritmo es incorrecto. a continuación se muestra el algoritmo correcto: int delta = targetdow - base.getdayofweek(); int positivedelta = delta + 7; int adjust = positivedelta % 7; if (adjust > 3) adjust -= 7; return serialdate.adddays (adjust, base); por último, las pruebas de la líneas 417 y 429 se pueden superar si se genera illegalargumentexception en lugar de devolver una cadena de error desde weekinmonthtostring y relativetostring . con estos cambios, todas las pruebas de unidad se superan y creo que ahora serialdate funciona. llega el momento de hacer que sea correcta. 340hacer que sea correcta describiremos serialdate de arriba a abajo para mejorarla en nuestro recorrido. aunque no lo veamos en este análisis, ejecutaré todas las pruebas de unidad de jcommon , incluida mi prueba de unidad mejorada para serialdate , con todos los cambios efectuados. por ello, tenga la seguridad de que todos los cambios que vea funcionan para jcommon . en la línea 1 vemos abundantes comentarios sobre información de licencia, derechos de autor, autores e historial de cambios. asumo que hay ciertos aspectos legales que mostrar, por lo que los derechos de autor y las licencias deben conservarse. por otra parte, el historial de cambios es una rémora de la década de 1960. ahora tenemos herramientas de control de código fuente que se encargan de ello. hay que eliminar este historial [c1]. la lista de importación que comienza en la línea 61 se puede reducir por medio de java.text.* y java.util.* . [j1] no me convence el formato html del javadoc (línea 67). un archivo fuente con más de un lenguaje me parece un problema. este comentario tiene cuatro lenguajes: java, español, javadoc y html [g1]. con tantos lenguajes se hace difícil mantener la coherencia. por ejemplo, la ubicación de las líneas 71 y 72 se pierde al generar el javadoc y además, ¿quién quiere ver <ul> y <li> en el código fuente? una estrategia más acertada consiste en rodear el comentario con <pre> para que el formato del código fuente se conserve en el javadoc [96] . la línea 86 es la declaración de la clase. ¿por qué se le asigna el nombre serialdate ? ¿qué sentido tiene la palabra serial ? ¿es porque la clase se deriva de serializable ? parece improbable. basta de adivinanzas. sé por qué (o al menos eso creo) se usa la palabra serial . la clave se encuentra en las constantes serial_lower_bound y serial_upper_bound de las líneas 98 y 101. y una clave todavía mejor es el comentario de la línea 830. el nombre de la clase es serialdate ya que se implementa con un número de serie, que parece ser el número de días desde el 30 de diciembre de 1899. 341pero esto supone un problema. por un lado, el término «número de serie» no es realmente correcto. puede ser un detalle menor pero la representación es más un desplazamiento relativo que un número de serie. el término «número de serie» tiene que ver más con marcadores de identificación de productos que con fechas. por ello, no lo considero especialmente descriptivo [n1]. un término más descriptivo sería «ordinal». el segundo problema es más significativo. el nombre serialdate implica una implementación. esta clase es abstracta. no es necesario que implique nada sobre la implementación; de hecho, es aconsejable ocultarla. por ello, creo que el nombre se encuentra en un nivel de abstracción incorrecto [n2]. en mi opinión, el nombre de esta clase debería ser simplemente date . desafortunadamente, hay demasiadas clases con el nombre date en la biblioteca de java, de modo que no es el más adecuado. como esta clase trabaja con días y no horas, podríamos usar day , pero ya se usa en otros muchos puntos. al final, opté por daydate como mejor opción. a partir de ahora, usaremos daydate . recuerde que los listados que va a leer siguen usando serialdate . entiendo porque daydate se hereda de comparable y serializable . ¿pero de monthconstants ? la clase monthconstants (véase el listado b-3) es una serie de constantes finales estáticas que definen los meses. heredar de clases con constantes es un viejo truco que los programadores de java usan para evitar expresiones como monthconstants.january , pero es una mala idea [j2]. monthconstants debería ser una enumeración. public abstract class daydate implements comparable, serializable { public static enum month { january(1), february(2), march(3), april(4), may(5), june(6), july(7), august(8), september(9), october(10), november(11), december(12); 342month(int index) { this.index = index; } public static month make(int monthindex) { for (month m : month.values()) { if (m.index == monthindex) return m; } throw new illegalargumentexception(“invalid month index ” + monthindex); } public final int index; } al cambiar monthconstants por esta enumeración se modifica la clase daydate y todos sus usuarios. tardé una hora en realizar todos los cambios. sin embargo, las funciones que antes aceptaban un valor int para el mes, ahora aceptan un enumerador month . esto significa que podemos deshacernos del método isvalidmonthcode (línea 326) y de la comprobación de errores del código de los meses como en monthcodetoquarter (línea 356) [g5]. tras ello, en la línea 91, tenemos serialversionuid . esta variable se usa para controlar el señalizador. si la cambiamos, con lo que todos los elementos daydate escritos con una versión antigua del software serán ilegibles y se generará invalidclassexception . si no declara la variable serialversionuid , el compilador genera una automáticamente y será diferente cada vez que modifique el módulo. ya sé que todos los documentos recomiendan el control manual de esta variable, pero creo que el control automático de la señalización es más seguro [g4]. después de todo, prefiero depurar una invalidclassexception que el extraño comportamiento que se produciría si me olvido de cambiar serialversionuid . por ello, eliminaré la variable, al menos por ahora [97] . creo que el comentario de la línea 93 es redundante. los comentarios redundantes sólo sirven para acumular mentiras y desinformación [c2]. por ello los eliminaré. los comentarios de las líneas 97 y 100 hablan sobre números de serie, que ya hemos mencionado antes [c1]. las variables que describen son la primera y última fecha posible que daydate puede describir. podríamos hacer que fuera más claro [n1]. 343public static final int earliest_date_ordinal = 2; // 1/1/1900 public static final int latest_date_ordinal = 2958465; // 12/31/9999 desconozco por qué earliest_date_ordinal es 2 en lugar de 0. el comentario de la línea 829 sugiere que tiene que ver con la forma de representar fechas en microsoft excel. hay información mucho más completa en una variante de daydate : spreadsheetdate (véase el listado b-5). el comentario de la línea 71 describe este problema. el problema parece relacionado con la implementación de spreadsheetdate y no con daydate . mi conclusión es que earliest_date_ordinal y latest_date_ordinal no pertenecen a daydate y deberían cambiarse a spreadsheetdate [g6]. de hecho, una búsqueda en el código demuestra que estas variables sólo se usan en spreadsheetdate . ni en daydate , ni en otras clases de la estructura jcommon. por lo tanto, las cambio por spreadsheetdate . las siguientes variables, minimum_year_supported y maximum_year_supported (líneas 104 y 107), constituyen un dilema. parece evidente que si daydate es una clase abstracta que no dice nada sobre implementación, no debería informarnos de un año mínimo o máximo. de nuevo, siento la necesidad de cambiar las variables a spreadsheetdate [g6]. pero una búsqueda rápida de los usuarios de estas variables muestra que otra clase las utiliza: relativedayofweekrule (véase el listado b-6), vemos dicho uso en las líneas 177 y 178, en la función getdate , donde se usan para comprobar que el argumento de getdate sea un año válido. el dilema es que un usuario de una clase abstracta necesita información sobre su implementación. tendremos que proporcionar esta información sin contaminar daydate . por lo general, obtendríamos la información de implementación de una instancia de una variante. sin embargo, la función getdate no recibe una instancia de daydate , aunque sí la devuelve, lo que significa que debe crearla en alguna parte. la solución está en las líneas 187-205. la instancia daydate se crea por medio de una de estas tres funciones: getpreviousdayofweek , getnearestdayofweek o getfollowingdayofweek . si nos fijamos en el 344listado daydate , vemos que estas funciones (líneas 638-724) devuelven una fecha creada por adddays (línea 571), que invoca createinstance (línea 808), que crea spreadsheetdate [g7]. no es recomendable que las clases base conozcan sus variantes. para corregirlo, debemos usar el patrón de factoría abstracta [98] y crear daydatefactory . esta factoría creará las instancias de daydate que necesitamos y también responderá a preguntas sobre la implementación, como las fechas máxima y mínima. public abstract class daydatefactory { private static daydatefactory factory = new spreadsheetdatefactory(); public static void set instance(daydatefactory factory) { daydatefactory.factory = factory; } protected abstract daydate _makedate(int ordinal); protected abstract daydate _makedate(int day, daydate.month month, int year); protected abstract daydate _makedate(int day, int month, int year); protected abstract daydate _makedate(java.util.date date); protected abstract int _getminimumyear(); protected abstract int _getmaximumyear(); public static daydate makedate(int ordinal) { return factory._makedate(ordinal); } public static daydate makedate(int day, daydate.month month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(int day, int month, int year) { return factory._makedate(day, month, year); } public static daydate makedate(java.util.date date) { return factory._makedate(date); } public static int getminimumyear() { return factory._getminimumyear(); } public static int getmaximumyear() { return factory._getmaximumyear(); } } esta clase de factoría sustituye los métodos createinstance por métodos 345makedate , lo que mejora ligeramente los nombres [n1]. de forma predeterminada es spreadsheetdatefactory pero se puede cambiar por otra factoría. los métodos estáticos delegados en métodos abstractos usan una combinación de los patrones de instancia única [99] , decorador [100] y factoría abstracta que considero muy útil. spreadsheetdatefactory tiene este aspecto: public class spreadsheetdatefactory extends daydatefactory { public daydate _makedate(int ordinal) { return new spreadsheetdate(ordinal); } public daydate _makedate(int day, daydate.month month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(int day, int month, int year) { return new spreadsheetdate(day, month, year); } public daydate _makedate(date date) { final gregoriancalendar calendar = new gregoriancalendar(); calendar.settime(date); return new spreadsheetdate( calendar.get(calendar.date), daydate.month.make(calendar.get(calendar.month) + 1), calendar.get(calendar.year)); } protected int _getminimumyear() { return spreadsheetdate.minimum_year_supported; } protected int _getmaximumyear() { return spreadsheetdate.maximum_year_supported; } } como puede apreciar, hemos enviado las variables minimum_year_supported y maximum_year_supported a spreadsheetdate , donde pertenecen [g6]. el siguiente problema de daydate son las constantes de días, comenzando en la línea 109. deberían ser otra enumeración [j3]. ya hemos visto este patrón, de modo que no lo repetiremos. se incluye en los listados definitivos. seguidamente, vemos una serie de tablas que comienzan en last_day_of_month (línea 140). el primer problema con estas tablas es que 346los comentarios que las describen son redundantes [c3]. basta con sus nombres, de modo que eliminamos los comentarios. no hay motivos para que la tabla no sea privada [g8], ya que existe una función estática lastdayofmonth que proporciona los mismos datos. la siguiente tabla, aggregate_days_to_end_of_month , es más misteriosa, ya que no se usa en ninguna parte de la estructura jcommon [g9], de modo que la elimino. lo mismo sucede con leap_year_aggregate_days_to_end_of_month . la siguiente tabla, aggregate_days_to_end_of_preceding_month , sólo se usa en spreadsheetdate (líneas 434 y 473), lo que me hace dudar si transferirla a spreadsheetdate . la razón de no cambiarla es que la tabla no es específica de ninguna implementación concreta [g6]. por otra parte, sólo existe la implementación spreadsheetdate , de modo que la tabla debe acercarse a donde se vaya a usar [g10], para zanjar la duda y ser coherentes [g11], deberíamos privatizar la tabla y mostrarla a través de una función como juliandateoflastdayofmonth . pero nadie parece que la necesita. es más, la tabla se puede cambiar a daydate si una nueva implementación de daydate la necesita. así que la cambiamos. lo mismo sucede con leap_year_aggregate_days_to_end_of_month . tras ello, vemos tres grupos de constantes que se pueden convertir en enumeraciones (líneas 162-205). la primera selecciona una semana de un mes. la transformo en la enumeración weekinmonth . public enum weekinmonth { first(1), second(2), third(3), fourth(4), last(0); public final int index; weekinmonth(int index) { this.index = index; } } el segundo grupo de constantes (líneas 177-187) es más complicado. las constantes include_none, include_first, include_second e include_both se usan para describir si las fechas finales de un intervalo deben incluirse en el mismo. matemáticamente, se describe como intervalo 347abierto, intervalo a medio abrir e intervalo cerrado. creo que resulta más claro con la nomenclatura matemática [n3], de modo que lo cambio por la enumeración dateinterval con los enumeradores closed, closed_left, closed_right y open . el tercer grupo de constantes (líneas 18-205) describen si la búsqueda de un día concreto de la semana devuelve la última instancia, la siguiente o la más próxima. decidir un nombre adecuado es complicado. al final, opté por weekdayrange con los enumeradores last, next y nearest . puede que no esté de acuerdo con los nombres elegidos. para mí tienen sentido. lo importante es que ahora son más fáciles de cambiar [j3]. ya no se pasan como enteros, sino como símbolos. puedo usar la función de cambio de nombre de mi ide para cambiar los nombres o los tipos sin preocuparme de haberme olvidado de un -1 o un 2 en alguna parte del código o de que la declaración de un argumento int no estén bien descrita. el campo de descripción de la línea 208 no parece que se use en ninguna parte. lo elimino junto a sus elementos de acceso y mutación [g9]. también elimino el constructor predeterminado de la línea 213 [g12]. el compilador se encargará de generarlo. podemos ignorar el método isvalidweekdaycode (líneas 216-238) ya que lo eliminamos al crear la enumeración day . llegamos al método stringtoweekdaycode (líneas 242-270). los javadoc que no suponen demasiado para la firma del método sobran [c3], [g12]. el único valor de este javadoc es la descripción del valor devuelto -1 . sin embargo, como cambiamos a la enumeración day , el comentario es en realidad incorrecto [c2]. ahora el método genera illegalargumentexception . por ello, eliminamos el javadoc. también elimino las palabras clave final de argumentos y declaraciones de variables, ya que no parecen servir de mucho [g12]. la eliminación de final no goza de gran aceptación. por ejemplo, robert simmons [101] recomienda «… diseminar final por la totalidad del código». no estoy de acuerdo. creo que existen casos para usar final , por ejemplo como constante ocasional, pero en general, esta palabra clave apenas añade valor y suele ser 348un estorbo. puede que lo piense porque el tipo de errores que puede capturar final ya se capturan en las pruebas de unidad que he creado. las instrucciones if duplicadas [g5] del bucle for (líneas 259 y 263) son irrelevantes, de modo que las conecté en una única instrucción if con el operador || . también usé la enumeración day para dirigir el bucle for y realicé otros cambios estéticos. este método no pertenece realmente a daydate . en realidad es la función de análisis de day . por lo tanto, lo cambié a la enumeración day , lo que hizo que aumentara considerablemente de tamaño. como el concepto de day no depende de daydate , extraje la enumeración day de la clase daydate a un archivo propio [g13]. también cambié la siguiente función, weekdaycodetostring (líneas 272-286) a la enumeración day y le asigné el nombre tostring . public enum day { monday(calendar.monday), tuesday(calendar.tuesday), wednesday(calendar.wednesday), thursday(calendar.thursday), friday(calendar.friday), saturday(calendar.saturday), sunday(calendar.sunday); public final int index; private static dateformatsymbols datesymbols = new dateformatsymbols(); day(int day) { index = day; } public static day make(int index) throws illegalargumentexception { for (day d : day.values()) if (d.index == index) return d; throw new illegalargumentexception( string.format(“illegal day index: %d.”, index)); } public static day parse(string s) throws illegalargumentexception { string[] shortweekdaynames = datesymbols.getshortweekdays(); string[] weekdaynames = datesymbols.getweekdays(); s = s.trim(); for (day day : day.values()) { 349if (s.equalsignorecase(shortweekdaynames[day.index]) || s.equalsignorecase(weekdaynames[day.index])) { return day; } } throw new illegalargumentexception( string.format(“%s is not a valid weekday string”, s)); } public string tostring() { return datesymbols.getweekdays()[index]; } } hay dos funciones getmonths (líneas 288-316). la primera invoca la segunda. la segunda solamente se invoca desde la primera. por ello, las he combinado en una y las he simplificado considerablemente [g9], [g12], [f4]. por último, he cambiado el nombre por otro más descriptivo [n1]. public static string[] getmonthnames() { return dateformatsymbols.getmonths(); } la función isvalidmonthcode (líneas 326-346) es ahora irrelevante gracias a la enumeración month , de modo que la elimino [g9]. la función monthcodetoquarter (líneas 356-375) parece sufrir envidia de las características [102] [g14] y seguramente pertenezca a la enumeración month como método quarter , motivo por el que la sustituyo. public int quarter() { return 1 + (index-1)/3; } de este modo, la enumeración month tiene tamaño suficiente como para estar en una clase propia. la extraigo de daydate para mantener la coherencia con la enumeración day [g11], [g13]. los dos siguientes métodos tienen el nombre monthcodetostring (líneas 377-426). vemos de nuevo que uno invoca al otro con un indicador. no es recomendable pasar un indicador como argumento de una función, en especial si dicho indicador sólo selecciona el formato del resultado [g15]. por tanto, cambio de nombre, simplifico y reestructuro estas funciones y las incluyo en la enumeración month [n1], [n3], [c3], [g14]. public string tostring() { return dateformatsymbols.getmonths()[index - 1]; 350} public string toshortstring() { return dateformatsymbols.getshortmonths()[index – 1]; } el siguiente método es stringtomonthcode (líneas 428-472). lo cambio de nombre, lo paso a la enumeración month y lo simplifico [n1], [n3], [c3], [g14], [g12]. public static month parse(string s) { s = s.trim(); for (month m : month.values()) if (m.matches(s)) return m; try { return make(integer.parseint(s)); } catch (numberformatexception e) {} throw new illegalargumentexception(“invalid month ” + s); } private boolean matches(string a) { return s.equalsignorecase(tostring()) || s.equalsignorecase(toshortstring()); } el método isleapyear (líneas 495-517) se puede modificar para que sea más expresivo [g16]. public static boolean isleapyear(int year) { boolean fourth = year % 4 == 0; boolean hundredth = year % 100 == 0; boolean fourhundredth = year % 400 == 0; return fourth && (!hundredth || fourhundredth); } la siguiente función, leapyearcount (líneas 519-536) no pertenece realmente a daydate . nadie la invoca, excepto los dos métodos de spreadsheetdate , de modo que la desplazo hacia abajo [g6]. la función lastdayofmonth (líneas 538-560) usa la matriz last_day_of_month , que en realidad pertenece a la enumeración month [g17], por lo que la cambio de ubicación. también simplifico la función y aumento su expresividad [g16]. public static int lastdayofmonth(month month, int year) { if (month == month.february && isleapyear(year)) return month.lastday() + 1; else 351return month.lastday(); } ahora empieza a ponerse interesante. la siguiente función es adddays (líneas 562-576). en primer lugar, como opera en las variables de daydate , no debería ser estática [g18]. la cambio por un método de instancia. por otra parte, invoca la función toserial , cuyo nombre deberíamos cambiar por toordinal [n1]. por último, el método se puede simplificar. public daydate adddays(int days) { return daydatefactory.makedate(toordinal() + days); } lo mismo sucede con addmonths (líneas 578-602). debería ser un método de instancia [g18]. el algoritmo es un tanto complicado, de modo que recurro a la explicación de variables temporales [103] [g19] para que sea más transparente. también cambio el nombre del método getyyy por getyear [n1]. public daydate addmonths(int months) { int thismonthasordinal = 12 * getyear() + getmonth().index - 1; int resultmonthasordinal = thismonthasordinal + months; int resultyear = resultmonthasordinal / 12; month resultmonth = month.make(resultmonthasordinal % 12 + 1); int lastdayofresultmonth = lastdayofmonth(resultmonth, resultyear); int resultday = math.min(getdayofmonth(), lastdayofresultmonth); return daydatefactory.makedate(resultday, resultmonth, resultyear); } la función addyears (líneas 604-626) es similar al resto. public daydate plusyears(int years) { int resultyear = getyear() + years; int lastdayofmonthinresultyear = lastdayofmonth(getmonth(), resultyear); int resultday = math.min(getdayofmonth(), lastdayofmonthinresultyear); return daydatefactory.makedate(resultday, getmonth(), resultyear); } hay algo que me preocupa sobre el cambio de estos métodos de estáticos a métodos de instancia. ¿la expresión date.adddays(5) aclara que el objeto date no cambia y que se devuelve una nueva instancia de daydate o se supone, equivocadamente, que se añaden cinco días al objeto date ? pensará que no es un gran problema, pero un fragmento de código como el siguiente puede ser muy engañoso [g20]. daydate date = datefactory.makedate(5, month.december, 1952); date.adddays(7); // desplazar la fecha una semana 352un lector de este código podría aceptar que adddays cambia el objeto date , de modo que necesitamos un nombre que acabe con la ambigüedad [n4]: plusdays y plusmonths . creo que la intención del método se captura correctamente por medio de daydate date = olddate.plusdays(5); mientras que el siguiente no transmite con fluidez al lector que el objeto date ha cambiado: date.plusdays(5); los algoritmos son cada vez más interesantes. getpreviousdayofweek (líneas 628-660) funciona pero es complicado. tras meditar en lo que sucedía [g21], pude simplificarlo y aplicar la explicación de variables temporales [g19] para aclarar su significado. también lo cambié de método estático a método de instancia [g18] y me deshice del método de instancia duplicado [g5] (líneas 997-1008). public daydate getpreviousdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index = getdayofweek().index; if (offsettotarget >= 0) offsettotarget - 7; return plusdays(offsettotarget); } sucede exactamente lo mismo con getfollowingdayofweek (líneas 662-693). public daydate getfollowingdayofweek(day targetdayofweek) { int offsettotarget = targetdayofweek.index - getdayofweek().index; if (offsettotarget <= 0) offsettotarget += 7; return plusdays(offsettotarget); } la siguiente función es getnearestdayofweek (líneas 695-726), que corregimos en un apartado anterior. pero esos cambios no son coherentes con el patrón actual de las dos últimas funciones [g11]. por ello, recurro a la explicación de variables temporales [g19] para aclarar el algoritmo. public daydate getnearestdayofweek(final day targetday) { int offsettothisweekstarget = targetday.index - getdayofweek().index; int offsettofuturetarget = (offsettothisweekstarget + 7) % 7; int offsettoprevioustarget = offsettofuturetarget - 7; if (offsettofuturetarget > 3) 353return plusdays(offsettoprevioustarget); else return plusdays(offsettofuturetarget); } el método getendofcurrentmonth (líneas 728-740) es un tanto extraño ya que es un método de instancia que envidia [g14] a su propia clase aceptado un argumento daydate . lo convierto en un verdadero método de instancia y clarifico algunos de los nombres. public daydate getendofmonth() { month month = getmonth(); int year = getyear(); int lastday = lastdayofmonth(month, year); return daydatefactory.makedate(lastday, month, year); } la refactorización de weekinmonthtostring (líneas 742-761) resultó ser muy interesante. mediante las herramientas de refactorización de mi ide, primero cambié el método a la enumeración weekinmonth creada antes y después cambié el nombre por tostring . tras ello, lo convertí en método de instancia. todas las pruebas fueron correctas (¿adivina hacia dónde nos dirigimos?). seguidamente, eliminé el método. fallaron cinco afirmaciones (líneas 411-415 del listado b-4). cambié estas líneas para usar los nombres de los enumeradores ( first , second , etc.). las pruebas fueron correctas. ¿ve por qué? ¿puede ver también por qué son necesarios estos pasos? la herramienta de refactorización se encargó de que los invocadores anteriores de weekinmonthtostring invocaran ahora tostring en el enumerador weekinmonth ya que todos los enumeradores implementan tostring para devolver sus nombres… desafortunadamente, me pasé de listo. a pesar de la elegancia de la cadena de refactorización, comprobé que los únicos usuarios de esta función eran las pruebas que acababa de modificar, de modo que las eliminé. así pues, tras determinar que sólo las pruebas invocaban relativetostring (líneas 765-781), eliminé directamente la función y sus pruebas. hemos llegado a los métodos abstractos de esta clase abstracta. y el primero es toserial (líneas 838-844). en un apartado anterior cambié el nombre por toordinal . al verlo en este contexto, decidí que el cambio de 354nombre debería ser por getordinalday . el siguiente método abstracto es todate (líneas 838-844). convierte daydate en java.util.date . ¿por qué es abstracto? si analizamos su implementación en spreadsheetdate (líneas 198-207 del listado b-5), vemos que no depende de la implementación de esa clase [g6]. por tanto, lo desplazo hacia arriba. los métodos getyyyy , getmonth y getdayofmonth son evidentemente abstractos. sin embargo, getdayofweek debería ascender desde spreadsheetdate ya que no depende de nada de lo que encontremos en daydate [g6]. ¿o sí? si se fija atentamente (línea 247 del listado b-5), verá que el algoritmo depende implícitamente del origen del día ordinal (es decir, el día de la semana del día 0). por ello, aunque esta función carezca de dependencias físicas que no se puedan cambiar a daydate , cuenta con una dependencia lógica. este tipo de dependencias lógicas me molestan [g22]. si algo lógico depende de la implementación, también debería haber algo físico. además, me parece que el propio algoritmo podría ser genérico y que debería depender en menor medida de la implementación [g6]. por tanto, creé un método abstracto en daydate con el nombre getdayofweekforordinalzero y lo implementé en spreadsheetdate para devolver day.saturday . tras ello, envié el método getdayofweek a daydate y lo cambié para que invocara getordinalday y getdayofweekforordinalzero . public day getdayofweek() { day startingday = getdayofweekforordinalzero(); int startingoffset = startingday.index - day.sunday.index; return day.make((getordinalday() + startingoffset) % 7 + 1); } fíjese en el comentario de las líneas 895-899. ¿necesitamos realmente esta repetición? como de costumbre, eliminé este comentario junto a los demás. el siguiente método es compare (líneas 902-913). de nuevo, es incorrectamente abstracto [g6], por lo que cambio la implementación a daydate . además, el nombre no es descriptivo [n1]. en realidad, este método devuelve la diferencia en días desde el argumento, por lo que cambié el nombre por dayssince . tampoco existían pruebas para este método, de 355modo que las creé. las seis siguientes funciones (líneas 915-980) son métodos abstractos que deben implementarse en daydate , por lo que las extraje de spreadsheetdate . la última función, isinrange (líneas 982-995), también debe extraerse y refactorizarse. la instrucción switch no es agradable [g23] y se puede modificar si enviamos los casos a la enumeración dateinterval . public enum dateinterval { open { public boolean isin(int d, int left, int right) { return d > left && d < right; } }, closed_left { public boolean isin(int d, int left, int right) { return d >= left && d < right; } }, closed_right { public boolean isin(int d, int left, int right) { return d > left && d <= right; } }, closed { public boolean isin(int d, int left, int right) { return d >= left && d <= right; } }; public abstract boolean isin(int d, int left, int right); } public boolean isinrange(daydate d1, daydate d2, dateinterval interval) { int left = math.min(d1.getordinalday(), d2.getordinalday()); int right = math.max(d1.getordinalday(), d2.getordinalday()); return interval.isin(getordinalday(), left, right); } con esto llegamos al final de daydate . realizaremos una nueva pasada por la clase completa para comprobar cómo fluye. primero, el comentario inicial está desfasado, de modo que lo reduzco y lo mejoro [c2]. tras ello, desplazo las enumeraciones restantes a sus propios archivos [g12]. seguidamente, desplazo la variable estática ( dateformatsymbols ) y tres métodos estáticos ( getmonthnames , isleapyear , lastdayofmonth ) a una nueva clase con el nombre dateutil [g6]. 356cambio los métodos abstractos a una posición superior, donde pertenecen [g24]. cambio month.make por month.fromint [n1] y repito la operación con las demás enumeraciones. también creo un método de acceso toint() para todas las enumeraciones y convierto en privado el campo index . se produce una interesante duplicación [g5] en plusyears y plusmonths que conseguí eliminar extrayendo un nuevo método con el nombre correctlastdayofmonth , lo que aclaraba el significado de los tres métodos. me deshice del número mágico 1 [g25] y lo sustituí por month.january.toint() o day.sunday.toint() , según el caso. me detuve en limpiar los algoritmos de spreadsheetdate . el resultado final se puede comprobar en los listados b.7 a b.16. el alcance del código en daydate se ha reducido al 84.9 por 100, no porque se pruebe una cantidad menor de funcionalidad, sino porque la clase se ha reducido tanto que las líneas sin alcance tienen un peso mayor. ahora, en daydate las pruebas se aplican a 45 de las 53 instrucciones ejecutables. las líneas sin alcance son tan triviales que no merece la pena probarlas. conclusión otra vez hemos aplicado la regla del boy scout. hemos entregado el código más limpio de lo que lo recibimos. nos ha llevado tiempo, pero ha merecido la pena. el alcance de las pruebas ha aumentado, hemos corregido algunos errores y hemos aclarado y reducido el tamaño del código. la próxima persona que lo lea seguramente lo encontrará más fácil de leer. y probablemente esa persona sea capaz de limpiarlo algo más de lo que hemos hecho nosotros. bibliografía [gof] : design patterns: elements of reusable object oriented 357software , gamma et al., addison-wesley, 1996. [simmons04] : hardcore java , robert simmons, jr., o’reilly, 2004. [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. [beck97] : smalltalk best practice patterns , kent beck, prentice hall, 1997. 35817 síntomas y heurística en su magnífico libro refactoring [104] , martin fowler identifica diversos síntomas de código ( smells ). la lista que mostramos a continuación incluye muchos de los síntomas de martin y otros propios. también contiene otras perlas y heurística que suelo emplear en mi trabajo. 359para compilar esta lista he examinado diversos programas y los he refactorizado. al aplicar un cambio, me preguntaba el por qué y anotaba el motivo. el resultado es una extensa lista de aspectos que no me «huelen» bien cuando leo código. la lista se debe leer de arriba a abajo, y también se puede usar como referencia. comentarios c1: información inapropiada no es apropiado que un comentario contenga información que se pueda almacenar en otro tipo de sistema como un sistema de control de código fuente, de seguimiento de problemas o de mantenimiento de registros. los historiales de cambios, por ejemplo, abarrotan los archivos de código con abundante texto sin interés alguno. por lo general, metadatos como autores, fechas de modificación, números spr y similares no deben aparecer en los comentarios. los comentarios deben reservarse para notas técnicas sobre el código y el diseño. c2: comentario obsoleto un comentario anticuado, irrelevante e incorrecto es obsoleto. los comentarios envejecen rápidamente. es recomendable no escribir un comentario que vaya a quedar obsoleto. si detecta un comentario obsoleto, conviene actualizarlo o eliminarlo lo antes posible. los comentarios obsoletos tienden a alejarse del código que describían. se convierten en islas de irrelevancia y desorientación en el código. c3: comentario redundante un comentario es redundante si describe algo que ya se define correctamente 360por sí mismo. por ejemplo: i++; // incrementar i otro ejemplo es un javadoc que no dice más (o incluso menos) que la firma de una función: /** * @param sellrequest * @return * @throws managedcomponentexception */ public sellresponse beginsellitem(sellrequest sellrequest) throws managedcomponentexception los comentarios deben comunicar lo que el código no pueda expresar por sí mismo. c4: comentario mal escrito un comentario que merezca la pena escribir merece la pena ser leído. si piensa escribir un comentario, asegúrese de que es el mejor que puede crear. elija las palabras con atención. use gramática y puntuación correctas. no divague. no afirme lo evidente. sea breve. c5: código comentado me molesta ver grandes fragmentos de código comentado. ¿quién sabe qué antigüedad tienen? ¿quién sabe si tiene sentido o no? pero nadie lo borra porque piensa que alguien más lo necesita. ese código se estanca y se corrompe, y cada día que pasa es menos relevante. invoca funciones que ya no existen. usa variables cuyos nombres han cambiado. se rige por convenciones obsoletas. contamina los módulos en los que aparece y distrae a los usuarios que lo leen. el código comentado es una aberración. cuando vea código comentado, elimínelo. no se preocupe, el sistema de control de código fuente lo recordará. si alguien lo necesita, puede consultar una versión anterior. no sufra el código comentado para sobrevivir. 361entorno e1: la generación requiere más de un paso la generación de un proyecto debería ser una operación sencilla. no debería tener que comprobar demasiados elementos del control de código fuente. no debería necesitar una secuencia de antiguos comandos ni secuencias de comandos dependientes del contexto para generar cada elemento. no debería tener que buscar los distintos archivos jar, xml y similares necesarios para el sistema. debería finalizar el sistema con un sencillo comando y después ejecutar otro igual de sencillo para generarlo. svn get mysystem cd mysystem ant all e2: las pruebas requieren más de un paso debería poder ejecutar todas las pruebas de unidad con un solo comando. en el mejor de los casos, debería poder ejecutarlas pulsando un botón de su ide. en el peor, debería poder ejecutar un único comando en una línea de comandos. la capacidad de ejecutar todas las pruebas es tan importante que debe ser algo rápido, sencillo y obvio. funciones f1: demasiados argumentos las funciones deben tener un número reducido de argumentos. lo mejor es que no tengan, seguido de uno, dos y tres argumentos. más de tres ya es cuestionable y debería evitarse (véase el capítulo 3). 362f2: argumentos de salida los argumentos de salida son ilógicos. el lector espera que los argumentos sean entradas, no salidas. si su función tiene que cambiar el estado de algo, haga que cambie el estado del objeto en el que se invoca (véase el capítulo 3). f3: argumentos de indicador los argumentos booleanos declaran abiertamente que la función hace más de una cosa. resultan confusos y deben eliminarse (véase el capítulo 3). f4: función muerta los métodos que nunca se invocan deben descartarse. la presencia de código muerto es innecesaria. no tema eliminar la función. su sistema de control de código fuente la recordará. general g1: varios lenguajes en un archivo de código los modernos entornos de programación actuales permiten incluir varios lenguajes diferentes en el mismo archivo de código. por ejemplo, un archivo de java puede contener fragmentos de xml, html, yaml, javadoc, javascript, y similares. además de html, un archivo jsp podría incluir java, sintaxis de biblioteca de etiquetas, comentarios en español, javadoc, xml, javascript, etc. resulta confuso en el mejor de los casos y un desastre en el peor. lo ideal sería que el archivo de código incluyera un solo lenguaje pero, en realidad, seguramente tendremos que usar más de uno. debemos intentar minimizar la cantidad y el alcance de los lenguajes adicionales en nuestros 363archivos de código. g2: comportamiento evidente no implementado de acuerdo al principio de la mínima sorpresa [105] , una función o clase debe implementar los comportamientos que otro programador esperaría. por ejemplo, imagine una función que traduce el nombre de un día en una enumeración que represente dicho día. day day = daydate.stringtoday(string dayname); esperaríamos que la cadena « monday » se tradujera en day.monday. también esperaríamos la traducción de las abreviaturas habituales y que la función ignorara mayúsculas y minúsculas. cuando un comportamiento obvio no se implementa, los lectores y usuarios del código ya no dependen de su intuición sobre los nombres de las funciones. pierden su confianza en el autor original y se ven obligados a leer los detalles del código. g3: comportamiento incorrecto en los límites parece evidente afirmar que el código debe comportarse de forma correcta. el problema es que no nos damos cuenta de lo complicado que es dicho comportamiento correcto. los programadores suelen crear funciones que esperan que funcionen y confían en su intuición más que en comprobar que el código funciona en todos los casos de límites. no existe sustituto para la meticulosidad. las condiciones de límite, los casos extremos, las excepciones, representan algo que puede confundir a un algoritmo elegante e intuitivo. no dependa de su intuición . busque todas las condiciones de límite y cree pruebas para cada una. g4: medidas de seguridad canceladas chernobyl se derritió porque el director de la central ignoró todos y cada uno de los mecanismos de seguridad. impedían que se realizara un experimento. 364el resultado fue que el experimento no salió bien y el mundo fue testigo de la primera gran catástrofe nuclear para la población. anular las medidas de seguridad es un riesgo. puede que sea necesario ejercer el control manual sobre serialversionuid pero siempre es arriesgado. la desactivación de determinadas advertencias del compilador (o de todas) puede ayudarle a conseguir la generación, pero corre el riesgo de sufrir interminables sesiones de depuración. desactivar las pruebas que fallan y convencerse de que conseguirá que después sean satisfactorias es tan erróneo como pensar que sus tarjetas de crédito son dinero gratuito. g5: duplicación una de las reglas más importantes del libro y que debe tomarse muy en serio. la práctica totalidad de los autores que escriben sobre diseño de software mencionan esta regla. dave thomas y andy hunt la denominaron principio dry [106] ( don't repeat yourself , no repetirse). kent beck la convirtió en uno de los principios fundamentales de la programación extreme y la denominó «una sola vez». ron jeffries sitúa esta regla en segunda posición, por debajo de la consecución satisfactoria de todas las pruebas. siempre que vea duplicados en el código, indican una oportunidad de abstracción fallida. la duplicación podría convertirse en una subrutina o en otra clase. al incluir la duplicación en una abstracción, aumenta el vocabulario del lenguaje del diseño. otros programadores pueden usar sus creaciones abstractas. el código se vuelve más rápido y menos proclive a errores ya que ha aumentado el nivel de abstracción. el caso más evidente de duplicación es la presencia de fragmentos de código idéntico que parecen pegados repetidamente por el programador, sin sentido. conviene reemplazarlos por métodos simples. una forma más sutil es la cadena switch/case o if/else que aparece repetidamente en diversos módulos y que siempre prueba las mismas condiciones. conviene reemplazar estas cadenas por polimorfismo. y más sutiles todavía son los módulos con algoritmos similares pero que no comparten las mismas líneas de código. sigue siendo duplicación y debe 365corregirse por medio del patrón de método de plantilla [107] o estrategia [108] . en realidad, la mayoría de patrones de diseño aparecidos en los últimos 15 años son formas de eliminar la duplicación. las formas normales de codd también son una estrategia para eliminar la duplicación en esquemas de base de datos. incluso la programación orientada a objetos es una estrategia para organizar módulos y eliminar la duplicación. no debería sorprenderle, ya que se trata de programación estructurada. creo que el objetivo es evidente: localice los elementos duplicados y elimínelos siempre que pueda. g6: código en un nivel de abstracción incorrecto es importante crear abstracciones que separen conceptos generales de nivel superior de conceptos detallados de nivel inferior. para ello, en ocasiones creamos clases abstractas que contengan los conceptos de nivel superior y variantes los de nivel inferior. si lo hacemos, debemos asegurarnos de que la separación sea completa. todos los conceptos de nivel inferior deben estar en las variantes y los de nivel superior en la clase base. por ejemplo, constantes, variables o funciones de utilidad que solamente pertenezcan a la implementación detallada no deben aparecer en la clase base. la clase base no debe saber nada al respecto de estos elementos. esta regla también se aplica a archivos fuente, componentes y módulos. el diseño correcto de software requiere la separación de conceptos en distintos niveles y su inclusión en contenedores diferentes. en ocasiones, dichos contenedores son clases base o variantes, y en otros casos son archivos fuente, módulos o componentes. independientemente del caso, la separación debe ser completa. no queremos que conceptos de nivel inferior y superior se mezclen. fíjese en este código: public interface stack { object pop() throws emptyexception; void push(object o) throws fullexception; double percentfull(); class emptyexception extends exception {} class fullexception extends exception {} } la función percentfull se encuentra en el nivel de abstracción 366equivocado. aunque hay implementaciones de stack en las que el concepto de amplitud es razonable, otras no pueden conocer su nivel de amplitud. por tanto, la función debería incluirse en una interfaz derivada como boundedstack . pensará que la implementación podría devolver cero si la pila no tuviera límites. el problema es que no existen pilas totalmente sin límites. no se puede evitar outofmemoryexception mediante la comprobación de stack.percentfull() < 50.0. la implementación de esta función para que devuelva 0 sería una mentira. la moraleja es que no puede mentir o escapar de una abstracción mal ubicada. el aislamiento de abstracciones es una de las operaciones más complicadas para los desarrolladores de software y no se puede corregir cuando se realiza de forma incorrecta. g7: clases base que dependen de sus variantes el motivo más habitual para dividir conceptos en clases base y derivadas es para que los conceptos de nivel superior de la clase base sean independientes de los de nivel inferior de las derivadas. por ello, cuando vemos clases base que mencionan los nombres de sus variantes, se intuye un problema. por lo general, las clases base no deben saber nada sobre su derivadas. evidentemente, hay excepciones. en ocasiones, el número de variantes es fijo y la clase base tiene código que elegir entre las variantes. es muy habitual en implementaciones de equipos con estado finito. sin embargo, en ese caso las variantes y la clase base están íntimamente unidas y siempre se implementan en el mismo archivo jar. en el caso general, deben implementarse en archivos independientes. al implementar variantes y clases base en archivos diferentes y garantizar que los archivos de la clase base desconocen el contenido de los archivos de las variantes podemos implementar nuestros sistemas en componentes discretos e independientes. al modificar dichos componentes, se pueden volver a implementar sin necesidad de implementar de nuevo los componentes base. de este modo se reduce significativamente el impacto del 367cambio y se facilita el mantenimiento de los sistemas. g8: exceso de información los módulos bien definidos tienen interfaces reducidas que nos permiten hacer mucho con poco. los módulos definidos de forma incorrecta tienen interfaces más amplias que nos obligan a usar distintos gestos para realizar operaciones sencillas. una interfaz bien definida no ofrece demasiadas funciones y las conexiones son reducidas. una interfaz definida de forma incorrecta ofrece multitud de funciones que invocar y, por tanto, las conexiones son elevadas. los buenos programadores de software aprenden a limitar la parte de sus clases y módulos que muestran en sus interfaces. cuantos menos métodos tenga una clase, mejor. cuantas menos variables conozca una función, mejor. cuantas menos variables de instancia tenga una clase, mejor. oculte sus datos. oculte sus funciones de utilidad. oculte sus constantes y elementos temporales. no cree clases con multitud de métodos y variables de instancia. no cree multitud de variables y funciones protegidas para sus subclases. concéntrese en crear interfaces concisas y de tamaño reducido. limite la información para reducir las conexiones. g9: código muerto el código muerto es el que no se ejecuta. se encuentra en el cuerpo de una instrucción if que comprueba una condición que no sucede. se encuentra en el bloque catch de una instrucción try que carece de throws . se encuentra en pequeños métodos de utilidad que nunca se invocan o en condiciones switch/case inexistentes. el problema del código muerto es que con el tiempo empieza a oler. cuanto más antiguo es, más profundo el hedor que despide. se debe a que el código muerto no se actualiza al cambiar los diseños. sigue compilándose pero no se rige por nuevas convenciones o reglas. se creó en un momento en el que el sistema era diferente . debe tener un entierro digno. bórrelo del 368sistema. g10: separación vertical variables y funciones deben definirse cerca de donde se utilicen. las variables locales deben declararse por encima de su primer uso y deben tener un reducido ámbito vertical. no deben declararse a cientos de líneas de distancia de su uso. las funciones privadas deben definirse justo debajo de su primer uso. pertenecen al ámbito de la clase completa pero conviene limitar la distancia vertical entre las invocaciones y las definiciones. para localizar una función privada debe bastar con buscar debajo de su primer uso. g11: incoherencia si hace algo de una forma concreta, aplique la misma técnica a operaciones similares. esto entronca con el principio de mínima sorpresa. preste atención a las convenciones que elija y, una vez elegidas, asegúrese de mantenerlas. si en una función concreta usa la variable response para almacenar httpservletresponse , use el mismo nombre de variable en las demás funciones que usen objetos httpservletresponse . si asigna el nombre processverificationrequest a un método, use un nombre similar, como processdeletionrequest , para los métodos que procesen otros tipos de solicitudes. este tipo de coherencia, si se aplica repetidamente, facilita la lectura y modificación del código. g12: desorden ¿para qué sirve un constructor predeterminado sin implementación? únicamente desordena el código y lo inunda de elementos sin sentido. variables sin usar, funciones que nunca se invocan, comentarios que no añaden información, etc. todos estos elementos sobran y deben eliminarse. 369mantenga limpios sus archivos, bien organizados y sin elementos sobrantes. g13: conexiones artificiales los elementos que no dependen unos de otros no deben conectarse de forma artificial. por ejemplo, las enumeraciones generales no deben incluirse en clases más específicas ya que esto obliga a la aplicación a saber más sobre dichas clases. lo mismo sucede con funciones static de propósito general declaradas en clases específicas. por lo general, una conexión artificial es la que se establece entre dos módulos sin un propósito directo. es el resultado de incluir una variable, constante o función en una ubicación temporalmente útil pero inadecuada. es un síntoma de falta de atención. piense en dónde debe declarar sus funciones, constantes y variables. no las deje en el punto más cómodo. g14: envidia de las características uno de los síntomas de martin fowler [109] . los métodos de una clase deben interesarse por las variables y funciones de la clase a la que pertenecen, no por las variables y funciones de otras clases. cuando un método usa elementos de acceso y mutación de otro objeto para manipular los datos de éste, envidia el ámbito de la clase de dicho objeto. desea formar parte de la otra clase para tener acceso directo a las variables que manipula. por ejemplo: public class hourlypaycalculator { public money calculateweeklypay(hourlyemployee e) { int tenthrate = e.gettenthrate().getpennies(); int tenthsworked = e.gettenthsworked(); int straighttime = math.min(400, tenthsworked); int overtime = math.max(0, tenthsworked - straighttime); int straightpay = straighttime * tenthrate; int overtimepay = (int)math.round(overtime*tenthrate*1.5); return new money(straightpay + overtimepay); } } el método calculateweeklypay se acerca al objeto hourlyemployee para 370obtener los datos sobre los que opera. el método calculateweeklypay envidia el ámbito de hourlyemployee . su deseo es formar parte de hourlyemployee . es recomendable suprimir la envidia de características ya que muestra los detalles internos de una clase a otra. sin embargo, en ocasiones es un mal necesario. fíjese en lo siguiente: public class hourlyemployeereport { private hourlyemployee employee; public hourlyemployeereport(hourlyemployee e) { this.employee = e; } string reporthours() { return string.format( “name: %s\thours:%d.%1d\n”, employee.getname(), employee.gettenthsworked()/10, employee.gettenthsworked()%10); } } evidentemente, el método reporthours envidia la clase hourlyemployee . por otra parte, no queremos que hourlyemployee tenga que conocer el formato del informe. al incluir la cadena de formato en la clase hourlyemployee incumpliríamos varios de los principios del diseño orientado a objetos [110] . conectaría hourlyemployee al formato del informe y lo mostraría en los cambios de dicho formato. g15: argumentos de selector no hay nada más abominable que un argumento false aislado al final de la invocación de una función. ¿qué significa? ¿qué cambiaría si fuera true ? no sólo el propósito de un argumento de selector es difícil de recordar, sino que cada argumento de selector combina varias funciones en una. los argumentos de selector son una forma indolente de evitar dividir una función de gran tamaño en otras menores. fíjese en lo siguiente: public int calculateweeklypay(boolean overtime) { int tenthrate = gettenthrate(); int tenthsworked = gettenthsworked(); 371int straighttime = math.min(400, tenthsworked); int overtime = math.max(0, tenthsworked - straighttime); int straightpay = straighttime * tenthrate; double overtimerate = overtime ? 1.5 : 1.0 * tenthrate; int overtimepay = (int)math.round(overtime*overtimerate); return straightpay + overtimepay; } esta función se invoca con true si las horas extras se pagan como hora y media, y con false si se pagan como una hora normal. ya es bastante malo tener que recordar lo que significa calculateweeklypay(false) cada vez que aparezca. pero lo peor de esta función es que el autor ha perdido la oportunidad de crear lo siguiente: public int straightpay() { return gettenthsworked() * gettenthrate(); } public int overtimepay() { int overtimetenths = math.max(0, gettenthsworked() - 400); int overtimepay = overtimebonus(overtimetenths); return straightpay() + overtimepay; } private int overtimebonus(int overtimetenths) { double bonus = 0.5 * gettenthrate() * overtimetenths; return (int) math.round(bonus); } evidentemente, los selectores no deben ser boolean . pueden ser enumeraciones, enteros u otro tipo de argumento que se use para seleccionar el comportamiento de la función. es más recomendable tener varias funciones que pasar código a una función para seleccionar el comportamiento. g16: intención desconocida queremos que el código sea lo más expresivo posible. expresiones extensas, notación húngara y números mágicos distorsionan la intención del autor. por ejemplo, veamos la función overtimepay cómo podría haber aparecido: public int m_otcalc() { return ithswkd * ithsrte + (int) math.round(0.5 * ithsrte * math.max(0/ ithswkd - 400) ); } 372aunque parezca reducida y densa, también es prácticamente impenetrable. es recomendable dedicar tiempo a lograr que la intención de nuestro código sea aparente para nuestros lectores. g17: responsabilidad desubicada una de las principales decisiones de un programador de software es dónde ubicar el código. por ejemplo, dónde incluir la constante pi . ¿en la clase math ? ¿pertenece a la clase trigonometry ? ¿o a la clase circle ? el principio de mínima sorpresa vuelve a aparecer. el código debe ubicarse donde el lector espera encontrarlo. la constante pi debe incluirse junto a la declaración de las funciones trigonométricas. la constante overtime_rate debe declararse en la clase hourlypaycalculator . en ocasiones presumimos de dónde añadimos una determinada funcionalidad. incluimos una función porque nos resulta cómodo pero no porque sea intuitivo para el lector. por ejemplo, puede que tengamos que imprimir un informe con el total de horas que ha trabajado un empleado. podríamos sumar las horas en el código que imprime el informe o intentar mantener un total en el código que acepte horarios de trabajo. una forma de tomar esta decisión consiste en analizar el nombre de las funciones. imagine que el módulo del informe tiene la función gettotalhours . imagine también que el módulo que acepta horarios de trabajo tiene la función savetimecard . ¿cuál de las dos, por nombre, implica que calcula el total? la respuesta es evidente. existen motivos de rendimiento para calcular el total como horarios de trabajo y no como informe impreso. es correcto, pero el nombre de las funciones debería reflejarlo. por ejemplo, debería haber una función computerunningtotalofhours en el módulo de horarios. g18: elementos estáticos incorrectos math.max (double a, double b) es un método estático correcto. no opera 373en una única instancia; de hecho, sería un error tener que usar new math().max(a,b) o incluso a.max(b) . todos los datos que usa max provienen de sus dos argumentos, no de un objeto. además, es prácticamente imposible que queramos que math.max sea polimórfico. sin embargo, en ocasiones creamos funciones estáticas que no deben serlo. fíjese en este ejemplo: hourlypaycalculator.calculatepay(employee, overtimerate). de nuevo, parece una función estática razonable. no opera en un objeto concreto y recibe todos los datos de sus argumentos. sin embargo, existe la posibilidad de que queramos que sea polimórfica. puede que queramos implementar distintos algoritmos para calcular el precio de la hora, como por ejemplo. overtimehourlypaycalculator y straighttimehourlypaycalculator . en este caso, la función no debe ser estática. debería ser una función miembro no estática de employee . por lo general, debe decantarse por métodos no estáticos. en caso de duda, convierta la función en no estática. si realmente quiere que una función sea estática, asegúrese de que nunca querrá que sea polimórfica. g19: usar variables explicativas kent beck escribió sobre este tema en su magnífico libro smalltalk best practice patterns [111] y, más recientemente en implementation patterns [112] . una de las técnicas más completas para que un programa sea legible consiste en dividir los cálculos en valores intermedios almacenados en variables con nombres descriptivos. fíjese en este ejemplo de fitnesse: matcher match = headerpattern.matcher(line); if(match.find()) { string key = match.group(1); string value = match.group(2); headers.put(key.tolowercase(), value); } el simple uso de variables explicativas ilustra con claridad que el primer grupo comparado es la clave y el segundo es el valor . es complicado excederse en esta técnica. por lo general, es mejor tener más variables explicativas que menos. es sorprendente que un módulo opaco 374se vuelva más transparente con tan sólo dividir los cálculos en valores intermedios con los nombres adecuados. g20: los nombres de función deben indicar lo que hacen fíjese en este código: date newdate = date.add(5); ¿intuye que se añaden cinco días a la fecha o son semanas u horas? ¿la instancia date cambia y la función simplemente devuelve un nuevo objeto date sin cambiar el antiguo? por la invocación no podemos saber qué hace la función . si la función añade cinco días a la fecha y después la cambia, el nombre debería ser adddaysto o increasebydays . si, por otra parte, la función devuelve una nueva fecha con cinco días más pero no cambia la instancia date , el nombre debería ser dayslater o dayssince . si tiene que fijarse en la implementación (o documentación) de la función para saber qué hace, tendrá que elegir un nombre más apropiado o modificar la funcionalidad para que se pueda incluir en funciones con nombres más acertados. g21: comprender el algoritmo se crea gran cantidad de código extraño porque los autores no se esfuerzan en comprender el algoritmo. consiguen que algo funcione combinando instrucciones if e indicadores sin pararse a pensar en qué sucede realmente. la programación es una tarea de exploración. creemos que conocemos el algoritmo adecuado para algo pero después lo modificamos y variamos hasta conseguir que funcione . ¿cómo sabemos que funciona ? porque supera los casos de prueba que pensamos. no es un enfoque equivocado. de hecho, suele ser la única forma de conseguir que una función haga lo que pensamos que debe hacer. sin 375embargo, no basta con conseguir que funcione . antes de creer que hemos terminado con una función, asegúrese de entender su funcionamiento. no basta con que supere todas las pruebas. tiene que estar seguro [113] de que la solución es la correcta. por lo general, la forma óptima de saberlo consiste en refactorizar la función en algo tan limpio y expresivo que su funcionamiento sea evidente . g22: convertir dependencias lógicas en físicas si un módulo depende de otro, dicha dependencia debe ser física, no sólo lógica. el módulo dependiente no debe asumir aspectos (es decir, dependencias lógicas) sobre el módulo del que depende. por el contrario, debe solicitar de forma explícita al módulo toda la información de la que depende. por ejemplo, imagine que tiene que crear una función que imprima un informe de las horas trabajadas por cada empleado. la clase hourlyreporter recopila los datos y los pasa a hourlyreportformatter para imprimirlos (véase el listado 17-1). listado 17-1 hourlyreporter.java. public class hourlyreporter { private hourlyreportformatter formatter; private list<lineitem> page; private final int page_size = 55; public hourlyreporter(hourlyreportformatter formatter) { this.formatter = formatter; page = new arraylist<lineitem>(); } public void generatereport(list<hourlyemployee> employees) { for (hourlyemployee e : employees) { addlineitemtopage(e); if (page.size() == page_size) printandclearitemlist(); } if (page.size() > 0) printandclearitemlist(); 376} private void printandclearitemlist() { formatter.format(page); page.clear(); } private void addlineitemtopage(hourlyemployee e) { lineitem item = new lineitem(); item.name = e.getname(); item.hours = e.gettenthsworked() / 10; item.tenths = e.gettenthsworked() % 10; page.add(item); } public class lineitem { public string name; public int hours; public int tenths; } } este código tiene una dependencia lógica que no se ha convertido en física. ¿la detecta? es la constante page_size . ¿para qué necesita hourlyreporter saber el tamaño de la página? el tamaño de la página debe ser responsabilidad de hourlyreportformatter . la declaración de page_size en hourlyreporter representa una responsabilidad desubicada [g17] que hace que hourlyreporter asuma que conoce el tamaño que debe tener la página. esta presunción es una dependencia lógica. hourlyreporter depende de que hourlyreportformatter pueda procesar tamaños de página de hasta 55. si alguna implementación de hourlyreportformatter no puede asumir esos tamaños, se producirá un error. podemos convertir en física esta dependencia si creamos un nuevo método en hourlyreportformatter con el nombre getmaxpagesize() . tras ello, hourlyreporter invoca esta función en lugar de usar la constante page_size . g23: polimorfismo antes que if/else o switch/case puede parecer una sugerencia extraña dado el tema descrito en el capítulo 6. en este capítulo, afirmo que las instrucciones switch son adecuadas en partes del sistema en las que se añadan más funciones nuevas que tipos nuevos. 377por un lado, la mayoría usamos instrucciones switch por ser una solución de fuerza bruta evidente, no por ser la solución perfecta. por tanto, esta heurística nos recuerda que debemos considerar el uso de polimorfismo antes de usar switch . por otra parte, los casos en que las funciones son más volátiles que los tipos son escasos. por tanto, toda instrucción switch es sospechosa. suelo aplicar la siguiente regla de una instrucción switch : no puede haber más de una instrucción  switch  por cada tipo de selección. los casos de esa instrucción  switch  deben crear objetos polimórficos que ocupen el lugar de otras instrucciones  switch  similares en el resto del sistema . g24: seguir las convenciones estándar todos los equipos deben seguir un estándar de diseño de código basado en normas comunes de la industria. este estándar debe especificar aspectos como dónde declarar variables de instancia, cómo asignar nombres a clases, métodos y variables, dónde añadir llaves, etc. el equipo no debe necesitar un documento que describa estas convenciones ya que su código proporciona los ejemplos. todos los miembros del equipo deben seguir estas convenciones, lo que significa que no importa dónde añada cada uno las llaves mientras todos estén de acuerdo en dónde añadirlas. si desea saber qué convenciones aplico, puede verlas en el código refactorizado de los listados b.7 a b.14 del apéndice b. g25: sustituir números mágicos por constantes con nombre es probablemente una de las reglas más antiguas del desarrollo de software . recuerdo haberla leído a finales de la década de 1960 en manuales de cobol, fortran y pl/1. por lo general, no es recomendable incluir números sin procesar en el código; debe ocultarlos tras constantes con 378nombres correctos. por ejemplo, el número 86 400 debe ocultarse tras la constante seconds_per_day . si va a imprimir 55 líneas por página, la constante 55 debe ocultarse tras la constante lines_per_page . algunas constantes son tan fáciles de reconocer que no siempre necesitan una constante con nombre tras la que ocultarse mientras se usen junto a código explicativo. por ejemplo: double mileswalked = feetwalked/5280.0; int dailypay = hourlyrate * 8; double circumference = radius * math.pi * 2; ¿necesitamos realmente las constantes feet_per_mile, work_hours_per_day y two en los ejemplos anteriores? el último caso es absurdo. existen ciertas fórmulas en las que las constantes se escriben mejor como números sin procesar. puede cuestionar el caso de work_hours_per_day ya que las leyes o las convenciones pueden cambiar. por otra parte, esa fórmula se lee perfectamente si se incluye el 8 por lo que no es necesario añadir 17 más. en el caso de feet_per_mile , el número 5280 es una constante tan conocida y exclusiva que los lectores la reconocerán aunque se muestre de forma independiente en una página sin contexto alguno. constantes como 3.141592653589793 también son conocidas y reconocibles. sin embargo, la probabilidad de errores es alta y no conviene mostrarlas tal cual. siempre que alguien ve 3.1415927535890793, sabe que es π, y no se molestan en examinarlo (¿ha visto el error de un dígito?). tampoco queremos que la gente use 3.14, 3.14159, 3.142, y similares. por lo tanto, es una suerte contar con math.pi . el término número mágico no sólo se aplica a números, sino a todo símbolo que tenga un valor que no sea descriptivo por sí mismo. por ejemplo: assertequals(7777, employee.find(“john doe”).employeenumber()); en esta afirmación hay dos números mágicos. el primero es obviamente 7777, aunque no significa que no sea obvio. el segundo es « john doe » y su cometido tampoco está claro. “john doe” es el nombre del empleado #7777 en una conocida base de datos de pruebas creada por nuestro equipo. todo el mundo sabe que al 379conectarse a la base de datos, ya cuenta con varios empleados con sus valores y atributos. además, « john doe » representa el único empleado por horas de la base de datos. por tanto, la prueba debería ser la siguiente: assertequals( hourly_employee_id, employee.find(hourly_employee_name).employeenumber()); g26: precisión esperar que la primera coincidencia de una consulta sea la única es una ingenuidad. el uso de números de coma flotante para representar divisas es casi un delito. evitar bloqueos y/o la administración de transacciones por creer que las actualizaciones concurrentes no son posibles es pura indolencia. declarar una variable como arraylist cuando se necesita list es un exceso de restricciones. crear todas las variables como protected de forma predeterminada es falta de restricciones. al adoptar una decisión en el código, debe hacerlo de forma precisa. debe saber por qué la adopta y cómo afrontará las excepciones. no sea indolente sobre la precisión de sus decisiones. si decide invocar una función que pueda devolver null , asegúrese de comprobar null . si consulta el que considera el único registro de una base de datos, asegúrese de que el código comprueba que no haya otros. si tiene que trabajar con divisas, use enteros [114] y aplique el redondeo correcto. si existe la posibilidad de una actualización concurrente, asegúrese de implementar algún tipo de mecanismo de bloqueo. en el código, la ambigüedad y las imprecisiones son el resultado de desacuerdos o de indolencia. en cualquier caso, elimínelas. g27: estructura sobre convención aplique las decisiones de diseño con estructura y no convenciones. las convenciones de nomenclatura son correctas pero resultan inferiores a estructuras que refuerzan la compatibilidad. por ejemplo, los casos switch con enumeraciones de nombres correctos son inferiores a clases base con 380métodos abstractos. no estamos obligados a implementar siempre la instrucción switch/case de la misma forma, pero las clases base hacen que las clases concretas implementen métodos abstractos. g28: encapsular condicionales la lógica booleana es difícil de entender sin necesidad de verla en el contexto de una instrucción if o while . extraiga funciones que expliquen el cometido de la condicional. por ejemplo: if (shouldbedeleted(timer)) es preferible a if (timer.hasexpired() && !timer.isrecurrent()) g29: evitar condicionales negativas las condicionales negativas son más difíciles de entender que las positivas. por ello, siempre que sea posible, debe expresar las condiciones como positivas. por ejemplo: if (buffer.shouldcompact()) es preferible a if (!buffer.shouldnotcompact()) g30: las funciones sólo deben hacer una cosa es tentador crear funciones con varias secciones que realicen una serie de operaciones. este tipo de funciones hacen más de una cosa y deben convertirse en funciones de menor tamaño, cada una para una cosa . por ejemplo: public void pay() { for (employee e : employees) { if (e.ispayday()) { money pay = e .calculatepay(); e.deliverpay(pay); } } 381} este fragmento de código realiza tres operaciones. itera por todos los empleados, comprueba si cada uno debe recibir su paga y después paga al empleado. se podría reescribir de esta forma: public void pay() { for (employee e : employees) payifnecessary(e); } private void payifnecessary(employee e) { if (e.ispayday()) calculateanddeliverpay(e); } private void calculateanddeliverpay(employee e) { money pay = e.calculatepay(); e.deliverpay(pay); } cada una de estas funciones hace una sola cosa (véase el capítulo 3). g31: conexiones temporales ocultas las conexiones temporales suelen ser necesarias pero no debe ocultar la conexión. estructure los argumentos de sus funciones de modo que el orden de invocación sea evidente. fíjese en lo siguiente: public class moogdiver { gradient gradient; list<spline> splines; public void dive(string reason) { saturategradient(); reticulatesplines(); diveformoog(reason); } … } el orden de las tres funciones es importante. debe saturar el degradado antes de poder entrelazar las tiras, para después continuar. desafortunadamente, el código no aplica esta conexión temporal. otro programador podría invocar reticulatesplines antes de saturategradient , lo que generaría unsaturatedgradientexception . una solución más acertada sería: 382public class moogdiver { gradient gradient; list<spline> splines; public void dive(string reason) { gradient gradient = saturategradient(); list<spline> splines = reticulatesplines(gradient); diveformoog(splines, reason); } … } de este modo se muestra la conexión temporal generando una especie de embudo. cada función genera un resultado que la siguiente necesita de modo que no se pueden invocar en otro orden. puede argumentar que esto aumenta la complejidad de las funciones y tiene razón, pero ese incremento de complejidad sintáctica muestra la verdadera complejidad temporal de la situación. observará que he mantenido las variables de instancia. imagino que son necesarias para los métodos privados de las clases. incluso así, conservo los argumentos para que la conexión temporal sea explícita. g32: evitar la arbitrariedad argumente la estructura de su código y asegúrese de que la estructura del código comunica dicho argumento. si la estructura parece arbitraria, otros se verán con derecho a modificarla. si la estructura parece coherente en la totalidad del sistema, otros la usarán y conservarán la convención. por ejemplo, recientemente repasaba cambios realizados en fitnesse y descubrí lo siguiente: public class aliaslinkwidget extends parentwidget { public static class variableexpandingwidgetroot { … … } el problema es que variableexpandingwidgetroot no debía estar en el ámbito de aliaslinkwidget . es más, otras clases sin relación usaban aliaslinkwidget.variableexpandingwidgetroot y no tenían por qué saber 383nada de aliaslinkwidget . puede que el programador añadiera variableexpandingwidgetroot a aliaswidget por comodidad o que realmente pensara que debía formar parte del ámbito de aliaswidget . independientemente del motivo, el resultado será arbitrario. las clases públicas que no son utilidades de otra clase no deben incluirse en el ámbito de otra clase. la convención es convertirlas en públicas en el nivel superior de su paquete. g33: encapsular condiciones de límite las condiciones de límite son difíciles de controlar. aísle su procesamiento y no permita que se transfieran al resto del código. no necesitamos legiones de +1 y -1 por todas partes. fíjese en este ejemplo de fit: if (level + 1 < tags.length) { parts = new parse(body, tags, level + 1, offset + endtag); body = null; } level+1 aparece dos veces. es una condición de límite que debe encapsularse en una variable con un nombre como nextlevel . int nextlevel = level + 1; if(nextlevel < tags.length) { parts = new parse(body, tags, nextlevel, offset + endtag); body = null; } g34: las funciones sólo deben descender un nivel de abstracción las instrucciones de una función deben crearse en el mismo nivel de abstracción, un nivel por debajo de la operación descrita por el nombre de la función. puede que sea la heurística más difícil de interpretar y aplicar. aunque la idea es simple, como humanos nos cuesta mezclar niveles de abstracción. fíjese en el siguiente código de fitnesse: public string render() throws exception { 384stringbuffer html = new stringbuffer(“<hr”); if(size > 0) html.append(“ size=\“”).append(size + 1).append(“\””); html.append(“>”); return html.tostring(); } si lo analiza, verá lo que sucede. esta función crea la etiqueta html que traza una regla horizontal por la página. la altura de la regla se especifica en la variable size . fíjese otra vez en el código. este método mezcla al menos dos niveles de abstracción. el primero es la noción de que una regla horizontal tiene un tamaño. el segundo es la sintaxis de la propia etiqueta hr . el código proviene del módulo hrulewidget de fitnesse. este módulo detecta una fila de cuatro o más guiones y la convierte en la correspondiente etiqueta hr . cuantos más guiones haya, mayor será el tamaño. a continuación le muestro la refactorización del código. he cambiado el nombre del campo size para reflejar su verdadero cometido. contenía el número de guiones adicionales. public string render() throws exception { htmltag hr = new htmltag(“hr”); if (extradashes > 0) hr.addattribute(“size”, hrsize(extradashes)); return hr.html(); } private string hrsize(int height) { int hrsize = height + 1; return string.format(“%d”, hrsize); } este cambio separa correctamente los dos niveles de abstracción. la función render simplemente crea una etiqueta hr sin tener que saber nada sobre su sintaxis html. el módulo htmltag se encarga de los problemas sintácticos. de hecho, al realizar este cambio detecté un sutil error. el código original no incluía la barra final en la etiqueta hr , como haría el estándar xhtml (es decir, generaba <hr> en lugar de <hr/> ). el módulo htmltag se había modificado hace tiempo para ajustarlo a xhtml. 385la separación de niveles de abstracción es una de las tareas más importantes de la refactorización, y también una de las más complejas. por ejemplo, fíjese en el siguiente código. fue mi primer intento de separar los niveles de abstracción del método hrulewidget.render . public string render() throws exception { htmltag hr = new htmltag(“hr”); if (size > 0) { hr.addattribute (“size”, “”+(size+1)); } return hr.html(); } mi objetivo, en esta fase, es crear la separación necesaria y conseguir superar las pruebas. el objetivo lo alcancé fácilmente pero el resultado fue una función con niveles de abstracción mezclados. en este caso, fueron obra de la etiqueta hr y de la interpretación y el formato de la variable size. esto indica que al dividir una función en líneas de abstracción, suelen aparecer nuevas líneas de abstracción ocultas por la estructura anterior. g35: mantener los datos configurables en los niveles superiores si tiene una constante como un valor predeterminado o de configuración que se conoce y se espera en un nivel superior de abstracción, no debe sepultarla en una función de nivel inferior. muéstrela como argumento para esa función de nivel inferior invocado desde la función de nivel superior. fíjese en este ejemplo de fitnesse: public static void main(string[] args) throws exception { arguments arguments = parsecommandline(args); … } public class arguments { public static final string default_path = “.”; public static final string default_root = “fitnesseroot”; public static final int default_port = 80; public static final int default_version_days = 14; … } 386los argumentos de línea de comandos se analizan en la primera línea ejecutable de fitnesse. los valores predeterminados de dichos argumentos se especifican al inicio de la clase argument . no tiene que buscar instrucciones como la siguiente en los niveles inferiores del sistema: if (arguments.port == 0) // usar 80 de forma predeterminada las constantes de configuración se encuentran en un nivel superior y son fáciles de cambiar. se pasan al resto de la aplicación. los niveles inferiores de la aplicación no poseen los valores de estas constantes. g36: evitar desplazamientos transitivos por lo general, no es recomendable que un módulo sepa demasiado sobre sus colaboradores. en concreto, si a colabora con b y b con c, no queremos que los módulos que usan a sepan nada sobre c (por ejemplo, o queremos a.getb().getc().dosomething(); ). es lo que en ocasiones se denomina ley de demeter. los programadores pragmáticos lo denominan crear código silencioso [115] . en cualquier caso, se trata de garantizar que los módulos sólo tienen conocimiento de sus colaboradores inmediatos y no del mapa de navegación completo del sistema. si varios módulos usan alguna variante de la instrucción a.getb().getc() , sería complicado cambiar el diseño y la arquitectura para intercalar q entre b y c. tendría que localizar todas las instancias de a.getb().getc() y convertirlas a a.getb().getq().getc() . es la forma en que las arquitecturas se vuelven rígidas. demasiados módulos saben demasiado sobre la arquitectura. por el contrario, queremos que nuestros colaboradores intermedios ofrezcan todos los servicios que necesitamos. no debemos deambular por el gráfico de objetos del sistema en busca del método que necesitamos invocar. bastaría con poder usar: mycollaborator.dosomething(). java 387j1: evitar extensas listas de importación mediante el uso de comodines si usa dos o más clases de un paquete, importe el paquete completo con import package.*; las listas extensas de importaciones intimidan al lector. no queremos colapsar la parte superior de los módulos con 80 líneas de importaciones, sino que sean una instrucción concisa de los paquetes con los que colaboramos. las importaciones específicas son dependencias rígidas, mientras que las importaciones de comodín no. si importa una clase concreta, esa clase debe existir, pero si importa un paquete con un comodín, no es necesario que existan clases concretas. la instrucción de importación simplemente añade el paquete a la ruta de búsqueda al localizar los nombres. por tanto, no se genera una verdadera dependencia en estas importaciones y permiten aligerar las conexiones de nuestros módulos. en ocasiones, la lista extensa de importaciones puede resultar útil. por ejemplo, si tiene que trabajar con código de legado y desea saber para qué clases crear elementos ficticios, puede examinar la lista de importaciones concretas para determinar los verdaderos nombres cualificados de todas esas clases y después añadirlos. no obstante, este uso de las importaciones concretas no es habitual. es más, muchos ide modernos le permiten convertir las importaciones con comodines en una lista de importaciones concretas con un solo comando. por tanto, incluso en el caso anterior, es recomendable usar comodines. las importaciones de comodín pueden probar conflictos de nombres y ambigüedades. dos clases con el mismo nombre pero en paquetes diferentes tienen que importarse de forma concreta o al menos cualificarse de forma específica cuando se usen. puede resultar molesto pero no es habitual que el uso de importaciones de comodín sea más indicado que el de importaciones concretas. j2: no heredar constantes lo he visto muchas veces y siempre me molesta. un programador añade 388constantes a una interfaz y después accede a las mismas heredando dicha interfaz. fíjese en el siguiente código: public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } ¿de dónde salen las constantes tenths_per_week y overtime_rate ? puede que provengan de la clase employee ; comprobémoslo: public abstract class employee implements payrollconstants { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } no, de ahí no. ¿entonces de dónde? fíjese atentamente en la clase employee . implementa payrollconstants . public interface payrollconstants { public static final int tenths_per_week = 400; public static final double overtime_rate = 1.5; } es horrible. las constantes se ocultan en la parte superior de la jerarquía de herencia. no use la herencia para burlar las reglas de ámbito del lenguaje. use una importación estática: import static payrollconstants.*; public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } 389j3: constantes frente a enumeraciones ahora que se han añadido enumeraciones al lenguaje (java 5), ¡úselas! no recurra al viejo truco de public static final int . el significado de int se puede perder. el de enum no, ya que pertenece a una enumeración con nombre. es más, analice atentamente la sintaxis de las enumeraciones . pueden tener métodos y campos, lo que las convierte en potentes herramientas que ofrecen mayor expresividad y flexibilidad que los int . fíjese en esta variante del código: public class hourlyemployee extends employee { private int tenthsworked; hourlypaygrade grade; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( grade.rate() * (tenthsworked + overtime_rate * overtime) ); } … } public enum hourlypaygrade { apprentice { public double rate() { return 1.0; } }, leutenant_journeyman ( public double rate() { return 1.2; } }, journeyman { public double rate() { return 1.5; } }, master { public double rate() { return 2.0; } }; public abstract double rate(); 390} nombres n1: elegir nombres descriptivos no sea demasiado rápido a la hora de elegir un nombre. asegúrese de que sea descriptivo. recuerde que los significados suelen variar cuando el código evoluciona, de modo que debe revisar frecuentemente la corrección de los nombres elegidos. no es una recomendación de sensaciones. en software , los nombres constituyen el 90 por 100 de su legibilidad. dedique tiempo a seleccionarlos con atención y mantenga su relevancia. los nombres son demasiado importantes como para tratarlos mal. fíjese en el siguiente código. ¿para qué sirve? si le muestro el mismo código con nombres bien elegidos, tendrá sentido, pero con este formato no es más que una masa de símbolos y números mágicos. public int x() { int q = 0; int z = 0; for (int kk = 0; kk < 10; kk++) { if (l[z] == 10) { q += 10 + (l[z + 1] + l[z + 2]); z += 1; } else if (l[z] + l[z + 1] == 10) { q += 10 + l[z + 2]; z += 2; } else { q += l[z] + l[z + 1]; z += 2; } } return q; } a continuación, el código como debería haberse escrito. este fragmento es en realidad menos completo que el anterior, pero detectará inmediatamente 391lo que intenta hacer y es probable que pudiera crear las funciones que faltan en función de ese significado que intuye. los números mágicos ya no lo son y la estructura del algoritmo es descriptiva y atractiva: public int score() { int score = 0; int frame = 0; for (int framenumber = 0; framenumber < 10; framenumber++) { if (isstrike(frame)) { score += 10 + nexttwoballsforstrike(frame); frame += 1; } else if (isspare(frame)) { score += 10 + nextballforspare(frame); frame += 2; } else { score += twoballsinframe(frame); frame += 2; } } return score; } los nombres bien elegidos inundan la estructura del código con descripciones. dicha inundación define las expectativas del lector sobre el cometido de otras funciones del módulo. puede inferir la implementación de isstrike() si se fija en el código anterior. cuando lea el método isstrike , será prácticamente lo que esperaba [116] . private boolean isstrike(int frame) { return rolls[frame] = 10; } n2: elegir nombres en el nivel correcto de abstracción no elija nombres que comuniquen implementación; seleccione nombres que reflejen el nivel de abstracción de la clase o la función con la que trabaje. es complicado. de nuevo, nos cuesta mezclar niveles de abstracción. siempre que realice una pasada por su código, es probable que encuentre una variable con nombre en un nivel demasiado bajo. cambie esos nombres cuando los vea. para que el código sea legible se necesita una mejora continua. fíjese en la siguiente interfaz modem : public interface modem { 392boolean dial(string phonenumber); boolean disconnect(); boolean send(char c); char recv(); string getconnectedphonenumber(); } inicialmente parece correcta. las funciones parecen las adecuadas. de hecho lo son para muchas aplicaciones, pero piense ahora en una aplicación en la que algunos módems no se conecten mediante marcación telefónica, sino mediante cables (como los usados para conexiones domésticas a internet). puede que algunos se conecten enviando un número de puerto a un concentrador a través de una conexión usb. es evidente que la noción de números de teléfono se encuentra en un nivel de abstracción equivocado. una estrategia de nomenclatura más adecuada para este caso sería la siguiente: public interface modem { boolean connect(string connectionlocator); boolean disconnect(); boolean send(char c); char recv(); string getconnectedlocator(); } ahora los nombres no se limitan a números de teléfono. se pueden usar para números de teléfono o para otros tipos de estrategia de conexión. n3: usar nomenclatura estándar siempre que sea posible los nombres son más fáciles de entender si se basan en una convención o un uso existente. por ejemplo, si emplea el patrón decorator , debería usar la palabra decorator en los nombres de las clases. por ejemplo, autohangupmodemdecorator podría ser el nombre de una clase que permite a un módem colgar automáticamente al final de una sesión. los patrones son un tipo de estándar. en java, por ejemplo, las funciones que convierten objetos en representaciones de cadena suelen tener el nombre tostring . es mejor seguir estas convenciones que inventar otras propias. los equipos suelen inventar su propio sistema estándar de nombres para un proyecto concreto. eric evans lo denomina lenguaje omnipresente del 393proyecto [117] . su código debe usar los términos de este lenguaje. en definitiva, cuantos más nombres con significado especial y relevante para su proyecto utilice, más fácil será para los lectores saber de qué trata el código. n4: nombres inequívocos seleccione nombres que ilustren de forma inequívoca el funcionamiento de funciones y variables. fíjese en este ejemplo de fitnesse: private string dorename() throws exception { if (refactorreferences) renamereferences(); renamepage(); pathtorename.removenamefromend(); pathtorename.addnametoend(newname); return pathparser.render(pathtorename); } el nombre de esta función no indica qué hace, al menos en términos amplios y sin concretar. además, se refuerza por la presencia de la función renamepage dentro de la función dorename . ¿qué indican los nombres sobre la diferencia entre ambas funciones? nada. un nombre más acertado para la función sería renamepageandoptionallyallreferences . puede parecerle extenso, y lo es, pero sólo se invoca desde un punto del módulo, de modo que su valor descriptivo supera su longitud. n5: usar nombres extensos para ámbitos extensos la longitud de un nombre debe estar relacionada con la de su ámbito. puede usar nombres de variables breves para ámbitos diminutos pero en ámbitos mayores debe emplear nombres extensos. los nombres de variables como i y j son correctos si su ámbito tiene cinco líneas de longitud. fíjese en el siguiente fragmento del conocido juego de los bolos: private void rollmany(int n, int pins) { for (int i=0; i<n; i++) 394g.roll(pins); } es totalmente claro y se complicaría si la variable i se cambiara por algo como rollcount . por otra parte, las variables y funciones con nombres breves pierden su significado en las grandes distancias. por tanto, cuanto mayor sea el ámbito del nombre, más extenso y preciso tendrá que ser el nombre. n6: evitar codificaciones los nombres no deben codificarse con información de tipos o ámbitos. prefijos como m_ o f no sirven de nada en los entornos actuales. además, codificaciones de proyecto y/o subsistema como vis_ (para un sistema de imágenes visuales) distraen la atención y son redundantes. los entornos actuales proporcionan toda esa información sin tener que modificar los nombres. aleje sus nombres de la contaminación húngara. n7: los nombres deben describir efectos secundarios los nombres deben describir todo lo que haga una función, variable o clase. no oculte efectos secundarios con un nombre. no utilice un simple verbo para describir una función que realiza algo más que una simple acción. fíjese en este código de testng: public objectoutputstream getoos() throws ioexception { if (m_oos == null) { m_oos = new objectoutputstream(m_socket.getoutputstream()); } return m_oos; } esta función hace algo más que obtener oos ; lo crea si todavía no se ha creado. por lo tanto, un nombre más acertado sería createorreturnoos . pruebas (test) 395t1: pruebas insuficientes ¿cuántas pruebas debe incluir una suite de pruebas? desafortunadamente, muchos programadores dirían que las que parezcan suficientes. una suite de pruebas debe probar todo lo que pueda fallar. las pruebas son insuficientes mientras haya condiciones que no se hayan examinado o cálculos que no se hayan validado. t2: usar una herramienta de cobertura las herramientas de cobertura indican vacíos en su estrategia de pruebas. facilitan la detección de módulos, clases y funciones insuficientemente probadas. muchos ide le ofrecen un indicador visual y marcan en verde las líneas cubiertas y en rojo las no cubiertas. de este modo es más rápido y sencillo detectar instrucciones if o catch cuyos cuerpos no se han comprobado. t3: no ignorar pruebas triviales son fáciles de redactar y su valor documental es mayor que el coste de crearlas. t4: una prueba ignorada es una pregunta sobre una ambigüedad en ocasiones dudamos de un detalle de comportamiento porque los requisitos no son claros. podemos expresar nuestra duda sobre los requisitos en forma de prueba comentada o como prueba anotada con @ignore . la decisión depende de si la ambigüedad es sobre algo que se compila o no. t5: probar condiciones de límite 396preste especial atención a las pruebas de condiciones de límite. solemos acertar con la parte central de un algoritmo pero malinterpretar los límites. t6: probar de forma exhaustiva junto a los errores los errores suelen congregarse. si detecta un error en una función, es recomendable probarla de forma exhaustiva. seguramente no sea el único error. t7: los patrones de fallo son reveladores en ocasiones diagnosticamos un problema detectando patrones de fallo en los casos de prueba. es otro argumento para crear casos de prueba lo más completos posibles. los casos de prueba completos, si se ordenan de forma razonable, revelan patrones. como ejemplo, imagine que ha detectado que todas las pruebas con un entero mayor de cinco caracteres fallan. o que fallan todas las pruebas que pasan un número negativo al segundo argumento de una función. en ocasiones, con ver el patrón de rojos y verdes de un informe de pruebas basta para hacer saltar la chispa y llegar a una solución. en el capítulo 16 encontrará un interesante ejemplo en el caso de serialdate . t8: los patrones de cobertura de pruebas pueden ser reveladores el análisis del código que se ejecuta o no en las pruebas superadas suele indicar porqué fallan las pruebas no superadas. t9: las pruebas deben ser rápidas una prueba lenta no se ejecuta. cuando las cosas se ponen feas, las pruebas lentas se eliminan de la suite . por lo tanto, intente que sus pruebas sean 397rápidas. conclusión esta lista de heurística y síntomas no se podría considerar completa. de hecho, dudo de que alguna vez exista alguna. pero puede que ese no sea el objetivo, ya que lo que implica esta lista es un sistema de valores. el sistema de valores ha sido el objetivo y la base de este libro. el código limpio no se crea siguiendo una serie de reglas. no se convertirá en un maestro del software aprendiendo una lista de heurísticas. la profesionalidad y la maestría provienen de los valores que impulsan las disciplinas. bibliografía [refactoring] : refactoring: improving the design of existing code , martin fowler et al., addison-wesley, 1999. [prag] : the pragmatic programmer , andrew hunt, dave thomas, addison-wesley, 2000. [gof] : design patterns: elements of reusable object oriented software , gamma et al., addison-wesley, 1996. [beck97] : smalltalk best practice patterns , kent beck, prentice hall, 1997. [beck07] : implementation patterns , kent beck, addison-wesley, 2008. [ppp] : agile software development: principles, patterns, and practices , robert c. martin, prentice hall, 2002. [ddd] : domain driven design , eric evans, addison-wesley, 2003. 398apéndice a concurrencia ii por brett l. schuchert este apéndice complementa y amplía el capítulo 13 sobre concurrencia. se ha escrito como una serie de temas independientes que puede leer en el orden que desee. algunas secciones están duplicadas para facilitar dicha lectura. ejemplo cliente/servidor imagine una sencilla aplicación cliente/servidor. un servidor espera a que un cliente se conecte. un cliente se conecta y envía una solicitud. el servidor a continuación le mostramos una versión simplificada de una aplicación de servidor. el código completo de este ejemplo se recoge en el listado a-3. serversocket serversocket = new serversocket(8009); while (keepprocessing) { try { socket socket = serversocket.accept(); process(socket); } catch (exception e) { handle(e); } 399} esta sencilla aplicación espera una conexión, procesa un mensaje entrante y vuelve a esperar a la siguiente solicitud cliente. el código cliente para conectarse al servidor es el siguiente: private void connectsendreceive(int i) { try { socket socket = new socket (“localhost”, port); messageutils.sendmessage(socket, integer.tostring(i)); messageutils.getmessage(socket); socket.close(); } catch (exception e) { e.printstacktrace(); } } ¿cómo se comporta esta combinación de cliente y servidor? ¿cómo podemos describir formalmente ese rendimiento? la siguiente prueba afirma que el rendimiento es aceptable: @test(timeout = 10000) public void shouldruninunder10seconds() throws exception { thread[] threads = createthreads(); startallthreadsw(threads); waitforallthreadstofinish(threads); } se omite la configuración para que el ejemplo sea sencillo (véase “ clienttest.java ” más adelante). esta prueba afirma que debe completarse en 10 000 milisegundos. es un ejemplo clásico de validación del rendimiento de un sistema. este sistema debe completar una serie de solicitudes cliente en 10 segundos. mientras el servidor pueda procesar cada solicitud cliente a tiempo, la prueba será satisfactoria. ¿qué sucede si la prueba falla? aparte de desarrollar algún tipo de bucle de consulta de eventos, no hay mucho que hacer en un único proceso para aumentar la velocidad de este código. ¿se solucionaría el problema con varios procesos? puede, pero necesitamos saber cómo se consume el tiempo. hay dos posibilidades: e/s: con un socket, conectándose a la base de datos, esperando al intercambio de memoria virtual, etc. procesador: cálculos numéricos, procesamiento de expresiones 400regulares, recolección de elementos sin usar, etc. los sistemas suelen tener uno de cada, pero para una operación concreta suele haber uno dominante. si el código se vincula al procesador, mayor cantidad de hardware de procesamiento puede mejorar el rendimiento y hacer que se supere la prueba, pero no hay tantos ciclos de cpu disponibles, de modo que añadir procesos a un problema vinculado al procesador no hará que aumente la velocidad. por otra parte, si el proceso está vinculado a e/s, la concurrencia puede aumentar la eficacia. cuando una parte del sistema espera a e/s, otra puede usar ese tiempo de espera para procesar algo distinto, maximizando el uso eficaz de la cpu disponible. añadir subprocesos imagine que la prueba de rendimiento falla. ¿cómo podemos mejorar la producción para que la prueba de rendimiento sea satisfactoria? si el método process del servidor está vinculado a la e/s, existe una forma de conseguir que el servidor use subprocesos (basta con cambiar processmessage): void process (final socket socket) { if (socket == null) return; runnable clienthandler = new runnable() { public void run() { try { string message = messageutils.getmessage(socket); messageutils.sendmessage(socket, “processed: ” + message); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } }; thread clientconnection = new thread(clienthandler); clientconnection.start(); } asuma que este cambio hace que la prueba se supere [118] ; el código es completo, ¿correcto? 401observaciones del servidor el servidor actualizado completa satisfactoriamente la prueba en algo más de un segundo. desafortunadamente, la solución genera ciertos problemas. ¿cuántos subprocesos podría crear nuestro servidor? el código no define límites de modo que podríamos alcanzar el impuesto por la máquina virtual de java (mvj), suficiente en muchos sistemas sencillos. ¿pero y si el sistema tiene que asumir multitud de usuarios de una red pública? si se conectan demasiados usuarios al mismo tiempo, el sistema podría colapsarse. pero dejemos temporalmente este problema de comportamiento. la solución mostrada tiene problemas de limpieza y estructura. ¿cuántas responsabilidades tiene el código del servidor? administración de conexiones. procesamiento de clientes. política de subprocesos. política de cierre del servidor. desafortunadamente, todas estas responsabilidades se encuentran en la función process . además, el código cruza varios niveles diferentes de abstracción. por tanto, a pesar de la reducida función process , es necesario dividirlo. existen varios motivos para cambiar el servidor; por tanto, incumple el principio de responsabilidad única. para mantener la limpieza de un sistema concurrente, la administración de subprocesos debe limitarse a una serie de puntos controlados. es más, el código que gestione los subprocesos únicamente debe encargarse de la gestión de subprocesos. ¿por qué? si no existe otro motivo, el control de problemas de concurrencia ya es lo suficientemente complicado como para generar simultáneamente otros problemas no relacionados con la concurrencia. si creamos una lista independiente para cada una de las responsabilidades anteriores, incluyendo la administración de subprocesos, al cambiar la estrategia de administración de subprocesos, el cambio tiene un menor impacto sobre el código y no contamina a otras responsabilidades. de este 402modo también es más sencillo probar las demás responsabilidades sin necesidad de preocuparse de los subprocesos. veamos la versión actualizada que se encarga de ello: public void run() { while (keepprocessing) { try { clientconnection clientconnection = connectionmanager.awaitclient(); clientrequestprocessor requestprocessor = new clientrequestprocessor(clientconnection); clientscheduler.schedule(requestprocessor); } catch (exception e) { e.printstacktrace(); } } connectionmanager.shutdown(); } ahora centra en el mismo punto todos los aspectos relacionados con los subprocesos: clientscheduler . si hay problemas de concurrencia, bastará con examinar un punto concreto: public interface clientscheduler { void schedule(clientrequestprocessor requestprocessor); } la política actual es fácil de implementar: public class threadperrequestscheduler implements clientscheduler { public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; thread thread = new thread(runnable); thread.start(); } } tras aislar la administración de subprocesos, resulta más sencillo cambiar el control de los mismos. por ejemplo, para cambiar a la estructura executor de java 5 es necesario crear una nueva clase y conectarla (véase el listado a-1). listado a-1 403executorclientscheduler.java. import java.util.concurrent.executor; import java.util.concurrent.executors; public class executorclientscheduler implements clientscheduler { executor executor; public executorclientscheduler(int availablethreads) { executor = executors.newfixedthreadpool(availablethreads); } public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; executor.execute(runnable); } } conclusión en este ejemplo concreto, la presencia de la concurrencia ilustra una forma de mejorar la producción de un sistema y otra de validar dicha producción a través de una estructura de pruebas. al centrar el código de concurrencia en un número reducido de clases, aplicamos el principio de responsabilidad única. en el caso de la programación concurrente, resulta especialmente importante debido a su complejidad. posibles rutas de ejecución repase el método incrementvalue , un método de java de una línea sin bucles ni ramificaciones: public class idgenerator { int lastidused; public int incrementvalue() { return ++lastidused; } } ignore el desbordamiento de enteros e imagine que solamente un 404subproceso accede a una instancia de idgenerator . en este caso existe una sola ruta de ejecución y un único resultado garantizado: el valor devuelto es igual al valor de lastidused , y ambos son una unidad mayores que antes de invocar el método. ¿qué sucede si usamos dos subprocesos y no cambiamos el método? ¿cuáles son los posibles resultados si cada subproceso invoca incrementvalue una vez? ¿cuántas rutas de ejecución posibles hay? primero, los resultados (imagine que el valor inicial de lastidused es 93): el primer subproceso obtiene el valor 94, el segundo el valor 95 y lastidused es 95. el primer subproceso obtiene el valor 95, el segundo el valor 94 y lastidused es 95. el primer subproceso obtiene el valor 94, el segundo el valor 94 y lastidused es 94. el resultado final, aunque sorprendente, es posible. para ver los distintos resultados, debemos comprender las diferentes rutas de ejecución posibles y cómo las ejecuta la mvj. número de rutas para calcular el número de rutas de ejecución posibles, comenzaremos con el código de bytes generado. la única línea de java ( return ++lastidused; ) se convierte en ocho instrucciones de código de bytes . los dos subprocesos pueden intercambiar la ejecución de estas ocho instrucciones del mismo modo que mezclamos las cartas de una baraja [119] . incluso con sólo ocho cartas en cada mano, el número de posibles resultados es sorprendente. para este sencillo caso de n instrucciones en una secuencia, sin bucles ni condicionales y t subprocesos, el número total de posibles rutas de ejecución es igual a: 405(nt)! n! t calcular las órdenes posibles extraído de un correo electrónico de uncle bob a brett: con n pasos y t subprocesos hay t * n pasos totales. antes de cada paso hay un conmutador de contexto que elige entre los subprocesos. por tanto, cada ruta se representa como una cadena de dígitos que denota los cambios de contexto. dados los pasos a y b y los subprocesos 1 y 2, las seis rutas posibles son 1122, 1212, 1221, 2112, 2121 y 2211. o, en términos de pasos, a1b1a2b2, a1a2b1b2, a1a2b2b1, a2a1b1b2, a2a1b2b1 y a2b2a1b1. para tres subprocesos, la secuencia sería 112233, 112323, 113223, 113232, 112233, 121233, 121323, 121332, 123132, 123123… una característica de estas cadenas es que siempre debe haber n instancias de cada t . por tanto, la cadena 111111 no es válida ya que tiene seis instancias de 1 y ninguna de 2 y 3. por tanto, necesitamos las permutaciones de n 1, n 2… y n  t . en realidad son las permutaciones de n * t tomando cada vez n * t , que es (n * t)! , pero sin los duplicados. por tanto, el truco consiste en contar los duplicados y restarlos de (n * t)! . dados dos pasos y dos subprocesos, ¿cuántos duplicados hay? cada cadena de cuatro dígitos tiene dos 1 y dos 2. estos pares se pueden intercambiar sin modificar el sentido de la cadena. podríamos intercambiar los 1 o los 2, o ninguno. por tanto hay cuatro isomorfas por cada cadena, lo que significa que hay tres duplicados, de modo que tres de las cuatro opciones son duplicados; por otra parte, una de las cuatro permutaciones no son duplicados. 4! * .25 = 6. este razonamiento parece funcionar. ¿cuántos duplicados hay? si n = 2 y t = 2, podría intercambiar los 1, los 2, o ambos. en el caso de n = 2 y t = 3, podría intercambiar los 1, los 2, los 3, 1 y 2, 1 y 3, o 2 y 3. el intercambio son las permutaciones de n . imagine que hay p permutaciones de n . el número de formas diferentes de organizar dichas permutaciones es p**t . por tanto el número de isomorfas posibles es n!**t . y el número de rutas es ( t*n )!/( n!**t ). de nuevo, en nuestro caso t = 2, n = 2 obtenemos 6 (24/4). para n = 2 y t = 3 obtenemos 720/8 = 90. para n = 3 y t = 3 obtenemos 9!/6^3 = 1680. en nuestro sencillo caso de una sola línea de código java, que equivale a ocho líneas de código de bytes y a dos subprocesos, el número total de posibles rutas de ejecución es 12 870. si el tipo de lastidused es long , cada lectura y escritura se convierte en dos operaciones y no una, y el número de posibilidades asciende a 2 704 156. ¿qué sucede si realizamos un cambio en este método? 406public synchronized void incrementvalue() { ++lastidused; } el número de posibles rutas de ejecución es dos para dos subprocesos y n! para el caso general. un examen más profundo ¿qué piensa del sorprendente resultado de dos subprocesos que invoquen el método una vez (antes de añadir synchronized ) y obtengan el mismo resultado numérico? ¿cómo es posible? vayamos por partes. ¿qué es una operación atómica? podemos definir una operación atómica como toda operación ininterrumpible. por ejemplo, en el siguiente código, la línea 5, donde se asigna 0 a lastid , es atómica ya que de acuerdo al modelo de memoria de java, la asignación a un valor de 32 bits es ininterrumpible. 01: public class example { 02: int lastid; 03: 04: public void resetid() { 05: value = 0; 06: } 07: 08: public int getnextid() { 09: ++value; 10: } 11: } ¿qué sucede si cambiamos el tipo de lastid de int a long ? ¿sigue siendo atómica la línea 5? no de acuerdo a la especificación de la mvj. podría ser atómica en un procesador concreto, pero según la especificación de la mvj, la asignación a un valor de 64 bits requiere dos asignaciones de 32 bits. esto significa que entre la primera y la segunda podría irrumpir otro subproceso y cambiar uno de los valores. ¿y qué sucede con el operador de preincremento, ++ , de la línea 9? este operador se puede interrumpir, de modo que no es atómico. para entenderlo, repasemos el código de bytes de ambos métodos. antes de continuar, hay tres definiciones importantes: 407marco: la invocación de un método requiere un marco, el cual incluye la dirección de devolución, los parámetros pasados al método y las variables locales definidas en el mismo. es una técnica estándar empleada para definir una pila de invocaciones, que se usa en muchos lenguajes modernos para permitir la invocación de funciones y métodos básicos, además de invocaciones recursivas. variable local: las variables definidas en el ámbito del método. todos los métodos no estáticos tienen al menos una variable, this , que representa el objeto actual, el objeto que ha recibido el último mensaje (en el subproceso actual) que ha propiciado la invocación del método. pila de operandos: muchas instrucciones de la mvj aceptan parámetros. la pila de operandos es donde se incluyen dichos parámetros. la pila es una estructura de datos lifo ( last-in, first-out o último en entrar, primero en salir) estándar. veamos el código de bytes generado para resetid(). nemónico descripción pila de operandos posterior aload 0 cargar la variable 0 a en la pila de operandos. ¿qué es la variable 0 a ? es this. , el objeto actual. al invocar el método, el receptor del mensaje, una instancia de example , se envía a la matriz de variables locales del marco creado para la invocación de métodos. siempre es la primera variable que se añade a todos los métodos de instancia. this iconst_0 incluir el valor constante 0 en la pila de operandos. this, 0 putfield lastid almacenar el valor superior de la pila (0) en el valor de campo del objeto denominado por la referencia de objeto una posición alejada de la parte superior de la pila, this . <vacío> 408estas tres instrucciones son atómicas ya que a pesar de que el subproceso que las ejecuta podría verse interrumpido por cualquiera de ellas, la información para la instrucción putfield (el valor constante 0 de la parte superior de la pila y la referencia a éste una posición inferior, junto con el valor del campo) no se ve alterada por ningún otro subproceso. por tanto, al producirse la asignación, sabemos que el valor 0 se almacena en el valor del campo. la operación es atómica. todos los operandos procesan información local del método, de modo que no hay interferencias entre subprocesos. si estas instrucciones se ejecutan en diez subprocesos, hay 4.38679733629e+24 ordenaciones posibles. sin embargo, sólo hay un resultado posible, de modo que las distintas ordenaciones son irrelevantes. y además, se garantiza el mismo resultado para valores long en este caso. ¿por qué? los diez subprocesos asignan un valor constante. aunque se entremezclen, el resultado final será el mismo. habrá problemas con la operación ++ en el método getnextid . imagine que lastid contiene 42 al inicio de este método. veamos el código de bytes de este nuevo método: nemónico descripción pila de operandos posterior aload 0 cargar this en la pila de operandos. this dup copiar la parte superior de la pila. ahora tenemos dos copias de this en la pila de operandos. this, this getfield lastid recuperar el valor del campo lastid del objeto al que se apunta en la parte superior de la pila ( this ) y volver a almacenar el valor en la pila. this, 42 iconst_1 desplazar la constante entera 1 en la pila. this, 42, 1 iadd suma entera de los dos valores superiores de la pila de operandos y volver a almacenar el resultado en la pila. this, 43 dup_x1 duplicar el valor 43 y añadirlo delante de this . 43, this, 43 putfield almacenar el valor superior de la pila de operandos, 43 409value 43, en el valor de campo del objeto actual, representado por el siguiente valor superior de la pila de operandos, this . ireturn devolver el valor superior (y único) de la pila de operandos. <vacío> imagine que el primer subproceso completa las tres primeras instrucciones, hasta getfield incluida y después se interrumpe. aparece un segundo subproceso y ejecuta el método completo, incrementando lastid en uno; devuelve 43. tras ello, el primer subproceso retoma desde donde se detuvo; 42 sigue en la pila de operandos por ser el valor de lastid cuando ejecutó getfield . suma uno para obtener 43 y almacena el resultado. el valor 43 también se devuelve al primer subproceso. como resultado, uno de los incrementos se pierde ya que el primer subproceso interfiere con el segundo después de que éste haya interrumpido al primero. al convertir el método getnextid() en synchronized se corrige este problema. conclusión no se necesita un conocimiento extenso del código de bytes para entender cómo unos subprocesos interrumpen a otros. si consigue entender este ejemplo, demostrará la posibilidad de varios subprocesos entrelazados, un conocimiento suficiente. dicho esto, lo que este sencillo ejemplo revela es la necesidad de entender el modelo de memoria para saber qué se permite y qué no. equivocadamente se piensa que el operador ++ (pre o postincremento) es atómico, y evidentemente no lo es. esto significa que tiene que saber: dónde están los objetos y valores compartidos. el código que provoca problemas de lectura/actualización concurrente. cómo evitar que se produzcan dichos problemas. 410conocer su biblioteca la estructura executor como mostramos en executorclientscheduler.java , la estructura executor de java 5 permite la ejecución sofisticada por medio de agrupaciones de subprocesos. es una clase del paquete java.util.concurrent . si va a crear subprocesos y no usa una agrupación de subprocesos o utiliza una creada a mano, considere el uso de executor. hace que el código sea más limpio, más fácil de entender y de menor tamaño. la estructura executor agrupa subprocesos, los cambia automáticamente de tamaño y los vuelve a crear si es necesario. también admite futuros , una construcción de programación concurrente habitual. la estructura executor funciona con clases que implementan runnable y también con clases que implementan la interfaz callable . callable se parece a runnable , pero puede devolver un resultado, una necesidad habitual en soluciones de múltiples subprocesos. un futuro resulta muy útil cuando el código tiene que ejecutar varias operaciones independientes y esperar a que terminen: public string processrequest(string message) throws exception { callable<string> makeexternalcall = new callable<string>() { public string call() throws exception { string result = “”; // realizar solicitud externa return result; } }; future<string> result = executorservice.submit(makeexternalcall); string partialresult = dosomelocalprocessing(); return result.get() + partialresult; } en este ejemplo, el método comienza a ejecutar el objeto makeexternalcall , prosigue con otro procesamiento y la última línea invoca result.get(), que se bloquea hasta que el futuro termina. 411soluciones no bloqueantes la mv java 5 aprovecha el diseño de los procesadores modernos que admiten actualizaciones fiables y no bloqueantes. imagine una clase que usa sincronización (y por tanto bloqueo) para proporcionar la actualización compatible con subprocesos de un valor: public class objectwithvalue { private int value; public void synchronized incrementvalue() { ++value; } public int getvalue() { return value; } } java 5 dispone de varias clases nuevas para este tipo de situaciones, como por ejemplo atomicboolean , atomicinteger y atomicreference . podemos modificar el código anterior para usar un enfoque no bloqueante: public class objectwithvalue { private atomicinteger value = new atomicinteger(0); public void incrementvalue() { value.incrementandget(); } public int getvalue() { return value.get(); } } aunque use un objeto en lugar de una primitiva y envíe mensajes como incrementandget() en lugar de ++ , el rendimiento de esta clase supera en la mayoría de los casos al de la versión anterior. en algunos casos será ligeramente más rápido pero los casos en los que es más lento son prácticamente inexistentes. ¿cómo es posible? los procesadores modernos disponen de una operación denominada cas (compare and swap, comparar e intercambiar). es una operación similar al bloqueo optimista de una base de datos, mientras que la versión sincronizada es similar al bloqueo pesimista. la palabra clave synchronized siempre adquiere un bloqueo, incluso cuando un segundo subproceso no intenta actualizar el mismo valor. aunque el rendimiento de los bloqueos intrínsecos ha mejorado con respecto a versiones anteriores, sigue siendo muy costoso. la versión no bloqueante asume inicialmente que varios subprocesos no 412modifican el mismo valor con la suficiente periodicidad como para generar un problema. por el contrario, detecta de forma eficaz si se produce dicha situación y la reintenta hasta que la actualización es satisfactoria. esta detección suele ser menos costosa que la adquisición de un bloqueo, incluso en situaciones de contención moderada o alta. ¿cómo lo hace la mv? la operación cas es atómica. por tanto, la operación cas tiene este aspecto: int variablebeingset; void simulatenonblockingset (int newvalue) { int currentvalue; do { currentvalue = variablebeingset } while(currentvalue != compareandswap(currentvalue, newvalue)); } int synchronized compareandswap(int currentvalue, int newvalue) { if(variablebeingset == currentvalue) { variablebeingset = newvalue; return currentvalue; } return variablebeingset; } cuando un método intenta actualizar una variable compartida, la operación cas comprueba que la variable establecida sigue teniendo el último valor conocido. en caso afirmativo, se cambia la variable. en caso contrario, la variable no se establece ya que otro subproceso ha conseguido acceder. el método que realiza el intento (mediante la operación cas) ve que el cambio no se ha realizado y lo intenta de nuevo. clases incompatibles con subprocesos existen clases que no son compatibles con subprocesos, como las siguientes: simpledateformat . conexiones de base de datos. contenedores de java.util . 413servlet. algunas clases de colección tienen métodos concretos compatibles con subprocesos. sin embargo, cualquier operación que invoque más de un método no lo es. por ejemplo, si no quiere reemplazar algo en hashtable porque ya existe, podría crear el siguiente código: if(!hashtable.containskey(somekey)) { hashtable.put(somekey, new somevalue()); } cada uno de los métodos es compatible con subprocesos. sin embargo, otro subproceso podría añadir un valor entre las invocaciones de containskey y put . existen varias formas de solucionar este problema: bloquear primero hashtable y comprobar que los demás usuarios de hashtable hagan lo mismo; bloqueo basado en clientes: synchronized(map) { if(!map.containskey(key)) map.put(key,value); } envolver hashtable en su propio objeto y usar dos api distintas; bloqueo basado en servidores con un adaptador: public class wrappedhashtable<k, v> { private map<k, v> map = new hashtable<k, v>(); public synchronized void putifabsent(k key, v value) { if (map.containskey(key)) map.put(key, value); } } usar colecciones compatibles con subprocesos: concurrenthashmap<integer, string> map = new concurrenthashmap<integer, string>(); map.putifabsent(key, value); las colecciones de java.util.concurrent incluyen operaciones como putifabsent() para acomodar este tipo de operaciones. 414las dependencias entre métodos pueden afectar al código concurrente el siguiente ejemplo es una forma de añadir dependencias entre métodos: public class integeriterator implements iterator<integer> private integer nextvalue = 0; public synchronized boolean hasnext() { return nextvalue < 100000; } public synchronized integer next() { if (nextvalue == 100000) throw new iteratorpastendexception(); return nextvalue++; } public synchronized integer getnextvalue() { return nextvalue; } } veamos otro código que usa integeriterator : integeriterator iterator = new integeriterator(); while(iterator.hasnext()) { int nextvalue = iterator.next(); // hacer algo con nextvalue } si un subproceso ejecuta este código no habrá problemas. ¿qué sucede si dos subprocesos intentan compartir una misma instancia de integeriterator para procesar el valor que reciba cada uno pero cada elemento de la lista sólo se procesa una vez? en la mayoría de los casos, no hay consecuencias negativas; los subprocesos comparten la lista, procesan los elementos devueltos por el iterador y se detienen cuando éste termina. sin embargo, existe la posibilidad de que al final de la iteración los dos subprocesos interfieran entre ellos y provoquen que uno supere el final del iterador y se genere una excepción. el problema es el siguiente: el subproceso 1 pregunta hasnext() , que devuelve true . el subproceso 1 se evita y el subproceso 2 realiza la misma pregunta, que sigue siendo true . tras ello, el subproceso 2 invoca next() , que devuelve un valor, como era de esperar, pero como efecto secundario 415hace que hasnext() devuelva false . se vuelve a iniciar el subproceso 1, pensando que hasnext() sigue siendo true , y después invoca next() . aunque los métodos concretos están sincronizados, el cliente usa dos métodos. es un problema real y un ejemplo que puede surgir en código concurrente. en este caso concreto, el problema es especialmente sutil ya que la única ocasión en la que produce un fallo es durante la iteración final del iterador. si los subprocesos se dividen de forma correcta, puede que uno supere el final del iterador. es el tipo de error que surge en un sistema que lleva tiempo en producción, y es difícil de detectar. tiene tres opciones: tolerar el fallo. solucionar el problema cambiando el cliente: bloqueo basado en el cliente. solucionar el problema cambiando el servidor, lo que también provoca que cambie el cliente: bloqueo basado en el servidor. tolerar el fallo en ocasiones, los sistemas se configuran para que un fallo no produzca daños. por ejemplo, el cliente anterior podía capturar la excepción y limpiarla, aunque sería un tanto torpe. es como limpiar fugas de memoria reiniciando a medianoche. bloqueo basado en el cliente para que integeriterator funcione correctamente con varios subprocesos, cambie el cliente (y los demás) como se indica a continuación: integeriterator iterator = new integeriterator(); while (true) { int nextvalue; synchronized (iterator) { if (!iterator.hasnext()) break; nextvalue = iterator.next(); 416} dosometingwith(nextvalue); } cada cliente añade un bloqueo a través de la palabra clave synchronized . esta duplicación incumple el principio dry, pero puede ser necesaria si el código usa agrupaciones de terceros no compatibles con subprocesos. la estrategia es arriesgada ya que todos los programadores que usen el servidor deben acordarse de bloquearlo antes de usarlo y de desbloquearlo cuando terminen. hace muchos años, trabajé en un sistema que usaba el bloqueo basado en el cliente en un recurso compartido. el recurso se usaba en cientos de puntos distintos del código. un pobre programador se olvidó de bloquear el recurso en uno de esos puntos. era un sistema de varios terminales con software de contabilidad para el sindicato de transportistas. local 705. el ordenador se encontraba en una sala de temperatura controlada de un piso elevado, a unas 50 millas al norte de la sede de local 705. en la sede, decenas de trabajadores introducían datos en las terminales, conectadas al ordenador mediante líneas telefónicas dedicadas y módem semidúplex de 600bps (esto fue hace mucho , mucho tiempo). una vez al día, una de las terminales se bloqueaba, sin razón aparente. el bloqueo no tenía preferencia alguna por una terminal o una hora concreta. es como si alguien echara a suertes la terminal que bloquear y la hora del bloqueo. en ocasiones, se bloqueaba más de una terminal. en ocasiones, podían pasar varios días sin bloqueos. inicialmente, se optó por reiniciar como solución, pero era complicado coordinar los reinicios. tenemos que avisar a la sede y esperar a que todos terminaran lo que estuvieran haciendo en todas las terminales. tras ello, se apagaba el sistema y se reiniciaba. si alguien estaba haciendo algo importante para lo que necesitaba una o dos horas, la terminal bloqueada tenía que seguir bloqueada. tras varias semanas de depuración, descubrimos que la causa era un contador de búfer circular desincronizado con su puntero. este búfer controlaba la salida a la terminal. el valor del puntero indicaba que el búfer estaba vacío pero el contador mostraba que estaba lleno. como estaba vacío, no había nada que mostrar; pero como también estaba lleno, no se podía añadir nada al búfer que mostrar en la pantalla. 417sabíamos qué era lo que bloqueaba las terminales pero no qué provocaba la desincronización del búfer circular, por lo que añadimos un truco para resolver el problema. se podían leer los conmutadores del panel frontal en el ordenador (esto fue hace mucho, mucho, mucho tiempo). diseñamos una función de trampa que detectaba si uno de los conmutadores se había generado y después buscábamos un búfer circular que estuviera tanto lleno como vacío. si lo encontrábamos, lo variábamos. ¡ voilá ! la terminal bloqueada volvía a funcionar. de este modo no era necesario reiniciar el sistema si una terminal se bloqueaba. la sede nos llamaba y nos decía que había un bloqueo, nos acercábamos hasta la sala de ordenadores y pulsábamos un conmutador. en ocasiones ellos trabajan los fines de semana pero nosotros no. por ello, añadimos una función al programador que comprobaba los búfer circulares una vez por minuto y restablecía los que estuvieran tanto llenos como vacíos. de este modo se descongestionaban las pantallas antes de que la dirección llegara al teléfono. necesitamos varias semanas de análisis de código de lenguaje de ensamblado antes de localizar al culpable. habíamos calculado que la frecuencia de los bloqueos se debía a un uso desprotegido del búfer circular, así que sólo era necesario determinar el uso fallido. desafortunadamente, esto fue hace mucho tiempo y no disponíamos de herramientas de búsqueda, referencias cruzadas ni de otras técnicas automáticas de ayuda. teníamos que escudriñar los listados. en aquel frío invierno de 1971 en chicago aprendí que los bloqueos basados en el cliente son verdaderamente terribles. bloqueo basado en el servidor la duplicación se puede eliminar si modificamos integeriterator de esta forma: public class integeriteratorserverlocked { private integer nextvalue = 0; public synchronized integer getnextornull() { if (nextvalue < 100000) return nextvalue++; else return null; 418} } y también cambia el código cliente: while (true) { integer nextvalue = iterator.getnextornull(); if (next == null) break; // hacer algo con nextvalue } en este caso, en realidad cambiamos la api de la clase para que sea compatible con el subproceso [120] . el cliente debe realizar una comprobación de null en lugar de comprobar hasnext() . por lo general, el bloqueo basado en el servidor es preferible por estos motivos: reduce el código repetido: el bloqueo basado en el servidor hace que el cliente bloquee correctamente el servidor. al incluir el código de bloqueo en el servidor, se libera a los clientes para usar el objeto y no tener que preocuparse de crear código de bloqueo adicional. permite un mejor rendimiento: puede intercambiar un servidor compatible con subprocesos por otro incompatible en caso de desarrollo de un solo subproceso, lo que evita la sobrecarga. reduce las posibilidades de error: sólo se necesita un programador que se olvide del bloqueo. aplica una única política: la política se aplica solamente al servidor, no a todos los clientes. reduce el ámbito de las variables compartidas: el cliente las desconoce y tampoco sabe cómo se bloquean. todo se oculta en el servidor. cuando se produce un fallo, su origen se busca en menos puntos. ¿y si no es el propietario del código de servidor? usar un adaptador para cambiar la api y añadir bloqueo public class threadsafeintegeriterator { private integeriterator iterator = new integeriterator(); public synchronized integer getnextornull() { 419if(iterator.hasnext()) return iterator.next(); return null; } } mejor todavía, usar colecciones compatibles con subprocesos con interfaces ampliadas. aumentar la producción imagine que desea leer el contenido de una serie de páginas de una lista de url en la red. al leer cada página, la analizamos para acumular estadísticas. después de leer todas, imprimimos un informe de resumen. la siguiente clase devuelve el contenido de una página, dada una url. public class pagereader { //… public string getpagefor(string url) { httpmethod method = new getmethod(url); try { httpclient.executemethod(method); string response = method.getresponsebodyasstring(); return response; } catch (exception e) { handle(e); } finally { method.releaseconnection(); } } } la siguiente clase es el iterador que proporciona el contenido de las páginas en función de un iterador de url: public class pageiterator { private pagereader reader; private urliterator urls; public pageiterator(pagereader reader, urliterator urls) { this.urls = urls; this.reader = reader; } public synchronized string getnextpageornull() { if (urls.hasnext()) getpagefor(urls.next()); 420else return null; } public string getpagefor(string url) { return reader.getpagefor(ur1); } } se puede compartir una instancia de pageiterator entre varios subprocesos distintos, cada uno con su propia instancia de pagereader para leer las páginas que obtiene del iterador. hemos reducido el tamaño del bloque synchronized . simplemente contiene la sección crítica de pageiterator . siempre conviene sincronizar lo menos posible. cálculo de producción de un solo subproceso vayamos con los cálculos. imagine lo siguiente, de acuerdo al argumento anterior: tiempo de e/s para recuperar una página (de media): 1 segundo. tiempo de procesamiento para analizar la página (de media): .5 segundos. e/s requiere 0 por 100 de la cpu mientras que el procesamiento requiere 100 por 100. si se procesan n páginas en un mismo subproceso, el tiempo de ejecución total es de 1.5 segundos * n . en la figura a.1 puede ver una instantánea de 13 páginas, aproximadamente 19.5 segundos. figura a.1. un único subproceso 421cálculo de producción con varios subprocesos si se pueden recuperar páginas en cualquier orden y procesarlas de forma independiente, entonces es posible usar varios subprocesos para aumentar la producción. ¿qué sucede si usamos tres subprocesos? ¿cuántas páginas podemos obtener en el mismo tiempo? como se aprecia en la figura a.2, la solución con varios procesos permite que el análisis de las páginas vinculado al proceso se solape con la lectura de las mismas, vinculada a e/s. en un mundo ideal, significaría que el procesador se utiliza totalmente. cada lectura de página por segundo se solapa con dos análisis. por tanto, podemos procesar dos páginas por segundo, lo que triplica la producción de la solución con un solo proceso. figura a.2. tres subprocesos concurrentes. bloqueo mutuo imagine una aplicación web con dos agrupaciones de recursos compartidos de tamaño finito: una agrupación de conexiones de base de datos para tareas locales de almacenamiento de procesos. 422una agrupación de conexiones mq a un repositorio principal. imagine que hay dos operaciones en la aplicación: crear y actualizar: crear: adquirir una conexión al repositorio principal y la base de datos. comunicarse con el repositorio principal y después almacenar el trabajo local en la base de datos de procesos. actualizar: adquirir una conexión a la base de datos y después al repositorio principal. leer el trabajo de la base de datos y enviarlo al repositorio principal. ¿qué sucede con los usuarios que superan el tamaño de la agrupación? imagine que el tamaño de cada agrupación es 10 . 10 usuarios intentan usar crear, de modo que se adquieren diez conexiones de base de datos y cada subproceso se interrumpe después de esta adquisición pero antes de adquirir una conexión al repositorio principal. 10 usuarios intentan usar actualizar, de modo que se adquieren las diez conexiones al repositorio principal y cada subproceso se interrumpe después de adquirir el repositorio principal pero antes de adquirir una conexión a la base de datos. ahora los 10 subprocesos crear deben esperar a adquirir una conexión al repositorio principal pero los 10 subprocesos actualizar deben esperar a adquirir una conexión a la base de datos. bloqueo mutuo. el sistema no se recupera nunca. puede parecerle una situación improbable pero ¿quién desea un sistema que se colapsa cada semana? ¿quién quiere depurar un sistema con síntomas tan difíciles de reproducir? es el tipo de problema que tarda semanas en resolverse. una solución habitual consiste en añadir instrucciones de depuración para determinar qué sucede. evidentemente, estas instrucciones cambian tanto el código que el bloqueo mutuo se genera en otras situaciones y tarda meses en 423volver a producirse [121] . para solucionar realmente el problema del bloqueo absoluto, debemos entender sus causas. para que se produzca, deben darse cuatro condiciones: exclusión mutua. bloqueo y espera. no expropiación. espera circular. exclusión mutua la exclusión mutua se produce cuando varios subprocesos deben usar los mismos recursos y dichos recursos no se pueden usar en varios subprocesos al mismo tiempo. son de número limitado. un ejemplo típico de este tipo de recurso es una conexión de base de datos, un archivo abierto para escritura, un bloqueo de registro o un semáforo. bloqueo y espera cuando un subproceso adquiere un recurso, no lo libera hasta adquirir los demás recursos que necesita y terminar su trabajo. no expropiación un subproceso no puede adueñarse de los recursos de otro. cuando un subproceso obtiene un recurso, la única forma de que otro lo consiga es que el primero lo libere. espera circular 424también se denomina abrazo mortal. imagine dos subprocesos, t1 y t2, y dos recursos, r1 y r2. t1 tiene r1, t2 tiene r2. t1 también necesita r2 y t2 también necesita r1. es similar al diagrama de la figura a.3: figura a.3. estas cuatro condiciones deben cumplirse para que se produzca un bloqueo mutuo. si se incumple alguna de ellas, no se producirá. evitar la exclusión mutua una estrategia para evitar el bloqueo mutuo es impedir la condición de exclusión mutua, por medio de lo siguiente: usar recursos que permitan un uso simultáneo, como por ejemplo, atomicinteger . incrementar el número de recursos para que sea igual o mayor que el número de subprocesos implicados. comprobar que todos los recursos están libres antes de adquirir ninguno. desafortunadamente, la mayoría de recursos son limitados y no permiten un uso simultáneo, y es habitual que la identidad del segundo recurso se base en los resultados de operar sobre el primero, pero no se desanime, todavía 425quedan tres condiciones. evitar bloqueo y espera también puede eliminar el bloqueo mutuo si rechaza la espera. compruebe cada uno de los recursos antes de obtenerlos y libere todos los recursos y comience de nuevo si detecta uno que esté ocupado. este enfoque genera algunos problemas: inanición: un subproceso no consigue adquirir los recursos que necesita (puede que tenga una combinación exclusiva de recursos que casi nunca esté disponible). bloqueo activo: varios subprocesos pueden actuar al unísono, adquirir un recurso y liberarlo, de forma repetida. es especialmente probable en algoritmos de programación de cpu simples (como dispositivos incrustados o algoritmos de equilibrio de subprocesos escritos a mano). en ambos casos, se puede reducir la producción. el primero reduce la utilización de la cpu, mientras que el segundo genera una elevada utilización de la cpu sin sentido. aunque esta estrategia parezca ineficaz, es mejor que nada. como ventaja, siempre se puede implementar si todo lo demás falla. evitar la expropiación otra estrategia para evitar el bloqueo mutuo consiste en permitir que todos los subprocesos se apropien de los recursos de otros. suele realizarse a través de un sencillo mecanismo de solicitudes. cuando un subproceso descubre que hay un recurso ocupado, le solicita al propietario que lo libere. si el propietario también espera a otro recurso, lo libera y comienza de nuevo. es similar al enfoque anterior, pero, como ventaja, un subproceso puede esperar a un recurso, lo que reduce el número de reinicios. sin embargo, la gestión de todas estas solicitudes puede resultar complicada. 426evitar la espera circular es el enfoque más habitual para impedir el bloqueo mutuo. en la mayoría de sistemas, basta con una sencilla convención acordada entre ambas partes. en el ejemplo anterior del subproceso 1 que quiere tanto el recurso 1 como el 2, y el subproceso 2 que desea tanto el recurso 2 como el 1, al forzar a ambos subprocesos a que asignen los recursos en el mismo orden se imposibilita la espera circular. en general, si todos los subprocesos pueden acordar un orden global de los recursos y si todos asignan los recursos en ese orden, el bloqueo mutuo es imposible. pero como todas las estrategias, también se pueden producir problemas: el orden de adquisición puede no corresponderse al orden de uso; por tanto, un recurso adquirido al inicio puede que no se use hasta el final. esto puede bloquear recursos más tiempo de lo estrictamente necesario. en ocasiones no se puede imponer un orden de adquisición de recursos. si el id del segundo recurso proviene de una operación realizada en el primero, ese orden no es factible. por tanto, existen varias formas de evitar el bloqueo mutuo. algunas provocan inanición, mientras que otras usan la cpu en exceso y reducen la capacidad de respuesta. ¡ tanstaafl ! [122] el aislamiento de la parte relacionada con subprocesos de su solución para permitir ajustes y experimentación es una forma de aprender a determinar las estrategias óptimas. probar código con múltiples subprocesos ¿cómo se puede crear una prueba que demuestre que el siguiente código no es correcto? 01: public class classwiththreadingproblem { 02: int nextid; 03: 42704: public int takenextid() { 05: return nextid++; 06: } 07: } veamos la descripción de una prueba que lo demuestre: recordar el valor actual de nextid . crear dos subprocesos y que cada uno invoque takenextid() una vez. comprobar que el valor de nextid es dos más que el inicial. ejecutar hasta demostrar que nextid sólo se ha incrementado en uno y no en dos. en el listado a-2 se reproduce la prueba: listado a-2 classwiththreadingproblemtest.java. 01: package example; 02: 03: import static org.junit.assert.fail; 04: 05: import org.junit.test; 06: 07: public class classwiththreadingproblemtest { 08: @test 09: public void twothreadsshouldfaileventually() throws exception { 10: final classwiththreadingproblem classwiththreadingproblem = new classwiththreadingproblem(); 11: 12: runnable runnable = new runnable() { 13: public void run() { 14: classwiththreadingproblem.takenextid(); 15: } 16: }; 17: 18: for (int i = 0; i < 50000; ++i) { 19: int startingid = classwiththreadingproblem.lastid; 20: int expectedresult = 2 + startingid; 21: 22: thread t1 = new thread(runnable); 42823: thread t2 = new thread(runnable); 24: t1.start(); 25: t2.start(); 26: t1.join(); 27: t2.join(); 28: 29: int endingid = classwiththreadingproblem.lastid; 30: 31: if (endingid != expectedresult) 32: return; 33: } 34: 35: fail(“should have exposed a threading issue but it did not.”); 36: } 37: } línea descripción 10 crear una sola instancia de classwiththreadingproblem . debemos usar la palabra clave final ya que se usa después en una clase interna anónima. 12-16 crear una clase interna anónima que use la instancia de classwiththreadingproblem . 18 ejecutar este código hasta demostrar que falla, pero no tanto como para que la prueba tarde demasiado. es un acto de equilibrio; no queremos esperar demasiado para demostrar el fallo. elegir la cantidad de ejecuciones es complicado, aunque como veremos después, esta cifra se puede reducir considerablemente. 19 recordar el valor inicial, la prueba intenta demostrar que el código de classwiththreadingproblem es incorrecto. si se supera la prueba, lo habrá demostrado. si la prueba falla, habrá sido incapaz de demostrarlo. 20 esperamos que el valor final sea dos más que el actual. 22-23 crear dos subprocesos que usen el objeto creado en las líneas 12-16. de este modo contamos con dos posibles subprocesos que intentan usar nuestra instancia de classwiththreadingproblem y ambos interfieren entre sí. 24-25 hacer que los dos subprocesos se puedan ejecutar. 42926-27 esperar a que terminen los dos subprocesos antes de comprobar los resultados. 29 registrar el valor final. 31-32 ¿es diferente endingid a lo que esperábamos? en caso afirmativo, se finaliza la prueba; hemos demostrado que el código es incorrecto. en caso negativo, volver a intentarlo. 35 si hemos llegado hasta aquí, la prueba no ha podido demostrar que el código de producción era incorrecto en una cantidad de tiempo razonable; el código ha fallado. o no es incorrecto o no hemos realizado suficientes iteraciones para que se produzca la condición de fallo. esta prueba establece las condiciones de un problema de actualización concurrente. sin embargo, el problema es tan infrecuente que la mayoría de las veces la prueba no lo detecta. en realidad, para detectar el problema debemos establecer el número de iteraciones en más de un millón. incluso con esa cantidad, en diez ejecuciones de un bucle de 1 000 000, el problema sólo apareció una vez, lo que significa que debemos aumentar las iteraciones para obtener fallos fiables. ¿cuánto estamos dispuestos a esperar? aunque ajustáramos la prueba para obtener fallos fiables en un equipo, seguramente tendríamos que ajustarla con otros valores para ilustrar el fallo en otro equipo, sistema operativo o versión de la mvj. y es un problema sencillo . si no podemos demostrarlo, ¿qué pasará cuando detectemos problemas realmente complejos? ¿qué enfoques debemos adoptar para demostrar este sencillo fallo? y, sobre todo, ¿cómo podemos crear pruebas que demuestren fallos en un código más complejo? ¿cómo podremos saber si el código tiene fallos cuando ni siquiera sabemos dónde buscar? veamos algunas sugerencias: pruebas monte carlo: crear pruebas flexibles que se puedan ajustar. después, ejecutarlas repetidamente, por ejemplo, en un servidor de prueba, y cambiar los valores de ajuste aleatoriamente. si las pruebas 430fallan, el código es incorrecto. diseñe las pruebas en las fases iniciales para que un servidor de integración continua las ejecute lo antes posible. registre las condiciones de fallo de las pruebas. ejecutar la prueba en todas las plataformas de desarrollo: de forma repetida y continuada. cuanto más tiempo se ejecuten las pruebas sin fallos, más probable es que el código de producción sea correcto o las pruebas no sean adecuadas para revelar los problemas. ejecutar las pruebas en un equipo con distintas cargas: si puede simular cargas similares a las del entorno de producción, hágalo. sin embargo, aunque realice todos estos pasos, no es probable que detecte problemas de subprocesos en el código. los problemas más complicados son los que sólo se producen una vez cada mil millones de oportunidades. son el azote de los sistemas complejos. herramientas para probar código basado en subprocesos ibm ha creado la herramienta contest [123] . lo que hace es instrumentar las clases para aumentar las probabilidades de que falle el código sin subprocesos. no tenemos relación directa con ibm ni con el equipo que ha desarrollado contest. un colega nos la descubrió. tras varios minutos de usarla, notamos una gran mejoría en la detección de errores. a continuación, le indicamos cómo usar contest: crear pruebas y código de producción, asegurándonos que haya pruebas diseñadas específicamente para simular varios usuarios con diferentes cargas, como mencionamos antes. instrumentar el código de pruebas y producción con contest. ejecutar las pruebas. 431al instrumentar el código con contest, la tasa de éxito pasó de un fallo por cada millón de iteraciones a un fallo en 30 iteraciones. los valores de bucle de las distintas ejecuciones de la prueba tras la instrumentación son los siguientes: 13, 23, 0, 54, 16, 14, 6, 69, 107, 49, 2. evidentemente, las clases instrumentadas fallaban antes y con mayor fiabilidad. conclusión en este capítulo hemos realizado un breve recorrido por el vasto y complejo territorio de la programación concurrente. apenas hemos mostrado la superficie. nos hemos centrado en disciplinas para mantener la limpieza del código concurrente, pero hay mucho más que aprender si tiene pensado diseñar sistemas concurrentes. le recomendamos que empiece por el libro de doug lea concurrent programming in java: design principles and patterns [124] . en este capítulo hemos presentado la actualización concurrente y las disciplinas de sincronización y bloqueo para evitarla. hemos visto cómo los subprocesos pueden mejorar la producción de un sistema vinculado a e/s y las técnicas limpias para lograr dichas mejoras. hemos descrito el bloqueo mutuo y las disciplinas para evitarlo de forma limpia. por último, hemos analizado estrategias para mostrar problemas de concurrencia mediante la instrumentación del código. ejemplos de código completos cliente/servidor sin subprocesos listado a-3 server.java package com.objectmentor.clientserver.nonthreaded; 432import java.io.ioexception; import java.net.serversocket; import java.net.socket; import java.net.socketexception; import common.messageutils; public class server implements runnable { serversocket serversocket; volatile boolean keepprocessing = true; public server(int port, int millisecondstimeout) throws ioexception { serversocket = new serversocket(port); serversocket.setsotimeout(millisecondstimeout); } public void run() { system.out.printf(“server starting\n”); while (keepprocessing) { try { system.out.printf(“accepting client\n”); socket socket = serversocket.accept(); system.out.printf(“got client\n”); process(socket); } catch (exception e) { handle(e); } } } private void handle(exception e) { if (!(e instanceof socketexception)) { e.printstacktrace(); } } public void stopprocessing() { keepprocessing = false; closeignoringexception(serversocket); } void process(socket socket) { if (socket == null) return; try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); 433closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } private void closeignoringexception(socket socket) { if (socket != null) try { socket.close(); } catch (ioexception ignore) { } } private void closeignoringexception(serversocket serversocket) { if (serversocket != null) try { serversocket.close(); } catch (ioexception ignore) { } } } listado a-4 clienttest.java. package com.objectmentor.clientserver.nonthreaded; import java.io.ioexception; import java.net.serversocket; import java.net.socket; import java.net.socketexception; import common.messageutils; public class server implements runnable { serversocket serversocket; volatile boolean keepprocessing = true; public server(int port, int millisecondstimeout) throws ioexception { serversocket = new serversocket(port); serversocket.setsotimeout(millisecondstimeout); } public void run() { system.out.printf(“server starting\n”); while (keepprocessing) { try { system.out.printf(“accepting client\n”); socket socket = serversocket.accept(); system.out.printf(“got client\n”); process(socket); } catch (exception e) { 434handle(e); } } } private void handle(exception e) { if (!(e instanceof socketexception)) { e.printstacktrace(); } } public void stopprocessing() { keepprocessing = false; closeignoringexception(serversocket); } void process(socket socket) { if (socket == null) return; try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } private void closeignoringexception(socket socket) { if (socket != null) try { socket.close(); } catch (ioexception ignore) { } } private void closeignoringexception(serversocket serversocket) { if (serversocket != null) try { serversocket.close(); } catch (ioexception ignore) { } } } listado a-5 435messageutils.java. package common; import java.io.ioexception; import java.io.inputstream; import java.io.objectinputstream; import java.io.objectoutputstream; import java.io.outputstream; import java.net.socket; public class messageutils { public static void sendmessage(socket socket, string message) throws ioexception { outputstream stream = socket.getoutputstream(); objectoutputstream oos = new objectoutputstream(stream); oos.writeutf(message); oos.flush(); } public static string getmessage(socket socket) throws ioexception { inputstream stream = socket.getinputstream(); objectinputstream ois = new objectinputstream(stream); return ois.readutf(); } } cliente/servidor con subprocesos para cambiar el servidor para que use subprocesos basta con cambiar el mensaje process (las nuevas líneas se muestran en negrita para destacarlas): void process(final socket socket) { if (socket == null) return; runnable clienthandler = new runnable() { public void run() { try { system.out.printf(“server: getting message\n”); string message = messageutils.getmessage(socket); system.out.printf(“server: got message: %s\n”, message); thread.sleep(1000); system.out.printf(“server: sending reply: %s\n”, message); messageutils.sendmessage(socket, “processed: ” + message); system.out.printf(“server: sent\n”); closeignoringexception(socket); } catch (exception e) { e.printstacktrace(); } } 436}; thread clientconnection = new thread(clienthandler); clientconnection.start(); } 437apéndice b org.jfree.date.serialdate listado b-1 serialdate.java 1 /*============================================================== 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 *============================================================== 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia 17 * pública general gnu si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110- 1301, 22 * ee.uu. 23 * 43824 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ------------------ 28 * serialdate.java 29 * ------------------ 30 * (c) copyright 2001-2005, de object refinery limited. 31 * 32 * autor original: david gilbert (para object refinery limited); 33 * colaborador(es): -; 34 * 35 * $id: serialdate.java,v 1.7 2005/11/03 09:25:17 mungady exp $ 36 * 37 * cambios (11-oct-2001) 38 * -------------------------------------- 39 * 11-oct-2001: reorganización de la clase y cambio a un nuevo paquete 40 * com.jrefinery.date (dg); 41 * 05-nov-2001: se añade un método getdescription() y se elimina la clase 42 * notabledate (dg); 43 * 12-nov-2001: ibd requiere el método setdescription(), una vez eliminada la clase 44 * notabledate (dg); se cambian getpreviousdayofweek(), 45 * getfollowingdayofweek() y getnearestdayofweek() para corregir 46 * errores (dg); 47 * 05-dic-2001: error corregido en la clase spreadsheetdate (dg); 48 * 29-may-2002: se transfieren las constantes de mes a una interfaz independiente 49 * (monthconstants) (dg); 50 * 27-ago-2002: error corregido en el método addmonths(), gracias a nálevka petr (dg); 51 * 03-oct-2002: errores indicados por checkstyle (dg) corregidos; 52 * 13-mar-2003: implementación de serializable (dg); 53 * 29-may-2003: error corregido en el método addmonths (dg); 54 * 04-sep-2003: implementación de comparable. actualización de los javadoc isinrange (dg); 55 * 05-ene-2005: error corregido en el método addyears() (1096282) (dg); 56 * 57 */ 58 59 package org.jfree.date; 60 61 import java.io.serializable; 62 import java.text.dateformatsymbols; 63 import java.text.simpledateformat; 64 import java.util.calendar; 65 import java.util.gregoriancalendar; 43966 67 /** 68 * clase abstracta que define nuestros requisitos para manipular fechas, 68 * sin limitación a una determinada implementación. 70 * <p> 71 * requisito 1: coincidir al menos con el procesamiento de fechas en excel; 72 * requisito 2: la clase es inmutable; 73 * <p> 74 * ¿por qué no usar java.util.date? lo haremos, cuando tenga sentido. en ocasiones, 75 * java.util.date puede ser demasiado precisa; representa un instante en el tiempo, 76 * con una precisión de 1/1000 de segundo (y la fecha depende de la 77 * zona horaria). en ocasiones sólo querremos representar un día concreto (como el 21 78 * de enero de 2015) sin preocuparnos de la hora del día, la 79 * zona horaria u otros aspectos. para eso hemos definido daydate. 80 * <p> 81 * puede invocar getinstance() para obtener una subclase concreta de serialdate, 82 * sin preocuparse de su implementación exacta 83 * 84 * @author david gilbert 85 */ 86 public abstract class serialdate implements comparable, 87 serializable, 88 monthconstants { 89 90 /** para serialización. */ 91 private static final long serialversionuid = -293716040467423637l; 92 93 /** símbolos de formato de fecha. */ 94 public static final dateformatsymbols 95 date_format_symbols = new simpledateformat().getdateformatsymbols(); 96 97 /** número de serie para el 1 de enero de 1900. */ 98 public static final int serial_lower_bound = 2; 99 100 /** número de serie para el 31 de diciembre de 9999. */ 101 public static final int serial_upper_bound = 2958465; 102 103 /** valor de año más bajo admitido por este formato de fecha. */ 104 public static final int minimum_year_supported = 1900; 105 106 /** valor de año más alto admitido por este formato de fecha. */ 440107 public static final int maximum_year_supported = 9999; 108 109 /** constante útil para lunes; equivale a java.util.calendar.monday. */ 110 public static final int monday = calendar.monday; 111 112 /** 113 * constante útil para martes; equivale a java.util.calendar.tuesday. 114 * / 115 public static final int tuesday = calendar.tuesday; 116 117 /** 118 * constante útil para miércoles; equivale a 119 * java.util.calendar.wednesday. 120 */ 121 public static final int wednesday = calendar.wednesday; 122 123 /** 124 * constante útil para jueves; equivale a java.util.calendar.thursday. 125 */ 126 public static final int thursday = calendar.thursday; 127 128 /** constante útil para viernes; equivale a java.util.calendar.friday. */ 129 public static final int friday = calendar.friday; 130 131 /** 132 * constante útil para sábado; equivale a java.util.calendar.saturday. 133 */ 134 public static final int saturday = calendar.saturday; 135 136 /** constante útil para domingo; equivale a java.util.calendar.sunday. */ 137 public static final int sunday = calendar.sunday; 138 139 /** número de días de cada mes en años no bisiestos. */ 140 static final int[] last_day_of_month = 141 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 142 143 /** número de días en un año (no bisiesto) hasta el final de cada mes. */ 144 static final int[] aggregate_days_to_end_of_month = 145 {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 146 147 /** número de días en un año hasta el final del mes anterior. */ 148 static final int[] aggregate_days_to_end_of_preceding_month = 441149 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 150 151 /** número de días en un año bisiesto hasta el final de cada mes. */ 152 static final int[] leap_year_aggregate_days_to_end_of_month = 153 {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 154 155 /** 156 * número de días en un año bisiesto hasta el final del mes anterior. 157 */ 158 static final int[] 159 leap_year_aggregate_days_to_end_of_preceding_month = 160 {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 161 162 /** una constante útil para hacer referencia a la primera semana del mes. */ 163 public static final int first_week_in_month = 1; 164 165 /** una constante útil para hacer referencia a la segunda semana del mes. */ 166 public static final int second_week_in_month = 2; 167 168 /** una constante útil para hacer referencia a la tercera semana del mes. */ 169 public static final int third_week_in_month = 3; 170 171 /** una constante útil para hacer referencia a la cuarta semana del mes. */ 172 public static final int fourth_week_in_month = 4; 173 174 /** una constante útil para hacer referencia a la última semana del mes. */ 175 public static final int last_week_in_month = 0; 176 177 /** constante de intervalo. */ 178 public static final int include_none = 0; 179 180 /** constante de intervalo. */ 181 public static final int include_first = 1; 182 183 /** constante de intervalo. */ 184 public static final int include_second = 2; 185 186 /** constante de intervalo. */ 187 public static final int include_both = 3; 188 189 /** 442190 * constante útil para especificar un día de la semana con respecto a una fecha 191 * fija. 192 */ 193 public static final int preceding = -1; 194 195 /** 196 * constante útil para especificar un día de la semana con respecto a una fecha 197 * fija. 198 */ 199 public static final int nearest = 0; 200 201 /** 202 * constante útil para especificar un día de la semana con respecto a una fecha 203 * fija. 204 */ 205 public static final int following = 1; 206 207 /** una descripción para la fecha. */ 208 private string description; 209 210 /** 211 * constructor predeterminado. 212 */ 213 protected serialdate() { 214 } 215 216 /** 217 * devuelve <code>true</code> si el código entero proporcionado representa un 218 * día de la semana válido y <code>false</code> en caso contrario. 219 * 220 * @param code el código del que se comprueba la validez. 221 * 222 * @return <code>true</code> si el código entero proporcionado representa un 223 * día de la semana válido y <code>false</code> en caso contrario. 224 */ 225 public static boolean isvalidweekdaycode(final int code) { 227 switch(code) { 228 case sunday: 229 case monday: 230 case tuesday: 231 case wednesday: 443232 case thursday: 233 case friday: 234 case saturday: 235 return true; 236 default: 237 return false; 238 } 239 240 } 241 242 /** 243 * convierte la cadena proporcionada en un día de la semana. 244 * 245 * @param s una cadena que representa el día de la semana. 246 * 247 * @return <code>-1</code> si la cadena no se puede convertir o el día de 248 * la semana en caso contrario. 249 */ 250 public static int stringtoweekdaycode(string s) { 251 252 final string[] shortweekdaynames 253 = date_format_symbols.getshortweekdays(); 254 final string[] weekdaynames = date_format_symbols.getweekdays(); 255 256 int result = -1; 257 s = s.trim(); 258 for (int i = 0; i < weekdaynames.length; i++) { 259 if (s.equals(shortweekdaynames[i])) { 260 result = i; 261 break; 262 } 263 if (s.equals(weekdaynames[i])) { 264 result = i; 265 break; 266 } 267 } 268 return result; 269 270 } 271 272 /** 273 * devuelve una representación en cadena del día de la semana proporcionado. 274 * <p> 275 * necesitamos un enfoque mejor. 444276 * 277 * @param weekday el día de la semana. 278 * 279 * @return una cadena que representa el día de la semana proporcionado. 280 */ 281 public static string weekdaycodetostring(final int weekday) { 282 283 final string[] weekdays = date_format_symbols.getweekdays(); 284 return weekdays[weekday]; 285 286 } 287 288 /** 289 * devuelve una matriz de nombres de mes. 290 * 291 * @return una matriz de nombres de mes. 292 */ 293 public static string[] getmonths() { 294 295 return getmonths(false); 296 297 } 298 299 /** 300 * devuelve una matriz de nombres de mes. 301 * 302 * @param shortened un indicador para indicar que deben devolverse los nombres 303 * de mes en formato reducido. 304 * 305 * @return una matriz de nombres de mes. 306 */ 307 public static string[] getmonths(final boolean shortened) { 308 309 if (shortened) { 310 return date_format_symbols.getshortmonths(); 311 } 312 else { 313 return date_format_symbols.getmonths(); 314 } 315 316 } 317 318 /** 319 * devuelve true si el código entero proporcionado representa un mes 445válido. 320 * 321 * @param code el código del que se comprueba la validez. 322 * 323 * return <code>true</code> si el código entero proporcionado representa un 324 * mes válido. 325 */ 326 public static boolean isvalidmonthcode(final int code) { 327 328 switch(code) { 329 case january: 330 case february: 331 case march: 332 case april: 333 case may: 334 case june: 335 case july: 336 case august: 337 case september: 338 case october: 339 case november: 340 case december: 341 return true; 342 default: 343 return false; 344 } 345 346 } 347 348 /** 349 * devuelve el trimestre del mes especificado. 350 * 351 * @param code el código del mes (1-12). 352 * 353 * @return el trimestre al que pertenece el mes. 354 * @throws java.lang.illegalargumentexception 355 */ 356 public static int monthcodetoquarter(final int code) { 357 358 switch(code) { 359 case january: 360 case february: 361 case march: return 1; 362 case april: 446363 case may: 364 case june: return 2; 365 case july: 366 case august: 367 case september: return 3; 368 case october: 369 case november: 370 case december: return 4; 371 default: throw new illegalargumentexception( 372 “serialdate.monthcodetoquarter: invalid month code.”); 373 } 374 375 } 376 377 /** 378 * devuelve una cadena que representa el mes proporcionado. 379 * <p> 380 * la cadena devuelta es la forma extensa del nombre del mes obtenido de la 381 * configuración regional. 382 * 383 * @param month el mes. 384 * 385 * @return una cadena que representa el mes proporcionado 386 */ 387 public static string monthcodetostring(final int month) { 388 389 return monthcodetostring(month, false); 390 391 } 392 393 /** 394 * devuelve una cadena que representa el mes proporcionado. 395 * <p> 396 * la cadena devuelta es la forma extensa o reducida del nombre del mes 397 * obtenido de la configuración regional. 398 * 399 * @param month el mes. 400 * @param shortened si <code>true</code> devuelve la abreviatura del 401 * mes. 402 * 403 * @return una cadena que representa el mes proporcionado. 404 * @throws java.lang.illegalargumentexception 405 */ 406 public static string monthcodetostring(final int month, 447407 final boolean shortened) { 408 409 // comprobar argumentos… 410 if (!isvalidmonthcode(month)) { 411 throw new illegalargumentexception( 412 “serialdate.monthcodetostring: month outside valid range.”); 413 } 414 415 final string[] months; 416 417 if (shortened) { 418 months = date_format_symbols.getshortmonths(); 419 } 420 else { 421 months = date_format_symbols.getmonths(); 422 } 423 424 return months[month - 1]; 425 426 } 427 428 /** 429 * convierte una cadena en el código del mes. 430 * <p> 431 * este método devuelve una de las constantes january, february, …, 432 * december correspondientes a la cadena. si la cadena no se 433 * reconoce, este método devuelve -1. 434 * 435 * @param s la cadena que analizar. 436 * 437 * @return <code>-1</code> si la cadena no se puede analizar, o el mes del 438 * año en caso contrario. 439 */ 440 public static int stringtomonthcode(string s) { 441 442 final string[] shortmonthnames = date_format_symbols.getshortmonths(); 443 final string[] monthnames = date_format_symbols.getmonths(); 444 445 int result = -1; 446 s = s.trim(); 447 448 // primero intentar analizar la cadena como entero (1-12)… 449 try { 450 result = integer.parseint(s); 448451 } 452 catch (numberformatexception e) { 453 // suprimir 454 } 455 456 // buscar por los nombres de los meses… 457 if ((result < 1) || (result > 12)) { 458 for (int i = 0; i < monthnames.length; i++) { 459 if (s.equals(shortmonthnames[i])) { 460 result = i + 1; 461 break; 462 } 463 if (s.equals(monthnames[i])) { 464 result = i + 1; 465 break; 466 } 467 } 468 } 469 470 return result; 471 472 } 473 474 /** 475 * devuelve true si el código entero proporcionado representa una semana 476 * del mes válida y false en caso contrario 477 * 478 * @param code el código del que se comprueba la validez. 479 * @return <code>true</code> si el código entero proporcionado representa una 480 * semana del mes válida. 481 */ 482 public static boolean isvalidweekinmonthcode(final int code) { 483 484 switch(code) { 485 case first_week_in_month: 486 case second_week_in_month: 487 case third_week_in_month: 488 case fourth_week_in_month: 489 case last_week_in_month: return true; 490 default: return false; 491 } 492 493 } 449494 495 /** 496 * determina si el año especificado es bisiesto o no. 497 * 498 * @param yyyy el año (entre 1900 y 9999). 499 * 500 * @return <code>true</code> si el año especificado es bisiesto. 501 */ 502 public static boolean isleapyear(final int yyyy) { 503 504 if ((yyyy % 4) != 0) { 505 return false; 506 } 507 else if ((yyyy % 400) == 0) { 508 return true; 509 } 510 else if ((yyyy % 100) == 0) { 511 return false; 512 } 513 else { 514 return true; 515 } 516 517 } 518 519 /** 520 * devuelve el número de años bisiestos desde 1900 hasta el año especificado 521 * inclusive. 522 * <p> 523 * 1900 no es un año bisiesto. 524 * 525 * @param yyyy el año (entre 1900 y 9999). 526 * 527 * @return el número de años bisiestos desde 1900 hasta el año especificado. 528 */ 529 public static int leapyearcount(final int yyyy) { 530 531 final int leap4 = (yyyy - 1896) / 4; 532 final int leap100 = (yyyy - 1800) / 100; 533 final int leap400 = (yyyy - 1600) / 400; 534 return leap4 - leap100 + leap400; 535 536 } 537 450538 /** 539 * devuelve el número del último día del mes, teniendo en cuenta los 540 * años bisiestos. 541 * 542 * @param month el mes. 543 * @param yyyy el año (entre 1900 y 9999). 544 * 545 * @return el número del último día del mes. 546 */ 547 public static int lastdayofmonth(final int month, final int yyyy) { 548 549 final int result = last_day_of_month[month]; 550 if (month != february) { 551 return result; 552 } 553 else if (isleapyear(yyyy)) { 554 return result + 1; 555 } 556 else { 557 return result; 558 } 559 560 } 561 562 /** 563 * crea una nueva fecha añadiendo el número especificado de días a la fecha 564 * base. 565 * 566 * @param days el número de días que añadir (puede ser negativo). 567 * @param base la fecha base. 568 * 569 * @return una nueva fecha. 570 */ 571 public static serialdate adddays(final int days, final serialdate base) { 572 573 final int serialdaynumber = base.toserial() + days; 574 return serialdate.createinstance(serialdaynumber); 575 576 } 577 578 /** 579 * crea una nueva fecha añadiendo el número especificado de meses a la fecha 580 * base. 451581 * <p> 582 * si la fecha base es próxima al final del mes, el día del resultado 583 * se puede ajustar ligeramente: 31 mayo + 1 mes = 30 junio. 584 * 585 * @param months el número de meses que añadir (puede ser negativo). 586 * @param base la fecha base. 587 * 588 * @return una nueva fecha. 589 */ 590 public static serialdate addmonths(final int months, 591 final serialdate base) { 592 593 final int yy = (12 * base.getyyyy() + base.getmonth() + months - 1) 594 / 12; 595 final int mm = (12 * base.getyyyy() + base.getmonth() + months – 1) 596 % 12 + 1; 597 final int dd = math.min( 598 base.getdayofmonth(), serialdate.lastdayofmonth(mm, yy) 599 ); 600 return serialdate.createinstance(dd, mm, yy); 601 602 } 603 604 /** 605 * crea una nueva fecha añadiendo el número especificado de años a la fecha 606 * base. 607 * 608 * @param years el número de años que añadir (puede ser negativo). 609 * @param base la fecha base. 610 * 611 * @return una nueva fecha. 612 */ 613 public static serialdate addyears(final int years, final serialdate base) { 614 615 final int basey = base.getyyyy(); 616 final int basem = base.getmonth(); 617 final int based = base.getdayofmonth(); 618 619 final int targety = basey + years; 620 final int targetd = math.min( 621 based, serialdate.lastdayofmonth(basem, targety) 622 ); 623 624 return serialdate.createinstance(targetd, basem, targety); 452625 626 } 627 628 /** 629 * devuelve la última fecha correspondiente al día de la semana especificado y 630 * anterior a la fecha base. 631 * 632 * @param targetweekday un código para el día de la semana de destino. 633 * @param base la fecha base. 634 * 635 * @return la última fecha correspondiente al día de la semana especificado y 636 * anterior a la fecha base. 637 */ 638 public static serialdate getpreviousdayofweek(final int targetweekday, 639 final serialdate base) { 640 641 // comprobar argumentos… 642 if (!serialdate.isvalidweekdaycode(targetweekday)) { 643 throw new illegalargumentexception( 644 “invalid day-of-the-week code.” 645 ); 646 } 647 648 // buscar la fecha… 649 final int adjust; 650 final int basedow = base.getdayofweek(); 651 if (basedow > targetweekday) { 652 adjust = math.min(0, targetweekday - basedow); 653 } 654 else { 655 adjust = -7 + math.max(0, targetweekday - basedow); 656 } 657 658 return serialdate.adddays(adjust, base); 659 660 } 661 662 /** 663 * devuelve la primera fecha que coincide con el día de la semana especificado 664 * y posterior a la fecha base. 665 * 666 * @param targetweekday un código para el día de la semana de destino. 453667 * @param base la fecha base. 668 * 669 * @return la primera fecha que coincide con el día de la semana especificado 670 * y posterior a la fecha base. 671 */ 672 public static serialdate getfollowingdayofweek(final int targetweekday, 673 final serialdate base) { 674 675 // comprobar argumentos… 676 if (!serialdate.isvalidweekdaycode(targetweekday)) { 677 throw new illegalargumentexception( 678 “invalid day-of-the-week code.” 679 ); 680 } 681 682 // buscar la fecha… 683 final int adjust; 684 final int basedow = base.getdayofweek(); 685 if (basedow > targetweekday) { 686 adjust = 7 + math.min(0, targetweekday - basedow); 687 } 688 else { 689 adjust = math.max(0, targetweekday - basedow); 690 } 691 692 return serialdate.adddays(adjust, base); 693 } 694 695 /** 696 * devuelve la fecha que coincide con el día de la semana especificado y más 697 * próxima a la fecha base. 698 * 699 * @param targetdow un código para el día de la semana de destino. 700 * @param base la fecha base. 701 * 702 * @return la fecha que coincide con el día de la semana especificado y más 703 * próxima a la fecha base. 704 */ 705 public static serialdate getnearestdayofweek(final int targetdow, 706 final serialdate base) { 707 708 // comprobar argumentos… 454709 if (!serialdate.isvalidweekdaycode(targetdow)) { 710 throw new illegalargumentexception( 711 “invalid day-of-the-week code.” 712 ); 713 } 714 715 // buscar la fecha… 716 final int basedow = base.getdayofweek(); 717 int adjust = -math.abs(targetdow - basedow); 718 if (adjust >= 4) { 719 adjust = 7 - adjust; 720 } 721 if (adjust <= -4) { 722 adjust = 7 + adjust; 723 } 724 return serialdate.adddays(adjust, base); 725 726 } 727 728 /** 729 * avanzar la fecha hasta el último día del mes. 730 * 731 * @param base la fecha base. 732 * 733 * @return una nueva fecha de serie. 734 */ 735 public serialdate getendofcurrentmonth(final serialdate base) { 736 final int last = serialdate.lastdayofmonth( 737 base.getmonth(), base.getyyyy() 738 ); 739 return serialdate.createinstance(last, base.getmonth(), base.getyyyy()); 740 } 741 742 /** 743 * devuelve una cadena correspondiente al código de la semana del mes. 744 * <p> 745 * necesitamos un enfoque mejor. 746 * 747 * @param count un código entero que representa la semana del mes. 748 * 749 * @return una cadena correspondiente al código de la semana del mes. 750 */ 751 public static string weekinmonthtostring(final int count) { 752 455753 switch (count) { 754 case serialdate.first_week_in_month : return “first”; 755 case serialdate.second_week_in_month : return “second”; 756 case serialdate.third_week_in_month : return “third”; 757 case serialdate.fourth_week_in_month : return “fourth”; 758 case serialdate.last_week_in_month : return “last”; 759 default : 760 return “serialdate.weekinmonthtostring(): invalid code.”; 761 } 762 763 } 764 765 /** 766 * devuelve una cadena que representa el valor ‘relativo’ proporcionado. 767 * <p> 768 * necesitamos un enfoque mejor. 769 * 770 * @param relative una constante que representa el valor ‘relativo’. 771 * 772 * @return una cadena que representa el valor ‘relativo’ proporcionado. 773 */ 774 public static string relativetostring(final int relative) { 775 776 switch (relative) { 777 case serialdate.preceding : return “preceding”; 778 case serialdate.nearest : return “nearest”; 779 case serialdate.following : return “following”; 780 default : return “error : relative to string”; 781 } 782 783 } 784 785 /** 786 * método de factoría que devuelve una instancia de una subclase concreta de 787 * {@link serialdate}. 788 * 789 * @param day el día (1-31). 790 * @param month el mes (1-12). 791 * @param yyyy el año (entre 1900 y 9999). 792 * 793 * @return una instancia de {@link serialdate} 794 */ 795 public static serialdate createinstance(final int day, final int 456month, 796 final int yyyy) { 797 return new spreadsheetdate(day, month, yyyy); 798 } 799 800 /** 801 * método de factoría que devuelve una instancia de una subclase concreta de 802 * {@link serialdate}. 803 * 804 * @param serial numero de serie del día (1 de enero de 1900 = 2). 805 * 806 * @return una instancia de serialdate. 807 */ 808 public static serialdate createinstance(final int serial) { 809 return new spreadsheetdate(serial); 810 } 811 812 /** 813 * método de factoría que devuelve una instancia de una subclase de serialdate. 814 * 815 * @param date un objeto de fecha de java. 816 * 817 * @return una instancia de serialdate. 818 */ 818 public static serialdate createinstance(final java.util.date date) { 820 821 final gregoriancalendar calendar = new gregoriancalendar(); 822 calendar.settime(date); 823 return new spreadsheetdate(calendar.get(calendar.date), 824 calendar.get(calendar.month) + 1, 825 calendar.get(calendar.year)); 826 827 } 828 829 /** 830 * devuelve el número de serie de la fecha, siendo el 1 de enero de 1900 = 2 (se 831 * corresponde, casi totalmente, al sistema de numeración empleado en microsoft 832 * excel para windows y lotus 1-2-3). 833 * 834 * @return el número de serie de la fecha. 835 */ 836 public abstract int toserial(); 457837 838 /** 839 * devuelve java.util.date. como java.util.date tiene mayor precisión que 840 * serialdate, debemos definir una convención para “la hora del día”. 841 * 842 * @return this como <code>java.util.date</code>. 843 */ 844 public abstract java.util.date todate(); 845 846 /** 847 * devuelve una descripción de la fecha. 848 * 849 * @return una descripción de la fecha. 850 */ 851 public string getdescription() { 852 return this.description; 853 } 854 855 /** 856 * establece la descripción de la fecha. 857 * 858 * @param description la nueva descripción de la fecha. 859 */ 860 public void setdescription(final string description) { 861 this.description = description; 862 } 863 864 /** 865 * convierte la fecha en una cadena. 866 * 867 * @return una representación en cadena de la fecha. 868 */ 869 public string tostring() { 870 return getdayofmonth() + “-” + serialdate.monthcodetostring(getmonth()) 871 + “-” + getyyyy(); 872 } 873 874 /** 875 * devuelve el año (con un intervalo válido de 1900 a 9999). 876 * 877 * @return el año. 878 */ 879 public abstract int getyyyy(); 880 458881 /** 882 * devuelve el mes (enero = 1, febrero = 2, marzo = 3). 883 * 884 * @return el mes del año. 885 */ 886 public abstract int getmonth(); 887 888 /** 889 * devuelve el día del mes. 890 * 891 * @return el día del mes. 892 */ 893 public abstract int getdayofmonth(); 894 895 /** 896 * devuelve el día de la semana. 897 * 898 * @return el día de la semana. 899 */ 900 public abstract int getdayofweek(); 901 902 /** 903 * devuelve la diferencia (en días) entre esta fecha y la 904 * ‘otra’ fecha especificada. 905 * <p> 906 * el resultado es positivo si esta fecha es posterior a la ‘otra’ y 907 * negativo si es anterior. 908 * 909 * @param other la fecha con la que se compara. 910 * 911 * @return la diferencia entre esta fecha y la otra. 912 */ 913 public abstract int compare(serialdate other); 914 915 /** 916 * devuelve true si esta serialdate representa la misma fecha que la 917 * serialdate especificada. 918 * 919 * @param other la fecha con la que se compara. 920 * 921 * @return <code>true</code> si esta serialdate representa la misma fecha que 922 * la serialdate especificada. 923 */ 924 public abstract boolean ison(serialdate other); 459925 926 /** 927 * devuelve true si esta serialdate representa una fecha anterior en 928 * comparación a la serialdate especificada. 929 * 930 * @param other la fecha con la que se compara. 931 * 932 * @return <code>true</code> si esta serialdate representa una fecha anterior 933 * en comparación a la serialdate especificada. 934 */ 935 public abstract boolean isbefore(serialdate other); 936 937 /** 938 * devuelve true si esta serialdate representa la misma fecha que la 939 * serialdate especificada. 940 * 941 * @param other la fecha con la que se compara. 942 * 943 * @return <code>true</code> si esta serialdate representa la misma fecha 944 * que la serialdate especificada. 945 */ 946 public abstract boolean isonorbefore(serialdate other); 947 948 /** 949 * devuelve true si esta serialdate representa la misma fecha que la 950 * serialdate especificada. 951 * 952 * @param other la fecha con la que se compara. 953 * 954 * @return <code>true</code> si esta serialdate representa la misma fecha 955 * que la serialdate especificada. 956 */ 957 public abstract boolean isafter(serialdate other); 958 959 /** 960 * devuelve true si esta serialdate representa la misma fecha que la 961 * serialdate especificada. 962 * 963 * @param other la fecha con la que se compara. 964 * 965 * @return <code>true</code> si esta serialdate representa la misma fecha 966 * que la serialdate especificada. 460967 */ 968 public abstract boolean isonorafter(serialdate other); 969 970 /** 971 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 972 * rango especificado (inclusive). el orden de fecha de d1 y d2 no es 973 * importante. 974 * 975 * @param d1 fecha límite del rango. 976 * @param d2 la otra fecha límite del rango. 977 * 978 * @return un valor booleano. 979 */ 980 public abstract boolean isinrange(serialdate d1, serialdate d2); 981 982 /** 983 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 984 * rango especificado (el invocador especifica si los puntos finales se 985 * incluyen o no). el orden de fecha de d1 y d2 no es importante. 986 * 987 * @param d1 fecha límite del rango. 988 * @param d2 la otra fecha límite del rango. 989 * @param include un código que controla si las fechas inicial y final 990 * se incluyen o no en el rango. 991 * 992 * @return un valor booleano. 993 */ 994 public abstract boolean isinrange(serialdate d1, serialdate d2, 995 int include); 996 997 /** 998 * devuelve la última fecha que coincide con el día de la semana especificado y 999 * que es anterior a esta fecha. 1000 * 1001 * @param targetdow un código para el día de la semana de destino. 1002 * 1003 * @return la última fecha que coincide con el día de la semana especificado y 1004 * que es anterior a esta fecha. 1005 */ 1006 public serialdate getpreviousdayofweek(final int targetdow) { 1007 return getpreviousdayofweek(targetdow, this); 1008 } 1009 4611010 /** 1011 * devuelve la primera fecha que coincide con el día de la semana especificado 1012 * y que es posterior a esta fecha. 1013 * 1014 * @param targetdow un código para el día de la semana de destino. 1015 * 1016 * @return la primera fecha que coincide con el día de la semana especificado 1017 * que es posterior a esta fecha. 1018 */ 1019 public serialdate getfollowingdayofweek(final int targetdow) { 1020 return getfollowingdayofweek(targetdow, this); 1021 } 1022 1023 /** 1024 * devuelve la fecha más próxima que coincide con el día de la semana especificado. 1025 * 1026 * @param targetdow un código para el día de la semana de destino. 1027 * 1028 * @return la fecha más próxima que coincide con el día de la semana especificado. 1029 */ 1030 public serialdate getnearestdayofweek(final int targetdow) { 1031 return getnearestdayofweek(targetdow, this); 1032 } 1033 1034 } listado b-2 serialdatetest.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del projecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 46212 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ------------------------- 28 * serialdatetests.java 29 * ------------------------- 30 * (c) copyright 2001-2005, por object refinery limited. 31 32 * autor original: david gilbert (por object refinery limited); 33 * colaborador(es): -; 34 35 * $id: serialdatetests.java,v 1.6 2005/11/16 15:58:40 taqua exp $ 36 37 * cambios 38 * ----------- 39 * 15-nov-2001: version 1 (dg); 40 * 25-jun-2002: se elimina la importación innecesaria (dg); 41 * 24-oct-2002: errores indicados checkstyle corregidos (dg); 42 * 13-mar-2003: se añade prueba de serialización (dg); 43 * 05-jan-2005: se añade prueba para el informe de errores 1096282 (dg); 44 * 45 */ 46 47 package org.jfree.date.junit; 48 49 import java.io.bytearrayinputstream; 50 import java.io.bytearrayoutputstream; 51 import java.io.objectinput; 52 import java.io.objectinputstream; 53 import java.io.objectoutput; 54 import java.io.objectoutputstream; 55 46356 import junit.framework.test; 57 import junit.framework.testcase; 58 import junit.framework.testsuite; 59 60 import org.jfree.date.monthconstants; 61 import org.jfree.date.serialdate; 62 63 /** 64 * pruebas junit para la clase {@link serialdate}. 65 */ 66 public class serialdatetests extends testcase { 67 68 /** fecha que representa 9 de noviembre. 69 private serialdate nov9y2001; 70 71 /** 72 * crea un nuevo caso de prueba. 73 * 74 * @param name el nombre. 75 */ 76 public serialdatetests(final string name) { 77 super(name); 78 } 79 80 /** 81 * devuelve una suite de pruebas para el ejecutor de pruebas junit. 82 * 83 * @return la suite de pruebas. 84 */ 85 public static test suite() { 86 return new testsuite(serialdatetests.class); 87 } 88 89 /** 90 * problema. 91 */ 92 protected void setup() { 93 this.nov9y2001 = serialdate.createinstance(9, monthconstants.november, 2001); 94 } 95 96 /** 97 * 9 nov 2001 más dos meses debe ser 9 ene 2002. 98 */ 99 public void testaddmonthsto9nov2001() { 464100 final serialdate jan9y2002 = serialdate.addmonths(2, this.nov9y2001); 101 final serialdate answer = serialdate.createinstance(9, 1, 2002); 102 assertequals(answer, jan9y2002); 103 } 104 105 /** 106 * caso de prueba de un error, ya corregido. 107 */ 108 public void testaddmonthsto5oct2003() { 109 final serialdate d1 = serialdate.createinstance(5, monthconstants.october, 2003); 110 final serialdate d2 = serialdate.addmonths(2, d1); 111 assertequals(d2, serialdate.createinstance(5, monthconstants.december, 2003)); 112 } 113 114 /** 115 * caso de prueba de un error, ya corregido. 116 */ 117 public void testaddmonthsto1jan2003() { 118 final serialdate d1 = serialdate.createinstance(1, monthconstants.january, 2003); 119 final serialdate d2 = serialdate.addmonths(0, d1); 120 assertequals(d2, d1); 121 } 122 123 /** 124 * el lunes anterior al viernes 9 de noviembre de 2001 debe ser el 5 de noviembre. 125 */ 126 public void testmondayprecedingfriday9nov2001() { 127 serialdate mondaybefore = serialdate.getpreviousdayofweek( 128 serialdate.monday, this.nov9y2001 129 ); 130 assertequals(5, mondaybefore.getdayofmonth()); 131 } 132 133 /** 134 * el lunes posterior al viernes 9 de noviembre de 2001 debe ser el 12 de noviembre. 135 */ 136 public void testmondayfollowingfriday9nov2001() { 137 serialdate mondayafter = serialdate.getfollowingdayofweek( 138 serialdate.monday, this.nov9y2001 139 ); 465140 assertequals(12, mondayafter.getdayofmonth()); 141 } 142 143 /** 144 * el lunes más próximo al viernes 9 de noviembre de 2001 debe ser el 12 de noviembre. 145 */ 146 public void testmondaynearestfriday9nov2001() { 147 serialdate mondaynearest = serialdate.getnearestdayofweek( 148 serialdate.monday, this.nov9y2001 149 ); 150 assertequals(12, mondaynearest.getdayofmonth()); 151 } 152 153 /** 154 * el lunes más próximo al 22 de enero de 1970 cae en el 19. 155 */ 156 public void testmondaynearest22jan1970() { 157 serialdate jan22y1970 = serialdate.createinstance(22, monthconstants.january, 1970); 158 serialdate mondaynearest = serialdate.getnearestdayofweek(serialdate.monday, jan22y1970); 159 assertequals(19, mondaynearest.getdayofmonth()); 160 } 161 162 /** 163 * el problema es que la conversión de días en cadenas devuelva el resultado 164 * correcto. en realidad este resultado depende de la configuración regional. 165 */ 166 public void testweekdaycodetostring() { 167 168 final string test = serialdate.weekdaycodetostring(serialdate.saturday); 169 assertequals(“saturday”, test); 170 171 } 172 173 /** 174 * probar la conversión de una cadena en día de la semana. esta prueba falla si 175 * la configuración regional predeterminada no usa nombres de días en inglés 176 */ 177 public void teststringtoweekday() { 178 466179 int weekday = serialdate.stringtoweekdaycode(“wednesday”); 180 assertequals(serialdate.wednesday, weekday); 181 182 weekday = serialdate.stringtoweekdaycode(“ wednesday ”); 183 assertequals(serialdate.wednesday, weekday); 184 185 weekday = serialdate.stringtoweekdaycode(“wed”); 186 assertequals(serialdate.wednesday, weekday); 187 188 } 189 190 /** 191 * probar la conversión de una cadena en mes. esta prueba falla si la 192 * configuración regional predeterminada no usa nombres de días en inglés 193 */ 194 public void teststringtomonthcode() { 195 196 int m = serialdate.stringtomonthcode(“january”); 197 assertequals(monthconstants.january, m); 198 199 m = serialdate.stringtomonthcode(“ january ”); 200 assertequals(monthconstants.january, m); 201 202 m = serialdate.stringtomonthcode(“jan”); 203 assertequals(monthconstants.january, m); 204 205 } 206 207 /** 208 * probar la conversión de un código de mes en cadena. 209 */ 210 public void testmonthcodetostringcode() { 211 212 final string test = serialdate.monthcodetostring(monthconstants.december); 213 assertequals(“december”, test); 214 215 } 216 217 /** 218 * 1900 no es un año bisiesto. 219 */ 220 public void testisnotleapyear1900() { 221 asserttrue(!serialdate.isleapyear(1900)); 222 } 467223 224 /** 225 * 2000 es un año bisiesto. 226 */ 227 public void testisleapyear2000() { 228 asserttrue(serialdate.isleapyear(2000)); 229 } 230 231 /** 232 * el número de años bisiestos desde 1900 y hasta 1899 incluido es 0. 233 */ 234 public void testleapyearcount1899() { 235 assertequals(serialdate.leapyearcount(1899), 0); 236 } 237 238 /** 239 * el número de años bisiestos desde 1900 y hasta 1903 incluido es 0. 240 */ 241 public void testleapyearcount1903() { 242 assertequals(serialdate.leapyearcount(1903), 0); 243 } 244 245 /** 246 * el número de años bisiestos desde 1900 y hasta 1904 incluido es 1. 247 */ 248 public void testleapyearcount1904() { 249 assertequals(serialdate.leapyearcount(1904), 1); 250 } 251 252 /** 253 * el número de años bisiestos desde 1900 y hasta 1999 incluido es 24. 254 */ 255 public void testleapyearcount1999() { 256 assertequals(serialdate.leapyearcount(1999), 24); 257 } 258 259 /** 260 * el número de años bisiestos desde 1900 y hasta 2000 incluido es 25. 261 */ 262 public void testleapyearcount2000() { 263 assertequals(serialdate.leapyearcount(2000), 25); 264 } 265 266 /** 267 * serializar una instancia, restaurarla y comprobar la igualdad. 468268 */ 269 public void testserialization() { 270 271 serialdate d1 = serialdate.createinstance(15, 4, 2000); 272 serialdate d2 = null; 273 274 try { 275 bytearrayoutputstream buffer = new bytearrayoutputstream(); 276 objectoutput out = new objectoutputstream(buffer); 277 out.writeobject(d1); 278 out.close(); 279 280 objectinput in = new objectinputstream( new bytearrayinputstream(buffer.tobytearray())); 281 d2 = (serialdate) in.readobject(); 282 in.close(); 283 } 284 catch (exception e) { 285 system.out.println(e.tostring()); 286 } 287 assertequals(d1, d2); 288 289 } 290 291 /** 292 * prueba para el informe de error 1096282 (ya corregido). 293 */ 294 public void test1096282() { 295 serialdate d = serialdate.createinstance(29, 2, 2004); 296 d = serialdate.addyears(1, d); 297 serialdate expected = serialdate.createinstance(28, 2, 2005); 298 asserttrue(d.ison(expected)); 299 } 300 301 /** 302 * diversas pruebas para el método addmonths(). 303 */ 304 public void testaddmonths() { 305 serialdate d1 = serialdate.createinstance(31, 5, 2004); 307 serialdate d2 = serialdate.addmonths(1, d1); 308 assertequals(30, d2.getdayofmonth()); 309 assertequals(6, d2.getmonth()); 310 assertequals(2004, d2.getyyyy()); 311 312 serialdate d3 = serialdate.addmonths(2, d1); 469313 assertequals(31, d3.getdayofmonth()); 314 assertequals(7, d3.getmonth()); 315 assertequals(2004, d3.getyyyy()); 316 317 serialdate d4 = serialdate.addmonths(1, serialdate.addmonths(1, d1)); 318 assertequals(30, d4.getdayofmonth()); 319 assertequals(7, d4.getmonth()); 320 assertequals(2004, d4.getyyyy()); 321 } 322 } listado b-3 monthconstants.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * ---------------------- 28 * monthconstants.java 47029 * ---------------------- 30 * (c) copyright 2002, 2003, de object refinery limited. 31 * 32 * autor original: david gilbert (para object refinery limited); 33 * colaborador(es): -; 34 * 35 * $id: monthconstants.java,v 1.4 2005/11/16 15:58:40 taqua exp $ 36 * 37 * cambios 38 * ---------- 39 * 29-may-2002 : version 1 (code moved from serialdate class) (dg); 40 * 41 */ 42 43 package org.jfree.date; 44 45 /** 46 * constantes útiles para los meses. no son equivalentes a las 47 * constantes definidas por java.util.calendar (donde january=0 y december=11). 48 * <p> 49 * se usa en las clases serialdate y regulartimeperiod. 50 * 51 * @author david gilbert 52 */ 53 public interface monthconstants { 54 55 /** constante para enero. */ 56 public static final int january = 1; 57 58 /** constante para febrero. */ 59 public static final int february = 2; 60 61 /** constante para marzo. */ 62 public static final int march = 3; 63 64 /** constante para abril. */ 65 public static final int april = 4; 66 67 /** constante para mayo. */ 68 public static final int may = 5; 69 70 /** constante para junio. */ 71 public static final int june = 6; 72 47173 /** constante para julio. */ 74 public static final int july = 7; 75 76 /** constante para agosto. */ 77 public static final int august = 8; 78 79 /** constante para septiembre. */ 80 public static final int september = 9; 81 82 /** constante para octubre. */ 83 public static final int october = 10; 84 85 /** constante para noviembre. */ 86 public static final int november = 11; 87 88 /** constante para diciembre. */ 89 public static final int december = 12; 90 91 } listado b-4 bobsserialdatetest.java 1 package org.jfree.date.junit; 2 3 import junit.framework.testcase; 4 import org.jfree.date.*; 5 import static org.jfree.date.serialdate.*; 6 7 import java.util.*; 8 9 public class bobsserialdatetest extends testcase { 10 11 public void testisvalidweekdaycode() throws exception { 12 for (int day = 1; day <= 7; day++) 13 asserttrue(isvalidweekdaycode(day)); 14 assertfalse(isvalidweekdaycode(0)); 15 assertfalse(isvalidweekdaycode(8)); 16 } 17 18 public void teststringtoweekdaycode() throws exception { 19 20 assertequals(-1, stringtoweekdaycode(“hello”)); 21 assertequals(monday, stringtoweekdaycode(“monday”)); 47222 assertequals(monday, stringtoweekdaycode(“mon”)); 23 //todo assertequals(monday,stringtoweekdaycode(“monday”)); 24 // assertequals(monday,stringtoweekdaycode(“monday”)); 25 // assertequals(monday, stringtoweekdaycode(“mon”)); 26 27 assertequals(tuesday, stringtoweekdaycode(“tuesday”)); 28 assertequals(tuesday, stringtoweekdaycode(“tue”)); 29 // assertequals(tuesday,stringtoweekdaycode(“tuesday”)); 30 // assertequals(tuesday,stringtoweekdaycode(“tuesday”)); 31 // assertequals(tuesday, stringtoweekdaycode(“tue”)); 32 // assertequals(tuesday, stringtoweekdaycode(“tues”)); 33 34 assertequals(wednesday, stringtoweekdaycode (“wednesday”)); 35 assertequals(wednesday, stringtoweekdaycode(“wed”)); 36 // assertequals(wednesday,stringtoweekdaycode(“wednesday”)); 37 // assertequals(wednesday,stringtoweekdaycode(“wednesday”)); 38 // assertequals(wednesday, stringtoweekdaycode(“wed”)); 39 40 assertequals(thursday, stringtoweekdaycode(“thursday”)); 41 assertequals(thursday, stringtoweekdaycode(“thu”)); 42 // assertequals(thursday,stringtoweekdaycode(“thursday”)); 43 // assertequals(thursday,stringtoweekdaycode(“thursday”)); 44 // assertequals(thursday, stringtoweekdaycode(“thu”)); 45 // assertequals(thursday, stringtoweekdaycode(“thurs”)); 46 47 assertequals(friday, stringtoweekdaycode(“friday”)); 48 assertequals(friday, stringtoweekdaycode(“fri”)); 49 // assertequals(friday,stringtoweekdaycode(“friday”)); 50 // assertequals(friday,stringtoweekdaycode(“friday”)); 51 // assertequals(friday, stringtoweekdaycode(“fri”)); 52 53 assertequals(saturday, stringtoweekdaycode(“saturday”)); 54 assertequals(saturday, stringtoweekdaycode(“sat”)); 55 // assertequals(saturday,stringtoweekdaycode(“saturday”)); 56 // assertequals(saturday,stringtoweekdaycode(“saturday”)); 57 // assertequals(saturday, stringtoweekdaycode(“sat”)); 58 59 assertequals(sunday, stringtoweekdaycode(“sunday”)); 60 assertequals(sunday, stringtoweekdaycode(“sun”)); 61 // assertequals(sunday,stringtoweekdaycode(“sunday”)); 62 // assertequals(sunday,stringtoweekdaycode(“sunday”)); 63 // assertequals(sunday, stringtoweekdaycode(“sun”)); 64 } 65 66 public void testweekdaycodetostring() throws exception { 47367 assertequals(“sunday”, weekdaycodetostring(sunday)); 68 assertequals(“monday”, weekdaycodetostring(monday)); 69 assertequals(“tuesday”, weekdaycodetostring(tuesday)); 70 assertequals(“wednesday”, weekdaycodetostring(wednesday)); 71 assertequals(“thursday”, weekdaycodetostring(thursday)); 72 assertequals(“friday”, weekdaycodetostring(friday)); 73 assertequals(“saturday”, weekdaycodetostring(saturday)); 74 } 75 76 public void testisvalidmonthcode() throws exception { 77 for (int i = 1; i <= 12; i++) 78 asserttrue(isvalidmonthcode(i)); 79 assertfalse(isvalidmonthcode(0)); 80 assertfalse(isvalidmonthcode(13)); 81 } 82 83 public void testmonthtoquarter() throws exception { 84 assertequals(1, monthcodetoquarter(january)); 85 assertequals(1, monthcodetoquarter(february)); 86 assertequals(1, monthcodetoquarter(march)); 87 assertequals(2, monthcodetoquarter(april)); 88 assertequals(2, monthcodetoquarter(may)); 89 assertequals(2, monthcodetoquarter(june)); 90 assertequals(3, monthcodetoquarter(july)); 91 assertequals(3, monthcodetoquarter(august)); 92 assertequals(3, monthcodetoquarter(september)); 93 assertequals(4, monthcodetoquarter(october)); 94 assertequals(4, monthcodetoquarter(november)); 95 assertequals(4, monthcodetoquarter(december)); 96 97 try { 98 monthcodetoquarter(-1); 99 fail(“invalid month code should throw exception”); 100 } catch (illegalargumentexception e) { 101 } 102 } 103 104 public void testmonthcodetostring() throws exception { 105 assertequals(“january”, monthcodetostring(january)); 106 assertequals(“february”, monthcodetostring(february)); 107 assertequals(“march”, monthcodetostring(march)); 108 assertequals(“april”, monthcodetostring(april)); 109 assertequals(“may”, monthcodetostring(may)); 110 assertequals(“june”, monthcodetostring(june)); 111 assertequals(“july”, monthcodetostring(july)); 474112 assertequals(“august”, monthcodetostring(august)); 113 assertequals(“september”, monthcodetostring(september)); 114 assertequals(“october”, monthcodetostring(october)); 115 assertequals(“november”, monthcodetostring(november)); 116 assertequals(“december”, monthcodetostring(december)); 117 118 assertequals(“jan”, monthcodetostring(january, true)); 119 assertequals(“feb”, monthcodetostring(february, true)); 120 assertequals(“mar”, monthcodetostring(march, true)); 121 assertequals(“apr”, monthcodetostring(april, true)); 122 assertequals(“may”, monthcodetostring(may, true)); 123 assertequals(“jun”, monthcodetostring(june, true)); 124 assertequals(“jul”, monthcodetostring(july, true)); 125 assertequals(“aug”, monthcodetostring(august, true)); 126 assertequals(“sep”, monthcodetostring(september, true)); 127 assertequals(“oct”, monthcodetostring(october, true)); 128 assertequals(“nov”, monthcodetostring(november, true)); 129 assertequals(“dec”, monthcodetostring(december, true)); 130 131 try { 132 monthcodetostring(-1); 133 fail(“invalid month code should throw exception”); 134 } catch (illegalargumentexception e) { 135 } 136 137 } 138 139 public void teststringtomonthcode() throws exception { 140 assertequals(january,stringtomonthcode(“1”)); 141 assertequals(february,stringtomonthcode(“2”)); 142 assertequals(march,stringtomonthcode(“3”)); 143 assertequals(april,stringtomonthcode(“4”)); 144 assertequals(may,stringtomonthcode(“5”)); 145 assertequals(june,stringtomonthcode(“6”)); 146 assertequals(july,stringtomonthcode(“7”)); 147 assertequals(august,stringtomonthcode(“8”)); 148 assertequals(september,stringtomonthcode(“9”)); 149 assertequals(october,stringtomonthcode(“10”)); 150 assertequals(november, stringtomonthcode(“11”)); 151 assertequals(december,stringtomonthcode(“12”)); 152 153 //todo assertequals(-1, stringtomonthcode(“0”)); 154 // assertequals(-1, stringtomonthcode(“13”)); 155 156 assertequals(-1,stringtomonthcode(“hello”)); 475157 158 for (int m = 1; m <= 12; m++) { 159 assertequals(m, stringtomonthcode(monthcodetostring(m, false))); 160 assertequals(m, stringtomonthcode(monthcodetostring(m, true))); 161 } 162 163 // assertequals(1,stringtomonthcode(“jan”)); 164 // assertequals(2,stringtomonthcode(“feb”)); 165 // assertequals(3,stringtomonthcode(“mar”)); 166 // assertequals(4,stringtomonthcode(“apr”)); 167 // assertequals(5,stringtomonthcode(“may”)); 168 // assertequals(6,stringtomonthcode(“jun”)); 169 // assertequals(7,stringtomonthcode(“jul”)); 170 // assertequals(8,stringtomonthcode(“aug”)); 171 // assertequals(9,stringtomonthcode(“sep”)); 172 // assertequals(10,stringtomonthcode(“oct”)); 173 // assertequals(11,stringtomonthcode(“nov”)); 174 // assertequals(12,stringtomonthcode(“dec”)); 175 176 // assertequals(1,stringtomonthcode(“jan”)); 177 // assertequals(2,stringtomonthcode(“feb”)); 178 // assertequals(3,stringtomonthcode(“mar”)); 179 // assertequals(4,stringtomonthcode(“apr”)); 180 // assertequals(5,stringtomonthcode(“may”)); 181 // assertequals(6,stringtomonthcode(“jun”)); 182 // assertequals(7,stringtomonthcode(“jul”)); 183 // assertequals(8,stringtomonthcode(“aug”)); 184 // assertequals(9,stringtomonthcode(“sep”)); 185 // assertequals(10,stringtomonthcode(“oct”)); 186 // assertequals(11,stringtomonthcode(“nov”)); 187 // assertequals(12,stringtomonthcode(“dec”)); 188 189 // assertequals(1,stringtomonthcode(“january”)); 190 // assertequals(2,stringtomonthcode(“february”)); 191 // assertequals(3,stringtomonthcode(“march”)); 192 // assertequals(4,stringtomonthcode(“april”)); 193 // assertequals(5,stringtomonthcode(“may”)); 194 // assertequals(6,stringtomonthcode(“june”)); 195 // assertequals(7,stringtomonthcode(“july”)); 196 // assertequals(8,stringtomonthcode(“august”)); 197 // assertequals(9,stringtomonthcode(“september”)); 198 // assertequals(10,stringtomonthcode(“october”)); 199 // assertequals(11,stringtomonthcode(“november”)); 200 // assertequals(12,stringtomonthcode(“december”)); 201 476202 // assertequals(1,stringtomonthcode(“january”)); 203 // assertequals(2,stringtomonthcode(“february”)); 204 // assertequals(3,stringtomonthcode(“mar”)); 205 // assertequals(4,stringtomonthcode(“april”)); 206 // assertequals(5,stringtomonthcode(“may”)); 207 // assertequals(6,stringtomonthcode(“june”)); 208 // assertequals(7,stringtomonthcode(“july”)); 209 // assertequals(8,stringtomonthcode(“august”)); 210 // assertequals(9,stringtomonthcode(“september”)); 211 // assertequals(10,stringtomonthcode(“october”)); 212 // assertequals(11,stringtomonthcode(“november”)); 213 // assertequals(12,stringtomonthcode(“december”)); 214 } 215 216 public void testisvalidweekinmonthcode() throws exception { 217 for (int w = 0; w <= 4; w++) { 218 asserttrue(isvalidweekinmonthcode(w)); 219 } 220 assertfalse(isvalidweekinmonthcode(5)); 221 } 222 223 public void testisleapyear() throws exception { 224 assertfalse(isleapyear(1900)); 225 assertfalse(isleapyear(1901)); 226 assertfalse(isleapyear(1902)); 227 assertfalse(isleapyear(1903)); 228 asserttrue(isleapyear(1904)); 229 asserttrue(isleapyear(1908)); 230 assertfalse(isleapyear(1955)); 231 asserttrue(isleapyear(1964)); 232 asserttrue(isleapyear(1980)); 233 asserttrue(isleapyear(2000)); 234 assertfalse(isleapyear(2001)); 235 assertfalse(isleapyear(2100)); 236 } 237 238 public void testleapyearcount() throws exception { 239 assertequals(0, leapyearcount(1900)); 240 assertequals(0, leapyearcount(1901)); 241 assertequals(0, leapyearcount(1902)); 242 assertequals(0, leapyearcount(1903)); 243 assertequals(1, leapyearcount(1904)); 244 assertequals(1, leapyearcount(1905)); 245 assertequals(1, leapyearcount(1906)); 246 assertequals(1, leapyearcount(1907)); 477247 assertequals(2, leapyearcount(1908)); 248 assertequals(24, leapyearcount(1999)); 249 assertequals(25, leapyearcount(2001)); 250 assertequals(49, leapyearcount(2101)); 251 assertequals(73, leapyearcount(2201)); 252 assertequals(97, leapyearcount(2301)); 253 assertequals(122, leapyearcount(2401)); 254 } 255 256 public void testlastdayofmonth() throws exception { 257 assertequals(31, lastdayofmonth(january, 1901)); 258 assertequals(28, lastdayofmonth(february, 1901)); 259 assertequals(31, lastdayofmonth(march, 1901)); 260 assertequals(30, lastdayofmonth(april, 1901)); 261 assertequals(31, lastdayofmonth(may, 1901)); 262 assertequals(30, lastdayofmonth(june, 1901)); 263 assertequals(31, lastdayofmonth(july, 1901)); 264 assertequals(31, lastdayofmonth(august, 1901)); 265 assertequals(30, lastdayofmonth(september, 1901)); 266 assertequals(31, lastdayofmonth(october, 1901)); 267 assertequals(30, lastdayofmonth(november, 1901)); 268 assertequals(31, lastdayofmonth(december, 1901)); 269 assertequals(29, lastdayofmonth(february, 1904)); 270 } 271 272 public void testadddays() throws exception { 273 serialdate newyears = d(1, january, 1900); 274 assertequals(d(2, january, 1900), adddays(1, newyears)); 275 assertequals(d(1, february, 1900), adddays(31, newyears)); 276 assertequals(d(1, january, 1901), adddays(365, newyears)); 277 assertequals(d(31, december, 1904), adddays(5 * 365, newyears)); 278 } 279 280 private static spreadsheetdate d(int day, int month, int year) { return new spreadsheetdate(day, month, year); } 281 282 public void testaddmonths() throws exception { 283 assertequals(d(1, february, 1900), addmonths(1, d(1, january, 1900))); 284 assertequals(d(28, february, 1900), addmonths(1, d(31, january, 1900))); 285 assertequals(d(28, february, 1900), addmonths(1, d(30, january, 1900))); 286 assertequals(d(28, february, 1900), addmonths(1, d(29, january, 1900))); 287 assertequals(d(28, february, 1900), addmonths(1, d(28, january, 4781900))); 288 assertequals(d(27, february, 1900), addmonths(1, d(27, january, 1900))); 289 290 assertequals(d(30, june, 1900), addmonths(5, d(31, january, 1900))); 291 assertequals(d(30, june, 1901), addmonths(17, d(31, january, 1900))); 292 293 assertequals(d(29, february, 1904), addmonths(49, d(31, january, 1900))); 294 295 } 296 297 public void testaddyears() throws exception { 298 assertequals(d(1, january, 1901), addyears(1, d(1, january, 1900))); 299 assertequals(d(28, february, 1905), addyears(1, d(29, february, 1904))); 300 assertequals(d(28, february, 1905), addyears(1, d(28, february, 1904))); 301 assertequals(d(28, february, 1904), addyears(1, d(28, february, 1903))); 302 } 303 304 public void testgetpreviousdayofweek() throws exception { 305 assertequals(d(24, february, 2006), getpreviousdayofweek(friday, d(1, march, 2006))); 306 assertequals(d(22, february, 2006), getpreviousdayofweek(wednesday, d(1, march, 2006))); 307 assertequals(d(29, february, 2004), getpreviousdayofweek(sunday, d(3, march, 2004))); 308 assertequals(d(29, december, 2004), getpreviousdayofweek(wednesday, d(5, january, 2005))); 309 310 try { 311 getpreviousdayofweek(-1, d(1, january, 2006)); 312 fail(“invalid day of week code should throw exception”); 313 } catch (illegalargumentexception e) { 314 } 315 } 316 317 public void testgetfollowingdayofweek() throws exception { 318 // assertequals(d(1, january, 2005),getfollowingdayofweek(saturday, d(25, december, 2004))); 319 assertequals(d(1, january, 2005), getfollowingdayofweek(saturday, d(26, december, 2004))); 320 assertequals(d(3, march, 2004), getfollowingdayofweek(wednesday, d(28, february, 2004))); 321 479322 try { 323 getfollowingdayofweek(-1, d(1, january, 2006)); 324 fail(“invalid day of week code should throw exception”); 325 } catch (illegalargumentexception e) { 326 } 327 } 328 329 public void testgetnearestdayofweek() throws exception { 330 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(16, april, 2006))); 331 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(17, april, 2006))); 332 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(18, april, 2006))); 333 assertequals(d(16, april, 2006), getnearestdayofweek(sunday, d(19, april, 2006))); 334 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(20, april, 2006))); 335 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(21, april, 2006))); 336 assertequals(d(23, april, 2006), getnearestdayofweek(sunday, d(22, april, 2006))); 337 338 //todo assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(16, april, 2006))); 339 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(17, april, 2006))); 340 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(18, april, 2006))); 341 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(19, april, 2006))); 342 assertequals(d(17, april, 2006), getnearestdayofweek(monday, d(20, april, 2006))); 343 assertequals(d(24, april, 2006), getnearestdayofweek(monday, d(21, april, 2006))); 344 assertequals(d(24, april, 2006), getnearestdayofweek(monday, d(22, april, 2006))); 345 346 // assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(16, april, 2006))); 347 // assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(17, april, 2006))); 348 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(18, april, 2006))); 349 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(19, april, 2006))); 350 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(20, april, 2006))); 351 assertequals(d(18, april, 2006), getnearestdayofweek(tuesday, d(21, 480april, 2006))); 352 assertequals(d(25, april, 2006), getnearestdayofweek(tuesday, d(22, april, 2006))); 353 354 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(16, april, 2006))); 355 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(17, april, 2006))); 356 // assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(18, april, 2006))); 357 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(19, april, 2006))); 358 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(20, april, 2006))); 359 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(21, april, 2006))); 360 assertequals(d(19, april, 2006), getnearestdayofweek(wednesday, d(22, april, 2006))); 361 362 // assertequals(d(13, april, 2006), getnearestdayofweek(thursday, d(16, april, 2006))); 363 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(17, april, 2006))); 364 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(18, april, 2006))); 365 // assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(19, april, 2006))); 366 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(20, april, 2006))); 367 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(21, april, 2006))); 368 assertequals(d(20, april, 2006), getnearestdayofweek(thursday, d(22, april, 2006))); 369 370 // assertequals(d(14, april, 2006), getnearestdayofweek(friday, d(16, april, 2006))); 371 // assertequals(d(14, april, 2006), getnearestdayofweek(friday, d(17, april, 2006))); 372 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(18, april, 2006))); 373 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(19, april, 2006))); 374 // assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(20, april, 2006))); 375 assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(21, april, 2006))); 376 assertequals(d(21, april, 2006), getnearestdayofweek(friday, d(22, april, 2006))); 377 378 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(16, 481april, 2006))); 379 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(17, april, 2006))); 380 // assertequals(d(15, april, 2006), getnearestdayofweek(saturday, d(18, april, 2006))); 381 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(19, april, 2006))); 382 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(20, april, 2006))); 383 // assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(21, april, 2006))); 384 assertequals(d(22, april, 2006), getnearestdayofweek(saturday, d(22, april, 2006))); 385 386 try { 387 getnearestdayofweek(-1, d(1, january, 2006)); 388 fail(“invalid day of week code should throw exception”); 389 } catch (illegalargumentexception e) { 390 } 391 } 392 393 public void testendofcurrentmonth() throws exception { 394 serialdate d = serialdate.createinstance(2); 395 assertequals(d(31, january, 2006), d.getendofcurrentmonth(d(1, january, 2006))); 396 assertequals(d(28, february, 2006), d.getendofcurrentmonth(d(1, february, 2006))); 397 assertequals(d(31, march, 2006), d.getendofcurrentmonth(d(1, march, 2006))); 398 assertequals(d(30, april, 2006), d.getendofcurrentmonth(d(1, april, 2006))); 399 assertequals(d(31, may, 2006), d.getendofcurrentmonth(d(1, may, 2006))); 400 assertequals(d(30, june, 2006), d.getendofcurrentmonth(d(1, june, 2006))); 401 assertequals(d(31, july, 2006), d.getendofcurrentmonth(d(1, july, 2006))); 402 assertequals(d(31, august, 2006), d.getendofcurrentmonth(d(1, august, 2006))); 403 assertequals(d(30, september, 2006), d.getendofcurrentmonth(d(1, september, 2006))); 404 assertequals(d(31, october, 2006), d.getendofcurrentmonth(d(1, october, 2006))); 405 assertequals(d(30, november, 2006), d.getendofcurrentmonth(d(1, november, 2006))); 406 assertequals(d(31, december, 2006), d.getendofcurrentmonth(d(1, december, 2006))); 407 assertequals(d(29, february, 2008), d.getendofcurrentmonth(d(1, february, 2008))); 482408 } 409 410 public void testweekinmonthtostring() throws exception { 411 assertequals(“first”,weekinmonthtostring(first_week_in_month)); 412 assertequals(“second”,weekinmonthtostring(second_week_in_month)); 413 assertequals(“third”,weekinmonthtostring(third_week_in_month)); 414 assertequals(“fourth”,weekinmonthtostring(fourth_week_in_month)); 415 assertequals(“last”,weekinmonthtostring(last_week_in_month)); 416 417 //todo try { 418 // weekinmonthtostring(-1); 419 // fail(“invalid week code should throw exception”); 420 // } catch (illegalargumentexception e) { 421 // } 422 } 423 424 public void testrelativetostring() throws exception { 425 assertequals(“preceding”,relativetostring(preceding)); 426 assertequals(“nearest”,relativetostring(nearest)); 427 assertequals(“following”,relativetostring(following)); 428 429 //todo try { 430 // relativetostring(-1000); 431 // fail(“invalid relative code should throw exception”); 432 // } catch (illegalargumentexception e) { 433 // } 434 } 435 436 public void testcreateinstancefromddmmyyyy() throws exception { 437 serialdate date = createinstance(1, january, 1900); 438 assertequals(1,date.getdayofmonth()); 439 assertequals(january,date.getmonth()); 440 assertequals(1900,date.getyyyy()); 441 assertequals(2,date.toserial()); 442 } 443 444 public void testcreateinstancefromserial() throws exception { 445 assertequals(d(1, january, 1900),createinstance(2)); 446 assertequals(d(1, january, 1901), createinstance(367)); 447 } 448 449 public void testcreateinstancefromjavadate() throws exception { 450 assertequals(d(1, january, 1900), createinstance(new gregoriancalendar(1900,0,1).gettime())); 451 assertequals(d(1, january, 2006), 483createinstance(new gregoriancalendar(2006,0,1).gettime())); 452 } 453 454 public static void main(string[] args) { 455 junit.textui.testrunner.run(bobsserialdatetest.class); 456 } 457 } 484listado b-5 spreadsheetdate.java. 1 /* ============================================================= 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 19 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * -------------------------- 28 * spreadsheetdate.java 29 * -------------------------- 30 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 31 * 32 * autor original: david gilbert (por object refinery limited); 33 * colaboradores(s): -; 34 * 35 * $id: speadsheetdate.java,v 1.8 2005/11/03 09:25:39 mungady exp $ 36 * 37 * cambios 38 * ---------- 39 * 11-oct-2001 : version 1 (dg); 48540 * 05-nov-2001 : se añaden los métodos getdescription() y setdescription() (dg); 41 * 12-nov-2001 : se cambia el nombre exceldate.java por spreadsheetdate.java (dg); 42 * se corrige un error a la hora de calcular el día, mes y año a 43 * partir del número de serie (dg); 44 * 24-jan-2002 : se corrige un error a la hora de calcular el número de serie a 45 * partir del día, mes y año. gracias a trevor kills por el informe (dg); 46 * 29-may-2002 : se añade el método equals(object) (sourceforge id 558850) (dg); 47 * 03-oct-2002 : se corrigen los errores detectados por checkstyle (dg); 48 * 13-mar-2003 : implementación de serializable (dg); 49 * 04-sep-2003 : métodos isinrange() completados (dg); 50 * 05-sep-2003 : implementación de comparable (dg); 51 * 21-oct-2003 : se añade el método hashcode() (dg); 52 * 53 /* 54 55 package org.jfree.date; 56 57 import java.util.calendar; 58 import java.util.date; 59 /** 60 61 * representa una con un entero, de forma similar a la 62 * implementación en microsoft excel. el intervalo de fechas admitido es 63 * 1-ene-1900 a 31-dic-9999. 64 * <p> 65 * recuerde que excel tiene un error que reconoce el año 66 * 1900 como bisiesto cuando en realidad no lo es. encontrará más 67 * información en el sitio web de microsoft, en el artículo q181370: 68 * <p> 69 * http://support.microsoft.com/support/kb/articles/q181/3/70.asp 70 * <p> 71 * excel usa como convención que el 1-ene-1900 = 1. esta clase usa la 72 * convención de que 1-ene-1900 = 2. 73 * como resultado, el número de día de esta clase será diferente al de 74 * excel para enero y febrero de 1900… pero excel añade un día 75 * más (29-feb-1900 que en realidad no existe) y a partir de ahí 76 * los números de los días coinciden. 77 * 78 * @author david gilbert 79 */ 80 public class spreadsheetdate extends serialdate { 81 48682 /** para serialización. */ 83 private static final long serialversionuid = -2039586705374454461l; 84 85 /** 86 * el número de día (1-ene-1900 = 2, 2-ene-1900 = 3…, 31-dic-9999 = 87 * 2958465). 88 */ 89 private int serial; 90 91 /** el día del mes (de 1 a 28, 29, 30 o 31 en función del mes). */ 92 private int day; 93 94 /** el mes del año (de 1 a 12). */ 95 private int month; 96 97 /** el año (de 1900 a 9999). */ 98 private int year; 99 100 /** una descripción opcional para la fecha. */ 101 private string description; 102 103 /** 104 * crear una nueva instancia de la fecha. 105 * 106 * @param day el día (entre 1 y 28/29/30/31). 107 * @param month el mes (entre 1 y 12). 108 * @param year el año (entre 1900 y 9999). 109 */ 110 public spreadsheetdate(final int day, final int month, final int year) { 111 112 if ((year >= 1900) && (year <= 9999)) { 113 this.year = year; 114 } 115 else { 116 throw new illegalargumentexception( 117 “the ‘year’ argument must be in range 1900 to 9999.” 118 ); 119 } 120 121 if ((month >= monthconstants.january) 122 && (month <= monthconstants.december)) { 123 this.month = month; 124 } 125 else { 487126 throw new illegalargumentexception( 127 “the ‘month’ argument must be in the range 1 to 12.” 128 ); 129 } 130 131 if ((day >= 1) && (day <= serialdate.lastdayofmonth(month, year))) { 132 this.day = day; 133 } 134 else { 135 throw new illegalargumentexception(“invalid ‘day’ argument.”); 136 } 137 138 // es necesario sincronizar el número de serie con el día-mes-año… 139 this.serial = calcserial(day, month, year); 140 141 this.description = null; 142 143 } 144 145 /** 146 * constructor estándar: crear un nuevo objeto de fecha que representa el 147 * número de día especificado (que debe estar comprendido entre 2 y 2958465). 148 * 149 * @param serial número de serie para el día (entre 2 y 2958465). 150 */ 151 public spreadsheetdate(final int serial) { 152 153 if ((serial >= serial_lower_bound) && (serial <= serial_upper_bound)) { 154 this.serial = serial; 155 } 156 else { 157 throw new illegalargumentexception( 158 “spreadsheetdate: serial must be in range 2 to 2958465.”); 159 } 160 161 // el día-mes-año debe estar sincronizado con el número de serie… 162 calcdaymonthyear(); 163 164 } 165 166 /** 167 * devuelve la descripción adjuntada a la fecha. no es 168 * obligatorio que la fecha tenga una descripción, pero resulta útil 488169 * en algunas aplicaciones. 170 * 171 * @return la descripción adjuntada a la fecha. 172 */ 173 public string getdescription() { 174 return this.description; 175 } 176 177 /** 178 * establece la descripción de la fecha. 179 * 180 * @param description la descripción de esta fecha (<code>null</code> 181 * se permite) 182 */ 183 public void setdescription(final string description) { 184 this.description = description; 185 } 186 187 /** 188 * devuelve el número de serie de la fecha, siendo el 1 de enero 1900 = 2 189 * (se corresponde, casi totalmente, al sistema de numeración empleado en 190 * microsoft excel para windows y lotus 1-2-3). 191 * 192 * @return el número de serie de la fecha. 193 */ 194 public int toserial() { 195 return this.serial; 196 } 197 198 /** 199 * devuelve una <code>java.util.date</code> equivalente a esta fecha. 200 * 201 * @return la fecha. 202 */ 203 public date todate() { 204 final calendar calendar = calendar.getinstance(); 205 calendar.set(getyyyy(), getmonth() - 1, getdayofmonth(), 0, 0, 0); 206 return calendar.gettime(); 207 } 208 209 /** 210 * devuelve el año (con un intervalo válido de 1900 a 9999). 211 * 212 * @return el año. 489213 */ 214 public int getyyyy() { 215 return this.year; 216 } 217 218 /** 219 * devuelve el mes (enero = 1, febrero = 2, marzo = 3). 220 * 221 * @return el mes del año. 222 */ 223 public int getmonth() { 224 return this.month; 225 } 226 227 /** 228 * devuelve el día del mes. 229 * 230 * @return el día del mes. 231 */ 232 public int getdayofmonth() { 233 return this.day; 234 } 235 236 /** 237 * devuelve un código que representa el día de la semana. 238 * <p> 239 * los códigos se definen en la clase {@link serialdate} como: 240 * <code>sunday</code>, <code>monday</code>, <code>tuesday</code>, 241 * <code>wednesday</code>, <code>thursday</code>, <code>friday</code>, y 242 * <code>saturday</code>. 243 * 244 * @return un código que representa el día de la semana. 245 */ 246 public int getdayofweek() { 247 return (this.serial + 6) % 7 + 1; 248 } 249 250 /** 251 * prueba la igualdad de esta fecha con un objeto arbitrario. 252 * <p> 253 * este método sólo devuelve true si el objeto es una instancia de la 254 * clase base {@link serialdate} y representa el mismo día que 255 * {@link spreadsheetdate}. 256 * 490257 * @param object el objeto que comparar (se permite <code>null</code>). 258 * 259 * @return un valor booleano. 260 */ 261 public boolean equals(final object object) { 262 263 if (object instanceof serialdate) { 264 final serialdate s = (serialdate) object; 265 return (s.toserial() == this.toserial()); 266 } 267 else { 268 return false; 269 } 270 271 } 272 273 /** 274 * devuelve un código hash para la instancia de este objeto. 275 * 276 * @return un código hash. 277 */ 278 public int hashcode() { 279 return toserial(); 280 } 281 282 /** 283 * devuelve la diferencia (en días) entre esta fecha y la 284 * ‘otra’ fecha especificada. 285 * 286 * @param other la fecha con la que se compara. 287 * 288 * @return la diferencia (en días) entre esta fecha y la 289 * otra’ fecha especificada. 290 */ 291 public int compare(final serialdate other) { 292 return this.serial – other.toserial(); 293 } 294 295 /** 296 * implementa el método necesario para la interfaz comparable. 297 * 298 * @param other el otro objeto (normalmente otro serialdate). 299 * 300 * @return un entero negativo, cero o un entero positivo si este objeto 301 * es menor que, igual o mayor que el objeto especificado. 491302 */ 303 public int compareto(final object other) { 304 return compare((serialdate) other); 305 } 306 307 /** 308 * devuelve true si esta serialdate representa la misma fecha que la 309 * serialdate especificada. 310 * 311 * @param other la fecha con la que se compara. 312 * 313 * @return <code>true</code> si esta serialdate representa la misma fecha que 314 * la otra serialdate especificada. 315 */ 316 public boolean ison(final serialdate other) { 317 return (this.serial == other.toserial()); 318 } 319 320 /** 321 * devuelve true si esta serialdate representa una fecha anterior a 322 * la serialdate especificada. 323 * 324 * @param other la fecha con la que se compara. 325 * 326 * @return <code>true</code> si esta serialdate representa una fecha anterior a 327 * la serialdate especificada. 328 */ 329 public boolean isbefore(final serialdate other) { 330 return (this.serial < other.toserial()); 331 } 332 333 /** 334 * devuelve true si esta serialdate representa la misma fecha que la 335 * serialdate especificada. 336 * 337 * @param other la fecha con la que se compara. 338 * 339 * @return <code>true</code> si esta serialdate representa la misma fecha 340 * que la serialdate especificada. 341 */ 342 public boolean isonorbefore(final serialdate other) { 343 return (this.serial <= other.toserial()); 344 } 492345 346 /** 347 * devuelve true si esta serialdate representa la misma fecha que la 348 * serialdate especificada. 349 * 350 * @param other la fecha con la que se compara. 351 * 352 * @return <code>true</code> si esta serialdate representa la misma fecha 353 * que la serialdate especificada. 354 */ 355 public boolean isafter(final serialdate other) { 356 return (this.serial > other.toserial()); 357 } 358 359 /** 360 * devuelve true si esta serialdate representa la misma fecha que la 361 * serialdate especificada. 362 * 363 * @param other la fecha con la que se compara. 364 * 365 * @return <code>true</code> si esta serialdate representa la misma fecha 366 * que la serialdate especificada. 367 */ 368 public boolean isonorafter(final serialdate other) { 369 return (this.serial >= other.toserial()); 370 } 371 372 /** 373 * devuelve <code>true</code> si {@link serialdate} se encuentra en el 374 * intervalo especificado (inclusive). el orden de fecha de d1 y d2 no es 375 * importante. 376 * 377 * @param d1 una fecha límite para el rango. 378 * @param d2 la otra fecha límite para el rango. 379 * 380 * @return un valor booleano. 381 */ 382 public boolean isinrange(final serialdate d1, final serialdate d2) { 383 return isinrange(d1, d2, serialdate.include_both); 384 } 385 386 /** 387 * devuelve true si esta serialdate se encuentra en el intervalo 493especificado 388 * (el invocador especifica si los puntos finales se incluyen o no). el orden 389 * de d1 y d2 no es importante. 390 * 391 * @param d1 una fecha límite para el rango. 392 * @param d2 la otra fecha límite para el rango. 393 * @param include un código que controla si la fecha inicial y final 394 * se incluyen en el intervalo. 395 * 396 * @return <code>true</code> si esta serialdate se encuentra en el intervalo 397 * especificado. 398 */ 399 public boolean isinrange(final serialdate d1, final serialdate d2, 400 final int include) { 401 final int s1 = d1.toserial(); 402 final int s2 = d2.toserial(); 403 final int start = math.min(s1, s2); 404 final int end = math.max(s1, s2); 405 406 final int s = toserial(); 407 if (include == serialdate.include_both) { 408 return (s >= start && s <= end); 409 } 410 else if (include == serialdate.include_first) { 411 return (s >= start && s < end); 412 } 413 else if (include == serialdate.include_second) { 414 return (s > start && s <= end); 415 } 416 else { 417 return (s > start && s < end); 418 } 419 } 420 421 /** 422 * calcular el número de serie a partir del día, mes y año. 423 * <p> 424 * 1-ene-1900 = 2. 425 * 426 * @param d el día. 427 * @param m el mes. 428 * @param y el año. 429 * 430 * @return el número de serie a partir del día, mes y año. 494431 */ 432 private int calcserial(final int d, final int m, final int y) { 433 final int yy = ((y - 1900) * 365) + serialdate.leapyearcount(y - 1); 434 int mm = serialdate.aggregate_days_to_end_of_preceding_month[m]; 435 if (m > monthconstants.february) { 436 if (serialdate.isleapyear(y)) { 437 mm = mm + 1; 438 } 439 } 440 final int dd = d; 441 return yy + mm + dd + 1; 442 } 443 444 /** 445 * calcular el día, mes y año a partir del número de serie. 446 */ 447 private void calcdaymonthyear() { 448 449 // obtener el año a partir del número de serie de la fecha 450 final int days = this.serial - serial_lower_bound; 451 // sobrevalorado ya que ignoramos los días bisiestos 452 final int overestimatedyyyy = 1900 + (days / 365); 453 final int leaps = serialdate.leapyearcount(overestimatedyyyy); 454 final int nonleapdays = days - leaps; 455 // subestimado ya que sobrevaloramos los años 456 int underestimatedyyyy = 1900 + (nonleapdays / 365); 457 458 if (underestimatedyyyy == overestimatedyyyy) { 459 this.year = underestimatedyyyy; 460 } 461 else { 462 int ss1 = calcserial(1, 1, underestimatedyyyy); 463 while (ss1 <= this.serial) { 464 underestimatedyyyy = underestimatedyyyy + 1; 465 ss1 = calcserial(1, 1, underestimatedyyyy); 466 } 467 this.year = underestimatedyyyy - 1; 468 } 469 470 final int ss2 = calcserial(1, 1, this.year); 471 472 int[] daystoendofprecedingmonth 473 = aggregate_days_to_end_of_preceding_month; 474 475 if (isleapyear(this.year)) { 495476 daystoendofprecedingmonth 477 = leap_year_aggregate_days_to_end_of_preceding_month; 478 } 479 480 // get the month from the serial date 481 int mm = 1; 482 int sss = ss2 + daystoendofprecedingmonth[mm] - 1; 483 while (sss < this.serial) { 484 mm = mm + 1; 485 sss = ss2 + daystoendofprecedingmonth[mm] - 1; 486 } 487 this.month = mm - 1; 488 489 // el resto es d(+1); 490 this.day = this.serial - ss2 491 - daystoendofprecedingmonth[this.month] + 1; 492 493 } 494 495 } listado b-6 relativedayofweekrule.java 1 /* ============================================================= 2 * jcommon : biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * 7 * información del proyecto: http://www.jfree.org/jcommon/index.html 8 * 9 * esta biblioteca es software gratuito; puede distribuirla y/o modificarla 10 * bajo las condiciones de la licencia pública general gnu publicada por 11 * la free software foundation; ya sea la versión 2.1 de la licencia, u 12 * otra versión posterior (de su elección). 13 * 14 * esta biblioteca se distribuye con la intención de que sea útil, pero 15 * sin garantía alguna, incluida la garantía implícita de comerciabilidad 16 * e idoneidad para un determinado fin. consulte la licencia pública general gnu 17 * si necesita más información al respecto. 18 * 49619 * debería haber recibido una copia de la licencia pública general gnu 20 * junto a esta biblioteca; en caso contrario, contacte con la free software 21 * foundation, inc., 51 franklin street, fifth floor, boston, ma 02110-1301, 22 * ee.uu. 23 * 24 * [java es una marca comercial o marca comercial registrada de sun 25 * microsystems, inc. en estados unidos y otros países.] 26 * 27 * -------------------------- 28 * relativedayofweekrule.java 29 * -------------------------- 30 * (c) copyright 2000-2003, de object refinery limited y colaboradores. 31 * 32 * autor original: david gilbert (por object refinery limited); 33 * colaboradores(s): -; 34 * 35 * $id: relativedayofweekrule.java,v 1.6 2005/11/16 15:58:40 taqua exp $ 36 * 37 * cambios (26-oct-2001) 38 * -------------------------- 39 * 26-oct-2001 : se cambió el paquete por com.jrefinery.date.*; 40 * 03-oct-2002 : se corrigen los errores detectados por checkstyle (dg); 41 * 42 */ 43 44 package org.jfree.date; 45 46 /** 47 * una regla de fechas anuales que devuelve una fecha por cada año en función de 48 * (a) una regla de referencia; (b) un día de la semana y (c) un parámetro de 49 * selección (serialdate.preceding, serialdate.nearest, serialdate.following). 50 * <p> 51 * por ejemplo, el viernes santo se puede especificado ‘el viernes anterior al 52 * domingo de resurrección. 53 * 54 * @author david gilbert 55 */ 56 public class relativedayofweekrule extends annualdaterule { 57 58 /** una referencia a la regla de fechas anuales sobre la que se basa esta regla. */ 59 private annualdaterule subrule; 49760 61 /** 62 * el día de la semana (serialdate.monday, serialdate.tuesday, etc). 63 */ 64 private int dayofweek; 65 66 /** indica que día de la semana (preceding, nearest o following). */ 67 private int relative; 68 69 /** 70 * constructor predeterminado: genera una regla para el lunes siguiente al 1 de enero. 71 */ 72 public relativedayofweekrule() { 73 this(new dayandmonthrule(), serialdate.monday, serialdate.following); 74 } 75 76 /** 77 * constructor estándar: genera una regla en función de la subregla proporcionada. 78 * 79 * @param subrule la regla que determina la fecha de referencia. 80 * @param dayofweek el día de la semana relativo a la fecha de referencia. 81 * @param relative indica “qué” día de la semana (anterior, más próximo 82 * o posterior). 83 */ 84 public relativedayofweekrule(final annualdaterule subrule, 85 final int dayofweek, final int relative) { 86 this.subrule = subrule; 87 this.dayofweek = dayofweek; 88 this.relative = relative; 89 } 90 91 /** 92 * devuelve la subregla (también denominada regla de referencia). 93 * 94 * @return la regla de fechas anuales que determina la fecha de referencia para 95 * esta regla. 96 */ 97 public annualdaterule getsubrule() { 98 return this.subrule; 99 } 100 498101 /** 102 * establece la subregla. 103 * 104 * @param subrule la regla de fechas anuales que determina la fecha de 105 * referencia para esta regla. 106 */ 107 public void setsubrule(final annualdaterule subrule) { 108 this.subrule = subrule; 109 } 110 111 /** 112 * devuelve el día de la semana de esta regla. 113 * 114 * @return el día de la semana de esta regla. 115 */ 116 public int getdayofweek() { 117 return this.dayofweek; 118 } 119 120 /** 121 * establece el día de la semana de esta regla. 122 * 123 * @param dayofweek el día de la semana de (serialdate.monday, 124 * serialdate.tuesday, etc.). 125 */ 126 public void setdayofweek(final int dayofweek) { 127 this.dayofweek = dayofweek; 128 } 129 130 /** 131 * devuelve el atributo ‘relativo’ que determina “qué” 132 * día de la semana nos interesa (serialdate.preceding, 133 * serialdate.nearest o serialdate.following). 134 * 135 * @return el atributo ‘relativo’. 136 */ 137 public int getrelative() { 138 return this.relative; 139 } 140 141 /** 142 * establece el atributo ‘relativo’ (serialdate.preceding, serialdate.nearest, 143 * serialdate.following). 144 * 499145 * @param relative determina “qué” día de la semana se selecciona con esta 146 * regla. 147 */ 148 public void setrelative(final int relative) { 149 this.relative = relative; 150 } 151 152 /** 153 * crea un clon de esta regla. 154 * 155 * @return un clon de esta regla. 156 * 157 * @throws clonenotsupportedexception nunca debe producirse. 158 */ 159 public object clone() throws clonenotsupportedexception { 160 final relativedayofweekrule duplicate 161 = (relativedayofweekrule) super.clone(); 162 duplicate.subrule = (annualdaterule) duplicate.getsubrule().clone(); 163 return duplicate; 164 } 165 166 /** 167 * devuelve la fecha generada por esta regla, para el año especificado. 168 * 169 * @param year el año (1900 &lt;= year &lt;= 9999). 170 * 171 * @return la fecha generada por esta regla para un año concreto (posiblemente 172 * <code>null</code>). 173 */ 174 public serialdate getdate(final int year) { 175 176 // comprobar argumento… 177 if ((year < serialdate.minimum_year_supported) 178 || (year > serialdate.maximum_year_supported)) { 179 throw new illegalargumentexception( 180 “relativedayofweekrule.getdate(): year outside valid range.”); 181 } 182 183 // calcular la fecha… 184 serialdate result = null; 185 final serialdate base = this.subrule.getdate(year); 186 187 if (base != null) { 188 switch (this.relative) { 500189 case(serialdate.preceding): 190 result = serialdate.getpreviousdayofweek(this.dayofweek, 191 base); 192 break; 193 case(serialdate.nearest): 194 result = serialdate.getnearestdayofweek(this.dayofweek, 195 base); 196 break; 197 case(serialdate.following): 198 result = serialdate.getfollowingdayofweek(this.dayofweek, 199 base); 200 break; 201 default: 202 break; 203 } 204 } 205 return result; 206 207 } 208 209 } listado b-7 daydate.java (final) 1 /* ============================================================= 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================= 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. … 36 */ 37 package org.jfree.date; 38 39 import java.io.serializable; 40 import java.util.*; 41 42 /** 43 * una clase abstracta que representa fechas inmutables con una precisión de 44 * un día. la implementación asigna cada fecha a un entero que 45 * representa un número ordinal de días de un origen fijo. 46 * 47 * ¿por qué no usar java.útil.date? lo haremos, cuando tenga sentido. en ocasiones, 50148 * java.util.date puede ser demasiado precisa; representa un instante en el tiempo, 49 * con una precisión de 1/1000 de segundo (y la fecha depende de la 50 * zona horaria). en ocasiones solo querremos representar un día concreto (como el 21 51 * de enero de 2015) sin preocuparnos de la hora del día, la 52 * zona horaria u otros aspectos. para eso hemos definido serialdate. 53 * 54 * usar daydatefactory.makedate para crear una instancia. 55 * 56 * @author david gilbert 57 * @author robert c. martin realizó gran parte de la refactorización. 58 */ 59 60 public abstract class daydate implements comparable, serializable { 61 public abstract int getordinalday(); 62 public abstract int getyear(); 63 public abstract month getmonth(); 64 public abstract int getdayofmonth(); 65 66 protected abstract day getdayofweekforordinalzero(); 67 68 public daydate plusdays(int days) { 69 return daydatefactory.makedate(getordinalday() + days); 70 } 71 72 public daydate plusmonths(int months) { 73 int thismonthasordinal = getmonth().toint() - month.january.toint(); 74 int thismonthandyearasordinal = 12 * getyear() + thismonthasordinal; 75 int resultmonthandyearasordinal = thismonthandyearasordinal + months; 76 int resultyear = resultmonthandyearasordinal / 12; 77 int resultmonthasordinal = resultmonthandyearasordinal % 12 + month.january.toint(); 78 month resultmonth = month.fromint(resultmonthasordinal); 79 int resultday = correctlastdayofmonth(getdayofmonth(), resultmonth, resultyear); 80 return daydatefactory.makedate(resultday, resultmonth, resultyear); 81 } 82 83 public daydate plusyears(int years) { 84 int resultyear = getyear() + years; 85 int resultday = correctlastdayofmonth(getdayofmonth(), getmonth(), resultyear); 86 return daydatefactory.makedate(resultday, getmonth(), resultyear); 87 } 50288 89 private int correctlastdayofmonth(int day, month month, int year) { 90 int lastdayofmonth = dateutil.lastdayofmonth(month, year); 91 if (day > lastdayofmonth) 92 day = lastdayofmonth; 93 return day; 94 } 95 96 public daydate getpreviousdayofweek(day targetdayofweek) { 97 int offsettotarget = targetdayofweek.toint() - getdayofweek().toint(); 98 if (offsettotarget >= 0) 99 offsettotarget -= 7; 100 return plusdays(offsettotarget); 101 } 102 103 public daydate getfollowingdayofweek(day targetdayofweek) { 104 int offsettotarget = targetdayofweek.toint() - getdayofweek().toint(); 105 if (offsettotarget <= 0) 106 offsettotarget += 7; 107 return plusdays(offsettotarget); 108 } 109 110 public daydate getnearestdayofweek(day targetdayofweek) { 111 int offsettothisweekstarget = targetdayofweek.toint() - getdayofweek().toint(); 112 int offsettofuturetarget = (offsettothisweekstarget + 7) % 7; 113 int offsettoprevioustarget = offsettofuturetarget - 7; 114 115 if (offsettofuturetarget > 3) 116 return plusdays(offsettoprevioustarget); 117 else 118 return plusdays(offsettofuturetarget); 119 } 120 121 public daydate getendofmonth() { 122 month month = getmonth(); 123 int year = getyear(); 124 int lastday = dateutil.lastdayofmonth(month, year); 125 return daydatefactory.makedate(lastday, month, year); 126 } 127 128 public date todate() { 129 final calendar calendar = calendar.getinstance(); 130 int ordinalmonth = getmonth().toint() - month.january.toint(); 503131 calendar.set(getyear(), ordinalmonth, getdayofmonth(), 0, 0, 0); 132 return calendar.gettime(); 133 } 134 135 public string tostring() { 136 return string.format(“%02d-%s-%d”, getdayofmonth(), getmonth(), getyear()); 137 } 138 139 public day getdayofweek() { 140 day startingday = getdayofweekforordinalzero(); 141 int startingoffset = startingday.toint() - day.sunday.toint(); 142 int ordinalofdayofweek = (getordinalday() + startingoffset) % 7; 143 return day.fromint(ordinalofdayofweek + day.sunday.toint()); 144 } 145 146 public int dayssince(daydate date) { 147 return getordinalday() - date.getordinalday(); 148 } 149 150 public boolean ison(daydate other) { 151 return getordinalday() == other.getordinalday(); 152 } 153 154 public boolean isbefore(daydate other) { 155 return getordinalday() < other.getordinalday(); 156 } 157 158 public boolean isonorbefore(daydate other) { 159 return getordinalday() <= other.getordinalday(); 160 } 161 162 public boolean isafter(daydate other) { 163 return getordinalday() > other.getordinalday(); 164 } 165 166 public boolean isonorafter(daydate other) { 167 return getordinalday() >= other.getordinalday(); 168 } 169 170 public boolean isinrange(daydate d1, daydate d2) { 171 return isinrange(d1, d2, dateinterval.closed); 172 } 173 174 public boolean isinrange(daydate d1, daydate d2, dateinterval interval) { 504175 int left = math.min(d1.getordinalday(), d2.getordinalday()); 176 int right = math.max(d1.getordinalday(), d2.getordinalday()); 177 return interval.isin(getordinalday(), left, right); 178 } 179 } listado b-8 month.java (final) 1 package org.jfree.date; 2 3 import java.text.dateformatsymbols; 4 5 public enum month { 6 january(1), february(2), march(3), 7 april(4), may(5), june(6), 8 july(7), august(8), september(9), 9 october(10),november(11),december(12); 10 private static dateformatsymbols dateformatsymbols = new dateformatsymbols(); 11 private static final int[] last_day_of_month = 12 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 13 14 private int index; 15 16 month(int index) { 17 this.index = index; 18 } 19 20 public static month fromint(int monthindex) { 21 for (month m : month.values()) { 22 if (m.index == monthindex) 23 return m; 24 } 25 throw new illegalargumentexception(“invalid month index ” + monthindex); 26 } 27 28 public int lastday() { 29 return last_day_of_month[index]; 30 } 31 32 public int quarter() { 33 return 1 + (index - 1) / 3; 50534 } 35 36 public string tostring() { 37 return dateformatsymbols.getmonths()[index - 1]; 38 } 39 40 public string toshortstring() { 41 return dateformatsymbols.getshortmonths()[index - 1]; 42 } 43 44 public static month parse(string s) { 45 s = s.trim(); 46 for (month m : month.values()) 47 if (m.matches(s)) 48 return m; 49 50 try { 51 return fromint(integer.parseint(s)); 52 } 53 catch (numberformatexception e) {} 54 throw new illegalargumentexception(“invalid month ” + s); 55 } 56 57 private boolean matches(string s) { 58 return s.equalsignorecase(tostring()) || 59 s.equalsignorecase(toshortstring()); 60 } 61 62 public int toint() { 63 return index; 64 } 65 } listado b-9 day.java (final) 1 package org.jfree.date; 2 3 import java.util.calendar; 4 import java.text.dateformatsymbols; 5 6 public enum day { 7 monday(calendar.monday), 8 tuesday(calendar.tuesday), 5069 wednesday(calendar.wednesday), 10 thursday(calendar.thursday), 11 friday(calendar.friday), 12 saturday(calendar.saturday), 13 sunday(calendar.sunday); 14 15 private final int index; 16 private static dateformatsymbols datesymbols = new dateformatsymbols(); 17 18 day(int day) { 19 index = day; 20 } 21 22 public static day fromint(int index) throws illegalargumentexception { 23 for (day d : day.values()) 24 if (d.index == index) 25 return d; 26 throw new illegalargumentexception( 27 string.format(“illegal day index: %d.”, index)); 28 } 29 30 public static day parse(string s) throws illegalargumentexception { 31 string[] shortweekdaynames = 32 datesymbols.getshortweekdays(); 33 string[] weekdaynames = 34 datesymbols.getweekdays(); 35 36 s = s.trim(); 37 for (day day : day.values()) { 38 if (s.equalsignorecase(shortweekdaynames[day.index]) || 39 s.equalsignorecase(weekdaynames[day.index])) { 40 return day; 41 } 42 } 43 throw new illegalargumentexception( 44 string.format(“%s is not a valid weekday string”, s)); 45 } 46 47 public string tostring() { 48 return datesymbols.getweekdays()[index]; 49 } 50 51 public int toint() { 52 return index; 53 } 50754 } listado b-10 dateinterval.java (final) 1 package org.jfree.date; 2 3 public enum dateinterval { 4 open { 5 public boolean isin(int d, int left, int right) { 6 return d > left && d < right; 7 } 8 }, 9 closed_left { 10 public boolean isin(int d, int left, int right) { 11 return d >= left && d < right; 12 } 13 }, 14 closed_right { 15 public boolean isin(int d, int left, int right) { 16 return d > left && d <= right; 17 } 18 }, 19 closed { 20 public boolean isin(int d, int left, int right) { 21 return d >= left && d <= right; 22 } 23 }; 24 25 public abstract boolean isin(int d, int left, int right); 26 } listado b-11 weekinmonth.java (final) 1 package org.jfree.date; 2 3 public enum weekinmonth { 4 first(1), second(2), third(3), fourth(4), last(0); 5 private final int index; 6 7 weekinmonth(int index) { 8 this.index = index; 5089 } 10 11 public int toint() { 12 return index; 13 } 14 } listado b-12 weekdayrange.java (final) 1 package org.jfree.date; 2 3 public enum weekdayrange { 4 last, nearest, next 5 } listado b-13 dateutil.java (final) 1 package org.jfree.date; 2 3 import java.text.dateformatsymbols; 4 5 public class dateutil { 6 private static dateformatsymbols dateformatsymbols = new dateformatsymbols(); 7 8 public static string[] getmonthnames() { 9 return dateformatsymbols.getmonths(); 10 } 11 12 public static boolean isleapyear(int year) { 13 boolean fourth = year % 4 == 0; 14 boolean hundredth = year % 100 == 0; 15 boolean fourhundredth = year % 400 == 0; 16 return fourth && (!hundredth || fourhundredth); 17 } 18 19 public static int lastdayofmonth(month month, int year) { 20 if (month == month.february && isleapyear(year)) 21 return month.lastday() + 1; 22 else 23 return month.lastday(); 50924 } 25 26 public static int leapyearcount(int year) { 27 int leap4 = (year - 1896) / 4; 28 int leap100 = (year - 1800) / 100; 29 int leap400 = (year - 1600) / 400; 30 return leap4 - leap100 + leap400; 31 } 32 } listado b-14 daydatefactory.java (final) 1 package org.jfree.date; 2 3 public abstract class daydatefactory { 4 private static daydatefactory factory = new spreadsheetdatefactory(); 5 public static void setinstance(daydatefactory factory) { 6 daydatefactory.factory = factory; 7 } 8 9 protected abstract daydate _makedate(int ordinal); 10 protected abstract daydate _makedate(int day, month month, int year); 11 protected abstract daydate _makedate(int day, int month, int year); 12 protected abstract daydate _makedate(java.util.date date); 13 protected abstract int _getminimumyear(); 14 protected abstract int _getmaximumyear(); 15 16 public static daydate makedate(int ordinal) { 17 return factory._makedate(ordinal); 18 } 19 20 public static daydate makedate(int day, month month, int year) { 21 return factory._makedate(day, month, year); 22 } 23 24 public static daydate makedate(int day, int month, int year) { 25 return factory._makedate(day, month, year); 26 } 27 28 public static daydate makedate(java.util.date date) { 29 return factory._makedate(date); 30 } 51031 32 public static int getminimumyear() { 33 return factory._getminimumyear(); 34 } 35 36 public static int getmaximumyear() { 37 return factory._getmaximumyear(); 38 } 39 } listado b-15 spreadsheetdatefactory.java (final) 1 package org.jfree.date; 2 3 import java.util.*; 4 5 public class spreadsheetdatefactory extends daydatefactory { 6 public daydate _makedate(int ordinal) { 7 return new spreadsheetdate(ordinal); 8 } 9 10 public daydate _makedate(int day, month month, int year) { 11 return new spreadsheetdate(day, month, year); 12 } 13 14 public daydate _makedate(int day, int month, int year) { 15 return new spreadsheetdate(day, month, year); 16 } 17 18 public daydate _makedate(date date) { 19 final gregoriancalendar calendar = new gregoriancalendar(); 20 calendar.settime(date); 21 return new spreadsheetdate( 22 calendar.get(calendar.date), 23 month.fromint(calendar.get(calendar.month) + 1), 24 calendar.get(calendar.year)); 25 } 26 27 protected int _getminimumyear() { 28 return spreadsheetdate.minimum_year_supported; 29 } 30 31 protected int _getmaximumyear() { 51132 return spreadsheetdate.maximum_year_supported; 33 } 34 } listado b-16 spreadsheetdate.java (final) 1 /* ============================================================== 2 * jcommon: biblioteca gratuita de clases de propósito general para java(tm) 3 * ============================================================== 4 * 5 * (c) copyright 2000-2005, de object refinery limited y colaboradores. 6 * … 52 * 53 */ 54 55 package org.jfree.date; 56 57 import static org.jfree.date.month.february; 58 59 import java.util.*; 60 61 /** 62 * representa una fecha con un entero, de forma similar a la 63 * implementación en microsoft excel. el intervalo de fechas admitido es 64 * del 1-ene-1900 al 31-dic-9999. 65 * <p/> 66 * recuerde que excel tiene un error que reconoce el año 67 * 1900 como bisiesto cuando en realidad no lo es. encontrará más 68 * información en el sitio de microsoft, en el artículo q181370: 69 * <p/> 70 * http://support.microsoft.com/support/kb/articles/q181/3/70.asp 71 * <p/> 72 * excel usa como convención que el 1-ene-1900 = 1. esta clase usa la 73 * convención de que el 1-ene-1900 = 2. 74 * como resultado, el número de día de esta clase será diferente al de 75 * excel para enero y febrero de 1900… pero excel añade un día 76 * más (29-feb-1900 que en realidad no existe) y a partir de ahí 77 * los números de los días coinciden. 78 * 79 * @author david gilbert 80 */ 81 public class spreadsheetdate extends daydate { 51282 public static final int earliest_date_ordinal = 2; // 1/1/1900 83 public static final int latest_date_ordinal = 2958465; // 12/31/9999 84 public static final int minimum_year_supported = 1900; 85 public static final int maximum_year_supported = 9999; 86 static final int[] aggregate_days_to_end_of_preceding_month = 87 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 88 static final int[] leap_year_aggregate_days_to_end_of_preceding_month = 89 {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 90 91 private int ordinalday; 92 private int day; 93 private month month; 94 private int year; 95 96 public spreadsheetdate(int day, month month, int year) { 97 if (year < minimum_year_supported || year > maximum_year_supported) 98 throw new illegalargumentexception( 99 “the ‘year’ argument must be in range ” + 100 minimum_year_supported + “ to ” + maximum_year_supported + “.”); 101 if (day < 1 || day > dateutil.lastdayofmonth(month, year)) 102 throw new illegalargumentexception(“invalid ‘day’ argument.”); 103 104 this.year = year; 105 this.month = month; 106 this.day = day; 107 ordinalday = calcordinal(day, month, year); 108 } 109 110 public spreadsheetdate(int day, int month, int year) { 111 this(day, month.fromint(month), year); 112 } 113 114 public spreadsheetdate(int serial) { 115 if (serial < earliest_date_ordinal || serial > latest_date_ordinal) 116 throw new illegalargumentexception( 117 “spreadsheetdate: serial must be in range 2 to 2958465.”); 118 119 ordinalday = serial; 120 calcdaymonthyear(); 121 } 122 123 public int getordinalday() { 124 return ordinalday; 125 } 513126 127 public int getyear() { 128 return year; 129 } 130 131 public month getmonth() { 132 return month; 133 } 134 135 public int getdayofmonth() { 136 return day; 137 } 138 139 protected day getdayofweekforordinalzero() {return day.saturday;} 140 141 public boolean equals(object object) { 142 if (!(object instanceof daydate)) 143 return false; 144 145 daydate date = (daydate) object; 146 return date.getordinalday() == getordinalday(); 147 } 148 149 public int hashcode() { 150 return getordinalday(); 151 } 152 153 public int compareto(object other) { 154 return dayssince((daydate) other); 155 } 156 157 private int calcordinal(int day, month month, int year) { 158 int leapdaysforyear = dateutil.leapyearcount(year - 1); 159 int daysuptoyear = (year - minimum_year_supported) * 365 + leapdaysforyear; 160 int daysuptomonth = aggregate_days_to_end_of_preceding_month[month.toint()]; 161 if (dateutil.isleapyear(year) && month.toint() > february.toint()) 162 daysuptomonth++; 163 int daysinmonth = day - 1; 164 return daysuptoyear + daysuptomonth + daysinmonth + earliest_date_ordinal; 165 } 166 167 private void calcdaymonthyear() { 168 int days = ordinalday - earliest_date_ordinal; 514169 int overestimatedyear = minimum_year_supported + days / 365; 170 int nonleapdays = days - dateutil.leapyearcount(overestimatedyear); 171 int underestimatedyear = minimum_year_supported + nonleapdays / 365; 172 173 year = huntforyearcontaining(ordinalday, underestimatedyear); 174 int firstordinalofyear = firstordinalofyear(year); 175 month = huntformonthcontaining(ordinalday, firstordinalofyear); 176 day = ordinalday - firstordinalofyear - daysbeforethismonth(month.toint()); 177 } 178 179 private month huntformonthcontaining(int anordinal, int firstordinalofyear) { 180 int daysintothisyear = anordinal - firstordinalofyear; 181 int amonth = 1; 182 while (daysbeforethismonth(amonth) < daysintothisyear) 183 amonth++; 184 185 return month.fromint(amonth - 1); 186 } 187 188 private int daysbeforethismonth(int amonth) { 189 if (dateutil.isleapyear(year)) 190 return leap_year_aggregate_days_to_end_of_preceding_month[amonth] - 1; 191 else 192 return aggregate_days_to_end_of_preceding_month[amonth] - 1; 193 } 194 195 private int huntforyearcontaining(int anordinalday, int startingyear) { 196 int ayear = startingyear; 197 while (firstordinalofyear(ayear) <= anordinalday) 198 ayear++; 199 200 return ayear - 1; 201 } 202 203 private int firstordinalofyear(int year) { 204 return calcordinal(1, month.january, year); 205 } 206 207 public static daydate createinstance(date date) { 208 gregoriancalendar calendar = new gregoriancalendar(); 209 calendar.settime(date); 210 return new spreadsheetdate(calendar.get(calendar.date), 515211 month.fromint(calendar.get(calendar.month) + 1), 212 calendar.get(calendar.year)); 213 214 } 215 } 516epílogo en 2005, mientras asistía a la conferencia agile en denver (ee.uu.), elisabeth hedrickson [125] me dio una pulsera verde parecida a la que lance armstrong popularizó hace unos años. en ésta se leía test obsessed (obsesionado por las pruebas). me la puse y la lucí con orgullo. desde que aprendí el tdd de kent beck en 1999, sin duda el desarrollo controlado por pruebas me ha obsesionado. pero sucedió algo extraño. no me podía quitar la pulsera. no porque se hubiera quedado físicamente pegada, sino porque estaba moralmente pegada. la pulsera resumía mi ética profesional. era un indicador visible de mi compromiso por crear el mejor código posible. si me la hubiera quitado habría traicionado a esa ética y a ese compromiso. y todavía la llevo en la muñeca. cuando escribo código, la veo ahí. es un recordatorio constante de la promesa que me hice de escribir código limpio. 517robert cecil “uncle bob” martin (palo alto california, estados unidos, 1952). es un prestigioso desarrollador de software desde 1970 y consultor internacional desde 1990. es fundador y presidente de object mentor, inc., un equipo de experimentados consultores que ayudan a clientes de todo el mundo en diferentes campos de la programación como c++, java, c#, ruby, programación orientada a objetos (poo), patrones de diseño, uml, metodologías ágiles y programación extreme. 518notas 519[1] [beck07]. << 520[2] cuando ignaz semmelweis recomendó en 1847 que los médicos se lavaran las manos, su propuesta fue rechazada aludiendo que los doctores estaban demasiado ocupados para hacerlo entre paciente y paciente. << 521[3] http://www.pragmaticprogrammer.com/booksellers/2004-12.html. << 522[4] [knuth92]. << 523[5] es una adaptación del mensaje de despedida de robert stephenson smyth baden-powell a los scouts: «intentad dejar este mundo un poco mejor de como os lo encontrasteis…». << 524[6] como veremos más adelante, aunque un contenedor sea una lista , no conviene codificar el tipo de contenedor en el nombre. << 525[7] imagine que se crea una variable con el nombre klass sólo porque el nombre class se ha usado en otro elemento. << 526[8] uncle bob solía hacerlo en c++ pero ha abandonado esta práctica ya que no es necesario en los ide modernos. << 527[9] http://java.sun.com/products/javabeans/docs/spec.html. << 528[10] una herramienta de pruebas de código abierto (www.fitnese.org). << 529[11] una herramienta de código abierto para probar unidades para java ( www.junit.org ). << 530[12] le pregunté a kent si todavía conservaba una copia, pero no la encontró. busqué en mis viejos ordenadores, pero nada. solamente se conserva el recuerdo de aquél programa. << 531[13] el lenguaje logo usaba la palabra clave to al igual que ruby y python usaban def . por tanto, todas las funciones comenzaban por to , lo que tenía un efecto interesante en cómo se diseñaban. << 532[14] [kp78], p. 37. << 533[15] y, por supuesto, se incluyen cadenas if/else. << 534[16] a. http://en.wikipedia.org/wiki/single_responsibility_principle b. http://www.objectmentor.com/resources/articles/srp.pdf << 535[17] a. http://en.wikipedia.org/wiki/open/closed_principle b. http://www.objectmentor.com/resources/articles/ocp.pdf << 536[18] [gof]. << 537[19] terminé la refactorización de un módulo que usaba la forma dinámica. conseguí convertir el módulo outputstream en un campo de la clase y las invocaciones de writefield a formato monódico. el resultado fue mucho más limpio. << 538[20] existen algunos que creen que pueden evitar volver a compilar e implementar, y nos hemos encargado de ellos. << 539[21] ejemplo de principio abierto/cerrado (ocp) [ppp02]. << 540[22] el principio dry. [prag]. << 541[23] [sp72]. << 542[24] [kp78], p. 144. << 543[25] la tendencia actual de los ide de comprobar la ortografía de los comentarios será un bálsamo para los que tenemos que leer gran cantidad de código. << 544[26] el cuadro muestra sigma/2 por encima y debajo de la media. asumo que la distribución de la longitud de archivos no es normal, por lo que la desviación estándar no es matemáticamente precisa. pero aquí el objetivo no es la precisión, sino la sensación. << 545[27] es lo contrario a lo que sucede en lenguajes como pascal, c y c++ que obligan a definir, o al menos a declarar, las funciones antes de usarlas. << 546[28] ¿a quien voy a engañar? sigo siendo programador de lenguajes de ensamblado. en este caso, el hábito sí hace al monje. << 547[29] siempre existe una solución conocida por los diseñadores orientados a objetos con experiencia: visitor o entrega dual, por ejemplo. pero son técnicas costosas y suelen devolver la estructura de un programa por procedimientos. << 548[30] http://es.wikipedia.org/wiki/ley_de_demeter. << 549[31] de la estructura apache. << 550[32] en ocasiones se denomina feature envy (envidia de las características), de [refactoring]. << 551[33] [martin]. << 552[34] [becktdd], pp. 136-137. << 553[35] véase el patrón del adaptador en [gof]. << 554[36] más información al respecto en [welc]. << 555[37]  professionalism and test-driven development , robert c. martin, object mentor, ieee software, mayo/junio 2007 (vol. 24, no. 3) pp. 32-36 http://doi.ieeecomputersociety.org/10.1109/ms.2007.85 << 556[38] http://fitnesse.org/fitnesse.acceptancetestpatterns. << 557[39] véase el apartado sobre asignaciones mentales del capítulo 2. << 558[40] véase la entrada de dave astel: http://www.artima.com/weblogs/viewpost.jsp?thread=35578 << 559[41] [rspec]. << 560[42] [gof]. << 561[43] ¡cíñase al código! << 562[44] materiales de formación de object mentor. << 563[45] [rdd]. << 564[46] encontrará más información sobre este principio en [ppp]. << 565[47] [knuth92]. << 566[48] [ppp]. << 567[49] [ppp]. << 568[50] [mezzaros07]. << 569[51] [gof]. << 570[52] véase, por ejemplo, [fowler]. << 571[53] véase [spring], también existe una estructura spring.net. << 572[54] no olvide que la creación de instancias/evaluación tardía es sólo una optimización, puede que prematura. << 573[55] sistema de administración de base de datos. << 574[56] consulte [aosd] si necesita información general sobre aspectos y [aspectj] y [colyer] para información concreta de aspectj. << 575[57] no se necesita la modificación manual del código fuente de destino. << 576[58] véase [cglib], [asm] y [javassist]. << 577[59] si necesita ejemplos más detallados de la api proxy y ejemplos de uso, consulte [goetz]. << 578[60] aop se suele confundir con técnicas empleadas para implementarlo, como la intercepción y envoltorio de métodos a través de proxies . el verdadero valor de un sistema aop es la capacidad para especificar comportamientos del sistema de forma concisa y modular. << 579[61] véase [spring] y [jboss]. java puro significa sin aspectj. << 580[62] adaptado de www.theserverside.com/tt/articles/article.tss? l=introtospring25. << 581[63] [gof]. << 582[64] el ejemplo se puede simplificar mediante mecanismos que usen convenciones y anotaciones de java 5 para reducir la cantidad necesaria de lógica de conexión explícita. << 583[65] adaptado de http://www.onjava.com/pub/a/onjava/2006/05/17/standardizing-with-ejb3- java-persistence-api.html. << 584[66] véase [aspectj] y [colyer]. << 585[67] no confundir con la práctica de diseño anticipado. bduf es la práctica de diseñar todo por adelantado antes de implementar nada. << 586[68] existe una cantidad significativa de exploración iterativa y detalles de análisis, incluso una vez iniciada la construcción. << 587[69] el término fue empleado por primera vez por [kolence]. << 588[70] el trabajo de [alexander] ha sido una gran influencia para la comunidad de software . << 589[71] véase, por ejemplo, [dsl]. [jmock] es un buen ejemplo de api de java que crea un dsl. << 590[72] [xpe]. << 591[73] [gof]. << 592[74] correspondencia privada. << 593[75] rayos cósmicos, repeticiones, etc. << 594[76] véase el apéndice a. << 595[77] véase el apéndice a. << 596[78] [ppp]. << 597[79] véase el apéndice a. << 598[80] [prag]. << 599[81] [lea99]. << 600[82] http://en.wikipedia.org/wiki/producer-consumer. << 601[83] http://en.wikipedia.org/wiki/readers-writers_problem. << 602[84] http://es.wikipedia.org/wiki/problema_de_la_cena_de_los_filósofos. << 603[85] véase el apéndice a. << 604[86] una sección crítica es cualquier sección de código que debe protegerse de usos simultáneos por parte del programa para que sea correcta. << 605[87] véase el apéndice a. << 606[88] véase el apéndice a. << 607[89] ¿sabía que el modelo de procesos de java no garantiza el procesamiento preventivo? los so modernos sí lo hacen, de modo que lo obtiene de forma gratuita. no obstante, la mvj no lo garantiza. << 608[90] no es estrictamente el caso. como la mvj no garantiza los procesos preventivos, un determinado algoritmo puede que siempre funcione en un so que no prevea los procesos. lo contrario también es posible, pero por distintos motivos. << 609[91] https://www.ibm.com/developerworks/community/groups/service/html/communityview? lang=es&communityuuid=18d10b14-e2c8-4780-bace-9af1fc463cc0. << 610[92] hace poco modifiqué este módulo para ruby. tenía una séptima parte del tamaño original y una mejor estructura. << 611[93] para evitar este tipo de sorpresas, añadí una nueva prueba de unidad que invocaba todas las pruebas de fitnesse. << 612[94]  junit pocket guide , kent beck, o’reilly. 2004. p. 43. << 613[95] véase el capítulo 1. << 614[96] una solución mejor sería que el javadoc presentara todos los comentarios con formato previo, para que tengan el mismo aspecto en el código y en el documento. << 615[97] algunos revisores de este texto no comparten esta decisión. sostienen que en una estructura de código abierto es más recomendable ejercer control manual sobre el id de serie para que los cambios mínimos del software no invaliden las fechas señalizadas antiguas. me parece justo. sin embargo, al menos el fallo, aunque sea inconveniente, tiene un motivo evidente. por otra parte, si el autor de la clase se olvida de actualizar el id, el modo de fallo será indefinido y puede que silencioso. creo que la moraleja es que no debe esperar a deserializar entre versiones. << 616[98] [gof]. << 617[99] ibid. << 618[100] ibid. << 619[101] [simmons04], p. 73. << 620[102] [refactoring]. << 621[103] [beck97]. << 622[104] [refactoring]. << 623[105] http://es.wikipedia.org/wiki/principio_de_la_mínima_sorpresa << 624[106] [prag]. << 625[107] [gof]. << 626[108] [gof]. << 627[109] [refactoring]. << 628[110] en concreto, el principio de responsabilidad única, el principio abierto/cerrado y el principio de cierre común. véase [ppp]. << 629[111] [beck97], p. 108. << 630[112] [beck07]. << 631[113] es distinto saber cómo funciona el código y saber si el algoritmo se encargará de realizar la tarea para la que se necesita. es habitual desconocer si un algoritmo es el adecuado. desconocer lo que hace el código es indolencia. << 632[114] o mejor todavía, una clase money que use enteros. << 633[115] [prag]. p. 138. << 634[116] véase la cita de ward cunningham del capítulo 1. << 635[117] [ddd]. << 636[118] puede comprobar personalmente el código antes y después, y revisar las versiones con y sin subprocesos, que veremos en un apartado posterior. << 637[119] es una comparación simplificada, pero para los objetivos de este ejercicio es un modelo válido. << 638[120] de hecho, la interfaz iterator es incompatible con subprocesos por naturaleza. no se diseñó para usar varios subprocesos, de modo que no debería sorprenderle. << 639[121] por ejemplo, alguien añade un resultado de depuración y el problema desaparece. el código de depuración corrige el problema, pero permanece en el sistema. << 640[122] siglas de there ain’t no such thing as a free lunch (todo tiene un precio). << 641[123] http://www.haifa.ibm.com/projects/verification/contest/index.html << 642[124] véase [lea99] p. 191. << 643[125] http://www.qualitytree.com/ << 644