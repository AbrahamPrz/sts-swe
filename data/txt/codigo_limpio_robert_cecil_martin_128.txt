implementan un nivel a la derecha de su bloque contenedor y así sucesivamente. los programadores dependen de este sistema de sangrado. alinean visualmente las líneas a la izquierda para ver el ámbito al que pertenece. de este modo pueden acceder rápidamente a los ámbitos, como por ejemplo a implementaciones de instrucciones if o while , que no son relevantes para la situación actual. buscan en la izquierda nuevas declaraciones de métodos, variables e incluso clases. sin el sangrado, los programas serian prácticamente ilegibles. fíjese en los siguientes programas, sintáctica y semánticamente idénticos: public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket s) { serve(s, 10000); } public void serve(socket s, long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(s, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch(exception e) { e.printstacktrace(); } } } public class fitnesseserver implements socketserver { private fitnessecontext context; public fitnesseserver(fitnessecontext context) { this.context = context; } public void serve(socket s) { serve (s, 10000); } public void serve(socket s, long requesttimeout) { try { fitnesseexpediter sender = new fitnesseexpediter(s, context); sender.setrequestparsingtimelimit(requesttimeout); sender.start(); } catch (exception e) { e.printstacktrace(); } } } a la vista puede incluso apreciar la estructura del archivo sangrado. detectamos inmediatamente las variables, constructores y métodos de acceso. en cuestión de segundos vemos que es una especie de interfaz de conexión, 129