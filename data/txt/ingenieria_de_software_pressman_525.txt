494 PARTE TRES  ADMINISTRACIÓN DE LA CALIDAD OCL proporciona operaciones internas que implementan operadores de conjunto y lógicos,  especificación constructiva y matemáticas relacionadas. En la tabla 21.1 se presenta una pe-queña muestra de aquéllas. Para ilustrar el uso de OCL en especificación, se reexamina el ejemplo de manipulador de  bloques, que se introdujo en la sección 21.5. El primer paso es desarrollar un modelo UML (figura 21.9). Este diagrama de clase especifica muchas relaciones entre los objetos involucrados. Sin embargo, las expresiones OCL se agregan para que los implementadores del sistema puedan conocer con más precisión que debe permanecer verdadero conforme corre el sistema. Las expresiones OCL que complementan el diagrama de clase corresponden a las seis partes  de la invariante que se estudió en la sección 21.5. En el ejemplo que sigue, la invariante se repite en castellano y luego se escribe la correspondiente expresión OCL. Se considera buena práctica proporcionar texto en lenguaje natural junto con la lógica formal; hacerlo así ayuda a entender la lógica, y también ayuda a los revisores a descubrir errores, por ejemplo, situaciones donde el lenguaje natural y la lógica no corresponden.  1. Ningún bloque se mar  cará como no utilizado y usado al mismo tiempo. context BlockHandler inv: (self.used2.intersection(self.free)) 2.isEmpty()   Observe que cada expresión comienza con la palabra clave context. Esto indica el ele- mento del diagrama UML que restringe la expresión. De manera alternativa, podría co-locar la restricción directamente en el diagrama UML, encerrada entre llaves. Aquí la palabra clave self se refiere a la instancia de BlockHandler; en lo que sigue, como es per- misible en OCL, se omitirá el self.  2. T odos los conjuntos de bloques que se conservan en la fila serán subconjuntos de la colec- ción de los bloques actualmente utilizados. context BlockHandler inv: blockQueue2.forAll(aBlockSet | used2.includesAll(aBlockSet ))  3. Ningún elemento de la fila contendr á el mismo número de bloque. context BlockHandler inv: blockQueue2.forAll(blockSet1, blockSet2 | blockSet1 ,. blockSet2 impliesblockSet1.elements.number2.excludesAll(blockSet2elements.number))1 1Número BlockSet BlockHandler* ** * *1 1 1blockQueue {ordenado} free allBlocks {subconjuto}{subconjuto}usedelementos addBlock( )removeBlock( )bloqueFIGURA 21.9 Diagrama de  clase para un manipulador de bloques 21Pressman(478-500).indd   49421Pressman(478-500).indd   494 19/1/10   12:43:2819/1/10   12:43:28