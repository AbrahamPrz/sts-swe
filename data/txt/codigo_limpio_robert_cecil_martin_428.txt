23: thread t2 = new thread(runnable); 24: t1.start(); 25: t2.start(); 26: t1.join(); 27: t2.join(); 28: 29: int endingid = classwiththreadingproblem.lastid; 30: 31: if (endingid != expectedresult) 32: return; 33: } 34: 35: fail(“should have exposed a threading issue but it did not.”); 36: } 37: } línea descripción 10 crear una sola instancia de classwiththreadingproblem . debemos usar la palabra clave final ya que se usa después en una clase interna anónima. 12-16 crear una clase interna anónima que use la instancia de classwiththreadingproblem . 18 ejecutar este código hasta demostrar que falla, pero no tanto como para que la prueba tarde demasiado. es un acto de equilibrio; no queremos esperar demasiado para demostrar el fallo. elegir la cantidad de ejecuciones es complicado, aunque como veremos después, esta cifra se puede reducir considerablemente. 19 recordar el valor inicial, la prueba intenta demostrar que el código de classwiththreadingproblem es incorrecto. si se supera la prueba, lo habrá demostrado. si la prueba falla, habrá sido incapaz de demostrarlo. 20 esperamos que el valor final sea dos más que el actual. 22-23 crear dos subprocesos que usen el objeto creado en las líneas 12-16. de este modo contamos con dos posibles subprocesos que intentan usar nuestra instancia de classwiththreadingproblem y ambos interfieren entre sí. 24-25 hacer que los dos subprocesos se puedan ejecutar. 429