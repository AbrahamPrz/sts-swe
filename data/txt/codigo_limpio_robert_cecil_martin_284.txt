excepción, pero el resultado es más indicado ya que el concepto de numberformatexception se oculta totalmente en integerargumentmarshaler . private boolean isintarg(char argchar) { return intargs.containskey(argchar); } private void setintarg(char argchar) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; intargs.get(argchar). set (parameter); } catch (arrayindexoutofboundsexception e) { valid = false; errorargumentid = argchar; errorcode = errorcode.missing_integer; throw new argsexception(); } catch ( argsexception e) { valid = false; errorargumentid = argchar; errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e ; } } … private void setbooleanarg(char argchar) { try { booleanargs.get(argchar).set(“true”); } catch (argsexception e) { } } … public int getint(char arg) { args.argumentmarshaler am = intargs.get(arg); return am == null ? 0 : (integer) am. get (); } … private abstract class argumentmarshaler { public abstract void set(string s) throws argsexception; public abstract object get(); } … private class integerargumentmarshaler extends argumentmarshaler { private int intvalue = 0; public void set(string s) throws argsexception { try { intvalue = integer.parseint(s); } catch (numberformatexception s) { throw new argsexception(); } 285