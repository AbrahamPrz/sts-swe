CAPÍTULO 29  MANTENIMIENTO Y REINGENIERÍA 663 Cada una de estas opciones es viable. Su organización de software debe elegir aquella que sea  más adecuada para cada caso. Ingeniería inversa. El término ingeniería in versa tiene su origen en el mundo del hardware. Una  compañía desensambla un producto de hardware de otra empresa con la intención de entender  los “secretos” de diseño y fabricación de su competidor. Dichos secretos podrían entenderse fácilmente si se obtuvieran las especificaciones de diseño y fabricación. Pero esos documentos son propiedad de la empresa competidora y no están disponibles para la compañía que hace la ingeniería inversa. En esencia, la ingeniería inversa exitosa deriva en una o más especificacio-nes de diseño y fabricación para un producto al examinar especímenes reales del mismo. La ingeniería inversa para el software es muy similar. No obstante, en la mayoría de los casos,  el programa que se va a someter a ingeniería inversa no es de un competidor: es el propio tra-bajo de la compañía (con frecuencia, elaborado muchos años atrás). Los “secretos” por entender son oscuros porque jamás se desarrollaron especificaciones. Por tanto, la ingeniería inversa para software es el proceso de analizar un programa con la intención de crear una representa-ción del mismo en un nivel superior de abstracción que el código fuente. La ingeniería inversa es un proceso de recuperación de diseño. Las herramientas de ingeniería inversa extraen infor- mación de diseño de datos, arquitectónico y procedimental de un programa existente. Reestructuración de código. El tipo más común de reingeniería (en realidad, en este caso  es cuestionable el uso del término reingeniería) es la reestructur ación de código.4 Algunos siste- mas heredados tienen una arquitectura de programa relativamente sólida, pero los módulos individuales fueron codificados en una forma que los hace difíciles de entender, poner a prueba y mantener. En tales casos, el código dentro de los módulos sospechosos puede reestructu-rarse. Para realizar esta actividad se analiza el código fuente con una herramienta de reestructura- ción. Las violaciones a los constructos de programación estructurada se anotan y luego el có-digo se reestructura (esto puede hacerse automáticamente) o incluso se reescribe en un len-guaje de programación más moderno. El código reestructurado resultante se revisa y pone a prueba para garantizar que no se introdujeron anomalías. La documentación de código interna se actualiza. Reestructuración de datos. Un programa con arquitectura de datos débil será difícil de adap- tar y mejorar . De hecho, para muchas aplicaciones, la arquitectura de información tiene más que  ver con la viabilidad a largo plazo de un programa que con el código fuente en sí. A diferencia de la reestructuración de código, que ocurre en un nivel de abstracción relativa- mente bajo, la reestructuración de datos es una actividad de reingeniería a gran escala. En la mayoría de los casos, la reestructuración de los datos comienza con una actividad de ingeniería inversa. La arquitectura de datos existente se diseca y se definen modelos de datos necesarios (capítulos 6 y 9). Se identifican los objetos y atributos de datos, y se revisa la calidad de las es-tructuras de datos existentes. Cuando la estructura de datos es débil (por ejemplo, si se implementan archivos planos,  cuando un enfoque relacional simplificaría enormemente el procesamiento), los datos se some-ten a reingeniería. Puesto que la arquitectura de datos tiene una fuerte influencia sobre la arquitectura del pro- grama y sobre los algoritmos que los pueblan, los cambios a los datos invariablemente resulta-rán en cambios arquitectónicos o en el nivel de código.WebRef En www.comp.lancs.ac.uk/ projects/RenaissanceWeb/, puede encontrar varios recursos para la comunidad de reingeniería. 4 La reestructuración de código tiene algunos de los elementos de la “refactorización”, un concepto de rediseño  introducido en el capítulo 8 y estudiado en otras partes de este libro. 29Pressman(655-674).indd   66329Pressman(655-674).indd   663 26/1/10   17:33:0026/1/10   17:33:00