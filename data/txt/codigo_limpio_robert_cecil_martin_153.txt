sólo para capturar una excepción y permitir el paso de otra distinta. Definir el flujo normal Si sigue los consejos de apartados anteriores, realizará una importante separación entre la lógica empresarial y el control de errores. La mayoría de su código parecerá un algoritmo limpio y sin adornos. Sin embargo, el proceso desplaza la detección de errores hacia los bordes del programa. Debe envolver API externas para poder generar sus propias excepciones y definir un controlador por encima del código para poder procesar cálculos cancelados. En muchos casos es el enfoque más acertado, pero en ocasiones conviene no cancelar. Veamos un ejemplo, un código extraño que suma gastos en una aplicación de facturación: try { MealExpenses expenses = expenseReportDAO.getMeals(employee.getID()); m_total += expenses.getTotal(); } catch(MealExpensesNotFound e) { m_total += getMealPerDiem(); } En esta empresa, si las comidas son gastos, pasan a formar parte del total. Si no lo son, los trabajadores reciben una cantidad diaria para la comida. La excepción entorpece la lógica. Sería más adecuado no tener que procesar el caso especial y el código sería mucho más sencillo: MealExpenses expenses = expenseReportDAO.getMeals(employee.getID()); m_total += expenses.getTotal(); ¿De verdad que el código puede ser tan simple? Pues sí. Podemos cambiar  ExpenseReportDAO  para que siempre devuelva un objeto MealExpense . Si no hay gastos de comida, devuelve un objeto  MealExpense que devuelve la dieta diaria como total: public class PerDiemMealExpenses implements MealExpenses { public int getTotal() { // devolver la dieta diaria predeterminada 154