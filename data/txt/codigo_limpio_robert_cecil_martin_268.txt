return argsFound.contains(arg); } public boolean isValid() { return valid; } private class ArgsException extends Exception { } } Espero que su reacción inicial ante tal cantidad de código es alegrarse por no haberlo conservado tal cual. Si ha sido su reacción, recuerde que será la que tengan otros que lean un borrador de su código. En realidad, primer borrador es lo mejor que se puede decir sobre este código. Evidentemente es un trabajo en progreso. La cantidad de variables de instancia es apabullante. Cadenas extrañas como « TILT »,  HashSet  y  TreeSet , y los bloques  try-catch-catch  aumentan el desastre. No era mi intención crear este desastre. En realidad, intentaba mantener cierta organización, como demuestra la elección de nombres de funciones y variables, y la estructura del programa. Pero es evidente que el problema se me fue de las manos. El desastre aumentó gradualmente. Las versiones anteriores no fueron tan malas. Por ejemplo, el Listado 14-9 muestra una versión inicial en la que sólo funcionaban los argumentos booleanos. Listado 14-9 Args.java (sólo argumentos booleanos) package com.objectmentor.utilities.getopts; import java.util.*; public class Args { private String schema; private String[] args; private boolean valid; private Set<Character> unexpectedArguments = new TreeSet<Character>(); private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>(); private int numberOfArguments = 0; public Args(String schema, String[] args) { this.schema = schema; this.args = args; 269