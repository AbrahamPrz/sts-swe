SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1)); assertEquals(30, d4.getDayOfMonth()); assertEquals(7, d4.getMonth()); assertEquals(2004, d4.getYYYY()); } Las tres funciones deberían ser las siguientes: Dado el último día de un mes con 31 días (como mayo): 1 .  Cuando se añade un mes, si el último día de ese mes es el 30 (como en junio), entonces la fecha debe ser el día 30 de ese mes, no el 31. 2 .  Cuando se añaden dos meses a esa fecha, si el último mes tiene 31 días, entonces la fecha debe ser el día 31. Dado el último día de un mes con 30 días (como junio): 1 .  Cuando se añade, si el último día de ese mes tiene 31 días, entonces la fecha debe ser el 30, no el 31. Expresado de esta forma, se aprecia que existe una regla general entre las distintas pruebas. Al incrementar el mes, la fecha no puede ser mayor que su último día. Esto implica que al incrementar el mes en el 28 de febrero debe generarse el 28 de marzo. Falta esa prueba y convendría que la escribiéramos. Así pues, no son las múltiples afirmaciones del Listado 9-8 las causantes del problema, sino el hecho de que se prueba más de un concepto. Probablemente la regla óptima sea minimizar el número de activos por concepto y probar un solo concepto por función de prueba. F.I.R.S.T. [44] Las pruebas limpias siguen otras cinco reglas, cuyas iniciales forman las siglas FIRST en inglés: Rapidez  ( Fast ): Las reglas deben ser rápidas y ejecutarse de forma rápida. Si lo hacen lentamente, no las ejecutará con frecuencia. Al no hacerlo, no detectará los problemas con la suficiente antelación como para solucionarlos. No se sentirá con libertad para limpiar el código, que acabará corrompiéndose. 182