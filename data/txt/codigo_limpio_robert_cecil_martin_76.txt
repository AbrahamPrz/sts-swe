} El efecto secundario es la invocación de  Session.initialize() . La función  checkPassword , por su nombre, afirma comprobar la contraseña. El nombre no implica que inicialice la sesión. Por tanto, un invocador que se crea lo que dice el nombre de la función se arriesga a borrar los datos de sesión actuales cuando decida comprobar la validez del usuario. Este efecto secundario genera una combinación temporal. Es decir, sólo se puede invocar checkPassword  en determinados momentos (cuando se pueda inicializar la sesión). Si no se invoca en orden, se pueden perder los datos de la sesión. Las combinaciones temporales son confusas, en especial cuando se ocultan como efecto secundario. Si tiene que realizar una combinación temporal, hágalo de forma clara en el nombre de la función. En este caso, podríamos cambiar el nombre de la función por  checkPasswordAndInitializeSession , pero incumpliría la norma de hacer una sola cosa. Argumentos de salida Los argumentos suelen interpretarse como entradas de una función. Si lleva varios años programando, estoy seguro de que habrá visto un argumento que en vez de ser de entrada era de salida. Por ejemplo; appendFooter(s); ¿Está función añade  s  al final de algo? ¿O añade el final de algo a  s ? ¿ s es una entrada o una salida? Lo sabemos al ver la firma de la función: public void appendFooter(StringBuffer report) Esto lo aclara todo, pero para ello hay que comprobar la declaración de la función. Todo lo que le obligue a comprobar la firma de la función es un esfuerzo doble. Es una pausa cognitiva y debe evitarse. Antes de la programación orientada a objetos, era necesario tener argumentos de salida. Sin embargo, gran parte de su necesidad desaparece en los lenguajes orientados a objetos, pensados para actuar como argumento de salida. Es decir, sería más indicado invocar  appendFooter  como report.appendFooter();. Por lo general, los argumentos de salida deben evitarse. Si su función 77