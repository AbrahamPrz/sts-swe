} dosometingwith(nextvalue); } cada cliente añade un bloqueo a través de la palabra clave synchronized . esta duplicación incumple el principio dry, pero puede ser necesaria si el código usa agrupaciones de terceros no compatibles con subprocesos. la estrategia es arriesgada ya que todos los programadores que usen el servidor deben acordarse de bloquearlo antes de usarlo y de desbloquearlo cuando terminen. hace muchos años, trabajé en un sistema que usaba el bloqueo basado en el cliente en un recurso compartido. el recurso se usaba en cientos de puntos distintos del código. un pobre programador se olvidó de bloquear el recurso en uno de esos puntos. era un sistema de varios terminales con software de contabilidad para el sindicato de transportistas. local 705. el ordenador se encontraba en una sala de temperatura controlada de un piso elevado, a unas 50 millas al norte de la sede de local 705. en la sede, decenas de trabajadores introducían datos en las terminales, conectadas al ordenador mediante líneas telefónicas dedicadas y módem semidúplex de 600bps (esto fue hace mucho , mucho tiempo). una vez al día, una de las terminales se bloqueaba, sin razón aparente. el bloqueo no tenía preferencia alguna por una terminal o una hora concreta. es como si alguien echara a suertes la terminal que bloquear y la hora del bloqueo. en ocasiones, se bloqueaba más de una terminal. en ocasiones, podían pasar varios días sin bloqueos. inicialmente, se optó por reiniciar como solución, pero era complicado coordinar los reinicios. tenemos que avisar a la sede y esperar a que todos terminaran lo que estuvieran haciendo en todas las terminales. tras ello, se apagaba el sistema y se reiniciaba. si alguien estaba haciendo algo importante para lo que necesitaba una o dos horas, la terminal bloqueada tenía que seguir bloqueada. tras varias semanas de depuración, descubrimos que la causa era un contador de búfer circular desincronizado con su puntero. este búfer controlaba la salida a la terminal. el valor del puntero indicaba que el búfer estaba vacío pero el contador mostraba que estaba lleno. como estaba vacío, no había nada que mostrar; pero como también estaba lleno, no se podía añadir nada al búfer que mostrar en la pantalla. 417