obtener los datos sobre los que opera. el método calculateweeklypay envidia el ámbito de hourlyemployee . su deseo es formar parte de hourlyemployee . es recomendable suprimir la envidia de características ya que muestra los detalles internos de una clase a otra. sin embargo, en ocasiones es un mal necesario. fíjese en lo siguiente: public class hourlyemployeereport { private hourlyemployee employee; public hourlyemployeereport(hourlyemployee e) { this.employee = e; } string reporthours() { return string.format( “name: %s\thours:%d.%1d\n”, employee.getname(), employee.gettenthsworked()/10, employee.gettenthsworked()%10); } } evidentemente, el método reporthours envidia la clase hourlyemployee . por otra parte, no queremos que hourlyemployee tenga que conocer el formato del informe. al incluir la cadena de formato en la clase hourlyemployee incumpliríamos varios de los principios del diseño orientado a objetos [110] . conectaría hourlyemployee al formato del informe y lo mostraría en los cambios de dicho formato. g15: argumentos de selector no hay nada más abominable que un argumento false aislado al final de la invocación de una función. ¿qué significa? ¿qué cambiaría si fuera true ? no sólo el propósito de un argumento de selector es difícil de recordar, sino que cada argumento de selector combina varias funciones en una. los argumentos de selector son una forma indolente de evitar dividir una función de gran tamaño en otras menores. fíjese en lo siguiente: public int calculateweeklypay(boolean overtime) { int tenthrate = gettenthrate(); int tenthsworked = gettenthsworked(); 371