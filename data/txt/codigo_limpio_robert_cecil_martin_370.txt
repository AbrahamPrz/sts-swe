obtener los datos sobre los que opera. El método  calculateWeeklyPay envidia el ámbito de  HourlyEmployee . Su deseo es formar parte de HourlyEmployee . Es recomendable suprimir la envidia de características ya que muestra los detalles internos de una clase a otra. Sin embargo, en ocasiones es un mal necesario. Fíjese en lo siguiente: public class HourlyEmployeeReport { private HourlyEmployee employee; public HourlyEmployeeReport(HourlyEmployee e) { this.employee = e; } String reportHours() { return String.format( “Name: %s\tHours:%d.%1d\n”, employee.getName(), employee.getTenthsWorked()/10, employee.getTenthsWorked()%10); } } Evidentemente, el método  reportHours  envidia la clase  HourlyEmployee . Por otra parte, no queremos que  HourlyEmployee  tenga que conocer el formato del informe. Al incluir la cadena de formato en la clase HourlyEmployee  incumpliríamos varios de los principios del diseño orientado a objetos [110] . Conectaría  HourlyEmployee  al formato del informe y lo mostraría en los cambios de dicho formato. G15: Argumentos de selector No hay nada más abominable que un argumento  false  aislado al final de la invocación de una función. ¿Qué significa? ¿Qué cambiaría si fuera  true ? No sólo el propósito de un argumento de selector es difícil de recordar, sino que cada argumento de selector combina varias funciones en una. Los argumentos de selector son una forma indolente de evitar dividir una función de gran tamaño en otras menores. Fíjese en lo siguiente: public int calculateWeeklyPay(boolean overtime) { int tenthRate = getTenthRate(); int tenthsWorked = getTenthsWorked(); 371