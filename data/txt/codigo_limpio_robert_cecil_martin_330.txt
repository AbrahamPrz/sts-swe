private void compactexpectedandactual() { findcommonprefixandsuffix(); compactexpected = compactstring(expected); compactactual = compactstring(actual); } private void findcommonprefixandsuffix () { findcommonprefix(); int expectedsuffix = expected.length() - 1; int actualsuffix = actual.length() - 1; for (; actualsuffix >= prefixindex && expectedsuffix >= prefixindex; actualsuffix--, expectedsuffix-- ) { if (expected.charat(expectedsuffix) != actual.charat(actualsuffix)) break; } suffixindex = expected.length() - expectedsuffix; } private void findcommonprefix() { prefixindex = 0; int end = math.min(expected.length(), actual.length()); for (; prefixindex < end; prefixindex++) if (expected.charat(prefixindex) != actual.charat(prefixindex)) break; } devolvemos findcommonprefix y findcommonsuffix a su posición original, cambiamos el nombre de findcommonsuffix por findcommonprefixandsuffix y hacemos que invoque findcommonprefix antes de hacer nada más. de ese modo se establece la naturaleza temporal de ambas funciones de forma más evidente que antes. además, se muestra el mínimo atractivo de findcommonprefixandsuffix , que limpiaremos a continuación: private void findcommonprefixandsuffix() { findcommonprefix(); int suffixlength = 1; for (; !suffixoverlapsprefix(suffixlength); suffixlength++) { if (charfromend(expected, suffixlength) != charfromend(actual, suffixlength)) break; } suffixindex = suffixlength; } private char charfromend(string s, int i) { return s.charat(s.length()-i);} private boolean suffixoverlapsprefix(int suffixlength) { 331