431 */ 432 private int calcserial(final int d, final int m, final int y) { 433 final int yy = ((y - 1900) * 365) + serialdate.leapyearcount(y - 1); 434 int mm = serialdate.aggregate_days_to_end_of_preceding_month[m]; 435 if (m > monthconstants.february) { 436 if (serialdate.isleapyear(y)) { 437 mm = mm + 1; 438 } 439 } 440 final int dd = d; 441 return yy + mm + dd + 1; 442 } 443 444 /** 445 * calcular el día, mes y año a partir del número de serie. 446 */ 447 private void calcdaymonthyear() { 448 449 // obtener el año a partir del número de serie de la fecha 450 final int days = this.serial - serial_lower_bound; 451 // sobrevalorado ya que ignoramos los días bisiestos 452 final int overestimatedyyyy = 1900 + (days / 365); 453 final int leaps = serialdate.leapyearcount(overestimatedyyyy); 454 final int nonleapdays = days - leaps; 455 // subestimado ya que sobrevaloramos los años 456 int underestimatedyyyy = 1900 + (nonleapdays / 365); 457 458 if (underestimatedyyyy == overestimatedyyyy) { 459 this.year = underestimatedyyyy; 460 } 461 else { 462 int ss1 = calcserial(1, 1, underestimatedyyyy); 463 while (ss1 <= this.serial) { 464 underestimatedyyyy = underestimatedyyyy + 1; 465 ss1 = calcserial(1, 1, underestimatedyyyy); 466 } 467 this.year = underestimatedyyyy - 1; 468 } 469 470 final int ss2 = calcserial(1, 1, this.year); 471 472 int[] daystoendofprecedingmonth 473 = aggregate_days_to_end_of_preceding_month; 474 475 if (isleapyear(this.year)) { 495