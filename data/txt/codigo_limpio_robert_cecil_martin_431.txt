Al instrumentar el código con ConTest, la tasa de éxito pasó de un fallo por cada millón de iteraciones a un fallo en 30 iteraciones. Los valores de bucle de las distintas ejecuciones de la prueba tras la instrumentación son los siguientes: 13, 23, 0, 54, 16, 14, 6, 69, 107, 49, 2. Evidentemente, las clases instrumentadas fallaban antes y con mayor fiabilidad. Conclusión En este capítulo hemos realizado un breve recorrido por el vasto y complejo territorio de la programación concurrente. Apenas hemos mostrado la superficie. Nos hemos centrado en disciplinas para mantener la limpieza del código concurrente, pero hay mucho más que aprender si tiene pensado diseñar sistemas concurrentes. Le recomendamos que empiece por el libro de Doug Lea  Concurrent Programming in Java: Design Principles and Patterns [124] . En este capítulo hemos presentado la actualización concurrente y las disciplinas de sincronización y bloqueo para evitarla. Hemos visto cómo los subprocesos pueden mejorar la producción de un sistema vinculado a E/S y las técnicas limpias para lograr dichas mejoras. Hemos descrito el bloqueo mutuo y las disciplinas para evitarlo de forma limpia. Por último, hemos analizado estrategias para mostrar problemas de concurrencia mediante la instrumentación del código. Ejemplos de código completos Cliente/Servidor sin subprocesos Listado A-3 Server.java package com.objectmentor.clientserver.nonthreaded; 432