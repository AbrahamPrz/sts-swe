} public Object get() { return intValue; } } Evidentemente, las pruebas seguían funcionando. Tras ello, me deshice de las distintas asignaciones de la parte superior del algoritmo, lo que hace que el sistema sea mucho más genérico. Sin embargo, no las puede eliminar ya que afectaría a la integridad del sistema. En su lugar, añadí un nuevo  Map para  ArgumentMarshaler  y, tras ello, cambié uno a uno los métodos para que usaran la nueva asignación en lugar de las originales. public class Args { … private Map<Character, ArgumentMarshaler> booleanArgs = new HashMap<Character, ArgumentMarshaler>(); private Map<Character, ArgumentMarshaler> stringArgs = new HashMap<Character, ArgumentMarshaler>(); private Map<Character, ArgumentMarshaler> intArgs = new HashMap<Character, ArgumentMarshaler>(); private Map<Character, ArgumentMarshaler> marshalers = new HashMap<Character, ArgumentMarshaler>(); … private void parseBooleanSchemaElement(char elementId) { ArgumentMarshaler m = new BooleanArgumentMarshaler(); booleanArgs.put(elementId, m); marshalers.put(elementId, m); } private void parseIntegerSchemaElement(char elementId) { ArgumentMarshaler m = new IntegerArgumentMarshaler(); intArgs.put(elementId, m); marshalers.put(elementId, m); } private void parseStringSchemaElement(char elementId) { ArgumentMarshaler m = new StringArgumentMarshaler(); stringArgs.put(elementId, m); marshalers.put(elementId, m); } Las pruebas seguían funcionando. Tras ello, cambié  isBooleanArg  de esto: private boolean isBooleanArg(char argChar) { return booleanArgs.containsKey(argChar); } a este otro: 286