deliverpay(employee e, date date), o muchas otras, todas con la misma estructura. la solución al problema (véase el listado 3-5) consiste en ocultar la instrucción switch en una factoría abstracta [18] e impedir que nadie la vea. la factoría usa la instrucción switch para crear las instancias adecuadas de los derivados de employee y las distintas funciones, como calculatepay , ispayday y deliverpay , se entregarán de forma polimórfica a través de la interfaz employee . listado 3-5 employee y factory. public abstract class employee { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } public interface employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype; } public class employeefactoryimpl implements employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype { switch (r.type) { case commissioned: return new commissionedemployee(r); case hourly: return new hourlyemployee(r); case salaried: return new salariedemployee(r); default: throw new invalidemployeetype(r.type); } } } mi regla general para las instrucciones switch es que se pueden tolerar si sólo aparecen una vez, se usan para crear objetos polimórficos y se ocultan tras una relación de herencia para que el resto del sistema no las pueda ver [g23]. evidentemente, cada caso es diferente y en ocasiones se puede 69