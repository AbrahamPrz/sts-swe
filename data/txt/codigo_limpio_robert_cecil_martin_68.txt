deliverPay(Employee e, Date date), o muchas otras, todas con la misma estructura. La solución al problema (véase el Listado 3-5) consiste en ocultar la instrucción  switch  en una factoría abstracta [18]  e impedir que nadie la vea. La factoría usa la instrucción  switch  para crear las instancias adecuadas de los derivados de Employee y las distintas funciones, como  calculatePay , isPayday  y  deliverPay , se entregarán de forma polimórfica a través de la interfaz  Employee . Listado 3-5 Employee y Factory. public abstract class Employee { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay); } public interface EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; } public class EmployeeFactoryImpl implements EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType { switch (r.type) { case COMMISSIONED: return new CommissionedEmployee(r); case HOURLY: return new HourlyEmployee(r); case SALARIED: return new SalariedEmployee(r); default: throw new InvalidEmployeeType(r.type); } } } Mi regla general para las instrucciones  switch  es que se pueden tolerar si sólo aparecen una vez, se usan para crear objetos polimórficos y se ocultan tras una relación de herencia para que el resto del sistema no las pueda ver [G23]. Evidentemente, cada caso es diferente y en ocasiones se puede 69