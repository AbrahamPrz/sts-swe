Sabíamos qué era lo que bloqueaba las terminales pero no qué provocaba la desincronización del búfer circular, por lo que añadimos un truco para resolver el problema. Se podían leer los conmutadores del panel frontal en el ordenador (esto fue hace mucho, mucho, mucho tiempo). Diseñamos una función de trampa que detectaba si uno de los conmutadores se había generado y después buscábamos un búfer circular que estuviera tanto lleno como vacío. Si lo encontrábamos, lo variábamos. ¡ Voilá ! La terminal bloqueada volvía a funcionar. De este modo no era necesario reiniciar el sistema si una terminal se bloqueaba. La sede nos llamaba y nos decía que había un bloqueo, nos acercábamos hasta la sala de ordenadores y pulsábamos un conmutador. En ocasiones ellos trabajan los fines de semana pero nosotros no. Por ello, añadimos una función al programador que comprobaba los búfer circulares una vez por minuto y restablecía los que estuvieran tanto llenos como vacíos. De este modo se descongestionaban las pantallas antes de que la dirección llegara al teléfono. Necesitamos varias semanas de análisis de código de lenguaje de ensamblado antes de localizar al culpable. Habíamos calculado que la frecuencia de los bloqueos se debía a un uso desprotegido del búfer circular, así que sólo  era  necesario determinar el uso fallido. Desafortunadamente, esto fue hace mucho tiempo y no disponíamos de herramientas de búsqueda, referencias cruzadas ni de otras técnicas automáticas de ayuda. Teníamos que escudriñar los listados. En aquel frío invierno de 1971 en Chicago aprendí que los bloqueos basados en el cliente son verdaderamente terribles. Bloqueo basado en el servidor La duplicación se puede eliminar si modificamos  IntegerIterator  de esta forma: public class IntegerIteratorServerLocked { private Integer nextValue = 0; public synchronized Integer getNextOrNull() { if (nextValue < 100000) return nextValue++; else return null; 418