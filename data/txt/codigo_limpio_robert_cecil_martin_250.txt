incorrecto falle lo antes posible y con frecuencia. Hay dos opciones de instrumentación de código: Manual. Automática. Manual Puede añadir invocaciones de  wait() ,  sleep() ,  yield()  y  priority() manualmente a su código, en especial si tiene que probar un fragmento especialmente escabroso. Veamos un ejemplo: public synchronized String nextUrlOrNull() { if (hasNext()) { String url = urlGenerator.next(); Thread.yield(); // se añade para pruebas. updateHasNext(); return url; } return null; } La invocación de  yield()  cambia la ruta de ejecución adoptada por el código y posiblemente hace que el código falla donde no lo hacía antes. Si el código falla, no se debe a la invocación de yield() añadida [90] . Se debe a que el código es incorrecto y hemos hecho que el fallo sea más evidente. Este enfoque presenta varios problemas: Tendrá que buscar manualmente los puntos adecuados donde hacerlo. ¿Cómo sabe dónde incluir la invocación y qué tipo de invocación usar? La presencia de este código en un entorno de producción ralentiza innecesariamente el código. Es un enfoque que puede o no detectar los fallos; de hecho, no las tiene todas consigo. Lo que necesitamos es una forma de hacerlo durante la fase de pruebas, no de producción. También debemos poder mezclar configuraciones entre ejecuciones, lo que aumenta las probabilidades de detectar los errores. 251