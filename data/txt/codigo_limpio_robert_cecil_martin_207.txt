mayoría de los casos? return service; } es la técnica de inicialización/evaluación tardía y tiene sus méritos. no incurrimos en la sobrecarga de la construcción a menos que usemos el objeto realmente, y como resultado el tiempo de inicio se puede acelerar. también evitamos que se devuelva null . sin embargo, ahora tenemos una dependencia en myserviceimpl y todo lo que su constructor requiere (que he omitido). no podemos compilar sin resolver estas dependencias, aunque nunca usemos un objeto de este tipo en tiempo de ejecución. las pruebas también pueden ser un problema. si myserviceimpl es un objeto pesado, tendremos que asegurarnos de asignar el correspondiente test double [50] u objeto simulado al campo de servicio antes de invocar este método en las pruebas de unidad. como la lógica de la construcción se mezcla con el procesamiento normal de tiempo de ejecución, debemos probar todas las rutas de ejecución (como la prueba null y su bloque). al contar con ambas responsabilidades, el método hace más de una cosa, por lo que se incumple el principio de responsabilidad única. lo peor de todo es que no sabemos si myserviceimpl es el objeto correcto en todos los casos. ¿por qué la clase con este método tiene que conocer el contexto global? ¿podemos saber realmente cuál es el objeto correcto que usar aquí? ¿es posible que un mismo tipo sea el correcto para todos los contextos posibles? un caso de inicialización tardía no es un problema serio. sin embargo, suele haber muchos casos de este tipo de configuración en las aplicaciones. por tanto, la estrategia de configuración global (si existe) se disemina por la aplicación, sin apenas modularidad y con una significativa duplicación. si somos diligentes sobre el diseño de sistemas robustos y bien formados, no debemos permitir fallos de modularidad. el proceso de inicio de la construcción y conexión de objetos no es una excepción. debemos modularizar este proceso y asegurarnos de contar con una estrategia global y coherente para resolver las dependencias principales. 208