servlet. algunas clases de colección tienen métodos concretos compatibles con subprocesos. sin embargo, cualquier operación que invoque más de un método no lo es. por ejemplo, si no quiere reemplazar algo en hashtable porque ya existe, podría crear el siguiente código: if(!hashtable.containskey(somekey)) { hashtable.put(somekey, new somevalue()); } cada uno de los métodos es compatible con subprocesos. sin embargo, otro subproceso podría añadir un valor entre las invocaciones de containskey y put . existen varias formas de solucionar este problema: bloquear primero hashtable y comprobar que los demás usuarios de hashtable hagan lo mismo; bloqueo basado en clientes: synchronized(map) { if(!map.containskey(key)) map.put(key,value); } envolver hashtable en su propio objeto y usar dos api distintas; bloqueo basado en servidores con un adaptador: public class wrappedhashtable<k, v> { private map<k, v> map = new hashtable<k, v>(); public synchronized void putifabsent(k key, v value) { if (map.containskey(key)) map.put(key, value); } } usar colecciones compatibles con subprocesos: concurrenthashmap<integer, string> map = new concurrenthashmap<integer, string>(); map.putifabsent(key, value); las colecciones de java.util.concurrent incluyen operaciones como putifabsent() para acomodar este tipo de operaciones. 414