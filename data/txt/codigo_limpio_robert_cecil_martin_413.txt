Servlet. Algunas clases de colección tienen métodos concretos compatibles con subprocesos. Sin embargo, cualquier operación que invoque más de un método no lo es. Por ejemplo, si no quiere reemplazar algo en  HashTable porque ya existe, podría crear el siguiente código: if(!hashTable.containsKey(someKey)) { hashTable.put(someKey, new SomeValue()); } Cada uno de los métodos es compatible con subprocesos. Sin embargo, otro subproceso podría añadir un valor entre las invocaciones de containsKey  y  put . Existen varias formas de solucionar este problema: Bloquear primero  HashTable  y comprobar que los demás usuarios de HashTable  hagan lo mismo; bloqueo basado en clientes: synchronized(map) { if(!map.containsKey(key)) map.put(key,value); } Envolver  HashTable  en su propio objeto y usar dos API distintas; bloqueo basado en servidores con un adaptador: public class WrappedHashtable<K, V> { private Map<K, V> map = new Hashtable<K, V>(); public synchronized void putIfAbsent(K key, V value) { if (map.containsKey(key)) map.put(key, value); } } Usar colecciones compatibles con subprocesos: ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<Integer, String>(); map.putIfAbsent(key, value); Las colecciones de  java.util.concurrent  incluyen operaciones como putIfAbsent()  para acomodar este tipo de operaciones. 414