9.3 ■ Mantenimiento del software  251 rice un programa, no se debe agregar funcionalidad, sino que hay que concentrarse en la  mejora del programa. Por ende, se puede considerar la refactorización como el “manteni-miento preventivo” que reduce los problemas de cambios futuros. Aunque la reingeniería y la refactorización tienen la intención de hacer el software más fácil de entender y cambiar, no son lo mismo. La reingeniería se lleva a cabo des-pués de haber mantenido un sistema durante cierto tiempo y, por consiguiente, los costos de mantenimiento aumentan. Se usan herramientas automatizadas para procesar y some-ter a reingeniería un sistema heredado y así crear un nuevo sistema que sea más mante-nible. La refactorización es un proceso continuo de mejoramiento debido al proceso de desarrollo y evolución. Tiene la intención de evitar la degradación de la estructura y el código que aumentan los costos y las dificultades por mantener un sistema. La refactorización es una parte inherente de los métodos ágiles, como lo es la pro-gramación extrema, porque dichos métodos se basan en el cambio. En consecuencia, la calidad del programa es proclive a degradarse rápidamente, de modo que los desarrolla-dores ágiles con frecuencia refactorizan sus programas para evitar tal degradación. El énfasis en las pruebas de regresión en los métodos ágiles reduce el riesgo de introducir nuevos errores a través de la refactorización. Cualquier error que se introduzca debe ser detectable, ya que las pruebas anteriormente exitosas podrían fracasar. Sin embargo, la refactorización no depende de otras “actividades ágiles” y se utiliza con cualquier enfo-que al desarrollo. Fowler y sus colaboradores (1999) sugieren que existen situaciones estereotípicas (que se llaman “malos olores”), en las cuales el código de un programa es susceptible de mejorarse. Los ejemplos de malos olores que pueden mejorarse mediante refactorización incluyen: 1. Código duplicado El mismo de código muy similar puede incluirse en diferentes  lugares de un programa. Éste se descarta o se implementa como un solo método o función que se llame cuando se requiera. 2. Métodos largos Si un método es demasiado largo, debe rediseñarse en varios métodos más cortos. 3. Enunciados de switch (case) Con frecuencia éstos implican duplicación, donde el cambio (switch) depende del tipo de algún valor. Los enunciados switch pueden dispersarse alrededor de un programa. En los lenguajes orientados a objetos, nor-malmente es posible usar un polimorfismo para lograr lo mismo. 4. Aglomeración de datos Las aglomeraciones de datos ocurren cuando el mismo grupo de objetos de datos (campos en clases, parámetros en métodos) vuelven a ocurrir en muchos lugares en un programa. Generalmente pueden sustituirse con un objeto que encapsule todos los datos. 5. Generalidad especulativa Esto ocurre cuando los desarrolladores incluyen gene-ralidad en un programa, en caso de que se requiera en el futuro. Por lo general, esto simplemente puede eliminarse.  Fowler, en su libro y sitio Web, también sugiere algunas transformaciones primitivas de refactorización que pueden usarse de manera individual o en conjunto para lidiar con los malos olores. Los ejemplos de dichas transformaciones incluyen el método Extract (extraer), donde se eliminan duplicados y se crea un nuevo método; la expresión condi-cional Consolidate (consolidar), donde se sustituye una secuencia de pruebas con una sola prueba; y el método Pull up (subir), donde se sustituyen métodos similares en subclases con  M09_SOMMERVILLE_INGENIERIA_1ED_SE_234-260.indd   251M09_SOMMERVILLE_INGENIERIA_1ED_SE_234-260.indd   251 3/18/11   4:52:25 PM3/18/11   4:52:25 PM