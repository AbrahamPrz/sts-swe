public int getId() { return id; } public void setID(int id) { this.id = id; } public void addAccount(Account account) { account.setBank(this); accounts.add(account); } public Collection<Account> getAccounts() { return accounts; } public void setAccounts(Collection<Account> accounts) { this.accounts = accounts; } } Este código es mucho más limpio que el código EJB2 original. Se conservan algunos detalles de entidades, en las anotaciones. Sin embargo, como no hay información fuera de las anotaciones, el código es limpio y fácil de probar, mantener y demás. Parte de la información de persistencia de las anotaciones se puede cambiar a descriptores de implementación XML si es necesario, dejando un POJO puro. Si los detalles de asignación de persistencia no cambian con frecuencia, muchos equipos pueden optar por mantener las anotaciones pero con menos obstáculos que si usaran EJB2. Aspectos de AspectJ Por último, la herramienta más completa de separación a través de aspectos es el lenguaje AspectJ [66] , una extensión de Java que ofrece compatibilidad de primer nivel para aspectos como construcciones de modularidad. Los enfoques puros de Java proporcionados por Spring AOP y JBoss AOP son suficientes en el  80-90  por 100 de los casos en los que los aspectos son útiles. Sin embargo, AspectJ ofrece un conjunto de herramientas avanzadas y completas para la separación de aspectos. El inconveniente de AspectJ es la necesidad de adoptar nuevas herramientas y aprender nuevas construcciones 221