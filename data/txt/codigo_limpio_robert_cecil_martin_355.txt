modo que las creé. Las seis siguientes funciones (líneas  915-980)  son métodos abstractos que deben implementarse en  DayDate , por lo que las extraje de  SpreadsheetDate . La última función,  isInRange  (líneas  982-995),  también debe extraerse y refactorizarse. La instrucción  switch  no es agradable [G23] y se puede modificar si enviamos los casos a la enumeración  DateInterval . public enum DateInterval { OPEN { public boolean isIn(int d, int left, int right) { return d > left && d < right; } }, CLOSED_LEFT { public boolean isIn(int d, int left, int right) { return d >= left && d < right; } }, CLOSED_RIGHT { public boolean isIn(int d, int left, int right) { return d > left && d <= right; } }, CLOSED { public boolean isIn(int d, int left, int right) { return d >= left && d <= right; } }; public abstract boolean isIn(int d, int left, int right); } public boolean isInRange(DayDate d1, DayDate d2, DateInterval interval) { int left = Math.min(d1.getOrdinalDay(), d2.getOrdinalDay()); int right = Math.max(d1.getOrdinalDay(), d2.getOrdinalDay()); return interval.isIn(getOrdinalDay(), left, right); } Con esto llegamos al final de  DayDate . Realizaremos una nueva pasada por la clase completa para comprobar cómo fluye. Primero, el comentario inicial está desfasado, de modo que lo reduzco y lo mejoro [C2]. Tras ello, desplazo las enumeraciones restantes a sus propios archivos [G12]. Seguidamente, desplazo la variable estática ( dateFormatSymbols ) y tres métodos estáticos ( getMonthNames ,  isLeapYear ,  lastDayOfMonth ) a una nueva clase con el nombre  DateUtil  [G6]. 356