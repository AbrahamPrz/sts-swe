prefijos de miembros tampoco es necesario añadir m_ como prefijo a los nombres de variables. las clases y funciones tienen el tamaño necesario para no tener que hacerlo, y debe usar un entorno de edición que resalte o coloree los miembros para distinguirlos. public class part { private string m_dsc; // la descripción textual void setname(string name) { m_dsc = name; } } public class part { string description; void setdescription(string description) { this.description = description; } } además, los usuarios aprenden rápidamente a ignorar el prefijo (o sufijo) y fijarse en la parte con sentido del nombre. cuanto más código leemos, menos nos fijamos en los prefijos. en última instancia, los prefijos son un indicio de código antiguo. interfaces e implementaciones existe un caso especial para usar codificaciones. imagine por ejemplo que crea una factoría abstracta para crear formas. esta factoría será una interfaz y se implementará por medio de una clase concreta. ¿qué nombres debe asignar? ¿ ishapefactory y shapefactory ? prefiero las interfaces sin adornos. la i inicial, tan habitual en los archivos de legado actuales es, en el mejor de los casos, una distracción, y en el peor, un exceso de información. no quiero que mis usuarios sepan que se trata de una interfaz, solamente que se trata de shapefactory . si tengo que codificar la interfaz o la implementación, opto por ésta última. es mejor usar shapefactoryimp o incluso cshapefactory , que codificar la interfaz. 50