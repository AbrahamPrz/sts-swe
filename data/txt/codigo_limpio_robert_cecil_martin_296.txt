} catch (NumberFormatException e) { throw new ArgsException(); } } public Object get() { return intValue; } } } Tras todo este esfuerzo, es un tanto decepcionante. La estructura ha mejorado pero todavía hay demasiadas variables en la parte superior; se mantiene un terrible caso de tipos en  setArgument ; y todas las funciones  set . Sin mencionar el procesamiento de errores. Todavía nos queda mucho trabajo por hacer. Mi intención es eliminar el caso de tipos de  setArgument  [G23] y que sólo incluya una invocación a  ArgumentMarshaler.set . Para ello, debo desplazar  setIntArg ,  setStringArg  y  setBooleanArg  a las correspondientes variantes de  ArgumentMarshaler . Pero hay un problema. Si se fija atentamente en  setIntArg , comprobará que usa dos variables de instancia:  args  y  currentArg . Para desplazar  setIntArg  hasta BooleanArgumentMarshaler , tengo que pasar  args  y  currentArgs  como argumentos de función. Muy desagradable [F1]. Resultaría más indicado pasar un argumento y no dos. Afortunadamente, la solución es sencilla. Podemos convertir la matriz  args  en  list  y pasar  Iterator  a las funciones set . Para el siguiente cambio necesité diez pasos, y superar todas las pruebas tras cada uno. Pero sólo mostraremos el resultado. Debería determinar la mayoría de estos pequeños pasos. public class Args { private String schema; private String[] args; private boolean valid = true; private Set<Character> unexpectedArguments = new TreeSet<Character>(); private Map<Character, ArgumentMarshaler> marshalers = new HashMap<Character, ArgumentMarshaler>(); private Set<Character> argsFound = new HashSet<Character>(); private  Iterator<String>  currentArgument; private char errorArgumentId = ‘\0’; private String errorParameter = “TILT”; private ErrorCode errorCode = ErrorCode.OK; private List<String> argsList; 297