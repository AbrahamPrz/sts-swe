} catch (numberformatexception e) { throw new argsexception(); } } public object get() { return intvalue; } } } tras todo este esfuerzo, es un tanto decepcionante. la estructura ha mejorado pero todavía hay demasiadas variables en la parte superior; se mantiene un terrible caso de tipos en setargument ; y todas las funciones set . sin mencionar el procesamiento de errores. todavía nos queda mucho trabajo por hacer. mi intención es eliminar el caso de tipos de setargument [g23] y que sólo incluya una invocación a argumentmarshaler.set . para ello, debo desplazar setintarg , setstringarg y setbooleanarg a las correspondientes variantes de argumentmarshaler . pero hay un problema. si se fija atentamente en setintarg , comprobará que usa dos variables de instancia: args y currentarg . para desplazar setintarg hasta booleanargumentmarshaler , tengo que pasar args y currentargs como argumentos de función. muy desagradable [f1]. resultaría más indicado pasar un argumento y no dos. afortunadamente, la solución es sencilla. podemos convertir la matriz args en list y pasar iterator a las funciones set . para el siguiente cambio necesité diez pasos, y superar todas las pruebas tras cada uno. pero sólo mostraremos el resultado. debería determinar la mayoría de estos pequeños pasos. public class args { private string schema; private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private iterator<string> currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private list<string> argslist; 297