modo también es más sencillo probar las demás responsabilidades sin necesidad de preocuparse de los subprocesos. Veamos la versión actualizada que se encarga de ello: public void run() { while (keepProcessing) { try { ClientConnection clientConnection = connectionManager.awaitClient(); ClientRequestProcessor requestProcessor = new ClientRequestProcessor(clientConnection); clientScheduler.schedule(requestProcessor); } catch (Exception e) { e.printStackTrace(); } } connectionManager.shutdown(); } Ahora centra en el mismo punto todos los aspectos relacionados con los subprocesos:  clientScheduler . Si hay problemas de concurrencia, bastará con examinar un punto concreto: public interface ClientScheduler { void schedule(ClientRequestProcessor requestProcessor); } La política actual es fácil de implementar: public class ThreadPerRequestScheduler implements ClientScheduler { public void schedule(final ClientRequestProcessor requestProcessor) { Runnable runnable = new Runnable() { public void run() { requestProcessor.process(); } }; Thread thread = new Thread(runnable); thread.start(); } } Tras aislar la administración de subprocesos, resulta más sencillo cambiar el control de los mismos. Por ejemplo, para cambiar a la estructura  Executor de Java 5 es necesario crear una nueva clase y conectarla (véase el Listado  A-1). Listado A-1 403