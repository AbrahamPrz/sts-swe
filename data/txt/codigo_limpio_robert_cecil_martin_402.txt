modo también es más sencillo probar las demás responsabilidades sin necesidad de preocuparse de los subprocesos. veamos la versión actualizada que se encarga de ello: public void run() { while (keepprocessing) { try { clientconnection clientconnection = connectionmanager.awaitclient(); clientrequestprocessor requestprocessor = new clientrequestprocessor(clientconnection); clientscheduler.schedule(requestprocessor); } catch (exception e) { e.printstacktrace(); } } connectionmanager.shutdown(); } ahora centra en el mismo punto todos los aspectos relacionados con los subprocesos: clientscheduler . si hay problemas de concurrencia, bastará con examinar un punto concreto: public interface clientscheduler { void schedule(clientrequestprocessor requestprocessor); } la política actual es fácil de implementar: public class threadperrequestscheduler implements clientscheduler { public void schedule(final clientrequestprocessor requestprocessor) { runnable runnable = new runnable() { public void run() { requestprocessor.process(); } }; thread thread = new thread(runnable); thread.start(); } } tras aislar la administración de subprocesos, resulta más sencillo cambiar el control de los mismos. por ejemplo, para cambiar a la estructura executor de java 5 es necesario crear una nueva clase y conectarla (véase el listado a-1). listado a-1 403