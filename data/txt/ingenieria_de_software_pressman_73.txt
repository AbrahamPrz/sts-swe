42 parte uno el proceso del software por ejemplo, la actividad de comunicación (no se muestra en la figura) termina su primera iteración al principio de un proyecto y existe en el estado de cambios en espera. la actividad de modelado (que existía en estado inactivo mientras concluía la comunicación inicial, ahora hace una transición al estado en desarrollo. sin embargo, si el cliente indica que deben hacerse cambios en los requerimientos, la actividad de modelado pasa del estado en desarrollo al de cambios en espera. el modelado concurrente define una serie de eventos que desencadenan transiciones de un estado a otro para cada una de las actividades, acciones o tareas de la ingeniería de software. por ejemplo, durante las primeras etapas del diseño (acción importante de la ingeniería de soft-ware que ocurre durante la actividad de modelado), no se detecta una inconsistencia en el modelo de requerimientos. esto genera el evento corrección del modelo de análisis, que disparará la acción de análisis de requerimientos del estado terminado al de cambios en espera. el modelado concurrente es aplicable a todos los tipos de desarrollo de software y propor- ciona un panorama apropiado del estado actual del proyecto. en lugar de confinar las activida-des, acciones y tareas de la ingeniería de software a una secuencia de eventos, define una red del proceso. cada actividad, acción o tarea de la red existe simultáneamente con otras activida-des, acciones o tareas. los eventos generados en cierto punto de la red del proceso desencade-nan transiciones entre los estados. 2.3.5 una última palabra acerca de los procesos evolutivos ya se dijo que el software de cómputo moderno se caracteriza por el cambio continuo, por tiem-pos de entrega muy apretados y por una necesidad apremiante de la satisfacción del cliente o usuario. en muchos casos, el tiempo para llegar al mercado es el requerimiento administrativo más importante. si se pierde un nicho de mercado, todo el proyecto de software podría carecer de sentido. 13 los modelos de proceso evolutivo fueron concebidos para cumplir esos requisitos, pero, aun así, como clase general de modelos de proceso tienen demasiadas debilidades, que fueron re-sumidas por nogueira y sus colegas [nog00]: a pesar de los beneficios incuestionables de los procesos evolutivos de software, existen algunas pre- ocupaciones. la primera es que hacer prototipos (y otros procesos evolutivos más sofisticados) plantea un problema para la planeación del proyecto debido a la incertidumbre en el número de ciclos que se requieren para elaborar el producto. la mayor parte de técnicas de administración y estimación de pro-yectos se basa en un planteamiento lineal de las actividades, por lo que no se ajustan por completo. en segundo lugar, los procesos evolutivos de software no establecen la velocidad máxima de la evolución. si las evoluciones ocurren demasiado rápido, sin un periodo de relajamiento, es seguro que el proceso se volverá un caos. por otro lado, si la velocidad es muy lenta, se verá perjudicada la pro-ductividad… en tercer lugar, los procesos de software deben centrarse en la flexibilidad y capacidad de exten- sión en lugar de en la alta calidad. esto suena preocupante. sin embargo, debe darse prioridad a la velocidad del desarrollo con el enfoque de cero defectos. extender el desarrollo a fin de lograr alta calidad podría dar como resultado la entrega tardía del producto, cuando haya desaparecido el nicho de oportunidad. este cambio de paradigma es impuesto por la competencia al borde del caos. en realidad, sí parece preocupante un proceso del software que se centre en la flexibilidad, expansión y velocidad del desarrollo por encima de la calidad. no obstante, esta idea ha sido propuesta por varios expertos en ingeniería de software muy respetados ([you95], [bac97]).cita: “todo proceso en su organiza- ción tiene un cliente, y un proceso sin cliente no tiene pro-pósito.” v. daniel hunt 13 sin embargo, es importante notar que ser el primero en llegar al mercado no es garantía de éxito. en realidad, muchos productos de software muy exitosos han llegado en segundo o hasta en tercer lugar al mercado (apren- den de los errores de sus antecesores). 02pressman(025-054).indd  4202pressman(025-054).indd  42 14/1/10  13:36:5014/1/10  13:36:50