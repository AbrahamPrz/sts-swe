public class MoogDiver { Gradient gradient; List<Spline> splines; public void dive(String reason) { Gradient gradient = saturateGradient(); List<Spline> splines = reticulateSplines(gradient); diveForMoog(splines, reason); } … } De este modo se muestra la conexión temporal generando una especie de embudo. Cada función genera un resultado que la siguiente necesita de modo que no se pueden invocar en otro orden. Puede argumentar que esto aumenta la complejidad de las funciones y tiene razón, pero ese incremento de complejidad sintáctica muestra la verdadera complejidad temporal de la situación. Observará que he mantenido las variables de instancia. Imagino que son necesarias para los métodos privados de las clases. Incluso así, conservo los argumentos para que la conexión temporal sea explícita. G32: Evitar la arbitrariedad Argumente la estructura de su código y asegúrese de que la estructura del código comunica dicho argumento. Si la estructura parece arbitraria, otros se verán con derecho a modificarla. Si la estructura parece coherente en la totalidad del sistema, otros la usarán y conservarán la convención. Por ejemplo, recientemente repasaba cambios realizados en FitNesse y descubrí lo siguiente: public class AliasLinkWidget extends ParentWidget { public static class VariableExpandingWidgetRoot { … … } El problema es que  VariableExpandingWidgetRoot  no debía estar en el ámbito de  AliasLinkWidget . Es más, otras clases sin relación usaban AliasLinkWidget.VariableExpandingWidgetRoot  y no tenían por qué saber 383