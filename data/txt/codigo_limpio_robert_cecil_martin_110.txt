private static boolean[] crossedout; private static int[] result; public static int[] generateprimes(int maxvalue) { if (maxvalue < 2) return new int[0]; else { uncrossintegersupto(maxvalue); crossoutmultiples(); putuncrossedintegersintoresult(); return result; } } private static void uncrossintegersupto(int maxvalue) { crossedout = new boolean[maxvalue + 1]; for (int i = 2; i < crossedout.length; i++) crossedout[i] = false; } private static void crossoutmultiples() { int limit = determineiterationlimit(); for (int i = 2; i <= limit; i++) if (notcrossed(i)) crossoutmultiplesof(i); } private static int determineiterationlimit() { // cada múltiplo en la matriz tiene un factor primordial que // es menor o igual que la raíz del tamaño de la matriz, // entonces no tenemos que tachar múltiplos de números // más grande que esa raíz. double iterationlimit = math.sqrt(crossedout.length); return (int) iterationlimit; } private static void crossoutmultiplesof (int i) { for (int multiple = 2 * i; multiple < crossedout.length; multiple += i) crossedout[multiple] = true; } private static boolean notcrossed(int i) { return crossedout[i] == false; } private static void putuncrossedintegersintoresult() 111