crawler = context.root.getPageCrawler(); crawler.setDeadEndStrategy(new VirtualEnabledPageCrawler()); page = crawler.getPage(context.root, path); if (page != null) pageData = page.getData(); } private Response notFoundResponse(FitNesseContext context, Request request) throws Exception { return new NotFoundResponder().makeResponse(context, request); } private SimpleResponse makePageResponse(FitNesseContext context) throws Exception { pageTitle = PathParser.render(crawler.getFullPath(page)); String html = makeHtml(context); SimpleResponse response = new SimpleResponse(); response.setMaxAge(0); response.setContent(html); return response; } … Además, este fragmento es un buen ejemplo de ubicación de constantes en un nivel correcto [G35]. La constante  FrontPage  se podría haber ocultado en la función  getPageNameOrDefault , pero eso habría ocultado una constante conocida y esperada en una función de nivel inferior de forma incorrecta. Es mejor pasar la constante desde un punto en el que tiene sentido a la posición en la que realmente se usa. Afinidad conceptual Determinados conceptos de código  deben  estar próximos a otros. Tienen una afinidad conceptual concreta. Cuanto mayor sea esta afinidad, menor distancia vertical debe existir entre ellos. Como hemos visto, esta afinidad se puede basar en una dependencia directa, como cuando una función invoca a otra, o cuando usa una variable. Pero hay otras causas de afinidad. Puede generarse porque un grupo de funciones realice una operación similar. Fíjese en este fragmento de código de Junit 4.3.1: public class Assert { static public void assertTrue(String message, boolean condition) { 123