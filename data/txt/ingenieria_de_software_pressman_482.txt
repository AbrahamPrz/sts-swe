CAPÍTULO 19  PRUEBA DE APLICACIONES ORIENTADAS A OBJETOS 451 tamiento de clase da como resultado una colaboración con una o más clases, se usan diagramas  de estado múltiple para rastrear el flujo de comportamiento del sistema. El modelo de estado puede recorrerse en una forma “ancho primero” [McG94]. En este con- texto, ancho primero implica que un caso de prueba ejercita una sola transición y que, cuando se prueba una nueva transición, sólo se usan transiciones previamente probadas. Considere un objeto CreditCard que es parte del sistema bancario. El estado inicial de Cre- ditCard es indefinido (es decir, no se proporcionó número de tarjeta de crédito). Hasta leer la tarjeta de crédito durante una venta, el objeto toma un estado definido, es decir, se definen los atributos card number y expiration date, junto con identificadores específicos del banco. La tarjeta de  crédito se somete cuando se envía para autorización y se aprueba cuando se recibe la autoriza-ción. La transición de CreditCard de un estado a otro puede probarse al derivar casos de prueba que hacen que ocurra la transición. Un enfoque de ancho primero aplicado a este tipo de prue-ba no ejercitaría submitted antes de ejercitar undefined y defined. Si lo hiciera, usaría transiciones  que no se probaron anteriormente y, por tanto, violaría el criterio de ancho primero.  19.7 R ESUMEN El objetivo global de las pruebas orientadas a objetos (encontrar el número máximo de errores con una cantidad mínima de esfuerzo) es idéntico al de la prueba de software convencional. Pero la estrategia y las tácticas de la prueba OO difieren significativamente. La visión de las pruebas se ensancha para incluir la revisión de los modelos de requerimientos y de diseño. Además, el foco de la prueba se mueve alejándose del componente procedimental (el módulo) y acercándose hacia la clase. Puesto que los modelos de requerimientos y diseño OO y el código fuente resultante están  semánticamente acoplados, la prueba (en la forma de revisiones técnicas) comienza durante la actividad de modelado. Por esta razón, la revisión de los modelos CRC, objeto-relación y objeto-comportamiento puede verse como pruebas de primera etapa. Una vez disponible el código, la prueba de unidad se aplica para cada clase. El diseño de  pruebas para una clase usa varios métodos: prueba basada en fallo, prueba aleatoria y prueba de partición. Cada uno de éstos ejercita las operaciones encapsuladas por la clase. Las secuen-cias de prueba se diseñan para garantizar que se ejercitan las operaciones relevantes. El estado de la clase, representado por los valores de sus atributos, se examina para determinar si existen errores. La prueba de integración puede lograrse usando una estrategia basada en hebra o en uso. La  prueba basada en hebra integra el conjunto de clases que colaboran para responder a una en-trada o evento. La prueba basada en uso construye el sistema en capas, comenzando con aque-llas clases que no utilizan clases servidor. La integración de métodos de diseño de caso de prueba también puede usar pruebas aleatorias y de partición. Además, la prueba basada en escenario y las pruebas derivadas de los modelos de comportamiento pueden usarse para pro-bar una clase y a sus colaboradores. Una secuencia de prueba rastrea el flujo de operaciones a través de las colaboraciones de clase. La prueba de validación del sistema OO está orientada a caja negra y puede lograrse al apli- car los mismos métodos de caja negra estudiados para el software convencional. Sin embargo, la prueba basada en escenario domina la validación de los sistemas OO, lo que hace al caso de uso un impulsor primario para la prueba de validación.   PROBLEMAS  Y PUNTOS  POR EVALUAR 19.1. Con sus palabras, describa por qué la clase es la unidad razonable más pequeña para probar dentro  de un sistema OO. 19Pressman(437-452).indd   45119Pressman(437-452).indd   451 21/1/10   10:58:3621/1/10   10:58:36