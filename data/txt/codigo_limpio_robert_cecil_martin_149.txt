FileNotFoundException : public List<RecordedGrip> retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName); stream.close(); } catch (FileNotFoundException e) { throw new StorageException(“retrieval error”, e); } return new ArrayList<RecordedGrip>(); } Ahora que hemos definido el ámbito con una estructura  try-catch , podemos usar TDD para diseñar el resto de la lógica necesaria. Dicha lógica se añade entre la creación de  FileInputStream  y el cierre, y podemos pretender que no pasa nada incorrecto. Intente crear pruebas que fuercen las excepciones, para después añadir al controlador un comportamiento que satisfaga dichas pruebas. De este modo primero creará el ámbito de transacción del bloque  try  y podrá mantener la naturaleza de transacción del ámbito. Usar excepciones sin comprobar El debate ha terminado. Durante años, los programadores de Java han debatido las ventajas y los problemas de las excepciones comprobadas. Cuando aparecieron en la primera versión de Java, parecían una gran idea. La firma de todos los métodos enumeraría todas las excepciones que se podían pasar a su invocador. Es más, estas excepciones formaban parte del tipo del método. El código no se compilaría si la firma no coincidía con lo que el código iba a hacer. En aquel momento, pensábamos que las excepciones comprobadas eran una gran idea y sí, ofrecían ciertas ventajas. Sin embargo, ahora es evidente que no se necesitan para crear  software  robusto. C# carece de excepciones comprobadas y, a pesar de los intentos, C++ tampoco, como sucede en Python o Ruby. Y en todos estos lenguajes se puede crear  software  robusto. Por ello, debemos decidir si las excepciones comprobadas valen su precio. ¿Qué precio? El precio de las excepciones comprobadas es un 150