notifyall() void - object put(object key, object value) object - map putall(map t) void - map remove(object key) object - map size() int - map tostring() string - object values() collection - map wait() void - object wait(long timeout) void - object wait(long timeout, int nanos) void - object figura 8.1. los métodos de map si nuestra aplicación necesita un mapa de sensor , comprobará que los sensores se definen de esta forma: map sensors = new hashmap(); tras ello, cuando otra parte del código necesite acceder a sensor, vemos este código: sensor s = (sensor)sensors.get(sensorid); no lo vemos una sola vez, sino repetidamente a lo largo del código. el cliente de este código es responsable de obtener un objeto de map y convertirlo al tipo correcto. funciona, pero no es código limpio. además, este código no cuenta su historia como debería. la legibilidad del código se podría mejorar mediante el uso de genéricos, como se indica a continuación: map<sensor> sensors = new hashmap<sensor>(); … sensor s = sensors.get(sensorid); sin embargo, esto no soluciona el problema de que map<sensor> ofrezca más prestaciones de las que necesitamos o deseamos. al pasar una instancia de map<sensor> en el sistema, significa que habrá muchos puntos que corregir si la interfaz de map cambia. seguramente piense que son cambios improbables, pero recuerde que se han producido al añadir compatibilidad con genéricos en java 5. sin duda hemos visto sistemas que impiden el uso de genéricos debido a la gran cantidad de cambios necesarios para compensar el uso liberal de map . una forma más limpia de usar map sería la siguiente. a ningún usuario 161