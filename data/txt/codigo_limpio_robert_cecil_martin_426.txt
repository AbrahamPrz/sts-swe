Evitar la espera circular Es el enfoque más habitual para impedir el bloqueo mutuo. En la mayoría de sistemas, basta con una sencilla convención acordada entre ambas partes. En el ejemplo anterior del subproceso 1 que quiere tanto el recurso 1 como el 2, y el subproceso 2 que desea tanto el recurso 2 como el 1, al forzar a ambos subprocesos a que asignen los recursos en el mismo orden se imposibilita la espera circular. En general, si todos los subprocesos pueden acordar un orden global de los recursos y si todos asignan los recursos en ese orden, el bloqueo mutuo es imposible. Pero como todas las estrategias, también se pueden producir problemas: El orden de adquisición puede no corresponderse al orden de uso; por tanto, un recurso adquirido al inicio puede que no se use hasta el final. Esto puede bloquear recursos más tiempo de lo estrictamente necesario. En ocasiones no se puede imponer un orden de adquisición de recursos. Si el ID del segundo recurso proviene de una operación realizada en el primero, ese orden no es factible. Por tanto, existen varias formas de evitar el bloqueo mutuo. Algunas provocan inanición, mientras que otras usan la CPU en exceso y reducen la capacidad de respuesta. ¡ TANSTAAFL ! [122] El aislamiento de la parte relacionada con subprocesos de su solución para permitir ajustes y experimentación es una forma de aprender a determinar las estrategias óptimas. Probar código con múltiples subprocesos ¿Cómo se puede crear una prueba que demuestre que el siguiente código no es correcto? 01: public class ClassWithThreadingProblem { 02: int nextId; 03: 427