664 PARTE CUATRO  ADMINISTRACIÓN DE PROYECTOS DE SOFTWARE Ingeniería hacia adelante. En un mundo ideal, las aplicaciones se reconstruirían usando un  “motor de reingeniería” automático. El programa antiguo se alimentaría en el motor , se anali- zaría, se reestructuraría y luego se regeneraría de manera que mostrara los mejores aspectos  de la calidad del software. A corto plazo es improbable que tal “motor” aparezca, pero los pro-veedores introdujeron herramientas que proporcionan un subconjunto limitado de dichas capa-cidades y que abordan dominios de aplicación específicos (por ejemplo, aplicaciones que se implementan usando un sistema de base de datos específico). Más importante, dichas herra-mientas de reingeniería se vuelven cada vez más sofisticadas. La ingeniería hacia adelante no sólo recupera información de diseño del software existente,  sino que también usa esta información para alterar o reconstituir el sistema existente con la intención de mejorar su calidad global. En la mayoría de los casos, el software sometido a rein-geniería vuelve a implementar la función del sistema existente y también añade nuevas funcio-nes y/o mejora el rendimiento global.  29.6 I NGENIERÍA  INVERSA La ingeniería inversa conjura una imagen de la “rendija mágica”. Usted alimenta en la rendija un archivo fuente sin documentar, diseñado de manera fortuita, y del otro lado sale una descrip-ción y documentación completas del diseño para el programa de cómputo. Por desgracia, la rendija mágica no existe. La ingeniería inversa puede extraer información de diseño a partir del código fuente, pero el nivel de abstracción, la completitud de la documentación, el grado en el que las herramientas y un analista humano trabajan en conjunto, y la direccionalidad del pro-ceso son enormemente variables. El nivel de abstracción de un proceso de ingeniería inversa y las herramientas usadas para  efectuarla tienen que ver con la sofisticación de la información de diseño que puede extraerse del código fuente. De manera ideal, el nivel de abstracción debe ser tan alto como sea posible, es decir, el proceso de ingeniería inversa debe ser capaz de inferir representaciones de diseño procedimental (una abstracción de bajo nivel), información de estructura de programa y datos (un nivel de abstracción un poco más alto), modelos de objeto, modelos de datos y/o flujo de control (un nivel de abstracción relativamente alto) y modelos de relación de entidad (un nivel de abstracción alto). Conforme aumenta el nivel de abstracción se proporciona información que permitirá facilitar la comprensión del programa. La completitud de un proceso de ingeniería inversa se refiere al nivel de detalle que se pro- porciona en un nivel de abstracción. En la mayoría de los casos, la completitud disminuye con-forme aumenta el nivel de abstracción. Por ejemplo, dada una lista de código fuente, es relati-vamente sencillo desarrollar una representación de diseño procedimental completa. También pueden inferirse representaciones de diseño arquitectónico simples, pero es mucho más difícil desarrollar un conjunto completo de diagramas o modelos UML. La completitud mejora en proporción directa a la cantidad de análisis realizado por la per- sona que efectúa la ingeniería inversa. La interactividad tiene que ver con el grado en el que el ser humano se “integra” con las herramientas automatizadas para crear un proceso de ingenie-ría inversa efectivo. En la mayoría de los casos, conforme aumenta el nivel de abstracción, la interactividad debe aumentar o decaerá la completitud. Si la direccionalidad del proceso de ingeniería inversa es de una vía, toda la información ex- traída del código fuente se proporciona al ingeniero de software que luego puede usarla, durante cualquier actividad de mantenimiento. Si la direccionalidad es de dos vías, la información se alimenta a una herramienta de reingeniería que intenta reestructurar o regenerar el programa antiguo. 29Pressman(655-674).indd   66429Pressman(655-674).indd   664 26/1/10   17:33:0126/1/10   17:33:01