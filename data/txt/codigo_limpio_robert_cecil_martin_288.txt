throw e; } return true; } private void setIntArg( ArgumentMarshaler m ) throws ArgsException { currentArgument++; String parameter = null; try { parameter = args[currentArgument]; m .set(parameter); } catch (ArrayIndexOutOfBoundsException e) { errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (ArgsException e) { errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw e; } } private void setStringArg( ArgumentMarshaler m ) throws ArgsException { currentArgument++; try { m .set(args[currentArgument]); } catch (ArrayIndexOutOfBoundsException e) { errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } Ya podía eliminar las tres asignaciones antiguas. Primero, debía cambiar la función  getBoolean  de: public boolean getBoolean(char arg) { Args.ArgumentMarshaler am = booleanArgs.get(arg); return am != null && (Boolean) am.get(); } a: public boolean getBoolean(char arg) { Args.ArgumentMarshaler am = marshalers.get(arg); boolean b = false; try { b  = am != null && (Boolean) am.get(); } catch (ClassCastException e) { b = false; } return b; } Este último cambio puede parecer sorprendente. ¿Por qué de repente decidí enfrentarme a  ClassCastException ? Por tener una serie de pruebas de 289