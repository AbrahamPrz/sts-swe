throw e; } return true; } private void setintarg( argumentmarshaler m ) throws argsexception { currentargument++; string parameter = null; try { parameter = args[currentargument]; m .set(parameter); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_integer; throw new argsexception(); } catch (argsexception e) { errorparameter = parameter; errorcode = errorcode.invalid_integer; throw e; } } private void setstringarg( argumentmarshaler m ) throws argsexception { currentargument++; try { m .set(args[currentargument]); } catch (arrayindexoutofboundsexception e) { errorcode = errorcode.missing_string; throw new argsexception(); } } ya podía eliminar las tres asignaciones antiguas. primero, debía cambiar la función getboolean de: public boolean getboolean(char arg) { args.argumentmarshaler am = booleanargs.get(arg); return am != null && (boolean) am.get(); } a: public boolean getboolean(char arg) { args.argumentmarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null && (boolean) am.get(); } catch (classcastexception e) { b = false; } return b; } este último cambio puede parecer sorprendente. ¿por qué de repente decidí enfrentarme a classcastexception ? por tener una serie de pruebas de 289