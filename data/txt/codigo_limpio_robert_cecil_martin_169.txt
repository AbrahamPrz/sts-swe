desechable que creábamos para asegurarnos de que nuestros programas funcionaban. Escribíamos clases y métodos, y después código  ad hoc  para probarlos, lo que implicaba algún tipo de programa controlador que nos permitiera interactuar manualmente con el programa que habíamos escrito. Recuerdo crear un programa de C++ para un sistema incrustado de tiempo real a mediados de la década de 1990. El programa era un sencillo temporizador con la siguiente firma: void Timer::ScheduleCommand(Command* theCommand, int milliseconds) La idea era sencilla; el método  execute  de  Command  se ejecutaba en un nuevo subproceso tras el número especificado de milisegundos. El problema era cómo probarlo. Confeccioné un sencillo programa controlador que escuchaba al teclado. Cada vez que se introducía un carácter, se programaba un comando que escribía el mismo carácter cinco segundos después. Introduje una rítmica melodía en el teclado y esperé a que se reprodujera en pantalla cinco segundos después: «I… want-a-girl… just… like-the-girl-who-marr… ied… dear… old… dad.» Incluso tarareé la melodía mientras pulsaba la tecla, y la volví a cantar cuando aparecieron los puntos en la pantalla. Ésa fue mi prueba. Cuando vi que funcionaba y se lo mostré a mis compañeros, me deshice del código de prueba. Como he afirmado, nuestra profesión ha evolucionado mucho. Ahora crearía una prueba que garantizara el funcionamiento de hasta el más mínimo detalle del código. Aislaría el código del sistema operativo en lugar de invocar las funciones estándar de temporización. Las imitaría para tener control total sobre el tiempo. Programaría comandos que definieran indicadores Booleanos y avanzaría el tiempo, para observar los indicadores y asegurarme de que pasaran de  false  a  true  al cambiar el tiempo al valor correcto. Cuando superara una serie de pruebas, comprobaría que fueran adecuadas para todo el que tuviera que trabajar con el código. Me aseguraría de comprobar las pruebas y el código en el mismo paquete. Sí, hemos 170