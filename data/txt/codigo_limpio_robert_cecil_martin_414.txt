Las dependencias entre métodos pueden afectar al código concurrente El siguiente ejemplo es una forma de añadir dependencias entre métodos: public class IntegerIterator implements Iterator<Integer> private Integer nextValue = 0; public synchronized boolean hasNext() { return nextValue < 100000; } public synchronized Integer next() { if (nextValue == 100000) throw new IteratorPastEndException(); return nextValue++; } public synchronized Integer getNextValue() { return nextValue; } } Veamos otro código que usa  IntegerIterator : IntegerIterator iterator = new IntegerIterator(); while(iterator.hasNext()) { int nextValue = iterator.next(); // hacer algo con nextValue } Si un subproceso ejecuta este código no habrá problemas. ¿Qué sucede si dos subprocesos intentan compartir una misma instancia de  IntegerIterator para procesar el valor que reciba cada uno pero cada elemento de la lista sólo se procesa una vez? En la mayoría de los casos, no hay consecuencias negativas; los subprocesos comparten la lista, procesan los elementos devueltos por el iterador y se detienen cuando éste termina. Sin embargo, existe la posibilidad de que al final de la iteración los dos subprocesos interfieran entre ellos y provoquen que uno supere el final del iterador y se genere una excepción. El problema es el siguiente: El subproceso 1 pregunta  hasNext() , que devuelve  true . El subproceso 1 se evita y el subproceso 2 realiza la misma pregunta, que sigue siendo  true . Tras ello, el subproceso 2 invoca  next() , que devuelve un valor, como era de esperar, pero como efecto secundario 415