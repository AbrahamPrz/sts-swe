411CAPÍTULO 18PRUEBA DE APLICACIONES CONVENCIONALES CONCEPTOS  CLAVE   análisis de valor de frontera . . . . . . . . . . . . . 425 complejidad ciclomática  . . . . 417entornos especializados. . . . 429gráfico de flujo  . . . . . . . . . . 415matrices de grafo  . . . . . . . . 420métodos de prueba basados en gráficos  . . . . . . . . . . . . . 423 partición de equivalencia  . . . 425patrones. . . . . . . . . . . . . . . 433prueba basada en modelo  . . 429prueba de arreglo ortogonal . . . . . . . . . . . . . . 426 prueba de caja blanca  . . . . . 414prueba de caja negra . . . . . . 423prueba de estructura de control . . . . . . . . . . . . . . 420 prueba de ruta básica  . . . . . 414 ¿Qué es? Una vez generado el código fuente,  el software debe probarse para descubrir (y corregir) tantos errores como sea posible antes de entregarlo al cliente. La meta es diseñar una  serie de casos de prueba que tengan una alta probabili-dad de encontrar errores; ¿pero cómo? Ahí es donde entran en escena las técnicas de prueba de software. Dichas técnicas proporcionan lineamientos sistemáticos para diseñar pruebas que: 1) revisen la lógica interna y las interfaces de todo componente de software y 2) revisen los dominios de entrada y salida del programa para descubrir errores en el funcionamiento, comportamiento y rendi-miento del programa. ¿Quién lo hace? Durante las primeras etapas del proceso,  un ingeniero de software realiza todas las pruebas. Sin embargo, conforme avanza el proceso, pueden involucrar-se especialistas en pruebas. ¿Por qué es importante? Las revisiones y otras acciones  SQA pueden y deben descubrir errores, pero no son sufi-cientes. Cada vez que el programa se ejecuta, ¡el cliente lo prueba! Por tanto, tiene que ejecutarse el programa antes de que llegue al cliente, con la intención específica de encontrar y remover todos los errores. Para encontrar el mayor número posible de éstos, las pruebas deben reali-zarse de manera sistemática y deben diseñarse casos de prueba usando técnicas sistematizadas. ¿Cuáles son los pasos? Para aplicaciones convenciona- les, el software se prueba desde dos perspectivas diferen-tes: 1) la lógica de programa interno se revisa usando técnicas de diseño de casos de prueba de “caja blanca” y 2) los requerimientos de software se revisan usando técni-cas de diseño de casos de prueba de “caja negra”. El uso de casos auxilia en el diseño de pruebas para descubrir errores de validación del software. En todo caso, la inten-ción es encontrar el máximo número de errores con la mínima cantidad de esfuerzo y tiempo. ¿Cuál es el producto final?  Se diseña y documenta un  conjunto de casos de prueba elaborados para revisar la lógica interna, las interfaces, las colaboraciones de com-ponentes y los requerimientos externos; se definen los resultados esperados y se registran los resultados reales. ¿Cómo me aseguro de que lo hice bien? Cuando se  realizan pruebas, cambia el punto de vista. ¡Intente con ahínco “romper” el software! Diseñe casos de prueba en forma sistemática y revise minuciosamente los casos de prueba creados. Además, puede evaluar la cobertura de la prueba y rastrear las actividades de detección de errores. UNA  MIRADA   RÁPIDALas pruebas presentan una interesante anomalía para los ingenieros de software, quienes  por naturaleza son personas constructivas. Las pruebas requieren que el desarrollador deseche nociones preconcebidas sobre lo “correcto” del software recién desarrollado y  luego trabajen duro para diseñar casos de prueba a fin de “romper” el software. Beizer [Bei90] describe esta situación de manera efectiva cuando afirma: Existe el mito de que no habría errores que pescar si fuésemos realmente buenos en programación. Si  realmente nos pudiéramos concentrar, si todo mundo usara programación estructurada, diseño des-cendente... entonces no habría errores. Ése es el mito. Hay errores, dice el mito, porque somos malos en lo que hacemos; y si lo somos, deberíamos sentirnos culpables por ello. Por tanto, la aplicación de pruebas y el diseño de casos de prueba es una admisión del fracaso, que inspira una buena dosis de culpa. Y el tedio de las pruebas es un justo castigo por nuestros errores. ¿El castigo por qué? ¿Por ser humanos? ¿Culpa por qué? ¿Por fracasar en lograr la perfección inhumana? ¿Por no distinguir entre lo que otro programador piensa y lo que dice? ¿Por no poder ser telépatas? ¿Por no resolver problemas de comunicación humana a los que se les ha dado la vuelta... durante siglos? ¿Las pruebas deben inspirar culpa? ¿Las pruebas son realmente destructivas? La respuesta a  estas preguntas es: “¡No!” En este capítulo se estudian técnicas para el diseño de casos de prueba de software para  aplicaciones convencionales. Este diseño se enfoca en un conjunto de técnicas para la creación de casos de prueba que satisfacen los objetivos de prueba globales y las estrategias de pruebas que se estudiaron en el capítulo 17. 18Pressman(411-436).indd   41118Pressman(411-436).indd   411 21/1/10   10:58:5221/1/10   10:58:52