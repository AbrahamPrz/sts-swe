excepción común: LocalPort port = new LocalPort(12); try { port.open(); } catch (PortDeviceFailure e) { reportError(e); logger.log(e.getMessage(), e); } finally { … } Nuestra clase  LocalPort  es un simple envoltorio que captura y traduce excepciones generadas por la clase  ACMEPort : public class LocalPort { private ACMEPort innerPort; public LocalPort(int portNumber) { innerPort = new ACMEPort(portNumber); } public void open() { try { innerPort.open(); } catch (DeviceResponseException e) { throw new PortDeviceFailure(e); } catch (ATM1212UnlockedException e) { throw new PortDeviceFailure(e); } catch (GMXError e) { throw new PortDeviceFailure(e); } } … } Los envoltorios como el definido para  ACMEPort  pueden ser muy útiles. De hecho, es recomendable envolver API de terceros. Al hacerlo, se minimizan las dependencias: puede cambiar a otra biblioteca diferente sin apenas problemas y el envoltorio también facilita imitar invocaciones de terceros cuando se prueba el código. Una última ventaja es que no estamos limitados a las decisiones de diseño de API de un determinado fabricante. Puede definir una API que le resulte cómoda. En el ejemplo anterior, definimos un único tipo de excepción para el fallo de puertos y podemos escribir un código mucho más limpio. A menudo, una única clase de excepción es suficiente para una zona concreta del código. La información enviada con la excepción puede distinguir los errores. Use clases diferentes 153