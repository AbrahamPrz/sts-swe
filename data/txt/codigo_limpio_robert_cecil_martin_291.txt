private string[] args; private boolean valid = true; private set<character> unexpectedarguments = new treeset<character>(); private map<character, argumentmarshaler> marshalers = new hashmap<character, argumentmarshaler>(); private set<character> argsfound = new hashset<character>(); private int currentargument; private char errorargumentid = ‘\0’; private string errorparameter = “tilt”; private errorcode errorcode = errorcode.ok; private enum errorcode { ok, missing_string, missing_integer, invalid_integer, unexpected_argument} public args(string schema, string[] args) throws parseexception { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws parseexception { if (schema.length() == 0 && args.length == 0) return true; parseschema(); try { parsearguments(); } catch (argsexception e) { } return valid; } private boolean parseschema() throws parseexception { for (string element : schema.split(“,”)) { if (element.length() > 0) { string trimmedelement = element.trim(); parseschemaelement(trimmedelement); } } return true; } private void parseschemaelement(string element) throws parseexception { char elementid = element.charat(0); string elementtail = element.substring(1); validateschemaelementid(elementid); if (isbooleanschemaelement(elementtail)) marshalers.put(elementid, new booleanargumentmarshaler()); else if (isstringschemaelement(elementtail)) marshalers.put(elementid, new stringargumentwarshaler()); else if (isintegerschemaelement(elementtail)) { marshalers.put(elementid, new integerargumentmarshaler()); } else { throw new parseexception(string.format( 292