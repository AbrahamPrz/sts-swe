métodos abstractos. no estamos obligados a implementar siempre la instrucción switch/case de la misma forma, pero las clases base hacen que las clases concretas implementen métodos abstractos. g28: encapsular condicionales la lógica booleana es difícil de entender sin necesidad de verla en el contexto de una instrucción if o while . extraiga funciones que expliquen el cometido de la condicional. por ejemplo: if (shouldbedeleted(timer)) es preferible a if (timer.hasexpired() && !timer.isrecurrent()) g29: evitar condicionales negativas las condicionales negativas son más difíciles de entender que las positivas. por ello, siempre que sea posible, debe expresar las condiciones como positivas. por ejemplo: if (buffer.shouldcompact()) es preferible a if (!buffer.shouldnotcompact()) g30: las funciones sólo deben hacer una cosa es tentador crear funciones con varias secciones que realicen una serie de operaciones. este tipo de funciones hacen más de una cosa y deben convertirse en funciones de menor tamaño, cada una para una cosa . por ejemplo: public void pay() { for (employee e : employees) { if (e.ispayday()) { money pay = e .calculatepay(); e.deliverpay(pay); } } 381