métodos abstractos. No estamos obligados a implementar siempre la instrucción  switch/case  de la misma forma, pero las clases base hacen que las clases concretas implementen métodos abstractos. G28: Encapsular condicionales La lógica booleana es difícil de entender sin necesidad de verla en el contexto de una instrucción  if  o  while . Extraiga funciones que expliquen el cometido de la condicional. Por ejemplo: if (shouldBeDeleted(timer)) es preferible a if (timer.hasExpired() && !timer.isRecurrent()) G29: Evitar condicionales negativas Las condicionales negativas son más difíciles de entender que las positivas. Por ello, siempre que sea posible, debe expresar las condiciones como positivas. Por ejemplo: if (buffer.shouldCompact()) es preferible a if (!buffer.shouldNotCompact()) G30: Las funciones sólo deben hacer una cosa Es tentador crear funciones con varias secciones que realicen una serie de operaciones. Este tipo de funciones hacen más de  una cosa  y deben convertirse en funciones de menor tamaño, cada una para  una cosa . Por ejemplo: public void pay() { for (Employee e : employees) { if (e.isPayday()) { Money pay = e .calculatePay(); e.deliverPay(pay); } } 381