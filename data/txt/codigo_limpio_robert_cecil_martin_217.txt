BankImpl , y así sucesivamente. El código es abundante y complejo, incluso para este sencillo caso [59] . El uso de una de las bibliotecas de manipulación de  bytes  es igualmente complicado. El volumen y la complejidad de este código son dos de los inconvenientes de los  proxies . Dificultan la creación de código limpio. Además, los proxies no ofrecen un mecanismo para especificar puntos de ejecución globales del sistema, imprescindibles para una verdadera solución AOP [60] . Estructuras AOP Java puras Afortunadamente, gran parte del código predefinido de proxy se puede procesar de forma automática mediante herramientas. Los proxies se usan internamente en varias estructuras de Java como Spring AOP y JBoss AOP, para implementar aspectos en Java [61] . En Spring, se crea la lógica empresarial en forma de POJO, específicos de su dominio. No dependen de estructuras empresariales (ni de otros dominios). Por tanto, son conceptualmente más sencillos y más fáciles de probar. Su relativa simplicidad garantiza que se implementen correctamente las correspondientes historias y el mantenimiento y evolución del código en historias futuras. La infraestructura necesaria de la aplicación, incluidos aspectos transversales como persistencia, transacciones, seguridad, almacenamiento en caché y recuperación ante fallos, se incorpora por medio de archivos de configuración declarativos o API. En muchos casos, se especifican aspectos de bibliotecas Spring o JBoss, en los que la estructura controla el uso de proxies de Java o bibliotecas de código de  bytes  de forma transparente al usuario. Estas declaraciones controlan el contenedor de inyección de dependencias, que crea instancias de los principales objetos y las conecta bajo demanda. El Listado 11-4 muestra un fragmento tipo de un archivo de configuración de Spring V2.5, app.xml [62] . 218