constantes a una interfaz y después accede a las mismas heredando dicha interfaz. fíjese en el siguiente código: public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } ¿de dónde salen las constantes tenths_per_week y overtime_rate ? puede que provengan de la clase employee ; comprobémoslo: public abstract class employee implements payrollconstants { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } no, de ahí no. ¿entonces de dónde? fíjese atentamente en la clase employee . implementa payrollconstants . public interface payrollconstants { public static final int tenths_per_week = 400; public static final double overtime_rate = 1.5; } es horrible. las constantes se ocultan en la parte superior de la jerarquía de herencia. no use la herencia para burlar las reglas de ámbito del lenguaje. use una importación estática: import static payrollconstants.*; public class hourlyemployee extends employee { private int tenthsworked; private double hourlyrate; public money calculatepay() { int straighttime = math.min(tenthsworked, tenths_per_week); int overtime = tenthsworked - straighttime; return new money( hourlyrate * (tenthsworked + overtime_rate * overtime) ); } … } 389