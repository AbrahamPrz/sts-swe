 Desde luego, todos los componentes podrían tener una falla de diseño común y, además,  producir todos la misma respuesta (equivocada). Al usar unidades de hardware que tienen una especificación común, pero que se diseñan y construyen por fabricantes diferentes, se reducen de modo común las posibilidades de tal falla. Se supone que es mínima la probabi-lidad de que diferentes equipos cometan el mismo error de diseño o de fabricación. Un enfoque similar puede usarse para software tolerante a fallas, donde n versiones diversas de un sistema de software se ejecutan en paralelo (Avizienis, 1985; Avizienis, 1995). Este enfoque a la tolerancia a fallas de software, que se ilustra en la figura 13.7, se usa en sistemas de señalización ferroviaria, sistemas de aeronaves y sistemas de protec-ción de reactores. Al usar una especificación común, el mismo sistema de software se implementa por algunos equipos. Dichas versiones se ejecutan en computadoras separadas. Sus salidas se comparan al usar un sistema de votación, y se rechazan las salidas inconsistentes o las que no se producen en tiempo. Al menos tres versiones del sistema deben estar disponibles, de modo que dos versiones tienen que ser consistentes en caso de una falla individual. La programación de n-versión suele ser menos costosa que las arquitecturas de auto-verificación, en sistemas para los cuales se requiere un alto nivel de disponibilidad. Sin embargo, todavía se requieren muchos equipos diferentes para desarrollar diferentes versiones del software. Esto conduce a costos de desarrollo de software muy elevados. Como resultado, este enfoque sólo se usa en sistemas donde no resulta práctico ofrecer un sistema de protección que proteja contra fallas críticas de seguridad.  13.3.4 Diversidad de software Todas las arquitecturas anteriores tolerantes a fallas se apoyan en la diversidad del software para lograr tolerancia a fallas. Esto se basa en la suposición de que son independientes las implementaciones diversas de la misma especificación (o una parte de la especificación, para sistemas de protección). No deben incluir errores comunes y, además, no fallarán A1 A2 A3Selector de salidaEntrada Figura 13.6 Redundancia  modular triple Versión 1 Versión 2 Versión 3Selector de salida Gestor de fallas n versiones de softwareResultado acordadoEntrada Figura 13.7 Programación  de n-versión13.3 ■ Arquitecturas de sistemas confiables  353 M13_SOMMERVILLE_INGENIERIA_1ED_SE_341-365.indd   353M13_SOMMERVILLE_INGENIERIA_1ED_SE_341-365.indd   353 3/18/11   4:59:13 PM3/18/11   4:59:13 PM