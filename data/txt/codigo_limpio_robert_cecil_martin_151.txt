excepciones. Mencione la operación fallida y el tipo de fallo. Si guarda registros en su aplicación, incluya información suficiente para poder registrar el error en la cláusula  catch . Definir clases de excepción de acuerdo a las necesidades del invocador Existen varias formas de clasificar los errores. Podemos hacerlo por origen (¿provienen de uno u otro componente?) o por tipo (¿son fallos del dispositivo, de la red o errores de programación?). Sin embargo, al definir clases de excepción en una aplicación, debemos preocuparnos principalmente en  cómo se capturan . Veamos un pobre ejemplo de clasificación de excepciones. Es una instrucción  try-catch-finally  de la invocación de una biblioteca de terceros. Abarca todas las excepciones que las invocaciones pueden generar: ACMEPort port = new ACMEPort(12); try { port.open(); } catch (DeviceResponseException e) { reportPortError(e); logger.log{“Device response exception”, e); } catch (ATM1212UnlockedException e) { reportPortError(e); logger.log(“Unlock exception”, e); } catch (GMXError e) { reportPortError(e); logger.log(“Device response exception”); } finally { … } Esta instrucción contiene elementos duplicados, algo que no debería sorprendernos. En muchos casos de control de excepciones, el trabajo que realizamos es relativamente estándar independientemente de la causa real. Debemos registrar un error y asegurarnos de poder continuar. En este caso, como sabemos que el trabajo es el mismo independientemente de la excepción, podemos simplificar el código si incluimos la API invocada y nos aseguramos de que devuelve un tipo de 152