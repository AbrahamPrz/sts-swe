en una única instancia; de hecho, sería un error tener que usar  new Math().max(a,b)  o incluso  a.max(b) . Todos los datos que usa  max  provienen de sus dos argumentos, no de un objeto. Además, es prácticamente imposible que queramos que  Math.max  sea polimórfico. Sin embargo, en ocasiones creamos funciones estáticas que no deben serlo. Fíjese en este ejemplo: HourlyPayCalculator.calculatePay(employee, overtimeRate). De nuevo, parece una función estática razonable. No opera en un objeto concreto y recibe todos los datos de sus argumentos. Sin embargo, existe la posibilidad de que queramos que sea polimórfica. Puede que queramos implementar distintos algoritmos para calcular el precio de la hora, como por ejemplo.  OvertimeHourlyPayCalculator  y StraightTimeHourlyPayCalculator . En este caso, la función no debe ser estática. Debería ser una función miembro no estática de  Employee . Por lo general, debe decantarse por métodos no estáticos. En caso de duda, convierta la función en no estática. Si realmente quiere que una función sea estática, asegúrese de que nunca querrá que sea polimórfica. G19: Usar variables explicativas Kent Beck escribió sobre este tema en su magnífico libro  Smalltalk Best Practice Patterns [111]  y, más recientemente en  Implementation Patterns [112] . Una de las técnicas más completas para que un programa sea legible consiste en dividir los cálculos en valores intermedios almacenados en variables con nombres descriptivos. Fíjese en este ejemplo de FitNesse: Matcher match = headerPattern.matcher(line); if(match.find()) { String key = match.group(1); String value = match.group(2); headers.put(key.toLowercase(), value); } El simple uso de variables explicativas ilustra con claridad que el primer grupo comparado es la  clave  y el segundo es el  valor . Es complicado excederse en esta técnica. Por lo general, es mejor tener más variables explicativas que menos. Es sorprendente que un módulo opaco 374