assertequals(“expected:<a> but was:<null>”, failure); } public void testcomparisonerrorwithexpectednull() { string failure= new comparisoncompactor(0, null, “a”).compact(null); assertequals(“expected:<null> but was:<a>”, failure); } public void testcomparisonerrorwithexpectednullcontext() { string failure= new comparisoncompactor(2, null, “a”).compact(null); assertequals(“expected:<null> but was:<a>”, failure); } public void testbug609972() { string failure= new comparisoncompactor(10, “s&p500”, “0”).compact(null); assertequals(“expected:<[s&p50]0> but was:<[]0>”, failure); } } realicé un análisis de alcance de código en comparisoncompactor con estas pruebas. el código se cubre en un 100 por 100. cada línea, cada instrucción if y cada bucle for se ejecuta con las pruebas. de este modo sé que el código funciona y sus autores me merecen el mayor de los respetos. el código comparisoncompactor se reproduce en el listado 15-2. examínelo. creo que lo encontrará bien distribuido, razonablemente expresivo y estructuralmente sencillo. cuando termine, lo diseccionaremos. listado 15-2 comparisoncompactor.java (original). package junit.framework; public class comparisoncompactor { private static final string ellipsis = “…”; private static final string delta_end = “]”; private static final string delta_start = “[”; private int fcontextlength; private string fexpected; private string factual; private int fprefix; private int fsuffix; public comparisoncompactor(int contextlength, string expected, string actual) { fcontextlength = contextlength; fexpected = expected; 324