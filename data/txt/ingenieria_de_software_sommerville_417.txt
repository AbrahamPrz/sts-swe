400  Capítulo 15 ■ Garantía de confiabilidad y seguridad el análisis basado en errores comunes puede ser muy efectivo en términos de costo.  Zheng y sus colaboradores (2006) estudiaron el uso de análisis estático contra una gran base de código en C y C++, y descubrieron que el 90% de los errores en los programas resultaron de 10 tipos de error característico. 2. Comprobación de error definido por el usuario En este enfoque, los usuarios del analizador estático pueden definir patrones de error, por lo tanto, se extienden los tipos de error que pueden detectarse. Esto es particularmente útil en situaciones donde debe mantenerse el orden (por ejemplo, el método A siempre debe llamarse antes que el método B). Con el tiempo, una organización podrá recolectar información acerca de bugs comunes que ocurren en sus programas y extender el análisis estático para destacar dichos errores. 3. Comprobación de aserción Éste es el enfoque más general y poderoso del análisis estático. Los desarrolladores incluyen aserciones formales (escritas con frecuencia en comentarios estilizados) en su programa, las cuales establecen relaciones que deben sostenerse en dicho punto del programa. Por ejemplo, puede incluirse una aserción que establezca que el valor de cierta variable debe encontrarse en el rango x..y. El analizador ejecuta simbólicamente el código y destaca los enunciados donde no se sostiene la aserción. Este enfoque se usa en analizadores como Splint (Evans y Larochelle, 2002) y el SPARK Examiner (Croxford y Sutton, 2006).  El análisis estático es efectivo para encontrar errores en programas, pero por lo regular genera un gran número de “falsos positivos”. Se trata de secciones de código donde no hay errores, pero donde las reglas del analizador estático detectaron un potencial de error. Es posible reducir el número de falsos positivos al agregar más información al programa en forma de aserciones; desde luego, esto requiere trabajo adicional por parte del desarro-llador del código. Habrá que trabajar en el tamizado de esos falsos positivos antes de que el código en sí pueda comprobarse en busca de errores. El análisis estático es particularmente valioso para la comprobación de seguridad (Evans y Larochelle, 2002). Los analizadores estáticos pueden ajustarse a la medida para comprobar problemas bien conocidos, como desbordamiento de buffer o entradas sin verificar, que podrían aprovechar los atacantes. La comprobación de problemas bien conocidos es efectiva para mejorar la seguridad, pues la mayoría de los intrusos basan sus ataques en vulnerabilidades comunes. Como se estudiará más adelante, las pruebas de seguridad son difíciles porque los ata-cantes a menudo actúan de forma inesperada, lo que dificulta que los examinadores pue-dan anticipar su comportamiento. Es posible que los analizadores estáticos incorporen experiencia de seguridad detallada que esté fuera del alcance de los examinadores, y que ésta se aplique antes de que un programa se ponga a prueba. Si se usa análisis estático, se pueden hacer afirmaciones que sean verdaderas para todas las posibles ejecuciones del programa, no sólo para aquellas que correspondan a las pruebas que ya se diseñaron. Muchas organizaciones utilizan ahora el análisis estático de manera rutinaria en sus procesos de desarrollo de software. Microsoft introdujo el análisis estático en el desa-rrollo de controladores de dispositivo (Larus et al., 2003), donde las fallas de programa podrían tener un efecto serio. Ahora extendió el enfoque a través de un rango mucho más amplio de su software para buscar problemas de seguridad, así como errores que afectan la fiabilidad del programa (Ball et al., 2006). Muchos sistemas críticos, incluidos siste-mas de aviones y nucleares, se someten por lo regular a análisis estático como parte del proceso V&V (Nguyen y Ourghanlian, 2003). M15_SOMMERVILLE_INGENIERIA_1ED_SE_393-422.indd   400M15_SOMMERVILLE_INGENIERIA_1ED_SE_393-422.indd   400 3/18/11   5:01:19 PM3/18/11   5:01:19 PM